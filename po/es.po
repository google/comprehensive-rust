msgid ""
msgstr ""
"Project-Id-Version: Comprehensive Rust ü¶Ä\n"
"POT-Creation-Date: 2023-09-11\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.3.2\n"

#: src/SUMMARY.md:4 src/index.md:1
msgid "Welcome to Comprehensive Rust ü¶Ä"
msgstr "Te damos la bienvenida a Comprehensive Rust ü¶Ä"

#: src/SUMMARY.md:5 src/running-the-course.md:1
msgid "Running the Course"
msgstr "Desarrollo del curso"

#: src/SUMMARY.md:6 src/running-the-course/course-structure.md:1
msgid "Course Structure"
msgstr "Estructura del curso"

#: src/SUMMARY.md:7 src/running-the-course/keyboard-shortcuts.md:1
msgid "Keyboard Shortcuts"
msgstr "Combinaciones de teclas"

#: src/SUMMARY.md:8 src/running-the-course/translations.md:1
msgid "Translations"
msgstr "Traducciones"

#: src/SUMMARY.md:9 src/cargo.md:1
msgid "Using Cargo"
msgstr "Usando Cargo"

#: src/SUMMARY.md:10
msgid "Rust Ecosystem"
msgstr "Ecosistema Rust"

#: src/SUMMARY.md:11
msgid "Code Samples"
msgstr "Ejemplos de C√≥digo"

#: src/SUMMARY.md:12
msgid "Running Cargo Locally"
msgstr "Ejecutar Cargo a nivel local"

#: src/SUMMARY.md:15
msgid "Day 1: Morning"
msgstr "D√≠a 1: ma√±ana"

#: src/SUMMARY.md:19 src/SUMMARY.md:79 src/SUMMARY.md:134 src/SUMMARY.md:192
#: src/SUMMARY.md:218 src/SUMMARY.md:268
msgid "Welcome"
msgstr "Te damos la bienvenida"

#: src/SUMMARY.md:20 src/welcome-day-1/what-is-rust.md:1
msgid "What is Rust?"
msgstr "¬øQu√© es Rust?"

#: src/SUMMARY.md:21 src/hello-world.md:1
msgid "Hello World!"
msgstr "¬°Hola, mundo!"

#: src/SUMMARY.md:22 src/hello-world/small-example.md:1
msgid "Small Example"
msgstr "Peque√±o ejemplo"

#: src/SUMMARY.md:23 src/why-rust.md:1
msgid "Why Rust?"
msgstr "¬øPor qu√© Rust?"

#: src/SUMMARY.md:24 src/why-rust/compile-time.md:1
msgid "Compile Time Guarantees"
msgstr "Garant√≠as en Tiempo de Compilaci√≥n"

#: src/SUMMARY.md:25 src/why-rust/runtime.md:1
msgid "Runtime Guarantees"
msgstr "Garant√≠as en Runtime (Tiempo de Ejecuci√≥n)"

#: src/SUMMARY.md:26 src/why-rust/modern.md:1
msgid "Modern Features"
msgstr "Funcionalidades Modernas"

#: src/SUMMARY.md:27 src/basic-syntax.md:1
msgid "Basic Syntax"
msgstr "Sintaxis b√°sica"

#: src/SUMMARY.md:28 src/basic-syntax/scalar-types.md:1
msgid "Scalar Types"
msgstr "Tipos escalares"

#: src/SUMMARY.md:29 src/basic-syntax/compound-types.md:1
msgid "Compound Types"
msgstr "Tipos compuestos"

#: src/SUMMARY.md:30 src/basic-syntax/references.md:1
msgid "References"
msgstr "Referencias"

#: src/SUMMARY.md:31 src/basic-syntax/references-dangling.md:1
msgid "Dangling References"
msgstr "Referencias colgantes"

#: src/SUMMARY.md:32 src/basic-syntax/slices.md:1
msgid "Slices"
msgstr "Slices"

#: src/SUMMARY.md:33
msgid "String vs str"
msgstr "String o str"

#: src/SUMMARY.md:34 src/basic-syntax/functions.md:1
msgid "Functions"
msgstr "Funciones"

#: src/SUMMARY.md:35 src/basic-syntax/rustdoc.md:1
msgid "Rustdoc"
msgstr "Rustdoc"

#: src/SUMMARY.md:36 src/SUMMARY.md:102 src/basic-syntax/methods.md:1
#: src/methods.md:1
msgid "Methods"
msgstr "M√©todos"

#: src/SUMMARY.md:37
msgid "Overloading"
msgstr "Sobrecarga"

#: src/SUMMARY.md:38 src/SUMMARY.md:71 src/SUMMARY.md:105 src/SUMMARY.md:125
#: src/SUMMARY.md:154 src/SUMMARY.md:184 src/SUMMARY.md:211 src/SUMMARY.md:232
#: src/SUMMARY.md:260 src/SUMMARY.md:282 src/SUMMARY.md:303
#: src/exercises/android/morning.md:1 src/exercises/bare-metal/morning.md:1
#: src/exercises/bare-metal/afternoon.md:1
#: src/exercises/concurrency/morning.md:1
#: src/exercises/concurrency/afternoon.md:1
msgid "Exercises"
msgstr "Ejercicios"

#: src/SUMMARY.md:39 src/exercises/day-1/implicit-conversions.md:1
msgid "Implicit Conversions"
msgstr "Conversiones Impl√≠citas"

#: src/SUMMARY.md:40
msgid "Arrays and for Loops"
msgstr "Arrays y Loops for"

#: src/SUMMARY.md:42
msgid "Day 1: Afternoon"
msgstr "D√≠a 1: Tarde"

#: src/SUMMARY.md:44 src/SUMMARY.md:295 src/control-flow.md:1
msgid "Control Flow"
msgstr "Control de Flujo"

#: src/SUMMARY.md:45 src/control-flow/blocks.md:1
msgid "Blocks"
msgstr "Bloques"

#: src/SUMMARY.md:46
msgid "if expressions"
msgstr "expresiones if"

#: src/SUMMARY.md:47
msgid "for expressions"
msgstr "expresiones for"

#: src/SUMMARY.md:48
msgid "while expressions"
msgstr "expresiones while"

#: src/SUMMARY.md:49
msgid "break & continue"
msgstr "break y continue"

#: src/SUMMARY.md:50
msgid "loop expressions"
msgstr "Expresiones loop"

#: src/SUMMARY.md:52 src/basic-syntax/variables.md:1
msgid "Variables"
msgstr "Variables"

#: src/SUMMARY.md:53 src/basic-syntax/type-inference.md:1
msgid "Type Inference"
msgstr "Inferencia de tipos"

#: src/SUMMARY.md:54
msgid "static & const"
msgstr "static y const"

#: src/SUMMARY.md:55 src/basic-syntax/scopes-shadowing.md:1
msgid "Scopes and Shadowing"
msgstr "√Åmbitos y _Shadowing_"

#: src/SUMMARY.md:56 src/enums.md:1
msgid "Enums"
msgstr ""

#: src/SUMMARY.md:57 src/enums/variant-payloads.md:1
msgid "Variant Payloads"
msgstr "Payloads Variantes"

#: src/SUMMARY.md:58 src/enums/sizes.md:1
msgid "Enum Sizes"
msgstr "Tama√±os de Enum"

#: src/SUMMARY.md:60 src/control-flow/novel.md:1
#, fuzzy
msgid "Novel Control Flow"
msgstr "Control de Flujo"

#: src/SUMMARY.md:61
msgid "if let expressions"
msgstr "expresiones if let"

#: src/SUMMARY.md:62
msgid "while let expressions"
msgstr "expresiones while let"

#: src/SUMMARY.md:63
msgid "match expressions"
msgstr "expresiones match"

#: src/SUMMARY.md:65 src/pattern-matching.md:1
msgid "Pattern Matching"
msgstr "Correspondencia de Patrones"

#: src/SUMMARY.md:66 src/pattern-matching/destructuring-enums.md:1
msgid "Destructuring Enums"
msgstr "Desestructurando Enums"

#: src/SUMMARY.md:67 src/pattern-matching/destructuring-structs.md:1
msgid "Destructuring Structs"
msgstr "Desestructurando Structs"

#: src/SUMMARY.md:68 src/pattern-matching/destructuring-arrays.md:1
msgid "Destructuring Arrays"
msgstr "Desestructurando Arrays"

#: src/SUMMARY.md:69 src/pattern-matching/match-guards.md:1
msgid "Match Guards"
msgstr "Guardas de Match"

#: src/SUMMARY.md:72 src/exercises/day-1/luhn.md:1
#: src/exercises/day-1/solutions-afternoon.md:3
msgid "Luhn Algorithm"
msgstr "Algoritmo de Luhn"

#: src/SUMMARY.md:73
#, fuzzy
msgid "Pattern Matching (TBD)"
msgstr "Correspondencia de Patrones"

#: src/SUMMARY.md:75
msgid "Day 2: Morning"
msgstr "D√≠a 2: Ma√±ana"

#: src/SUMMARY.md:81 src/memory-management.md:1
msgid "Memory Management"
msgstr "Manejo de Memoria"

#: src/SUMMARY.md:82
msgid "Stack vs Heap"
msgstr ""

#: src/SUMMARY.md:83
msgid "Stack Memory"
msgstr "Memoria de la Pila (_Stack_)"

#: src/SUMMARY.md:84 src/memory-management/manual.md:1
msgid "Manual Memory Management"
msgstr "Manejo Manual de Memoria"

#: src/SUMMARY.md:85 src/memory-management/scope-based.md:1
msgid "Scope-Based Memory Management"
msgstr "Manejo de Memoria basado en Scope (√°mbitos)"

#: src/SUMMARY.md:86
msgid "Garbage Collection"
msgstr "Recolecci√≥n de memoria residual"

#: src/SUMMARY.md:87
msgid "Rust Memory Management"
msgstr "Manejo de la Memoria en Rust"

#: src/SUMMARY.md:88 src/ownership.md:1
msgid "Ownership"
msgstr "Propiedad (_Ownership_)"

#: src/SUMMARY.md:89 src/ownership/move-semantics.md:1
msgid "Move Semantics"
msgstr "Sem√°ntica de movimiento"

#: src/SUMMARY.md:90 src/ownership/moved-strings-rust.md:1
msgid "Moved Strings in Rust"
msgstr "Cadenas movidas en Rust"

#: src/SUMMARY.md:91
msgid "Double Frees in Modern C++"
msgstr "Double free en c√≥digo C++ moderno"

#: src/SUMMARY.md:92 src/ownership/moves-function-calls.md:1
msgid "Moves in Function Calls"
msgstr "Movimientos en llamadas de funci√≥n"

#: src/SUMMARY.md:93 src/ownership/copy-clone.md:1
msgid "Copying and Cloning"
msgstr "Copiar y clonar"

#: src/SUMMARY.md:94 src/ownership/borrowing.md:1
msgid "Borrowing"
msgstr "Pr√©stamos (_Borrowing_)"

#: src/SUMMARY.md:95 src/ownership/shared-unique-borrows.md:1
msgid "Shared and Unique Borrows"
msgstr "Pr√©stamos compartidos y √∫nicos"

#: src/SUMMARY.md:96 src/ownership/lifetimes.md:1
msgid "Lifetimes"
msgstr "Tiempos de vida"

#: src/SUMMARY.md:97 src/ownership/lifetimes-function-calls.md:1
msgid "Lifetimes in Function Calls"
msgstr "Tiempos de Vida en Llamadas a Funci√≥n"

#: src/SUMMARY.md:98 src/ownership/lifetimes-data-structures.md:1
msgid "Lifetimes in Data Structures"
msgstr "Tiempos de vida en estructuras de datos"

#: src/SUMMARY.md:99 src/structs.md:1
msgid "Structs"
msgstr "Estructuras (_Structs_)"

#: src/SUMMARY.md:100 src/structs/tuple-structs.md:1
msgid "Tuple Structs"
msgstr "Estructuras de tuplas"

#: src/SUMMARY.md:101 src/structs/field-shorthand.md:1
msgid "Field Shorthand Syntax"
msgstr "Sintaxis abreviada de campos"

#: src/SUMMARY.md:103 src/methods/receiver.md:1
msgid "Method Receiver"
msgstr "Receptor de m√©todo"

#: src/SUMMARY.md:104 src/SUMMARY.md:166 src/SUMMARY.md:281
#: src/methods/example.md:1 src/concurrency/shared_state/example.md:1
msgid "Example"
msgstr "Ejemplo"

#: src/SUMMARY.md:106 src/exercises/day-2/book-library.md:1
msgid "Storing Books"
msgstr "Almacenar libros"

#: src/SUMMARY.md:107 src/exercises/day-2/health-statistics.md:1
msgid "Health Statistics"
msgstr "Estad√≠sticas de salud"

#: src/SUMMARY.md:109
msgid "Day 2: Afternoon"
msgstr "D√≠a 2: tarde"

#: src/SUMMARY.md:111 src/std.md:1
msgid "Standard Library"
msgstr "Biblioteca est√°ndar"

#: src/SUMMARY.md:112
msgid "Option and Result"
msgstr "Option y Result"

#: src/SUMMARY.md:113 src/std/string.md:1
msgid "String"
msgstr "String"

#: src/SUMMARY.md:114
msgid "Vec"
msgstr "Vec"

#: src/SUMMARY.md:115
msgid "HashMap"
msgstr "HashMap"

#: src/SUMMARY.md:116
msgid "Box"
msgstr "Box"

#: src/SUMMARY.md:117
msgid "Recursive Data Types"
msgstr "Tipos de datos recursivos"

#: src/SUMMARY.md:118 src/std/box-niche.md:1
msgid "Niche Optimization"
msgstr "Optimizaci√≥n de la Memoria"

#: src/SUMMARY.md:119
msgid "Rc"
msgstr "Rc"

#: src/SUMMARY.md:120
msgid "Cell/RefCell"
msgstr ""

#: src/SUMMARY.md:121 src/modules.md:1
msgid "Modules"
msgstr "M√≥dulos"

#: src/SUMMARY.md:122 src/modules/visibility.md:1
msgid "Visibility"
msgstr "Visibilidad"

#: src/SUMMARY.md:123 src/modules/paths.md:1
msgid "Paths"
msgstr "Rutas"

#: src/SUMMARY.md:124 src/modules/filesystem.md:1
msgid "Filesystem Hierarchy"
msgstr "Jerarqu√≠a del sistema de archivos"

#: src/SUMMARY.md:126 src/exercises/day-2/iterators-and-ownership.md:1
msgid "Iterators and Ownership"
msgstr "Iteradores y Ownership (Propiedad)"

#: src/SUMMARY.md:127 src/exercises/day-2/strings-iterators.md:1
#: src/exercises/day-2/solutions-afternoon.md:3
msgid "Strings and Iterators"
msgstr "Cadenas e Iteradores"

#: src/SUMMARY.md:130
msgid "Day 3: Morning"
msgstr "D√≠a 3: Ma√±ana"

#: src/SUMMARY.md:135 src/generics.md:1
msgid "Generics"
msgstr "Gen√©ricos"

#: src/SUMMARY.md:136 src/generics/data-types.md:1
msgid "Generic Data Types"
msgstr "Tipos de Datos Gen√©ricos"

#: src/SUMMARY.md:137 src/generics/methods.md:1
msgid "Generic Methods"
msgstr "M√©todos Gen√©ricos"

#: src/SUMMARY.md:138 src/generics/monomorphization.md:1
msgid "Monomorphization"
msgstr "Monomorfizaci√≥n"

#: src/SUMMARY.md:139 src/traits.md:1
msgid "Traits"
msgstr "Traits"

#: src/SUMMARY.md:140 src/traits/trait-objects.md:1
msgid "Trait Objects"
msgstr "Objetos Trait"

#: src/SUMMARY.md:141 src/traits/deriving-traits.md:1
msgid "Deriving Traits"
msgstr "Derivaci√≥n de Traits"

#: src/SUMMARY.md:142 src/traits/default-methods.md:1
msgid "Default Methods"
msgstr "M√©todos por Default"

#: src/SUMMARY.md:143 src/traits/trait-bounds.md:1
msgid "Trait Bounds"
msgstr "L√≠mites Trait (Bounds)"

#: src/SUMMARY.md:144
msgid "impl Trait"
msgstr "impl Trait"

#: src/SUMMARY.md:145 src/traits/important-traits.md:1
msgid "Important Traits"
msgstr "Traits Importantes"

#: src/SUMMARY.md:146
msgid "Iterator"
msgstr "Iteradores"

#: src/SUMMARY.md:147 src/traits/from-iterator.md:1
msgid "FromIterator"
msgstr "FromIterator"

#: src/SUMMARY.md:148
msgid "From and Into"
msgstr "From e Into"

#: src/SUMMARY.md:149
msgid "Read and Write"
msgstr "Read y Write"

#: src/SUMMARY.md:150
msgid "Drop"
msgstr ""

#: src/SUMMARY.md:151
msgid "Default"
msgstr ""

#: src/SUMMARY.md:152
msgid "Operators: Add, Mul, ..."
msgstr "Operadores: Add, Mul, ‚Ä¶."

#: src/SUMMARY.md:153
msgid "Closures: Fn, FnMut, FnOnce"
msgstr ""

#: src/SUMMARY.md:155 src/exercises/day-3/simple-gui.md:1
#: src/exercises/day-3/solutions-morning.md:3
msgid "A Simple GUI Library"
msgstr "Una Biblioteca GUI sencilla"

#: src/SUMMARY.md:156 src/exercises/day-3/solutions-morning.md:175
msgid "Points and Polygons"
msgstr "Puntos y Pol√≠gonos"

#: src/SUMMARY.md:158
msgid "Day 3: Afternoon"
msgstr "D√≠a 3: Tarde"

#: src/SUMMARY.md:160 src/error-handling.md:1
msgid "Error Handling"
msgstr "Manejo de Errores"

#: src/SUMMARY.md:161 src/error-handling/panics.md:1
msgid "Panics"
msgstr ""

#: src/SUMMARY.md:162
msgid "Catching Stack Unwinding"
msgstr "Catching Stack Unwinding"

#: src/SUMMARY.md:163
msgid "Structured Error Handling"
msgstr "Manejo de Errores Estructurado"

#: src/SUMMARY.md:164
msgid "Propagating Errors with ?"
msgstr "Propagaci√≥n de Errores con ?"

#: src/SUMMARY.md:165 src/error-handling/converting-error-types.md:1
#: src/error-handling/converting-error-types-example.md:1
msgid "Converting Error Types"
msgstr "Conversi√≥n de Tipos de Errores"

#: src/SUMMARY.md:167 src/error-handling/deriving-error-enums.md:1
msgid "Deriving Error Enums"
msgstr "Derivaci√≥n de Enums de Error"

#: src/SUMMARY.md:168 src/error-handling/dynamic-errors.md:1
msgid "Dynamic Error Types"
msgstr "Tipos de Errores Din√°micos"

#: src/SUMMARY.md:169 src/error-handling/error-contexts.md:1
msgid "Adding Context to Errors"
msgstr "A√±adir Contexto a los Errores"

#: src/SUMMARY.md:170 src/testing.md:1
msgid "Testing"
msgstr "Probando"

#: src/SUMMARY.md:171 src/testing/unit-tests.md:1
msgid "Unit Tests"
msgstr "Pruebas Unitarias"

#: src/SUMMARY.md:172 src/testing/test-modules.md:1
msgid "Test Modules"
msgstr "M√≥dulos de Pruebas"

#: src/SUMMARY.md:173 src/testing/doc-tests.md:1
msgid "Documentation Tests"
msgstr "Pruebas de Documentaci√≥n"

#: src/SUMMARY.md:174 src/testing/integration-tests.md:1
msgid "Integration Tests"
msgstr "Pruebas de Integraci√≥n"

#: src/SUMMARY.md:175 src/bare-metal/useful-crates.md:1
msgid "Useful crates"
msgstr "Crates √ötiles"

#: src/SUMMARY.md:176 src/unsafe.md:1
msgid "Unsafe Rust"
msgstr "Unsafe Rust"

#: src/SUMMARY.md:177 src/unsafe/raw-pointers.md:1
msgid "Dereferencing Raw Pointers"
msgstr "Dereferenciaci√≥n de Punteros Sin Formato"

#: src/SUMMARY.md:178 src/unsafe/mutable-static-variables.md:1
msgid "Mutable Static Variables"
msgstr "Variables Est√°ticas Mutables"

#: src/SUMMARY.md:179 src/unsafe/unions.md:1
msgid "Unions"
msgstr "Uniones"

#: src/SUMMARY.md:180 src/unsafe/calling-unsafe-functions.md:1
msgid "Calling Unsafe Functions"
msgstr "Llamar Funciones Unsafe (Inseguras)"

#: src/SUMMARY.md:181 src/unsafe/writing-unsafe-functions.md:1
msgid "Writing Unsafe Functions"
msgstr "Escribir Funciones Unsafe (Inseguras)"

#: src/SUMMARY.md:182
msgid "Extern Functions"
msgstr "Funciones Externas"

#: src/SUMMARY.md:183 src/unsafe/unsafe-traits.md:1
msgid "Implementing Unsafe Traits"
msgstr "Implementaci√≥n de Traits Unsafe (Inseguras) "

#: src/SUMMARY.md:185 src/exercises/day-3/safe-ffi-wrapper.md:1
#: src/exercises/day-3/solutions-afternoon.md:3
msgid "Safe FFI Wrapper"
msgstr "Envoltorio de FFI Seguro"

#: src/SUMMARY.md:188 src/SUMMARY.md:258 src/bare-metal/android.md:1
msgid "Android"
msgstr ""

#: src/SUMMARY.md:193 src/android/setup.md:1
msgid "Setup"
msgstr "Configurar"

#: src/SUMMARY.md:194 src/android/build-rules.md:1
msgid "Build Rules"
msgstr "Reglas de Compilaci√≥n (Build)"

#: src/SUMMARY.md:195
msgid "Binary"
msgstr "Binarios"

#: src/SUMMARY.md:196
msgid "Library"
msgstr "Biblioteca"

#: src/SUMMARY.md:197 src/android/aidl.md:1
msgid "AIDL"
msgstr ""

#: src/SUMMARY.md:198
msgid "Interface"
msgstr "Interfaz"

#: src/SUMMARY.md:199
msgid "Implementation"
msgstr "Implementaci√≥n"

#: src/SUMMARY.md:200
msgid "Server"
msgstr "Servidor"

#: src/SUMMARY.md:201 src/android/aidl/deploy.md:1
msgid "Deploy"
msgstr "Despliegue"

#: src/SUMMARY.md:202
msgid "Client"
msgstr "Cliente"

#: src/SUMMARY.md:203 src/android/aidl/changing.md:1
msgid "Changing API"
msgstr "Cambio de API"

#: src/SUMMARY.md:204 src/SUMMARY.md:248 src/android/logging.md:1
#: src/bare-metal/aps/logging.md:1
msgid "Logging"
msgstr "Almacenamiento de registros"

#: src/SUMMARY.md:205 src/android/interoperability.md:1
msgid "Interoperability"
msgstr "Interoperabilidad"

#: src/SUMMARY.md:206
msgid "With C"
msgstr "Con C"

#: src/SUMMARY.md:207
msgid "Calling C with Bindgen"
msgstr "Llamar a C con Bindgen"

#: src/SUMMARY.md:208
msgid "Calling Rust from C"
msgstr "Llamar a Rust desde C"

#: src/SUMMARY.md:209 src/android/interoperability/cpp.md:1
msgid "With C++"
msgstr "Con C++"

#: src/SUMMARY.md:210
msgid "With Java"
msgstr "Con Java"

#: src/SUMMARY.md:214
msgid "Bare Metal: Morning"
msgstr "Bare Metal: ma√±ana"

#: src/SUMMARY.md:219
msgid "no_std"
msgstr "no_std"

#: src/SUMMARY.md:220
msgid "A Minimal Example"
msgstr "Un Peque√±o Ejemplo"

#: src/SUMMARY.md:221
msgid "alloc"
msgstr "alloc"

#: src/SUMMARY.md:222 src/bare-metal/microcontrollers.md:1
msgid "Microcontrollers"
msgstr "Microcontroladores"

#: src/SUMMARY.md:223 src/bare-metal/microcontrollers/mmio.md:1
msgid "Raw MMIO"
msgstr "MMIO sin procesar"

#: src/SUMMARY.md:224
msgid "PACs"
msgstr "PAC"

#: src/SUMMARY.md:225
msgid "HAL Crates"
msgstr "Crates HAL"

#: src/SUMMARY.md:226
msgid "Board Support Crates"
msgstr "Crates de Soporte de Placa"

#: src/SUMMARY.md:227
msgid "The Type State Pattern"
msgstr "El Patr√≥n de Tipo de Estado"

#: src/SUMMARY.md:228
msgid "embedded-hal"
msgstr "embedded-hal"

#: src/SUMMARY.md:229
msgid "probe-rs, cargo-embed"
msgstr "probe-rs, cargo-embed"

#: src/SUMMARY.md:230 src/bare-metal/microcontrollers/debugging.md:1
msgid "Debugging"
msgstr "Depuraci√≥n"

#: src/SUMMARY.md:231 src/SUMMARY.md:251
msgid "Other Projects"
msgstr "Otros proyectos"

#: src/SUMMARY.md:233 src/exercises/bare-metal/compass.md:1
#: src/exercises/bare-metal/solutions-morning.md:3
msgid "Compass"
msgstr "Br√∫jula"

#: src/SUMMARY.md:235
msgid "Bare Metal: Afternoon"
msgstr "Bare Metal: tarde"

#: src/SUMMARY.md:237
msgid "Application Processors"
msgstr "Procesadores de aplicaciones"

#: src/SUMMARY.md:238 src/bare-metal/aps/entry-point.md:1
msgid "Getting Ready to Rust"
msgstr "Iniciaci√≥n a Rust"

#: src/SUMMARY.md:239
msgid "Inline Assembly"
msgstr "Ensamblador en l√≠nea"

#: src/SUMMARY.md:240
msgid "MMIO"
msgstr "MMIO"

#: src/SUMMARY.md:241
msgid "Let's Write a UART Driver"
msgstr "Escribir un controlador UART"

#: src/SUMMARY.md:242
msgid "More Traits"
msgstr "M√°s traits"

#: src/SUMMARY.md:243
msgid "A Better UART Driver"
msgstr "Un controlador UART mejor"

#: src/SUMMARY.md:244 src/bare-metal/aps/better-uart/bitflags.md:1
msgid "Bitflags"
msgstr "Bitflags"

#: src/SUMMARY.md:245
msgid "Multiple Registers"
msgstr "Varios registros"

#: src/SUMMARY.md:246 src/bare-metal/aps/better-uart/driver.md:1
msgid "Driver"
msgstr "Conductor"

#: src/SUMMARY.md:247 src/SUMMARY.md:249
msgid "Using It"
msgstr "C√≥mo usarlo"

#: src/SUMMARY.md:250 src/bare-metal/aps/exceptions.md:1
msgid "Exceptions"
msgstr "Excepciones"

#: src/SUMMARY.md:252
msgid "Useful Crates"
msgstr "Crates √∫tiles"

#: src/SUMMARY.md:253
msgid "zerocopy"
msgstr "zerocopy"

#: src/SUMMARY.md:254
msgid "aarch64-paging"
msgstr "aarch64-paging"

#: src/SUMMARY.md:255
msgid "buddy_system_allocator"
msgstr "buddy_system_allocator"

#: src/SUMMARY.md:256
msgid "tinyvec"
msgstr "tinyvec"

#: src/SUMMARY.md:257
msgid "spin"
msgstr "girar"

#: src/SUMMARY.md:259 src/bare-metal/android/vmbase.md:1
msgid "vmbase"
msgstr "vmbase"

#: src/SUMMARY.md:261
msgid "RTC Driver"
msgstr "Controlador RTC"

#: src/SUMMARY.md:264
msgid "Concurrency: Morning"
msgstr "Concurrencia: ma√±ana"

#: src/SUMMARY.md:269 src/concurrency/threads.md:1
msgid "Threads"
msgstr "Hilos"

#: src/SUMMARY.md:270 src/concurrency/scoped-threads.md:1
msgid "Scoped Threads"
msgstr "Hilos con √°mbito"

#: src/SUMMARY.md:271 src/concurrency/channels.md:1
msgid "Channels"
msgstr "Canales"

#: src/SUMMARY.md:272 src/concurrency/channels/unbounded.md:1
msgid "Unbounded Channels"
msgstr "Canales sin l√≠mites"

#: src/SUMMARY.md:273 src/concurrency/channels/bounded.md:1
msgid "Bounded Channels"
msgstr "Canales delimitados"

#: src/SUMMARY.md:274
msgid "Send and Sync"
msgstr "Send y Sync"

#: src/SUMMARY.md:274
msgid "Send"
msgstr "Enviar"

#: src/SUMMARY.md:274
msgid "Sync"
msgstr "Sincronizar"

#: src/SUMMARY.md:277 src/concurrency/send-sync/examples.md:1
msgid "Examples"
msgstr "Ejemplos"

#: src/SUMMARY.md:278 src/concurrency/shared_state.md:1
msgid "Shared State"
msgstr "Estado compartido"

#: src/SUMMARY.md:279
msgid "Arc"
msgstr "Arco"

#: src/SUMMARY.md:280
msgid "Mutex"
msgstr "Mutex"

#: src/SUMMARY.md:283 src/SUMMARY.md:304
#: src/exercises/concurrency/dining-philosophers.md:1
#: src/exercises/concurrency/solutions-morning.md:3
msgid "Dining Philosophers"
msgstr "La cena de los fil√≥sofos"

#: src/SUMMARY.md:284 src/exercises/concurrency/link-checker.md:1
msgid "Multi-threaded Link Checker"
msgstr "Comprobador de enlaces multihilo"

#: src/SUMMARY.md:286
msgid "Concurrency: Afternoon"
msgstr "Concurrencia: tarde"

#: src/SUMMARY.md:288
msgid "Async Basics"
msgstr "Conceptos b√°sicos de Async"

#: src/SUMMARY.md:289
msgid "async/await"
msgstr "async / await"

#: src/SUMMARY.md:290 src/async/futures.md:1
msgid "Futures"
msgstr "Future"

#: src/SUMMARY.md:291 src/async/runtimes.md:1
msgid "Runtimes"
msgstr "Runtimes (Tiempos de Ejecuci√≥n)"

#: src/SUMMARY.md:292 src/async/runtimes/tokio.md:1
msgid "Tokio"
msgstr "Tokio"

#: src/SUMMARY.md:293 src/exercises/concurrency/link-checker.md:126
#: src/async/tasks.md:1 src/exercises/concurrency/chat-app.md:143
msgid "Tasks"
msgstr "Tasks"

#: src/SUMMARY.md:294 src/async/channels.md:1
msgid "Async Channels"
msgstr "Canales as√≠ncronos"

#: src/SUMMARY.md:296 src/async/control-flow/join.md:1
msgid "Join"
msgstr "Unirme"

#: src/SUMMARY.md:297 src/async/control-flow/select.md:1
msgid "Select"
msgstr "Seleccionar"

#: src/SUMMARY.md:298
msgid "Pitfalls"
msgstr "Inconvenientes"

#: src/SUMMARY.md:299
msgid "Blocking the Executor"
msgstr "Bloqueo del ejecutor"

#: src/SUMMARY.md:300 src/async/pitfalls/pin.md:1
msgid "Pin"
msgstr "Fijar"

#: src/SUMMARY.md:301 src/async/pitfalls/async-traits.md:1
msgid "Async Traits"
msgstr "Traits as√≠ncronos"

#: src/SUMMARY.md:302 src/async/pitfalls/cancellation.md:1
msgid "Cancellation"
msgstr "Cancelaci√≥n"

#: src/SUMMARY.md:305 src/exercises/concurrency/chat-app.md:1
#: src/exercises/concurrency/solutions-afternoon.md:119
msgid "Broadcast Chat Application"
msgstr "Aplicaci√≥n de chat de difusi√≥n"

#: src/SUMMARY.md:308
msgid "Final Words"
msgstr "Conclusiones"

#: src/SUMMARY.md:312 src/thanks.md:1
msgid "Thanks!"
msgstr "Gracias."

#: src/SUMMARY.md:313
msgid "Other Resources"
msgstr "Otros recursos"

#: src/SUMMARY.md:314 src/credits.md:1
msgid "Credits"
msgstr "Cr√©ditos"

#: src/SUMMARY.md:317 src/exercises/solutions.md:1
msgid "Solutions"
msgstr "Soluciones"

#: src/SUMMARY.md:322
msgid "Day 1 Morning"
msgstr "D√≠a 1: ma√±ana"

#: src/SUMMARY.md:323
msgid "Day 1 Afternoon"
msgstr "D√≠a 1: tarde"

#: src/SUMMARY.md:324
msgid "Day 2 Morning"
msgstr "D√≠a 2: ma√±ana"

#: src/SUMMARY.md:325
msgid "Day 2 Afternoon"
msgstr "D√≠a 2: tarde"

#: src/SUMMARY.md:326
msgid "Day 3 Morning"
msgstr "D√≠a 3: ma√±ana"

#: src/SUMMARY.md:327
msgid "Day 3 Afternoon"
msgstr "D√≠a 3: tarde"

#: src/SUMMARY.md:328
msgid "Bare Metal Rust Morning"
msgstr "Rust Bare Metal: ma√±ana"

#: src/SUMMARY.md:329 src/exercises/bare-metal/solutions-afternoon.md:1
msgid "Bare Metal Rust Afternoon"
msgstr "Rust Bare Metal: tarde"

#: src/SUMMARY.md:330
msgid "Concurrency Morning"
msgstr "Concurrencia: ma√±ana"

#: src/SUMMARY.md:331
msgid "Concurrency Afternoon"
msgstr "Concurrencia: tarde"

#: src/index.md:3
msgid ""
"[![Build workflow](https://img.shields.io/github/actions/workflow/status/"
"google/comprehensive-rust/build.yml?style=flat-square)](https://github.com/"
"google/comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain) [!"
"[GitHub contributors](https://img.shields.io/github/contributors/google/"
"comprehensive-rust?style=flat-square)](https://github.com/google/"
"comprehensive-rust/graphs/contributors) [![GitHub stars](https://img.shields."
"io/github/stars/google/comprehensive-rust?style=flat-square)](https://github."
"com/google/comprehensive-rust/stargazers)"
msgstr ""

#: src/index.md:7
msgid ""
"This is a free Rust course developed by the Android team at Google. The "
"course covers the full spectrum of Rust, from basic syntax to advanced "
"topics like generics and error handling."
msgstr ""
"Este es un curso de Rust de tres d√≠as que ha desarrollado el equipo de "
"Android de Google. El curso abarca todo lo relacionado con Rust, desde la "
"sintaxis b√°sica hasta temas avanzados como los gen√©ricos y la gesti√≥n de "
"errores. Tambi√©n incluye contenidos espec√≠ficos de Android el √∫ltimo d√≠a."

#: src/index.md:11
msgid ""
"The latest version of the course can be found at <https://google.github.io/"
"comprehensive-rust/>. If you are reading somewhere else, please check there "
"for updates."
msgstr ""
"La √∫ltima versi√≥n del curso se puede encontrar en <https://google.github.io/"
"comprehensive-rust/>. Si lo est√°s leyendo en otro lugar, consulta all√≠ para "
"obtener actualizaciones."

#: src/index.md:15
msgid ""
"The goal of the course is to teach you Rust. We assume you don't know "
"anything about Rust and hope to:"
msgstr ""
"El objetivo del curso es ense√±arte Rust. Suponemos que no sabes nada sobre "
"Rust y esperamos lograr lo siguiente:"

#: src/index.md:18
msgid "Give you a comprehensive understanding of the Rust syntax and language."
msgstr "Darte un entendimiento comprensivo de la sintaxis y lenguaje Rust."

#: src/index.md:19
msgid "Enable you to modify existing programs and write new programs in Rust."
msgstr "Permitirte modificar programas de Rust y escribir otros nuevos."

#: src/index.md:20
msgid "Show you common Rust idioms."
msgstr "Brindarte idiom√°tica propia de Rust."

#: src/index.md:22
msgid "We call the first three course days Rust Fundamentals."
msgstr "Llamamos a los tres primeros d√≠as del curso Fundamentos de Rust."

#: src/index.md:24
msgid ""
"Building on this, you're invited to dive into one or more specialized topics:"
msgstr ""
"Bas√°ndonos en esto, te invitamos a profundizar en uno o m√°s temas "
"especializados:"

#: src/index.md:26
msgid ""
"[Android](android.md): a half-day course on using Rust for Android platform "
"development (AOSP). This includes interoperability with C, C++, and Java."
msgstr ""
"[Android](android.md): un curso de medio d√≠a sobre el uso de Rust en el "
"desarrollo de la plataforma Android (AOSP). En √©l se incluye la "
"interoperabilidad con C, C++ y Java."

#: src/index.md:28
msgid ""
"[Bare-metal](bare-metal.md): a whole-day class on using Rust for bare-metal "
"(embedded) development. Both microcontrollers and application processors are "
"covered."
msgstr ""
"[Bare Metal](bare-metal.md): una clase de un d√≠a sobre el uso de Rust para "
"el desarrollo bare-metal (insertado). Se tratar√°n tanto los "
"microcontroladores como los procesadores de aplicaciones."

#: src/index.md:31
msgid ""
"[Concurrency](concurrency.md): a whole-day class on concurrency in Rust. We "
"cover both classical concurrency (preemptively scheduling using threads and "
"mutexes) and async/await concurrency (cooperative multitasking using "
"futures)."
msgstr ""
"[Concurrencia](concurrency.md): una clase de un d√≠a sobre concurrencia en "
"Rust. Abordaremos tanto la concurrencia cl√°sica (programaci√≥n interrumpible "
"mediante hilos y exclusiones mutuas), como la concurrencia async / await "
"(multitarea cooperativa mediante traits future)."

#: src/index.md:37
msgid "Non-Goals"
msgstr "Objetivos que no trataremos"

#: src/index.md:39
msgid ""
"Rust is a large language and we won't be able to cover all of it in a few "
"days. Some non-goals of this course are:"
msgstr ""
"Rust es un lenguaje muy amplio y no podremos abarcarlo todo en unos pocos "
"d√≠as. Algunos de los objetivos que no se plantean en este curso son los "
"siguientes:"

#: src/index.md:42
msgid ""
"Learning how to develop macros: please see [Chapter 19.5 in the Rust Book]"
"(https://doc.rust-lang.org/book/ch19-06-macros.html) and [Rust by Example]"
"(https://doc.rust-lang.org/rust-by-example/macros.html) instead."
msgstr ""
"Aprender a desarrollar macros: consulta el [cap√≠tulo 19.5 del Libro de Rust ]"
"(https://doc.rust-lang.org/book/ch19-06-macros.html) y [Rust by Example]"
"(https://doc.rust-lang.org/rust-by-example/macros.html)."

#: src/index.md:46
msgid "Assumptions"
msgstr "Suposiciones"

#: src/index.md:48
msgid ""
"The course assumes that you already know how to program. Rust is a "
"statically-typed language and we will sometimes make comparisons with C and "
"C++ to better explain or contrast the Rust approach."
msgstr ""
"El curso presupone que ya sabes programar. Rust es un lenguaje est√°ticamente "
"tipado y, a veces, haremos comparaciones con C y C++ para explicarlo mejor o "
"contrastar nuestro enfoque."

#: src/index.md:52
msgid ""
"If you know how to program in a dynamically-typed language such as Python or "
"JavaScript, then you will be able to follow along just fine too."
msgstr ""
"Si sabes programar en un lenguaje din√°micamente tipado, como Python o "
"JavaScript, podr√°s seguir el ritmo sin problema."

#: src/index.md:57
msgid ""
"This is an example of a _speaker note_. We will use these to add additional "
"information to the slides. This could be key points which the instructor "
"should cover as well as answers to typical questions which come up in class."
msgstr ""
"Este es un ejemplo de una _nota del orador_. Las utilizaremos para a√±adir "
"informaci√≥n adicional a las diapositivas. Puede tratarse de puntos clave que "
"el instructor deber√≠a tratar, as√≠ como de respuestas a preguntas frecuentes "
"que surgen en clase."

#: src/running-the-course.md:3 src/running-the-course/course-structure.md:3
msgid "This page is for the course instructor."
msgstr "Esta p√°gina est√° dirigida al instructor del curso."

#: src/running-the-course.md:5
msgid ""
"Here is a bit of background information about how we've been running the "
"course internally at Google."
msgstr ""
"A continuaci√≥n, te ofrecemos informaci√≥n general sobre c√≥mo se ha "
"desarrollado el curso en Google."

#: src/running-the-course.md:8
msgid ""
"We typically run classes from 10:00 am to 4:00 pm, with a 1 hour lunch break "
"in the middle. This leaves 2.5 hours for the morning class and 2.5 hours for "
"the afternoon class. Note that this is just a recommendation: you can also "
"spend 3 hour on the morning session to give people more time for exercises. "
"The downside of longer session is that people can become very tired after 6 "
"full hours of class in the afternoon."
msgstr ""
"Normalmente, impartimos las clases de 10:00 a 16:00, con una pausa para "
"comer de una hora. Esto deja 2,5 horas para la clase de la ma√±ana y 2,5 "
"horas para la clase de la tarde. Ten en cuenta que esta es solo una "
"recomendaci√≥n: tambi√©n puedes dedicar 3 horas a la sesi√≥n de la ma√±ana para "
"dar a la gente m√°s tiempo para los ejercicios. El inconveniente de las "
"sesiones m√°s largas es que la gente puede cansarse mucho despu√©s de 6 horas "
"completas de clase por la tarde."

#: src/running-the-course.md:16
msgid "Before you run the course, you will want to:"
msgstr "Antes de impartir el curso, te recomdamos hacer lo siguiente:"

#: src/running-the-course.md:18
msgid ""
"Make yourself familiar with the course material. We've included speaker "
"notes to help highlight the key points (please help us by contributing more "
"speaker notes!). When presenting, you should make sure to open the speaker "
"notes in a popup (click the link with a little arrow next to \"Speaker "
"Notes\"). This way you have a clean screen to present to the class."
msgstr ""
"Familiar√≠zate con el material del curso. Hemos incluido notas del orador "
"para destacar los puntos clave (ay√∫danos a a√±adir m√°s notas de este tipo). "
"Cuando hagas una presentaci√≥n, aseg√∫rate de abrir las notas del orador en "
"una ventana emergente (haz clic en el enlace que tiene una peque√±a flecha "
"junto a \"Notas del orador\"). De esta manera, tendr√°s una pantalla "
"despejada para mostrar a la clase."

#: src/running-the-course.md:24
msgid ""
"Decide on the dates. Since the course takes at least three full days, we "
"recommend that you schedule the days over two weeks. Course participants "
"have said that they find it helpful to have a gap in the course since it "
"helps them process all the information we give them."
msgstr ""
"Decide bien las fechas. Dado que el curso dura al menos tres d√≠as completos, "
"te recomendamos que repartas los d√≠as a lo largo de dos semanas. Los "
"participantes del curso han dicho que les resulta √∫til hacer pausas durante "
"el curso, ya que les ayuda a procesar toda la informaci√≥n que les "
"proporcionamos."

#: src/running-the-course.md:29
msgid ""
"Find a room large enough for your in-person participants. We recommend a "
"class size of 15-25 people. That's small enough that people are comfortable "
"asking questions --- it's also small enough that one instructor will have "
"time to answer the questions. Make sure the room has _desks_ for yourself "
"and for the students: you will all need to be able to sit and work with your "
"laptops. In particular, you will be doing a lot of live-coding as an "
"instructor, so a lectern won't be very helpful for you."
msgstr ""
"Busca una sala con capacidad suficiente para los participantes presenciales. "
"Recomendamos una sala para entre 15 y 25 personas. Es el tama√±o ideal para "
"que los alumnos se sientan c√≥modos haciendo preguntas y para que el profesor "
"tenga tiempo de responderlas. Aseg√∫rate de que en la sala haya _mesas_ para "
"ti y para los alumnos: todos necesitar√©is sentaros y trabajar con vuestros "
"port√°tiles. Adem√°s, como instructor, programar√°s mucho en directo, por lo "
"que un atril no te resultar√° muy √∫til."

#: src/running-the-course.md:37
msgid ""
"On the day of your course, show up to the room a little early to set things "
"up. We recommend presenting directly using `mdbook serve` running on your "
"laptop (see the [installation instructions](https://github.com/google/"
"comprehensive-rust#building)). This ensures optimal performance with no lag "
"as you change pages. Using your laptop will also allow you to fix typos as "
"you or the course participants spot them."
msgstr ""
"El mismo d√≠a del curso, llega con antelaci√≥n a la clase para preparar todo "
"lo necesario. Te recomendamos que realices la presentaci√≥n directamente "
"desde `mdbook serve` en tu port√°til (consulta las \\[instrucciones de "
"instalaci√≥n\\]\\[3\\]). As√≠ conseguir√°s un rendimiento √≥ptimo y que no haya "
"demoras al pasar de una p√°gina a otra. Tambi√©n podr√°s corregir las erratas a "
"medida que t√∫ o los participantes del curso las detect√©is."

#: src/running-the-course.md:43
msgid ""
"Let people solve the exercises by themselves or in small groups. We "
"typically spend 30-45 minutes on exercises in the morning and in the "
"afternoon (including time to review the solutions). Make sure to ask people "
"if they're stuck or if there is anything you can help with. When you see "
"that several people have the same problem, call it out to the class and "
"offer a solution, e.g., by showing people where to find the relevant "
"information in the standard library."
msgstr ""
"Deja que los alumnos resuelvan los ejercicios por s√≠ mismos o en peque√±os "
"grupos. Solemos dedicar entre 30 y 45 minutos a los ejercicios por la ma√±ana "
"y por la tarde (incluido el tiempo para revisar las soluciones). Aseg√∫rate "
"de preguntar a los asistentes si les est√° costando hacerlo o si hay algo en "
"lo que puedas ayudarles. Cuando veas que varias personas tienen el mismo "
"problema, com√©ntalo delante de la clase y ofrece una soluci√≥n. Por ejemplo, "
"ens√©√±ales d√≥nde encontrar la informaci√≥n importante en la biblioteca "
"est√°ndar."

#: src/running-the-course.md:51
msgid ""
"That is all, good luck running the course! We hope it will be as much fun "
"for you as it has been for us!"
msgstr ""
"Eso es todo. ¬°Buena suerte con el curso! Esperamos que te diviertas tanto "
"como nosotros."

#: src/running-the-course.md:54
msgid ""
"Please [provide feedback](https://github.com/google/comprehensive-rust/"
"discussions/86) afterwards so that we can keep improving the course. We "
"would love to hear what worked well for you and what can be made better. "
"Your students are also very welcome to [send us feedback](https://github.com/"
"google/comprehensive-rust/discussions/100)!"
msgstr ""
"Despu√©s, [env√≠anos un comentario](https://github.com/google/comprehensive-"
"rust/discussions/86) para que podamos seguir mejorando  el curso. Estaremos "
"encantados de que nos cuentes qu√© aspectos destacar√≠as y qu√© se puede "
"mejorar. Tus alumnos tambi√©n pueden [enviarnos sus sugerencias](https://"
"github.com/google/comprehensive-rust/discussions/100)!"

#: src/running-the-course/course-structure.md:5
msgid "Rust Fundamentals"
msgstr "Fundamentos de Rust"

#: src/running-the-course/course-structure.md:7
msgid ""
"The first three days make up [Rust Fundaments](../welcome-day-1.md). The "
"days are fast paced and we cover a lot of ground:"
msgstr ""
"Los primeros tres d√≠as forman los [Fundamentos de Rust](../welcome-day-1."
"md). Los d√≠as son muy intensos y cubrimos mucho terreno:"

#: src/running-the-course/course-structure.md:10
msgid "Day 1: Basic Rust, syntax, control flow, creating and consuming values."
msgstr ""
"D√≠a 1: Rust B√°sico, sintaxis, control de flujo, creaci√≥n y consumo de "
"valores."

#: src/running-the-course/course-structure.md:11
msgid ""
"Day 2: Memory management, ownership, compound data types, and the standard "
"library."
msgstr ""
"D√≠a 2: Gesti√≥n de memoria, _ownership_ (propiedad), tipos de datos "
"compuestos y la biblioteca est√°ndar."

#: src/running-the-course/course-structure.md:12
msgid "Day 3: Generics, traits, error handling, testing, and unsafe Rust."
msgstr ""
"D√≠a 3: Gen√©ricos, _traits_, gesti√≥n de errores, pruebas y _unsafe_ "
"(inseguro) Rust."

#: src/running-the-course/course-structure.md:14
msgid "Deep Dives"
msgstr "Informaci√≥n m√°s detallada"

#: src/running-the-course/course-structure.md:16
msgid ""
"In addition to the 3-day class on Rust Fundamentals, we cover some more "
"specialized topics:"
msgstr ""
"Adem√°s de la clase de 3 d√≠as sobre los fundamentos de Rust, abordamos "
"algunos temas m√°s especializados:"

#: src/running-the-course/course-structure.md:19
msgid "Rust in Android"
msgstr "Rust en Android"

#: src/running-the-course/course-structure.md:21
msgid ""
"The [Rust in Android](../android.md) deep dive is a half-day course on using "
"Rust for Android platform development. This includes interoperability with "
"C, C++, and Java."
msgstr ""
"[Rust en Android](../android.md) es un curso de medio d√≠a sobre el uso de "
"Rust para el desarrollo de la plataforma Android. En √©l se incluye la "
"interoperabilidad con C, C++ y Java."

#: src/running-the-course/course-structure.md:25
msgid ""
"You will need an [AOSP checkout](https://source.android.com/docs/setup/"
"download/downloading). Make a checkout of the [course repository](https://"
"github.com/google/comprehensive-rust) on the same machine and move the `src/"
"android/` directory into the root of your AOSP checkout. This will ensure "
"that the Android build system sees the `Android.bp` files in `src/android/`."
msgstr ""
"Necesitar√°s [conseguir el AOSP](https://source.android.com/docs/setup/"
"download/downloading). Descarga el [repositorio del curso](https://github."
"com/google/comprehensive-rust) en el mismo ordenador y mueve el directorio "
"`src/android/` a la ra√≠z del AOSP. De esta forma, el sistema de compilaci√≥n "
"de Android ver√° los archivos `Android.bp` en `src/android/`."

#: src/running-the-course/course-structure.md:30
msgid ""
"Ensure that `adb sync` works with your emulator or real device and pre-build "
"all Android examples using `src/android/build_all.sh`. Read the script to "
"see the commands it runs and make sure they work when you run them by hand."
msgstr ""
"Aseg√∫rate que `adb sync` funciona con tu emulador o en un dispositivo f√≠sico "
"y haz pre-build en todos los ejemplos de Android usando `src/android/"
"build_all.sh`. Lee el script para ver los comandos que corren y aseg√∫rate "
"que funcionan cuando lo corres a mano."

#: src/running-the-course/course-structure.md:37
msgid "Bare-Metal Rust"
msgstr ""

#: src/running-the-course/course-structure.md:39
msgid ""
"The [Bare-Metal Rust](../bare-metal.md) deep dive is a full day class on "
"using Rust for bare-metal (embedded) development. Both microcontrollers and "
"application processors are covered."
msgstr ""
"[Bare Metal Rust](../bare-metal.md) es una clase de un d√≠a sobre c√≥mo usar "
"Rust para el desarrollo bare-metal (insertado). Se tratar√°n tanto "
"microcontroladores como procesadores de aplicaciones."

#: src/running-the-course/course-structure.md:43
msgid ""
"For the microcontroller part, you will need to buy the [BBC micro:bit]"
"(https://microbit.org/) v2 development board ahead of time. Everybody will "
"need to install a number of packages as described on the [welcome page](../"
"bare-metal.md)."
msgstr ""
"Para la parte de los microcontroladores, necesitar√°s comprar con antelaci√≥n "
"la segunda versi√≥n de la placa programable [BBC micro:bit](https://microbit."
"org/). Todo el mundo deber√° instalar una serie de paquetes, tal como se "
"describe en la [p√°gina de bienvenida](../bare-metal.md)."

#: src/running-the-course/course-structure.md:48
msgid "Concurrency in Rust"
msgstr "Concurrencia en Rust"

#: src/running-the-course/course-structure.md:50
msgid ""
"The [Concurrency in Rust](../concurrency.md) deep dive is a full day class "
"on classical as well as `async`/`await` concurrency."
msgstr ""
"[Concurrencia en profundidad](../concurrency.md) es una clase de un d√≠a "
"sobre la concurrencia cl√°sica y la concurrencia `async`/`await`."

#: src/running-the-course/course-structure.md:53
msgid ""
"You will need a fresh crate set up and the dependencies downloaded and ready "
"to go. You can then copy/paste the examples into `src/main.rs` to experiment "
"with them:"
msgstr ""
"Necesitar√°s configurar un nuevo crate, y descargar y preparar las "
"dependencias. A continuaci√≥n, podr√°s copiar y pegar los ejemplos en `src/"
"main.rs` para experimentar con ellos:"

#: src/running-the-course/course-structure.md:57
msgid ""
"```shell\n"
"cargo init concurrency\n"
"cd concurrency\n"
"cargo add tokio --features full\n"
"cargo run\n"
"```"
msgstr ""
"```shell\n"
"cargo init concurrency\n"
"cd concurrency\n"
"cargo add tokio --features full\n"
"cargo run\n"
"```"

#: src/running-the-course/course-structure.md:64
msgid "Format"
msgstr "Formato"

#: src/running-the-course/course-structure.md:66
msgid ""
"The course is meant to be very interactive and we recommend letting the "
"questions drive the exploration of Rust!"
msgstr ""
"El curso est√° pensado para ser muy interactivo, por lo que te recomendamos "
"que dejes que las preguntas gu√≠en el aprendizaje de Rust."

#: src/running-the-course/keyboard-shortcuts.md:3
msgid "There are several useful keyboard shortcuts in mdBook:"
msgstr "Existen varias combinaciones de teclas √∫tiles en mdBook:"

#: src/running-the-course/keyboard-shortcuts.md:5
msgid "Arrow-Left"
msgstr "Flecha izquierda"

#: src/running-the-course/keyboard-shortcuts.md:5
msgid ": Navigate to the previous page."
msgstr ": ir a la p√°gina anterior."

#: src/running-the-course/keyboard-shortcuts.md:6
msgid "Arrow-Right"
msgstr "Flecha derecha"

#: src/running-the-course/keyboard-shortcuts.md:6
msgid ": Navigate to the next page."
msgstr ": ir a la p√°gina siguiente."

#: src/running-the-course/keyboard-shortcuts.md:7 src/cargo/code-samples.md:19
msgid "Ctrl + Enter"
msgstr "Ctrl + Intro"

#: src/running-the-course/keyboard-shortcuts.md:7
msgid ": Execute the code sample that has focus."
msgstr ": ejecutar el c√≥digo de ejemplo seleccionado."

#: src/running-the-course/keyboard-shortcuts.md:8
msgid "s"
msgstr "s"

#: src/running-the-course/keyboard-shortcuts.md:8
msgid ": Activate the search bar."
msgstr ": activar la barra de b√∫squeda."

#: src/running-the-course/translations.md:3
msgid ""
"The course has been translated into other languages by a set of wonderful "
"volunteers:"
msgstr ""
"El curso se ha traducido a otros idiomas gracias a grupo de maravillosos "
"voluntarios:"

#: src/running-the-course/translations.md:6
msgid ""
"[Brazilian Portuguese](https://google.github.io/comprehensive-rust/pt-BR/) "
"by [@rastringer](https://github.com/rastringer), [@hugojacob](https://github."
"com/hugojacob), [@joaovicmendes](https://github.com/joaovicmendes) and "
"[@henrif75](https://github.com/henrif75)."
msgstr ""

#: src/running-the-course/translations.md:7
msgid ""
"[Korean](https://google.github.io/comprehensive-rust/ko/) by [@keispace]"
"(https://github.com/keispace), [@jiyongp](https://github.com/jiyongp) and "
"[@jooyunghan](https://github.com/jooyunghan)."
msgstr ""

#: src/running-the-course/translations.md:9
msgid ""
"Use the language picker in the top-right corner to switch between languages."
msgstr ""
"Cambia el idioma con el selector situado en la esquina superior derecha."

#: src/running-the-course/translations.md:11
msgid "Incomplete Translations"
msgstr "Traducciones Incompletas"

#: src/running-the-course/translations.md:13
msgid ""
"There is a large number of in-progress translations. We link to the most "
"recently updated translations:"
msgstr ""
"Hay muchas traducciones todav√≠a en curso. A continuaci√≥n, incluimos enlaces "
"a las traducciones m√°s actualizadas:"

#: src/running-the-course/translations.md:16
msgid ""
"[Bengali](https://google.github.io/comprehensive-rust/bn/) by [@raselmandol]"
"(https://github.com/raselmandol)."
msgstr ""

#: src/running-the-course/translations.md:17
msgid ""
"[French](https://google.github.io/comprehensive-rust/fr/) by [@KookaS]"
"(https://github.com/KookaS) and [@vcaen](https://github.com/vcaen)."
msgstr ""

#: src/running-the-course/translations.md:18
msgid ""
"[German](https://google.github.io/comprehensive-rust/de/) by [@Throvn]"
"(https://github.com/Throvn) and [@ronaldfw](https://github.com/ronaldfw)."
msgstr ""

#: src/running-the-course/translations.md:19
msgid ""
"[Japanese](https://google.github.io/comprehensive-rust/ja/) by [@CoinEZ-JPN]"
"(https://github.com/CoinEZ) and [@momotaro1105](https://github.com/"
"momotaro1105)."
msgstr ""

#: src/running-the-course/translations.md:21
msgid ""
"If you want to help with this effort, please see [our instructions](https://"
"github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md) for how to "
"get going. Translations are coordinated on the [issue tracker](https://"
"github.com/google/comprehensive-rust/issues/282)."
msgstr ""
"Si quieres ayudar en esta iniciativa, consulta [nuestras instrucciones]"
"(https://github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md) "
"para empezar. Las traducciones se coordinan en la [herramienta de "
"seguimiento de incidencias](https://github.com/google/comprehensive-rust/"
"issues/282)."

#: src/cargo.md:3
msgid ""
"When you start reading about Rust, you will soon meet [Cargo](https://doc."
"rust-lang.org/cargo/), the standard tool used in the Rust ecosystem to build "
"and run Rust applications. Here we want to give a brief overview of what "
"Cargo is and how it fits into the wider ecosystem and how it fits into this "
"training."
msgstr ""
"Cuando empieces a informarte sobre Rust, conocer√°s [Cargo](https://doc.rust-"
"lang.org/cargo/), la herramienta est√°ndar que se utiliza en el ecosistema de "
"Rust para crear y ejecutar sus aplicaciones. En este art√≠culo, te ofrecemos "
"una breve descripci√≥n de lo que es Cargo, c√≥mo se integra en el ecosistema "
"m√°s amplio y c√≥mo encaja en esta formaci√≥n."

#: src/cargo.md:8
msgid "Installation"
msgstr "Instalaci√≥n"

#: src/cargo.md:10
msgid "**Please follow the instructions on <https://rustup.rs/>.**"
msgstr "**Sigue las instrucciones que se indican en <https://rustup.rs/>.**"

#: src/cargo.md:12
msgid ""
"This will give you the Cargo build tool (`cargo`) and the Rust compiler "
"(`rustc`). You will also get `rustup`, a command line utility that you can "
"use to install/switch toolchains, setup cross compilation, etc."
msgstr ""
"De este modo, obtendr√°s la herramienta de compilaci√≥n de Cargo (`cargo`) y "
"el compilador de Rust (`rustc`). Tambi√©n obtendr√°s `rustup`, una utilidad de "
"l√≠nea de comandos que puedes utilizar para instalar o cambiar cadenas de "
"herramientas, configurar la compilaci√≥n cruzada, etc."

#: src/cargo.md:16
#, fuzzy
msgid ""
"On Debian/Ubuntu, you can also install Cargo, the Rust source and the [Rust "
"formatter](https://github.com/rust-lang/rustfmt) via `apt`. However, this "
"gets you an outdated rust version and may lead to unexpected behavior. The "
"command would be:"
msgstr ""
"En Debian o Ubuntu, tambi√©n puedes instalar Cargo, el c√≥digo fuente de Rust "
"y [el formateador de Rust](https://github.com/rust-lang/rustfmt) a trav√©s de "
"`apt`. Sin embargo, solo podr√°s conseguir una versi√≥n de Rust obsoleta que "
"podr√≠a dar lugar a comportamientos inesperados. El comando es el siguiente:"

#: src/cargo.md:18
msgid ""
"```shell\n"
"sudo apt install cargo rust-src rustfmt\n"
"```"
msgstr ""
"```shell\n"
"sudo apt install cargo rust-src rustfmt\n"
"```"

#: src/cargo.md:22
#, fuzzy
msgid ""
"We suggest using [VS Code](https://code.visualstudio.com/) to edit the code "
"(but any LSP compatible editor works with rust-analyzer[3](https://rust-"
"analyzer.github.io/))."
msgstr ""
"Recomendamos usar [VS Code](https://code.visualstudio.com/) para editar el "
"c√≥digo (aunque cualquier editor compatible con LSP funciona con [rust-"
"analyzer](https://rust-analyzer.github.io/))."

#: src/cargo.md:24
msgid ""
"Some folks also like to use the [JetBrains](https://www.jetbrains.com/"
"clion/) family of IDEs, which do their own analysis but have their own "
"tradeoffs. If you prefer them, you can install the [Rust Plugin](https://www."
"jetbrains.com/rust/). Please take note that as of January 2023 debugging "
"only works on the CLion version of the JetBrains IDEA suite."
msgstr ""
"A algunos compa√±eros tambi√©n les gusta usar la familia [JetBrains](https://"
"www.jetbrains.com/clion/) de IDEs, que hacen sus propios an√°lisis, pero "
"tambi√©n tienen inconvenientes. Si lo prefieres, puedes instalar el [Rust "
"Plugin](https://www.jetbrains.com/rust/). Ten en cuenta que, a partir de "
"enero del 2023, la depuraci√≥n solo funciona en la versi√≥n CLion del paquete "
"de JetBrains IDEA."

#: src/cargo/rust-ecosystem.md:1
msgid "The Rust Ecosystem"
msgstr "El ecosistema de Rust"

#: src/cargo/rust-ecosystem.md:3
msgid ""
"The Rust ecosystem consists of a number of tools, of which the main ones are:"
msgstr ""
"El ecosistema de Rust se compone de varias herramientas, entre las que se "
"incluyen las siguientes:"

#: src/cargo/rust-ecosystem.md:5
msgid ""
"`rustc`: the Rust compiler which turns `.rs` files into binaries and other "
"intermediate formats."
msgstr ""
"`rustc`: el compilador de Rust que convierte archivos `.rs` en binarios y "
"otros formatos intermedios."

#: src/cargo/rust-ecosystem.md:8
#, fuzzy
msgid ""
"`cargo`: the Rust dependency manager and build tool. Cargo knows how to "
"download dependencies, usually hosted on <https://crates.io>, and it will "
"pass them to `rustc` when building your project. Cargo also comes with a "
"built-in test runner which is used to execute unit tests."
msgstr ""
"`cargo`: herramienta de compilaci√≥n y gesti√≥n de dependencias de Rust. Cargo "
"sabe c√≥mo descargar dependencias, que normalmente se alojan en <https://"
"crates.io>, y las transfiere a `rustc` al crear el proyecto. Cargo tambi√©n "
"incorpora un ejecutor de pruebas que se utiliza para realizar pruebas "
"unitarias."

#: src/cargo/rust-ecosystem.md:13
msgid ""
"`rustup`: the Rust toolchain installer and updater. This tool is used to "
"install and update `rustc` and `cargo` when new versions of Rust is "
"released. In addition, `rustup` can also download documentation for the "
"standard library. You can have multiple versions of Rust installed at once "
"and `rustup` will let you switch between them as needed."
msgstr ""
"`rustup`: el instalador y actualizador de cadenas de herramientas de Rust. "
"Esta herramienta se utiliza para instalar y actualizar `rustc` y `cargo` "
"cuando se lanzan nuevas versiones de Rust. Adem√°s, `rustup` tambi√©n puede "
"descargar documentaci√≥n de la biblioteca est√°ndar. Puedes tener varias "
"versiones de Rust instaladas a la vez y `rustup` te permitir√° cambiar de una "
"a otra seg√∫n lo necesites."

#: src/cargo/rust-ecosystem.md:21 src/hello-world.md:25
#: src/hello-world/small-example.md:27 src/why-rust/runtime.md:10
#: src/why-rust/modern.md:21 src/basic-syntax/compound-types.md:30
#: src/basic-syntax/references.md:23
#: src/pattern-matching/destructuring-enums.md:35
#: src/ownership/double-free-modern-cpp.md:55
#: src/error-handling/try-operator.md:48
#: src/error-handling/converting-error-types-example.md:50
#: src/concurrency/threads.md:30 src/async/async-await.md:25
msgid "Key points:"
msgstr "Puntos clave:"

#: src/cargo/rust-ecosystem.md:23
msgid ""
"Rust has a rapid release schedule with a new release coming out every six "
"weeks. New releases maintain backwards compatibility with old releases --- "
"plus they enable new functionality."
msgstr ""
"Rust cuenta con un programa de lanzamiento r√°pido en el que se publica una "
"nueva versi√≥n cada seis semanas. Las nuevas versiones mantienen la "
"retrocompatibilidad con las versiones anteriores, adem√°s de habilitar nuevas "
"funciones."

#: src/cargo/rust-ecosystem.md:27
msgid ""
"There are three release channels: \"stable\", \"beta\", and \"nightly\"."
msgstr "Hay tres canales de lanzamiento: \"stable\", \"beta\" y \"nightly\"."

#: src/cargo/rust-ecosystem.md:29
msgid ""
"New features are being tested on \"nightly\", \"beta\" is what becomes "
"\"stable\" every six weeks."
msgstr ""
"Las funciones nuevas se prueban en \"nightly\", y \"beta\" es lo que se "
"convierte en \"estable\" cada seis semanas."

#: src/cargo/rust-ecosystem.md:32
msgid ""
"Dependencies can also be resolved from alternative [registries](https://doc."
"rust-lang.org/cargo/reference/registries.html), git, folders, and more."
msgstr ""
"Las dependencias tambi√©n pueden resolverse desde \\[registros\\] "
"alternativos, git, carpetas, etc."

#: src/cargo/rust-ecosystem.md:34
msgid ""
"Rust also has [editions](https://doc.rust-lang.org/edition-guide/): the "
"current edition is Rust 2021. Previous editions were Rust 2015 and Rust 2018."
msgstr ""
"Rust tambi√©n tiene varias \\[ediciones\\]: la m√°s actual es Rust 2021. Las "
"ediciones anteriores son Rust 2015 y Rust 2018."

#: src/cargo/rust-ecosystem.md:37
msgid ""
"The editions are allowed to make backwards incompatible changes to the "
"language."
msgstr ""
"Las ediciones pueden introducir cambios de incompatibilidad con versiones "
"anteriores en el lenguaje."

#: src/cargo/rust-ecosystem.md:40
msgid ""
"To prevent breaking code, editions are opt-in: you select the edition for "
"your crate via the `Cargo.toml` file."
msgstr ""
"Para evitar que se rompa el c√≥digo, las ediciones son opcionales: selecciona "
"la edici√≥n para tu crate a trav√©s del archivo `Cargo.toml`."

#: src/cargo/rust-ecosystem.md:43
msgid ""
"To avoid splitting the ecosystem, Rust compilers can mix code written for "
"different editions."
msgstr ""
"Para evitar la divisi√≥n del ecosistema, los compiladores de Rust pueden "
"mezclar el c√≥digo escrito para distintas ediciones."

#: src/cargo/rust-ecosystem.md:46
msgid ""
"Mention that it is quite rare to ever use the compiler directly not through "
"`cargo` (most users never do)."
msgstr ""
"Hay que mencionar que es bastante raro utilizar el compilador directamente y "
"no a trav√©s de `cargo` (la mayor√≠a de los usuarios nunca lo hacen)."

#: src/cargo/rust-ecosystem.md:48
msgid ""
"It might be worth alluding that Cargo itself is an extremely powerful and "
"comprehensive tool.  It is capable of many advanced features including but "
"not limited to: "
msgstr ""
"Vale la pena mencionar que Cargo en s√≠ es una herramienta extremadamente "
"poderosa e integral.  Es capaz de hacer muchas cosas avanzadas y no "
"limitadas a: "

#: src/cargo/rust-ecosystem.md:49
msgid "Project/package structure"
msgstr "Estructura del proyecto/package "

#: src/cargo/rust-ecosystem.md:50
msgid "[workspaces](https://doc.rust-lang.org/cargo/reference/workspaces.html)"
msgstr ""
"[workspaces](https://doc.rust-lang.org/cargo/reference/workspaces.html) "

#: src/cargo/rust-ecosystem.md:51
msgid "Dev Dependencies and Runtime Dependency management/caching"
msgstr "Manejo/Cach√© de Dependencias de Desarrollo y de Runtime "

#: src/cargo/rust-ecosystem.md:52
msgid ""
"[build scripting](https://doc.rust-lang.org/cargo/reference/build-scripts."
"html)"
msgstr ""
"Consulta el libro [Rust Reference](https://doc.rust-lang.org/reference/type-"
"layout.html)."

#: src/cargo/rust-ecosystem.md:53
msgid ""
"[global installation](https://doc.rust-lang.org/cargo/commands/cargo-install."
"html)"
msgstr ""

#: src/cargo/rust-ecosystem.md:54
msgid ""
"It is also extensible with sub command plugins as well (such as [cargo "
"clippy](https://github.com/rust-lang/rust-clippy))."
msgstr "Consulta m√°s informaci√≥n en el \\[libro oficial de Cargo\\]."

#: src/cargo/rust-ecosystem.md:55
msgid ""
"Read more from the [official Cargo Book](https://doc.rust-lang.org/cargo/)"
msgstr ""

#: src/cargo/code-samples.md:1
msgid "Code Samples in This Training"
msgstr "C√≥digo de ejemplo en esta formaci√≥n"

#: src/cargo/code-samples.md:3
msgid ""
"For this training, we will mostly explore the Rust language through examples "
"which can be executed through your browser. This makes the setup much easier "
"and ensures a consistent experience for everyone."
msgstr ""
"En esta formaci√≥n, aprenderemos el lenguaje Rust principalmente con ejemplos "
"que podr√°s ejecutar con tu navegador. De este modo, la configuraci√≥n es "
"mucho m√°s sencilla y se asegura una experiencia homog√©nea para todos."

#: src/cargo/code-samples.md:7
msgid ""
"Installing Cargo is still encouraged: it will make it easier for you to do "
"the exercises. On the last day, we will do a larger exercise which shows you "
"how to work with dependencies and for that you need Cargo."
msgstr ""
"Se recomienda instalar Cargo, ya que facilitar√° la realizaci√≥n de los "
"ejercicios. El √∫ltimo d√≠a realizaremos un ejercicio m√°s largo en el que se "
"mostrar√° c√≥mo trabajar con dependencias, y para eso se necesita Cargo."

#: src/cargo/code-samples.md:11
msgid "The code blocks in this course are fully interactive:"
msgstr "Los bloques de c√≥digo de este curso son totalmente interactivos:"

#: src/cargo/code-samples.md:13
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"Edit me!\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"Edit me!\");\n"
"}\n"
"```"

#: src/cargo/code-samples.md:19
msgid "You can use "
msgstr "Puedes usar "

#: src/cargo/code-samples.md:19
msgid " to execute the code when focus is in the text box."
msgstr " para ejecutar el c√≥digo cuando el cursor est√© en el cuadro de texto."

#: src/cargo/code-samples.md:24
msgid ""
"Most code samples are editable like shown above. A few code samples are not "
"editable for various reasons:"
msgstr ""
"La mayor√≠a de los c√≥digos de ejemplo se pueden editar, como se muestra "
"arriba, pero hay algunos que no se pueden editar por varios motivos:"

#: src/cargo/code-samples.md:27
msgid ""
"The embedded playgrounds cannot execute unit tests. Copy-paste the code and "
"open it in the real Playground to demonstrate unit tests."
msgstr ""
"Los playgrounds insertados no pueden ejecutar pruebas unitarias. Copia y "
"pega el c√≥digo y √°brelo en la p√°gina del playground para mostrar pruebas "
"unitarias."

#: src/cargo/code-samples.md:30
msgid ""
"The embedded playgrounds lose their state the moment you navigate away from "
"the page! This is the reason that the students should solve the exercises "
"using a local Rust installation or via the Playground."
msgstr ""
"Los playgrounds insertados pierden su estado en cuanto sales e de la p√°gina. "
"Por este motivo, los alumnos deben resolver los ejercicios con una versi√≥n "
"local de Rust o a trav√©s del playground."

#: src/cargo/running-locally.md:1
msgid "Running Code Locally with Cargo"
msgstr "Ejecutar c√≥digo de forma local con Cargo"

#: src/cargo/running-locally.md:3
#, fuzzy
msgid ""
"If you want to experiment with the code on your own system, then you will "
"need to first install Rust. Do this by following the [instructions in the "
"Rust Book](https://doc.rust-lang.org/book/ch01-01-installation.html). This "
"should give you a working `rustc` and `cargo`. At the time of writing, the "
"latest stable Rust release has these version numbers:"
msgstr ""
"Si quieres experimentar con el c√≥digo en tu propio sistema, primero tendr√°s "
"que instalar Rust. Para ello, sigue las \\[instrucciones que aparecen en el "
"libro de Rust\\]\\[1\\]. De este modo, obtendr√°s un `rustc` y un `cargo` que "
"funcionen. En el momento en que se redact√≥ este documento, los n√∫meros de "
"las √∫ltimas versiones estables de Rust eran los siguientes:"

#: src/cargo/running-locally.md:8
msgid ""
"```shell\n"
"% rustc --version\n"
"rustc 1.69.0 (84c898d65 2023-04-16)\n"
"% cargo --version\n"
"cargo 1.69.0 (6e9a83356 2023-04-12)\n"
"```"
msgstr ""
"```shell\n"
"% rustc --version\n"
"rustc 1.69.0 (84c898d65 2023-04-16)\n"
"% cargo --version\n"
"cargo 1.69.0 (6e9a83356 2023-04-12)\n"
"```"

#: src/cargo/running-locally.md:15
msgid ""
"You can use any later version too since Rust maintains backwards "
"compatibility."
msgstr ""

#: src/cargo/running-locally.md:17
msgid ""
"With this in place, follow these steps to build a Rust binary from one of "
"the examples in this training:"
msgstr ""
"Una vez hecho lo anterior, sigue estos pasos para compilar un binario de "
"Rust a partir de uno de los ejemplos de la formaci√≥n:"

#: src/cargo/running-locally.md:20
msgid "Click the \"Copy to clipboard\" button on the example you want to copy."
msgstr ""
"Haz clic en el bot√≥n \"Copiar en el portapapeles\" del ejemplo que quieras "
"copiar."

#: src/cargo/running-locally.md:22
msgid ""
"Use `cargo new exercise` to create a new `exercise/` directory for your code:"
msgstr ""
"Usa `cargo new exercise` para crear un directorio `exercise/` para tu c√≥digo:"

#: src/cargo/running-locally.md:24
msgid ""
"```shell\n"
"$ cargo new exercise\n"
"     Created binary (application) `exercise` package\n"
"```"
msgstr ""
"```shell\n"
"$ cargo new exercise\n"
"     Created binary (application) `exercise` package\n"
"```"

#: src/cargo/running-locally.md:29
msgid ""
"Navigate into `exercise/` and use `cargo run` to build and run your binary:"
msgstr ""
"Ve a `exercise/` y usa `cargo run` para compilar y ejecutar tu binario:"

#: src/cargo/running-locally.md:31
msgid ""
"```shell\n"
"$ cd exercise\n"
"$ cargo run\n"
"   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.75s\n"
"     Running `target/debug/exercise`\n"
"Hello, world!\n"
"```"
msgstr ""
"```shell\n"
"$ cd exercise\n"
"$ cargo run\n"
"   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.75s\n"
"     Running `target/debug/exercise`\n"
"Hola Mundo!\n"
"```"

#: src/cargo/running-locally.md:40
msgid ""
"Replace the boiler-plate code in `src/main.rs` with your own code. For "
"example, using the example on the previous page, make `src/main.rs` look like"
msgstr ""
"Sustituye el c√≥digo de plantilla en `src/main.rs` con tu propio c√≥digo. Por "
"ejemplo, si usamos el ejemplo de la p√°gina anterior, podemos hacer que `src/"
"main.rs` tenga el siguiente aspecto:"

#: src/cargo/running-locally.md:43
msgid ""
"```rust\n"
"fn main() {\n"
"    println!(\"Edit me!\");\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    println!(\"Edit me!\");\n"
"}\n"
"```"

#: src/cargo/running-locally.md:49
msgid "Use `cargo run` to build and run your updated binary:"
msgstr "Usa `cargo run` para hacer build y ejecutar tu binario actualizado:"

#: src/cargo/running-locally.md:51
msgid ""
"```shell\n"
"$ cargo run\n"
"   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.24s\n"
"     Running `target/debug/exercise`\n"
"Edit me!\n"
"```"
msgstr ""
"```shell\n"
"$ cargo run\n"
"   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.24s\n"
"     Running `target/debug/ejercicio`\n"
"Modif√≠came!\n"
"```"

#: src/cargo/running-locally.md:59
msgid ""
"Use `cargo check` to quickly check your project for errors, use `cargo "
"build` to compile it without running it. You will find the output in `target/"
"debug/` for a normal debug build. Use `cargo build --release` to produce an "
"optimized release build in `target/release/`."
msgstr ""
"Comprueba que no haya errores en el proyecto con `cargo check`. Comp√≠lalo "
"sin ejecutarlo con `cargo build`. Encontrar√°s la salida en `target/debug/` "
"para una versi√≥n de depuraci√≥n normal. Usa `cargo build --release` para "
"generar una compilaci√≥n de lanzamiento optimizada en `target/release/`."

#: src/cargo/running-locally.md:64
msgid ""
"You can add dependencies for your project by editing `Cargo.toml`. When you "
"run `cargo` commands, it will automatically download and compile missing "
"dependencies for you."
msgstr ""
"Edita `Cargo.toml` para a√±adir dependencias a tu proyecto. Cuando ejecutes "
"comandos `cargo`, se descargar√°n y compilar√°n autom√°ticamente las "
"dependencias que falten."

#: src/cargo/running-locally.md:72
msgid ""
"Try to encourage the class participants to install Cargo and use a local "
"editor. It will make their life easier since they will have a normal "
"development environment."
msgstr ""
"Anima a los participantes de la clase a instalar Cargo y utilizar un editor "
"local. Les facilitar√° mucho las cosas, ya que dispondr√°n de un entorno de "
"desarrollo normal."

#: src/welcome-day-1.md:1
msgid "Welcome to Day 1"
msgstr "Te damos la bienvenida al D√≠a 1"

#: src/welcome-day-1.md:3
#, fuzzy
msgid ""
"This is the first day of Rust Fundamentals. We will cover a lot of ground "
"today:"
msgstr ""
"Este es el primer d√≠a de Comprehensive Rust. Hoy trataremos muchos temas:"

#: src/welcome-day-1.md:6
msgid ""
"Basic Rust syntax: variables, scalar and compound types, enums, structs, "
"references, functions, and methods."
msgstr ""
"Sintaxis b√°sica Rust: variables, scalar y tipos compuestos, enums, structs,  "
"references, funciones, y m√©todos."

#: src/welcome-day-1.md:9
msgid ""
"Control flow constructs: `if`, `if let`, `while`, `while let`, `break`, and "
"`continue`."
msgstr ""
"Control de flujo: `if`, `if let`, `while`, `while let`, `break`, y "
"`continue`."

#: src/welcome-day-1.md:12
msgid "Pattern matching: destructuring enums, structs, and arrays."
msgstr ""

#: src/welcome-day-1.md:16
msgid "Please remind the students that:"
msgstr "Recuerda a los alumnos lo siguiente:"

#: src/welcome-day-1.md:18
msgid ""
"They should ask questions when they get them, don't save them to the end."
msgstr ""
"Deben hacer las preguntas cuando surgen, no las guarden hasta el final."

#: src/welcome-day-1.md:19
msgid ""
"The class is meant to be interactive and discussions are very much "
"encouraged!"
msgstr ""
"El curso est√° pensado para ser muy interactivo, por lo que te recomendamos "
"que dejes que las preguntas gu√≠en el aprendizaje de Rust."

#: src/welcome-day-1.md:20
msgid ""
"As an instructor, you should try to keep the discussions relevant, i.e., "
"keep the discussions related to how Rust does things vs some other "
"language.  It can be hard to find the right balance, but err on the side of "
"allowing  discussions since they engage people much more than one-way "
"communication."
msgstr ""
"Como instructor, debes intentar llevar discusiones relevantes, por ejemplo, "
"mantener relaci√≥n de c√≥mo Rust hace las cosas vs otros lenguajes. Puede "
"costar encontrar un balance adecuado, pero permite llevar un debate que "
"atraiga la atenci√≥n de la gente por sobre un discurso unidireccional."

#: src/welcome-day-1.md:24
msgid ""
"The questions will likely mean that we talk about things ahead of the slides."
msgstr ""
"Las preguntas deber√≠an ser sobre cosas acerca del contenido de los slides."

#: src/welcome-day-1.md:25
msgid ""
"This is perfectly okay! Repetition is an important part of learning. "
"Remember that the slides are just a support and you are free to skip them as "
"you like."
msgstr ""
"Esto est√° perfecto! Repetir es una parte importante del aprendizaje. "
"Recuerda que los slides son solo un soporte y tienes libertad de saltearlos "
"cuando quieras."

#: src/welcome-day-1.md:29
msgid ""
"The idea for the first day is to show _just enough_ of Rust to be able to "
"speak about the famous borrow checker. The way Rust handles memory is a "
"major feature and we should show students this right away."
msgstr ""
"La idea del primer d√≠a es mostrar _lo suficiente_ de Rustcomo para poder "
"hablar del famoso _borrow checker_. La forma en que Rust gestiona la memoria "
"es una caracter√≠stica importante y debemos mostrarla a los estudiantes desde "
"el principio."

#: src/welcome-day-1.md:33
msgid ""
"If you're teaching this in a classroom, this is a good place to go over the "
"schedule. We suggest splitting the day into two parts (following the slides):"
msgstr ""
"Si est√°s impartiendo el curso en un aula, este es un buen lugar para repasar "
"el calendario. Te recomendamos que dividas el d√≠a en dos partes (siguiendo "
"las diapositivas):"

#: src/welcome-day-1.md:36
msgid "Morning: 9:00 to 12:00,"
msgstr "Ma√±ana: 9:00 to 12:00,"

#: src/welcome-day-1.md:37
msgid "Afternoon: 13:00 to 16:00."
msgstr "Tarde: de 13:00 a 16:00."

#: src/welcome-day-1.md:39
msgid ""
"You can of course adjust this as necessary. Please make sure to include "
"breaks, we recommend a break every hour!"
msgstr ""
"Por supuesto, puedes ajustar las horas seg√∫n lo necesites. No olvides "
"incluir pausas, recomendamos hacer un descanso cada hora."

#: src/welcome-day-1/what-is-rust.md:3
msgid ""
"Rust is a new programming language which had its [1.0 release in 2015]"
"(https://blog.rust-lang.org/2015/05/15/Rust-1.0.html):"
msgstr ""
"Rust es un nuevo lenguaje de programaci√≥n que lanz√≥ su versi√≥n [1.0 en el "
"2015](https://blog.rust-lang.org/2015/05/15/Rust-1.0.html):"

#: src/welcome-day-1/what-is-rust.md:5
msgid "Rust is a statically compiled language in a similar role as C++"
msgstr "Rust es un lenguaje compilado est√°tico similar a C++"

#: src/welcome-day-1/what-is-rust.md:6
msgid "`rustc` uses LLVM as its backend."
msgstr "`rustc` usa LLVM como backend."

#: src/welcome-day-1/what-is-rust.md:7
msgid ""
"Rust supports many [platforms and architectures](https://doc.rust-lang.org/"
"nightly/rustc/platform-support.html):"
msgstr ""
"Rust es compatible con muchas [plataformas y arquitecturas](https://doc.rust-"
"lang.org/nightly/rustc/platform-support.html):"

#: src/welcome-day-1/what-is-rust.md:9
msgid "x86, ARM, WebAssembly, ..."
msgstr "x86, ARM, WebAssembly, ..."

#: src/welcome-day-1/what-is-rust.md:10
msgid "Linux, Mac, Windows, ..."
msgstr "Linux, Mac, Windows, ..."

#: src/welcome-day-1/what-is-rust.md:11
msgid "Rust is used for a wide range of devices:"
msgstr "Rust se utiliza en una gran variedad de dispositivos:"

#: src/welcome-day-1/what-is-rust.md:12
msgid "firmware and boot loaders,"
msgstr "firmware y cargadores de inicio,"

#: src/welcome-day-1/what-is-rust.md:13
msgid "smart displays,"
msgstr "pantallas inteligentes,"

#: src/welcome-day-1/what-is-rust.md:14
msgid "mobile phones,"
msgstr "tel√©fonos m√≥viles,"

#: src/welcome-day-1/what-is-rust.md:15
msgid "desktops,"
msgstr "ordenadores,"

#: src/welcome-day-1/what-is-rust.md:16
msgid "servers."
msgstr "servidores."

#: src/welcome-day-1/what-is-rust.md:21
msgid "Rust fits in the same area as C++:"
msgstr "Rust satisface las mismas necesidades que C++:"

#: src/welcome-day-1/what-is-rust.md:23
msgid "High flexibility."
msgstr "Gran flexibilidad."

#: src/welcome-day-1/what-is-rust.md:24
msgid "High level of control."
msgstr "Nivel alto de control."

#: src/welcome-day-1/what-is-rust.md:25
msgid ""
"Can be scaled down to very constrained devices such as microcontrollers."
msgstr ""
"Se puede reducir verticalmente a dispositivos muy limitados, como los "
"microcontroladores."

#: src/welcome-day-1/what-is-rust.md:26
msgid "Has no runtime or garbage collection."
msgstr "No tiene _runtime_ ni _garbage collection_."

#: src/welcome-day-1/what-is-rust.md:27
msgid "Focuses on reliability and safety without sacrificing performance."
msgstr ""
"Se centra en la fiabilidad y la seguridad sin sacrificar el rendimiento."

#: src/hello-world.md:3
msgid ""
"Let us jump into the simplest possible Rust program, a classic Hello World "
"program:"
msgstr "Vamos a hablar del programa Rust m√°s simple, un cl√°sico Hola Mundo:"

#: src/hello-world.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"Hello üåç!\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"Hola üåç!\");\n"
"}\n"
"```"

#: src/hello-world.md:12
msgid "What you see:"
msgstr "Lo que ves:"

#: src/hello-world.md:14
msgid "Functions are introduced with `fn`."
msgstr "Las funciones se introducen con `fn`."

#: src/hello-world.md:15
msgid "Blocks are delimited by curly braces like in C and C++."
msgstr "Los bloques se delimitan con llaves, como en C y C++."

#: src/hello-world.md:16
msgid "The `main` function is the entry point of the program."
msgstr "La funci√≥n `main` es el punto de entrada del programa."

#: src/hello-world.md:17
msgid "Rust has hygienic macros, `println!` is an example of this."
msgstr "Rust tiene macros higi√©nicas, como por ejemplo `println!`."

#: src/hello-world.md:18
msgid "Rust strings are UTF-8 encoded and can contain any Unicode character."
msgstr ""
"Las cadenas de Rust est√°n codificadas en UTF-8 y pueden contener caracteres "
"Unicode."

#: src/hello-world.md:22
msgid ""
"This slide tries to make the students comfortable with Rust code. They will "
"see a ton of it over the next three days so we start small with something "
"familiar."
msgstr ""
"Con esta diapositiva se intenta que los alumnos se sientan c√≥modos con el "
"c√≥digo de Rust. En los pr√≥ximos tres d√≠as lo ver√°n mucho, as√≠ que "
"empezaremos con algo que ya conocemos."

#: src/hello-world.md:27
msgid ""
"Rust is very much like other languages in the C/C++/Java tradition. It is "
"imperative and it doesn't try to reinvent things unless absolutely necessary."
msgstr ""
"Rust es muy similar a otros lenguajes, como C, C++ o Java. Es imperativo y "
"no intenta reinventar las cosas a menos que sea absolutamente necesario."

#: src/hello-world.md:31
msgid "Rust is modern with full support for things like Unicode."
msgstr "Rust es moderno y totalmente compatible con sistemas como Unicode."

#: src/hello-world.md:33
msgid ""
"Rust uses macros for situations where you want to have a variable number of "
"arguments (no function [overloading](basic-syntax/functions-interlude.md))."
msgstr ""
"Rust utiliza macros en situaciones en las que se desea tener un n√∫mero "
"variable de argumentos (sin [sobrecarga](basic-syntax/functions-interlude."
"md) de funciones)."

#: src/hello-world.md:36
msgid ""
"Macros being 'hygienic' means they don't accidentally capture identifiers "
"from the scope they are used in. Rust macros are actually only [partially "
"hygienic](https://veykril.github.io/tlborm/decl-macros/minutiae/hygiene."
"html)."
msgstr ""
"Que las macros sean 'higi√©nicas' significa que no capturan "
"accidentalmenteidentificadores del √°mbito en el que se utilizan. En "
"realidad, las macros de Rust solo son [parcialmente higi√©nicas](https://"
"veykril.github.io/tlborm/decl-macros/minutiae/hygiene.html)."

#: src/hello-world.md:40
msgid ""
"Rust is multi-paradigm. For example, it has powerful [object-oriented "
"programming features](https://doc.rust-lang.org/book/ch17-00-oop.html), and, "
"while it is not a functional language, it includes a range of [functional "
"concepts](https://doc.rust-lang.org/book/ch13-00-functional-features.html)."
msgstr ""
"Rust es un lenguaje multiparadigma. Por ejemplo, cuenta con [funciones de "
"programaci√≥n orientadas a objetos](https://doc.rust-lang.org/book/ch17-00-"
"oop.html) y, aunque no es un lenguaje funcional, incluye una serie de "
"[conceptos funcionales](https://doc.rust-lang.org/book/ch13-00-functional-"
"features.html)."

#: src/hello-world/small-example.md:3
msgid "Here is a small example program in Rust:"
msgstr "A continuaci√≥n, se muestra un peque√±o programa de ejemplo de Rust:"

#: src/hello-world/small-example.md:5
msgid ""
"```rust,editable\n"
"fn main() {              // Program entry point\n"
"    let mut x: i32 = 6;  // Mutable variable binding\n"
"    print!(\"{x}\");       // Macro for printing, like printf\n"
"    while x != 1 {       // No parenthesis around expression\n"
"        if x % 2 == 0 {  // Math like in other languages\n"
"            x = x / 2;\n"
"        } else {\n"
"            x = 3 * x + 1;\n"
"        }\n"
"        print!(\" -> {x}\");\n"
"    }\n"
"    println!();\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {              // Punto de entrada del programa\n"
"    let mut x: i32 = 6;  // Variable mutable vinculante\n"
"    print!(\"{x}\");       // Macro para printing, como printf\n"
"    while x != 1 {       // Sin par√©ntesis alrededor de las expresiones\n"
"        if x % 2 == 0 {  // Operaciones matem√°ticas como en otros lenguajes\n"
"            x = x / 2;\n"
"        } else {\n"
"            x = 3 * x + 1;\n"
"        }\n"
"        print!(\" -> {x}\");\n"
"    }\n"
"    println!();\n"
"}\n"
"```"

#: src/hello-world/small-example.md:23
msgid ""
"The code implements the Collatz conjecture: it is believed that the loop "
"will always end, but this is not yet proved. Edit the code and play with "
"different inputs."
msgstr ""
"El c√≥digo implementa la conjetura de Collatz: se cree que el bucle terminar√° "
"siempre, pero a√∫n no se ha demostrado. Edita el c√≥digo y prueba con "
"diferentes entradas."

#: src/hello-world/small-example.md:29
msgid ""
"Explain that all variables are statically typed. Try removing `i32` to "
"trigger type inference. Try with `i8` instead and trigger a runtime integer "
"overflow."
msgstr ""
"Explica que todas las variables est√°n tipadas est√°ticamente. Prueba a quitar "
"`i32` para activar la inferencia de tipos. Prueba con `i8` y provoca un "
"desbordamiento de enteros en _runtime_."

#: src/hello-world/small-example.md:32
msgid "Change `let mut x` to `let x`, discuss the compiler error."
msgstr "Cambia `let mut x` por `let x` y discute el error del compilador."

#: src/hello-world/small-example.md:34
msgid ""
"Show how `print!` gives a compilation error if the arguments don't match the "
"format string."
msgstr ""
"Muestra c√≥mo `print!` da un error de compilaci√≥n si los argumentos no "
"coinciden con la cadena de formato."

#: src/hello-world/small-example.md:37
msgid ""
"Show how you need to use `{}` as a placeholder if you want to print an "
"expression which is more complex than just a single variable."
msgstr ""
"Muestra c√≥mo se debe usar `{}` como marcador de posici√≥n para poder imprimir "
"una expresi√≥n m√°s compleja que una sola variable."

#: src/hello-world/small-example.md:40
msgid ""
"Show the students the standard library, show them how to search for `std::"
"fmt` which has the rules of the formatting mini-language. It's important "
"that the students become familiar with searching in the standard library."
msgstr ""
"Muestra a los alumnos la biblioteca est√°ndar y c√≥mo buscar `std::fmt`, que "
"tiene las reglas del mini-lenguaje de formato. Es importante que los alumnos "
"se familiaricen con la b√∫squeda en la biblioteca est√°ndar."

#: src/hello-world/small-example.md:44
msgid ""
"In a shell `rustup doc std::fmt` will open a browser on the local std::fmt "
"documentation"
msgstr ""
"En un shell, `rustup doc std::fmt` abrir√° un navegador en la documentaci√≥n "
"local de std::fmt."

#: src/why-rust.md:3
msgid "Some unique selling points of Rust:"
msgstr "Estas son algunas de las ventajas competitivas de Rust:"

#: src/why-rust.md:5
msgid "Compile time memory safety."
msgstr "Seguridad de la memoria en tiempo de compilaci√≥n."

#: src/why-rust.md:6
msgid "Lack of undefined runtime behavior."
msgstr "Ausencia de comportamientos indefinidos en _runtime_."

#: src/why-rust.md:7
msgid "Modern language features."
msgstr "Caracter√≠sticas de lenguajes modernos."

#: src/why-rust.md:11
msgid ""
"Make sure to ask the class which languages they have experience with. "
"Depending on the answer you can highlight different features of Rust:"
msgstr ""
"Aseg√∫rate de preguntar a la clase en qu√© lenguajes tienen experiencia. "
"Dependiendo de la respuesta puedes destacar diferentes caracter√≠sticas de "
"Rust:"

#: src/why-rust.md:14
msgid ""
"Experience with C or C++: Rust eliminates a whole class of _runtime errors_ "
"via the borrow checker. You get performance like in C and C++, but you don't "
"have the memory unsafety issues. In addition, you get a modern language with "
"constructs like pattern matching and built-in dependency management."
msgstr ""
"Experiencia con C o C++: Rust elimina una clase completa de _errores de "
"runtime_ mediante el _borrow checker_. Obtienes un rendimiento similar al de "
"C y C++, pero no tienes problemas de seguridad en la memoria. Adem√°s, "
"obtienes un lenguaje moderno con elementos como la coincidencia de patrones "
"y la gesti√≥n de dependencias integrado."

#: src/why-rust.md:19
msgid ""
"Experience with Java, Go, Python, JavaScript...: You get the same memory "
"safety as in those languages, plus a similar high-level language feeling. In "
"addition you get fast and predictable performance like C and C++ (no garbage "
"collector) as well as access to low-level hardware (should you need it)"
msgstr ""
"Experiencia con Java, Go, Python, JavaScript, etc.: Consigues la misma "
"seguridad en la memoria que en √©stos lenguajes, adem√°s de una sensaci√≥n "
"similar a la de un lenguaje de alto nivel. Tambi√©n consigues un rendimiento "
"r√°pido y predecible como en C y C++ (sin recolector de memoria residual), "
"as√≠ como acceso a hardware de bajo nivel (si lo necesitas)."

#: src/why-rust/compile-time.md:3
msgid "Static memory management at compile time:"
msgstr "Gesti√≥n est√°tica de la memoria en tiempo de compilaci√≥n:"

#: src/why-rust/compile-time.md:5
msgid "No uninitialized variables."
msgstr "No hay variables no inicializadas."

#: src/why-rust/compile-time.md:6
msgid "No memory leaks (_mostly_, see notes)."
msgstr "No hay p√©rdidas de memoria (_casi siempre_, consulta las notas)."

#: src/why-rust/compile-time.md:7
msgid "No double-frees."
msgstr "No hay errores double free."

#: src/why-rust/compile-time.md:8
msgid "No use-after-free."
msgstr "No hay errores use-after-free."

#: src/why-rust/compile-time.md:9
msgid "No `NULL` pointers."
msgstr "No hay punteros `NULL`."

#: src/why-rust/compile-time.md:10
msgid "No forgotten locked mutexes."
msgstr "No se olvidan las exclusiones mutuas bloqueadas."

#: src/why-rust/compile-time.md:11
msgid "No data races between threads."
msgstr "No hay condiciones de carrera de datos entre hilos."

#: src/why-rust/compile-time.md:12
msgid "No iterator invalidation."
msgstr "No se invalidan los iteradores."

#: src/why-rust/compile-time.md:16
msgid ""
"It is possible to produce memory leaks in (safe) Rust. Some examples are:"
msgstr ""
"Es posible producir p√©rdidas de memoria en (_safe_) Rust. Estos son algunos "
"ejemplos:"

#: src/why-rust/compile-time.md:19
msgid ""
"You can use [`Box::leak`](https://doc.rust-lang.org/std/boxed/struct.Box."
"html#method.leak) to leak a pointer. A use of this could be to get runtime-"
"initialized and runtime-sized static variables"
msgstr ""
"Puedes usar [`Box::leak`](https://doc.rust-lang.org/std/boxed/struct.Box."
"html#method.leak) para perder un puntero. Esto podr√≠a usarse para obtener "
"variables est√°ticas iniciadas y medidas en _runtime_."

#: src/why-rust/compile-time.md:21
msgid ""
"You can use [`std::mem::forget`](https://doc.rust-lang.org/std/mem/fn.forget."
"html) to make the compiler \"forget\" about a value (meaning the destructor "
"is never run)."
msgstr ""
"Puedes usar [`std::mem::forget`](https://doc.rust-lang.org/std/mem/fn.forget."
"html) para que el compilador \"olvide\" un valor (lo que significa que el "
"destructor nunca se ejecuta)."

#: src/why-rust/compile-time.md:23
msgid ""
"You can also accidentally create a [reference cycle](https://doc.rust-lang."
"org/book/ch15-06-reference-cycles.html) with `Rc` or `Arc`."
msgstr ""
"Tambi√©n puedes crear por accidente una [referencia circular](https://doc."
"rust-lang.org/book/ch15-06-reference-cycles.html) con `Rc` o `Arc`."

#: src/why-rust/compile-time.md:25
msgid ""
"In fact, some will consider infinitely populating a collection a memory leak "
"and Rust does not protect from those."
msgstr ""
"De hecho, algunos consideran que poblar de forma infinita una colecci√≥n es "
"una fuga de memoria y Rust no protege de ellas."

#: src/why-rust/compile-time.md:28
msgid ""
"For the purpose of this course, \"No memory leaks\" should be understood as "
"\"Pretty much no _accidental_ memory leaks\"."
msgstr ""
"En este curso, \"sin p√©rdidas de memoria\" debe entenderse como\n"
" \"casi ninguna p√©rdida de memoria _accidental_\"."

#: src/why-rust/runtime.md:3
msgid "No undefined behavior at runtime:"
msgstr "No hay comportamientos indefinidos en _runtime_:"

#: src/why-rust/runtime.md:5
msgid "Array access is bounds checked."
msgstr "Se comprueban los l√≠mites de acceso a los arrays."

#: src/why-rust/runtime.md:6
msgid "Integer overflow is defined (panic or wrap-around)."
msgstr "Se define el desbordamiento de enteros (_panic_ o _wrap-around_)."

#: src/why-rust/runtime.md:12
msgid ""
"Integer overflow is defined via the [`overflow-checks`](https://doc.rust-"
"lang.org/rustc/codegen-options/index.html#overflow-checks) compile-time "
"flag. If enabled, the program will panic (a controlled crash of the "
"program), otherwise you get wrap-around semantics. By default, you get "
"panics in debug mode (`cargo build`) and wrap-around in release mode (`cargo "
"build --release`)."
msgstr ""
"El overflow en Integer es definido v√≠a un _flag_ en tiempo de compilaci√≥n. "
"Las opciones son alertas panic (un crash controlado del programa) o una "
"sem√°ntica de _wrap-around_. Por defecto, obtienes el alerta en modo "
"depuraci√≥n (`cargo build`) y _wrap-around_ en el modo release (`cargo build ‚Äî"

#: src/why-rust/runtime.md:18
msgid ""
"Bounds checking cannot be disabled with a compiler flag. It can also not be "
"disabled directly with the `unsafe` keyword. However, `unsafe` allows you to "
"call functions such as `slice::get_unchecked` which does not do bounds "
"checking."
msgstr ""
"La comprobaci√≥n de l√≠mites no se puede deshabilitar con una bandera de "
"compilador. Tampoco se puede inhabilitar directamente con la palabra clave "
"`unsafe`. Sin embargo, `unsafe` te permite llamar a funciones como `slice::"
"get_unchecked`, que no realiza comprobaciones de l√≠mites."

#: src/why-rust/modern.md:3
msgid "Rust is built with all the experience gained in the last decades."
msgstr ""
"Rust se ha creado a partir de toda la experiencia obtenida en las √∫ltimas "
"d√©cadas."

#: src/why-rust/modern.md:5
msgid "Language Features"
msgstr "Caracter√≠sticas del Lenguaje"

#: src/why-rust/modern.md:7
msgid "Enums and pattern matching."
msgstr "Enumeraciones (_Enums_) y coincidencia de patrones."

#: src/why-rust/modern.md:8
msgid "Generics."
msgstr "Gen√©ricos"

#: src/why-rust/modern.md:9
msgid "No overhead FFI."
msgstr "Sin _overhead_ de FFI."

#: src/why-rust/modern.md:10
msgid "Zero-cost abstractions."
msgstr "Abstracciones sin coste."

#: src/why-rust/modern.md:12
msgid "Tooling"
msgstr "Herramientas"

#: src/why-rust/modern.md:14
msgid "Great compiler errors."
msgstr "Excelentes errores de compilaci√≥n."

#: src/why-rust/modern.md:15
msgid "Built-in dependency manager."
msgstr "Gestor de dependencias integrado."

#: src/why-rust/modern.md:16
msgid "Built-in support for testing."
msgstr "Asistencia integrada para pruebas."

#: src/why-rust/modern.md:17
msgid "Excellent Language Server Protocol support."
msgstr "Compatibilidad excelente con el protocolo del servidor de lenguaje."

#: src/why-rust/modern.md:23
msgid ""
"Zero-cost abstractions, similar to C++, means that you don't have to 'pay' "
"for higher-level programming constructs with memory or CPU. For example, "
"writing a loop using `for` should result in roughly the same low level "
"instructions as using the `.iter().fold()` construct."
msgstr ""
"Las abstracciones sin coste, similares a las de C++, significan que no "
"tienes que 'pagar' por construcciones de programaci√≥n de alto nivel con "
"memoria o CPU. Por ejemplo, escribir un bucle utilizando `for` deber√≠a dar "
"como resultado pr√°cticamente las mismas instrucciones de bajo nivel que con "
"la construcci√≥n `.iter().fold()`."

#: src/why-rust/modern.md:28
msgid ""
"It may be worth mentioning that Rust enums are 'Algebraic Data Types', also "
"known as 'sum types', which allow the type system to express things like "
"`Option<T>` and `Result<T, E>`."
msgstr ""
"Merece la pena mencionar que los enums de Rust son tipos de datos "
"algebraicos, tambi√©n denominados 'tipos suma', que permiten al sistema de "
"tipos expresar cosas como `Option<T>` y `Result<T, E>`."

#: src/why-rust/modern.md:32
msgid ""
"Remind people to read the errors --- many developers have gotten used to "
"ignore lengthy compiler output. The Rust compiler is significantly more "
"talkative than other compilers. It will often provide you with _actionable_ "
"feedback, ready to copy-paste into your code."
msgstr ""
"Recuerda a los alumnos que lean los errores, ya que muchos desarrolladores "
"se han acostumbrado a ignorar los largos resultados del compilador. El "
"compilador de Rust es mucho m√°s comunicativo que otros. A menudo, te "
"proporcionar√° sugerencias _pr√°cticas_, que puedes copiar y pegar en tu "
"c√≥digo."

#: src/why-rust/modern.md:37
msgid ""
"The Rust standard library is small compared to languages like Java, Python, "
"and Go. Rust does not come with several things you might consider standard "
"and essential:"
msgstr ""
"La biblioteca est√°ndar de Rust es peque√±a en comparaci√≥n con la de lenguajes "
"como Java, Python o Go. Rust no incluye elementos que se podr√≠an considerar "
"est√°ndar o esenciales:"

#: src/why-rust/modern.md:41
msgid "a random number generator, but see [rand](https://docs.rs/rand/)."
msgstr ""
"un generador de n√∫meros aleatorios, pero consulta [rand](https://docs.rs/"
"rand/)."

#: src/why-rust/modern.md:42
msgid "support for SSL or TLS, but see [rusttls](https://docs.rs/rustls/)."
msgstr ""
"compatibilidad con SSL o TLS, pero consulta [rusttls](https://docs.rs/"
"rustls/)."

#: src/why-rust/modern.md:43
msgid "support for JSON, but see [serde_json](https://docs.rs/serde_json/)."
msgstr ""
"Compatibilidad con JSON, pero consulta [serde_json](https://docs.rs/"
"serde_json/)."

#: src/why-rust/modern.md:45
msgid ""
"The reasoning behind this is that functionality in the standard library "
"cannot go away, so it has to be very stable. For the examples above, the "
"Rust community is still working on finding the best solution --- and perhaps "
"there isn't a single \"best solution\" for some of these things."
msgstr ""
"La raz√≥n es que la funcionalidad de la biblioteca est√°ndar no puede "
"desaparecer, por lo que tiene que ser muy estable. En los ejemplos "
"anteriores, la comunidad de Rust todav√≠a est√° trabajando para encontrar la "
"mejor soluci√≥n, y puede que no exista una √∫nica \"mejor soluci√≥n\" para "
"algunas de estas cuestiones."

#: src/why-rust/modern.md:50
msgid ""
"Rust comes with a built-in package manager in the form of Cargo and this "
"makes it trivial to download and compile third-party crates. A consequence "
"of this is that the standard library can be smaller."
msgstr ""
"Rust incluye un gestor de paquetes integrado con la forma de Cargo, lo que "
"hace que resulte sencillo descargar y compilar crates de terceros. Como "
"consecuencia, la biblioteca est√°ndar puede ser m√°s peque√±a."

#: src/why-rust/modern.md:54
msgid ""
"Discovering good third-party crates can be a problem. Sites like <https://"
"lib.rs/> help with this by letting you compare health metrics for crates to "
"find a good and trusted one."
msgstr ""
"Encontrar buenos crates de terceros puede ser un problema. Sitios como "
"<https://lib.rs/> te ayudan a comparar m√©tricas de salud de crates para "
"encontrar uno bueno y fiable."

#: src/why-rust/modern.md:58
msgid ""
"[rust-analyzer](https://rust-analyzer.github.io/) is a well supported LSP "
"implementation used in major IDEs and text editors."
msgstr ""
"[rust-analyzer](https://rust-analyzer.github.io/) es una implementaci√≥n de "
"LSP bien respaldada y utilizada en los principales IDE y editores de texto."

#: src/basic-syntax.md:3
msgid "Much of the Rust syntax will be familiar to you from C, C++ or Java:"
msgstr ""
"Gran parte de la sintaxis de Rust te resultar√° familiar de C, C++ o Java:"

#: src/basic-syntax.md:5
msgid "Blocks and scopes are delimited by curly braces."
msgstr "Los bloques y √°mbitos est√°n delimitados por llaves."

#: src/basic-syntax.md:6
msgid ""
"Line comments are started with `//`, block comments are delimited by `/* ... "
"*/`."
msgstr ""
"Los comentarios de l√≠nea empiezan por `//`, mientras que los comentarios de "
"bloque est√°n delimitados por `/* ... */`."

#: src/basic-syntax.md:8
msgid "Keywords like `if` and `while` work the same."
msgstr "Palabras clave como `if` y `while` funcionan igual."

#: src/basic-syntax.md:9
msgid "Variable assignment is done with `=`, comparison is done with `==`."
msgstr ""
"La asignaci√≥n de variables se realiza con `=` y la comparaci√≥n con `==`."

#: src/basic-syntax/scalar-types.md:3 src/basic-syntax/compound-types.md:3
#: src/exercises/day-3/safe-ffi-wrapper.md:16
msgid "Types"
msgstr "Tipos"

#: src/basic-syntax/scalar-types.md:3 src/basic-syntax/compound-types.md:3
msgid "Literals"
msgstr "Literales"

#: src/basic-syntax/scalar-types.md:5
msgid "Signed integers"
msgstr "Enteros con signo"

#: src/basic-syntax/scalar-types.md:5
msgid "`i8`, `i16`, `i32`, `i64`, `i128`, `isize`"
msgstr ""

#: src/basic-syntax/scalar-types.md:5
msgid "`-10`, `0`, `1_000`, `123_i64`"
msgstr ""

#: src/basic-syntax/scalar-types.md:6
msgid "Unsigned integers"
msgstr "Enteros sin signo"

#: src/basic-syntax/scalar-types.md:6
msgid "`u8`, `u16`, `u32`, `u64`, `u128`, `usize`"
msgstr ""

#: src/basic-syntax/scalar-types.md:6
msgid "`0`, `123`, `10_u16`"
msgstr ""

#: src/basic-syntax/scalar-types.md:7
msgid "Floating point numbers"
msgstr "N√∫meros de coma flotante"

#: src/basic-syntax/scalar-types.md:7
msgid "`f32`, `f64`"
msgstr ""

#: src/basic-syntax/scalar-types.md:7
msgid "`3.14`, `-10.0e20`, `2_f32`"
msgstr ""

#: src/basic-syntax/scalar-types.md:8
msgid "Strings"
msgstr "Cadenas de texto (_Strings_)"

#: src/basic-syntax/scalar-types.md:8
msgid "`&str`"
msgstr ""

#: src/basic-syntax/scalar-types.md:8
msgid "`\"foo\"`, `\"two\\nlines\"`"
msgstr ""

#: src/basic-syntax/scalar-types.md:9
msgid "Unicode scalar values"
msgstr "Valores escalares Unicode"

#: src/basic-syntax/scalar-types.md:9
msgid "`char`"
msgstr ""

#: src/basic-syntax/scalar-types.md:9
msgid "`'a'`, `'Œ±'`, `'‚àû'`"
msgstr ""

#: src/basic-syntax/scalar-types.md:10
msgid "Booleans"
msgstr "Booleanos"

#: src/basic-syntax/scalar-types.md:10
msgid "`bool`"
msgstr ""

#: src/basic-syntax/scalar-types.md:10
msgid "`true`, `false`"
msgstr ""

#: src/basic-syntax/scalar-types.md:12
msgid "The types have widths as follows:"
msgstr "Los tipos tienen la siguiente anchura:"

#: src/basic-syntax/scalar-types.md:14
msgid "`iN`, `uN`, and `fN` are _N_ bits wide,"
msgstr "`iN`, `uN`, and `fN` son _N_ bits de capacidad,"

#: src/basic-syntax/scalar-types.md:15
msgid "`isize` and `usize` are the width of a pointer,"
msgstr "`isize` y `usize` tienen el ancho de un puntero,"

#: src/basic-syntax/scalar-types.md:16
msgid "`char` is 32 bits wide,"
msgstr "`char` tiene un tama√±o de 32 bits,"

#: src/basic-syntax/scalar-types.md:17
msgid "`bool` is 8 bits wide."
msgstr "`bool` tiene 8 bits de ancho."

#: src/basic-syntax/scalar-types.md:21
msgid "There are a few syntaxes which are not shown above:"
msgstr "Hay algunas sintaxis que no se han mostrado anteriormente:"

#: src/basic-syntax/scalar-types.md:23
msgid ""
"Raw strings allow you to create a `&str` value with escapes disabled: "
"`r\"\\n\" == \"\\\\n\"`. You can embed double-quotes by using an equal "
"amount of `#` on either side of the quotes:"
msgstr ""
"Las cadenas sin formato te permiten crear un valor `&str` con los escapes "
"inhabilitados: `r\"\\n\" == \"\\\\n\"`. Puedes insertar comillas dobles con "
"la misma cantidad de `#` a cada lado de ellas:"

#: src/basic-syntax/scalar-types.md:27
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    println!(r#\"<a href=\"link.html\">link</a>\"#);\n"
"    println!(\"<a href=\\\"link.html\\\">link</a>\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/scalar-types.md:34
msgid "Byte strings allow you to create a `&[u8]` value directly:"
msgstr "Las cadenas de bytes te permiten crear un valor `&[u8]` directamente:"

#: src/basic-syntax/scalar-types.md:36
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"{:?}\", b\"abc\");\n"
"    println!(\"{:?}\", &[97, 98, 99]);\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/scalar-types.md:43
msgid ""
"All underscores in numbers can be left out, they are for legibility only. So "
"`1_000` can be written as `1000` (or `10_00`), and `123_i64` can be written "
"as `123i64`."
msgstr ""
"Todos guiones bajos en los n√∫meros pueden no utilizarse, ya que solo sirven "
"para facilitar la lectura. Por lo tanto, `1_000` se puede escribir como "
"`1000` (o `10_00`), y `123_i64` se puede escribir como `123i64`."

#: src/basic-syntax/compound-types.md:5
msgid "Arrays"
msgstr "Arrays"

#: src/basic-syntax/compound-types.md:5
msgid "`[T; N]`"
msgstr ""

#: src/basic-syntax/compound-types.md:5
msgid "`[20, 30, 40]`, `[0; 3]`"
msgstr ""

#: src/basic-syntax/compound-types.md:6
msgid "Tuples"
msgstr "Tuplas"

#: src/basic-syntax/compound-types.md:6
msgid "`()`, `(T,)`, `(T1, T2)`, ..."
msgstr ""

#: src/basic-syntax/compound-types.md:6
msgid "`()`, `('x',)`, `('x', 1.2)`, ..."
msgstr ""

#: src/basic-syntax/compound-types.md:8
msgid "Array assignment and access:"
msgstr "Asignaci√≥n y acceso a arrays:"

#: src/basic-syntax/compound-types.md:10
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut a: [i8; 10] = [42; 10];\n"
"    a[5] = 0;\n"
"    println!(\"a: {:?}\", a);\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/compound-types.md:18
msgid "Tuple assignment and access:"
msgstr "Asignaci√≥n y acceso a tuplas:"

#: src/basic-syntax/compound-types.md:20
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let t: (i8, bool) = (7, true);\n"
"    println!(\"1st index: {}\", t.0);\n"
"    println!(\"2nd index: {}\", t.1);\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/compound-types.md:32
msgid "Arrays:"
msgstr "Arrays:"

#: src/basic-syntax/compound-types.md:34
msgid ""
"A value of the array type `[T; N]` holds `N` (a compile-time constant) "
"elements of the same type `T`. Note that the length of the array is _part of "
"its type_, which means that `[u8; 3]` and `[u8; 4]` are considered two "
"different types."
msgstr ""
"Un valor del tipo array `[T; N]` contiene `N` (una constante en tiempo de "
"compilaci√≥n) elementos del mismo tipo `T`. Ten en cuenta que la longitud del "
"array es *parte de su tipo*, lo que significa que `[u8; 3]` y `[u8; 4]` se "
"consideran dos tipos diferentes."

#: src/basic-syntax/compound-types.md:38
msgid "We can use literals to assign values to arrays."
msgstr "Podemos usar literales para asignar valores a arrays."

#: src/basic-syntax/compound-types.md:40
msgid ""
"In the main function, the print statement asks for the debug implementation "
"with the `?` format parameter: `{}` gives the default output, `{:?}` gives "
"the debug output. We could also have used `{a}` and `{a:?}` without "
"specifying the value after the format string."
msgstr ""
"En la funci√≥n _main_, la instrucci√≥n de impresi√≥n solicita la implementaci√≥n "
"de depuraci√≥n con el par√°metro de formato `?`: `{}` ofrece la salida "
"predeterminada y `{:?}` ofrece la salida de depuraci√≥n. Tambi√©n se podr√≠a "
"haber usado `{a}` y `{a:?}` sin especificar el valor despu√©s de la cadena de "
"formato."

#: src/basic-syntax/compound-types.md:45
msgid ""
"Adding `#`, eg `{a:#?}`, invokes a \"pretty printing\" format, which can be "
"easier to read."
msgstr ""
"Si se a√±ade `#`, por ejemplo `{a:#?}`, se da formato al texto para facilitar "
"la lectura."

#: src/basic-syntax/compound-types.md:47
msgid "Tuples:"
msgstr "Tuplas:"

#: src/basic-syntax/compound-types.md:49
msgid "Like arrays, tuples have a fixed length."
msgstr "Al igual que los arrays, las tuplas tienen una longitud fija."

#: src/basic-syntax/compound-types.md:51
msgid "Tuples group together values of different types into a compound type."
msgstr "Las tuplas agrupan valores de diferentes tipos en un tipo compuesto."

#: src/basic-syntax/compound-types.md:53
msgid ""
"Fields of a tuple can be accessed by the period and the index of the value, "
"e.g. `t.0`, `t.1`."
msgstr ""
"Se puede acceder a los campos de una tupla por el punto y el √≠ndice del "
"valor, por ejemplo, `t.0`, `t.1`."

#: src/basic-syntax/compound-types.md:55
msgid ""
"The empty tuple `()` is also known as the \"unit type\". It is both a type, "
"and the only valid value of that type - that is to say both the type and its "
"value are expressed as `()`. It is used to indicate, for example, that a "
"function or expression has no return value, as we'll see in a future slide. "
msgstr ""
"La tupla vac√≠a `()` tambi√©n se conoce como \"tipo unitario\". Es a la vez un "
"tipo y el √∫nico valor v√°lido de ese tipo, es decir, tanto el tipo como su "
"valor se expresan como `()`. Se usa para indicar, por ejemplo, que una "
"funci√≥n o expresi√≥n no tiene valor de retorno, como veremos en una "
"diapositiva posterior."

#: src/basic-syntax/compound-types.md:59
msgid ""
"You can think of it as `void` that can be familiar to you from other  "
"programming languages."
msgstr ""
"Podr√≠amos pensar en ello como `void`, que quiz√° resulte familiar de otros "
"lenguajes de programaci√≥n."

#: src/basic-syntax/references.md:3
msgid "Like C++, Rust has references:"
msgstr "Al igual que C++, Rust tiene referencias:"

#: src/basic-syntax/references.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x: i32 = 10;\n"
"    let ref_x: &mut i32 = &mut x;\n"
"    *ref_x = 20;\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/references.md:14
msgid "Some notes:"
msgstr "Algunas notas:"

#: src/basic-syntax/references.md:16
msgid ""
"We must dereference `ref_x` when assigning to it, similar to C and C++ "
"pointers."
msgstr ""
"Debemos desreferenciar `ref_x` al asignarle un valor, de forma similar a los "
"punteros de C y C++."

#: src/basic-syntax/references.md:17
msgid ""
"Rust will auto-dereference in some cases, in particular when invoking "
"methods (try `ref_x.count_ones()`)."
msgstr ""
"Rust realizar√° una desreferencia autom√°tica en algunos casos, en especial al "
"invocar m√©todos (prueba `ref_x.count_ones()`)."

#: src/basic-syntax/references.md:19
msgid ""
"References that are declared as `mut` can be bound to different values over "
"their lifetime."
msgstr ""
"Las referencias que se declaran como `mut` se pueden vincular a distintos "
"valores durante su tiempo de vida."

#: src/basic-syntax/references.md:25
msgid ""
"Be sure to note the difference between `let mut ref_x: &i32` and `let ref_x: "
"&mut i32`. The first one represents a mutable reference which can be bound "
"to different values, while the second represents a reference to a mutable "
"value."
msgstr ""
"Ten en cuenta la diferencia entre `let mut ref_x: &i32` y `let ref_x: &mut "
"i32`. La primera representa una referencia mutable que se puede vincular a "
"distintos valores, mientras que la segunda representa una referencia a un "
"valor mutable."

#: src/basic-syntax/references-dangling.md:3
msgid "Rust will statically forbid dangling references:"
msgstr "Rust prohibir√° est√°ticamente las referencias colgantes:"

#: src/basic-syntax/references-dangling.md:5
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let ref_x: &i32;\n"
"    {\n"
"        let x: i32 = 10;\n"
"        ref_x = &x;\n"
"    }\n"
"    println!(\"ref_x: {ref_x}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/references-dangling.md:16
msgid "A reference is said to \"borrow\" the value it refers to."
msgstr ""
"Se dice que una referencia \"toma prestado\" el valor al que hace referencia."

#: src/basic-syntax/references-dangling.md:17
msgid ""
"Rust is tracking the lifetimes of all references to ensure they live long "
"enough."
msgstr ""
"Rust hace un seguimiento del tiempo de vida de todas las referencias para "
"asegurarse de que duran lo suficiente."

#: src/basic-syntax/references-dangling.md:19
msgid "We will talk more about borrowing when we get to ownership."
msgstr ""
"M√°s adelante hablaremos de los pr√©stamos cuando lleguemos a la parte de "
"propiedad."

#: src/basic-syntax/slices.md:3
msgid "A slice gives you a view into a larger collection:"
msgstr "Un _slice_ ofrece una visi√≥n de una colecci√≥n m√°s amplia:"

#: src/basic-syntax/slices.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut a: [i32; 6] = [10, 20, 30, 40, 50, 60];\n"
"    println!(\"a: {a:?}\");\n"
"\n"
"    let s: &[i32] = &a[2..4];\n"
"\n"
"    println!(\"s: {s:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/slices.md:16
msgid "Slices borrow data from the sliced type."
msgstr "Los slices toman prestados datos del tipo slice."

#: src/basic-syntax/slices.md:17
msgid "Question: What happens if you modify `a[3]` right before printing `s`?"
msgstr ""
"Pregunta: ¬øQu√© ocurre si se modifica `a[3]` justo antes de imprimir `s`?"

#: src/basic-syntax/slices.md:21
msgid ""
"We create a slice by borrowing `a` and specifying the starting and ending "
"indexes in brackets."
msgstr ""
"Creamos un slice tomando prestado `a` y especificando entre par√©ntesis los "
"√≠ndices de inicio y de fin."

#: src/basic-syntax/slices.md:23
msgid ""
"If the slice starts at index 0, Rust‚Äôs range syntax allows us to drop the "
"starting index, meaning that `&a[0..a.len()]` and `&a[..a.len()]` are "
"identical."
msgstr ""
"Si el slice comienza en el √≠ndice 0, la sintaxis de intervalo de Rust nos "
"permite eliminar el √≠ndice inicial, lo que significa que `&a[0..a.len()]` y "
"`&a[..a.len()]` son id√©nticos."

#: src/basic-syntax/slices.md:25
msgid ""
"The same is true for the last index, so `&a[2..a.len()]` and `&a[2..]` are "
"identical."
msgstr ""
"Lo mismo ocurre con el √∫ltimo √≠ndice, por lo que `&a[2..a.len()]` y "
"`&a[2..]` son id√©nticos."

#: src/basic-syntax/slices.md:27
msgid ""
"To easily create a slice of the full array, we can therefore use `&a[..]`."
msgstr ""
"Para crear f√°cilmente un slice del array completo, podemos usar `&a[..]`."

#: src/basic-syntax/slices.md:29
msgid ""
"`s` is a reference to a slice of `i32`s. Notice that the type of `s` "
"(`&[i32]`) no longer mentions the array length. This allows us to perform "
"computation on slices of different sizes."
msgstr ""
"`s` es una referencia a un slice de `i32`s. Ten en cuenta que el tipo de `s` "
"(`&[i32]`) ya no menciona la longitud del array. Esto nos permite realizar "
"c√°lculos en slices de diferentes tama√±os."

#: src/basic-syntax/slices.md:31
msgid ""
"Slices always borrow from another object. In this example, `a` has to remain "
"'alive' (in scope) for at least as long as our slice. "
msgstr ""
"Los slices siempre tienen pr√©stamos de otros objetos. En este ejemplo, `a` "
"tiene que permanecer \"con vida\" (en el √°mbito) al menos durante el tiempo "
"que dure el slice. "

#: src/basic-syntax/slices.md:33
msgid ""
"The question about modifying `a[3]` can spark an interesting discussion, but "
"the answer is that for memory safety reasons you cannot do it through `a` at "
"this point in the execution, but you can read the data from both `a` and `s` "
"safely. It works before you created the slice, and again after the "
"`println`, when the slice is no longer used. More details will be explained "
"in the borrow checker section."
msgstr ""
"La cuesti√≥n sobre la modificaci√≥n de `a[3]` puede suscitar un debate "
"interesante, pero la respuesta es que, por razones de seguridad de memoria, "
"no se puede hacer mediante `a` en este punto de la ejecuci√≥n, pero s√≠ se "
"pueden leer los datos de `a` y `s` de forma segura. Funciona antes de crear "
"el slice y despu√©s de `println`, cuando el slice ya no se utiliza. En la "
"secci√≥n que trata sobre el _borrow checker_ se dar√° m√°s informaci√≥n."

#: src/basic-syntax/string-slices.md:1
msgid "`String` vs `str`"
msgstr "`String` o `str`"

#: src/basic-syntax/string-slices.md:3
msgid "We can now understand the two string types in Rust:"
msgstr "Ahora podemos entender los dos tipos de cadenas de Rust:"

#: src/basic-syntax/string-slices.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: &str = \"World\";\n"
"    println!(\"s1: {s1}\");\n"
"\n"
"    let mut s2: String = String::from(\"Hello \");\n"
"    println!(\"s2: {s2}\");\n"
"    s2.push_str(s1);\n"
"    println!(\"s2: {s2}\");\n"
"    \n"
"    let s3: &str = &s2[6..];\n"
"    println!(\"s3: {s3}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/string-slices.md:20
msgid "Rust terminology:"
msgstr "Terminolog√≠a de Rust:"

#: src/basic-syntax/string-slices.md:22
msgid "`&str` an immutable reference to a string slice."
msgstr "`&str` es una referencia inmutable a un slice de una cadena."

#: src/basic-syntax/string-slices.md:23
msgid "`String` a mutable string buffer."
msgstr "`String` es un b√∫fer de cadena mutable."

#: src/basic-syntax/string-slices.md:27
msgid ""
"`&str` introduces a string slice, which is an immutable reference to UTF-8 "
"encoded string data  stored in a block of memory. String literals "
"(`‚ÄùHello‚Äù`), are stored in the program‚Äôs binary."
msgstr ""
"`&str` introduce un slice de cadena, que es una referencia inmutable a los "
"datos de cadena codificados en UTF-8 y almacenados en un bloque de memoria. "
"Los literales de cadena (`\"Hello\"`) se almacenan en el binario del "
"programa."

#: src/basic-syntax/string-slices.md:30
msgid ""
"Rust‚Äôs `String` type is a wrapper around a vector of bytes. As with a "
"`Vec<T>`, it is owned."
msgstr ""
"El tipo `String` de Rust es un envoltorio que rodea a un vector de bytes. "
"Como sucede con `Vec<T>`, tiene propiedad."

#: src/basic-syntax/string-slices.md:32
msgid ""
"As with many other types `String::from()` creates a string from a string "
"literal; `String::new()`  creates a new empty string, to which string data "
"can be added using the `push()` and `push_str()` methods."
msgstr ""
"Al igual que ocurre con muchos otros tipos, `String::from()` crea una cadena "
"a partir de un literal de cadena. `String::new()` crea una cadena vac√≠a a la "
"que se pueden a√±adir los datos de la cadena mediante los m√©todos `push()` y "
"`push_str()`."

#: src/basic-syntax/string-slices.md:35
msgid ""
"The `format!()` macro is a convenient way to generate an owned string from "
"dynamic values. It  accepts the same format specification as `println!()`."
msgstr ""
"La macro `format!()` es una forma pr√°ctica de generar una cadena propia a "
"partir de valores din√°micos. Acepta la misma especificaci√≥n de formato que "
"`println!()`."

#: src/basic-syntax/string-slices.md:38
msgid ""
"You can borrow `&str` slices from `String` via `&` and optionally range "
"selection."
msgstr ""
"Puedes tomar prestados slices `&str` desde `String` mediante `&` y, si "
"quieres, puedes seleccionar intervalos."

#: src/basic-syntax/string-slices.md:40
msgid ""
"For C++ programmers: think of `&str` as `const char*` from C++, but the one "
"that always points  to a valid string in memory. Rust `String` is a rough "
"equivalent of `std::string` from C++  (main difference: it can only contain "
"UTF-8 encoded bytes and will never use a small-string optimization)."
msgstr ""
"Para los programadores de C++: piensa en `&str` como el `const char*` de C+"
"+, pero el que siempre apunta a una cadena v√°lida en la memoria. `String` de "
"Rust es parecido a `std::string` de C++  (la diferencia principal es que "
"solo puede contener bytes codificados en UTF-8 y nunca utilizar√° una "
"optimizaci√≥n de cadena peque√±a)."

#: src/basic-syntax/functions.md:3
msgid ""
"A Rust version of the famous [FizzBuzz](https://en.wikipedia.org/wiki/"
"Fizz_buzz) interview question:"
msgstr ""
"Una versi√≥n de Rust de la famosa pregunta de la entrevista de [FizzBuzz]"
"(https://es.wikipedia.org/wiki/Fizz_buzz):"

#: src/basic-syntax/functions.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    print_fizzbuzz_to(20);\n"
"}\n"
"\n"
"fn is_divisible(n: u32, divisor: u32) -> bool {\n"
"    if divisor == 0 {\n"
"        return false;\n"
"    }\n"
"    n % divisor == 0\n"
"}\n"
"\n"
"fn fizzbuzz(n: u32) -> String {\n"
"    let fizz = if is_divisible(n, 3) { \"fizz\" } else { \"\" };\n"
"    let buzz = if is_divisible(n, 5) { \"buzz\" } else { \"\" };\n"
"    if fizz.is_empty() && buzz.is_empty() {\n"
"        return format!(\"{n}\");\n"
"    }\n"
"    format!(\"{fizz}{buzz}\")\n"
"}\n"
"\n"
"fn print_fizzbuzz_to(n: u32) {\n"
"    for i in 1..=n {\n"
"        println!(\"{}\", fizzbuzz(i));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/functions.md:35
msgid ""
"We refer in `main` to a function written below. Neither forward declarations "
"nor headers are necessary. "
msgstr ""
"En `main` hacemos referencia a una funci√≥n escrita m√°s abajo. No se "
"necesitan declaraciones de redirecci√≥n ni encabezados. "

#: src/basic-syntax/functions.md:36
msgid ""
"Declaration parameters are followed by a type (the reverse of some "
"programming languages), then a return type."
msgstr ""
"Los par√°metros de declaraci√≥n van seguidos de un tipo (al contrario que en "
"algunos lenguajes de programaci√≥n) y, a continuaci√≥n, de un tipo de "
"resultado devuelto."

#: src/basic-syntax/functions.md:37
msgid ""
"The last expression in a function body (or any block) becomes the return "
"value. Simply omit the `;` at the end of the expression."
msgstr ""
"La √∫ltima expresi√≥n del cuerpo de una funci√≥n (o de cualquier bloque) se "
"convierte en el valor devuelto. Basta con omitir el car√°cter `;` al final de "
"la expresi√≥n."

#: src/basic-syntax/functions.md:38
msgid ""
"Some functions have no return value, and return the 'unit type', `()`. The "
"compiler will infer this if the `-> ()` return type is omitted."
msgstr ""
"Algunas funciones no devuelven ning√∫n valor, devuelven el \"tipo unitario\", "
"`()`. El compilador deducir√° esto si se omite el tipo de retorno `-> ()`."

#: src/basic-syntax/functions.md:39
msgid ""
"The range expression in the `for` loop in `print_fizzbuzz_to()` contains "
"`=n`, which causes it to include the upper bound."
msgstr ""
"La expresi√≥n de intervalo del bucle `for` en `print_fizzbuzz_to()` contiene "
"`=n`, lo que hace que incluya el l√≠mite superior."

#: src/basic-syntax/rustdoc.md:3
msgid ""
"All language items in Rust can be documented using special `///` syntax."
msgstr ""
"Todos los elementos del lenguaje de Rust se pueden documentar con la "
"sintaxis especial `///`."

#: src/basic-syntax/rustdoc.md:5
msgid ""
"```rust,editable\n"
"/// Determine whether the first argument is divisible by the second "
"argument.\n"
"///\n"
"/// If the second argument is zero, the result is false.\n"
"fn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n"
"    if rhs == 0 {\n"
"        return false;  // Corner case, early return\n"
"    }\n"
"    lhs % rhs == 0     // The last expression in a block is the return "
"value\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/rustdoc.md:17
msgid ""
"The contents are treated as Markdown. All published Rust library crates are "
"automatically documented at [`docs.rs`](https://docs.rs) using the [rustdoc]"
"(https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html) tool. It is "
"idiomatic to document all public items in an API using this pattern."
msgstr ""
"El contenido se trata como Markdown. Todos los crates de la biblioteca de "
"Rust publicados se documentan autom√°ticamente\n"
" en [`docs.rs`](https://docs.rs) mediante la herramienta \n"
"[rustdoc](https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html). Es "
"propio\n"
"documentar todos los elementos p√∫blicos de una API usando este patr√≥n."

#: src/basic-syntax/rustdoc.md:24
msgid ""
"Show students the generated docs for the `rand` crate at [`docs.rs/rand`]"
"(https://docs.rs/rand)."
msgstr ""
"Muestra a los alumnos los documentos generados para el crate `rand` en "
"[`docs.rs/rand`](https://docs.rs/rand)."

#: src/basic-syntax/rustdoc.md:27
msgid ""
"This course does not include rustdoc on slides, just to save space, but in "
"real code they should be present."
msgstr ""
"Este curso no incluye diapositivas sobre rustdoc para ahorrar espacio, pero "
"deben aparecer en el c√≥digo real."

#: src/basic-syntax/rustdoc.md:30
msgid ""
"Inner doc comments are discussed later (in the page on modules) and need not "
"be addressed here."
msgstr ""
"Los comentarios internos de los documentos se tratar√°n m√°s adelante (en la "
"p√°gina de m√≥dulos), no es necesario tratarlos aqu√≠."

#: src/basic-syntax/rustdoc.md:33
msgid ""
"Rustdoc comments can contain code snippets that we can run and test using "
"`cargo test`. We will discuss these tests in the [Testing section](../"
"testing/doc-tests.html)."
msgstr ""
"Los comentarios de rustdoc pueden contener fragmentos de c√≥digo que podemos "
"ejecutar y probar utilizando `cargo test`. Hablaremos de esto en la [secci√≥n "
"de pruebas](../testing/doc-tests.html)."

#: src/basic-syntax/methods.md:3
msgid ""
"Methods are functions associated with a type. The `self` argument of a "
"method is an instance of the type it is associated with:"
msgstr ""
"Los m√©todos son funciones asociadas a un tipo. El argumento `self` de un "
"m√©todo es una instancia del tipo al que est√° asociada:"

#: src/basic-syntax/methods.md:6
msgid ""
"```rust,editable\n"
"struct Rectangle {\n"
"    width: u32,\n"
"    height: u32,\n"
"}\n"
"\n"
"impl Rectangle {\n"
"    fn area(&self) -> u32 {\n"
"        self.width * self.height\n"
"    }\n"
"\n"
"    fn inc_width(&mut self, delta: u32) {\n"
"        self.width += delta;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut rect = Rectangle { width: 10, height: 5 };\n"
"    println!(\"old area: {}\", rect.area());\n"
"    rect.inc_width(5);\n"
"    println!(\"new area: {}\", rect.area());\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/methods.md:30
msgid ""
"We will look much more at methods in today's exercise and in tomorrow's "
"class."
msgstr ""
"Abordaremos en mayor profundidad los m√©todos en el ejercicio de hoy y en la "
"clase de ma√±ana."

#: src/basic-syntax/methods.md:34
msgid "Add a static method called `Rectangle::new` and call this from `main`:"
msgstr ""
"A√±ade un m√©todo est√°tico denominado `Rectangle::new` y ll√°malo desde `main`:"

#: src/basic-syntax/methods.md:36
msgid ""
"```rust,editable,compile_fail\n"
"fn new(width: u32, height: u32) -> Rectangle {\n"
"    Rectangle { width, height }\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"fn new(width: u32, height: u32) -> Rectangle {\n"
"    Rectangle { width, height }\n"
"}\n"
"```"

#: src/basic-syntax/methods.md:42
msgid ""
"While _technically_, Rust does not have custom constructors, static methods "
"are commonly used to initialize structs (but don't have to). The actual "
"constructor, `Rectangle { width, height }`, could be called directly. See "
"the [Rustnomicon](https://doc.rust-lang.org/nomicon/constructors.html)."
msgstr ""
"Aunque _t√©cnicamente_ Rust no tiene constructores personalizados, los "
"m√©todos est√°ticos se utilizan habitualmente para inicializar estructuras, "
"pero no es obligatorio. El constructor real, `Rectangle { width, height }`, "
"podr√≠a llamarse directamente. Consulta el [Rustnomicon](https://doc.rust-"
"lang.org/nomicon/constructors.html)."

#: src/basic-syntax/methods.md:45
msgid ""
"Add a `Rectangle::square(width: u32)` constructor to illustrate that such "
"static methods can take arbitrary parameters."
msgstr ""
"A√±ade un constructor `Rectangle::square(width: u32)` para mostrar que esos "
"m√©todos est√°ticos puede utilizar par√°metros arbitrarios."

#: src/basic-syntax/functions-interlude.md:1
msgid "Function Overloading"
msgstr "Sobrecarga de funciones"

#: src/basic-syntax/functions-interlude.md:3
msgid "Overloading is not supported:"
msgstr "No se admite la sobrecarga:"

#: src/basic-syntax/functions-interlude.md:5
msgid "Each function has a single implementation:"
msgstr "Cada funci√≥n tiene una √∫nica implementaci√≥n:"

#: src/basic-syntax/functions-interlude.md:6
msgid "Always takes a fixed number of parameters."
msgstr "Siempre se utiliza un n√∫mero fijo de par√°metros."

#: src/basic-syntax/functions-interlude.md:7
msgid "Always takes a single set of parameter types."
msgstr "Siempre se utiliza un √∫nico conjunto de tipos de par√°metros."

#: src/basic-syntax/functions-interlude.md:8
msgid "Default values are not supported:"
msgstr "No se admiten valores predeterminados:"

#: src/basic-syntax/functions-interlude.md:9
msgid "All call sites have the same number of arguments."
msgstr "Todos los sitios de llamada tienen el mismo n√∫mero de argumentos."

#: src/basic-syntax/functions-interlude.md:10
msgid "Macros are sometimes used as an alternative."
msgstr "A veces, se utilizan macros como alternativa."

#: src/basic-syntax/functions-interlude.md:12
msgid "However, function parameters can be generic:"
msgstr "Sin embargo, los par√°metros de funci√≥n pueden ser gen√©ricos:"

#: src/basic-syntax/functions-interlude.md:14
msgid ""
"```rust,editable\n"
"fn pick_one<T>(a: T, b: T) -> T {\n"
"    if std::process::id() % 2 == 0 { a } else { b }\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"coin toss: {}\", pick_one(\"heads\", \"tails\"));\n"
"    println!(\"cash prize: {}\", pick_one(500, 1000));\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/functions-interlude.md:27
msgid ""
"When using generics, the standard library's `Into<T>` can provide a kind of "
"limited polymorphism on argument types. We will see more details in a later "
"section."
msgstr ""
"Cuando se utilizan gen√©ricos, el `Into<T>` de la biblioteca est√°ndar puede "
"proporcionar una especie de polimorfismo limitado en los tipos de "
"argumentos. Veremos m√°s informaci√≥n al respecto en una secci√≥n posterior."

#: src/exercises/day-1/morning.md:1
msgid "Day 1: Morning Exercises"
msgstr "D√≠a 1: ejercicios de la ma√±ana"

#: src/exercises/day-1/morning.md:3
msgid "In these exercises, we will explore two parts of Rust:"
msgstr "En estos ejercicios, estudiaremos dos partes de Rust:"

#: src/exercises/day-1/morning.md:5
msgid "Implicit conversions between types."
msgstr "Conversiones impl√≠citas entre tipos."

#: src/exercises/day-1/morning.md:7
msgid "Arrays and `for` loops."
msgstr "Arrays y bucles `for`."

#: src/exercises/day-1/morning.md:11
msgid "A few things to consider while solving the exercises:"
msgstr "Ten en cuenta lo siguiente a la hora de resolver los ejercicios:"

#: src/exercises/day-1/morning.md:13
msgid ""
"Use a local Rust installation, if possible. This way you can get auto-"
"completion in your editor. See the page about [Using Cargo](../../cargo.md) "
"for details on installing Rust."
msgstr ""
"Si es posible, utiliza una instalaci√≥n local de Rust. De esta forma, podr√°s "
"autocompletar datos en tu editor. Consulta la p√°gina sobre \\[c√≥mo usar "
"Cargo\\] para obtener m√°s informaci√≥n sobre c√≥mo instalar Rust."

#: src/exercises/day-1/morning.md:17
msgid "Alternatively, use the Rust Playground."
msgstr "Tambi√©n puedes usar el playground de Rust."

#: src/exercises/day-1/morning.md:19
msgid ""
"The code snippets are not editable on purpose: the inline code snippets lose "
"their state if you navigate away from the page."
msgstr ""
"Los fragmentos de c√≥digo no son editables a prop√≥sito: los que est√°n "
"insertados pierden su estado si se sale de la p√°gina."

#: src/exercises/day-1/morning.md:22 src/exercises/day-2/morning.md:11
#: src/exercises/day-3/morning.md:9 src/exercises/bare-metal/morning.md:7
#: src/exercises/concurrency/morning.md:12
msgid ""
"After looking at the exercises, you can look at the [solutions](solutions-"
"morning.md) provided."
msgstr ""
"Despu√©s de realizar los ejercicios, puedes consultar las [soluciones]"
"(solutions-morning.md) correspondientes."

#: src/exercises/day-1/implicit-conversions.md:3
msgid ""
"Rust will not automatically apply _implicit conversions_ between types "
"([unlike C++](https://en.cppreference.com/w/cpp/language/"
"implicit_conversion)). You can see this in a program like this:"
msgstr ""
"Rust no aplicar√° autom√°ticamente _conversiones impl√≠citas_ entre tipos ([a "
"diferencia de C++](https://en.cppreference.com/w/cpp/language/"
"implicit_conversion)). Puedes ver un ejemplo de esto en el siguiente "
"programa:"

#: src/exercises/day-1/implicit-conversions.md:6
msgid ""
"```rust,editable,compile_fail\n"
"fn multiply(x: i16, y: i16) -> i16 {\n"
"    x * y\n"
"}\n"
"\n"
"fn main() {\n"
"    let x: i8 = 15;\n"
"    let y: i16 = 1000;\n"
"\n"
"    println!(\"{x} * {y} = {}\", multiply(x, y));\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/implicit-conversions.md:19
msgid ""
"The Rust integer types all implement the [`From<T>`](https://doc.rust-lang."
"org/std/convert/trait.From.html) and [`Into<T>`](https://doc.rust-lang.org/"
"std/convert/trait.Into.html) traits to let us convert between them. The "
"`From<T>` trait has a single `from()` method and similarly, the `Into<T>` "
"trait has a single `into()` method. Implementing these traits is how a type "
"expresses that it can be converted into another type."
msgstr ""
"Todos los tipos de enteros de Rust implementan los traits [`From<T>`]"
"(https://doc.rust-lang.org/std/convert/trait.From.html) y [`Into<T>`]"
"(https://doc.rust-lang.org/std/convert/trait.Into.html) para permitirnos "
"realizar conversiones entre ellos. El trait `From<T>` tiene un √∫nico m√©todo "
"`from()` y, del mismo modo, el trait `Into<T>` tiene un √∫nico m√©todo "
"`into()`. Un tipo expresa que se puede convertir en otro tipo implementando "
"estos traits."

#: src/exercises/day-1/implicit-conversions.md:25
msgid ""
"The standard library has an implementation of `From<i8> for i16`, which "
"means that we can convert a variable `x` of type `i8` to an `i16` by "
"calling  `i16::from(x)`. Or, simpler, with `x.into()`, because `From<i8> for "
"i16` implementation automatically create an implementation of `Into<i16> for "
"i8`."
msgstr ""
"La biblioteca est√°ndar implementa `From<i8> for i16`, lo que significa que "
"podemos convertir una variable `x` del tipo `i8` a `i16` llamando a  `i16::"
"from(x)`. O, m√°s sencillo, con `x.into()`, ya que la implementaci√≥n de "
"`From<i8> for i16` crea autom√°ticamente una implementaci√≥n de `Into<i16> for "
"i8`."

#: src/exercises/day-1/implicit-conversions.md:30
msgid ""
"The same applies for your own `From` implementations for your own types, so "
"it is sufficient to only implement `From` to get a respective `Into` "
"implementation automatically."
msgstr ""
"Lo mismo se aplica a tus implementaciones `From` para tus propios tipos, por "
"lo que basta con implementar `From` para obtener la respectiva "
"implementaci√≥n `Into` de forma autom√°tica."

#: src/exercises/day-1/implicit-conversions.md:33
msgid "Execute the above program and look at the compiler error."
msgstr "Ejecuta el programa anterior y observa el error del compilador."

#: src/exercises/day-1/implicit-conversions.md:35
msgid "Update the code above to use `into()` to do the conversion."
msgstr ""
"Actualiza el c√≥digo anterior para usar `into()` y realizar la conversi√≥n."

#: src/exercises/day-1/implicit-conversions.md:37
msgid ""
"Change the types of `x` and `y` to other things (such as `f32`, `bool`, "
"`i128`) to see which types you can convert to which other types. Try "
"converting small types to big types and the other way around. Check the "
"[standard library documentation](https://doc.rust-lang.org/std/convert/trait."
"From.html) to see if `From<T>` is implemented for the pairs you check."
msgstr ""
"Cambia los tipos de `x` e `y` a otros elementos (por ejemplo, `f32`, `bool`, "
"`i128`) para ver qu√© tipos puedes convertir. Prueba a convertir tipos "
"peque√±os en tipos grandes y viceversa. Consulta la [documentaci√≥n de la "
"biblioteca est√°ndar](https://doc.rust-lang.org/std/convert/trait.From.html) "
"para comprobar si se ha implementado `From<T>` en los pares que elijas."

#: src/exercises/day-1/for-loops.md:1
#: src/exercises/day-1/solutions-morning.md:3
msgid "Arrays and `for` Loops"
msgstr "Arrays y bucles`for`"

#: src/exercises/day-1/for-loops.md:3
msgid "We saw that an array can be declared like this:"
msgstr "Hemos visto que un array se puede declarar de la siguiente manera:"

#: src/exercises/day-1/for-loops.md:5
msgid ""
"```rust\n"
"let array = [10, 20, 30];\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:9
msgid ""
"You can print such an array by asking for its debug representation with `{:?}"
"`:"
msgstr ""
"Puedes imprimir dicho array solicitando su representaci√≥n de depuraci√≥n con "
"`{:?}`:"

#: src/exercises/day-1/for-loops.md:11
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    println!(\"array: {array:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:18
msgid ""
"Rust lets you iterate over things like arrays and ranges using the `for` "
"keyword:"
msgstr ""
"Rust te permite iterar sobre elementos como arrays e intervalos usando la "
"palabra clave `for`:"

#: src/exercises/day-1/for-loops.md:21
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    print!(\"Iterating over array:\");\n"
"    for n in &array {\n"
"        print!(\" {n}\");\n"
"    }\n"
"    println!();\n"
"\n"
"    print!(\"Iterating over range:\");\n"
"    for i in 0..3 {\n"
"        print!(\" {}\", array[i]);\n"
"    }\n"
"    println!();\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:38
msgid ""
"Use the above to write a function `pretty_print` which pretty-print a matrix "
"and a function `transpose` which will transpose a matrix (turn rows into "
"columns):"
msgstr ""
"Usa el m√©todo anterior para escribir una funci√≥n `pretty_print` que sirva "
"para dar formato al texto de la matriz y una funci√≥n `transpose` que "
"transponga una matriz (convertir filas en columnas):"

#: src/exercises/day-1/for-loops.md:41
msgid ""
"```bob\n"
"           ‚éõ‚é°1 2 3‚é§‚éû      ‚é°1 4 7‚é§\n"
"\"transpose\"‚éú‚é¢4 5 6‚é•‚éü  \"==\"‚é¢2 5 8‚é•\n"
"           ‚éù‚é£7 8 9‚é¶‚é†      ‚é£3 6 9‚é¶\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:47
msgid "Hard-code both functions to operate on 3 √ó 3 matrices."
msgstr "Codifica ambas funciones para que operen con matrices de 3 √ó 3."

#: src/exercises/day-1/for-loops.md:49
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and implement the "
"functions:"
msgstr ""
"Copia el siguiente fragmento de c√≥digo en <https://play.rust-lang.org/> e "
"implementa las funciones:"

#: src/exercises/day-1/for-loops.md:52
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"\n"
"    println!(\"matrix:\");\n"
"    pretty_print(&matrix);\n"
"\n"
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:80
msgid "Bonus Question"
msgstr "Pregunta Extra"

#: src/exercises/day-1/for-loops.md:82
msgid ""
"Could you use `&[i32]` slices instead of hard-coded 3 √ó 3 matrices for your "
"argument and return types? Something like `&[&[i32]]` for a two-dimensional "
"slice-of-slices. Why or why not?"
msgstr ""
"¬øSe podr√≠an usar slices `&[i32]` en lugar de matrices de 3 √ó 3 predefinidas "
"en el c√≥digo para tus argumentos y tipos de resultados devueltos? Por "
"ejemplo, \\``&\\[&\\[i32\\]\\]\\` para un slice de slices de dos "
"dimensiones. ¬øPor qu√©? ¬øPor qu√© no?"

#: src/exercises/day-1/for-loops.md:87
msgid ""
"See the [`ndarray` crate](https://docs.rs/ndarray/) for a production quality "
"implementation."
msgstr ""
"Consulta el [crate `ndarray`](https://docs.rs/ndarray/) para obtener una "
"implementaci√≥n con calidad de producci√≥n."

#: src/exercises/day-1/for-loops.md:92
msgid ""
"The solution and the answer to the bonus section are available in the  "
"[Solution](solutions-morning.md#arrays-and-for-loops) section."
msgstr ""
"La soluci√≥n y la respuesta a la pregunta extra est√°n disponibles en la "
"secci√≥n [soluciones](solutions-morning.md#arrays-and-for-loops)."

#: src/exercises/day-1/for-loops.md:95
msgid ""
"The use of the reference `&array` within `for n in &array` is a subtle "
"preview of issues of ownership that will come later in the afternoon."
msgstr ""
"El uso de la referencia `&array` dentro de `for n in &array` es una vista "
"previa sutil de los problemas de propiedad que se tratar√°n m√°s tarde por la "
"tarde."

#: src/exercises/day-1/for-loops.md:98
msgid "Without the `&`..."
msgstr "Sin el `&`..."

#: src/exercises/day-1/for-loops.md:99
msgid ""
"The loop would have been one that consumes the array.  This is a change "
"[introduced in the 2021 Edition](https://doc.rust-lang.org/edition-guide/"
"rust-2021/IntoIterator-for-arrays.html)."
msgstr ""
"El bucle habr√≠a sido uno que consume el array. Este es un cambio "
"[introducido en la edici√≥n de 2021](https://doc.rust-lang.org/edition-guide/"
"rust-2021/IntoIterator-for-arrays.html)."

#: src/exercises/day-1/for-loops.md:102
msgid ""
"An implicit array copy would have occurred.  Since `i32` is a copy type, "
"then `[i32; 3]` is also a copy type."
msgstr ""
"Se habr√≠a producido una copia impl√≠cita del array. Dado que `i32` es un tipo "
"de copia, `[i32; 3]` tambi√©n es un tipo de copia."

#: src/control-flow.md:3
msgid ""
"As we have seen, `if` is an expression in Rust. It is used to conditionally "
"evaluate one of two blocks, but the blocks can have a value which then "
"becomes the value of the `if` expression. Other control flow expressions "
"work similarly in Rust."
msgstr ""
"Como hemos visto, `if` es una expresi√≥n de Rust. Se utiliza para realizar "
"una evaluaci√≥n condicional de uno de los dos bloques, aunque estos pueden "
"tener un valor que acaba convirti√©ndose en el valor de la expresi√≥n `if`. "
"Otras expresiones del flujo de control funcionan de forma similar en Rust."

#: src/control-flow/blocks.md:3
msgid ""
"A block in Rust contains a sequence of expressions. Each block has a value "
"and a type, which are those of the last expression of the block:"
msgstr ""
"En Rust, un bloque contiene una secuencia de expresiones.  Cada bloque tiene "
"un tipo y un valor,  que son los de la √∫ltima expresi√≥n del bloque:"

#: src/control-flow/blocks.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x = {\n"
"        let y = 10;\n"
"        println!(\"y: {y}\");\n"
"        let z = {\n"
"            let w = {\n"
"                3 + 4\n"
"            };\n"
"            println!(\"w: {w}\");\n"
"            y * w\n"
"        };\n"
"        println!(\"z: {z}\");\n"
"        z - y\n"
"    };\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/blocks.md:26
msgid ""
"If the last expression ends with `;`, then the resulting value and type is "
"`()`."
msgstr ""
"Si la √∫ltima expresi√≥n termina con `;`, el tipo y el valor resultante ser√° "
"`()`."

#: src/control-flow/blocks.md:28
msgid ""
"The same rule is used for functions: the value of the function body is the "
"return value:"
msgstr ""
"Se utiliza la misma regla para las funciones: el valor del cuerpo de la "
"funci√≥n es el valor devuelto:"

#: src/control-flow/blocks.md:31
msgid ""
"```rust,editable\n"
"fn double(x: i32) -> i32 {\n"
"    x + x\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"doubled: {}\", double(7));\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/blocks.md:43 src/enums.md:34 src/enums/sizes.md:28
#: src/pattern-matching.md:25 src/pattern-matching/match-guards.md:22
#: src/structs.md:31 src/methods.md:30 src/methods/example.md:46
msgid "Key Points:"
msgstr "Puntos Clave:"

#: src/control-flow/blocks.md:44
msgid ""
"The point of this slide is to show that blocks have a type and value in "
"Rust. "
msgstr ""
"El objetivo de esta diapositiva es mostrar que los bloques tienen un tipo y "
"un valor en Rust. "

#: src/control-flow/blocks.md:45
msgid ""
"You can show how the value of the block changes by changing the last line in "
"the block. For instance, adding/removing a semicolon or using a `return`."
msgstr ""
"Puedes mostrar c√≥mo cambia el valor del bloque cambiando su √∫ltima l√≠nea. "
"Por ejemplo, a√±ade o quita un punto y coma, o utiliza la expresi√≥n `return`."

#: src/control-flow/if-expressions.md:1
msgid "`if` expressions"
msgstr "Expresiones `if`"

#: src/control-flow/if-expressions.md:3
msgid ""
"You use [`if` expressions](https://doc.rust-lang.org/reference/expressions/"
"if-expr.html#if-expressions) exactly like `if` statements in other languages:"
msgstr ""
"Puedes usar [expresiones `if`](https://doc.rust-lang.org/reference/"
"expressions/if-expr.html#if-expressions) de la misma forma que en otros "
"lenguajes:"

#: src/control-flow/if-expressions.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    if x % 2 == 0 {\n"
"        x = x / 2;\n"
"    } else {\n"
"        x = 3 * x + 1;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/if-expressions.md:18
msgid ""
"In addition, you can use `if` as an expression. The last expression of each "
"block becomes the value of the `if` expression:"
msgstr ""
"Adem√°s, puedes utilizar `if` como expresi√≥n. La √∫ltima expresi√≥n de cada "
"bloque se convierte en el valor de la expresi√≥n `if`:"

#: src/control-flow/if-expressions.md:22
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    x = if x % 2 == 0 {\n"
"        x / 2\n"
"    } else {\n"
"        3 * x + 1\n"
"    };\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/if-expressions.md:35
msgid ""
"Because `if` is an expression and must have a particular type, both of its "
"branch blocks must have the same type. Consider showing what happens if you "
"add `;` after `x / 2` in the second example."
msgstr ""
"Dado que `if` es una expresi√≥n y debe tener un tipo concreto, ambos bloques "
"de ramas deben tener el mismo tipo. En el segundo ejemplo, puedes mostrar lo "
"que sucede al a√±adir `;` despu√©s de `x / 2`."

#: src/control-flow/for-expressions.md:1
#, fuzzy
msgid "`for` loops"
msgstr "Bucles `for`"

#: src/control-flow/for-expressions.md:3
msgid ""
"The [`for` loop](https://doc.rust-lang.org/std/keyword.for.html) is closely "
"related to the [`while let` loop](while-let-expressions.md). It will "
"automatically call `into_iter()` on the expression and then iterate over it:"
msgstr ""
"El [bucle `for`][`for` loop](https://doc.rust-lang.org/std/keyword.for.html) "
"est√° estrechamente relacionado con el [bucle `while let`](while-let-"
"expressions.md). Llamar√° autom√°ticamente a `into_iter()` en la expresi√≥n y "
"despu√©s iterar√° sobre ella:"

#: src/control-flow/for-expressions.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"\n"
"    for x in v {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"    \n"
"    for i in (0..10).step_by(2) {\n"
"        println!(\"i: {i}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/for-expressions.md:21
msgid "You can use `break` and `continue` here as usual."
msgstr "Aqu√≠ puedes usar `break` y `continue` como de costumbre."

#: src/control-flow/for-expressions.md:25
msgid "Index iteration is not a special syntax in Rust for just that case."
msgstr ""
"La iteraci√≥n de √≠ndices no es una sintaxis especial en Rust para ese caso."

#: src/control-flow/for-expressions.md:26
msgid "`(0..10)` is a range that implements an `Iterator` trait. "
msgstr "`(0..10)` es un rango que implementa un `Iterator` trait."

#: src/control-flow/for-expressions.md:27
msgid ""
"`step_by` is a method that returns another `Iterator` that skips every other "
"element. "
msgstr ""
"`step_by` es un m√©todo que devuelve otro `Iterator` que salta cada otro "
"elemento."

#: src/control-flow/for-expressions.md:28
msgid ""
"Modify the elements in the vector and explain the compiler errors. Change "
"vector `v` to be mutable and the for loop to `for x in v.iter_mut()`."
msgstr ""
"Modifica los elementos del vector y explica los errores del compilador. "
"Cambia el vector `v` para que sea mutable y el bucle `for x in v.iter_mut()`."

#: src/control-flow/while-expressions.md:1
msgid "`while` loops"
msgstr "Bucles `while`"

#: src/control-flow/while-expressions.md:3
msgid ""
"The [`while` keyword](https://doc.rust-lang.org/reference/expressions/loop-"
"expr.html#predicate-loops) works very similar to other languages:"
msgstr ""
"La [palabra clave `while`](https://doc.rust-lang.org/reference/expressions/"
"loop-expr.html#predicate-loops) es muy similar a otros lenguajes:"

#: src/control-flow/while-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    while x != 1 {\n"
"        x = if x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"    }\n"
"    println!(\"Final x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/break-continue.md:1
msgid "`break` and `continue`"
msgstr "`break` y `continue`"

#: src/control-flow/break-continue.md:3
msgid ""
"If you want to exit a loop early, use [`break`](https://doc.rust-lang.org/"
"reference/expressions/loop-expr.html#break-expressions),"
msgstr ""
"Si quieres salir de un bucle antes, usa [`break`](https://doc.rust-lang.org/"
"reference/expressions/loop-expr.html#break-expressions)."

#: src/control-flow/break-continue.md:4
msgid ""
"If you want to immediately start the next iteration use [`continue`](https://"
"doc.rust-lang.org/reference/expressions/loop-expr.html#continue-expressions)."
msgstr ""
"Si quieres iniciar inmediatamente la siguiente iteraci√≥n, usa [`continue`]"
"(https://doc.rust-lang.org/reference/expressions/loop-expr.html#continue-"
"expressions)."

#: src/control-flow/break-continue.md:7
msgid ""
"Both `continue` and `break` can optionally take a label argument which is "
"used to break out of nested loops:"
msgstr ""
"De forma opcional, tanto `continue` como `break` pueden utilizar un "
"argumento de etiqueta para interrumpir los bucles anidados:"

#: src/control-flow/break-continue.md:10
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();\n"
"    'outer: while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"        let mut i = 0;\n"
"        while i < x {\n"
"            println!(\"x: {x}, i: {i}\");\n"
"            i += 1;\n"
"            if i == 3 {\n"
"                break 'outer;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/break-continue.md:28
msgid ""
"In this case we break the outer loop after 3 iterations of the inner loop."
msgstr ""
"En este caso, detenemos el bucle exterior tras tres iteraciones del bucle "
"interno."

#: src/control-flow/loop-expressions.md:1
msgid "`loop` expressions"
msgstr "Expresiones `loop`"

#: src/control-flow/loop-expressions.md:3
msgid ""
"Finally, there is a [`loop` keyword](https://doc.rust-lang.org/reference/"
"expressions/loop-expr.html#infinite-loops) which creates an endless loop."
msgstr ""
"Por √∫ltimo, la [palabra clave `loop`](https://doc.rust-lang.org/reference/"
"expressions/loop-expr.html#infinite-loops) crea un bucle infinito."

#: src/control-flow/loop-expressions.md:6
msgid "Here you must either `break` or `return` to stop the loop:"
msgstr "Para detener el bucle, debes usar `break` o `return`:"

#: src/control-flow/loop-expressions.md:8
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    loop {\n"
"        x = if x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"        if x == 1 {\n"
"            break;\n"
"        }\n"
"    }\n"
"    println!(\"Final x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/loop-expressions.md:27
msgid "Break the `loop` with a value (e.g. `break 8`) and print it out."
msgstr "Interrumpe `loop` con un valor (por ejemplo, `break 8`) e impr√≠melo."

#: src/control-flow/loop-expressions.md:28
msgid ""
"Note that `loop` is the only looping construct which returns a non-trivial "
"value. This is because it's guaranteed to be entered at least once (unlike "
"`while` and `for` loops)."
msgstr ""
"Ten en cuenta que `loop` es la √∫nica construcci√≥n de bucle que devuelve un "
"valor no trivial. Esto se debe a que es inevitable que se introduzca al "
"menos una vez (a diferencia de los bucles `while` y `for`)."

#: src/basic-syntax/variables.md:3
msgid ""
"Rust provides type safety via static typing. Variable bindings are immutable "
"by default:"
msgstr ""
"Rust ofrece seguridad de tipos mediante tipado est√°tico. De forma "
"predeterminada, los enlaces a variables son inmutables:"

#: src/basic-syntax/variables.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x: i32 = 10;\n"
"    println!(\"x: {x}\");\n"
"    // x = 20;\n"
"    // println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/variables.md:17
msgid ""
"Due to type inference the `i32` is optional. We will gradually show the "
"types less and less as the course progresses."
msgstr ""
"Debido a la inferencia de tipos, `i32` es opcional. A medida que avance el "
"curso, iremos mostrando cada vez menos los tipos."

#: src/basic-syntax/type-inference.md:3
msgid "Rust will look at how the variable is _used_ to determine the type:"
msgstr "Rust consultar√° c√≥mo se _usa_ la variable para determinar el tipo:"

#: src/basic-syntax/type-inference.md:5
msgid ""
"```rust,editable\n"
"fn takes_u32(x: u32) {\n"
"    println!(\"u32: {x}\");\n"
"}\n"
"\n"
"fn takes_i8(y: i8) {\n"
"    println!(\"i8: {y}\");\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = 10;\n"
"    let y = 20;\n"
"\n"
"    takes_u32(x);\n"
"    takes_i8(y);\n"
"    // takes_u32(y);\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/type-inference.md:26
msgid ""
"This slide demonstrates how the Rust compiler infers types based on "
"constraints given by variable declarations and usages."
msgstr ""
"Esta diapositiva muestra c√≥mo el compilador de Rust infiere tipos bas√°ndose "
"en restricciones proporcionadas por declaraciones y usos de variables."

#: src/basic-syntax/type-inference.md:28
msgid ""
"It is very important to emphasize that variables declared like this are not "
"of some sort of dynamic \"any type\" that can hold any data. The machine "
"code generated by such declaration is identical to the explicit declaration "
"of a type. The compiler does the job for us and helps us write more concise "
"code."
msgstr ""
"Es muy importante subrayar que las variables que se declaran as√≠ no son de "
"un \"tipo cualquiera\" din√°mico que pueda contener cualquier dato. El c√≥digo "
"m√°quina generado por tal declaraci√≥n es id√©ntico a la declaraci√≥n expl√≠cita "
"de un tipo. El compilador hace el trabajo por nosotros y nos ayuda a "
"escribir c√≥digo m√°s conciso."

#: src/basic-syntax/type-inference.md:32
msgid ""
"The following code tells the compiler to copy into a certain generic "
"container without the code ever explicitly specifying the contained type, "
"using `_` as a placeholder:"
msgstr ""
"El siguiente fragmento de c√≥digo le indica al compilador que copie en un "
"determinado contenedor gen√©rico sin que el c√≥digo especifique expl√≠citamente "
"el tipo contenido utilizando `_` como marcador de posici√≥n:"

#: src/basic-syntax/type-inference.md:34
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v = Vec::new();\n"
"    v.push((10, false));\n"
"    v.push((20, true));\n"
"    println!(\"v: {v:?}\");\n"
"\n"
"    let vv = v.iter().collect::<std::collections::HashSet<_>>();\n"
"    println!(\"vv: {vv:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/type-inference.md:46
msgid ""
"[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator."
"html#method.collect) relies on [`FromIterator`](https://doc.rust-lang.org/"
"std/iter/trait.FromIterator.html), which [`HashSet`](https://doc.rust-lang."
"org/std/collections/struct.HashSet.html#impl-FromIterator%3CT%3E-for-"
"HashSet%3CT,+S%3E) implements."
msgstr ""
"[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator."
"html#method.collect) se basa en [`FromIterator`](https://doc.rust-lang.org/"
"std/iter/trait.FromIterator.html), que implementa [`HashSet`](https://doc."
"rust-lang.org/std/collections/struct.HashSet.html#impl-FromIterator%3CT%3E-"
"for-HashSet%3CT,+S%3E)."

#: src/basic-syntax/static-and-const.md:1
msgid "Static and Constant Variables"
msgstr "Variables Est√°ticas y Constantes"

#: src/basic-syntax/static-and-const.md:3
msgid ""
"Static and constant variables are two different ways to create globally-"
"scoped values that cannot be moved or reallocated during the execution of "
"the program. "
msgstr ""
"Las variables est√°ticas y constantes son dos formas diferentes de crear "
"valores de √°mbito global que no se pueden mover ni reasignar durante la "
"ejecuci√≥n del programa. "

#: src/basic-syntax/static-and-const.md:6
msgid "`const`"
msgstr "`const`"

#: src/basic-syntax/static-and-const.md:8
msgid ""
"Constant variables are evaluated at compile time and their values are "
"inlined wherever they are used:"
msgstr ""
"Las variables constantes se eval√∫an en tiempo de compilaci√≥n y sus valores "
"se insertan dondequiera que se utilicen:"

#: src/basic-syntax/static-and-const.md:11
msgid ""
"```rust,editable\n"
"const DIGEST_SIZE: usize = 3;\n"
"const ZERO: Option<u8> = Some(42);\n"
"\n"
"fn compute_digest(text: &str) -> [u8; DIGEST_SIZE] {\n"
"    let mut digest = [ZERO.unwrap_or(0); DIGEST_SIZE];\n"
"    for (idx, &b) in text.as_bytes().iter().enumerate() {\n"
"        digest[idx % DIGEST_SIZE] = digest[idx % DIGEST_SIZE]."
"wrapping_add(b);\n"
"    }\n"
"    digest\n"
"}\n"
"\n"
"fn main() {\n"
"    let digest = compute_digest(\"Hello\");\n"
"    println!(\"Digest: {digest:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/static-and-const.md:29
#, fuzzy
msgid ""
"According to the [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-"
"vs-static.html) these are inlined upon use."
msgstr ""
"Seg√∫n el libro [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-"
"vs-static.html), se insertan cuando se utilizan."

#: src/basic-syntax/static-and-const.md:31
msgid ""
"Only functions marked `const` can be called at compile time to generate "
"`const` values. `const` functions can however be called at runtime."
msgstr ""
"S√≥lo se pueden llamar a las funciones marcadas como `const` en tiempo de "
"compilaci√≥n para generar valores `const`. Sin embargo, las funciones `const` "
"se pueden llamar en _runtime_."

#: src/basic-syntax/static-and-const.md:33
msgid "`static`"
msgstr "`static`"

#: src/basic-syntax/static-and-const.md:35
msgid ""
"Static variables will live during the whole execution of the program, and "
"therefore will not move:"
msgstr ""
"Las variables est√°ticas vivir√°n durante toda la ejecuci√≥n del programa y, "
"por lo tanto, no se mover√°n:"

#: src/basic-syntax/static-and-const.md:37
msgid ""
"```rust,editable\n"
"static BANNER: &str = \"Welcome to RustOS 3.14\";\n"
"\n"
"fn main() {\n"
"    println!(\"{BANNER}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/static-and-const.md:45
msgid ""
"As noted in the [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-"
"vs-static.html), these are not inlined upon use and have an actual "
"associated memory location.  This is useful for unsafe and  embedded code, "
"and the variable lives through the entirety of the program execution. When a "
"globally-scoped value does not have a reason to need object identity, "
"`const` is generally preferred."
msgstr ""
"Tal y como se indica en el libro [Rust RFC Book](https://rust-lang.github.io/"
"rfcs/0246-const-vs-static.html), no est√°n insertadas y tienen una ubicaci√≥n "
"de memoria real asociada.  Esto resulta √∫til para c√≥digo insertado y no "
"seguro. Adem√°s, la variable contin√∫a durante toda la ejecuci√≥n del programa. "
"Cuando un valor de √°mbito global no tiene ning√∫n motivo para necesitar "
"identidad de objeto, se suele preferir `const`."

#: src/basic-syntax/static-and-const.md:49
msgid ""
"Because `static` variables are accessible from any thread, they must be "
"`Sync`. Interior mutability is possible through a [`Mutex`](https://doc.rust-"
"lang.org/std/sync/struct.Mutex.html), atomic or similar. It is also possible "
"to have mutable statics, but they require manual synchronisation so any "
"access to them requires `unsafe` code. We will look at [mutable statics](../"
"unsafe/mutable-static-variables.md) in the chapter on Unsafe Rust."
msgstr ""
"Dado que se puede acceder a las variables `static` desde cualquier hilo, es "
"necesario protegerlas, por ejemplo, mediante un comando [`Mutex`](https://"
"doc.rust-lang.org/std/sync/struct.Mutex.html), o que sean accesibles usando "
"c√≥digo `unsafe`. Veremos la [mutaci√≥n de datos est√°ticos](../unsafe/mutable-"
"static-variables.md) en el cap√≠tulo sobre Rust inseguro."

#: src/basic-syntax/static-and-const.md:57
msgid "Mention that `const` behaves semantically similar to C++'s `constexpr`."
msgstr ""
"Menciona que `const` se comporta sem√°nticamente de forma similar a "
"`constexpr` de C++."

#: src/basic-syntax/static-and-const.md:58
msgid ""
"`static`, on the other hand, is much more similar to a `const` or mutable "
"global variable in C++."
msgstr ""
"Por su parte, `static` se parece mucho m√°s a `const` o a una variable global "
"mutable de C++."

#: src/basic-syntax/static-and-const.md:59
msgid ""
"`static` provides object identity: an address in memory and state as "
"required by types with interior mutability such as `Mutex<T>`."
msgstr ""
"`static` proporciona la identidad del objeto: una direcci√≥n en la memoria y "
"en el estado que requieren los tipos con mutabilidad interior, como "
"`Mutex<T>`."

#: src/basic-syntax/static-and-const.md:60
msgid ""
"It isn't super common that one would need a runtime evaluated constant, but "
"it is helpful and safer than using a static."
msgstr ""
"No es muy habitual que se necesite una constante evaluada en _runtime_, pero "
"es √∫til y m√°s seguro que usar una est√°tica."

#: src/basic-syntax/static-and-const.md:61
msgid "`thread_local` data can be created with the macro `std::thread_local`."
msgstr ""
"Datos del `thread_local` se pueden crear con la macro `std::thread_local`."

#: src/basic-syntax/static-and-const.md:63
msgid "Properties table:"
msgstr "Tabla de Propiedades:"

#: src/basic-syntax/static-and-const.md:65
msgid "Property"
msgstr "Propiedad"

#: src/basic-syntax/static-and-const.md:65
msgid "Static"
msgstr "Est√°tico"

#: src/basic-syntax/static-and-const.md:65
msgid "Constant"
msgstr "Constante"

#: src/basic-syntax/static-and-const.md:67
msgid "Has an address in memory"
msgstr "Tiene una direcci√≥n en la memoria"

#: src/basic-syntax/static-and-const.md:67
#: src/basic-syntax/static-and-const.md:68
#: src/basic-syntax/static-and-const.md:70
#: src/basic-syntax/static-and-const.md:71
msgid "Yes"
msgstr "S√≠"

#: src/basic-syntax/static-and-const.md:67
msgid "No (inlined)"
msgstr "No (insertado)"

#: src/basic-syntax/static-and-const.md:68
msgid "Lives for the entire duration of the program"
msgstr "Vive durante toda la ejecuci√≥n del programa"

#: src/basic-syntax/static-and-const.md:68
#: src/basic-syntax/static-and-const.md:69
#: src/basic-syntax/static-and-const.md:71
msgid "No"
msgstr "No"

#: src/basic-syntax/static-and-const.md:69
msgid "Can be mutable"
msgstr "Puede ser mutable"

#: src/basic-syntax/static-and-const.md:69
msgid "Yes (unsafe)"
msgstr "S√≠ (inseguro)"

#: src/basic-syntax/static-and-const.md:70
msgid "Evaluated at compile time"
msgstr "Evaluado en tiempo de compilaci√≥n"

#: src/basic-syntax/static-and-const.md:70
msgid "Yes (initialised at compile time)"
msgstr "S√≠ (inicializado en tiempo de compilaci√≥n)"

#: src/basic-syntax/static-and-const.md:71
msgid "Inlined wherever it is used"
msgstr "Insertado dondequiera que se utilice"

#: src/basic-syntax/scopes-shadowing.md:3
msgid ""
"You can shadow variables, both those from outer scopes and variables from "
"the same scope:"
msgstr ""
"Puedes sombrear variables, tanto las de √°mbitos externos como las del propio "
"√°mbito:"

#: src/basic-syntax/scopes-shadowing.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 10;\n"
"    println!(\"before: {a}\");\n"
"\n"
"    {\n"
"        let a = \"hello\";\n"
"        println!(\"inner scope: {a}\");\n"
"\n"
"        let a = true;\n"
"        println!(\"shadowed in inner scope: {a}\");\n"
"    }\n"
"\n"
"    println!(\"after: {a}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/scopes-shadowing.md:25
msgid ""
"Definition: Shadowing is different from mutation, because after shadowing "
"both variable's memory locations exist at the same time. Both are available "
"under the same name, depending where you use it in the code. "
msgstr ""
"Definici√≥n: _Shadowing_ (sombreado) es distinto de la mutaci√≥n, ya que, "
"despu√©s de sombrear la memoria de las dos variables, las ubicaciones existen "
"al mismo tiempo. Ambas est√°n disponibles bajo el mismo nombre, en funci√≥n de "
"d√≥nde se utiliza en el c√≥digo. "

#: src/basic-syntax/scopes-shadowing.md:26
msgid "A shadowing variable can have a different type. "
msgstr "Una variable sombreada puede tener un tipo diferente. "

#: src/basic-syntax/scopes-shadowing.md:27
msgid ""
"Shadowing looks obscure at first, but is convenient for holding on to values "
"after `.unwrap()`."
msgstr ""
"Al principio, el sombreado no es f√°cil, pero resulta √∫til para conservar "
"valores despu√©s de `.unwrap()`."

#: src/basic-syntax/scopes-shadowing.md:28
msgid ""
"The following code demonstrates why the compiler can't simply reuse memory "
"locations when shadowing an immutable variable in a scope, even if the type "
"does not change."
msgstr ""
"El siguiente fragmento de c√≥digo demuestra por qu√© el compilador no puede "
"reutilizar ubicaciones de memoria cuando sombrea una variable inmutable en "
"un √°mbito, incluso si el tipo no cambia."

#: src/basic-syntax/scopes-shadowing.md:30
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 1;\n"
"    let b = &a;\n"
"    let a = a + 1;\n"
"    println!(\"{a} {b}\");\n"
"}\n"
"```"
msgstr ""

#: src/enums.md:3
msgid ""
"The `enum` keyword allows the creation of a type which has a few different "
"variants:"
msgstr ""
"La palabra clave `enum` permite crear un tipo que tiene diferentes variantes:"

#: src/enums.md:6
msgid ""
"```rust,editable\n"
"fn generate_random_number() -> i32 {\n"
"    // Implementation based on https://xkcd.com/221/\n"
"    4  // Chosen by fair dice roll. Guaranteed to be random.\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"enum CoinFlip {\n"
"    Heads,\n"
"    Tails,\n"
"}\n"
"\n"
"fn flip_coin() -> CoinFlip {\n"
"    let random_number = generate_random_number();\n"
"    if random_number % 2 == 0 {\n"
"        return CoinFlip::Heads;\n"
"    } else {\n"
"        return CoinFlip::Tails;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"You got: {:?}\", flip_coin());\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn generate_random_number() -> i32 {\n"
"    // Implementation based on https://xkcd.com/221/\n"
"    4  // Chosen by fair dice roll. Guaranteed to be random.\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"enum CoinFlip {\n"
"    Heads,\n"
"    Tails,\n"
"}\n"
"\n"
"fn flip_coin() -> CoinFlip {\n"
"    let random_number = generate_random_number();\n"
"    if random_number % 2 == 0 {\n"
"        return CoinFlip::Heads;\n"
"    } else {\n"
"        return CoinFlip::Tails;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"You got: {:?}\", flip_coin());\n"
"}\n"
"```"

#: src/enums.md:36
msgid "Enumerations allow you to collect a set of values under one type"
msgstr ""
"Las enumeraciones te permiten recoger un conjunto de valores en un solo tipo."

#: src/enums.md:37
msgid ""
"This page offers an enum type `CoinFlip` with two variants `Heads` and "
"`Tails`. You might note the namespace when using variants."
msgstr ""
"En esta p√°gina se ofrece el tipo de enumeraci√≥n `CoinFlip` (tirar moneda) "
"con dos variantes: `Heads` (cara) y `Tails` (cruz). Puede que veas el "
"espacio de nombres cuando utilices variantes."

#: src/enums.md:38
msgid "This might be a good time to compare Structs and Enums:"
msgstr ""
"Este es un buen momento para comparar las estructuras y las enumeraciones:"

#: src/enums.md:39
msgid ""
"In both, you can have a simple version without fields (unit struct) or one "
"with different types of fields (variant payloads). "
msgstr ""
"En ambas puedes tener una versi√≥n sencilla sin campos (estructura unitaria) "
"o una versi√≥n con distintos tipos de campos (variantes con carga √∫til). "

#: src/enums.md:40
msgid "In both, associated functions are defined within an `impl` block."
msgstr ""
"En ambos casos, las funciones asociadas se definen en un bloque `impl`."

#: src/enums.md:41
msgid ""
"You could even implement the different variants of an enum with separate "
"structs but then they wouldn‚Äôt be the same type as they would if they were "
"all defined in an enum. "
msgstr ""
"Incluso podr√≠as implementar las distintas variantes de una enumeraci√≥n con "
"estructuras diferentes, pero entonces no ser√≠an del mismo tipo como lo "
"ser√≠an si estuvieran todas definidas en una enumeraci√≥n. "

#: src/enums/variant-payloads.md:3
msgid ""
"You can define richer enums where the variants carry data. You can then use "
"the `match` statement to extract the data from each variant:"
msgstr ""
"Puedes definir enumeraciones m√°s completas en las que las variantes "
"contienen datos. Despu√©s, puedes usar la instrucci√≥n `match` para extraer "
"los datos de cada variante:"

#: src/enums/variant-payloads.md:6
msgid ""
"```rust,editable\n"
"enum WebEvent {\n"
"    PageLoad,                 // Variant without payload\n"
"    KeyPress(char),           // Tuple struct variant\n"
"    Click { x: i64, y: i64 }, // Full struct variant\n"
"}\n"
"\n"
"#[rustfmt::skip]\n"
"fn inspect(event: WebEvent) {\n"
"    match event {\n"
"        WebEvent::PageLoad       => println!(\"page loaded\"),\n"
"        WebEvent::KeyPress(c)    => println!(\"pressed '{c}'\"),\n"
"        WebEvent::Click { x, y } => println!(\"clicked at x={x}, y={y}\"),\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let load = WebEvent::PageLoad;\n"
"    let press = WebEvent::KeyPress('x');\n"
"    let click = WebEvent::Click { x: 20, y: 80 };\n"
"\n"
"    inspect(load);\n"
"    inspect(press);\n"
"    inspect(click);\n"
"}\n"
"```"
msgstr ""

#: src/enums/variant-payloads.md:35
msgid ""
"The values in the enum variants can only be accessed after being pattern "
"matched. The pattern binds references to the fields in the \"match arm\" "
"after the `=>`."
msgstr ""
"Solo se puede acceder a los valores de las variantes de enumeraci√≥n una vez "
"que coincidan con el patr√≥n. El patr√≥n vincula referencias a los campos del "
"\"brazo de coincidencias\" despu√©s de `=>`."

#: src/enums/variant-payloads.md:36
msgid ""
"The expression is matched against the patterns from top to bottom. There is "
"no fall-through like in C or C++."
msgstr ""
"La expresi√≥n se coteja con los patrones de arriba abajo. No hay ning√∫n "
"sistema de respaldo, como en C o C++."

#: src/enums/variant-payloads.md:37
msgid ""
"The match expression has a value. The value is the last expression in the "
"match arm which was executed."
msgstr ""
"La expresi√≥n de coincidencia tiene un valor. El valor es la √∫ltima expresi√≥n "
"en el brazo de coincidencia que se ha ejecutado."

#: src/enums/variant-payloads.md:38
msgid ""
"Starting from the top we look for what pattern matches the value then run "
"the code following the arrow. Once we find a match, we stop. "
msgstr ""
"Empezando por la parte superior, buscaremos el patr√≥n que coincide con el "
"valor y, a continuaci√≥n, ejecutaremos el fragmento de c√≥digo que sigue a la "
"flecha. Cuando encontremos una coincidencia, pararemos. "

#: src/enums/variant-payloads.md:39
msgid ""
"Demonstrate what happens when the search is inexhaustive. Note the advantage "
"the Rust compiler provides by confirming when all cases are handled. "
msgstr ""
"Demuestra lo que pasa cuando la b√∫squeda no es exhaustiva. Ten en cuenta la "
"ventaja que ofrece el compilador de Rust al confirmar cu√°ndo se gestionan "
"todos los casos. "

#: src/enums/variant-payloads.md:40
msgid "`match` inspects a hidden discriminant field in the `enum`."
msgstr "`match` inspecciona un campo discriminante oculto en `enum`."

#: src/enums/variant-payloads.md:41
msgid ""
"It is possible to retrieve the discriminant by calling `std::mem::"
"discriminant()`"
msgstr ""
"Se puede obtener el discriminante llamando a `std::mem::discriminant()`."

#: src/enums/variant-payloads.md:42
msgid ""
"This is useful, for example, if implementing `PartialEq` for structs where "
"comparing field values doesn't affect equality."
msgstr ""
"Esto resulta √∫til si, por ejemplo, se implementa `PartialEq` en estructuras "
"en las que la comparaci√≥n de valores de campos no afecta a la igualdad."

#: src/enums/variant-payloads.md:43
msgid ""
"`WebEvent::Click { ... }` is not exactly the same as `WebEvent::"
"Click(Click)` with a top level `struct Click { ... }`. The inlined version "
"cannot implement traits, for example."
msgstr ""
"`WebEvent::Click { ... }` no es exactamente lo mismo que `WebEvent::"
"Click(Click)` con un nivel superior `struct Click { ... }`. La versi√≥n "
"insertada no puede implementar traits, por ejemplo."

#: src/enums/sizes.md:3
msgid ""
"Rust enums are packed tightly, taking constraints due to alignment into "
"account:"
msgstr ""
"Las enumeraciones de Rust son densamente empaquetadas, ya que tienen en "
"cuenta las restricciones debidas a la alineaci√≥n:"

#: src/enums/sizes.md:5
msgid ""
"```rust,editable\n"
"use std::any::type_name;\n"
"use std::mem::{align_of, size_of};\n"
"\n"
"fn dbg_size<T>() {\n"
"    println!(\"{}: size {} bytes, align: {} bytes\",\n"
"        type_name::<T>(), size_of::<T>(), align_of::<T>());\n"
"}\n"
"\n"
"enum Foo {\n"
"    A,\n"
"    B,\n"
"}\n"
"\n"
"fn main() {\n"
"    dbg_size::<Foo>();\n"
"}\n"
"```"
msgstr ""

#: src/enums/sizes.md:24
msgid ""
"See the [Rust Reference](https://doc.rust-lang.org/reference/type-layout."
"html)."
msgstr ""
"Consulta el libro [Rust Reference](https://doc.rust-lang.org/reference/type-"
"layout.html)."

#: src/enums/sizes.md:30
msgid ""
"Internally Rust is using a field (discriminant) to keep track of the enum "
"variant."
msgstr ""
"Rust utiliza un campo (discriminante) de forma interna para hacer un "
"seguimiento de la variante de enumeraci√≥n."

#: src/enums/sizes.md:32
msgid ""
"You can control the discriminant if needed (e.g., for compatibility with C):"
msgstr ""
"Puedes controlar el discriminante si es necesario (por ejemplo, para "
"asegurar la compatibilidad con C):"

#: src/enums/sizes.md:34
msgid ""
"```rust,editable\n"
"#[repr(u32)]\n"
"enum Bar {\n"
"    A,  // 0\n"
"    B = 10000,\n"
"    C,  // 10001\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"A: {}\", Bar::A as u32);\n"
"    println!(\"B: {}\", Bar::B as u32);\n"
"    println!(\"C: {}\", Bar::C as u32);\n"
"}\n"
"```"
msgstr ""

#: src/enums/sizes.md:49
msgid ""
"Without `repr`, the discriminant type takes 2 bytes, because 10001 fits 2 "
"bytes."
msgstr ""
"Sin `repr`, el tipo discriminante ocupa 2 bytes, debido a que 10001 se cabe "
"en 2 bytes."

#: src/enums/sizes.md:53
msgid "Try out other types such as"
msgstr "Prueba otros tipos, como"

#: src/enums/sizes.md:55
msgid "`dbg_size!(bool)`: size 1 bytes, align: 1 bytes,"
msgstr "`dbg_size!(bool)`: tama√±o de 1 byte, alineaci√≥n de 1 byte,"

#: src/enums/sizes.md:56
msgid ""
"`dbg_size!(Option<bool>)`: size 1 bytes, align: 1 bytes (niche optimization, "
"see below),"
msgstr ""
"`dbg_size!(Option<bool>)`: tama√±o de 1 byte, alineaci√≥n de 1 byte "
"(optimizaci√≥n de nichos, consulta m√°s abajo),"

#: src/enums/sizes.md:57
msgid "`dbg_size!(&i32)`: size 8 bytes, align: 8 bytes (on a 64-bit machine),"
msgstr ""
"`dbg_size!(&i32)`: tama√±o de 8 bytes, alineaci√≥n de 8 bytes (en una m√°quina "
"de 64 bits),"

#: src/enums/sizes.md:58
msgid ""
"`dbg_size!(Option<&i32>)`: size 8 bytes, align: 8 bytes (null pointer "
"optimization, see below)."
msgstr ""
"`dbg_size!(Option<&i32>)`: tama√±o de 8 bytes, alineaci√≥n de 8 bytes "
"(optimizaci√≥n del puntero nulo, consulta m√°s abajo)."

#: src/enums/sizes.md:60
msgid ""
"Niche optimization: Rust will merge unused bit patterns for the enum "
"discriminant."
msgstr ""
"Optimizaci√≥n de nichos: Rust combina los patrones de bits no utilizados para "
"el discriminante de enumeraci√≥n."

#: src/enums/sizes.md:63
msgid ""
"Null pointer optimization: For [some types](https://doc.rust-lang.org/std/"
"option/#representation), Rust guarantees that `size_of::<T>()` equals "
"`size_of::<Option<T>>()`."
msgstr ""
"Optimizaci√≥n de puntero nulo: para [algunos tipos](https://doc.rust-lang.org/"
"std/option/#representation), Rust asegura que `size_of::<T>()` es igual a "
"`size_of::<Option<T> >()`."

#: src/enums/sizes.md:67
msgid ""
"Example code if you want to show how the bitwise representation _may_ look "
"like in practice. It's important to note that the compiler provides no "
"guarantees regarding this representation, therefore this is totally unsafe."
msgstr ""
"Fragmento de c√≥digo de ejemplo si quieres mostrar c√≥mo puede ser la "
"representaci√≥n bit a bit en la pr√°ctica. Es importante tener en cuenta que "
"el compilador no ofrece garant√≠as con respecto a esta representaci√≥n, por lo "
"tanto es totalmente inseguro. "

#: src/enums/sizes.md:70
msgid ""
"```rust,editable\n"
"use std::mem::transmute;\n"
"\n"
"macro_rules! dbg_bits {\n"
"    ($e:expr, $bit_type:ty) => {\n"
"        println!(\"- {}: {:#x}\", stringify!($e), transmute::<_, "
"$bit_type>($e));\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
"    // representation of types.\n"
"    unsafe {\n"
"        println!(\"Bitwise representation of bool\");\n"
"        dbg_bits!(false, u8);\n"
"        dbg_bits!(true, u8);\n"
"\n"
"        println!(\"Bitwise representation of Option<bool>\");\n"
"        dbg_bits!(None::<bool>, u8);\n"
"        dbg_bits!(Some(false), u8);\n"
"        dbg_bits!(Some(true), u8);\n"
"\n"
"        println!(\"Bitwise representation of Option<Option<bool>>\");\n"
"        dbg_bits!(Some(Some(false)), u8);\n"
"        dbg_bits!(Some(Some(true)), u8);\n"
"        dbg_bits!(Some(None::<bool>), u8);\n"
"        dbg_bits!(None::<Option<bool>>, u8);\n"
"\n"
"        println!(\"Bitwise representation of Option<&i32>\");\n"
"        dbg_bits!(None::<&i32>, usize);\n"
"        dbg_bits!(Some(&0i32), usize);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/enums/sizes.md:105
msgid ""
"More complex example if you want to discuss what happens when we chain more "
"than 256 `Option`s together."
msgstr ""
"Ejemplo m√°s complejo si quieres hablar de lo que pasa cuando encadenamos m√°s "
"de 256 `Option`."

#: src/enums/sizes.md:107
msgid ""
"```rust,editable\n"
"#![recursion_limit = \"1000\"]\n"
"\n"
"use std::mem::transmute;\n"
"\n"
"macro_rules! dbg_bits {\n"
"    ($e:expr, $bit_type:ty) => {\n"
"        println!(\"- {}: {:#x}\", stringify!($e), transmute::<_, "
"$bit_type>($e));\n"
"    };\n"
"}\n"
"\n"
"// Macro to wrap a value in 2^n Some() where n is the number of \"@\" "
"signs.\n"
"// Increasing the recursion limit is required to evaluate this macro.\n"
"macro_rules! many_options {\n"
"    ($value:expr) => { Some($value) };\n"
"    ($value:expr, @) => {\n"
"        Some(Some($value))\n"
"    };\n"
"    ($value:expr, @ $($more:tt)+) => {\n"
"        many_options!(many_options!($value, $($more)+), $($more)+)\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
"    // representation of types.\n"
"    unsafe {\n"
"        assert_eq!(many_options!(false), Some(false));\n"
"        assert_eq!(many_options!(false, @), Some(Some(false)));\n"
"        assert_eq!(many_options!(false, @@), "
"Some(Some(Some(Some(false)))));\n"
"\n"
"        println!(\"Bitwise representation of a chain of 128 Option's.\");\n"
"        dbg_bits!(many_options!(false, @@@@@@@), u8);\n"
"        dbg_bits!(many_options!(true, @@@@@@@), u8);\n"
"\n"
"        println!(\"Bitwise representation of a chain of 256 Option's.\");\n"
"        dbg_bits!(many_options!(false, @@@@@@@@), u16);\n"
"        dbg_bits!(many_options!(true, @@@@@@@@), u16);\n"
"\n"
"        println!(\"Bitwise representation of a chain of 257 Option's.\");\n"
"        dbg_bits!(many_options!(Some(false), @@@@@@@@), u16);\n"
"        dbg_bits!(many_options!(Some(true), @@@@@@@@), u16);\n"
"        dbg_bits!(many_options!(None::<bool>, @@@@@@@@), u16);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/novel.md:3
msgid ""
"Rust has a few control flow constructs which differ from other languages. "
"They are used for pattern matching:"
msgstr ""
"Rust tiene algunas construcciones de control de flujo que difieren de otros "
"lenguajes. Se utilizan para el patr√≥n de coincidencia:"

#: src/control-flow/novel.md:6 src/control-flow/if-let-expressions.md:1
msgid "`if let` expressions"
msgstr "Expresiones `if let`"

#: src/control-flow/novel.md:7
msgid "`while let` expressions"
msgstr "Expresiones `while let`"

#: src/control-flow/novel.md:8 src/control-flow/match-expressions.md:1
msgid "`match` expressions"
msgstr "Expresiones `match`"

#: src/control-flow/if-let-expressions.md:3
msgid ""
"The [`if let` expression](https://doc.rust-lang.org/reference/expressions/if-"
"expr.html#if-let-expressions) lets you execute different code depending on "
"whether a value matches a pattern:"
msgstr ""
"La [expresi√≥n `if let`][(https://doc.rust-lang.org/reference/expressions/if-"
"expr.html#if-let-expressions) te permite ejecutar c√≥digo diferente en "
"funci√≥n de si un valor coincide con un patr√≥n:"

#: src/control-flow/if-let-expressions.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let arg = std::env::args().next();\n"
"    if let Some(value) = arg {\n"
"        println!(\"Program name: {value}\");\n"
"    } else {\n"
"        println!(\"Missing name?\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/if-let-expressions.md:18
#: src/control-flow/while-let-expressions.md:21
#: src/control-flow/match-expressions.md:23
msgid ""
"See [pattern matching](../pattern-matching.md) for more details on patterns "
"in Rust."
msgstr ""
"Consulta de nuevo la secci√≥n de [coincidencia de patrones](../pattern-"
"matching.md) para obtener m√°s informaci√≥n sobre los patrones de Rust."

#: src/control-flow/if-let-expressions.md:23
msgid ""
"Unlike `match`, `if let` does not have to cover all branches. This can make "
"it more concise than `match`."
msgstr ""
"A diferencia de `match`, `if let` no tiene que cubrir todas las ramas, "
"pudiendo as√≠ conseguir que sea m√°s conciso que `match`."

#: src/control-flow/if-let-expressions.md:24
msgid "A common usage is handling `Some` values when working with `Option`."
msgstr ""
"Un uso habitual consiste en gestionar valores `Some` al trabajar con "
"`Option`."

#: src/control-flow/if-let-expressions.md:25
msgid ""
"Unlike `match`, `if let` does not support guard clauses for pattern matching."
msgstr ""
"A diferencia de `match`, `if let` no admite cl√°usulas guardia para la "
"coincidencia de patrones."

#: src/control-flow/if-let-expressions.md:26
msgid ""
"Since 1.65, a similar [let-else](https://doc.rust-lang.org/rust-by-example/"
"flow_control/let_else.html) construct allows to do a destructuring "
"assignment, or if it fails, execute a block which is required to abort "
"normal control flow (with `panic`/`return`/`break`/`continue`):"
msgstr ""
"A partir de la versi√≥n 1.65, una construcci√≥n [let-else](https://doc.rust-"
"lang.org/rust-by-example/flow_control/let_else.html) similar permite "
"realizar una tarea de desestructuraci√≥n o, si falla, ejecutar un bloque "
"necesario para anular el flujo de control normal (con `panic`/`return`/"
"`break`/`continue`)::"

#: src/control-flow/if-let-expressions.md:28
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"{:?}\", second_word_to_upper(\"foo bar\"));\n"
"}\n"
" \n"
"fn second_word_to_upper(s: &str) -> Option<String> {\n"
"    let mut it = s.split(' ');\n"
"    let (Some(_), Some(item)) = (it.next(), it.next()) else {\n"
"        return None;\n"
"    };\n"
"    Some(item.to_uppercase())\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/control-flow/while-let-expressions.md:1
msgid "`while let` loops"
msgstr "Bucles `while let`"

#: src/control-flow/while-let-expressions.md:3
msgid ""
"Like with `if let`, there is a [`while let`](https://doc.rust-lang.org/"
"reference/expressions/loop-expr.html#predicate-pattern-loops) variant which "
"repeatedly tests a value against a pattern:"
msgstr ""
"Al igual que con `if let`, hay una variante [`while let`](https://doc.rust-"
"lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops) que "
"prueba repetidamente un valor con respecto a un patr√≥n:"

#: src/control-flow/while-let-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();\n"
"\n"
"    while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/while-let-expressions.md:17
msgid ""
"Here the iterator returned by `v.into_iter()` will return a `Option<i32>` on "
"every call to `next()`. It returns `Some(x)` until it is done, after which "
"it will return `None`. The `while let` lets us keep iterating through all "
"items."
msgstr ""
"Aqu√≠, el iterador devuelto por `v.into_iter()` devolver√° `Option<i32>` en "
"cada llamada a `next()`. Devuelve `Some(x)` hasta que finaliza y, a "
"continuaci√≥n, devuelve `None`. `while let` nos permite seguir iterando a "
"trav√©s de todos los elementos."

#: src/control-flow/while-let-expressions.md:26
msgid ""
"Point out that the `while let` loop will keep going as long as the value "
"matches the pattern."
msgstr ""
"Se√±ala que el bucle `while let` seguir√° funcionando siempre que el valor "
"coincida con el patr√≥n."

#: src/control-flow/while-let-expressions.md:27
msgid ""
"You could rewrite the `while let` loop as an infinite loop with an if "
"statement that breaks when there is no value to unwrap for `iter.next()`. "
"The `while let` provides syntactic sugar for the above scenario."
msgstr ""
"Puedes reescribir el bucle `while let` como un ciclo infinito con una "
"instrucci√≥n if que deje de funcionar si `iter.next()` no tienen ning√∫n valor "
"que desenvolver. `while let` proporciona az√∫car sint√°ctico en la situaci√≥n "
"anterior."

#: src/control-flow/match-expressions.md:3
msgid ""
"The [`match` keyword](https://doc.rust-lang.org/reference/expressions/match-"
"expr.html) is used to match a value against one or more patterns. In that "
"sense, it works like a series of `if let` expressions:"
msgstr ""
"La \\[palabra clave `match`\\][`match` keyword](https://doc.rust-lang.org/"
"reference/expressions/match-expr.html) se usa para comparar un valor con uno "
"o varios patrones. En ese sentido, funciona como una serie de expresiones "
"`if let`:"

#: src/control-flow/match-expressions.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    match std::env::args().next().as_deref() {\n"
"        Some(\"cat\") => println!(\"Will do cat things\"),\n"
"        Some(\"ls\")  => println!(\"Will ls some files\"),\n"
"        Some(\"mv\")  => println!(\"Let's move some files\"),\n"
"        Some(\"rm\")  => println!(\"Uh, dangerous!\"),\n"
"        None        => println!(\"Hmm, no program name?\"),\n"
"        _           => println!(\"Unknown program name!\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/match-expressions.md:20
msgid ""
"Like `if let`, each match arm must have the same type. The type is the last "
"expression of the block, if any. In the example above, the type is `()`."
msgstr ""
"Al igual que con `if let`, cada brazo de coincidencia debe ser del mismo "
"tipo. El tipo es la √∫ltima expresi√≥n del bloque, si la hay. En el ejemplo "
"anterior, el tipo es `()`."

#: src/control-flow/match-expressions.md:28
msgid "Save the match expression to a variable and print it out."
msgstr "Guarda la expresi√≥n de coincidencia en una variable e impr√≠mela."

#: src/control-flow/match-expressions.md:29
msgid "Remove `.as_deref()` and explain the error."
msgstr "Elimina `.as_deref()` y explica el error."

#: src/control-flow/match-expressions.md:30
msgid ""
"`std::env::args().next()` returns an `Option<String>`, but we cannot match "
"against `String`."
msgstr ""
"`std::env::args().next()` devuelve `Option<String>`, pero no podemos "
"encontrar coincidencias con `String`."

#: src/control-flow/match-expressions.md:31
msgid ""
"`as_deref()` transforms an `Option<T>` to `Option<&T::Target>`. In our case, "
"this turns `Option<String>` into `Option<&str>`."
msgstr ""
"`as_deref()` transforma `Option<T>` en `Option<&T::Target>`. En nuestro "
"caso, esto convierte `Option<String>` en `Option<&str>`."

#: src/control-flow/match-expressions.md:32
msgid ""
"We can now use pattern matching to match against the `&str` inside `Option`."
msgstr ""
"Ahora podemos usar la coincidencia de patrones para encontrar coincidencias "
"con `&str` dentro de `Option`."

#: src/pattern-matching.md:3
msgid ""
"The `match` keyword let you match a value against one or more _patterns_. "
"The comparisons are done from top to bottom and the first match wins."
msgstr ""
"La palabra clave `match` te permite comparar un valor con uno o varios "
"_patrones_. Las comparaciones se hacen de arriba abajo y el primero que "
"coincida gana."

#: src/pattern-matching.md:6
msgid "The patterns can be simple values, similarly to `switch` in C and C++:"
msgstr ""
"Los patrones pueden ser valores simples, del mismo modo que `switch` en C y "
"C++:"

#: src/pattern-matching.md:8
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let input = 'x';\n"
"\n"
"    match input {\n"
"        'q'                   => println!(\"Quitting\"),\n"
"        'a' | 's' | 'w' | 'd' => println!(\"Moving around\"),\n"
"        '0'..='9'             => println!(\"Number input\"),\n"
"        _                     => println!(\"Something else\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching.md:21
msgid "The `_` pattern is a wildcard pattern which matches any value."
msgstr "`_` es un patr√≥n comod√≠n que coincide con cualquier valor."

#: src/pattern-matching.md:26
msgid ""
"You might point out how some specific characters are being used when in a "
"pattern"
msgstr "Puedes se√±alar c√≥mo se usan algunos caracteres concretos en un patr√≥n"

#: src/pattern-matching.md:27
msgid "`|` as an `or`"
msgstr "`|` como `or`,"

#: src/pattern-matching.md:28
msgid "`..` can expand as much as it needs to be"
msgstr "`..` se puede ampliar tanto como sea necesario."

#: src/pattern-matching.md:29
msgid "`1..=5` represents an inclusive range"
msgstr "`1..=5` representa un intervalo inclusivo."

#: src/pattern-matching.md:30
msgid "`_` is a wild card"
msgstr "`_` es un comod√≠n."

#: src/pattern-matching.md:31
msgid ""
"It can be useful to show how binding works, by for instance replacing a "
"wildcard character with a variable, or removing the quotes around `q`."
msgstr ""
"Puede ser √∫til para mostrar c√≥mo funciona un enlace, por ejemplo, cambiando "
"un car√°cter comod√≠n por una variable o quitando las comillas alrededor de "
"`q`. "

#: src/pattern-matching.md:32
msgid "You can demonstrate matching on a reference."
msgstr "Puedes mostrar la coincidencia con una referencia."

#: src/pattern-matching.md:33
msgid ""
"This might be a good time to bring up the concept of irrefutable patterns, "
"as the term can show up in error messages."
msgstr ""
"Este puede ser un buen momento para mencionar el concepto de patrones "
"irrefutables, ya que el t√©rmino puede aparecer en mensajes de error."

#: src/pattern-matching/destructuring-enums.md:3
msgid ""
"Patterns can also be used to bind variables to parts of your values. This is "
"how you inspect the structure of your types. Let us start with a simple "
"`enum` type:"
msgstr ""
"Los patrones tambi√©n se pueden usar para enlazar variables a partes de los "
"valores. As√≠ es como se inspecciona la estructura de tus tipos. Empecemos "
"con un tipo `enum` sencillo:"

#: src/pattern-matching/destructuring-enums.md:6
msgid ""
"```rust,editable\n"
"enum Result {\n"
"    Ok(i32),\n"
"    Err(String),\n"
"}\n"
"\n"
"fn divide_in_two(n: i32) -> Result {\n"
"    if n % 2 == 0 {\n"
"        Result::Ok(n / 2)\n"
"    } else {\n"
"        Result::Err(format!(\"cannot divide {n} into two equal parts\"))\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let n = 100;\n"
"    match divide_in_two(n) {\n"
"        Result::Ok(half) => println!(\"{n} divided in two is {half}\"),\n"
"        Result::Err(msg) => println!(\"sorry, an error happened: {msg}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/destructuring-enums.md:29
msgid ""
"Here we have used the arms to _destructure_ the `Result` value. In the first "
"arm, `half` is bound to the value inside the `Ok` variant. In the second "
"arm, `msg` is bound to the error message."
msgstr ""
"Aqu√≠ hemos utilizado los brazos para _desestructurar_ el valor de `Result`. "
"En el primer brazo, `half` est√° vinculado al valor que hay dentro de la "
"variante `Ok`. En el segundo, `msg` est√° vinculado al mensaje de error."

#: src/pattern-matching/destructuring-enums.md:36
msgid ""
"The `if`/`else` expression is returning an enum that is later unpacked with "
"a `match`."
msgstr ""
"La expresi√≥n `if`/`else` devuelve una enumeraci√≥n que m√°s tarde se "
"descomprime con `match`."

#: src/pattern-matching/destructuring-enums.md:37
msgid ""
"You can try adding a third variant to the enum definition and displaying the "
"errors when running the code. Point out the places where your code is now "
"inexhaustive and how the compiler tries to give you hints."
msgstr ""
"Puedes probar a a√±adir una tercera variante a la definici√≥n de la "
"enumeraci√≥n y mostrar los errores al ejecutar el c√≥digo. Se√±ala los lugares "
"en los que tu c√≥digo est√° ahora incompleto y explica c√≥mo el compilador "
"intenta dar sugerencias."

#: src/pattern-matching/destructuring-structs.md:3
msgid "You can also destructure `structs`:"
msgstr "Tambi√©n puedes desestructurar `structs`:"

#: src/pattern-matching/destructuring-structs.md:5
msgid ""
"```rust,editable\n"
"struct Foo {\n"
"    x: (u32, u32),\n"
"    y: u32,\n"
"}\n"
"\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let foo = Foo { x: (1, 2), y: 3 };\n"
"    match foo {\n"
"        Foo { x: (1, b), y } => println!(\"x.0 = 1, b = {b}, y = {y}\"),\n"
"        Foo { y: 2, x: i }   => println!(\"y = 2, x = {i:?}\"),\n"
"        Foo { y, .. }        => println!(\"y = {y}, other fields were "
"ignored\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/destructuring-structs.md:23
msgid "Change the literal values in `foo` to match with the other patterns."
msgstr ""
"Cambia los valores literales de `foo` para que coincidan con los dem√°s "
"patrones."

#: src/pattern-matching/destructuring-structs.md:24
msgid "Add a new field to `Foo` and make changes to the pattern as needed."
msgstr ""
"A√±ade un campo nuevo a `Foo` y realiza los cambios necesarios en el patr√≥n."

#: src/pattern-matching/destructuring-structs.md:25
msgid ""
"The distinction between a capture and a constant expression can be hard to "
"spot. Try changing the `2` in the second arm to a variable, and see that it "
"subtly doesn't work. Change it to a `const` and see it working again."
msgstr ""
"La diferencia entre una captura y una expresi√≥n constante puede ser dif√≠cil "
"de detectar. Prueba a cambiar el `2` del segundo brazo por una variable y "
"observa que no funciona. C√°mbialo a `const` y ver√°s que vuelve a funcionar."

#: src/pattern-matching/destructuring-arrays.md:3
msgid ""
"You can destructure arrays, tuples, and slices by matching on their elements:"
msgstr ""
"Puedes desestructurar arrays, tuplas y slices haciendo coincidir sus "
"elementos:"

#: src/pattern-matching/destructuring-arrays.md:5
msgid ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let triple = [0, -2, 3];\n"
"    println!(\"Tell me about {triple:?}\");\n"
"    match triple {\n"
"        [0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"        [1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
"        _         => println!(\"All elements were ignored\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/destructuring-arrays.md:21
msgid ""
"Destructuring of slices of unknown length also works with patterns of fixed "
"length."
msgstr ""
"La desestructuraci√≥n de slices de longitud desconocida tambi√©n funciona con "
"patrones de longitud fija."

#: src/pattern-matching/destructuring-arrays.md:24
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    inspect(&[0, -2, 3]);\n"
"    inspect(&[0, -2, 3, 4]);\n"
"}\n"
"\n"
"#[rustfmt::skip]\n"
"fn inspect(slice: &[i32]) {\n"
"    println!(\"Tell me about {slice:?}\");\n"
"    match slice {\n"
"        &[0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"        &[1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
"        _          => println!(\"All elements were ignored\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/destructuring-arrays.md:41
msgid "Create a new pattern using `_` to represent an element. "
msgstr "Crea un patr√≥n con `_` para representar un elemento. "

#: src/pattern-matching/destructuring-arrays.md:42
msgid "Add more values to the array."
msgstr "A√±ade m√°s valores al array."

#: src/pattern-matching/destructuring-arrays.md:43
msgid ""
"Point out that how `..` will expand to account for different number of "
"elements."
msgstr ""
"Se√±ala c√≥mo `..` se expandir√° para representar un n√∫mero distinto de "
"elementos."

#: src/pattern-matching/destructuring-arrays.md:44
msgid "Show matching against the tail with patterns `[.., b]` and `[a@..,b]`"
msgstr ""
"Muestra las coincidencias de tail con los patrones `[.., b]` y `[a@..,b]`."

#: src/pattern-matching/match-guards.md:3
msgid ""
"When matching, you can add a _guard_ to a pattern. This is an arbitrary "
"Boolean expression which will be executed if the pattern matches:"
msgstr ""
"Al establecer coincidencias, puedes a√±adir un _guardia_ a un patr√≥n. Se "
"trata de una expresi√≥n booleana arbitraria que se ejecutar√° si el patr√≥n "
"coincide:"

#: src/pattern-matching/match-guards.md:6
msgid ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let pair = (2, -2);\n"
"    println!(\"Tell me about {pair:?}\");\n"
"    match pair {\n"
"        (x, y) if x == y     => println!(\"These are twins\"),\n"
"        (x, y) if x + y == 0 => println!(\"Antimatter, kaboom!\"),\n"
"        (x, _) if x % 2 == 1 => println!(\"The first one is odd\"),\n"
"        _                    => println!(\"No correlation...\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/match-guards.md:23
msgid ""
"Match guards as a separate syntax feature are important and necessary when "
"we wish to concisely express more complex ideas than patterns alone would "
"allow."
msgstr ""
"Las guardas de coincidencia, como caracter√≠stica sint√°ctica independiente, "
"son importantes y necesarios cuando queremos expresar de forma concisa ideas "
"m√°s complejas de lo que permitir√≠an los patrones por s√≠ solos."

#: src/pattern-matching/match-guards.md:24
msgid ""
"They are not the same as separate `if` expression inside of the match arm. "
"An `if` expression inside of the branch block (after `=>`) happens after the "
"match arm is selected. Failing the `if` condition inside of that block won't "
"result in other arms of the original `match` expression being considered."
msgstr ""
"No son lo mismo que una expresi√≥n `if` independiente dentro del brazo de "
"coincidencias. Una expresi√≥n `if` dentro del bloque de ramas (despu√©s de "
"`=>`) se produce tras seleccionar el brazo de coincidencias. Si no se cumple "
"la condici√≥n `if` dentro de ese bloque, no se tienen en cuenta otros brazos "
"de la expresi√≥n `match` original."

#: src/pattern-matching/match-guards.md:26
msgid "You can use the variables defined in the pattern in your if expression."
msgstr "Puedes usar las variables definidas en el patr√≥n en tu expresi√≥n if."

#: src/pattern-matching/match-guards.md:27
msgid ""
"The condition defined in the guard applies to every expression in a pattern "
"with an `|`."
msgstr ""
"La condici√≥n definida en el guarda se aplica a todas las expresiones de un "
"patr√≥n con un `|`."

#: src/exercises/day-1/afternoon.md:1
msgid "Day 1: Afternoon Exercises"
msgstr "D√≠a 1: Ejercicios de la Tarde"

#: src/exercises/day-1/afternoon.md:3
msgid "We will look at two things:"
msgstr "Veremos todas estas cosas:"

#: src/exercises/day-1/afternoon.md:5
msgid "The Luhn algorithm,"
msgstr "Algoritmo de Luhn"

#: src/exercises/day-1/afternoon.md:7
msgid "An exercise on pattern matching."
msgstr "Un ejercicio sobre coincidencia de patrones."

#: src/exercises/day-1/afternoon.md:11 src/exercises/day-2/afternoon.md:7
#: src/exercises/bare-metal/afternoon.md:7
#: src/exercises/concurrency/afternoon.md:13
msgid ""
"After looking at the exercises, you can look at the [solutions](solutions-"
"afternoon.md) provided."
msgstr ""
"Luego de ver los ejercicios, puedes ver las [soluciones](solutions-afternoon."
"md) que se brindan."

#: src/exercises/day-1/luhn.md:3
msgid ""
"The [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm) is used "
"to validate credit card numbers. The algorithm takes a string as input and "
"does the following to validate the credit card number:"
msgstr ""
"El [algoritmo de Luhn](https://es.wikipedia.org/wiki/Luhn_algorithm) se usa "
"para validar n√∫meros de tarjetas de cr√©dito. El algoritmo toma una cadena "
"como entrada y hace lo siguiente para validar el n√∫mero de la tarjeta de "
"cr√©dito:"

#: src/exercises/day-1/luhn.md:7
msgid "Ignore all spaces. Reject number with less than two digits."
msgstr ""
"Ignora todos los espacios. Rechaza los n√∫meros con menos de dos d√≠gitos."

#: src/exercises/day-1/luhn.md:9
msgid ""
"Moving from **right to left**, double every second digit: for the number "
"`1234`, we double `3` and `1`. For the number `98765`, we double `6` and `8`."
msgstr ""
"De derecha a izquierda, duplica cada dos cifras: en el caso del n√∫mero "
"`1234`, se duplica el `3` y el `1`. En el caso del n√∫mero `98765`, se "
"duplica el `6` y el `8`."

#: src/exercises/day-1/luhn.md:12
#, fuzzy
msgid ""
"After doubling a digit, sum the digits if the result is greater than 9. So "
"doubling `7` becomes `14` which becomes `1 + 4 = 5`."
msgstr ""
"Despu√©s de duplicar un d√≠gito, se suman los d√≠gitos que contiene. Por tanto, "
"si duplicas `7`, pasar√° a ser `14`, lo cual pasar√° a ser `5`."

#: src/exercises/day-1/luhn.md:15
msgid "Sum all the undoubled and doubled digits."
msgstr "Suma todos los d√≠gitos, no duplicados y duplicados."

#: src/exercises/day-1/luhn.md:17
msgid "The credit card number is valid if the sum ends with `0`."
msgstr ""
"El n√∫mero de la tarjeta de cr√©dito es v√°lido si la suma termina en `0`."

#: src/exercises/day-1/luhn.md:19
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and implement the "
"function."
msgstr ""
"Copia el siguiente fragmento de c√≥digo en <https://play.rust-lang.org/> e "
"implementa la funci√≥n:"

#: src/exercises/day-1/luhn.md:21
msgid ""
"Try to solve the problem the \"simple\" way first, using `for` loops and "
"integers. Then, revisit the solution and try to implement it with iterators."
msgstr ""
"Intenta resolver el problema de la forma \"sencilla\" primero, usando bucles "
"`for` e enteros. Luego, vuelve a la soluci√≥n e intenta implementarla con "
"iteradores."

#: src/exercises/day-1/luhn.md:25
msgid ""
"```rust\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub fn luhn(cc_number: &str) -> bool {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\"));\n"
"    assert!(!luhn(\"foo 0 0\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_empty_cc_number() {\n"
"    assert!(!luhn(\"\"));\n"
"    assert!(!luhn(\" \"));\n"
"    assert!(!luhn(\"  \"));\n"
"    assert!(!luhn(\"    \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_single_digit_cc_number() {\n"
"    assert!(!luhn(\"0\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_two_digit_cc_number() {\n"
"    assert!(luhn(\" 0 0 \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_valid_cc_number() {\n"
"    assert!(luhn(\"4263 9826 4026 9299\"));\n"
"    assert!(luhn(\"4539 3195 0343 6467\"));\n"
"    assert!(luhn(\"7992 7398 713\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_invalid_cc_number() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}\n"
"\n"
"#[allow(dead_code)]\n"
"fn main() {}\n"
"```"
msgstr ""

#: src/welcome-day-2.md:1
msgid "Welcome to Day 2"
msgstr "Te damos la bienvenida al d√≠a 2"

#: src/welcome-day-2.md:3
msgid "Now that we have seen a fair amount of Rust, we will continue with:"
msgstr ""
"Ahora que ya sabemos bastante sobre Rust, continuaremos con lo siguiente:"

#: src/welcome-day-2.md:5
msgid ""
"Memory management: stack vs heap, manual memory management, scope-based "
"memory management, and garbage collection."
msgstr ""
"Gesti√≥n de la memoria: _stack_ (pila) vs _heap_ (mont√≠culo), gesti√≥n manual "
"de la memoria, gesti√≥n de la memoria basada en √°mbitos y _garbage collector_ "
"(recolecci√≥n de memoria residual)."

#: src/welcome-day-2.md:8
msgid ""
"Ownership: move semantics, copying and cloning, borrowing, and lifetimes."
msgstr ""
"_Ownership_ (Propiedad): sem√°ntica de movimiento, copiar, clonar, "
"_borrowing_ (pr√©stamos) y _lifetimes_ (tiempos de vida)."

#: src/welcome-day-2.md:10
msgid "Structs and methods."
msgstr "Estructuras (_Structs_) y m√©todos."

#: src/welcome-day-2.md:12
msgid ""
"The Standard Library: `String`, `Option` and `Result`, `Vec`, `HashMap`, "
"`Rc` and `Arc`."
msgstr ""
"La Biblioteca Est√°ndar (_Standard Library_): `String`, `Option` y `Result`, "
"`Vec`, `HashMap`, `Rc` y `Arc`."

#: src/welcome-day-2.md:15
msgid "Modules: visibility, paths, and filesystem hierarchy."
msgstr "M√≥dulos: visibilidad, rutas y jerarqu√≠a del sistema de archivos."

#: src/memory-management.md:3
msgid "Traditionally, languages have fallen into two broad categories:"
msgstr "Tradicionalmente, los lenguajes se dividen en dos grandes categor√≠as:"

#: src/memory-management.md:5
msgid "Full control via manual memory management: C, C++, Pascal, ..."
msgstr ""
"Control total a trav√©s de la gesti√≥n manual de la memoria: C, C++, Pascal, "
"etc."

#: src/memory-management.md:6
msgid ""
"Full safety via automatic memory management at runtime: Java, Python, Go, "
"Haskell, ..."
msgstr ""
"Seguridad total mediante la gesti√≥n autom√°tica de la memoria en _runtime_: "
"Java, Python, Go, Haskell, etc."

#: src/memory-management.md:8
msgid "Rust offers a new mix:"
msgstr "Rust ofrece una mezcla de ambas:"

#: src/memory-management.md:10
msgid ""
"Full control _and_ safety via compile time enforcement of correct memory "
"management."
msgstr ""
"Control _y_ seguridad completa gracias a que el compilador se encarga del "
"correcto manejo de la memoria"

#: src/memory-management.md:13
msgid "It does this with an explicit ownership concept."
msgstr ""
"Para ello, se utiliza un concepto de _ownership_ (propiedad) expl√≠cito."

#: src/memory-management.md:15
msgid "First, let's refresh how memory management works."
msgstr "En primer lugar, veamos c√≥mo funciona la gesti√≥n de la memoria."

#: src/memory-management/stack-vs-heap.md:1
msgid "The Stack vs The Heap"
msgstr "_Stack_ (Pila) vs _Heap_ (Mont√≠culo)"

#: src/memory-management/stack-vs-heap.md:3
msgid "Stack: Continuous area of memory for local variables."
msgstr "_Stack_: Zona de memoria continua para las variables locales."

#: src/memory-management/stack-vs-heap.md:4
msgid "Values have fixed sizes known at compile time."
msgstr "Los valores tienen tama√±os fijos conocidos en tiempo de compilaci√≥n."

#: src/memory-management/stack-vs-heap.md:5
msgid "Extremely fast: just move a stack pointer."
msgstr "Muy r√°pida: mueve el _stack pointer_."

#: src/memory-management/stack-vs-heap.md:6
msgid "Easy to manage: follows function calls."
msgstr "F√°cil de gestionar: sigue las llamadas de funciones."

#: src/memory-management/stack-vs-heap.md:7
msgid "Great memory locality."
msgstr "Excelente localidad de memoria."

#: src/memory-management/stack-vs-heap.md:9
msgid "Heap: Storage of values outside of function calls."
msgstr "_Heap_: almacenamiento de valores fuera de las llamadas de funciones."

#: src/memory-management/stack-vs-heap.md:10
msgid "Values have dynamic sizes determined at runtime."
msgstr "Los valores tienen tama√±os din√°micos determinados en _runtime_."

#: src/memory-management/stack-vs-heap.md:11
msgid "Slightly slower than the stack: some book-keeping needed."
msgstr "Ligeramente m√°s lento que el _stack_: requiere cierta trazabilidad."

#: src/memory-management/stack-vs-heap.md:12
msgid "No guarantee of memory locality."
msgstr "No se puede asegurar la localidad de la memoria."

#: src/memory-management/stack.md:1
msgid "Stack and Heap Example"
msgstr "Ejemplo de _Stack_ y de _Heap_"

#: src/memory-management/stack.md:3
msgid ""
"Creating a `String` puts fixed-sized metadata on the stack and dynamically "
"sized data, the actual string, on the heap:"
msgstr ""
"Al crear un `String`, los metadatos de tama√±o fijo se colocan en la _stack_ "
"y los datos de tama√±o din√°mico (la cadena real) en el _heap_:"

#: src/memory-management/stack.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1 = String::from(\"Hello\");\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/stack.md:12
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - -.\n"
":                           :     :                               :\n"
":    s1                     :     :                               :\n"
":   +-----------+-------+   :     :   +----+----+----+----+----+  :\n"
":   | ptr       |   o---+---+-----+-->| H  | e  | l  | l  | o  |  :\n"
":   | len       |     5 |   :     :   +----+----+----+----+----+  :\n"
":   | capacity  |     5 |   :     :                               :\n"
":   +-----------+-------+   :     :                               :\n"
":                           :     `- - - - - - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/memory-management/stack.md:28
msgid ""
"Mention that a `String` is backed by a `Vec`, so it has a capacity and "
"length and can grow if mutable via reallocation on the heap."
msgstr ""
"Menciona que un `String` est√° respaldado por un `Vec`, por lo que tiene "
"capacidad y longitud y, si es mutable, puede crecer mediante reasignaci√≥n en "
"el _heap_."

#: src/memory-management/stack.md:30
msgid ""
"If students ask about it, you can mention that the underlying memory is heap "
"allocated using the [System Allocator](https://doc.rust-lang.org/std/alloc/"
"struct.System.html) and custom allocators can be implemented using the "
"[Allocator API](https://doc.rust-lang.org/std/alloc/index.html)"
msgstr ""
"Si los alumnos lo preguntan, puedes mencionar que la memoria subyacente "
"recibe una asignaci√≥n de _heap_ mediante el [Asignador del Sistema](https://"
"doc.rust-lang.org/std/alloc/struct.System.html) y que se pueden implementar "
"asignadores personalizados mediante el [_Allocator API_](https://doc.rust-"
"lang.org/std/alloc/index.html)."

#: src/memory-management/stack.md:32
msgid ""
"We can inspect the memory layout with `unsafe` code. However, you should "
"point out that this is rightfully unsafe!"
msgstr ""
"Podemos inspeccionar la disposici√≥n de la memoria con c√≥digo `unsafe`. Sin "
"embargo, debes se√±alar que esto no es seguro."

#: src/memory-management/stack.md:34
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::from(\"Hello\");\n"
"    s1.push(' ');\n"
"    s1.push_str(\"world\");\n"
"    // DON'T DO THIS AT HOME! For educational purposes only.\n"
"    // String provides no guarantees about its layout, so this could lead "
"to\n"
"    // undefined behavior.\n"
"    unsafe {\n"
"        let (ptr, capacity, len): (usize, usize, usize) = std::mem::"
"transmute(s1);\n"
"        println!(\"ptr = {ptr:#x}, len = {len}, capacity = {capacity}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/manual.md:3
msgid "You allocate and deallocate heap memory yourself."
msgstr "Eres t√∫ quien asigna y desasigna la memoria del _heap_."

#: src/memory-management/manual.md:5
msgid ""
"If not done with care, this can lead to crashes, bugs, security "
"vulnerabilities, and memory leaks."
msgstr ""
"Si no lo haces con cuidado, podr√≠an producirse fallos, errores, "
"vulnerabilidades de seguridad y p√©rdidas de memoria."

#: src/memory-management/manual.md:7
msgid "C Example"
msgstr "Ejemplo en C"

#: src/memory-management/manual.md:9
msgid "You must call `free` on every pointer you allocate with `malloc`:"
msgstr "Debes llamar a `free` en cada puntero que asignes con `malloc`:"

#: src/memory-management/manual.md:11
msgid ""
"```c\n"
"void foo(size_t n) {\n"
"    int* int_array = malloc(n * sizeof(int));\n"
"    //\n"
"    // ... lots of code\n"
"    //\n"
"    free(int_array);\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/manual.md:21
msgid ""
"Memory is leaked if the function returns early between `malloc` and `free`: "
"the pointer is lost and we cannot deallocate the memory. Worse, freeing the "
"pointer twice, or accessing a freed pointer can lead to exploitable security "
"vulnerabilities."
msgstr ""
"La memoria se pierde si la funci√≥n devuelve un resultado antes de tiempo "
"entre `malloc` y `free`: el puntero se pierde y no podemos anular la "
"asignaci√≥n de la memoria. Peor a√∫n, si se libera el puntero dos veces o si "
"se accede a uno liberado, pueden producirse vulnerabilidades de seguridad de "
"las que otros podr√≠an aprovecharse."

#: src/memory-management/scope-based.md:3
msgid ""
"Constructors and destructors let you hook into the lifetime of an object."
msgstr ""
"Los constructores y destructores permiten acceder al tiempo de vida de un "
"objeto."

#: src/memory-management/scope-based.md:5
msgid ""
"By wrapping a pointer in an object, you can free memory when the object is "
"destroyed. The compiler guarantees that this happens, even if an exception "
"is raised."
msgstr ""
"Al envolver un puntero en un objeto, puedes liberar memoria cuando el objeto "
"se destruya. El compilador asegura que esto ocurra, aunque se genere una "
"excepci√≥n."

#: src/memory-management/scope-based.md:9
msgid ""
"This is often called _resource acquisition is initialization_ (RAII) and "
"gives you smart pointers."
msgstr ""
"A menudo, significa que la _adquisici√≥n de recursos es la inicializaci√≥n_ "
"(RAII) y te proporciona punteros inteligentes."

#: src/memory-management/scope-based.md:12
msgid "C++ Example"
msgstr "Ejemplo en C++"

#: src/memory-management/scope-based.md:14
msgid ""
"```c++\n"
"void say_hello(std::unique_ptr<Person> person) {\n"
"  std::cout << \"Hello \" << person->name << std::endl;\n"
"}\n"
"```"
msgstr ""
"```c++\n"
"void say_hello(std::unique_ptr<Person> person) {\n"
"  std::cout << \"Hola \" << person->name << std::endl;\n"
"}\n"
"```"

#: src/memory-management/scope-based.md:20
msgid ""
"The `std::unique_ptr` object is allocated on the stack, and points to memory "
"allocated on the heap."
msgstr ""
"El objeto `std::unique_ptr` se reserva en el _stack_ y apunta a la memoria "
"asignada en el _heap_."

#: src/memory-management/scope-based.md:22
msgid "At the end of `say_hello`, the `std::unique_ptr` destructor will run."
msgstr "Al final de `say_hello`, se ejecuta el destructor `std::unique_ptr`."

#: src/memory-management/scope-based.md:23
msgid "The destructor frees the `Person` object it points to."
msgstr "El destructor libera el objeto `Person` al que apunta."

#: src/memory-management/scope-based.md:25
msgid ""
"Special move constructors are used when passing ownership to a function:"
msgstr ""
"Los constructores de movimiento especiales se utilizan cuando se pasa el "
"_ownership_ a una funci√≥n:"

#: src/memory-management/scope-based.md:27
msgid ""
"```c++\n"
"std::unique_ptr<Person> person = find_person(\"Carla\");\n"
"say_hello(std::move(person));\n"
"```"
msgstr ""

#: src/memory-management/garbage-collection.md:1
msgid "Automatic Memory Management"
msgstr "Gesti√≥n Autom√°tica de la Memoria"

#: src/memory-management/garbage-collection.md:3
msgid ""
"An alternative to manual and scope-based memory management is automatic "
"memory management:"
msgstr ""
"Una alternativa a la gesti√≥n manual de la memoria basada en el √°mbito es la "
"gesti√≥n autom√°tica de la memoria:"

#: src/memory-management/garbage-collection.md:6
msgid "The programmer never allocates or deallocates memory explicitly."
msgstr ""
"El programador nunca asigna ni desasigna la memoria de forma expl√≠cita."

#: src/memory-management/garbage-collection.md:7
msgid ""
"A garbage collector finds unused memory and deallocates it for the "
"programmer."
msgstr ""
"Un _garbage collector_ (recolector de memoria residual) encuentra la que no "
"se utiliza y la desasigna para el programador."

#: src/memory-management/garbage-collection.md:9
msgid "Java Example"
msgstr "Ejemplo en Java"

#: src/memory-management/garbage-collection.md:11
msgid "The `person` object is not deallocated after `sayHello` returns:"
msgstr ""
"El objeto `person` no se libera despu√©s de que `sayHello` devuelva el "
"siguiente resultado:"

#: src/memory-management/garbage-collection.md:13
msgid ""
"```java\n"
"void sayHello(Person person) {\n"
"  System.out.println(\"Hello \" + person.getName());\n"
"}\n"
"```"
msgstr ""
"```java\n"
"void sayHello(Person person) {\n"
"  System.out.println(\"Hola \" + person.getName());\n"
"}\n"
"```"

#: src/memory-management/rust.md:1
msgid "Memory Management in Rust"
msgstr "Gesti√≥n de la Memoria en Rust"

#: src/memory-management/rust.md:3
msgid "Memory management in Rust is a mix:"
msgstr "La gesti√≥n de la memoria en Rust es una mezcla:"

#: src/memory-management/rust.md:5
msgid "Safe and correct like Java, but without a garbage collector."
msgstr "Segura y correcta como Java, pero sin _garbage collector_."

#: src/memory-management/rust.md:6
msgid "Scope-based like C++, but the compiler enforces full adherence."
msgstr ""
"Est√° basada en el √°mbito, como C++, pero el compilador cumple con todas las "
"normas."

#: src/memory-management/rust.md:7
msgid ""
"A Rust user can choose the right abstraction for the situation, some even "
"have no cost at runtime like C."
msgstr ""
"Un usuario de Rust puede elegir la abstracci√≥n adecuada para cada situaci√≥n, "
"algunas ni siquiera tienen coste en _runtime_, como C."

#: src/memory-management/rust.md:9
msgid "Rust achieves this by modeling _ownership_ explicitly."
msgstr "Rust lo consigue modelando expl√≠citamente el _ownership_."

#: src/memory-management/rust.md:13
msgid ""
"If asked how at this point, you can mention that in Rust this is usually "
"handled by RAII wrapper types such as [Box](https://doc.rust-lang.org/std/"
"boxed/struct.Box.html), [Vec](https://doc.rust-lang.org/std/vec/struct.Vec."
"html), [Rc](https://doc.rust-lang.org/std/rc/struct.Rc.html), or [Arc]"
"(https://doc.rust-lang.org/std/sync/struct.Arc.html). These encapsulate "
"ownership and memory allocation via various means, and prevent the potential "
"errors in C."
msgstr ""
"Si en este momento te preguntan c√≥mo, puedes mencionar que en Rust se suele "
"gestionar con tipos de envoltorios RAII, como [Box](https://doc.rust-lang."
"org/std/boxed/struct.Box.html), [Vec]https://doc.rust-lang.org/std/vec/"
"struct.Vec.html), [Rc](https://doc.rust-lang.org/std/rc/struct.Rc.html) o "
"[Arc](https://doc.rust-lang.org/std/sync/struct.Arc.html). Estos encapsulan "
"el _ownership_ y la asignaci√≥n de memoria a trav√©s de diversos medios, "
"evitando as√≠ los posibles errores en C."

#: src/memory-management/rust.md:15
msgid ""
"You may be asked about destructors here, the [Drop](https://doc.rust-lang."
"org/std/ops/trait.Drop.html) trait is the Rust equivalent."
msgstr ""
"Puede que aqu√≠ te pregunten por los destructores, as√≠ que debes saber que el "
"trait [Drop](https://doc.rust-lang.org/std/ops/trait.Drop.html) es el "
"equivalente en Rust."

#: src/ownership.md:3
msgid ""
"All variable bindings have a _scope_ where they are valid and it is an error "
"to use a variable outside its scope:"
msgstr ""
"Todos los enlaces a variables tienen un _√°mbito_ donde son v√°lidos y se "
"produce un error cuando se usan fuera de √©l:"

#: src/ownership.md:6
msgid ""
"```rust,editable,compile_fail\n"
"struct Point(i32, i32);\n"
"\n"
"fn main() {\n"
"    {\n"
"        let p = Point(3, 4);\n"
"        println!(\"x: {}\", p.0);\n"
"    }\n"
"    println!(\"y: {}\", p.1);\n"
"}\n"
"```"
msgstr ""

#: src/ownership.md:18
msgid ""
"At the end of the scope, the variable is _dropped_ and the data is freed."
msgstr "Al final del √°mbito, la variable _se elimina_ y los datos se liberan."

#: src/ownership.md:19
msgid "A destructor can run here to free up resources."
msgstr "Se puede ejecutar un destructor para liberar recursos."

#: src/ownership.md:20
msgid "We say that the variable _owns_ the value."
msgstr "Decimos que el valor _pertenece_ a la variable."

#: src/ownership/move-semantics.md:3
msgid "An assignment will transfer _ownership_ between variables:"
msgstr "Una asignaci√≥n transferir√° su _ownership_ entre variables:"

#: src/ownership/move-semantics.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Hello!\");\n"
"    let s2: String = s1;\n"
"    println!(\"s2: {s2}\");\n"
"    // println!(\"s1: {s1}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Hola!\");\n"
"    let s2: String = s1;\n"
"    println!(\"s2: {s2}\");\n"
"    // println!(\"s1: {s1}\");\n"
"}\n"
"```"

#: src/ownership/move-semantics.md:14
msgid "The assignment of `s1` to `s2` transfers ownership."
msgstr "La asignaci√≥n de `s1` a `s2` transfiere el _ownership_."

#: src/ownership/move-semantics.md:15
msgid "When `s1` goes out of scope, nothing happens: it does not own anything."
msgstr ""
"Cuando `s1` queda fuera del √°mbito, no ocurre nada: no le pertenece nada."

#: src/ownership/move-semantics.md:16
msgid "When `s2` goes out of scope, the string data is freed."
msgstr "Cuando `s2` sale del √°mbito, los datos de la cadena se liberan."

#: src/ownership/move-semantics.md:17
msgid "There is always _exactly_ one variable binding which owns a value."
msgstr "Siempre hay _exactamente_ un enlace a variable que posee un valor."

#: src/ownership/move-semantics.md:21
msgid ""
"Mention that this is the opposite of the defaults in C++, which copies by "
"value unless you use `std::move` (and the move constructor is defined!)."
msgstr ""
"Menciona que es lo contrario de los valores predeterminados de C++, que se "
"copian por valor, a menos que utilices `std::move` (y que el constructor de "
"movimiento est√© definido)."

#: src/ownership/move-semantics.md:23
msgid ""
"It is only the ownership that moves. Whether any machine code is generated "
"to manipulate the data itself is a matter of optimization, and such copies "
"are aggressively optimized away."
msgstr ""
"Es √∫nicamente el ownership el que se mueve. Si se genera alg√∫n c√≥digo "
"m√°quina para manipular los datos en s√≠, se trata de una cuesti√≥n de "
"optimizaci√≥n, y esas copias se optimizan de forma agresiva."

#: src/ownership/move-semantics.md:25
msgid ""
"Simple values (such as integers) can be marked `Copy` (see later slides)."
msgstr ""
"Los valores simples (como los enteros) se pueden marcar como `Copy` "
"(consulta las diapositivas posteriores)."

#: src/ownership/move-semantics.md:27
msgid "In Rust, clones are explicit (by using `clone`)."
msgstr "En Rust, la clonaci√≥n es expl√≠cita (usando `clone`)."

#: src/ownership/moved-strings-rust.md:3
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Rust\");\n"
"    let s2: String = s1;\n"
"}\n"
"```"
msgstr ""

#: src/ownership/moved-strings-rust.md:10
msgid "The heap data from `s1` is reused for `s2`."
msgstr "Los datos del _heap_ de `s1` se reutilizan en `s2`."

#: src/ownership/moved-strings-rust.md:11
msgid "When `s1` goes out of scope, nothing happens (it has been moved from)."
msgstr "Cuando `s1` sale del √°mbito, no ocurre nada (ha sido movida)."

#: src/ownership/moved-strings-rust.md:13
msgid "Before move to `s2`:"
msgstr "Antes de mover a `s2`:"

#: src/ownership/moved-strings-rust.md:15
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1                     :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+-----+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :     :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :     :                           :\n"
":   +-----------+-------+   :     :                           :\n"
":                           :     `- - - - - - - - - - - - - -'\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/ownership/moved-strings-rust.md:30
msgid "After move to `s2`:"
msgstr "Despu√©s de mover a `s2`:"

#: src/ownership/moved-strings-rust.md:32
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"(inaccessible)\"    :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :  |  :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :  |  :                           :\n"
":   +-----------+-------+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     4 |   :\n"
":   | capacity  |     4 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" _Stack_                          _Heap_\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"(inaccessible)\"    :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :  |  :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :  |  :                           :\n"
":   +-----------+-------+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     4 |   :\n"
":   | capacity  |     4 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/ownership/double-free-modern-cpp.md:1
#, fuzzy
msgid "Defensive Copies in Modern C++"
msgstr "Double free en c√≥digo C++ moderno"

#: src/ownership/double-free-modern-cpp.md:3
msgid "Modern C++ solves this differently:"
msgstr "La versi√≥n moderna de C++ soluciona este problema de forma diferente:"

#: src/ownership/double-free-modern-cpp.md:5
msgid ""
"```c++\n"
"std::string s1 = \"Cpp\";\n"
"std::string s2 = s1;  // Duplicate the data in s1.\n"
"```"
msgstr ""
"```c++\n"
"std::string s1 = \"Cpp\";\n"
"std::string s2 = s1;  // Duplicar datos en s1.\n"
"```"

#: src/ownership/double-free-modern-cpp.md:10
msgid ""
"The heap data from `s1` is duplicated and `s2` gets its own independent copy."
msgstr ""
"Los datos de la _stack_ de `s1` se duplican y `s2` obtiene su propia copia "
"independiente."

#: src/ownership/double-free-modern-cpp.md:11
msgid "When `s1` and `s2` go out of scope, they each free their own memory."
msgstr ""
"Cuando `s1` y `s2` salen del √°mbito, cada uno libera su propia memoria."

#: src/ownership/double-free-modern-cpp.md:13
msgid "Before copy-assignment:"
msgstr "Antes de la asignaci√≥n de copias:"

#: src/ownership/double-free-modern-cpp.md:16
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" _Stack_                          _Heap_\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/ownership/double-free-modern-cpp.md:30
msgid "After copy-assignment:"
msgstr "Despu√©s de la asignaci√≥n de copia:"

#: src/ownership/double-free-modern-cpp.md:32
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     :                       :\n"
":    s2                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+-----+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" _Stack_                          _Heap_\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     :                       :\n"
":    s2                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+-----+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/ownership/double-free-modern-cpp.md:57
msgid ""
"C++ has made a slightly different choice than Rust. Because `=` copies data, "
"the string data has to be cloned. Otherwise we would get a double-free when "
"either string goes out of scope."
msgstr ""

#: src/ownership/double-free-modern-cpp.md:61
msgid ""
"C++ also has [`std::move`](https://en.cppreference.com/w/cpp/utility/move), "
"which is used to indicate when a value may be moved from. If the example had "
"been `s2 = std::move(s1)`, no heap allocation would take place. After the "
"move, `s1` would be in a valid but unspecified state. Unlike Rust, the "
"programmer is allowed to keep using `s1`."
msgstr ""

#: src/ownership/double-free-modern-cpp.md:66
msgid ""
"Unlike Rust, `=` in C++ can run arbitrary code as determined by the type "
"which is being copied or moved."
msgstr ""

#: src/ownership/moves-function-calls.md:3
msgid ""
"When you pass a value to a function, the value is assigned to the function "
"parameter. This transfers ownership:"
msgstr ""
"Cuando pasas un valor a una funci√≥n, el valor se asigna al par√°metro de la "
"funci√≥n. Esta acci√≥n transfiere el _ownership_:"

#: src/ownership/moves-function-calls.md:6
msgid ""
"```rust,editable\n"
"fn say_hello(name: String) {\n"
"    println!(\"Hello {name}\")\n"
"}\n"
"\n"
"fn main() {\n"
"    let name = String::from(\"Alice\");\n"
"    say_hello(name);\n"
"    // say_hello(name);\n"
"}\n"
"```"
msgstr ""

#: src/ownership/moves-function-calls.md:20
msgid ""
"With the first call to `say_hello`, `main` gives up ownership of `name`. "
"Afterwards, `name` cannot be used anymore within `main`."
msgstr ""
"Con la primera llamada a `say_hello`, `main` deja de tener el _ownership_ de "
"`name`. Despu√©s, ya no se podr√° usar `name` dentro de `main`."

#: src/ownership/moves-function-calls.md:21
msgid ""
"The heap memory allocated for `name` will be freed at the end of the "
"`say_hello` function."
msgstr ""
"La memoria de _heap_ asignada a `name` se liberar√° al final de la funci√≥n "
"`say_hello`."

#: src/ownership/moves-function-calls.md:22
msgid ""
"`main` can retain ownership if it passes `name` as a reference (`&name`) and "
"if `say_hello` accepts a reference as a parameter."
msgstr ""
"main` podr√° conservar el _ownership_ si pasa`name` como referencia (`&name`) "
"y si `say_hello` acepta una referencia como par√°metro."

#: src/ownership/moves-function-calls.md:23
msgid ""
"Alternatively, `main` can pass a clone of `name` in the first call (`name."
"clone()`)."
msgstr ""
"Por otro lado, `main` puede pasar un clon de `name` en la primera llamada "
"(`name.clone()`)."

#: src/ownership/moves-function-calls.md:24
msgid ""
"Rust makes it harder than C++ to inadvertently create copies by making move "
"semantics the default, and by forcing programmers to make clones explicit."
msgstr ""
"Rust hace que resulte m√°s dif√≠cil que en C++ crear copias por error al "
"definir la sem√°ntica de movimiento como predeterminada y al obligar a los "
"programadores a clonar s√≥lo de forma expl√≠cita."

#: src/ownership/copy-clone.md:3
msgid ""
"While move semantics are the default, certain types are copied by default:"
msgstr ""
"Aunque la sem√°ntica de movimiento es la opci√≥n predeterminada, algunos tipos "
"se copian de forma predeterminada:"

#: src/ownership/copy-clone.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x = 42;\n"
"    let y = x;\n"
"    println!(\"x: {x}\");\n"
"    println!(\"y: {y}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/copy-clone.md:14
msgid "These types implement the `Copy` trait."
msgstr "Estos tipos implementan el trait `Copy`."

#: src/ownership/copy-clone.md:16
msgid "You can opt-in your own types to use copy semantics:"
msgstr ""
"Puedes habilitar tus propios tipos para que usen la sem√°ntica de copia:"

#: src/ownership/copy-clone.md:18
msgid ""
"```rust,editable\n"
"#[derive(Copy, Clone, Debug)]\n"
"struct Point(i32, i32);\n"
"\n"
"fn main() {\n"
"    let p1 = Point(3, 4);\n"
"    let p2 = p1;\n"
"    println!(\"p1: {p1:?}\");\n"
"    println!(\"p2: {p2:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/copy-clone.md:30
msgid "After the assignment, both `p1` and `p2` own their own data."
msgstr ""
"Despu√©s de la asignaci√≥n, tanto `p1` como `p2` tienen sus propios datos."

#: src/ownership/copy-clone.md:31
msgid "We can also use `p1.clone()` to explicitly copy the data."
msgstr ""
"Tambi√©n podemos utilizar `p1.clone()` para copiar los datos de forma "
"expl√≠cita."

#: src/ownership/copy-clone.md:35
msgid "Copying and cloning are not the same thing:"
msgstr "Copiar y clonar no es lo mismo:"

#: src/ownership/copy-clone.md:37
msgid ""
"Copying refers to bitwise copies of memory regions and does not work on "
"arbitrary objects."
msgstr ""
"Copiar hace referencia a las copias bit a bit de regiones de memoria y no "
"funciona en cualquier objeto."

#: src/ownership/copy-clone.md:38
msgid ""
"Copying does not allow for custom logic (unlike copy constructors in C++)."
msgstr ""
"Copiar no permite l√≥gica personalizada (a diferencia de los constructores de "
"copias de C++)."

#: src/ownership/copy-clone.md:39
msgid ""
"Cloning is a more general operation and also allows for custom behavior by "
"implementing the `Clone` trait."
msgstr ""
"Clonar es una operaci√≥n m√°s general y que permite un comportamiento "
"personalizado implementando el trait `Clone`."

#: src/ownership/copy-clone.md:40
msgid "Copying does not work on types that implement the `Drop` trait."
msgstr "Copiar no funciona en los tipos que implementan el trait `Drop`."

#: src/ownership/copy-clone.md:42 src/ownership/lifetimes-function-calls.md:29
msgid "In the above example, try the following:"
msgstr "En el ejemplo anterior, prueba lo siguiente:"

#: src/ownership/copy-clone.md:44
msgid ""
"Add a `String` field to `struct Point`. It will not compile because `String` "
"is not a `Copy` type."
msgstr ""
"A√±ade un campo `String` a `struct Point`. No se compilar√° porque `String` no "
"es de tipo `Copy`."

#: src/ownership/copy-clone.md:45
msgid ""
"Remove `Copy` from the `derive` attribute. The compiler error is now in the "
"`println!` for  `p1`."
msgstr ""
"Elimina `Copy` del atributo `derive`. El error del compilador se encuentra "
"ahora en `println!` para `p1`."

#: src/ownership/copy-clone.md:46
msgid "Show that it works if you clone `p1` instead."
msgstr "Demuestra que funciona si clonas `p1`."

#: src/ownership/copy-clone.md:48
msgid ""
"If students ask about `derive`, it is sufficient to say that this is a way "
"to generate code in Rust at compile time. In this case the default "
"implementations of `Copy` and `Clone` traits are generated."
msgstr ""
"Si los alumnos preguntan por `derive`, basta con decir que se trata de una "
"forma de generar c√≥digo en Rust durante el tiempo de compilaci√≥n. En este "
"caso, se generan las implementaciones predeterminadas de los traits `Copy` y "
"`Clone`."

#: src/ownership/borrowing.md:3
msgid ""
"Instead of transferring ownership when calling a function, you can let a "
"function _borrow_ the value:"
msgstr ""
"En lugar de transferir el _ownership_ al llamar a una funci√≥n, puedes "
"permitir que una funci√≥n _tome prestado_ el valor:"

#: src/ownership/borrowing.md:6
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point(i32, i32);\n"
"\n"
"fn add(p1: &Point, p2: &Point) -> Point {\n"
"    Point(p1.0 + p2.0, p1.1 + p2.1)\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Point(3, 4);\n"
"    let p2 = Point(10, 20);\n"
"    let p3 = add(&p1, &p2);\n"
"    println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/borrowing.md:22
msgid "The `add` function _borrows_ two points and returns a new point."
msgstr "La funci√≥n `add` _toma prestados_ dos puntos y devuelve uno nuevo."

#: src/ownership/borrowing.md:23
msgid "The caller retains ownership of the inputs."
msgstr "El llamador conserva el _ownership_ de las entradas."

#: src/ownership/borrowing.md:27
msgid "Notes on stack returns:"
msgstr "Notas sobre la devoluci√≥n de resultados de la _stack_:"

#: src/ownership/borrowing.md:28
msgid ""
"Demonstrate that the return from `add` is cheap because the compiler can "
"eliminate the copy operation. Change the above code to print stack addresses "
"and run it on the [Playground](https://play.rust-lang.org/) or look at the "
"assembly in [Godbolt](https://rust.godbolt.org/). In the \"DEBUG\" "
"optimization level, the addresses should change, while they stay the same "
"when changing to the \"RELEASE\" setting:"
msgstr ""
"Demuestra que la instrucci√≥n de retorno de `add` es f√°cil porque el "
"compilador puede eliminar la operaci√≥n de copia. Cambia el c√≥digo anterior "
"para imprimir las direcciones de la _stack_ y ejecutarlas en el [Playground]"
"(https://play.rust-lang.org/) o consulta el ensamblador en [Godbolt](https://"
"rust.godbolt.org/). En el nivel de optimizaci√≥n \"DEBUG\", las direcciones "
"deber√≠an cambiar. Sin embargo, deber√≠an mantenerse igual modificar la "
"configuraci√≥n \"RELEASE\":"

#: src/ownership/borrowing.md:30
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point(i32, i32);\n"
"\n"
"fn add(p1: &Point, p2: &Point) -> Point {\n"
"    let p = Point(p1.0 + p2.0, p1.1 + p2.1);\n"
"    println!(\"&p.0: {:p}\", &p.0);\n"
"    p\n"
"}\n"
"\n"
"pub fn main() {\n"
"    let p1 = Point(3, 4);\n"
"    let p2 = Point(10, 20);\n"
"    let p3 = add(&p1, &p2);\n"
"    println!(\"&p3.0: {:p}\", &p3.0);\n"
"    println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/borrowing.md:48
msgid "The Rust compiler can do return value optimization (RVO)."
msgstr ""
"El compilador de Rust puede hacer la optimizaci√≥n del valor devuelto (RVO)."

#: src/ownership/borrowing.md:49
msgid ""
"In C++, copy elision has to be defined in the language specification because "
"constructors can have side effects. In Rust, this is not an issue at all. If "
"RVO did not happen, Rust will always perform a simple and efficient `memcpy` "
"copy."
msgstr ""
"En C++, la elisi√≥n de copia tiene que definirse en la especificaci√≥n del "
"lenguaje, ya que los constructores pueden tener efectos secundarios. En "
"Rust, esto no supone ning√∫n problema. Si no hay RVO, Rust siempre realizar√° "
"una copia `memcpy` simple y eficiente."

#: src/ownership/shared-unique-borrows.md:3
msgid "Rust puts constraints on the ways you can borrow values:"
msgstr "Rust limita las formas en que se pueden tomar prestados valores:"

#: src/ownership/shared-unique-borrows.md:5
msgid "You can have one or more `&T` values at any given time, _or_"
msgstr "Puedes tener uno o varios valores `&T` en un momento dado, _o_"

#: src/ownership/shared-unique-borrows.md:6
msgid "You can have exactly one `&mut T` value."
msgstr "puedes tener exactamente un valor `&mut T`."

#: src/ownership/shared-unique-borrows.md:8
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let mut a: i32 = 10;\n"
"    let b: &i32 = &a;\n"
"\n"
"    {\n"
"        let c: &mut i32 = &mut a;\n"
"        *c = 20;\n"
"    }\n"
"\n"
"    println!(\"a: {a}\");\n"
"    println!(\"b: {b}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/shared-unique-borrows.md:25
msgid ""
"The above code does not compile because `a` is borrowed as mutable (through "
"`c`) and as immutable (through `b`) at the same time."
msgstr ""
"El c√≥digo anterior no se compila porque `a` se toma prestada como mutable (a "
"trav√©s de `c`) y como inmutable (a trav√©s de `b`) al mismo tiempo."

#: src/ownership/shared-unique-borrows.md:26
msgid ""
"Move the `println!` statement for `b` before the scope that introduces `c` "
"to make the code compile."
msgstr ""
"Mueve la instrucci√≥n `println!` de `b` antes del √°mbito que introduce `c` "
"para que el c√≥digo compile."

#: src/ownership/shared-unique-borrows.md:27
msgid ""
"After that change, the compiler realizes that `b` is only ever used before "
"the new mutable borrow of `a` through `c`. This is a feature of the borrow "
"checker called \"non-lexical lifetimes\"."
msgstr ""
"Despu√©s de ese cambio, el compilador se da cuenta de que `b` solo se usa "
"antes del nuevo pr√©stamo mutable de `a` a trav√©s de `c`. Se trata de una "
"funci√≥n del verificador de pr√©stamos denominada \"tiempo de vida no l√©xico\"."

#: src/ownership/lifetimes.md:3
msgid "A borrowed value has a _lifetime_:"
msgstr "Un valor que se toma prestado tiene un _tiempo de vida_:"

#: src/ownership/lifetimes.md:5
msgid "The lifetime can be implicit: `add(p1: &Point, p2: &Point) -> Point`."
msgstr ""
"El tiempo de vida puede ser impl√≠cito: `add(p1: &Point, p2: &Point) -> "
"Point`."

#: src/ownership/lifetimes.md:6
msgid "Lifetimes can also be explicit: `&'a Point`, `&'document str`."
msgstr ""
"Tiempo de vida tambi√©n puede ser expl√≠cito: `&'a Point`, `&'document str`."

#: src/ownership/lifetimes.md:7 src/ownership/lifetimes-function-calls.md:23
msgid ""
"Read `&'a Point` as \"a borrowed `Point` which is valid for at least the "
"lifetime `a`\"."
msgstr ""
"Lee `&'a Point` como \"un `Point` prestado que es v√°lido al menos durante el "
"tiempo de vida de `a`\"."

#: src/ownership/lifetimes.md:9
msgid ""
"Lifetimes are always inferred by the compiler: you cannot assign a lifetime "
"yourself."
msgstr ""
"El compilador siempre infiere el tiempo de vida: no puedes asignarlos t√∫."

#: src/ownership/lifetimes.md:11
msgid ""
"Lifetime annotations create constraints; the compiler verifies that there is "
"a valid solution."
msgstr ""
"Las anotaciones durante el tiempo de vida crean restricciones. El compilador "
"verifica que hay una soluci√≥n v√°lida."

#: src/ownership/lifetimes.md:13
msgid ""
"Lifetimes for function arguments and return values must be fully specified, "
"but Rust allows lifetimes to be elided in most cases with [a few simple "
"rules](https://doc.rust-lang.org/nomicon/lifetime-elision.html)."
msgstr ""
"El tiempo de vida de los argumentos de las funciones y los valores devueltos "
"deben especificarse por completo, pero Rust permite que se puedan eludir en "
"la mayor√≠a de los casos con [unas sencillas reglas](https://doc.rust-lang."
"org/nomicon/lifetime-elision.html)."

#: src/ownership/lifetimes-function-calls.md:3
msgid ""
"In addition to borrowing its arguments, a function can return a borrowed "
"value:"
msgstr ""
"Adem√°s de tomar prestados sus argumentos, una funci√≥n puede devolver un "
"valor que se ha tomado prestado:"

#: src/ownership/lifetimes-function-calls.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point(i32, i32);\n"
"\n"
"fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
"    if p1.0 < p2.0 { p1 } else { p2 }\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1: Point = Point(10, 10);\n"
"    let p2: Point = Point(20, 20);\n"
"    let p3: &Point = left_most(&p1, &p2);\n"
"    println!(\"left-most point: {:?}\", p3);\n"
"}\n"
"```"
msgstr ""

#: src/ownership/lifetimes-function-calls.md:21
msgid "`'a` is a generic parameter, it is inferred by the compiler."
msgstr "`'a` es un par√°metro gen√©rico que infiere el compilador."

#: src/ownership/lifetimes-function-calls.md:22
msgid "Lifetimes start with `'` and `'a` is a typical default name."
msgstr ""
"Los tiempos de vida comienzan por `'` y `'a` suele ser un nombre "
"predeterminado habitual."

#: src/ownership/lifetimes-function-calls.md:25
msgid ""
"The _at least_ part is important when parameters are in different scopes."
msgstr ""
"La parte _al menos_ es importante cuando los par√°metros est√°n en √°mbitos "
"distintos."

#: src/ownership/lifetimes-function-calls.md:31
msgid ""
"Move the declaration of `p2` and `p3` into a new scope (`{ ... }`), "
"resulting in the following code:"
msgstr ""
"Mueve la declaraci√≥n de `p2` y `p3` a un nuevo √°mbito (`{ ... }`), lo que "
"dar√° como resultado el siguiente c√≥digo:"

#: src/ownership/lifetimes-function-calls.md:32
msgid ""
"```rust,ignore\n"
"#[derive(Debug)]\n"
"struct Point(i32, i32);\n"
"\n"
"fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
"    if p1.0 < p2.0 { p1 } else { p2 }\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1: Point = Point(10, 10);\n"
"    let p3: &Point;\n"
"    {\n"
"        let p2: Point = Point(20, 20);\n"
"        p3 = left_most(&p1, &p2);\n"
"    }\n"
"    println!(\"left-most point: {:?}\", p3);\n"
"}\n"
"```"
msgstr ""

#: src/ownership/lifetimes-function-calls.md:50
msgid "Note how this does not compile since `p3` outlives `p2`."
msgstr ""
"Ten en cuenta que no se puede compilar, ya que `p3` dura m√°s tiempo que `p2`."

#: src/ownership/lifetimes-function-calls.md:52
msgid ""
"Reset the workspace and change the function signature to `fn left_most<'a, "
"'b>(p1: &'a Point, p2: &'a Point) -> &'b Point`. This will not compile "
"because the relationship between the lifetimes `'a` and `'b` is unclear."
msgstr ""
"Restablece el espacio de trabajo y cambia la firma de la funci√≥n a `fn "
"left_most<'a, 'b>(p1: &'a Point, p2: &'a Point) -> &'b Point`. No se "
"compilar√° porque la relaci√≥n entre los tiempos de vida de `'a` y `'b` no "
"est√° clara."

#: src/ownership/lifetimes-function-calls.md:53
msgid "Another way to explain it:"
msgstr "Otra forma de explicarlo:"

#: src/ownership/lifetimes-function-calls.md:54
msgid ""
"Two references to two values are borrowed by a function and the function "
"returns another reference."
msgstr ""
"Una funci√≥n toma prestadas dos referencias a dos valores y devuelve otra "
"referencia."

#: src/ownership/lifetimes-function-calls.md:56
msgid ""
"It must have come from one of those two inputs (or from a global variable)."
msgstr ""
"Esta debe proceder de una de esas dos entradas (o de una variable global)."

#: src/ownership/lifetimes-function-calls.md:57
msgid ""
"Which one is it? The compiler needs to know, so at the call site the "
"returned reference is not used for longer than a variable from where the "
"reference came from."
msgstr ""
"¬øCu√°l de ellas es? El compilador debe saberlo para que, en el sitio de la "
"llamada, la referencia devuelta no se use durante m√°s tiempo que una "
"variable de la que procede la referencia."

#: src/ownership/lifetimes-data-structures.md:3
msgid ""
"If a data type stores borrowed data, it must be annotated with a lifetime:"
msgstr ""
"Si un tipo de datos almacena datos prestados, se debe anotar con tiempo de "
"vida:"

#: src/ownership/lifetimes-data-structures.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Highlight<'doc>(&'doc str);\n"
"\n"
"fn erase(text: String) {\n"
"    println!(\"Bye {text}!\");\n"
"}\n"
"\n"
"fn main() {\n"
"    let text = String::from(\"The quick brown fox jumps over the lazy dog."
"\");\n"
"    let fox = Highlight(&text[4..19]);\n"
"    let dog = Highlight(&text[35..43]);\n"
"    // erase(text);\n"
"    println!(\"{fox:?}\");\n"
"    println!(\"{dog:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/lifetimes-data-structures.md:25
msgid ""
"In the above example, the annotation on `Highlight` enforces that the data "
"underlying the contained `&str` lives at least as long as any instance of "
"`Highlight` that uses that data."
msgstr ""
"En el ejemplo anterior, la anotaci√≥n en `Highlight` hace que los datos "
"subyacentes a la `&str` contenida tengan al menos la misma duraci√≥n que "
"cualquier instancia de `Highlight` que utilice esos datos."

#: src/ownership/lifetimes-data-structures.md:26
msgid ""
"If `text` is consumed before the end of the lifetime of `fox` (or `dog`), "
"the borrow checker throws an error."
msgstr ""
"Si `text` se consume antes de que acabe el tiempo de vida de `fox` (o "
"`dog`), el _borrow checker_ (verificador de pr√©stamos) muestra un error."

#: src/ownership/lifetimes-data-structures.md:27
msgid ""
"Types with borrowed data force users to hold on to the original data. This "
"can be useful for creating lightweight views, but it generally makes them "
"somewhat harder to use."
msgstr ""
"Los tipos con datos prestados (_borrowed_) obligan a los usuarios a "
"conservar los datos originales. Esto puede ser √∫til para crear vistas "
"ligeras aunque, por lo general, hace que sean un poco m√°s dif√≠ciles de usar."

#: src/ownership/lifetimes-data-structures.md:28
msgid "When possible, make data structures own their data directly."
msgstr ""
"Siempre que sea posible, haz que las estructuras de datos sean propietarias "
"directas de sus datos."

#: src/ownership/lifetimes-data-structures.md:29
msgid ""
"Some structs with multiple references inside can have more than one lifetime "
"annotation. This can be necessary if there is a need to describe lifetime "
"relationships between the references themselves, in addition to the lifetime "
"of the struct itself. Those are very advanced use cases."
msgstr ""
"Algunas estructuras con varias referencias dentro pueden tener m√°s de una "
"anotaci√≥n de tiempo de vida. Esto puede ser necesario si hay que describir "
"las relaciones de tiempo de vida entre las propias referencias, adem√°s del "
"tiempo de vida de la propia estructura. Estos son casos pr√°cticos muy "
"avanzados."

#: src/structs.md:3
msgid "Like C and C++, Rust has support for custom structs:"
msgstr "Al igual que C y C++, Rust admite estructuras (struct) personalizadas:"

#: src/structs.md:5
msgid ""
"```rust,editable\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        age: 27,\n"
"    };\n"
"    println!(\"{} is {} years old\", peter.name, peter.age);\n"
"    \n"
"    peter.age = 28;\n"
"    println!(\"{} is {} years old\", peter.name, peter.age);\n"
"    \n"
"    let jackie = Person {\n"
"        name: String::from(\"Jackie\"),\n"
"        ..peter\n"
"    };\n"
"    println!(\"{} is {} years old\", jackie.name, jackie.age);\n"
"}\n"
"```"
msgstr ""

#: src/structs.md:33
msgid "Structs work like in C or C++."
msgstr "Las estructuras funcionan como en C o en C++."

#: src/structs.md:34
msgid "Like in C++, and unlike in C, no typedef is needed to define a type."
msgstr ""
"Al igual que en C++, y a diferencia de C, no se necesita typedef para "
"definir un tipo."

#: src/structs.md:35
msgid "Unlike in C++, there is no inheritance between structs."
msgstr "A diferencia de C++, no existe ninguna herencia entre las estructuras."

#: src/structs.md:36
msgid ""
"Methods are defined in an `impl` block, which we will see in following "
"slides."
msgstr ""
"Los m√©todos est√°n definidos en un bloque `impl` que veremos en las "
"siguientes diapositivas."

#: src/structs.md:37
msgid ""
"This may be a good time to let people know there are different types of "
"structs. "
msgstr ""
"Puede que sea un buen momento para indicar a los alumnos que existen "
"diferentes tipos de estructuras. "

#: src/structs.md:38
msgid ""
"Zero-sized structs `e.g., struct Foo;` might be used when implementing a "
"trait on some type but don‚Äôt have any data that you want to store in the "
"value itself. "
msgstr ""
"Las estructuras de tama√±o cero, como `struct Foo;`, se pueden utilizar al "
"implementar un trait en alg√∫n tipo, pero no tienen ning√∫n dato que te "
"interese almacenar en el propio valor. "

#: src/structs.md:39
msgid ""
"The next slide will introduce Tuple structs, used when the field names are "
"not important."
msgstr ""
"La siguiente diapositiva presentar√° las estructuras de tuplas, que se "
"utilizan cuando los nombres de los campos no son importantes."

#: src/structs.md:40
msgid ""
"The syntax `..peter` allows us to copy the majority of the fields from the "
"old struct without having to explicitly type it all out. It must always be "
"the last element."
msgstr ""
"La sintaxis `..peter` nos permite copiar la mayor√≠a de los campos de la "
"estructura anterior sin tener que escribirlos expl√≠citamente. Siempre debe "
"ser el √∫ltimo elemento."

#: src/structs/tuple-structs.md:3
msgid "If the field names are unimportant, you can use a tuple struct:"
msgstr ""
"Si los nombres de los campos no son importantes, puedes utilizar una "
"estructura de tuplas:"

#: src/structs/tuple-structs.md:5
msgid ""
"```rust,editable\n"
"struct Point(i32, i32);\n"
"\n"
"fn main() {\n"
"    let p = Point(17, 23);\n"
"    println!(\"({}, {})\", p.0, p.1);\n"
"}\n"
"```"
msgstr ""

#: src/structs/tuple-structs.md:14
msgid "This is often used for single-field wrappers (called newtypes):"
msgstr ""
"Esto se suele utilizar para envoltorios de campo √∫nico (denominados "
"newtypes):"

#: src/structs/tuple-structs.md:16
msgid ""
"```rust,editable,compile_fail\n"
"struct PoundsOfForce(f64);\n"
"struct Newtons(f64);\n"
"\n"
"fn compute_thruster_force() -> PoundsOfForce {\n"
"    todo!(\"Ask a rocket scientist at NASA\")\n"
"}\n"
"\n"
"fn set_thruster_force(force: Newtons) {\n"
"    // ...\n"
"}\n"
"\n"
"fn main() {\n"
"    let force = compute_thruster_force();\n"
"    set_thruster_force(force);\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/structs/tuple-structs.md:37
msgid ""
"Newtypes are a great way to encode additional information about the value in "
"a primitive type, for example:"
msgstr ""
"Los newtypes son una buena forma de codificar informaci√≥n adicional sobre el "
"valor de un tipo primitivo, por ejemplo:"

#: src/structs/tuple-structs.md:38
msgid "The number is measured in some units: `Newtons` in the example above."
msgstr ""
"El n√∫mero se mide en algunas unidades: `Newtons` en el ejemplo anterior."

#: src/structs/tuple-structs.md:39
msgid ""
"The value passed some validation when it was created, so you no longer have "
"to validate it again at every use: 'PhoneNumber(String)`or`OddNumber(u32)\\`."
msgstr ""
"El valor ha pasado alguna validaci√≥n cuando se ha creado, por lo que ya no "
"tendr√°s que volver a validarlo cada vez que lo uses: `PhoneNumber(String)` u "
"`OddNumber(u32)`."

#: src/structs/tuple-structs.md:40
msgid ""
"Demonstrate how to add a `f64` value to a `Newtons` type by accessing the "
"single field in the newtype."
msgstr ""
"Demuestra c√≥mo se a√±ade un valor `f64` a un tipo `Newtons` accediendo al "
"campo √∫nico del newtype."

#: src/structs/tuple-structs.md:41
msgid ""
"Rust generally doesn‚Äôt like inexplicit things, like automatic unwrapping or "
"for instance using booleans as integers."
msgstr ""
"Por lo general, a Rust no le gustan los elementos no expl√≠citos, como el "
"desenvolvimiento autom√°tico o, por ejemplo, el uso de booleanos como enteros."

#: src/structs/tuple-structs.md:42
msgid "Operator overloading is discussed on Day 3 (generics)."
msgstr "El d√≠a 3 (gen√©ricos), se explicar√° la sobrecarga del operador."

#: src/structs/tuple-structs.md:43
msgid ""
"The example is a subtle reference to the [Mars Climate Orbiter](https://en."
"wikipedia.org/wiki/Mars_Climate_Orbiter) failure."
msgstr ""
"El ejemplo es una sutil referencia al fracaso de la sonda [Mars Climate "
"Orbiter](https://es.wikipedia.org/wiki/Mars_Climate_Orbiter)."

#: src/structs/field-shorthand.md:3
msgid ""
"If you already have variables with the right names, then you can create the "
"struct using a shorthand:"
msgstr ""
"Si ya dispones de variables con los nombres adecuados, puedes crear la "
"estructura con un m√©todo abreviado:"

#: src/structs/field-shorthand.md:6
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"\n"
"impl Person {\n"
"    fn new(name: String, age: u8) -> Person {\n"
"        Person { name, age }\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let peter = Person::new(String::from(\"Peter\"), 27);\n"
"    println!(\"{peter:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/structs/field-shorthand.md:27
msgid ""
"The `new` function could be written using `Self` as a type, as it is "
"interchangeable with the struct type name"
msgstr ""
"La funci√≥n `new` se podr√≠a escribir utilizando `Self` como tipo, ya que es "
"intercambiable con el nombre de tipo de estructura."

#: src/structs/field-shorthand.md:29
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"impl Person {\n"
"    fn new(name: String, age: u8) -> Self {\n"
"        Self { name, age }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/structs/field-shorthand.md:41
msgid ""
"Implement the `Default` trait for the struct. Define some fields and use the "
"default values for the other fields."
msgstr ""
"Implementa el trait `Default` en la estructura. Define algunos campos y usa "
"los valores predeterminados para el resto de los campos."

#: src/structs/field-shorthand.md:43
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"impl Default for Person {\n"
"    fn default() -> Person {\n"
"        Person {\n"
"            name: \"Bot\".to_string(),\n"
"            age: 0,\n"
"        }\n"
"    }\n"
"}\n"
"fn create_default() {\n"
"    let tmp = Person {\n"
"        ..Person::default()\n"
"    };\n"
"    let tmp = Person {\n"
"        name: \"Sam\".to_string(),\n"
"        ..Person::default()\n"
"    };\n"
"}\n"
"```"
msgstr ""

#: src/structs/field-shorthand.md:68
msgid "Methods are defined in the `impl` block."
msgstr "Los m√©todos se definen en el bloque `impl`."

#: src/structs/field-shorthand.md:69
msgid ""
"Use struct update syntax to define a new structure using `peter`. Note that "
"the variable `peter` will no longer be accessible afterwards."
msgstr ""
"Utiliza la sintaxis de actualizaci√≥n de estructuras para definir una "
"estructura nueva con `peter`. Ten en cuenta que, despu√©s, ya no podr√°s "
"acceder a la variable `peter`."

#: src/structs/field-shorthand.md:70
msgid ""
"Use `{:#?}` when printing structs to request the `Debug` representation."
msgstr ""
"Utiliza `{:#?}` al imprimir estructuras para solicitar la representaci√≥n de "
"`Debug`."

#: src/methods.md:3
msgid ""
"Rust allows you to associate functions with your new types. You do this with "
"an `impl` block:"
msgstr ""
"Rust te permite asociar funciones a los nuevos tipos. Para ello, usa un "
"bloque `impl`:"

#: src/methods.md:6
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"\n"
"impl Person {\n"
"    fn say_hello(&self) {\n"
"        println!(\"Hello, my name is {}\", self.name);\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        age: 27,\n"
"    };\n"
"    peter.say_hello();\n"
"}\n"
"```"
msgstr ""

#: src/methods.md:31
msgid "It can be helpful to introduce methods by comparing them to functions."
msgstr "Puede resultar √∫til presentar los m√©todos compar√°ndolos con funciones."

#: src/methods.md:32
msgid ""
"Methods are called on an instance of a type (such as a struct or enum), the "
"first parameter represents the instance as `self`."
msgstr ""
"Se llama a los m√©todos en una instancia de un tipo (como un estructura o una "
"enumeraci√≥n) y el primer par√°metro representa la instancia como `self`."

#: src/methods.md:33
msgid ""
"Developers may choose to use methods to take advantage of method receiver "
"syntax and to help keep them more organized. By using methods we can keep "
"all the implementation code in one predictable place."
msgstr ""
"Los desarrolladores pueden optar por utilizar m√©todos para aprovechar la "
"sintaxis de los receptores de m√©todos y para ayudar a mantenerlos m√°s "
"organizados. Mediante el uso de m√©todos podemos mantener todo el c√≥digo de "
"implementaci√≥n en un lugar predecible."

#: src/methods.md:34
msgid "Point out the use of the keyword `self`, a method receiver."
msgstr "Se√±ala el uso de la palabra clave `self`, receptor de un m√©todo. "

#: src/methods.md:35
msgid ""
"Show that it is an abbreviated term for `self: Self` and perhaps show how "
"the struct name could also be used."
msgstr ""
"Indica que se trata de un t√©rmino abreviado de `self:&Self` y muestra c√≥mo "
"se podr√≠a utilizar tambi√©n el nombre de la estructura. "

#: src/methods.md:36
msgid ""
"Explain that `Self` is a type alias for the type the `impl` block is in and "
"can be used elsewhere in the block."
msgstr ""
"Explica que `Self` es un tipo de alias para el tipo en el que est√° el bloque "
"`impl` y que se puede usar en cualquier parte del bloque."

#: src/methods.md:37
msgid ""
"Note how `self` is used like other structs and dot notation can be used to "
"refer to individual fields."
msgstr ""
"Ten en cuenta que se puede usar `self` como otras estructuras y que la "
"notaci√≥n de puntos puede utilizarse para referirse a campos concretos."

#: src/methods.md:38
msgid ""
"This might be a good time to demonstrate how the `&self` differs from `self` "
"by modifying the code and trying to run say_hello twice."
msgstr ""
"Puede ser un buen momento para mostrar la diferencia entre `&self` y `self` "
"modificando el c√≥digo e intentando ejecutar say_hello dos veces."

#: src/methods.md:39
msgid "We describe the distinction between method receivers next."
msgstr "A continuaci√≥n, se describe la diferencia entre receptores de m√©todos."

#: src/methods/receiver.md:3
msgid ""
"The `&self` above indicates that the method borrows the object immutably. "
"There are other possible receivers for a method:"
msgstr ""
"`&self` indica que el m√©todo toma prestado el objeto de forma inmutable. Hay "
"otros posibles receptores para un m√©todo:"

#: src/methods/receiver.md:6
msgid ""
"`&self`: borrows the object from the caller using a shared and immutable "
"reference. The object can be used again afterwards."
msgstr ""
"`&self`: toma prestado el objeto del llamador utilizando una referencia "
"compartida e inmutable. El objeto se puede volver a utilizar despu√©s."

#: src/methods/receiver.md:8
msgid ""
"`&mut self`: borrows the object from the caller using a unique and mutable "
"reference. The object can be used again afterwards."
msgstr ""
"`&mut self`: toma prestado el objeto del llamador mediante una referencia "
"√∫nica y mutable. El objeto se puede volver a utilizar despu√©s."

#: src/methods/receiver.md:10
msgid ""
"`self`: takes ownership of the object and moves it away from the caller. The "
"method becomes the owner of the object. The object will be dropped "
"(deallocated) when the method returns, unless its ownership is explicitly "
"transmitted. Complete ownership does not automatically mean mutability."
msgstr ""
"`self`: asume el _ownership_ del objeto y lo aleja del llamador. El m√©todo "
"se convierte en el propietario del objeto. El objeto se eliminar√° (es decir, "
"se anular√° la asignaci√≥n) cuando el m√©todo devuelva un resultado, a menos "
"que se transmita su _ownership_ de forma expl√≠cita. El _ownership_ completa "
"no implica autom√°ticamente una mutabilidad."

#: src/methods/receiver.md:14
msgid "`mut self`: same as above, but the method can mutate the object. "
msgstr ""
"`mut self`: igual que lo anterior, pero el m√©todo puede mutar el objeto. "

#: src/methods/receiver.md:15
msgid ""
"No receiver: this becomes a static method on the struct. Typically used to "
"create constructors which are called `new` by convention."
msgstr ""
"Sin receptor: se convierte en un m√©todo est√°tico de la estructura. "
"Normalmente se utiliza para crear constructores que se suelen denominar "
"`new`."

#: src/methods/receiver.md:18
msgid ""
"Beyond variants on `self`, there are also [special wrapper types](https://"
"doc.rust-lang.org/reference/special-types-and-traits.html) allowed to be "
"receiver types, such as `Box<Self>`."
msgstr ""
"Adem√°s de las variantes `self`, tambi√©n hay [tipos de envoltorios especiales]"
"(https://doc.rust-lang.org/reference/special-types-and-traits.html) que "
"pueden ser tipos de receptor, como `Box<Self>`."

#: src/methods/receiver.md:24
msgid ""
"Consider emphasizing \"shared and immutable\" and \"unique and mutable\". "
"These constraints always come together in Rust due to borrow checker rules, "
"and `self` is no exception. It isn't possible to reference a struct from "
"multiple locations and call a mutating (`&mut self`) method on it."
msgstr ""
"Considera recalcar los conceptos \"compartido e inmutable\" y \"√∫nico y "
"mutable\". Estas restricciones siempre vienen juntas en Rust debido a las "
"reglas del _borrow checker_, y `self` no es una excepci√≥n. No es posible "
"referenciar una estructura desde varias ubicaciones y llamar a un m√©todo "
"mutable (`&mut self`) en ella."

#: src/methods/example.md:3
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Race {\n"
"    name: String,\n"
"    laps: Vec<i32>,\n"
"}\n"
"\n"
"impl Race {\n"
"    fn new(name: &str) -> Race {  // No receiver, a static method\n"
"        Race { name: String::from(name), laps: Vec::new() }\n"
"    }\n"
"\n"
"    fn add_lap(&mut self, lap: i32) {  // Exclusive borrowed read-write "
"access to self\n"
"        self.laps.push(lap);\n"
"    }\n"
"\n"
"    fn print_laps(&self) {  // Shared and read-only borrowed access to self\n"
"        println!(\"Recorded {} laps for {}:\", self.laps.len(), self.name);\n"
"        for (idx, lap) in self.laps.iter().enumerate() {\n"
"            println!(\"Lap {idx}: {lap} sec\");\n"
"        }\n"
"    }\n"
"\n"
"    fn finish(self) {  // Exclusive ownership of self\n"
"        let total = self.laps.iter().sum::<i32>();\n"
"        println!(\"Race {} is finished, total lap time: {}\", self.name, "
"total);\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut race = Race::new(\"Monaco Grand Prix\");\n"
"    race.add_lap(70);\n"
"    race.add_lap(68);\n"
"    race.print_laps();\n"
"    race.add_lap(71);\n"
"    race.print_laps();\n"
"    race.finish();\n"
"    // race.add_lap(42);\n"
"}\n"
"```"
msgstr ""

#: src/methods/example.md:47
msgid "All four methods here use a different method receiver."
msgstr ""
"Cada uno de estos cuatro m√©todos utilizan un receptor de m√©todo distinto."

#: src/methods/example.md:48
msgid ""
"You can point out how that changes what the function can do with the "
"variable values and if/how it can be used again in `main`."
msgstr ""
"Puedes indicar c√≥mo eso cambia lo que la funci√≥n puede hacer con los valores "
"de las variables y si se puede utilizar de nuevo en `main` y, en caso "
"afirmativo, c√≥mo."

#: src/methods/example.md:49
msgid ""
"You can showcase the error that appears when trying to call `finish` twice."
msgstr ""
"Puedes mostrar el error que aparece al intentar llamar a `finish` dos veces."

#: src/methods/example.md:50
msgid ""
"Note that although the method receivers are different, the non-static "
"functions are called the same way in the main body. Rust enables automatic "
"referencing and dereferencing when calling methods. Rust automatically adds "
"in the `&`, `*`, `muts` so that that object matches the method signature."
msgstr ""
"Ten en cuenta que, aunque los receptores de los m√©todos sean diferentes, las "
"funciones no est√°ticas se llaman del mismo modo en el cuerpo principal. Rust "
"habilita la referenciaci√≥n y desreferenciaci√≥n autom√°ticas al llamar a los "
"m√©todos. Adem√°s, a√±ade autom√°ticamente los caracteres `&`, `*` y `muts` para "
"que el objeto coincida con la firma del m√©todo."

#: src/methods/example.md:51
msgid ""
"You might point out that `print_laps` is using a vector that is iterated "
"over. We describe vectors in more detail in the afternoon. "
msgstr ""
"Podr√≠as mencionar que `print_laps` est√° usando un vector sobre el que se "
"itera. Describiremos los vectores con m√°s detalle por la tarde. "

#: src/exercises/day-2/morning.md:1
msgid "Day 2: Morning Exercises"
msgstr "D√≠a 2: Ejercicios de la Ma√±ana"

#: src/exercises/day-2/morning.md:3
msgid "We will look at implementing methods in two contexts:"
msgstr "Veremos la implementaci√≥n de m√©todos en dos contextos:"

#: src/exercises/day-2/morning.md:5
msgid "Storing books and querying the collection"
msgstr "Almacenar libros y consultar la colecci√≥n"

#: src/exercises/day-2/morning.md:7
msgid "Keeping track of health statistics for patients"
msgstr "Hacer seguimiento de las estad√≠sticas de salud de pacientes"

#: src/exercises/day-2/book-library.md:3
msgid ""
"We will learn much more about structs and the `Vec<T>` type tomorrow. For "
"now, you just need to know part of its API:"
msgstr ""
"Ma√±ana conoceremos mucho mejor _structs_ y el tipo `Vec<T>`. Por ahora, solo "
"debes conocer parte de su API:"

#: src/exercises/day-2/book-library.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut vec = vec![10, 20];\n"
"    vec.push(30);\n"
"    let midpoint = vec.len() / 2;\n"
"    println!(\"middle value: {}\", vec[midpoint]);\n"
"    for item in &vec {\n"
"        println!(\"item: {item}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/book-library.md:18
msgid ""
"Use this to model a library's book collection. Copy the code below to "
"<https://play.rust-lang.org/> and update the types to make it compile:"
msgstr ""
"Crea un modelo de la colecci√≥n de libros de una biblioteca con esta opci√≥n. "
"Copia el c√≥digo que aparece abajo en <https://play.rust-lang.org/> y "
"actualiza los tipos para que compile:"

#: src/exercises/day-2/book-library.md:21
msgid ""
"```rust,should_panic\n"
"struct Library {\n"
"    books: Vec<Book>,\n"
"}\n"
"\n"
"struct Book {\n"
"    title: String,\n"
"    year: u16,\n"
"}\n"
"\n"
"impl Book {\n"
"    // This is a constructor, used below.\n"
"    fn new(title: &str, year: u16) -> Book {\n"
"        Book {\n"
"            title: String::from(title),\n"
"            year,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Implement the methods below. Update the `self` parameter to\n"
"// indicate the method's required level of ownership over the object:\n"
"//\n"
"// - `&self` for shared read-only access,\n"
"// - `&mut self` for unique and mutable access,\n"
"// - `self` for unique access by value.\n"
"impl Library {\n"
"    fn new() -> Library {\n"
"        todo!(\"Initialize and return a `Library` value\")\n"
"    }\n"
"\n"
"    //fn len(self) -> usize {\n"
"    //    todo!(\"Return the length of `self.books`\")\n"
"    //}\n"
"\n"
"    //fn is_empty(self) -> bool {\n"
"    //    todo!(\"Return `true` if `self.books` is empty\")\n"
"    //}\n"
"\n"
"    //fn add_book(self, book: Book) {\n"
"    //    todo!(\"Add a new book to `self.books`\")\n"
"    //}\n"
"\n"
"    //fn print_books(self) {\n"
"    //    todo!(\"Iterate over `self.books` and each book's title and "
"year\")\n"
"    //}\n"
"\n"
"    //fn oldest_book(self) -> Option<&Book> {\n"
"    //    todo!(\"Return a reference to the oldest book (if any)\")\n"
"    //}\n"
"}\n"
"\n"
"// This shows the desired behavior. Uncomment the code below and\n"
"// implement the missing methods. You will need to update the\n"
"// method signatures, including the \"self\" parameter! You may\n"
"// also need to update the variable bindings within main.\n"
"fn main() {\n"
"    let library = Library::new();\n"
"\n"
"    //println!(\"The library is empty: library.is_empty() -> {}\", library."
"is_empty());\n"
"    //\n"
"    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    //\n"
"    //println!(\"The library is no longer empty: library.is_empty() -> {}\", "
"library.is_empty());\n"
"    //\n"
"    //\n"
"    //library.print_books();\n"
"    //\n"
"    //match library.oldest_book() {\n"
"    //    Some(book) => println!(\"The oldest book is {}\", book.title),\n"
"    //    None => println!(\"The library is empty!\"),\n"
"    //}\n"
"    //\n"
"    //println!(\"The library has {} books\", library.len());\n"
"    //library.print_books();\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/book-library.md:102
msgid "[Solution](solutions-afternoon.md#designing-a-library)"
msgstr "[Soluciones](solutions-afternoon.md#designing-a-library)"

#: src/exercises/day-2/health-statistics.md:3
msgid ""
"You're working on implementing a health-monitoring system. As part of that, "
"you need to keep track of users' health statistics."
msgstr ""
"Est√°s trabajando en la implementaci√≥n de un sistema de monitorizaci√≥n de "
"salud. Por ello, debes realizar un seguimiento de las estad√≠sticas de salud "
"de los usuarios."

#: src/exercises/day-2/health-statistics.md:6
msgid ""
"You'll start with some stubbed functions in an `impl` block as well as a "
"`User` struct definition. Your goal is to implement the stubbed out methods "
"on the `User` `struct` defined in the `impl` block."
msgstr ""
"Comenzar√°s con algunas funciones stub en un bloque `impl`, as√≠ como con una "
"definici√≥n de estructura `User`. Tu objetivo es implementar m√©todos con "
"stubs en la  `struct` `User` definida en el bloque `impl`."

#: src/exercises/day-2/health-statistics.md:10
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing "
"methods:"
msgstr ""
"Copia el fragmento de c√≥digo que aparece m√°s abajo en la p√°gina <https://"
"play.rust-lang.org/> y rellena los m√©todos que faltan:"

#: src/exercises/day-2/health-statistics.md:13
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub struct User {\n"
"    name: String,\n"
"    age: u32,\n"
"    height: f32,\n"
"    visit_count: usize,\n"
"    last_blood_pressure: Option<(u32, u32)>,\n"
"}\n"
"\n"
"pub struct Measurements {\n"
"    height: f32,\n"
"    blood_pressure: (u32, u32),\n"
"}\n"
"\n"
"pub struct HealthReport<'a> {\n"
"    patient_name: &'a str,\n"
"    visit_count: u32,\n"
"    height_change: f32,\n"
"    blood_pressure_change: Option<(i32, i32)>,\n"
"}\n"
"\n"
"impl User {\n"
"    pub fn new(name: String, age: u32, height: f32) -> Self {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn name(&self) -> &str {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn age(&self) -> u32 {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn height(&self) -> f32 {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn doctor_visits(&self) -> u32 {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn set_age(&mut self, new_age: u32) {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn set_height(&mut self, new_height: f32) {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn visit_doctor(&mut self, measurements: Measurements) -> "
"HealthReport {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    println!(\"I'm {} and my age is {}\", bob.name(), bob.age());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_height() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.height(), 155.2);\n"
"}\n"
"\n"
"#[test]\n"
"fn test_set_age() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.age(), 32);\n"
"    bob.set_age(33);\n"
"    assert_eq!(bob.age(), 33);\n"
"}\n"
"\n"
"#[test]\n"
"fn test_visit() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.doctor_visits(), 0);\n"
"    let report = bob.visit_doctor(Measurements {\n"
"        height: 156.1,\n"
"        blood_pressure: (120, 80),\n"
"    });\n"
"    assert_eq!(report.patient_name, \"Bob\");\n"
"    assert_eq!(report.visit_count, 1);\n"
"    assert_eq!(report.blood_pressure_change, None);\n"
"\n"
"    let report = bob.visit_doctor(Measurements {\n"
"        height: 156.1,\n"
"        blood_pressure: (115, 76),\n"
"    });\n"
"\n"
"    assert_eq!(report.visit_count, 2);\n"
"    assert_eq!(report.blood_pressure_change, Some((-5, -4)));\n"
"}\n"
"```"
msgstr ""

#: src/std.md:3
msgid ""
"Rust comes with a standard library which helps establish a set of common "
"types used by Rust library and programs. This way, two libraries can work "
"together smoothly because they both use the same `String` type."
msgstr ""
"Rust viene con una biblioteca est√°ndar que ayuda a establecer un conjunto de "
"tipos comunes que se usan en la biblioteca y los programas de Rust. De esta "
"forma, dos bibliotecas pueden funcionar juntas sin problemas, puesto que "
"ambas utilizan el mismo tipo `String`."

#: src/std.md:7
msgid "The common vocabulary types include:"
msgstr ""
"Entre los tipos de vocabulario m√°s habituales se incluyen los siguientes:"

#: src/std.md:9
msgid ""
"[`Option` and `Result`](std/option-result.md) types: used for optional "
"values and [error handling](error-handling.md)."
msgstr ""
"Tipos [`Option` y `Result`](std/option-result.md): se utilizan para valores "
"opcionales y [gesti√≥n de errores](error-handling.md)."

#: src/std.md:12
msgid "[`String`](std/string.md): the default string type used for owned data."
msgstr ""
"[`String`](std/string.md): el tipo de cadena predeterminado que se usa para "
"los datos propios."

#: src/std.md:14
msgid "[`Vec`](std/vec.md): a standard extensible vector."
msgstr "[`Vec`](std/vec.md): un vector est√°ndar extensible."

#: src/std.md:16
msgid ""
"[`HashMap`](std/hashmap.md): a hash map type with a configurable hashing "
"algorithm."
msgstr ""
"[`HashMap`](std/hashmap.md): un mapa hash con un algoritmo hash configurable."

#: src/std.md:19
msgid "[`Box`](std/box.md): an owned pointer for heap-allocated data."
msgstr ""
"[`Box`](std/box.md): un puntero propio para datos ubicados en el _heap_."

#: src/std.md:21
msgid ""
"[`Rc`](std/rc.md): a shared reference-counted pointer for heap-allocated "
"data."
msgstr ""
"[`Rc`](std/rc.md): un puntero compartido de conteo de referencias para datos "
"asignados a _heap_."

#: src/std.md:25
msgid ""
"In fact, Rust contains several layers of the Standard Library: `core`, "
"`alloc` and `std`. "
msgstr ""
"De hecho, Rust contiene varias capas de la biblioteca est√°ndar: `core`, "
"`alloc` y `std`. "

#: src/std.md:26
msgid ""
"`core` includes the most basic types and functions that don't depend on "
"`libc`, allocator or even the presence of an operating system. "
msgstr ""
"`core` incluye los tipos y funciones m√°s b√°sicos que no dependen de `libc`, "
"de un _allocator_ (asignador de memoria) ni de la presencia de un sistema "
"operativo. "

#: src/std.md:28
msgid ""
"`alloc` includes types which require a global heap allocator, such as `Vec`, "
"`Box` and `Arc`."
msgstr ""
"`alloc` incluye tipos que requieren un _allocator_ de _heap_ global, como "
"`Vec`, `Box` y `Arc`."

#: src/std.md:29
msgid ""
"Embedded Rust applications often only use `core`, and sometimes `alloc`."
msgstr ""
"Las aplicaciones embebidas en Rust menudo solo usan `core` y a algunas veces "
"`alloc`."

#: src/std/option-result.md:1
msgid "`Option` and `Result`"
msgstr "`Option` y `Result`"

#: src/std/option-result.md:3
msgid "The types represent optional data:"
msgstr "Los tipos representan datos opcionales:"

#: src/std/option-result.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let numbers = vec![10, 20, 30];\n"
"    let first: Option<&i8> = numbers.first();\n"
"    println!(\"first: {first:?}\");\n"
"\n"
"    let idx: Result<usize, usize> = numbers.binary_search(&10);\n"
"    println!(\"idx: {idx:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/option-result.md:18
msgid "`Option` and `Result` are widely used not just in the standard library."
msgstr "`Option` y `Result` se usan mucho, no solo en la biblioteca est√°ndar."

#: src/std/option-result.md:19
msgid "`Option<&T>` has zero space overhead compared to `&T`."
msgstr "`Option<&T>` no usa espacio adicional en comparaci√≥n con `&T`."

#: src/std/option-result.md:20
msgid ""
"`Result` is the standard type to implement error handling as we will see on "
"Day 3."
msgstr ""
"`Result` es el tipo est√°ndar para implementar la gesti√≥n de errores, tal y "
"como veremos el d√≠a 3."

#: src/std/option-result.md:21
msgid "`binary_search` returns `Result<usize, usize>`."
msgstr "`binary_search` devuelve `Result<usize, usize>`."

#: src/std/option-result.md:22
msgid "If found, `Result::Ok` holds the index where the element is found."
msgstr ""
"Si se encuentra, `Result::Ok` contiene el √≠ndice donde se halla el elemento."

#: src/std/option-result.md:23
msgid ""
"Otherwise, `Result::Err` contains the index where such an element should be "
"inserted."
msgstr ""
"De lo contrario, `Result::Err` contendr√° el √≠ndice donde se debe insertar "
"dicho elemento."

#: src/std/string.md:3
msgid ""
"[`String`](https://doc.rust-lang.org/std/string/struct.String.html) is the "
"standard heap-allocated growable UTF-8 string buffer:"
msgstr ""
"[`String`](https://doc.rust-lang.org/std/string/struct.String.html) es el "
"b√∫fer de cadena UTF-8 est√°ndar, ampliable y asignado a un _heap_:"

#: src/std/string.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::new();\n"
"    s1.push_str(\"Hello\");\n"
"    println!(\"s1: len = {}, capacity = {}\", s1.len(), s1.capacity());\n"
"\n"
"    let mut s2 = String::with_capacity(s1.len() + 1);\n"
"    s2.push_str(&s1);\n"
"    s2.push('!');\n"
"    println!(\"s2: len = {}, capacity = {}\", s2.len(), s2.capacity());\n"
"\n"
"    let s3 = String::from(\"üá®üá≠\");\n"
"    println!(\"s3: len = {}, number of chars = {}\", s3.len(),\n"
"             s3.chars().count());\n"
"}\n"
"```"
msgstr ""

#: src/std/string.md:22
msgid ""
"`String` implements [`Deref<Target = str>`](https://doc.rust-lang.org/std/"
"string/struct.String.html#deref-methods-str), which means that you can call "
"all `str` methods on a `String`."
msgstr ""
"`String` implementa \\[`Deref<Target = str>`\\]\\[2\\], lo que significa que "
"puedes llamar a todos los m√©todos `str` en una `String`."

#: src/std/string.md:30
msgid ""
"`String::new` returns a new empty string, use `String::with_capacity` when "
"you know how much data you want to push to the string."
msgstr ""
"`String::new` devuelve una nueva cadena vac√≠a. Usa `String::with_capacity` "
"cuando sepas cu√°ntos datos quieres guardar."

#: src/std/string.md:31
msgid ""
"`String::len` returns the size of the `String` in bytes (which can be "
"different from its length in characters)."
msgstr ""
"`String::len` devuelve el tama√±o de `String` en bytes (que puede ser "
"diferente de su longitud en caracteres)."

#: src/std/string.md:32
msgid ""
"`String::chars` returns an iterator over the actual characters. Note that a "
"`char` can be different from what a human will consider a \"character\" due "
"to [grapheme clusters](https://docs.rs/unicode-segmentation/latest/"
"unicode_segmentation/struct.Graphemes.html)."
msgstr ""
"`String::chars` devuelve un iterador sobre los caracteres reales. Ten en "
"cuenta que un `char` puede ser diferente de lo que un humano considerar√≠a un "
"\"caracter\", debido a los [grupos de grafemas](https://docs.rs/unicode-"
"segmentation/latest/unicode_segmentation/struct.Graphemes.html)."

#: src/std/string.md:33
msgid ""
"When people refer to strings they could either be talking about `&str` or "
"`String`."
msgstr ""
"Cuando la gente se refiere a cadenas, pueden estar hablando de `&str` o de "
"`String`. "

#: src/std/string.md:34
msgid ""
"When a type implements `Deref<Target = T>`, the compiler will let you "
"transparently call methods from `T`."
msgstr ""
"Cuando un tipo implementa `Deref<Target = T>`, el compilador te permite "
"llamar a m√©todos de forma transparente desde `T`."

#: src/std/string.md:35
msgid ""
"`String` implements `Deref<Target = str>` which transparently gives it "
"access to `str`'s methods."
msgstr ""
"`String` implementa `Deref<Target = str>`, que le proporciona acceso "
"transparente a los m√©todos de `str`."

#: src/std/string.md:36
msgid "Write and compare `let s3 = s1.deref();` and  `let s3 = &*s1`;."
msgstr "Escribe y compara `let s3 = s1.deref();` y `let s3 = &*s1`;."

#: src/std/string.md:37
msgid ""
"`String` is implemented as a wrapper around a vector of bytes, many of the "
"operations you see supported on vectors are also supported on `String`, but "
"with some extra guarantees."
msgstr ""
"`String` se implementa como un envoltorio alrededor de un vector de bytes. "
"Muchas de las operaciones que ves como compatibles con vectores tambi√©n lo "
"son con `String`, pero con algunas garant√≠as adicionales."

#: src/std/string.md:38
msgid "Compare the different ways to index a `String`:"
msgstr "Compara las diferentes formas de indexar `String`:"

#: src/std/string.md:39
msgid ""
"To a character by using `s3.chars().nth(i).unwrap()` where `i` is in-bound, "
"out-of-bounds."
msgstr ""
"A un car√°cter mediante `s3. chars().nth(i).unwrap()`, donde `i` est√° dentro "
"o fuera de los l√≠mites"

#: src/std/string.md:40
msgid ""
"To a substring by using `s3[0..4]`, where that slice is on character "
"boundaries or not."
msgstr ""
"A una cadena secundaria mediante `s3[0..4]`, donde el slice est√° en los "
"l√≠mites de caracteres o no."

#: src/std/vec.md:1
msgid "`Vec`"
msgstr "`Vec`"

#: src/std/vec.md:3
msgid ""
"[`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html) is the standard "
"resizable heap-allocated buffer:"
msgstr ""
"[`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html) es el b√∫fer "
"est√°ndar redimensionable asignado al _heap_:"

#: src/std/vec.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v1 = Vec::new();\n"
"    v1.push(42);\n"
"    println!(\"v1: len = {}, capacity = {}\", v1.len(), v1.capacity());\n"
"\n"
"    let mut v2 = Vec::with_capacity(v1.len() + 1);\n"
"    v2.extend(v1.iter());\n"
"    v2.push(9999);\n"
"    println!(\"v2: len = {}, capacity = {}\", v2.len(), v2.capacity());\n"
"\n"
"    // Canonical macro to initialize a vector with elements.\n"
"    let mut v3 = vec![0, 0, 1, 2, 3, 4];\n"
"\n"
"    // Retain only the even elements.\n"
"    v3.retain(|x| x % 2 == 0);\n"
"    println!(\"{v3:?}\");\n"
"\n"
"    // Remove consecutive duplicates.\n"
"    v3.dedup();\n"
"    println!(\"{v3:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/vec.md:29
msgid ""
"`Vec` implements [`Deref<Target = [T]>`](https://doc.rust-lang.org/std/vec/"
"struct.Vec.html#deref-methods-%5BT%5D), which means that you can call slice "
"methods on a `Vec`."
msgstr ""
"`Vec` implementa [`Deref<Target = [T]>`](https://doc.rust-lang.org/std/vec/"
"struct.Vec.html#deref-methods-%5BT%5D), lo que significa que puedes llamar a "
"m√©todos slice en un `Vec`."

#: src/std/vec.md:37
msgid ""
"`Vec` is a type of collection, along with `String` and `HashMap`. The data "
"it contains is stored on the heap. This means the amount of data doesn't "
"need to be  known at compile time. It can grow or shrink at runtime."
msgstr ""
"`Vec` es un tipo de colecci√≥n, junto con `String` y `HashMap`. Los datos que "
"contiene se almacenan en el _heap_. Esto significa que no es necesario "
"conocer la cantidad de datos durante la compilaci√≥n. Puede aumentar o "
"disminuir durante la ejecuci√≥n."

#: src/std/vec.md:40
msgid ""
"Notice how `Vec<T>` is a generic type too, but you don't have to specify `T` "
"explicitly. As always with Rust type inference, the `T` was established "
"during the first `push` call."
msgstr ""
"Ten en cuenta que `Vec<T>` tambi√©n es un tipo gen√©rico, pero no tienes que "
"especificar `T` de forma expl√≠cita. Como siempre sucede con la inferencia de "
"tipos de Rust, `T` se estableci√≥ durante la primera llamada a `push`."

#: src/std/vec.md:42
msgid ""
"`vec![...]` is a canonical macro to use instead of `Vec::new()` and it "
"supports adding initial elements to the vector."
msgstr ""
"`vec![...]` es una macro can√≥nica para usarla en lugar de `Vec::new()` y "
"admite que se a√±adan elementos iniciales al vector."

#: src/std/vec.md:44
msgid ""
"To index the vector you use `[` `]`, but they will panic if out of bounds. "
"Alternatively, using `get` will return an `Option`. The `pop` function will "
"remove the last element."
msgstr ""
"Para indexar el vector, se utiliza `[` `]`, pero entrar√° en p√°nico si se "
"sale de los l√≠mites. Tambi√©n se puede usar `get` para obtener una `Option`. "
"La funci√≥n `pop` eliminar√° el √∫ltimo elemento."

#: src/std/vec.md:46
msgid ""
"Show iterating over a vector and mutating the value: `for e in &mut v { *e "
"+= 50; }`"
msgstr ""
"Muestra la iteraci√≥n sobre un vector y la mutaci√≥n del valor: `for e in &mut "
"v { *e += 50; }`."

#: src/std/hashmap.md:1 src/bare-metal/no_std.md:46
msgid "`HashMap`"
msgstr "`HashMap`"

#: src/std/hashmap.md:3
msgid "Standard hash map with protection against HashDoS attacks:"
msgstr "Mapa hash est√°ndar con protecci√≥n frente a ataques HashDoS:"

#: src/std/hashmap.md:5
msgid ""
"```rust,editable\n"
"use std::collections::HashMap;\n"
"\n"
"fn main() {\n"
"    let mut page_counts = HashMap::new();\n"
"    page_counts.insert(\"Adventures of Huckleberry Finn\".to_string(), "
"207);\n"
"    page_counts.insert(\"Grimms' Fairy Tales\".to_string(), 751);\n"
"    page_counts.insert(\"Pride and Prejudice\".to_string(), 303);\n"
"\n"
"    if !page_counts.contains_key(\"Les Mis√©rables\") {\n"
"        println!(\"We know about {} books, but not Les Mis√©rables.\",\n"
"                 page_counts.len());\n"
"    }\n"
"\n"
"    for book in [\"Pride and Prejudice\", \"Alice's Adventure in "
"Wonderland\"] {\n"
"        match page_counts.get(book) {\n"
"            Some(count) => println!(\"{book}: {count} pages\"),\n"
"            None => println!(\"{book} is unknown.\")\n"
"        }\n"
"    }\n"
"\n"
"    // Use the .entry() method to insert a value if nothing is found.\n"
"    for book in [\"Pride and Prejudice\", \"Alice's Adventure in "
"Wonderland\"] {\n"
"        let page_count: &mut i32 = page_counts.entry(book.to_string())."
"or_insert(0);\n"
"        *page_count += 1;\n"
"    }\n"
"\n"
"    println!(\"{page_counts:#?}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/hashmap.md:38
msgid ""
"`HashMap` is not defined in the prelude and needs to be brought into scope."
msgstr "`HashMap` no se ha explicado en el preludio y debe conocerse."

#: src/std/hashmap.md:39
msgid ""
"Try the following lines of code. The first line will see if a book is in the "
"hashmap and if not return an alternative value. The second line will insert "
"the alternative value in the hashmap if the book is not found."
msgstr ""
"Prueba las siguientes l√≠neas de c√≥digo. La primera l√≠nea comprobar√° si un "
"libro est√° incluido en el hashmap y, si no, devolver√° un valor alternativo. "
"La segunda l√≠nea insertar√° el valor alternativo en el hashmap si el libro no "
"se encuentra."

#: src/std/hashmap.md:41
msgid ""
"```rust,ignore\n"
"  let pc1 = page_counts\n"
"      .get(\"Harry Potter and the Sorcerer's Stone \")\n"
"      .unwrap_or(&336);\n"
"  let pc2 = page_counts\n"
"      .entry(\"The Hunger Games\".to_string())\n"
"      .or_insert(374);\n"
"```"
msgstr ""

#: src/std/hashmap.md:49
msgid "Unlike `vec!`, there is unfortunately no standard `hashmap!` macro."
msgstr ""
"A diferencia de `vec!`, por desgracia no hay ninguna macro est√°ndar de "
"`hashmap!`."

#: src/std/hashmap.md:50
msgid ""
"Although, since Rust 1.56, HashMap implements [`From<[(K, V); N]>`](https://"
"doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#impl-"
"From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E), which allows "
"us to easily initialize a hash map from a literal array:"
msgstr ""
"Sin embargo, desde la versi√≥n 1.56 de Rust, HashMap implementa [`From<[(K, "
"V); N]>`](https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap."
"html#impl-From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%, que "
"nos permite inicializar f√°cilmente un mapa hash a partir de un _array_ "
"literal:"

#: src/std/hashmap.md:52
msgid ""
"```rust,ignore\n"
"  let page_counts = HashMap::from([\n"
"    (\"Harry Potter and the Sorcerer's Stone\".to_string(), 336),\n"
"    (\"The Hunger Games\".to_string(), 374),\n"
"  ]);\n"
"```"
msgstr ""

#: src/std/hashmap.md:59
msgid ""
"Alternatively HashMap can be built from any `Iterator` which yields key-"
"value tuples."
msgstr ""
"HashMap tambi√©n se puede crear a partir de cualquier `Iterator` que genere "
"tuplas de pares clave-valor."

#: src/std/hashmap.md:60
msgid ""
"We are showing `HashMap<String, i32>`, and avoid using `&str` as key to make "
"examples easier. Using references in collections can, of course, be done, "
"but it can lead into complications with the borrow checker."
msgstr ""
"Mostraremos `HashMap<String, i32>` y evitaremos utilizar `&str` para que los "
"ejemplos sean m√°s sencillos. Por supuesto, se pueden usar las referencias en "
"las colecciones, pero pueden dar problemas con el _borrow checker_."

#: src/std/hashmap.md:62
msgid ""
"Try removing `to_string()` from the example above and see if it still "
"compiles. Where do you think we might run into issues?"
msgstr ""
"Prueba a eliminar `to_string()` del ejemplo anterior para ver si a√∫n sigue "
"compilando. ¬øD√≥nde crees que podr√≠amos encontrar problemas?"

#: src/std/hashmap.md:64
msgid ""
"This type has several \"method-specific\" return types, such as `std::"
"collections::hash_map::Keys`. These types often appear in searches of the "
"Rust docs. Show students the docs for this type, and the helpful link back "
"to the `keys` method."
msgstr ""
"Este tipo tiene varios tipos de devoluci√≥n \"espec√≠ficos del m√©todo\", como "
"`std::collections::hash_map::Keys`. Estos tipos a menudo aparecen en las "
"b√∫squedas de la documentaci√≥n de Rust. Muestra a los estudiantes la "
"documentaci√≥n de este tipo y el enlace √∫til de vuelta al m√©todo `keys`."

#: src/std/box.md:1
msgid "`Box`"
msgstr "`Box`"

#: src/std/box.md:3
msgid ""
"[`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) is an owned "
"pointer to data on the heap:"
msgstr ""
"[`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) es un puntero "
"propio de datos en el _heap_:"

#: src/std/box.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let five = Box::new(5);\n"
"    println!(\"five: {}\", *five);\n"
"}\n"
"```"
msgstr ""

#: src/std/box.md:13
msgid ""
"```bob\n"
" Stack                     Heap\n"
".- - - - - - -.     .- - - - - - -.\n"
":             :     :             :\n"
":    five     :     :             :\n"
":   +-----+   :     :   +-----+   :\n"
":   | o---|---+-----+-->|  5  |   :\n"
":   +-----+   :     :   +-----+   :\n"
":             :     :             :\n"
":             :     :             :\n"
"`- - - - - - -'     `- - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" _Stack_            _Heap_\n"
".- - - - - - -.     .- - - - - - -.\n"
":             :     :             :\n"
":    five     :     :             :\n"
":   +-----+   :     :   +-----+   :\n"
":   | o---|---+-----+-->|  5  |   :\n"
":   +-----+   :     :   +-----+   :\n"
":             :     :             :\n"
":             :     :             :\n"
"`- - - - - - -'     `- - - - - - -'\n"
"```"

#: src/std/box.md:26
msgid ""
"`Box<T>` implements `Deref<Target = T>`, which means that you can [call "
"methods from `T` directly on a `Box<T>`](https://doc.rust-lang.org/std/ops/"
"trait.Deref.html#more-on-deref-coercion)."
msgstr ""
"`Box<T>` implementa `Deref<Target = T>`, lo que significa que puedes [llamar "
"a m√©todos desde `T` directamente en un `Box<T>`](https://doc.rust-lang.org/"
"std/ops/trait.Deref.html#more-on-deref-coercion)."

#: src/std/box.md:34
msgid ""
"`Box` is like `std::unique_ptr` in C++, except that it's guaranteed to be "
"not null. "
msgstr ""
"`Box` es igual que `std::unique_ptr` en C++, salvo que est√° asegurado que no "
"ser√° nulo. "

#: src/std/box.md:35
msgid ""
"In the above example, you can even leave out the `*` in the `println!` "
"statement thanks to `Deref`. "
msgstr ""
"En el ejemplo anterior, incluso puedes omitir `*` en la instrucci√≥n `println!"
"` gracias a `Deref`. "

#: src/std/box.md:36
msgid "A `Box` can be useful when you:"
msgstr "Un `Box` puede resultar √∫til en los siguientes casos:"

#: src/std/box.md:37
msgid ""
"have a type whose size that can't be known at compile time, but the Rust "
"compiler wants to know an exact size."
msgstr ""
"Si tienes un tipo cuyo tama√±o no se conoce durante la compilaci√≥n, pero el "
"compilador de Rust quiere saber el tama√±o exacto."

#: src/std/box.md:38
msgid ""
"want to transfer ownership of a large amount of data. To avoid copying large "
"amounts of data on the stack, instead store the data on the heap in a `Box` "
"so only the pointer is moved."
msgstr ""
"Si quieres transferir la propiedad de una gran cantidad de datos. Para "
"evitar que se copien grandes cantidades de datos en la _stack_, almacena los "
"datos del _heap_ en un `Box` para que solo se mueva el puntero."

#: src/std/box-recursive.md:1
msgid "Box with Recursive Data Structures"
msgstr "Box con Estructuras de Datos Recursivos"

#: src/std/box-recursive.md:3
msgid ""
"Recursive data types or data types with dynamic sizes need to use a `Box`:"
msgstr ""
"Los tipos de datos recursivos o los tipos de datos con tama√±os din√°micos "
"deben utilizar un `Box`:"

#: src/std/box-recursive.md:5 src/std/box-niche.md:3
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"enum List<T> {\n"
"    Cons(T, Box<List<T>>),\n"
"    Nil,\n"
"}\n"
"\n"
"fn main() {\n"
"    let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::"
"new(List::Nil))));\n"
"    println!(\"{list:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/box-recursive.md:18
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                         :     :                                               :\n"
":    "
"list                 :     :                                               :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----"
"+   :\n"
":   | Cons | 1  | o--+----+-----+--->| Cons | 2  | o--+--->| Nil  | // | // "
"|   :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----"
"+   :\n"
":                         :     :                                               :\n"
":                         :     :                                               :\n"
"'- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"
msgstr ""
"```bob\n"
" _Stack_                       _Heap_\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                         :     :                                               :\n"
":    "
"list                 :     :                                               :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----"
"+   :\n"
":   | Cons | 1  | o--+----+-----+--->| Cons | 2  | o--+--->| Nil  | // | // "
"|   :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----"
"+   :\n"
":                         :     :                                               :\n"
":                         :     :                                               :\n"
"'- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"

#: src/std/box-recursive.md:33
msgid ""
"If `Box` was not used and we attempted to embed a `List` directly into the "
"`List`, the compiler would not compute a fixed size of the struct in memory "
"(`List` would be of infinite size)."
msgstr ""
"Si no se utiliza `Box` e intentamos insertar un `List` directamente dentro "
"de `List`, el compilador no calcular√≠a un tama√±o fijo de la estructura en la "
"memoria (`List` tendr√≠a un tama√±o infinito)."

#: src/std/box-recursive.md:36
msgid ""
"`Box` solves this problem as it has the same size as a regular pointer and "
"just points at the next element of the `List` in the heap."
msgstr ""
"`Box` resuelve este problema, ya que tiene el mismo tama√±o que un puntero "
"normal y solo apunta al siguiente elemento de la `List` en el _heap_."

#: src/std/box-recursive.md:39
msgid ""
"Remove the `Box` in the List definition and show the compiler error. "
"\"Recursive with indirection\" is a hint you might want to use a Box or "
"reference of some kind, instead of storing a value directly."
msgstr ""
"Elimina `Box` de la definici√≥n de la lista y muestra el error del "
"compilador. \"Recursivo con indirecci√≥n\" es una sugerencia de que puedes "
"usar un Box o referencia de alg√∫n tipo, en lugar de almacenar un valor "
"directamente."

#: src/std/box-niche.md:16
msgid ""
"A `Box` cannot be empty, so the pointer is always valid and non-`null`. This "
"allows the compiler to optimize the memory layout:"
msgstr ""
"`Box` no puede estar vac√≠o, por lo que el puntero siempre es v√°lido y no "
"`null`. Esto permite que el compilador optimice el dise√±o de la memoria:"

#: src/std/box-niche.md:19
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - "
"-.\n"
":                         :     :                                             :\n"
":    "
"list                 :     :                                             :\n"
":   +----+----+           :     :    +----+----+    +----+------"
"+             :\n"
":   | 1  | o--+-----------+-----+--->| 2  | o--+--->| // | null "
"|             :\n"
":   +----+----+           :     :    +----+----+    +----+------"
"+             :\n"
":                         :     :                                             :\n"
":                         :     :                                             :\n"
"`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - "
"-'\n"
"```"
msgstr ""
"```bob\n"
" _Stack_                        _Heap_\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - "
"-.\n"
":                         :     :                                             :\n"
":    "
"list                 :     :                                             :\n"
":   +----+----+           :     :    +----+----+    +----+------"
"+             :\n"
":   | 1  | o--+-----------+-----+--->| 2  | o--+--->| // | null "
"|             :\n"
":   +----+----+           :     :    +----+----+    +----+------"
"+             :\n"
":                         :     :                                             :\n"
":                         :     :                                             :\n"
"`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - "
"-'\n"
"```"

#: src/std/rc.md:1
msgid "`Rc`"
msgstr "`Rc`"

#: src/std/rc.md:3
msgid ""
"[`Rc`](https://doc.rust-lang.org/std/rc/struct.Rc.html) is a reference-"
"counted shared pointer. Use this when you need to refer to the same data "
"from multiple places:"
msgstr ""
"[`Rc`](https://doc.rust-lang.org/std/rc/struct.Rc.html) es un puntero "
"compartido de referencia contada. Util√≠zalo cuando necesites hacer "
"referencia a los mismos datos desde varios lugares:"

#: src/std/rc.md:6
msgid ""
"```rust,editable\n"
"use std::rc::Rc;\n"
"\n"
"fn main() {\n"
"    let mut a = Rc::new(10);\n"
"    let mut b = Rc::clone(&a);\n"
"\n"
"    println!(\"a: {a}\");\n"
"    println!(\"b: {b}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/rc.md:18
msgid ""
"See [`Arc`](../concurrency/shared_state/arc.md) and [`Mutex`](https://doc."
"rust-lang.org/std/sync/struct.Mutex.html) if you are in a multi-threaded "
"context."
msgstr ""
"Consulta [`Arc`](../concurrency/shared_state/arc.md) y [`Mutex`](https://doc."
"rust-lang.org/std/sync/struct.Mutex.html) si te encuentras en un contexto "
"multihilo."

#: src/std/rc.md:19
msgid ""
"You can _downgrade_ a shared pointer into a [`Weak`](https://doc.rust-lang."
"org/std/rc/struct.Weak.html) pointer to create cycles that will get dropped."
msgstr ""
"Puedes _degradar_ un puntero compartido en un puntero [`Weak`](https://doc."
"rust-lang.org/std/rc/struct.Weak.html) para crear ciclos que se abandonar√°n."

#: src/std/rc.md:29
msgid ""
"`Rc`'s count ensures that its contained value is valid for as long as there "
"are references."
msgstr ""
"El recuento de `Rc` asegura que el valor que contiene sea v√°lido mientras "
"haya referencias."

#: src/std/rc.md:30
msgid "`Rc` in Rust is like `std::shared_ptr` in C++."
msgstr "`Rc` en Rust es como `std::shared_ptr` en C++."

#: src/std/rc.md:31
msgid ""
"`Rc::clone` is cheap: it creates a pointer to the same allocation and "
"increases the reference count. Does not make a deep clone and can generally "
"be ignored when looking for performance issues in code."
msgstr ""
"`Rc::clone` es simple: crea un puntero en la misma asignaci√≥n y aumenta el "
"recuento de referencias. No hace clones completos y, por lo general, se "
"puede ignorar cuando se buscan problemas de rendimiento en el c√≥digo."

#: src/std/rc.md:32
msgid ""
"`make_mut` actually clones the inner value if necessary (\"clone-on-write\") "
"and returns a mutable reference."
msgstr ""
"`make_mut` clona el valor interno si es necesario (\"copiar al escribir\") y "
"devuelve una referencia mutable."

#: src/std/rc.md:33
msgid "Use `Rc::strong_count` to check the reference count."
msgstr "Comprueba el recuento de referencias con `Rc::strong_count`."

#: src/std/rc.md:34
msgid ""
"`Rc::downgrade` gives you a _weakly reference-counted_ object to create "
"cycles that will be dropped properly (likely in combination with `RefCell`, "
"on the next slide)."
msgstr ""
"`Rc::downgrade` ofrece un objeto _de referencia contada baja_ para crear "
"`Rc::downgrade` ofrece un objeto de _referencia contada d√©bil_ para crear "
"`RefCell`)."

#: src/std/cell.md:1
msgid "`Cell` and `RefCell`"
msgstr "`Cell` y `RefCell`"

#: src/std/cell.md:3
msgid ""
"[`Cell`](https://doc.rust-lang.org/std/cell/struct.Cell.html) and [`RefCell`]"
"(https://doc.rust-lang.org/std/cell/struct.RefCell.html) implement what Rust "
"calls _interior mutability:_ mutation of values in an immutable context."
msgstr ""
"[`Cell`](https://doc.rust-lang.org/std/cell/struct.Cell.html) y [`RefCell`]"
"(https://doc.rust-lang.org/std/cell/struct.RefCell.html) implementan lo que "
"Rust llama _mutabilidad interna_: mutaci√≥n de valores en un contexto "
"inmutable."

#: src/std/cell.md:8
msgid ""
"`Cell` is typically used for simple types, as it requires copying or moving "
"values. More complex interior types typically use `RefCell`, which tracks "
"shared and exclusive references at runtime and panics if they are misused."
msgstr ""
"Normalmente, `Cell` se utiliza para tipos simples, ya que requiere copiar o "
"mover valores. Los tipos internos m√°s complejos normalmente utilizan "
"`RefCell`, que realiza un seguimiento de las referencias compartidas y "
"exclusivas en tiempo de ejecuci√≥n y entra en p√°nico si se utilizan de forma "
"incorrecta."

#: src/std/cell.md:12
msgid ""
"```rust,editable\n"
"use std::cell::RefCell;\n"
"use std::rc::Rc;\n"
"\n"
"#[derive(Debug, Default)]\n"
"struct Node {\n"
"    value: i64,\n"
"    children: Vec<Rc<RefCell<Node>>>,\n"
"}\n"
"\n"
"impl Node {\n"
"    fn new(value: i64) -> Rc<RefCell<Node>> {\n"
"        Rc::new(RefCell::new(Node { value, ..Node::default() }))\n"
"    }\n"
"\n"
"    fn sum(&self) -> i64 {\n"
"        self.value + self.children.iter().map(|c| c.borrow().sum()).sum::"
"<i64>()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let root = Node::new(1);\n"
"    root.borrow_mut().children.push(Node::new(5));\n"
"    let subtree = Node::new(10);\n"
"    subtree.borrow_mut().children.push(Node::new(11));\n"
"    subtree.borrow_mut().children.push(Node::new(12));\n"
"    root.borrow_mut().children.push(subtree);\n"
"\n"
"    println!(\"graph: {root:#?}\");\n"
"    println!(\"graph sum: {}\", root.borrow().sum());\n"
"}\n"
"```"
msgstr ""

#: src/std/cell.md:47
msgid ""
"If we were using `Cell` instead of `RefCell` in this example, we would have "
"to move the `Node` out of the `Rc` to push children, then move it back in. "
"This is safe because there's always one, un-referenced value in the cell, "
"but it's not ergonomic."
msgstr ""
"Si estuvi√©ramos utilizando `Cell` en lugar de `RefCell` en este ejemplo, "
"tendr√≠amos que mover el `Node` fuera del `Rc` para insertar hijos y luego "
"volver a moverlo. Esto es seguro porque siempre hay un valor sin referenciar "
"en la celda, pero no es ergon√≥mico."

#: src/std/cell.md:48
msgid ""
"To do anything with a Node, you must call a `RefCell` method, usually "
"`borrow` or `borrow_mut`."
msgstr ""
"Para hacer cualquier cosa con un Node, debes llamar a un m√©todo de "
"`RefCell`, normalmente `borrow` o `borrow_mut`."

#: src/std/cell.md:49
msgid ""
"Demonstrate that reference loops can be created by adding `root` to `subtree."
"children` (don't try to print it!)."
msgstr ""
"Demuestra que se pueden crear bucles de referencia a√±adiendo `root` a "
"`subtree.children` (¬°no intentes imprimirlo!)."

#: src/std/cell.md:50
msgid ""
"To demonstrate a runtime panic, add a `fn inc(&mut self)` that increments "
"`self.value` and calls the same method on its children. This will panic in "
"the presence of the reference loop, with `thread 'main' panicked at 'already "
"borrowed: BorrowMutError'`."
msgstr ""
"Para demostrar un p√°nico en tiempo de ejecuci√≥n, a√±ade un `fn inc(&mut "
"self)` que incremente `self.value` y llame al mismo m√©todo en sus hijos. "
"Esto entrar√° en p√°nico en presencia del bucle de referencia, con `thread "
"'main' panicked at 'already borrowed: BorrowMutError'`."

#: src/modules.md:3
msgid "We have seen how `impl` blocks let us namespace functions to a type."
msgstr ""
"Hemos visto c√≥mo los bloques `impl` nos permiten asignar espacios de nombres "
"de funciones a un tipo."

#: src/modules.md:5
msgid "Similarly, `mod` lets us namespace types and functions:"
msgstr ""
"Del mismo modo, `mod` nos permite asignar espacios de nombres a funciones y "
"tipos:"

#: src/modules.md:7
msgid ""
"```rust,editable\n"
"mod foo {\n"
"    pub fn do_something() {\n"
"        println!(\"In the foo module\");\n"
"    }\n"
"}\n"
"\n"
"mod bar {\n"
"    pub fn do_something() {\n"
"        println!(\"In the bar module\");\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    foo::do_something();\n"
"    bar::do_something();\n"
"}\n"
"```"
msgstr ""

#: src/modules.md:28
msgid ""
"Packages provide functionality and include a `Cargo.toml` file that "
"describes how to build a bundle of 1+ crates."
msgstr ""
"Los paquetes ofrecen funciones e incluyen un archivo `Cargo.toml` que "
"describe c√≥mo compilar un paquete de m√°s de un crate."

#: src/modules.md:29
msgid ""
"Crates are a tree of modules, where a binary crate creates an executable and "
"a library crate compiles to a library."
msgstr ""
"Los crates son un √°rbol de m√≥dulos, donde un crate binario crea un "
"ejecutable y un crate de biblioteca compila una biblioteca."

#: src/modules.md:30
msgid "Modules define organization, scope, and are the focus of this section."
msgstr ""
"Los m√≥dulos definen la organizaci√≥n y el √°mbito, y son el centro de esta "
"secci√≥n."

#: src/modules/visibility.md:3
msgid "Modules are a privacy boundary:"
msgstr "Los m√≥dulos marcan el l√≠mite de la privacidad:"

#: src/modules/visibility.md:5
msgid "Module items are private by default (hides implementation details)."
msgstr ""
"Los elementos del m√≥dulo son privados de forma predeterminada (se ocultan "
"los detalles de implementaci√≥n)."

#: src/modules/visibility.md:6
msgid "Parent and sibling items are always visible."
msgstr "Los elementos superiores y los del mismo nivel siempre est√°n visibles."

#: src/modules/visibility.md:7
msgid ""
"In other words, if an item is visible in module `foo`, it's visible in all "
"the descendants of `foo`."
msgstr ""
"Es decir, si un elemento est√° visible en el m√≥dulo `foo`, se ver√° en todos "
"los elementos descendientes de `foo`."

#: src/modules/visibility.md:10
msgid ""
"```rust,editable\n"
"mod outer {\n"
"    fn private() {\n"
"        println!(\"outer::private\");\n"
"    }\n"
"\n"
"    pub fn public() {\n"
"        println!(\"outer::public\");\n"
"    }\n"
"\n"
"    mod inner {\n"
"        fn private() {\n"
"            println!(\"outer::inner::private\");\n"
"        }\n"
"\n"
"        pub fn public() {\n"
"            println!(\"outer::inner::public\");\n"
"            super::private();\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    outer::public();\n"
"}\n"
"```"
msgstr ""

#: src/modules/visibility.md:39
msgid "Use the `pub` keyword to make modules public."
msgstr "Haz que los m√≥dulos sean p√∫blicos con la palabra clave `pub`."

#: src/modules/visibility.md:41
msgid ""
"Additionally, there are advanced `pub(...)` specifiers to restrict the scope "
"of public visibility."
msgstr ""
"Adem√°s, hay especificadores `pub(...)` avanzados para restringir el √°mbito "
"de la visibilidad p√∫blica."

#: src/modules/visibility.md:43
msgid ""
"See the [Rust Reference](https://doc.rust-lang.org/reference/visibility-and-"
"privacy.html#pubin-path-pubcrate-pubsuper-and-pubself)."
msgstr ""
"Consulta el libro [Rust Reference](https://doc.rust-lang.org/reference/"
"visibility-and-privacy.html#pubin-path-pubcrate-pubsuper-and-pubself)."

#: src/modules/visibility.md:44
msgid "Configuring `pub(crate)` visibility is a common pattern."
msgstr "Configurar la visibilidad de `pub(crate)` es un patr√≥n com√∫n."

#: src/modules/visibility.md:45
msgid "Less commonly, you can give visibility to a specific path."
msgstr ""
"Aunque es menos frecuente, se puede dar visibilidad a una ruta espec√≠fica."

#: src/modules/visibility.md:46
msgid ""
"In any case, visibility must be granted to an ancestor module (and all of "
"its descendants)."
msgstr ""
"En cualquier caso, se debe dar visibilidad a un m√≥dulo antecedente (y a "
"todos sus descendientes)."

#: src/modules/paths.md:3
msgid "Paths are resolved as follows:"
msgstr "Las rutas se resuelven de la siguiente manera:"

#: src/modules/paths.md:5
msgid "As a relative path:"
msgstr "Como ruta relativa:"

#: src/modules/paths.md:6
msgid "`foo` or `self::foo` refers to `foo` in the current module,"
msgstr "`foo` o `self::foo` hacen referencia a `foo` en el m√≥dulo."

#: src/modules/paths.md:7
msgid "`super::foo` refers to `foo` in the parent module."
msgstr "`super::foo` hace referencia a `foo` en el m√≥dulo superior."

#: src/modules/paths.md:9
msgid "As an absolute path:"
msgstr "Como ruta absoluta:"

#: src/modules/paths.md:10
msgid "`crate::foo` refers to `foo` in the root of the current crate,"
msgstr "`crate::foo` hace referencia a `foo` en la ra√≠z del crate."

#: src/modules/paths.md:11
msgid "`bar::foo` refers to `foo` in the `bar` crate."
msgstr "`bar::foo` hace referencia a `foo` en el crate `bar`."

#: src/modules/paths.md:13
msgid ""
"A module can bring symbols from another module into scope with `use`. You "
"will typically see something like this at the top of each module:"
msgstr ""
"Un m√≥dulo puede incluir s√≠mbolos de otro m√≥dulo en el √°mbito con `use`. "
"Normalmente, se ve algo como esto en la parte superior de cada m√≥dulo:"

#: src/modules/paths.md:16
msgid ""
"```rust,editable\n"
"use std::collections::HashSet;\n"
"use std::mem::transmute;\n"
"```"
msgstr ""

#: src/modules/filesystem.md:3
msgid ""
"Omitting the module content will tell Rust to look for it in another file:"
msgstr ""
"Omitir el contenido del m√≥dulo har√° que Rust lo busque en otro archivo:"

#: src/modules/filesystem.md:5
msgid ""
"```rust,editable,compile_fail\n"
"mod garden;\n"
"```"
msgstr ""

#: src/modules/filesystem.md:9
msgid ""
"This tells rust that the `garden` module content is found at `src/garden."
"rs`. Similarly, a `garden::vegetables` module can be found at `src/garden/"
"vegetables.rs`."
msgstr ""
"Esto indica que el contenido del m√≥dulo `garden` se encuentra en `src/garden."
"rs`. Del mismo modo, el m√≥dulo `garden::vegetables` se encuentra en `src/"
"garden/vegetables.rs`."

#: src/modules/filesystem.md:12
msgid "The `crate` root is in:"
msgstr "La ra√≠z de `crate` est√° en:"

#: src/modules/filesystem.md:14
msgid "`src/lib.rs` (for a library crate)"
msgstr "`src/lib.rs` (para un crate de biblioteca)"

#: src/modules/filesystem.md:15
msgid "`src/main.rs` (for a binary crate)"
msgstr "`src/main.rs` (para un crate binario)"

#: src/modules/filesystem.md:17
msgid ""
"Modules defined in files can be documented, too, using \"inner doc "
"comments\". These document the item that contains them -- in this case, a "
"module."
msgstr ""
"Los m√≥dulos definidos en archivos tambi√©n se pueden documentar mediante "
"\"comentarios internos del documento\". En ellos se indica el elemento que "
"los contiene, en este caso, un m√≥dulo."

#: src/modules/filesystem.md:20
msgid ""
"```rust,editable,compile_fail\n"
"//! This module implements the garden, including a highly performant "
"germination\n"
"//! implementation.\n"
"\n"
"// Re-export types from this module.\n"
"pub use seeds::SeedPacket;\n"
"pub use garden::Garden;\n"
"\n"
"/// Sow the given seed packets.\n"
"pub fn sow(seeds: Vec<SeedPacket>) { todo!() }\n"
"\n"
"/// Harvest the produce in the garden that is ready.\n"
"pub fn harvest(garden: &mut Garden) { todo!() }\n"
"```"
msgstr ""

#: src/modules/filesystem.md:37
msgid ""
"Before Rust 2018, modules needed to be located at `module/mod.rs` instead of "
"`module.rs`, and this is still a working alternative for editions after 2018."
msgstr ""
"Antes de Rust 2018, los m√≥dulos deb√≠an ubicarse en `module/mod.rs` en lugar "
"de en `module.rs`. Esta alternativa sigue existiendo en las ediciones "
"posteriores a 2018."

#: src/modules/filesystem.md:39
msgid ""
"The main reason to introduce `filename.rs` as alternative to `filename/mod."
"rs` was because many files named `mod.rs` can be hard to distinguish in IDEs."
msgstr ""
"El principal motivo de introducir `filename.rs` en lugar de `filename/mod."
"rs` se debe a que si muchos archivos llamados `mod.rs` puede ser dif√≠cil "
"distinguirlos en IDEs."

#: src/modules/filesystem.md:42
msgid "Deeper nesting can use folders, even if the main module is a file:"
msgstr ""
"Un anidamiento m√°s profundo puede usar carpetas, incluso si el m√≥dulo "
"principal es un archivo:"

#: src/modules/filesystem.md:44
msgid ""
"```ignore\n"
"src/\n"
"‚îú‚îÄ‚îÄ main.rs\n"
"‚îú‚îÄ‚îÄ top_module.rs\n"
"‚îî‚îÄ‚îÄ top_module/\n"
"    ‚îî‚îÄ‚îÄ sub_module.rs\n"
"```"
msgstr ""

#: src/modules/filesystem.md:52
msgid ""
"The place rust will look for modules can be changed with a compiler "
"directive:"
msgstr ""
"El lugar donde Rust buscar√° los m√≥dulos se puede cambiar con una directiva "
"del compilador:"

#: src/modules/filesystem.md:54
msgid ""
"```rust,ignore\n"
"#[path = \"some/path.rs\"]\n"
"mod some_module;\n"
"```"
msgstr ""

#: src/modules/filesystem.md:59
msgid ""
"This is useful, for example, if you would like to place tests for a module "
"in a file named `some_module_test.rs`, similar to the convention in Go."
msgstr ""
"Esto resulta √∫til, por ejemplo, si deseas colocar pruebas de un m√≥dulo en un "
"archivo denominado `some_module_test.rs`, similar a la convenci√≥n en Go."

#: src/exercises/day-2/afternoon.md:1
msgid "Day 2: Afternoon Exercises"
msgstr "D√≠a 2: Ejercicios de la Tarde"

#: src/exercises/day-2/afternoon.md:3
msgid "The exercises for this afternoon will focus on strings and iterators."
msgstr ""
"Los ejercicios de esta tarde se centrar√°n en las cadenas y los iteradores."

#: src/exercises/day-2/iterators-and-ownership.md:3
msgid ""
"The ownership model of Rust affects many APIs. An example of this is the "
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) and "
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html) "
"traits."
msgstr ""
"El modelo de _ownership_ de Rust afecta a muchas APIs. Un ejemplo ser√≠an los "
"traits [`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) "
"y [`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator."
"html)."

#: src/exercises/day-2/iterators-and-ownership.md:8 src/bare-metal/no_std.md:28
msgid "`Iterator`"
msgstr "`Iterator`"

#: src/exercises/day-2/iterators-and-ownership.md:10
msgid ""
"Traits are like interfaces: they describe behavior (methods) for a type. The "
"`Iterator` trait simply says that you can call `next` until you get `None` "
"back:"
msgstr ""
"Los _traits_ son como las interfaces: describen el comportamiento (m√©todos) "
"de un tipo. El trait `Iterator` indica que se puede llamar a `next` hasta "
"que se obtenga `None`:"

#: src/exercises/day-2/iterators-and-ownership.md:13
msgid ""
"```rust\n"
"pub trait Iterator {\n"
"    type Item;\n"
"    fn next(&mut self) -> Option<Self::Item>;\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/iterators-and-ownership.md:20
msgid "You use this trait like this:"
msgstr "Utiliza este trait de la siguiente forma:"

#: src/exercises/day-2/iterators-and-ownership.md:22
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();\n"
"\n"
"    println!(\"v[0]: {:?}\", iter.next());\n"
"    println!(\"v[1]: {:?}\", iter.next());\n"
"    println!(\"v[2]: {:?}\", iter.next());\n"
"    println!(\"No more items: {:?}\", iter.next());\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/iterators-and-ownership.md:34
msgid "What is the type returned by the iterator? Test your answer here:"
msgstr "¬øQu√© tipo devuelve el iterador? Prueba tu respuesta aqu√≠:"

#: src/exercises/day-2/iterators-and-ownership.md:36
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();\n"
"\n"
"    let v0: Option<..> = iter.next();\n"
"    println!(\"v0: {v0:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/iterators-and-ownership.md:46
msgid "Why is this type used?"
msgstr "¬øPor qu√© se usa este tipo?"

#: src/exercises/day-2/iterators-and-ownership.md:48
msgid "`IntoIterator`"
msgstr "`IntoIterator`"

#: src/exercises/day-2/iterators-and-ownership.md:50
msgid ""
"The `Iterator` trait tells you how to _iterate_ once you have created an "
"iterator. The related trait `IntoIterator` tells you how to create the "
"iterator:"
msgstr ""
"El trait `Iterator` te indica c√≥mo _iterar_ una vez que has creado un "
"iterador. El trait relacionado `IntoIterator` indica c√≥mo crear el iterador:"

#: src/exercises/day-2/iterators-and-ownership.md:53
msgid ""
"```rust\n"
"pub trait IntoIterator {\n"
"    type Item;\n"
"    type IntoIter: Iterator<Item = Self::Item>;\n"
"\n"
"    fn into_iter(self) -> Self::IntoIter;\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/iterators-and-ownership.md:62
msgid ""
"The syntax here means that every implementation of `IntoIterator` must "
"declare two types:"
msgstr ""
"La sintaxis aqu√≠ significa que cada implementaci√≥n de `IntoIterator` debe "
"declarar dos tipos:"

#: src/exercises/day-2/iterators-and-ownership.md:65
msgid "`Item`: the type we iterate over, such as `i8`,"
msgstr "`Item`: el tipo sobre el que iteramos, como `i8`,"

#: src/exercises/day-2/iterators-and-ownership.md:66
msgid "`IntoIter`: the `Iterator` type returned by the `into_iter` method."
msgstr "`IntoIter`: el tipo `Iterator` devuelto por el m√©todo `into_iter`."

#: src/exercises/day-2/iterators-and-ownership.md:68
msgid ""
"Note that `IntoIter` and `Item` are linked: the iterator must have the same "
"`Item` type, which means that it returns `Option<Item>`"
msgstr ""
"Ten en cuenta que `IntoIter` y `Item` est√°n vinculados: el iterador debe "
"tener el mismo  tipo de `Item`, lo que significa que devuelve `Option<Item>`."

#: src/exercises/day-2/iterators-and-ownership.md:71
msgid "Like before, what  is the type returned by the iterator?"
msgstr "Al igual que antes, ¬øqu√© tipo devuelve el iterador?"

#: src/exercises/day-2/iterators-and-ownership.md:73
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::"
"from(\"bar\")];\n"
"    let mut iter = v.into_iter();\n"
"\n"
"    let v0: Option<..> = iter.next();\n"
"    println!(\"v0: {v0:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/iterators-and-ownership.md:83
msgid "`for` Loops"
msgstr "Bucles `for`"

#: src/exercises/day-2/iterators-and-ownership.md:85
msgid ""
"Now that we know both `Iterator` and `IntoIterator`, we can build `for` "
"loops. They call `into_iter()` on an expression and iterates over the "
"resulting iterator:"
msgstr ""
"Ahora que conocemos `Iterator` e `IntoIterator`, podemos crear bucles `for`. "
"Llaman a `into_iter()` sobre una expresi√≥n e iteran sobre el iterador "
"resultante:"

#: src/exercises/day-2/iterators-and-ownership.md:89
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::"
"from(\"bar\")];\n"
"\n"
"    for word in &v {\n"
"        println!(\"word: {word}\");\n"
"    }\n"
"\n"
"    for word in v {\n"
"        println!(\"word: {word}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/iterators-and-ownership.md:103
msgid "What is the type of `word` in each loop?"
msgstr "¬øCu√°l es el tipo de `word` en cada bucle?"

#: src/exercises/day-2/iterators-and-ownership.md:105
msgid ""
"Experiment with the code above and then consult the documentation for [`impl "
"IntoIterator for &Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec."
"html#impl-IntoIterator-for-%26'a+Vec%3CT,+A%3E) and [`impl IntoIterator for "
"Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-"
"for-Vec%3CT,+A%3E) to check your answers."
msgstr ""
"Experimenta con el c√≥digo anterior y consulta la documentaci√≥n sobre [`impl "
"IntoIterator for &Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec."
"html#impl-IntoIterator-for-%26'a+Vec%3CT,+A%3E) y sobre [`impl IntoIterator "
"for Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-"
"IntoIterator-for-Vec%3CT,+A%3E) para comprobar las respuestas."

#: src/exercises/day-2/strings-iterators.md:3
msgid ""
"In this exercise, you are implementing a routing component of a web server. "
"The server is configured with a number of _path prefixes_ which are matched "
"against _request paths_. The path prefixes can contain a wildcard character "
"which matches a full segment. See the unit tests below."
msgstr ""
"En este ejercicio se va a implementar un componente de enrutamiento de un "
"servidor web. El servidor est√° configurado con un n√∫mero de _prefijos de "
"ruta_ que se comparan con las _rutas de solicitud_. Los prefijos de ruta "
"pueden contener un car√°cter comod√≠n que coincida con un segmento completo. "
"Consulta las pruebas unitarias m√°s abajo."

#: src/exercises/day-2/strings-iterators.md:8
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and make the tests "
"pass. Try avoiding allocating a `Vec` for your intermediate results:"
msgstr ""
"Copia el siguiente fragmento de c√≥digo en la p√°gina <https://play.rust-lang."
"org/> para hacer la prueba. Prueba a no asignar un `Vec` a los resultados "
"intermedios:"

#: src/exercises/day-2/strings-iterators.md:12
msgid ""
"```rust\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/"
"abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/"
"books\"));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/publishersBooks\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/parent/"
"publishers\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_matches_with_wildcard() {\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/bar/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books/book1\"\n"
"    ));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/"
"publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"```"
msgstr ""

#: src/welcome-day-3.md:1
msgid "Welcome to Day 3"
msgstr "Te damos la Bienvenida al D√≠a 3"

#: src/welcome-day-3.md:3
msgid "Today, we will cover some more advanced topics of Rust:"
msgstr "Hoy vamos a tratar algunos temas m√°s avanzados de Rust:"

#: src/welcome-day-3.md:5
msgid ""
"Traits: deriving traits, default methods, and important standard library "
"traits."
msgstr ""
"_Traits_: derivaci√≥n de _traits_, m√©todos predeterminados y _traits_ "
"importantes de la _standard library_ (biblioteca est√°ndar)."

#: src/welcome-day-3.md:8
msgid ""
"Generics: generic data types, generic methods, monomorphization, and trait "
"objects."
msgstr ""
"_Generics_ (Gen√©ricos): tipos de datos gen√©ricos, m√©todos gen√©ricos, "
"monomorfizaci√≥n y objetos de _traits_."

#: src/welcome-day-3.md:11
msgid "Error handling: panics, `Result`, and the try operator `?`."
msgstr ""
"Gesti√≥n de errores: _panics_ (p√°nicos), `Result` y el operador _try_ `?`."

#: src/welcome-day-3.md:13
msgid "Testing: unit tests, documentation tests, and integration tests."
msgstr ""
"Pruebas: pruebas unitarias, pruebas de documentaci√≥n y pruebas de "
"integraci√≥n."

#: src/welcome-day-3.md:15
msgid ""
"Unsafe Rust: raw pointers, static variables, unsafe functions, and extern "
"functions."
msgstr ""
"Rust inseguro: punteros sin formato, variables est√°ticas, funciones no "
"seguras y funciones externas."

#: src/generics.md:3
msgid ""
"Rust support generics, which lets you abstract algorithms or data structures "
"(such as sorting or a binary tree) over the types used or stored."
msgstr ""
"Rust admite el uso de gen√©ricos, lo que permite abstraer los algoritmos o "
"las estructuras de datos (como el orden o un √°rbol binario) sobre los tipos "
"utilizados o almacenados."

#: src/generics/data-types.md:3
msgid "You can use generics to abstract over the concrete field type:"
msgstr "Puedes usar gen√©ricos para abstraer el tipo de campo concreto:"

#: src/generics/data-types.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point<T> {\n"
"    x: T,\n"
"    y: T,\n"
"}\n"
"\n"
"fn main() {\n"
"    let integer = Point { x: 5, y: 10 };\n"
"    let float = Point { x: 1.0, y: 4.0 };\n"
"    println!(\"{integer:?} and {float:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/generics/data-types.md:21
msgid "Try declaring a new variable `let p = Point { x: 5, y: 10.0 };`."
msgstr ""
"Prueba a declarar una nueva variable `let p = Point { x: 5, y: 10.0 };`."

#: src/generics/data-types.md:23
msgid "Fix the code to allow points that have elements of different types."
msgstr ""
"Corrige el c√≥digo para permitir puntos que tengan elementos de distintos "
"tipos."

#: src/generics/methods.md:3
msgid "You can declare a generic type on your `impl` block:"
msgstr "Puedes declarar un tipo gen√©rico en tu bloque `impl`:"

#: src/generics/methods.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point<T>(T, T);\n"
"\n"
"impl<T> Point<T> {\n"
"    fn x(&self) -> &T {\n"
"        &self.0  // + 10\n"
"    }\n"
"\n"
"    // fn set_x(&mut self, x: T)\n"
"}\n"
"\n"
"fn main() {\n"
"    let p = Point(5, 10);\n"
"    println!(\"p.x = {}\", p.x());\n"
"}\n"
"```"
msgstr ""

#: src/generics/methods.md:25
msgid ""
"_Q:_ Why `T` is specified twice in `impl<T> Point<T> {}`? Isn't that "
"redundant?"
msgstr ""
"_P:_ ¬øPor qu√© `T` se especifica dos veces en `impl<T> Point<T> {}`? ¬øNo es "
"redundante?"

#: src/generics/methods.md:26
msgid ""
"This is because it is a generic implementation section for generic type. "
"They are independently generic."
msgstr ""
"Esto se debe a que es una secci√≥n de implementaci√≥n gen√©rica para un tipo "
"gen√©rico. Son gen√©ricos de forma independiente."

#: src/generics/methods.md:27
msgid "It means these methods are defined for any `T`."
msgstr "Significa que estos m√©todos est√°n definidos para cualquier `T`."

#: src/generics/methods.md:28
msgid "It is possible to write `impl Point<u32> { .. }`. "
msgstr "Es posible escribir `impl Point<u32> { .. }`. "

#: src/generics/methods.md:29
msgid ""
"`Point` is still generic and you can use `Point<f64>`, but methods in this "
"block will only be available for `Point<u32>`."
msgstr ""
"`Point` sigue siendo gen√©rico y puedes usar `Point<f64>`, pero los m√©todos "
"de este bloque solo estar√°n disponibles para `Point<u32>`."

#: src/generics/monomorphization.md:3
msgid "Generic code is turned into non-generic code based on the call sites:"
msgstr ""
"El c√≥digo gen√©rico se convierte en c√≥digo no gen√©rico en funci√≥n de los "
"sitios de llamada:"

#: src/generics/monomorphization.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let integer = Some(5);\n"
"    let float = Some(5.0);\n"
"}\n"
"```"
msgstr ""

#: src/generics/monomorphization.md:12
msgid "behaves as if you wrote"
msgstr "se comporta como si se hubiera escrito"

#: src/generics/monomorphization.md:14
msgid ""
"```rust,editable\n"
"enum Option_i32 {\n"
"    Some(i32),\n"
"    None,\n"
"}\n"
"\n"
"enum Option_f64 {\n"
"    Some(f64),\n"
"    None,\n"
"}\n"
"\n"
"fn main() {\n"
"    let integer = Option_i32::Some(5);\n"
"    let float = Option_f64::Some(5.0);\n"
"}\n"
"```"
msgstr ""

#: src/generics/monomorphization.md:31
msgid ""
"This is a zero-cost abstraction: you get exactly the same result as if you "
"had hand-coded the data structures without the abstraction."
msgstr ""
"Se trata de una abstracci√≥n sin coste: se obtiene exactamente el mismo "
"resultado que si se hubiesen programado de forma manual las estructuras de "
"datos sin la abstracci√≥n."

#: src/traits.md:3
msgid ""
"Rust lets you abstract over types with traits. They're similar to interfaces:"
msgstr ""
"Rust te permite abstraer sobre tipos con _traits_. Son similares a las "
"interfaces:"

#: src/traits.md:5
msgid ""
"```rust,editable\n"
"trait Pet {\n"
"    fn name(&self) -> String;\n"
"}\n"
"\n"
"struct Dog {\n"
"    name: String,\n"
"}\n"
"\n"
"struct Cat;\n"
"\n"
"impl Pet for Dog {\n"
"    fn name(&self) -> String {\n"
"        self.name.clone()\n"
"    }\n"
"}\n"
"\n"
"impl Pet for Cat {\n"
"    fn name(&self) -> String {\n"
"        String::from(\"The cat\") // No name, cats won't respond to it "
"anyway.\n"
"    }\n"
"}\n"
"\n"
"fn greet<P: Pet>(pet: &P) {\n"
"    println!(\"Who's a cutie? {} is!\", pet.name());\n"
"}\n"
"\n"
"fn main() {\n"
"    let fido = Dog { name: \"Fido\".into() };\n"
"    greet(&fido);\n"
"\n"
"    let captain_floof = Cat;\n"
"    greet(&captain_floof);\n"
"}\n"
"```"
msgstr ""

#: src/traits/trait-objects.md:3
msgid ""
"Trait objects allow for values of different types, for instance in a "
"collection:"
msgstr ""
"Los objetos de _traits_ permiten valores de diferentes tipos, por ejemplo, "
"en una colecci√≥n:"

#: src/traits/trait-objects.md:5
msgid ""
"```rust,editable\n"
"trait Pet {\n"
"    fn name(&self) -> String;\n"
"}\n"
"\n"
"struct Dog {\n"
"    name: String,\n"
"}\n"
"\n"
"struct Cat;\n"
"\n"
"impl Pet for Dog {\n"
"    fn name(&self) -> String {\n"
"        self.name.clone()\n"
"    }\n"
"}\n"
"\n"
"impl Pet for Cat {\n"
"    fn name(&self) -> String {\n"
"        String::from(\"The cat\") // No name, cats won't respond to it "
"anyway.\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let pets: Vec<Box<dyn Pet>> = vec![\n"
"        Box::new(Cat),\n"
"        Box::new(Dog { name: String::from(\"Fido\") }),\n"
"    ];\n"
"    for pet in pets {\n"
"        println!(\"Hello {}!\", pet.name());\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/traits/trait-objects.md:40
msgid "Memory layout after allocating `pets`:"
msgstr "Dise√±o de la memoria despu√©s de asignar `pets`:"

#: src/traits/trait-objects.md:42
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                           :     :                                             :\n"
":    "
"pets                   :     :                                             :\n"
":   +-----------+-------+   :     :   +-----+-----"
"+                             :\n"
":   | ptr       |   o---+---+-----+-->| o o | o o "
"|                             :\n"
":   | len       |     2 |   :     :   +-|-|-+-|-|-"
"+                             :\n"
":   | capacity  |     2 |   :     :     | |   | |   +---------------"
"+           :\n"
":   +-----------+-------+   :     :     | |   | '-->| name: \"Fido\"  "
"|           :\n"
":                           :     :     | |   |     +---------------"
"+           :\n"
"`- - - - - - - - - - - - - -'     :     | |   "
"|                                 :\n"
"                                  :     | |   |     +----------------------"
"+    :   \n"
"                                  :     | |   '---->| \"<Dog as Pet>::name\" "
"|    :\n"
"                                  :     | |         +----------------------"
"+    : \n"
"                                  :     | "
"|                                     : \n"
"                                  :     | |   +-"
"+                               :   \n"
"                                  :     | '-->|"
"\\|                               :     \n"
"                                  :     |     +-"
"+                               :    \n"
"                                  :     "
"|                                       : \n"
"                                  :     |     +----------------------"
"+          : \n"
"                                  :     '---->| \"<Cat as Pet>::name\" "
"|          : \n"
"                                  :           +----------------------"
"+          :\n"
"                                  :                                             :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"\n"
"```"
msgstr ""
"```bob\n"
" _Stack_                          _Heap_\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                           :     :                                             :\n"
":    "
"pets                   :     :                                             :\n"
":   +-----------+-------+   :     :   +-----+-----"
"+                             :\n"
":   | ptr       |   o---+---+-----+-->| o o | o o "
"|                             :\n"
":   | len       |     2 |   :     :   +-|-|-+-|-|-"
"+                             :\n"
":   | capacity  |     2 |   :     :     | |   | |   +---------------"
"+           :\n"
":   +-----------+-------+   :     :     | |   | '-->| name: \"Fido\"  "
"|           :\n"
":                           :     :     | |   |     +---------------"
"+           :\n"
"`- - - - - - - - - - - - - -'     :     | |   "
"|                                 :\n"
"                                  :     | |   |     +----------------------"
"+    :   \n"
"                                  :     | |   '---->| \"<Dog as Pet>::name\" "
"|    :\n"
"                                  :     | |         +----------------------"
"+    : \n"
"                                  :     | "
"|                                     : \n"
"                                  :     | |   +-"
"+                               :   \n"
"                                  :     | '-->|"
"\\|                               :     \n"
"                                  :     |     +-"
"+                               :    \n"
"                                  :     "
"|                                       : \n"
"                                  :     |     +----------------------"
"+          : \n"
"                                  :     '---->| \"<Cat as Pet>::name\" "
"|          : \n"
"                                  :           +----------------------"
"+          :\n"
"                                  :                                             :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"\n"
"```"

#: src/traits/trait-objects.md:72
msgid ""
"Types that implement a given trait may be of different sizes. This makes it "
"impossible to have things like `Vec<Pet>` in the example above."
msgstr ""
"Los tipos que implementan un trait determinado pueden tener diferentes "
"tama√±os. Esto hace imposible tener elementos como `Vec<Pet>` en el ejemplo "
"anterior."

#: src/traits/trait-objects.md:73
msgid ""
"`dyn Pet` is a way to tell the compiler about a dynamically sized type that "
"implements `Pet`."
msgstr ""
"`dyn Pet` es una forma de indicar al compilador un tipo de tama√±o din√°mico "
"que implementa `Pet`."

#: src/traits/trait-objects.md:74
msgid ""
"In the example, `pets` holds _fat pointers_ to objects that implement `Pet`. "
"The fat pointer consists of two components, a pointer to the actual object "
"and a pointer to the virtual method table for the `Pet` implementation of "
"that particular object."
msgstr ""
"En el ejemplo, `pets` contiene _punteros grandes_ en los objetos que "
"implementan `Pet`. El puntero grande consta de dos componentes: un puntero "
"al objeto real y un puntero a la tabla de m√©todos virtuales para la "
"implementaci√≥n de `Pet` en ese objeto concreto."

#: src/traits/trait-objects.md:75
msgid "Compare these outputs in the above example:"
msgstr "Compara estas salidas en el ejemplo anterior:"

#: src/traits/trait-objects.md:76
msgid ""
"```rust,ignore\n"
"    println!(\"{} {}\", std::mem::size_of::<Dog>(), std::mem::size_of::"
"<Cat>());\n"
"    println!(\"{} {}\", std::mem::size_of::<&Dog>(), std::mem::size_of::"
"<&Cat>());\n"
"    println!(\"{}\", std::mem::size_of::<&dyn Pet>());\n"
"    println!(\"{}\", std::mem::size_of::<Box<dyn Pet>>());\n"
"```"
msgstr ""

#: src/traits/deriving-traits.md:3
msgid ""
"Rust derive macros work by automatically generating code that implements the "
"specified traits for a data structure."
msgstr ""
"Las macros de derivaci√≥n de Rust funcionan generando autom√°ticamente c√≥digo "
"que implementa los _traits_ especificados para una estructura de datos."

#: src/traits/deriving-traits.md:5
msgid "You can let the compiler derive a number of traits as follows:"
msgstr ""
"Puedes dejar que el compilador derive una serie de _traits_ de la siguiente "
"manera:"

#: src/traits/deriving-traits.md:7
msgid ""
"```rust,editable\n"
"#[derive(Debug, Clone, PartialEq, Eq, Default)]\n"
"struct Player {\n"
"    name: String,\n"
"    strength: u8,\n"
"    hit_points: u8,\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Player::default();\n"
"    let p2 = p1.clone();\n"
"    println!(\"Is {:?}\\nequal to {:?}?\\nThe answer is {}!\", &p1, &p2,\n"
"             if p1 == p2 { \"yes\" } else { \"no\" });\n"
"}\n"
"```"
msgstr ""

#: src/traits/default-methods.md:3
msgid "Traits can implement behavior in terms of other trait methods:"
msgstr ""
"Los _traits_ pueden implementar comportamientos en funci√≥n de otros m√©todos "
"de _traits_:"

#: src/traits/default-methods.md:5
msgid ""
"```rust,editable\n"
"trait Equals {\n"
"    fn equals(&self, other: &Self) -> bool;\n"
"    fn not_equals(&self, other: &Self) -> bool {\n"
"        !self.equals(other)\n"
"    }\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"struct Centimeter(i16);\n"
"\n"
"impl Equals for Centimeter {\n"
"    fn equals(&self, other: &Centimeter) -> bool {\n"
"        self.0 == other.0\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let a = Centimeter(10);\n"
"    let b = Centimeter(20);\n"
"    println!(\"{a:?} equals {b:?}: {}\", a.equals(&b));\n"
"    println!(\"{a:?} not_equals {b:?}: {}\", a.not_equals(&b));\n"
"}\n"
"```"
msgstr ""

#: src/traits/default-methods.md:32
msgid ""
"Traits may specify pre-implemented (default) methods and methods that users "
"are required to implement themselves. Methods with default implementations "
"can rely on required methods."
msgstr ""
"Los _traits_ pueden especificar los m√©todos implementados previamente "
"(predeterminados) y los m√©todos que los usuarios deben implementar ellos "
"mismos. Los m√©todos con implementaciones predeterminadas pueden basarse en "
"m√©todos obligatorios."

#: src/traits/default-methods.md:35
msgid "Move method `not_equals` to a new trait `NotEquals`."
msgstr "Mueve el m√©todo `not_equals` a un nuevo trait `NotEquals`."

#: src/traits/default-methods.md:37
msgid "Make `Equals` a super trait for `NotEquals`."
msgstr "Haz que `Equals` sea un supertrait para `NotEquals`."

#: src/traits/default-methods.md:38
msgid ""
"```rust,editable,compile_fail\n"
"trait NotEquals: Equals {\n"
"    fn not_equals(&self, other: &Self) -> bool {\n"
"        !self.equals(other)\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"trait NotEquals: Equals {\n"
"    fn not_equals(&self, other: &Self) -> bool {\n"
"        !self.equals(other)\n"
"    }\n"
"}\n"
"```"

#: src/traits/default-methods.md:46
msgid "Provide a blanket implementation of `NotEquals` for `Equals`."
msgstr "Proporciona una implementaci√≥n general de `NotEquals` para `Equals`."

#: src/traits/default-methods.md:47
msgid ""
"```rust,editable,compile_fail\n"
"trait NotEquals {\n"
"    fn not_equals(&self, other: &Self) -> bool;\n"
"}\n"
"\n"
"impl<T> NotEquals for T where T: Equals {\n"
"    fn not_equals(&self, other: &Self) -> bool {\n"
"        !self.equals(other)\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/traits/default-methods.md:58
msgid ""
"With the blanket implementation, you no longer need `Equals` as a super "
"trait for `NotEqual`."
msgstr ""
"Con la implementaci√≥n general, ya no necesitas `Equals` como supertrait para "
"`NotEqual`."

#: src/traits/trait-bounds.md:3
msgid ""
"When working with generics, you often want to require the types to implement "
"some trait, so that you can call this trait's methods."
msgstr ""
"Cuando se trabaja con gen√©ricos, a menudo se prefiere que los tipos "
"implementen alg√∫n trait, de forma que se pueda llamar a los m√©todos de este "
"trait."

#: src/traits/trait-bounds.md:6
msgid "You can do this with `T: Trait` or `impl Trait`:"
msgstr "Puedes hacerlo con `T: Trait` o `impl Trait`:"

#: src/traits/trait-bounds.md:8
msgid ""
"```rust,editable\n"
"fn duplicate<T: Clone>(a: T) -> (T, T) {\n"
"    (a.clone(), a.clone())\n"
"}\n"
"\n"
"// Syntactic sugar for:\n"
"//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"
"fn add_42_millions(x: impl Into<i32>) -> i32 {\n"
"    x.into() + 42_000_000\n"
"}\n"
"\n"
"// struct NotClonable;\n"
"\n"
"fn main() {\n"
"    let foo = String::from(\"foo\");\n"
"    let pair = duplicate(foo);\n"
"    println!(\"{pair:?}\");\n"
"\n"
"    let many = add_42_millions(42_i8);\n"
"    println!(\"{many}\");\n"
"    let many_more = add_42_millions(10_000_000);\n"
"    println!(\"{many_more}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/trait-bounds.md:35
msgid "Show a `where` clause, students will encounter it when reading code."
msgstr ""
"Muestra una cl√°usula `where` para que los alumnos la encuentren al leer el "
"c√≥digo."

#: src/traits/trait-bounds.md:37
msgid ""
"```rust,ignore\n"
"fn duplicate<T>(a: T) -> (T, T)\n"
"where\n"
"    T: Clone,\n"
"{\n"
"    (a.clone(), a.clone())\n"
"}\n"
"```"
msgstr ""

#: src/traits/trait-bounds.md:46
msgid "It declutters the function signature if you have many parameters."
msgstr "Despeja la firma de la funci√≥n si tienes muchos par√°metros."

#: src/traits/trait-bounds.md:47
msgid "It has additional features making it more powerful."
msgstr "Tiene funciones adicionales para que sea m√°s potente."

#: src/traits/trait-bounds.md:48
msgid ""
"If someone asks, the extra feature is that the type on the left of \":\" can "
"be arbitrary, like `Option<T>`."
msgstr ""
"Si alguien pregunta, la funci√≥n adicional es que el tipo que est√° a la "
"izquierda de \":\" puede ser arbitrario, como `Option<T>`."

#: src/traits/impl-trait.md:1
msgid "`impl Trait`"
msgstr "`impl Trait`"

#: src/traits/impl-trait.md:3
msgid ""
"Similar to trait bounds, an `impl Trait` syntax can be used in function "
"arguments and return values:"
msgstr ""
"De forma similar a los l√≠mites de _traits_, se puede usar la sintaxis `impl "
"Trait` en argumentos de funciones y valores devueltos:"

#: src/traits/impl-trait.md:6
msgid ""
"```rust,editable\n"
"use std::fmt::Display;\n"
"\n"
"fn get_x(name: impl Display) -> impl Display {\n"
"    format!(\"Hello {name}\")\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = get_x(\"foo\");\n"
"    println!(\"{x}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/impl-trait.md:19
msgid "`impl Trait` allows you to work with types which you cannot name."
msgstr ""
"`impl Trait` permite trabajar con tipos a los que no se les puede asignar un "
"nombre."

#: src/traits/impl-trait.md:23
msgid ""
"The meaning of `impl Trait` is a bit different in the different positions."
msgstr "La naturaleza de `impl Trait` var√≠a ligeramente seg√∫n la posici√≥n."

#: src/traits/impl-trait.md:25
msgid ""
"For a parameter, `impl Trait` is like an anonymous generic parameter with a "
"trait bound."
msgstr ""
"En el caso de los par√°metros, `impl Trait` es como un par√°metro gen√©rico "
"an√≥nimo con un l√≠mite de trait."

#: src/traits/impl-trait.md:27
msgid ""
"For a return type, it means that the return type is some concrete type that "
"implements the trait, without naming the type. This can be useful when you "
"don't want to expose the concrete type in a public API."
msgstr ""
"En el caso de un tipo de resultado devuelto, significa que este es un tipo "
"concreto que implementa el trait, sin nombrar el tipo. Esto puede ser √∫til "
"cuando no quieres exponer el tipo concreto en una API p√∫blica."

#: src/traits/impl-trait.md:31
msgid ""
"Inference is hard in return position. A function returning `impl Foo` picks "
"the concrete type it returns, without writing it out in the source. A "
"function returning a generic type like `collect<B>() -> B` can return any "
"type satisfying `B`, and the caller may need to choose one, such as with "
"`let x: Vec<_> = foo.collect()` or with the turbofish, `foo.collect::"
"<Vec<_>>()`."
msgstr ""
"La inferencia es m√°s complicada en la posici√≥n de retorno. Una funci√≥n que "
"devuelve `impl Foo` elige el tipo concreto que devuelve, sin escribirlo en "
"el c√≥digo fuente. Una funci√≥n que devuelve un tipo gen√©rico como "
"`collect<B>() -> B` puede devolver cualquier tipo que cumpla `B`, y es "
"posible que el llamador tenga que elegir uno, como con `let x: Vec<_> = foo."
"collect()` o con la sintaxis turbofish, `foo.collect::<Vec<_>>()`."

#: src/traits/impl-trait.md:37
msgid ""
"This example is great, because it uses `impl Display` twice. It helps to "
"explain that nothing here enforces that it is _the same_ `impl Display` "
"type. If we used a single  `T: Display`, it would enforce the constraint "
"that input `T` and return `T` type are the same type. It would not work for "
"this particular function, as the type we expect as input is likely not what "
"`format!` returns. If we wanted to do the same via `: Display` syntax, we'd "
"need two independent generic parameters."
msgstr ""
"Este ejemplo es fant√°stico porque usa `impl Display` dos veces. Nos ayuda "
"explicar que no hay nada que obligue a que sea _el mismo_ tipo `impl "
"Display`. Si se utiliza un solo `T: Display`, se aplicar√≠a la restricci√≥n de "
"que el tipo de entrada `T` y el tipo de retorno `T` son iguales. No "
"funcionar√≠a para esta funci√≥n en concreto, ya que el tipo que esperamos como "
"entrada probablemente no sea el que devuelve `format!`. Si quisi√©ramos hacer "
"lo mismo a trav√©s de la sintaxis `: Display`, necesitar√≠amos dos par√°metros "
"gen√©ricos independientes."

#: src/traits/important-traits.md:3
msgid ""
"We will now look at some of the most common traits of the Rust standard "
"library:"
msgstr ""
"A continuaci√≥n, veremos algunos de los _traits_ m√°s comunes de la biblioteca "
"est√°ndar de Rust:"

#: src/traits/important-traits.md:5
msgid ""
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) and "
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html) "
"used in `for` loops,"
msgstr ""
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) y "
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html) "
"se usan en los bucles `for`."

#: src/traits/important-traits.md:6
msgid ""
"[`From`](https://doc.rust-lang.org/std/convert/trait.From.html) and [`Into`]"
"(https://doc.rust-lang.org/std/convert/trait.Into.html) used to convert "
"values,"
msgstr ""
"[`From`](https://doc.rust-lang.org/std/convert/trait.From.html) y [`Into`]"
"(https://doc.rust-lang.org/std/convert/trait.Into.html) se usan para "
"convertir valores."

#: src/traits/important-traits.md:7
msgid ""
"[`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) and [`Write`]"
"(https://doc.rust-lang.org/std/io/trait.Write.html) used for IO,"
msgstr ""
"[`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) y [`Write`]"
"(https://doc.rust-lang.org/std/io/trait.Write.html) se usan para E/S."

#: src/traits/important-traits.md:8
msgid ""
"[`Add`](https://doc.rust-lang.org/std/ops/trait.Add.html), [`Mul`](https://"
"doc.rust-lang.org/std/ops/trait.Mul.html), ... used for operator "
"overloading, and"
msgstr ""
"[`Add`](https://doc.rust-lang.org/std/ops/trait.Add.html), [`Mul`](https://"
"doc.rust-lang.org/std/ops/trait.Mul.html), ... se usan para sobrecargar "
"operadores, y"

#: src/traits/important-traits.md:9
msgid ""
"[`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) used for "
"defining destructors."
msgstr ""
"[`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) se usa para "
"definir destructores."

#: src/traits/important-traits.md:10
msgid ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) used "
"to construct a default instance of a type."
msgstr ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) se usa "
"para construir una instancia predeterminada de un tipo."

#: src/traits/iterator.md:1
msgid "Iterators"
msgstr "Iteradores"

#: src/traits/iterator.md:3
msgid ""
"You can implement the [`Iterator`](https://doc.rust-lang.org/std/iter/trait."
"Iterator.html) trait on your own types:"
msgstr ""
"Se puede implementar el trait [`Iterator`](https://doc.rust-lang.org/std/"
"iter/trait.Iterator.html) en tus propios tipos:"

#: src/traits/iterator.md:5
msgid ""
"```rust,editable\n"
"struct Fibonacci {\n"
"    curr: u32,\n"
"    next: u32,\n"
"}\n"
"\n"
"impl Iterator for Fibonacci {\n"
"    type Item = u32;\n"
"\n"
"    fn next(&mut self) -> Option<Self::Item> {\n"
"        let new_next = self.curr + self.next;\n"
"        self.curr = self.next;\n"
"        self.next = new_next;\n"
"        Some(self.curr)\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = Fibonacci { curr: 0, next: 1 };\n"
"    for (i, n) in fib.enumerate().take(5) {\n"
"        println!(\"fib({i}): {n}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/traits/iterator.md:32
msgid ""
"The `Iterator` trait implements many common functional programming "
"operations over collections  (e.g. `map`, `filter`, `reduce`, etc). This is "
"the trait where you can find all the documentation about them. In Rust these "
"functions should produce the code as efficient as equivalent imperative "
"implementations."
msgstr ""
"El trait `Iterator` implementa muchas operaciones comunes de programaci√≥n "
"funcional en colecciones (por ejemplo, `map`, `filter`, `reduce`, etc.). "
"Este es el trait que te permite encontrar toda la documentaci√≥n sobre ellas. "
"En Rust, estas funciones deber√≠an generar un c√≥digo tan eficiente como las "
"implementaciones imperativas equivalentes."

#: src/traits/iterator.md:37
msgid ""
"`IntoIterator` is the trait that makes for loops work. It is implemented by "
"collection types such as `Vec<T>` and references to them such as `&Vec<T>` "
"and `&[T]`. Ranges also implement it. This is why you can iterate over a "
"vector with `for i in some_vec { .. }` but `some_vec.next()` doesn't exist."
msgstr ""
"`IntoIterator` es el trait que hace que los bucles funcionen. Se implementa "
"a trav√©s de tipos de colecciones, como `Vec<T>`, y de referencias a ellas, "
"como `&Vec<T>` y `&[T]`. Los intervalos tambi√©n lo implementan. Esta es la "
"raz√≥n por la que se puede iterar sobre un vector con `for i in some_vec "
"{ .. }`, pero `some_vec.next()` no existe."

#: src/traits/from-iterator.md:3
msgid ""
"[`FromIterator`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html) "
"lets you build a collection from an [`Iterator`](https://doc.rust-lang.org/"
"std/iter/trait.Iterator.html)."
msgstr ""
"[`FromIterator`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html) "
"permite construir una colecci√≥n a partir de un [`Iterator`](https://doc.rust-"
"lang.org/std/iter/trait.Iterator.html)."

#: src/traits/from-iterator.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let primes = vec![2, 3, 5, 7];\n"
"    let prime_squares = primes\n"
"        .into_iter()\n"
"        .map(|prime| prime * prime)\n"
"        .collect::<Vec<_>>();\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-iterator.md:17
msgid ""
"`Iterator` implements `fn collect<B>(self) -> B where B: FromIterator<Self::"
"Item>, Self: Sized`"
msgstr ""
"`Iterator` implementa `fn collect<B>(self) -> B where B: FromIterator<Self::"
"Item>, Self: Sized`."

#: src/traits/from-iterator.md:23
msgid ""
"There are also implementations which let you do cool things like convert an "
"`Iterator<Item = Result<V, E>>` into a `Result<Vec<V>, E>`."
msgstr ""
"Tambi√©n hay implementaciones que permiten hacer cosas interesantes, como "
"convertir un  `Iterator<Item = Result<V, E>>` en un `Result<Vec<V>, E>`."

#: src/traits/from-into.md:1
msgid "`From` and `Into`"
msgstr "`From` e `Into`"

#: src/traits/from-into.md:3
msgid ""
"Types implement [`From`](https://doc.rust-lang.org/std/convert/trait.From."
"html) and [`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) to "
"facilitate type conversions:"
msgstr ""
"Los tipos implementan [`From`](https://doc.rust-lang.org/std/convert/trait."
"From.html) y [`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) "
"para facilitar las conversiones de tipos:"

#: src/traits/from-into.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s = String::from(\"hello\");\n"
"    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);\n"
"    let one = i16::from(true);\n"
"    let bigger = i32::from(123i16);\n"
"    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-into.md:15
msgid ""
"[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) is "
"automatically implemented when [`From`](https://doc.rust-lang.org/std/"
"convert/trait.From.html) is implemented:"
msgstr ""
"[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) se "
"implementa autom√°ticamente cuando se implementa [`From`](https://doc.rust-"
"lang.org/std/convert/trait.From.html):"

#: src/traits/from-into.md:17
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s: String = \"hello\".into();\n"
"    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();\n"
"    let one: i16 = true.into();\n"
"    let bigger: i32 = 123i16.into();\n"
"    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-into.md:29
msgid ""
"That's why it is common to only implement `From`, as your type will get "
"`Into` implementation too."
msgstr ""
"Por eso se suele implementar solo `From`, ya que el tipo ya habr√° "
"implementado tambi√©n `Into`."

#: src/traits/from-into.md:30
msgid ""
"When declaring a function argument input type like \"anything that can be "
"converted into a `String`\", the rule is opposite, you should use `Into`. "
"Your function will accept types that implement `From` and those that _only_ "
"implement `Into`."
msgstr ""
"Cuando se declara un tipo de entrada de argumento de funci√≥n como "
"\"cualquier elemento que se pueda convertir en `String`\", la regla es la "
"contraria y se debe usar `Into`. La funci√≥n aceptar√° tipos que implementen "
"`From` y aquellos que _solo_ implementen `Into`."

#: src/traits/read-write.md:1
msgid "`Read` and `Write`"
msgstr "`Read` y `Write`"

#: src/traits/read-write.md:3
msgid ""
"Using [`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) and "
"[`BufRead`](https://doc.rust-lang.org/std/io/trait.BufRead.html), you can "
"abstract over `u8` sources:"
msgstr ""
"Usando [`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) y "
"[`BufRead`](https://doc.rust-lang.org/std/io/trait.BufRead.html), se puede "
"abstraer sobre fuentes `u8`:"

#: src/traits/read-write.md:5
msgid ""
"```rust,editable\n"
"use std::io::{BufRead, BufReader, Read, Result};\n"
"\n"
"fn count_lines<R: Read>(reader: R) -> usize {\n"
"    let buf_reader = BufReader::new(reader);\n"
"    buf_reader.lines().count()\n"
"}\n"
"\n"
"fn main() -> Result<()> {\n"
"    let slice: &[u8] = b\"foo\\nbar\\nbaz\\n\";\n"
"    println!(\"lines in slice: {}\", count_lines(slice));\n"
"\n"
"    let file = std::fs::File::open(std::env::current_exe()?)?;\n"
"    println!(\"lines in file: {}\", count_lines(file));\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/traits/read-write.md:23
msgid ""
"Similarly, [`Write`](https://doc.rust-lang.org/std/io/trait.Write.html) lets "
"you abstract over `u8` sinks:"
msgstr ""
"De forma similar, [`Write`](https://doc.rust-lang.org/std/io/trait.Write."
"html) te permite abstraer sobre fuentes `u8`:"

#: src/traits/read-write.md:25
msgid ""
"```rust,editable\n"
"use std::io::{Result, Write};\n"
"\n"
"fn log<W: Write>(writer: &mut W, msg: &str) -> Result<()> {\n"
"    writer.write_all(msg.as_bytes())?;\n"
"    writer.write_all(\"\\n\".as_bytes())\n"
"}\n"
"\n"
"fn main() -> Result<()> {\n"
"    let mut buffer = Vec::new();\n"
"    log(&mut buffer, \"Hello\")?;\n"
"    log(&mut buffer, \"World\")?;\n"
"    println!(\"Logged: {:?}\", buffer);\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/traits/drop.md:1
msgid "The `Drop` Trait"
msgstr "El Trait `Drop`"

#: src/traits/drop.md:3
msgid ""
"Values which implement [`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop."
"html) can specify code to run when they go out of scope:"
msgstr ""
"Los valores que implementan [`Drop`](https://doc.rust-lang.org/std/ops/trait."
"Drop.html) pueden especificar el c√≥digo que se ejecutar√° cuando salgan del "
"√°mbito:"

#: src/traits/drop.md:5
msgid ""
"```rust,editable\n"
"struct Droppable {\n"
"    name: &'static str,\n"
"}\n"
"\n"
"impl Drop for Droppable {\n"
"    fn drop(&mut self) {\n"
"        println!(\"Dropping {}\", self.name);\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let a = Droppable { name: \"a\" };\n"
"    {\n"
"        let b = Droppable { name: \"b\" };\n"
"        {\n"
"            let c = Droppable { name: \"c\" };\n"
"            let d = Droppable { name: \"d\" };\n"
"            println!(\"Exiting block B\");\n"
"        }\n"
"        println!(\"Exiting block A\");\n"
"    }\n"
"    drop(a);\n"
"    println!(\"Exiting main\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/drop.md:34 src/traits/operators.md:26
msgid "Discussion points:"
msgstr "Cuestiones de debate:"

#: src/traits/drop.md:36
msgid "Why doesn't `Drop::drop` take `self`?"
msgstr "¬øPor qu√© `Drop::drop` no acepta `self`?"

#: src/traits/drop.md:37
msgid ""
"Short-answer: If it did, `std::mem::drop` would be called at the end of the "
"block, resulting in another call to `Drop::drop`, and a stack overflow!"
msgstr ""
"Respuesta corta: si lo hiciera, se llamar√≠a a `std::mem::drop` al final del "
"bloque, lo que dar√≠a como resultado otra llamada a `Drop::drop` y un "
"desbordamiento de la _stack_."

#: src/traits/drop.md:40
msgid "Try replacing `drop(a)` with `a.drop()`."
msgstr "Prueba a sustituir `drop(a)` por `a.drop()`."

#: src/traits/default.md:1
msgid "The `Default` Trait"
msgstr "El trait `Default`"

#: src/traits/default.md:3
msgid ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) trait "
"produces a default value for a type."
msgstr ""
"El trait [`Default`](https://doc.rust-lang.org/std/default/trait.Default."
"html) produce un valor predeterminado para un tipo."

#: src/traits/default.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Default)]\n"
"struct Derived {\n"
"    x: u32,\n"
"    y: String,\n"
"    z: Implemented,\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"struct Implemented(String);\n"
"\n"
"impl Default for Implemented {\n"
"    fn default() -> Self {\n"
"        Self(\"John Smith\".into())\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let default_struct = Derived::default();\n"
"    println!(\"{default_struct:#?}\");\n"
"\n"
"    let almost_default_struct = Derived {\n"
"        y: \"Y is set!\".into(),\n"
"        ..Derived::default()\n"
"    };\n"
"    println!(\"{almost_default_struct:#?}\");\n"
"\n"
"    let nothing: Option<Derived> = None;\n"
"    println!(\"{:#?}\", nothing.unwrap_or_default());\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/traits/default.md:40
msgid ""
"It can be implemented directly or it can be derived via `#[derive(Default)]`."
msgstr ""
"Se puede implementar directamente o se puede derivar a trav√©s de "
"`#[derive(Default)]`."

#: src/traits/default.md:41
msgid ""
"A derived implementation will produce a value where all fields are set to "
"their default values."
msgstr ""
"Una implementaci√≥n derivada producir√° un valor en el que todos los campos "
"tendr√°n sus valores predeterminados."

#: src/traits/default.md:42
msgid "This means all types in the struct must implement `Default` too."
msgstr ""
"Esto significa que todos los tipos de la estructura tambi√©n deber√°n "
"implementar `Default`."

#: src/traits/default.md:43
msgid ""
"Standard Rust types often implement `Default` with reasonable values (e.g. "
"`0`, `\"\"`, etc)."
msgstr ""
"Los tipos est√°ndar de Rust suelen implementar `Default` con valores "
"razonables (por ejemplo, `0`, `\"\"`, etc.)."

#: src/traits/default.md:44
msgid "The partial struct copy works nicely with default."
msgstr ""
"La copia parcial de la estructura funciona correctamente con los valores "
"predeterminados. ."

#: src/traits/default.md:45
msgid ""
"Rust standard library is aware that types can implement `Default` and "
"provides convenience methods that use it."
msgstr ""
"La biblioteca est√°ndar de Rust tiene en cuenta que los tipos pueden "
"implementar `Default` y, por ello, proporciona m√©todos pr√°cticos que lo "
"utilizan."

#: src/traits/default.md:46
msgid ""
"the `..` syntax is called [struct update syntax](https://doc.rust-lang.org/"
"book/ch05-01-defining-structs.html#creating-instances-from-other-instances-"
"with-struct-update-syntax)"
msgstr ""
"la sintaxis `..` se denomina [sintaxis de actualizaci√≥n de estructuras]"
"(https://doc.rust-lang.org/book/ch05-01-defining-structs.html#creating-"
"instances-from-other-instances-with-struct-update-syntax)"

#: src/traits/operators.md:1
msgid "`Add`, `Mul`, ..."
msgstr "`Add`, `Mul`, etc."

#: src/traits/operators.md:3
msgid ""
"Operator overloading is implemented via traits in [`std::ops`](https://doc."
"rust-lang.org/std/ops/index.html):"
msgstr ""
"La sobrecarga de operadores se implementa mediante _traits_ en [`std::ops`]"
"(https://doc.rust-lang.org/std/ops/index.html):"

#: src/traits/operators.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Copy, Clone)]\n"
"struct Point { x: i32, y: i32 }\n"
"\n"
"impl std::ops::Add for Point {\n"
"    type Output = Self;\n"
"\n"
"    fn add(self, other: Self) -> Self {\n"
"        Self {x: self.x + other.x, y: self.y + other.y}\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Point { x: 10, y: 20 };\n"
"    let p2 = Point { x: 100, y: 200 };\n"
"    println!(\"{:?} + {:?} = {:?}\", p1, p2, p1 + p2);\n"
"}\n"
"```"
msgstr ""

#: src/traits/operators.md:28
msgid ""
"You could implement `Add` for `&Point`. In which situations is that useful? "
msgstr "¬øEn qu√© situaciones ser√≠a √∫til implementar `Add` para `&Point`? "

#: src/traits/operators.md:29
msgid ""
"Answer: `Add:add` consumes `self`. If type `T` for which you are overloading "
"the operator is not `Copy`, you should consider overloading the operator for "
"`&T` as well. This avoids unnecessary cloning on the call site."
msgstr ""
"Respuesta: `Add:add` consume a `self`. Si el tipo `T` para el que se "
"sobrecarga el operador no es `Copy`, deber√≠as plantearte tambi√©n sobrecargar "
"el operador para `&T`. As√≠ se evita la clonaci√≥n innecesaria en el sitio de "
"la llamada."

#: src/traits/operators.md:33
msgid ""
"Why is `Output` an associated type? Could it be made a type parameter of the "
"method?"
msgstr ""
"¬øPor qu√© `Output` es un tipo asociado? ¬øSe podr√≠a convertir en un par√°metro "
"tipo del m√©todo?"

#: src/traits/operators.md:34
msgid ""
"Short answer: Function type parameters are controlled by the caller, but "
"associated types (like `Output`) are controlled by the implementor of a "
"trait."
msgstr ""
"Respuesta corta: el llamador controla los par√°metros tipo de la funci√≥n, "
"pero los tipos asociados (como `Output`) los controla el implementador de un "
"trait ."

#: src/traits/operators.md:37
msgid ""
"You could implement `Add` for two different types, e.g. `impl Add<(i32, "
"i32)> for Point` would add a tuple to a `Point`."
msgstr ""
"Se podr√≠a implementar `Add` para dos tipos distintos; por ejemplo, `impl "
"Add<(i32, i32)> for Point` a√±adir√≠a una tupla a un `Point`."

#: src/traits/closures.md:1
msgid "Closures"
msgstr "Cierres"

#: src/traits/closures.md:3
msgid ""
"Closures or lambda expressions have types which cannot be named. However, "
"they implement special [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn."
"html), [`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), and "
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) traits:"
msgstr ""
"Los cierres o expresiones lambda tienen tipos que no pueden nombrarse. Sin "
"embargo, implementan _traits_ especiales [`Fn`](https://doc.rust-lang.org/"
"std/ops/trait.Fn.html), [`FnMut`](https://doc.rust-lang.org/std/ops/trait."
"FnMut.html) y [`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce."
"html):"

#: src/traits/closures.md:8
msgid ""
"```rust,editable\n"
"fn apply_with_log(func: impl FnOnce(i32) -> i32, input: i32) -> i32 {\n"
"    println!(\"Calling function on {input}\");\n"
"    func(input)\n"
"}\n"
"\n"
"fn main() {\n"
"    let add_3 = |x| x + 3;\n"
"    println!(\"add_3: {}\", apply_with_log(add_3, 10));\n"
"    println!(\"add_3: {}\", apply_with_log(add_3, 20));\n"
"\n"
"    let mut v = Vec::new();\n"
"    let mut accumulate = |x: i32| {\n"
"        v.push(x);\n"
"        v.iter().sum::<i32>()\n"
"    };\n"
"    println!(\"accumulate: {}\", apply_with_log(&mut accumulate, 4));\n"
"    println!(\"accumulate: {}\", apply_with_log(&mut accumulate, 5));\n"
"\n"
"    let multiply_sum = |x| x * v.into_iter().sum::<i32>();\n"
"    println!(\"multiply_sum: {}\", apply_with_log(multiply_sum, 3));\n"
"}\n"
"```"
msgstr ""

#: src/traits/closures.md:34
msgid ""
"An `Fn` (e.g. `add_3`) neither consumes nor mutates captured values, or "
"perhaps captures nothing at all. It can be called multiple times "
"concurrently."
msgstr ""
"Un `Fn` (por ejemplo, `add_3`) no consume ni modifica los valores "
"capturados, o quiz√°  no captura nada en absoluto. Se puede llamar varias "
"veces al mismo tiempo."

#: src/traits/closures.md:37
msgid ""
"An `FnMut` (e.g. `accumulate`) might mutate captured values. You can call it "
"multiple times, but not concurrently."
msgstr ""
"Un `FnMut` (por ejemplo, `accumulate`) puede modificar los valores "
"capturados. Se puede llamar varias veces, pero no de forma simult√°nea."

#: src/traits/closures.md:40
msgid ""
"If you have an `FnOnce` (e.g. `multiply_sum`), you may only call it once. It "
"might consume captured values."
msgstr ""
"Si tienes un `FnOnce` (por ejemplo, `multiply_sum`), solo puedes llamarlo "
"una vez. Puede consumir valores capturados."

#: src/traits/closures.md:43
msgid ""
"`FnMut` is a subtype of `FnOnce`. `Fn` is a subtype of `FnMut` and `FnOnce`. "
"I.e. you can use an `FnMut` wherever an `FnOnce` is called for, and you can "
"use an `Fn` wherever an `FnMut` or `FnOnce` is called for."
msgstr ""
"`FnMut` es un subtipo de `FnOnce`, mientras que `Fn` es un subtipo de "
"`FnMut` y `FnOnce`. Es decir, puedes utilizar un `FnMut` siempre que se "
"llame a un `FnOnce`, y puedes usar un `Fn` siempre que se llame a un `FnMut` "
"o a un `FnOnce`."

#: src/traits/closures.md:47
msgid ""
"The compiler also infers `Copy` (e.g. for `add_3`) and `Clone` (e.g. "
"`multiply_sum`), depending on what the closure captures."
msgstr ""
"El compilador tambi√©n infiere `Copy` (por ejemplo, `add_3`) y `Clone` (por "
"ejemplo, `multiply_sum`), dependiendo de lo que capture el cierre."

#: src/traits/closures.md:50
msgid ""
"By default, closures will capture by reference if they can. The `move` "
"keyword makes them capture by value."
msgstr ""
"De forma predeterminada, los cierres capturan, si pueden, por referencia. La "
"palabra clave `move` hace que capturen por valor."

#: src/traits/closures.md:52
msgid ""
"```rust,editable\n"
"fn make_greeter(prefix: String) -> impl Fn(&str) {\n"
"    return move |name| println!(\"{} {}\", prefix, name)\n"
"}\n"
"\n"
"fn main() {\n"
"    let hi = make_greeter(\"Hi\".to_string());\n"
"    hi(\"there\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-3/morning.md:1
msgid "Day 3: Morning Exercises"
msgstr "D√≠a 3: Ejercicios de la Ma√±ana"

#: src/exercises/day-3/morning.md:3
msgid "We will design a classical GUI library using traits and trait objects."
msgstr "Dise√±aremos una biblioteca GUI cl√°sica de _traits_ y objetos _trait_."

#: src/exercises/day-3/morning.md:5
msgid ""
"We will also look at enum dispatch with an exercise involving points and "
"polygons."
msgstr ""
"Tambi√©n veremos la asignaci√≥n de enumeraciones con un ejercicio que "
"involucra puntos y pol√≠gonos."

#: src/exercises/day-3/simple-gui.md:3
msgid ""
"Let us design a classical GUI library using our new knowledge of traits and "
"trait objects."
msgstr ""
"Vamos a dise√±ar una biblioteca GUI cl√°sica con nuestro reci√©n adquirido "
"conocimiento sobre _traits_ y objetos trait."

#: src/exercises/day-3/simple-gui.md:6
msgid "We will have a number of widgets in our library:"
msgstr "Tendremos varios widgets en nuestra biblioteca:"

#: src/exercises/day-3/simple-gui.md:8
msgid "`Window`: has a `title` and contains other widgets."
msgstr "`Window`: tiene un `title` y contiene otros widgets."

#: src/exercises/day-3/simple-gui.md:9
msgid ""
"`Button`: has a `label` and a callback function which is invoked when the "
"button is pressed."
msgstr ""
"`Button`: tiene una `label` y una funci√≥n de retrollamada que se invoca "
"cuando se pulsa el bot√≥n."

#: src/exercises/day-3/simple-gui.md:11
msgid "`Label`: has a `label`."
msgstr "`Label`: tiene una `label`."

#: src/exercises/day-3/simple-gui.md:13
msgid "The widgets will implement a `Widget` trait, see below."
msgstr "Los widgets implementar√°n un trait `Widget`, como se indica m√°s abajo."

#: src/exercises/day-3/simple-gui.md:15
msgid ""
"Copy the code below to <https://play.rust-lang.org/>, fill in the missing "
"`draw_into` methods so that you implement the `Widget` trait:"
msgstr ""
"Copia el siguiente fragmento de c√≥digo en la p√°gina <https://play.rust-lang."
"org/> y rellena los m√©todos `draw_into` que faltan para implementar el trait "
"`Widget`:"

#: src/exercises/day-3/simple-gui.md:18
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_imports, unused_variables, dead_code)]\n"
"\n"
"pub trait Widget {\n"
"    /// Natural width of `self`.\n"
"    fn width(&self) -> usize;\n"
"\n"
"    /// Draw the widget into a buffer.\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);\n"
"\n"
"    /// Draw the widget on standard output.\n"
"    fn draw(&self) {\n"
"        let mut buffer = String::new();\n"
"        self.draw_into(&mut buffer);\n"
"        println!(\"{buffer}\");\n"
"    }\n"
"}\n"
"\n"
"pub struct Label {\n"
"    label: String,\n"
"}\n"
"\n"
"impl Label {\n"
"    fn new(label: &str) -> Label {\n"
"        Label {\n"
"            label: label.to_owned(),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Button {\n"
"    label: Label,\n"
"    callback: Box<dyn FnMut()>,\n"
"}\n"
"\n"
"impl Button {\n"
"    fn new(label: &str, callback: Box<dyn FnMut()>) -> Button {\n"
"        Button {\n"
"            label: Label::new(label),\n"
"            callback,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Window {\n"
"    title: String,\n"
"    widgets: Vec<Box<dyn Widget>>,\n"
"}\n"
"\n"
"impl Window {\n"
"    fn new(title: &str) -> Window {\n"
"        Window {\n"
"            title: title.to_owned(),\n"
"            widgets: Vec::new(),\n"
"        }\n"
"    }\n"
"\n"
"    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
"        self.widgets.push(widget);\n"
"    }\n"
"\n"
"    fn inner_width(&self) -> usize {\n"
"        std::cmp::max(\n"
"            self.title.chars().count(),\n"
"            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
"        )\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"This is a small text GUI demo."
"\")));\n"
"    window.add_widget(Box::new(Button::new(\n"
"        \"Click me!\",\n"
"        Box::new(|| println!(\"You clicked the button!\")),\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-3/simple-gui.md:130
msgid "The output of the above program can be something simple like this:"
msgstr "La salida del programa anterior puede ser algo sencillo como esto:"

#: src/exercises/day-3/simple-gui.md:132
msgid ""
"```text\n"
"========\n"
"Rust GUI Demo 1.23\n"
"========\n"
"\n"
"This is a small text GUI demo.\n"
"\n"
"| Click me! |\n"
"```"
msgstr ""

#: src/exercises/day-3/simple-gui.md:142
msgid ""
"If you want to draw aligned text, you can use the [fill/alignment](https://"
"doc.rust-lang.org/std/fmt/index.html#fillalignment) formatting operators. In "
"particular, notice how you can pad with different characters (here a `'/'`) "
"and how you can control alignment:"
msgstr ""
"Si quieres trazar texto alineado, puedes usar los operadores de formato "
"[relleno/alineaci√≥n](https://doc.rust-lang.org/std/fmt/index."
"html#fillalignment). En concreto, observa c√≥mo puedes rellenar con distintos "
"caracteres (en este caso, `'/'`) y c√≥mo puedes controlar la alineaci√≥n:"

#: src/exercises/day-3/simple-gui.md:147
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let width = 10;\n"
"    println!(\"left aligned:  |{:/<width$}|\", \"foo\");\n"
"    println!(\"centered:      |{:/^width$}|\", \"foo\");\n"
"    println!(\"right aligned: |{:/>width$}|\", \"foo\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-3/simple-gui.md:156
msgid ""
"Using such alignment tricks, you can for example produce output like this:"
msgstr ""
"Con estos trucos de alineaci√≥n puedes, por ejemplo, obtener resultados como "
"el siguiente:"

#: src/exercises/day-3/simple-gui.md:158
msgid ""
"```text\n"
"+--------------------------------+\n"
"|       Rust GUI Demo 1.23       |\n"
"+================================+\n"
"| This is a small text GUI demo. |\n"
"| +-----------+                  |\n"
"| | Click me! |                  |\n"
"| +-----------+                  |\n"
"+--------------------------------+\n"
"```"
msgstr ""

#: src/exercises/day-3/points-polygons.md:1
msgid "Polygon Struct"
msgstr "Estructura de pol√≠gono"

#: src/exercises/day-3/points-polygons.md:3
msgid ""
"We will create a `Polygon` struct which contain some points. Copy the code "
"below to <https://play.rust-lang.org/> and fill in the missing methods to "
"make the tests pass:"
msgstr ""
"Crearemos una estructura `Polygon` que contenga algunos puntos. Copia el "
"siguiente fragmento de c√≥digo en la p√°gina <https://play.rust-lang.org/> y "
"rellena los m√©todos que faltan para pasar las pruebas:"

#: src/exercises/day-3/points-polygons.md:7
msgid ""
"```rust\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub struct Point {\n"
"    // add fields\n"
"}\n"
"\n"
"impl Point {\n"
"    // add methods\n"
"}\n"
"\n"
"pub struct Polygon {\n"
"    // add fields\n"
"}\n"
"\n"
"impl Polygon {\n"
"    // add methods\n"
"}\n"
"\n"
"pub struct Circle {\n"
"    // add fields\n"
"}\n"
"\n"
"impl Circle {\n"
"    // add methods\n"
"}\n"
"\n"
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    fn round_two_digits(x: f64) -> f64 {\n"
"        (x * 100.0).round() / 100.0\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_magnitude() {\n"
"        let p1 = Point::new(12, 13);\n"
"        assert_eq!(round_two_digits(p1.magnitude()), 17.69);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_dist() {\n"
"        let p1 = Point::new(10, 10);\n"
"        let p2 = Point::new(14, 13);\n"
"        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_add() {\n"
"        let p1 = Point::new(16, 16);\n"
"        let p2 = p1 + Point::new(-4, 3);\n"
"        assert_eq!(p2, Point::new(12, 19));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_left_most_point() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"        assert_eq!(poly.left_most_point(), Some(p1));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_iter() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"\n"
"        let points = poly.iter().cloned().collect::<Vec<_>>();\n"
"        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimeter)\n"
"            .map(round_two_digits)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}\n"
"\n"
"#[allow(dead_code)]\n"
"fn main() {}\n"
"```"
msgstr ""

#: src/exercises/day-3/points-polygons.md:117
msgid ""
"Since the method signatures are missing from the problem statements, the key "
"part of the exercise is to specify those correctly. You don't have to modify "
"the tests."
msgstr ""
"Dado que faltan las firmas de los m√©todos en las instrucciones del problema, "
"la parte clave del ejercicio consiste en especificarlas correctamente. No "
"tienes que modificar las pruebas."

#: src/exercises/day-3/points-polygons.md:120
msgid "Other interesting parts of the exercise:"
msgstr "Otras partes interesantes del ejercicio:"

#: src/exercises/day-3/points-polygons.md:122
msgid ""
"Derive a `Copy` trait for some structs, as in tests the methods sometimes "
"don't borrow their arguments."
msgstr ""
"Deriva un trait `Copy` en algunas estructuras, ya que, en las pruebas, los "
"m√©todos a veces no toman prestados sus argumentos."

#: src/exercises/day-3/points-polygons.md:123
msgid ""
"Discover that `Add` trait must be implemented for two objects to be addable "
"via \"+\". Note that we do not discuss generics until Day 3."
msgstr ""
"Descubrir que hay que implementar el trait `Add` para que se puedan a√±adir "
"dos objetos mediante \"+\". Ten en cuenta que no hablaremos de los gen√©ricos "
"hasta el d√≠a 3."

#: src/error-handling.md:3
msgid "Error handling in Rust is done using explicit control flow:"
msgstr ""
"La gesti√≥n de errores en Rust se realiza mediante un flujo de control "
"expl√≠cito:"

#: src/error-handling.md:5
msgid "Functions that can have errors list this in their return type,"
msgstr ""
"Las funciones que pueden tener errores lo indican en su tipo de resultado "
"devuelto."

#: src/error-handling.md:6
msgid "There are no exceptions."
msgstr "No hay excepciones."

#: src/error-handling/panics.md:3
msgid "Rust will trigger a panic if a fatal error happens at runtime:"
msgstr "Rust activar√° un _panic_ si se produce un error grave en _runtime_:"

#: src/error-handling/panics.md:5
msgid ""
"```rust,editable,should_panic\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    println!(\"v[100]: {}\", v[100]);\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/panics.md:12
msgid "Panics are for unrecoverable and unexpected errors."
msgstr "Los _panics_ se usan para errores irrecuperables e inesperados."

#: src/error-handling/panics.md:13
msgid "Panics are symptoms of bugs in the program."
msgstr "Los _panics_ son un s√≠ntoma de que hay fallos en el programa."

#: src/error-handling/panics.md:14
msgid ""
"Use non-panicking APIs (such as `Vec::get`) if crashing is not acceptable."
msgstr ""
"Utiliza API que no activen _panics_ (como `Vec::get`) si no se admiten "
"fallos."

#: src/error-handling/panic-unwind.md:1
msgid "Catching the Stack Unwinding"
msgstr "Capturar el Desenrrollado de la _Stack_"

#: src/error-handling/panic-unwind.md:3
msgid ""
"By default, a panic will cause the stack to unwind. The unwinding can be "
"caught:"
msgstr ""
"De forma predeterminada, el _panic_ har√° que la _stack_ se desenrolle. El "
"proceso de desenrrollado se puede detectar:"

#: src/error-handling/panic-unwind.md:5
msgid ""
"```rust,editable\n"
"use std::panic;\n"
"\n"
"fn main() {\n"
"    let result = panic::catch_unwind(|| {\n"
"        println!(\"hello!\");\n"
"    });\n"
"    assert!(result.is_ok());\n"
"    \n"
"    let result = panic::catch_unwind(|| {\n"
"        panic!(\"oh no!\");\n"
"    });\n"
"    assert!(result.is_err());\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/panic-unwind.md:21
msgid ""
"This can be useful in servers which should keep running even if a single "
"request crashes."
msgstr ""
"Esto puede ser √∫til en los servidores que deben seguir ejecut√°ndose aunque "
"una sola solicitud falle."

#: src/error-handling/panic-unwind.md:23
msgid "This does not work if `panic = 'abort'` is set in your `Cargo.toml`."
msgstr "No funciona si `panic = 'abort'` est√° definido en `Cargo.toml`."

#: src/error-handling/result.md:1
msgid "Structured Error Handling with `Result`"
msgstr "Gesti√≥n Estructurada de Errores con `Result`"

#: src/error-handling/result.md:3
msgid ""
"We have already seen the `Result` enum. This is used pervasively when errors "
"are expected as part of normal operation:"
msgstr ""
"Ya hemos visto la _enum_ `Result`. Se utiliza normalmente cuando se esperan "
"errores como parte del funcionamiento normal:"

#: src/error-handling/result.md:6
msgid ""
"```rust,editable\n"
"use std::fs;\n"
"use std::io::Read;\n"
"\n"
"fn main() {\n"
"    let file = fs::File::open(\"diary.txt\");\n"
"    match file {\n"
"        Ok(mut file) => {\n"
"            let mut contents = String::new();\n"
"            file.read_to_string(&mut contents);\n"
"            println!(\"Dear diary: {contents}\");\n"
"        },\n"
"        Err(err) => {\n"
"            println!(\"The diary could not be opened: {err}\");\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/result.md:27
msgid ""
"As with `Option`, the successful value sits inside of `Result`, forcing the "
"developer to explicitly extract it. This encourages error checking. In the "
"case where an error should never happen, `unwrap()` or `expect()` can be "
"called, and this is a signal of the developer intent too."
msgstr ""
"Al igual que con `Option`, el valor correcto se encuentra dentro de "
"`Result`, lo que obliga al desarrollador a extraerlo de forma expl√≠cita. "
"Esto fomenta la comprobaci√≥n de errores. En el caso de que nunca se produzca "
"un error, se puede llamar a `unwrap()` o a `expect()`, y esto tambi√©n es una "
"se√±al de la intenci√≥n del desarrollador."

#: src/error-handling/result.md:30
msgid ""
"`Result` documentation is a recommended read. Not during the course, but it "
"is worth mentioning.  It contains a lot of convenience methods and functions "
"that help functional-style programming. "
msgstr ""
"La documentaci√≥n sobre `Result` es una lectura recomendada. Aunque no se vea "
"durante este curso, merece la pena mencinarlo.  Contiene muchos m√©todos y "
"funciones pr√°cticos que ayudan a seguir una programaci√≥n funcional. "

#: src/error-handling/try-operator.md:1
msgid "Propagating Errors with `?`"
msgstr "Propagar errores con `?`"

#: src/error-handling/try-operator.md:3
msgid ""
"The try-operator `?` is used to return errors to the caller. It lets you "
"turn the common"
msgstr ""
"El operador try `?` se utiliza para devolver errores al llamador. Te permite "
"convertir"

#: src/error-handling/try-operator.md:6
msgid ""
"```rust,ignore\n"
"match some_expression {\n"
"    Ok(value) => value,\n"
"    Err(err) => return Err(err),\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/try-operator.md:13
msgid "into the much simpler"
msgstr "en algo mucho m√°s sencillo:"

#: src/error-handling/try-operator.md:15
msgid ""
"```rust,ignore\n"
"some_expression?\n"
"```"
msgstr ""

#: src/error-handling/try-operator.md:19
msgid "We can use this to simplify our error handling code:"
msgstr "Podemos utilizarlo para simplificar el c√≥digo de gesti√≥n de errores:"

#: src/error-handling/try-operator.md:21
msgid ""
"```rust,editable\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"\n"
"fn read_username(path: &str) -> Result<String, io::Error> {\n"
"    let username_file_result = fs::File::open(path);\n"
"    let mut username_file = match username_file_result {\n"
"        Ok(file) => file,\n"
"        Err(err) => return Err(err),\n"
"    };\n"
"\n"
"    let mut username = String::new();\n"
"    match username_file.read_to_string(&mut username) {\n"
"        Ok(_) => Ok(username),\n"
"        Err(err) => Err(err),\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"alice\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"username or error: {username:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/try-operator.md:50
#: src/error-handling/converting-error-types-example.md:52
msgid "The `username` variable can be either `Ok(string)` or `Err(error)`."
msgstr "La variable `username` puede ser `Ok(string)` o `Err(error)`."

#: src/error-handling/try-operator.md:51
#: src/error-handling/converting-error-types-example.md:53
msgid ""
"Use the `fs::write` call to test out the different scenarios: no file, empty "
"file, file with username."
msgstr ""
"Utiliza la llamada a `fs::write` para probar las distintas situaciones: sin "
"archivo, archivo vac√≠o o archivo con nombre de usuario."

#: src/error-handling/try-operator.md:52
msgid ""
"The return type of the function has to be compatible with the nested "
"functions it calls. For instance, a function returning a `Result<T, Err>` "
"can only apply the `?` operator on a function returning a  `Result<AnyT, "
"Err>`. It cannot apply the `?` operator on a function returning an "
"`Option<AnyT>` or `Result<T, OtherErr>` unless `OtherErr` implements "
"`From<Err>`. Reciprocally, a function returning an `Option<T>` can only "
"apply the `?` operator  on a function returning an `Option<AnyT>`."
msgstr ""
"El tipo de resultado de la funci√≥n tiene que ser compatible con las "
"funciones anidadas que llama. Por ejemplo, una funci√≥n que devuelve un "
"`Result<T, Err>` solo puede aplicar el operador `?` a una funci√≥n que "
"devuelve un `Result<AnyT, Err>`. No puede aplicar el operador `?` a una "
"funci√≥n que devuelve un `Option<AnyT>` o `Result<T, OtherErr>` a menos que "
"`OtherErr` implemente `From<Err>`. Rec√≠procamente, una funci√≥n que devuelve "
"un `Option<T>` solo puede aplicar el operador `?` a una funci√≥n que devuelve "
"un `Option<AnyT>`."

#: src/error-handling/try-operator.md:57
msgid ""
"You can convert incompatible types into one another with the different "
"`Option` and `Result` methods  such as `Option::ok_or`, `Result::ok`, "
"`Result::err`."
msgstr ""
"Puedes convertir tipos incompatibles entre s√≠ con los distintos m√©todos de "
"`Option` y `Result` como `Option::ok_or`, `Result::ok`, `Result::err`."

#: src/error-handling/converting-error-types.md:3
msgid ""
"The effective expansion of `?` is a little more complicated than previously "
"indicated:"
msgstr ""
"La expansi√≥n efectiva de `?` es un poco m√°s complicada de lo que se ha "
"indicado anteriormente:"

#: src/error-handling/converting-error-types.md:5
msgid ""
"```rust,ignore\n"
"expression?\n"
"```"
msgstr ""

#: src/error-handling/converting-error-types.md:9
msgid "works the same as"
msgstr "funciona igual que"

#: src/error-handling/converting-error-types.md:11
msgid ""
"```rust,ignore\n"
"match expression {\n"
"    Ok(value) => value,\n"
"    Err(err)  => return Err(From::from(err)),\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/converting-error-types.md:18
msgid ""
"The `From::from` call here means we attempt to convert the error type to the "
"type returned by the function:"
msgstr ""
"Aqu√≠ la llamada a `From::from` significa que intentamos convertir el tipo de "
"error al tipo que devuelve la funci√≥n:"

#: src/error-handling/converting-error-types-example.md:3
msgid ""
"```rust,editable\n"
"use std::error::Error;\n"
"use std::fmt::{self, Display, Formatter};\n"
"use std::fs::{self, File};\n"
"use std::io::{self, Read};\n"
"\n"
"#[derive(Debug)]\n"
"enum ReadUsernameError {\n"
"    IoError(io::Error),\n"
"    EmptyUsername(String),\n"
"}\n"
"\n"
"impl Error for ReadUsernameError {}\n"
"\n"
"impl Display for ReadUsernameError {\n"
"    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n"
"        match self {\n"
"            Self::IoError(e) => write!(f, \"IO error: {e}\"),\n"
"            Self::EmptyUsername(filename) => write!(f, \"Found no username "
"in {filename}\"),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl From<io::Error> for ReadUsernameError {\n"
"    fn from(err: io::Error) -> ReadUsernameError {\n"
"        ReadUsernameError::IoError(err)\n"
"    }\n"
"}\n"
"\n"
"fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
"    let mut username = String::with_capacity(100);\n"
"    File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(ReadUsernameError::EmptyUsername(String::from(path)));\n"
"    }\n"
"    Ok(username)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"username or error: {username:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/converting-error-types-example.md:55
msgid ""
"It is good practice for all error types that don't need to be `no_std` to "
"implement `std::error::Error`, which requires `Debug` and `Display`. The "
"`Error` crate for `core` is only available in [nightly](https://github.com/"
"rust-lang/rust/issues/103765), so not fully `no_std` compatible yet."
msgstr ""
"Se recomienda que todos los tipos de errores que no necesitan ser `no_std` "
"implementen `std::error::Error`, que requiere `Debug` y `Display`. El crate "
"`Error` para `core` solo est√° disponible en [nightly](https://github.com/"
"rust-lang/rust/issues/103765), por lo que a√∫n no es totalmente compatible "
"con `no_std`."

#: src/error-handling/converting-error-types-example.md:57
msgid ""
"It's generally helpful for them to implement `Clone` and `Eq` too where "
"possible, to make life easier for tests and consumers of your library. In "
"this case we can't easily do so, because `io::Error` doesn't implement them."
msgstr ""
"Por lo general, es √∫til que tambi√©n implementen `Clone` y `Eq`, siempre que "
"sea posible, para facilitar las cosas a las pruebas y a los consumidores de "
"tu biblioteca. En este caso, no podemos hacerlo de forma sencilla porque "
"`io::Error` no los implementa."

#: src/error-handling/deriving-error-enums.md:3
msgid ""
"The [thiserror](https://docs.rs/thiserror/) crate is a popular way to create "
"an error enum like we did on the previous page:"
msgstr ""
"Uno de los m√©todos m√°s populares para crear una _enum_ (enumeraci√≥n) de "
"errores es el crate [thiserror](https://docs.rs/thiserror/), como hicimos en "
"la p√°gina anterior:"

#: src/error-handling/deriving-error-enums.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use thiserror::Error;\n"
"\n"
"#[derive(Debug, Error)]\n"
"enum ReadUsernameError {\n"
"    #[error(\"Could not read: {0}\")]\n"
"    IoError(#[from] io::Error),\n"
"    #[error(\"Found no username in {0}\")]\n"
"    EmptyUsername(String),\n"
"}\n"
"\n"
"fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
"    let mut username = String::new();\n"
"    fs::File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(ReadUsernameError::EmptyUsername(String::from(path)));\n"
"    }\n"
"    Ok(username)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/deriving-error-enums.md:39
msgid ""
"`thiserror`'s derive macro automatically implements `std::error::Error`, and "
"optionally `Display` (if the `#[error(...)]` attributes are provided) and "
"`From` (if the `#[from]` attribute is added). It also works for structs."
msgstr ""
"La macro de derivaci√≥n de `thiserror` implementa autom√°ticamente `std::"
"error::Error` y, de forma opcional, `Display` (si se proporcionan los "
"atributos `#[error(...)]`) y `From` (si se a√±ade el atributo `#[from]`). "
"Tambi√©n funciona con estructuras."

#: src/error-handling/deriving-error-enums.md:43
msgid "It doesn't affect your public API, which makes it good for libraries."
msgstr ""
"No afecta a tu API p√∫blica, lo que la hace id√≥nea para las bibliotecas."

#: src/error-handling/dynamic-errors.md:3
msgid ""
"Sometimes we want to allow any type of error to be returned without writing "
"our own enum covering all the different possibilities. `std::error::Error` "
"makes this easy."
msgstr ""
"A veces, queremos permitir que se devuelva cualquier tipo de error sin "
"escribir nuestra propia _enum_ que cubra todas las posibilidades. `std::"
"error::Error` facilita este proceso."

#: src/error-handling/dynamic-errors.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use std::fs;\n"
"use std::io::Read;\n"
"use thiserror::Error;\n"
"use std::error::Error;\n"
"\n"
"#[derive(Clone, Debug, Eq, Error, PartialEq)]\n"
"#[error(\"Found no username in {0}\")]\n"
"struct EmptyUsernameError(String);\n"
"\n"
"fn read_username(path: &str) -> Result<String, Box<dyn Error>> {\n"
"    let mut username = String::new();\n"
"    fs::File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(EmptyUsernameError(String::from(path)).into());\n"
"    }\n"
"    Ok(username)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/dynamic-errors.md:36
msgid ""
"This saves on code, but gives up the ability to cleanly handle different "
"error cases differently in the program. As such it's generally not a good "
"idea to use `Box<dyn Error>` in the public API of a library, but it can be a "
"good option in a program where you just want to display the error message "
"somewhere."
msgstr ""
"Esto permite ahorrar c√≥digo, pero no da la posibilidad de gestionar "
"eficazmente los distintos casos de error en el programa. Por lo general, no "
"es una buena idea utilizar `Box<dyn Error>` en la API p√∫blica de una "
"biblioteca, pero puede ser una buena opci√≥n en un programa en el que solo "
"quieras mostrar el mensaje de error en alguna parte."

#: src/error-handling/error-contexts.md:3
msgid ""
"The widely used [anyhow](https://docs.rs/anyhow/) crate can help you add "
"contextual information to your errors and allows you to have fewer custom "
"error types:"
msgstr ""
"El crate [anyhow](https://docs.rs/anyhow/), que se utiliza con frecuencia, "
"puede ayudar a a√±adir informaci√≥n contextual a los errores y permite tener "
"menos tipos de errores personalizados:"

#: src/error-handling/error-contexts.md:7
msgid ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use anyhow::{Context, Result, bail};\n"
"\n"
"fn read_username(path: &str) -> Result<String> {\n"
"    let mut username = String::with_capacity(100);\n"
"    fs::File::open(path)\n"
"        .with_context(|| format!(\"Failed to open {path}\"))?\n"
"        .read_to_string(&mut username)\n"
"        .context(\"Failed to read\")?;\n"
"    if username.is_empty() {\n"
"        bail!(\"Found no username in {path}\");\n"
"    }\n"
"    Ok(username)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err:?}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/error-contexts.md:35
msgid "`anyhow::Result<V>` is a type alias for `Result<V, anyhow::Error>`."
msgstr ""
"`anyhow::Result<V>` es un alias de tipo para `Result<V, anyhow::Error>`."

#: src/error-handling/error-contexts.md:36
msgid ""
"`anyhow::Error` is essentially a wrapper around `Box<dyn Error>`. As such "
"it's again generally not a good choice for the public API of a library, but "
"is widely used in applications."
msgstr ""
"`anyhow::Error` es b√°sicamente un envoltorio alrededor de `Box<dyn Error>`. "
"Como tal, no suele ser una buena elecci√≥n para la API p√∫blica de una "
"biblioteca, pero se usa con frecuencia en aplicaciones."

#: src/error-handling/error-contexts.md:38
msgid ""
"Actual error type inside of it can be extracted for examination if necessary."
msgstr ""
"El tipo de error real que contiene se puede extraer para analizarlo si es "
"necesario."

#: src/error-handling/error-contexts.md:39
msgid ""
"Functionality provided by `anyhow::Result<T>` may be familiar to Go "
"developers, as it provides similar usage patterns and ergonomics to `(T, "
"error)` from Go."
msgstr ""
"La funcionalidad proporcionada por `anyhow::Result<T>` puede resultar "
"familiar a los desarrolladores de Go, ya que ofrece patrones de uso y "
"ergonom√≠a similares a `(T, error)` de Go."

#: src/testing.md:3
msgid "Rust and Cargo come with a simple unit test framework:"
msgstr "Rust y Cargo incluyen un sencillo framework para pruebas unitarias:"

#: src/testing.md:5
msgid "Unit tests are supported throughout your code."
msgstr "Las pruebas unitarias se admiten en todo el c√≥digo."

#: src/testing.md:7
msgid "Integration tests are supported via the `tests/` directory."
msgstr ""
"Las pruebas de integraci√≥n se admiten a trav√©s del directorio `tests/`."

#: src/testing/unit-tests.md:3
msgid "Mark unit tests with `#[test]`:"
msgstr "Marca pruebas unitarias con `#[test]`:"

#: src/testing/unit-tests.md:5
msgid ""
"```rust,editable,ignore\n"
"fn first_word(text: &str) -> &str {\n"
"    match text.find(' ') {\n"
"        Some(idx) => &text[..idx],\n"
"        None => &text,\n"
"    }\n"
"}\n"
"\n"
"#[test]\n"
"fn test_empty() {\n"
"    assert_eq!(first_word(\"\"), \"\");\n"
"}\n"
"\n"
"#[test]\n"
"fn test_single_word() {\n"
"    assert_eq!(first_word(\"Hello\"), \"Hello\");\n"
"}\n"
"\n"
"#[test]\n"
"fn test_multiple_words() {\n"
"    assert_eq!(first_word(\"Hello World\"), \"Hello\");\n"
"}\n"
"```"
msgstr ""

#: src/testing/unit-tests.md:29
msgid "Use `cargo test` to find and run the unit tests."
msgstr "Busca y ejecuta las pruebas unitarias con `cargo test`."

#: src/testing/test-modules.md:3
msgid ""
"Unit tests are often put in a nested module (run tests on the [Playground]"
"(https://play.rust-lang.org/)):"
msgstr ""
"Las pruebas unitarias se suelen incluir en un m√≥dulo anidado (ejecuta las "
"pruebas en el [_Playground_](https://play.rust-lang.org/)):"

#: src/testing/test-modules.md:6
msgid ""
"```rust,editable\n"
"fn helper(a: &str, b: &str) -> String {\n"
"    format!(\"{a} {b}\")\n"
"}\n"
"\n"
"pub fn main() {\n"
"    println!(\"{}\", helper(\"Hello\", \"World\"));\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    #[test]\n"
"    fn test_helper() {\n"
"        assert_eq!(helper(\"foo\", \"bar\"), \"foo bar\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/testing/test-modules.md:26
msgid "This lets you unit test private helpers."
msgstr "Esto permite realizar pruebas unitarias de los ayudantes privados."

#: src/testing/test-modules.md:27
msgid "The `#[cfg(test)]` attribute is only active when you run `cargo test`."
msgstr ""
"El atributo `#[cfg(test)]` solo est√° activo cuando se ejecuta `cargo test`."

#: src/testing/doc-tests.md:3
msgid "Rust has built-in support for documentation tests:"
msgstr "Rust cuenta con asistencia integrada para pruebas de documentaci√≥n:"

#: src/testing/doc-tests.md:5
msgid ""
"```rust\n"
"/// Shortens a string to the given length.\n"
"///\n"
"/// ```\n"
"/// use playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"
"pub fn shorten_string(s: &str, length: usize) -> &str {\n"
"    &s[..std::cmp::min(length, s.len())]\n"
"}\n"
"```"
msgstr ""

#: src/testing/doc-tests.md:18
msgid "Code blocks in `///` comments are automatically seen as Rust code."
msgstr ""
"Los bloques de c√≥digo en los comentarios `///` se ven autom√°ticamente como "
"c√≥digo de Rust."

#: src/testing/doc-tests.md:19
msgid "The code will be compiled and executed as part of `cargo test`."
msgstr "El c√≥digo se compilar√° y ejecutar√° como parte de `cargo test`."

#: src/testing/doc-tests.md:20
msgid ""
"Test the above code on the [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."
msgstr ""
"Prueba el c√≥digo anterior en el [playground de Rust](https://play.rust-lang."
"org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."

#: src/testing/integration-tests.md:3
msgid "If you want to test your library as a client, use an integration test."
msgstr ""
"Si quieres probar tu biblioteca como cliente, haz una prueba de integraci√≥n."

#: src/testing/integration-tests.md:5
msgid "Create a `.rs` file under `tests/`:"
msgstr "Crea un archivo `.rs` en `tests/`:"

#: src/testing/integration-tests.md:7
msgid ""
"```rust,ignore\n"
"use my_library::init;\n"
"\n"
"#[test]\n"
"fn test_init() {\n"
"    assert!(init().is_ok());\n"
"}\n"
"```"
msgstr ""

#: src/testing/integration-tests.md:16
msgid "These tests only have access to the public API of your crate."
msgstr "Estas pruebas solo tienen acceso a la API p√∫blica de tu crate."

#: src/testing/useful-crates.md:1
msgid "Useful crates for writing tests"
msgstr "Crates √∫tiles para escribir pruebas"

#: src/testing/useful-crates.md:3
msgid "Rust comes with only basic support for writing tests."
msgstr "Rust solo incluye asistencia b√°sica para las pruebas de escritura."

#: src/testing/useful-crates.md:5
msgid "Here are some additional crates which we recommend for writing tests:"
msgstr ""
"A continuaci√≥n, se indican algunos crates adicionales que recomendamos para "
"escribir pruebas:"

#: src/testing/useful-crates.md:7
msgid ""
"[googletest](https://docs.rs/googletest): Comprehensive test assertion "
"library in the tradition of GoogleTest for C++."
msgstr ""
"[googletest](https://docs.rs/googletest): biblioteca completa de aserci√≥n de "
"pruebas en la tradici√≥n de GoogleTest para C++."

#: src/testing/useful-crates.md:8
msgid "[proptest](https://docs.rs/proptest): Property-based testing for Rust."
msgstr ""
"[proptest](https://docs.rs/proptest): pruebas basadas en propiedades para "
"Rust."

#: src/testing/useful-crates.md:9
msgid ""
"[rstest](https://docs.rs/rstest): Support for fixtures and parameterised "
"tests."
msgstr ""
"[rstest](https://docs.rs/rstest): asistencia para _fixtures_ y pruebas "
"parametrizadas."

#: src/unsafe.md:3
msgid "The Rust language has two parts:"
msgstr "El lenguaje Rust tiene dos partes:"

#: src/unsafe.md:5
msgid "**Safe Rust:** memory safe, no undefined behavior possible."
msgstr ""
"**_Safe_ Rust:** memoria segura, sin posibilidad de comportamiento "
"indefinido."

#: src/unsafe.md:6
msgid ""
"**Unsafe Rust:** can trigger undefined behavior if preconditions are "
"violated."
msgstr ""
"**_Unsafe_ Rust:** puede activar un comportamiento no definido si se "
"infringen las condiciones previas."

#: src/unsafe.md:8
msgid ""
"We will be seeing mostly safe Rust in this course, but it's important to "
"know what Unsafe Rust is."
msgstr ""
"En este curso, casi todo lo que veremos es _Safe_ Rust, aunque es importante "
"saber qu√© es _Unsafe_ Rust."

#: src/unsafe.md:11
msgid ""
"Unsafe code is usually small and isolated, and its correctness should be "
"carefully documented. It is usually wrapped in a safe abstraction layer."
msgstr ""
"Por lo general, el c√≥digo inseguro es peque√±o y est√° aislado, y su "
"correcci√≥n debe estar bien documentada. Suele estar envuelto en una capa de "
"abstracci√≥n segura."

#: src/unsafe.md:14
msgid "Unsafe Rust gives you access to five new capabilities:"
msgstr "Rust inseguro te permite acceder a cinco nuevas funciones:"

#: src/unsafe.md:16
msgid "Dereference raw pointers."
msgstr "Desreferenciar punteros sin formato."

#: src/unsafe.md:17
msgid "Access or modify mutable static variables."
msgstr "Acceder o modificar variables est√°ticas mutables."

#: src/unsafe.md:18
msgid "Access `union` fields."
msgstr "Acceder a los campos `union`."

#: src/unsafe.md:19
msgid "Call `unsafe` functions, including `extern` functions."
msgstr "Llamar a funciones `unsafe`, incluidas las funciones `extern`."

#: src/unsafe.md:20
msgid "Implement `unsafe` traits."
msgstr "Implementar traits `unsafe`."

#: src/unsafe.md:22
msgid ""
"We will briefly cover unsafe capabilities next. For full details, please see "
"[Chapter 19.1 in the Rust Book](https://doc.rust-lang.org/book/ch19-01-"
"unsafe-rust.html) and the [Rustonomicon](https://doc.rust-lang.org/nomicon/)."
msgstr ""
"A continuaci√≥n, hablaremos brevemente sobre las funciones que no son "
"seguras. Para obtener m√°s informaci√≥n, consulta el [cap√≠tulo 19.1 del Libro "
"de Rust](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html) y el "
"documento [Rustonomicon](https://doc.rust-lang.org/nomicon/)."

#: src/unsafe.md:28
msgid ""
"Unsafe Rust does not mean the code is incorrect. It means that developers "
"have turned off the compiler safety features and have to write correct code "
"by themselves. It means the compiler no longer enforces Rust's memory-safety "
"rules."
msgstr ""
"_Unsafe_ Rust no significa que el c√≥digo sea incorrecto. Significa que los "
"desarrolladores han desactivado las funciones de seguridad del compilador y "
"que tienen que escribir el c√≥digo correcto por su cuenta. Significa que el "
"compilador ya no aplica las reglas de seguridad de memoria de Rust."

#: src/unsafe/raw-pointers.md:3
msgid "Creating pointers is safe, but dereferencing them requires `unsafe`:"
msgstr ""
"La creaci√≥n de punteros es un proceso seguro, pero para anular las "
"referencias, es necesario utilizar `unsafe`:"

#: src/unsafe/raw-pointers.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut num = 5;\n"
"\n"
"    let r1 = &mut num as *mut i32;\n"
"    let r2 = r1 as *const i32;\n"
"\n"
"    // Safe because r1 and r2 were obtained from references and so are\n"
"    // guaranteed to be non-null and properly aligned, the objects "
"underlying\n"
"    // the references from which they were obtained are live throughout the\n"
"    // whole unsafe block, and they are not accessed either through the\n"
"    // references or concurrently through any other pointers.\n"
"    unsafe {\n"
"        println!(\"r1 is: {}\", *r1);\n"
"        *r1 = 10;\n"
"        println!(\"r2 is: {}\", *r2);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/raw-pointers.md:27
msgid ""
"It is good practice (and required by the Android Rust style guide) to write "
"a comment for each `unsafe` block explaining how the code inside it "
"satisfies the safety requirements of the unsafe operations it is doing."
msgstr ""
"Se recomienda (y es obligatorio en la gu√≠a de estilo Rust de Android) "
"escribir un comentario para cada bloque `unsafe` explicando c√≥mo el c√≥digo "
"que contiene cumple los requisitos de seguridad de las operaciones inseguras "
"que realiza."

#: src/unsafe/raw-pointers.md:31
msgid ""
"In the case of pointer dereferences, this means that the pointers must be "
"[_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), i.e.:"
msgstr ""
"En el caso de la desreferenciaci√≥n de punteros, significa que los punteros "
"deben ser [_v√°lidos_](https://doc.rust-lang.org/std/ptr/index.html#safety), "
"por ejemplo:"

#: src/unsafe/raw-pointers.md:34
msgid "The pointer must be non-null."
msgstr "El puntero no puede ser nulo."

#: src/unsafe/raw-pointers.md:35
msgid ""
"The pointer must be _dereferenceable_ (within the bounds of a single "
"allocated object)."
msgstr ""
"El puntero debe ser _desreferenciable_ (dentro de los l√≠mites de un √∫nico "
"objeto asignado)."

#: src/unsafe/raw-pointers.md:36
msgid "The object must not have been deallocated."
msgstr "El objeto no debe haberse desasignado."

#: src/unsafe/raw-pointers.md:37
msgid "There must not be concurrent accesses to the same location."
msgstr "No debe haber accesos simult√°neos a la misma ubicaci√≥n."

#: src/unsafe/raw-pointers.md:38
msgid ""
"If the pointer was obtained by casting a reference, the underlying object "
"must be live and no reference may be used to access the memory."
msgstr ""
"Si el puntero se ha obtenido enviando una referencia, el objeto subyacente "
"debe estar activo y no puede utilizarse ninguna referencia para acceder a la "
"memoria."

#: src/unsafe/raw-pointers.md:41
msgid "In most cases the pointer must also be properly aligned."
msgstr ""
"En la mayor√≠a de los casos, el puntero tambi√©n debe estar alineado "
"adecuadamente."

#: src/unsafe/mutable-static-variables.md:3
msgid "It is safe to read an immutable static variable:"
msgstr "Es seguro leer una variable est√°tica inmutable:"

#: src/unsafe/mutable-static-variables.md:5
msgid ""
"```rust,editable\n"
"static HELLO_WORLD: &str = \"Hello, world!\";\n"
"\n"
"fn main() {\n"
"    println!(\"HELLO_WORLD: {HELLO_WORLD}\");\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/mutable-static-variables.md:13
msgid ""
"However, since data races can occur, it is unsafe to read and write mutable "
"static variables:"
msgstr ""
"Sin embargo, dado que pueden producirse carreras de datos, no es seguro leer "
"y escribir variables est√°ticas mutables:"

#: src/unsafe/mutable-static-variables.md:16
msgid ""
"```rust,editable\n"
"static mut COUNTER: u32 = 0;\n"
"\n"
"fn add_to_counter(inc: u32) {\n"
"    unsafe { COUNTER += inc; }  // Potential data race!\n"
"}\n"
"\n"
"fn main() {\n"
"    add_to_counter(42);\n"
"\n"
"    unsafe { println!(\"COUNTER: {COUNTER}\"); }  // Potential data race!\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/mutable-static-variables.md:32
msgid ""
"Using a mutable static is generally a bad idea, but there are some cases "
"where it might make sense in low-level `no_std` code, such as implementing a "
"heap allocator or working with some C APIs."
msgstr ""
"No suele ser buena idea usar una variable est√°tica mutable, pero en algunos "
"casos puede encajar en c√≥digo `no_std` de bajo nivel, como implementar una "
"asignaci√≥n de _heap_ o trabajar con algunas APIs C."

#: src/unsafe/unions.md:3
msgid "Unions are like enums, but you need to track the active field yourself:"
msgstr ""
"Las uniones son como _enums_ (enumeraciones), pero eres t√∫ quien debe hacer "
"el seguimiento del campo activo:"

#: src/unsafe/unions.md:5
msgid ""
"```rust,editable\n"
"#[repr(C)]\n"
"union MyUnion {\n"
"    i: u8,\n"
"    b: bool,\n"
"}\n"
"\n"
"fn main() {\n"
"    let u = MyUnion { i: 42 };\n"
"    println!(\"int: {}\", unsafe { u.i });\n"
"    println!(\"bool: {}\", unsafe { u.b });  // Undefined behavior!\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/unions.md:21
msgid ""
"Unions are very rarely needed in Rust as you can usually use an enum. They "
"are occasionally needed for interacting with C library APIs."
msgstr ""
"Las uniones raramente son necesarias en Rust, ya que se suele utilizar una "
"_enum_. A veces se necesitan para interactuar con APIs de biblioteca C."

#: src/unsafe/unions.md:24
msgid ""
"If you just want to reinterpret bytes as a different type, you probably want "
"[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn."
"transmute.html) or a safe wrapper such as the [`zerocopy`](https://crates.io/"
"crates/zerocopy) crate."
msgstr ""
"Si solo quieres reinterpretar los bytes como otro tipo, probablemente te "
"interese [`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn."
"transmute.html) o una envoltura segura, como el crate [`zerocopy`](https://"
"crates.io/crates/zerocopy)."

#: src/unsafe/calling-unsafe-functions.md:3
msgid ""
"A function or method can be marked `unsafe` if it has extra preconditions "
"you must uphold to avoid undefined behaviour:"
msgstr ""
"Una funci√≥n o m√©todo se puede marcar como `unsafe` si tiene condiciones "
"previas adicionales que debes mantener para evitar un comportamiento "
"indefinido:"

#: src/unsafe/calling-unsafe-functions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let emojis = \"üóª‚ààüåè\";\n"
"\n"
"    // Safe because the indices are in the correct order, within the bounds "
"of\n"
"    // the string slice, and lie on UTF-8 sequence boundaries.\n"
"    unsafe {\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(0..4));\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(4..7));\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(7..11));\n"
"    }\n"
"\n"
"    println!(\"char count: {}\", count_chars(unsafe { emojis."
"get_unchecked(0..7) }));\n"
"\n"
"    // Not upholding the UTF-8 encoding requirement breaks memory safety!\n"
"    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
"    // println!(\"char count: {}\", count_chars(unsafe { emojis."
"get_unchecked(0..3) }));\n"
"}\n"
"\n"
"fn count_chars(s: &str) -> usize {\n"
"    s.chars().map(|_| 1).sum()\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:3
msgid ""
"You can mark your own functions as `unsafe` if they require particular "
"conditions to avoid undefined behaviour."
msgstr ""
"Puedes marcar tus propias funciones como `unsafe` si requieren condiciones "
"concretas para evitar un comportamiento indefinido."

#: src/unsafe/writing-unsafe-functions.md:6
msgid ""
"```rust,editable\n"
"/// Swaps the values pointed to by the given pointers.\n"
"///\n"
"/// # Safety\n"
"///\n"
"/// The pointers must be valid and properly aligned.\n"
"unsafe fn swap(a: *mut u8, b: *mut u8) {\n"
"    let temp = *a;\n"
"    *a = *b;\n"
"    *b = temp;\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut a = 42;\n"
"    let mut b = 66;\n"
"\n"
"    // Safe because ...\n"
"    unsafe {\n"
"        swap(&mut a, &mut b);\n"
"    }\n"
"\n"
"    println!(\"a = {}, b = {}\", a, b);\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:33
msgid ""
"We wouldn't actually use pointers for this because it can be done safely "
"with references."
msgstr ""
"En realidad, no usar√≠amos punteros para este caso porque se puede hacer de "
"forma segura con referencias."

#: src/unsafe/writing-unsafe-functions.md:35
msgid ""
"Note that unsafe code is allowed within an unsafe function without an "
"`unsafe` block. We can prohibit this with `#[deny(unsafe_op_in_unsafe_fn)]`. "
"Try adding it and see what happens."
msgstr ""
"Ten en cuenta que el c√≥digo inseguro se admite en una funci√≥n insegura sin "
"un bloque `unsafe`. Podemos prohibirlo con "
"`#[deny(unsafe_op_in_unsafe_fn)]`. Prueba a a√±adirlo para ver qu√© ocurre."

#: src/unsafe/extern-functions.md:1
msgid "Calling External Code"
msgstr "Llamar a c√≥digo externo"

#: src/unsafe/extern-functions.md:3
msgid ""
"Functions from other languages might violate the guarantees of Rust. Calling "
"them is thus unsafe:"
msgstr ""
"Es posible que las funciones de otros lenguajes infrinjan las garant√≠as de "
"Rust. Por lo tanto, no es seguro llamarlas:"

#: src/unsafe/extern-functions.md:6
msgid ""
"```rust,editable\n"
"extern \"C\" {\n"
"    fn abs(input: i32) -> i32;\n"
"}\n"
"\n"
"fn main() {\n"
"    unsafe {\n"
"        // Undefined behavior if abs misbehaves.\n"
"        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/extern-functions.md:21
msgid ""
"This is usually only a problem for extern functions which do things with "
"pointers which might violate Rust's memory model, but in general any C "
"function might have undefined behaviour under any arbitrary circumstances."
msgstr ""
"Esto solo suele suponer un problema para las funciones externas que hacen "
"cosas con punteros que pueden infringir el modelo de memoria de Rust pero, "
"en general, cualquier funci√≥n C puede tener un comportamiento indefinido "
"bajo cualquier circunstancia arbitraria."

#: src/unsafe/extern-functions.md:25
msgid ""
"The `\"C\"` in this example is the ABI; [other ABIs are available too]"
"(https://doc.rust-lang.org/reference/items/external-blocks.html)."
msgstr ""
"En este ejemplo, `\"C\"` es la ABI.; [tambi√©n hay otras ABI disponibles]"
"(https://doc.rust-lang.org/reference/items/external-blocks.html)."

#: src/unsafe/unsafe-traits.md:3
msgid ""
"Like with functions, you can mark a trait as `unsafe` if the implementation "
"must guarantee particular conditions to avoid undefined behaviour."
msgstr ""
"Al igual que con las funciones, puedes marcar un trait como `unsafe` si la "
"implementaci√≥n debe asegurar condiciones concretas para evitar un "
"comportamiento indefinido."

#: src/unsafe/unsafe-traits.md:6
msgid ""
"For example, the `zerocopy` crate has an unsafe trait that looks [something "
"like this](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html):"
msgstr ""
"Por ejemplo, el crate `zerocopy` tiene un trait inseguro, [que se parece a "
"esto](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html):"

#: src/unsafe/unsafe-traits.md:9
msgid ""
"```rust,editable\n"
"use std::mem::size_of_val;\n"
"use std::slice;\n"
"\n"
"/// ...\n"
"/// # Safety\n"
"/// The type must have a defined representation and no padding.\n"
"pub unsafe trait AsBytes {\n"
"    fn as_bytes(&self) -> &[u8] {\n"
"        unsafe {\n"
"            slice::from_raw_parts(self as *const Self as *const u8, "
"size_of_val(self))\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Safe because u32 has a defined representation and no padding.\n"
"unsafe impl AsBytes for u32 {}\n"
"```"
msgstr ""

#: src/unsafe/unsafe-traits.md:30
msgid ""
"There should be a `# Safety` section on the Rustdoc for the trait explaining "
"the requirements for the trait to be safely implemented."
msgstr ""
"Deber√≠a haber una secci√≥n `# Safety` en el Rustdoc para el trait explicando "
"los requisitos para que el trait pueda implementarse de forma segura."

#: src/unsafe/unsafe-traits.md:33
msgid ""
"The actual safety section for `AsBytes` is rather longer and more "
"complicated."
msgstr ""
"La secci√≥n de seguridad actual de `AsBytes` es bastante m√°s larga y "
"complicada."

#: src/unsafe/unsafe-traits.md:35
msgid "The built-in `Send` and `Sync` traits are unsafe."
msgstr "Los traits integrados `Send` y `Sync` no son seguros."

#: src/exercises/day-3/afternoon.md:1
msgid "Day 3: Afternoon Exercises"
msgstr "D√≠a 3: ejercicios de la tarde"

#: src/exercises/day-3/afternoon.md:3
msgid "Let us build a safe wrapper for reading directory content!"
msgstr ""
"Vamos a crear un envoltorio seguro para leer el contenido del directorio."

#: src/exercises/day-3/afternoon.md:5
msgid ""
"For this exercise, we suggest using a local dev environment instead of the "
"Playground. This will allow you to run your binary on your own machine."
msgstr ""
"Para este ejercicio, recomendamos utilizar un entorno de desarrollo local, "
"en lugar del playground. De este modo, podr√°s ejecutar tu binario en tu "
"propia m√°quina."

#: src/exercises/day-3/afternoon.md:8
msgid ""
"To get started, follow the [running locally](../../cargo/running-locally.md) "
"instructions."
msgstr ""
"Para empezar, sigue las instrucciones para [ejecutar a nivel local](../../"
"cargo/running-locally.md)."

#: src/exercises/day-3/afternoon.md:14
msgid ""
"After looking at the exercise, you can look at the [solution](solutions-"
"afternoon.md) provided."
msgstr ""
"Despu√©s de realizar el ejercicio, puedes consultar la [soluci√≥n](solutions-"
"afternoon.md) proporcionada."

#: src/exercises/day-3/safe-ffi-wrapper.md:3
msgid ""
"Rust has great support for calling functions through a _foreign function "
"interface_ (FFI). We will use this to build a safe wrapper for the `libc` "
"functions you would use from C to read the filenames of a directory."
msgstr ""
"Rust ofrece una gran asisencia para llamar a funciones a trav√©s de una "
"_interfaz de funci√≥n externa_ (FFI). Usaremos esto para crear un envoltorio "
"seguro para las funciones `libc` que usar√≠as desde C para leer los nombres "
"de archivo de un directorio."

#: src/exercises/day-3/safe-ffi-wrapper.md:7
msgid "You will want to consult the manual pages:"
msgstr "Consulta las p√°ginas del manual:"

#: src/exercises/day-3/safe-ffi-wrapper.md:9
msgid "[`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)"
msgstr "[`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)"

#: src/exercises/day-3/safe-ffi-wrapper.md:10
msgid "[`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)"
msgstr "[`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)"

#: src/exercises/day-3/safe-ffi-wrapper.md:11
msgid "[`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"
msgstr "[`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"

#: src/exercises/day-3/safe-ffi-wrapper.md:13
msgid ""
"You will also want to browse the [`std::ffi`](https://doc.rust-lang.org/std/"
"ffi/) module. There you find a number of string types which you need for the "
"exercise:"
msgstr ""
"Tambi√©n te recomendamos que consultes el m√≥dulo [`std::ffi`](https://doc."
"rust-lang.org/std/ffi/). Ah√≠ encontrar√°s una serie de tipos de cadena que "
"necesitas para el ejercicio:"

#: src/exercises/day-3/safe-ffi-wrapper.md:16
msgid "Encoding"
msgstr "Codificaci√≥n"

#: src/exercises/day-3/safe-ffi-wrapper.md:16
msgid "Use"
msgstr "Uso"

#: src/exercises/day-3/safe-ffi-wrapper.md:18
msgid ""
"[`str`](https://doc.rust-lang.org/std/primitive.str.html) and [`String`]"
"(https://doc.rust-lang.org/std/string/struct.String.html)"
msgstr ""
"[`str`](https://doc.rust-lang.org/std/primitive.str.html) y [`String`]"
"(https://doc.rust-lang.org/std/string/struct.String.html)"

#: src/exercises/day-3/safe-ffi-wrapper.md:18
msgid "UTF-8"
msgstr "UTF-8"

#: src/exercises/day-3/safe-ffi-wrapper.md:18
msgid "Text processing in Rust"
msgstr "Procesar textos en Rust"

#: src/exercises/day-3/safe-ffi-wrapper.md:19
msgid ""
"[`CStr`](https://doc.rust-lang.org/std/ffi/struct.CStr.html) and [`CString`]"
"(https://doc.rust-lang.org/std/ffi/struct.CString.html)"
msgstr ""
"[`CStr`](https://doc.rust-lang.org/std/ffi/struct.CStr.html) y [`CString`]"
"(https://doc.rust-lang.org/std/ffi/struct.CString.html)"

#: src/exercises/day-3/safe-ffi-wrapper.md:19
msgid "NUL-terminated"
msgstr "Terminado en NUL"

#: src/exercises/day-3/safe-ffi-wrapper.md:19
msgid "Communicating with C functions"
msgstr "Comunicarse con funciones C"

#: src/exercises/day-3/safe-ffi-wrapper.md:20
msgid ""
"[`OsStr`](https://doc.rust-lang.org/std/ffi/struct.OsStr.html) and "
"[`OsString`](https://doc.rust-lang.org/std/ffi/struct.OsString.html)"
msgstr ""
"[`OsStr`](https://doc.rust-lang.org/std/ffi/struct.OsStr.html) y [`OsString`]"
"(https://doc.rust-lang.org/std/ffi/struct.OsString.html)"

#: src/exercises/day-3/safe-ffi-wrapper.md:20
msgid "OS-specific"
msgstr "Espec√≠fico del SO"

#: src/exercises/day-3/safe-ffi-wrapper.md:20
msgid "Communicating with the OS"
msgstr "Comunicarse con el SO"

#: src/exercises/day-3/safe-ffi-wrapper.md:22
msgid "You will convert between all these types:"
msgstr "Realizar√°s conversiones entre todos estos tipos:"

#: src/exercises/day-3/safe-ffi-wrapper.md:24
msgid ""
"`&str` to `CString`: you need to allocate space for a trailing `\\0` "
"character,"
msgstr ""
"De `&str` a `CString`: debes asignar espacio para un car√°cter final `\\0`,"

#: src/exercises/day-3/safe-ffi-wrapper.md:25
msgid "`CString` to `*const i8`: you need a pointer to call C functions,"
msgstr ""
"De `CString` a `*const i8`: necesitas un puntero para llamar a funciones C,"

#: src/exercises/day-3/safe-ffi-wrapper.md:26
msgid ""
"`*const i8` to `&CStr`: you need something which can find the trailing `\\0` "
"character,"
msgstr ""
"De `*const i8` a `&CStr`: necesitas algo que pueda encontrar el car√°cter "
"final `\\0`,"

#: src/exercises/day-3/safe-ffi-wrapper.md:27
msgid ""
"`&CStr` to `&[u8]`: a slice of bytes is the universal interface for \"some "
"unknow data\","
msgstr ""
"De `&CStr` a `&[u8]`: un slice de bytes es la interfaz universal para "
"\"algunos datos desconocidos\"."

#: src/exercises/day-3/safe-ffi-wrapper.md:28
msgid ""
"`&[u8]` to `&OsStr`: `&OsStr` is a step towards `OsString`, use [`OsStrExt`]"
"(https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html) to create it,"
msgstr ""
"De `&[u8]` a `&OsStr`: `&OsStr` es un paso hacia `OsString`, usa [`OsStrExt`]"
"(https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html) para crearlo."

#: src/exercises/day-3/safe-ffi-wrapper.md:31
msgid ""
"`&OsStr` to `OsString`: you need to clone the data in `&OsStr` to be able to "
"return it and call `readdir` again."
msgstr ""
"De `OsStr` a `OsString`: debes clonar los datos en `&OsStr` para poder "
"devolverlo y llamar a `readdir` de nuevo."

#: src/exercises/day-3/safe-ffi-wrapper.md:34
msgid ""
"The [Nomicon](https://doc.rust-lang.org/nomicon/ffi.html) also has a very "
"useful chapter about FFI."
msgstr ""
"El [Nomicon](https://doc.rust-lang.org/nomicon/ffi.html) tambi√©n tiene un "
"cap√≠tulo muy √∫til sobre FFI."

#: src/exercises/day-3/safe-ffi-wrapper.md:45
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing "
"functions and methods:"
msgstr ""
"Copia el fragmento de c√≥digo que aparece m√°s abajo en la p√°gina <https://"
"play.rust-lang.org/> y rellena los m√©todos y funciones que faltan:"

#: src/exercises/day-3/safe-ffi-wrapper.md:48
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_imports, unused_variables, dead_code)]\n"
"\n"
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int};\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    use std::os::raw::{c_long, c_ulong, c_ushort, c_uchar};\n"
"\n"
"    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
"    #[repr(C)]\n"
"    pub struct DIR {\n"
"        _data: [u8; 0],\n"
"        _marker: core::marker::PhantomData<(*mut u8, core::marker::"
"PhantomPinned)>,\n"
"    }\n"
"\n"
"    // Layout according to the Linux man page for readdir(3), where ino_t "
"and\n"
"    // off_t are resolved according to the definitions in\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_ino: c_ulong,\n"
"        pub d_off: c_long,\n"
"        pub d_reclen: c_ushort,\n"
"        pub d_type: c_uchar,\n"
"        pub d_name: [c_char; 256],\n"
"    }\n"
"\n"
"    // Layout according to the macOS man page for dir(5).\n"
"    #[cfg(all(target_os = \"macos\"))]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_fileno: u64,\n"
"        pub d_seekoff: u64,\n"
"        pub d_reclen: u16,\n"
"        pub d_namlen: u16,\n"
"        pub d_type: u8,\n"
"        pub d_name: [c_char; 1024],\n"
"    }\n"
"\n"
"    extern \"C\" {\n"
"        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
"\n"
"        #[cfg(not(all(target_os = \"macos\", target_arch = \"x86_64\")))]\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"\n"
"        // See https://github.com/rust-lang/libc/issues/414 and the section "
"on\n"
"        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).\n"
"        //\n"
"        // \"Platforms that existed before these updates were available\" "
"refers\n"
"        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and "
"PowerPC.\n"
"        #[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n"
"        #[link_name = \"readdir$INODE64\"]\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"\n"
"        pub fn closedir(s: *mut DIR) -> c_int;\n"
"    }\n"
"}\n"
"\n"
"use std::ffi::{CStr, CString, OsStr, OsString};\n"
"use std::os::unix::ffi::OsStrExt;\n"
"\n"
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}\n"
"\n"
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Keep calling readdir until we get a NULL pointer back.\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Drop for DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Call closedir as needed.\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/android.md:1
msgid "Welcome to Rust in Android"
msgstr "Te Damos la Bienvenida a Rust en Android"

#: src/android.md:3
msgid ""
"Rust is supported for native platform development on Android. This means "
"that you can write new operating system services in Rust, as well as "
"extending existing services."
msgstr ""
"Rust es compatible con el desarrollo de plataformas nativas en Android. Esto "
"significa que puedes escribir nuevos servicios del sistema operativo en "
"Rust, as√≠ como ampliar los que ya existen."

#: src/android.md:7
msgid ""
"We will attempt to call Rust from one of your own projects today. So try to "
"find a little corner of your code base where we can move some lines of code "
"to Rust. The fewer dependencies and \"exotic\" types the better. Something "
"that parses some raw bytes would be ideal."
msgstr ""
"Hoy intentaremos llamar a Rust desde un proyecto personal. Intenta encontrar "
"una peque√±a esquina de tu c√≥digo base donde podamos mover algunas l√≠neas de "
"c√≥digo a Rust. Cuantas menos dependencias y tipos \"ex√≥ticos\" tenga, mejor. "
"Lo ideal ser√≠a algo que analizara bytes sin procesar."

#: src/android/setup.md:3
msgid ""
"We will be using an Android Virtual Device to test our code. Make sure you "
"have access to one or create a new one with:"
msgstr ""
"Utilizaremos un dispositivo Android virtual para probar el c√≥digo. Aseg√∫rate "
"de que tienes acceso a uno o cr√©alo con:"

#: src/android/setup.md:6
msgid ""
"```shell\n"
"source build/envsetup.sh\n"
"lunch aosp_cf_x86_64_phone-userdebug\n"
"acloud create\n"
"```"
msgstr ""

#: src/android/setup.md:12
msgid ""
"Please see the [Android Developer Codelab](https://source.android.com/docs/"
"setup/start) for details."
msgstr ""
"Consulta el [Codelab para desarrolladores de Android](https://source.android."
"com/docs/setup/start) para obtener m√°s informaci√≥n."

#: src/android/build-rules.md:3
msgid "The Android build system (Soong) supports Rust via a number of modules:"
msgstr ""
"El sistema de compilaci√≥n de Android (Soong) es compatible con Rust a trav√©s "
"de una serie de m√≥dulos:"

#: src/android/build-rules.md:5
msgid "Module Type"
msgstr "Tipo de m√≥dulo"

#: src/android/build-rules.md:5
msgid "Description"
msgstr "Descripci√≥n"

#: src/android/build-rules.md:7
msgid "`rust_binary`"
msgstr "`rust_binary`"

#: src/android/build-rules.md:7
msgid "Produces a Rust binary."
msgstr "Produce un binario de Rust."

#: src/android/build-rules.md:8
msgid "`rust_library`"
msgstr "`rust_library`"

#: src/android/build-rules.md:8
msgid "Produces a Rust library, and provides both `rlib` and `dylib` variants."
msgstr ""
"Produce una biblioteca de Rust y proporciona las variantes `rlib` y `dylib`."

#: src/android/build-rules.md:9
msgid "`rust_ffi`"
msgstr "`rust_ffi`"

#: src/android/build-rules.md:9
msgid ""
"Produces a Rust C library usable by `cc` modules, and provides both static "
"and shared variants."
msgstr ""
"Produce una biblioteca de Rust C que pueden usar los m√≥dulos `cc` y "
"proporciona variantes est√°ticas y compartidas."

#: src/android/build-rules.md:10
msgid "`rust_proc_macro`"
msgstr "`rust_proc_macro`"

#: src/android/build-rules.md:10
msgid ""
"Produces a `proc-macro` Rust library. These are analogous to compiler "
"plugins."
msgstr ""
"Produce una biblioteca de Rust `proc-macro`. Son similares a complementos "
"del compilador."

#: src/android/build-rules.md:11
msgid "`rust_test`"
msgstr "`rust_test`"

#: src/android/build-rules.md:11
msgid "Produces a Rust test binary that uses the standard Rust test harness."
msgstr ""
"Produce un binario de prueba de Rust que utiliza el agente de prueba "
"est√°ndar de Rust."

#: src/android/build-rules.md:12
msgid "`rust_fuzz`"
msgstr "`rust_fuzz`"

#: src/android/build-rules.md:12
msgid "Produces a Rust fuzz binary leveraging `libfuzzer`."
msgstr "Produce un binario de fuzz de Rust que aprovecha `libfuzzer`."

#: src/android/build-rules.md:13
msgid "`rust_protobuf`"
msgstr "`rust_protobuf`"

#: src/android/build-rules.md:13
msgid ""
"Generates source and produces a Rust library that provides an interface for "
"a particular protobuf."
msgstr ""
"Genera c√≥digo fuente y produce una biblioteca Rust que proporciona una "
"interfaz para un protobuf en particular."

#: src/android/build-rules.md:14
msgid "`rust_bindgen`"
msgstr "`rust_bindgen`"

#: src/android/build-rules.md:14
msgid ""
"Generates source and produces a Rust library containing Rust bindings to C "
"libraries."
msgstr ""
"Genera c√≥digo fuente y produce una biblioteca de Rust que contiene enlaces "
"de Rust a bibliotecas de C."

#: src/android/build-rules.md:16
msgid "We will look at `rust_binary` and `rust_library` next."
msgstr "A continuaci√≥n, hablaremos de `rust_binary` y `rust_library`."

#: src/android/build-rules/binary.md:1
msgid "Rust Binaries"
msgstr "Binarios de Rust"

#: src/android/build-rules/binary.md:3
msgid ""
"Let us start with a simple application. At the root of an AOSP checkout, "
"create the following files:"
msgstr ""
"Empecemos con una sencilla aplicaci√≥n. Desde la ra√≠z de un AOSP revisado, "
"crea los siguientes archivos:"

#: src/android/build-rules/binary.md:6 src/android/build-rules/library.md:13
msgid "_hello_rust/Android.bp_:"
msgstr "_hello_rust/Android.bp_:"

#: src/android/build-rules/binary.md:8
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust\",\n"
"    crate_name: \"hello_rust\",\n"
"    srcs: [\"src/main.rs\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/binary.md:16 src/android/build-rules/library.md:34
msgid "_hello_rust/src/main.rs_:"
msgstr "_hello_rust/src/main.rs_:"

#: src/android/build-rules/binary.md:18
msgid ""
"```rust\n"
"//! Rust demo.\n"
"\n"
"/// Prints a greeting to standard output.\n"
"fn main() {\n"
"    println!(\"Hello from Rust!\");\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/binary.md:27
msgid "You can now build, push, and run the binary:"
msgstr "Ahora puedes compilar, insertar y ejecutar el binario:"

#: src/android/build-rules/binary.md:29
msgid ""
"```shell\n"
"m hello_rust\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust /data/local/tmp\"\n"
"adb shell /data/local/tmp/hello_rust\n"
"```"
msgstr ""

#: src/android/build-rules/binary.md:35
msgid ""
"```text\n"
"Hello from Rust!\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:1
msgid "Rust Libraries"
msgstr "Bibliotecas de Rust"

#: src/android/build-rules/library.md:3
msgid "You use `rust_library` to create a new Rust library for Android."
msgstr "Crea una biblioteca de Rust para Android con `rust_library`."

#: src/android/build-rules/library.md:5
msgid "Here we declare a dependency on two libraries:"
msgstr "Aqu√≠ declaramos una dependencia en dos bibliotecas:"

#: src/android/build-rules/library.md:7
msgid "`libgreeting`, which we define below,"
msgstr "`libgreeting`, que definimos m√°s abajo."

#: src/android/build-rules/library.md:8
msgid ""
"`libtextwrap`, which is a crate already vendored in [`external/rust/crates/`]"
"(https://cs.android.com/android/platform/superproject/+/master:external/rust/"
"crates/)."
msgstr ""
"`libtextwrap`, que es un crate ya incluido en [`external/rust/crates/`]"
"(https://cs.android.com/android/platform/superproject/+/master:external/rust/"
"crates/)."

#: src/android/build-rules/library.md:15
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_with_dep\",\n"
"    crate_name: \"hello_rust_with_dep\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"libgreetings\",\n"
"        \"libtextwrap\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"\n"
"rust_library {\n"
"    name: \"libgreetings\",\n"
"    crate_name: \"greetings\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_with_dep\",\n"
"    crate_name: \"hello_rust_with_dep\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"libgreetings\",\n"
"        \"libtextwrap\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"\n"
"rust_library {\n"
"    name: \"libgreetings\",\n"
"    crate_name: \"greetings\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"}\n"
"```"

#: src/android/build-rules/library.md:36
msgid ""
"```rust,ignore\n"
"//! Rust demo.\n"
"\n"
"use greetings::greeting;\n"
"use textwrap::fill;\n"
"\n"
"/// Prints a greeting to standard output.\n"
"fn main() {\n"
"    println!(\"{}\", fill(&greeting(\"Bob\"), 24));\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"//! Rust demo.\n"
"\n"
"use greetings::greeting;\n"
"use textwrap::fill;\n"
"\n"
"/// Imprime un saludo en una salida est√°ndar.\n"
"fn main() {\n"
"    println!(\"{}\", fill(&greeting(\"Bob\"), 24));\n"
"}\n"
"```"

#: src/android/build-rules/library.md:48
msgid "_hello_rust/src/lib.rs_:"
msgstr "_hello_rust/src/lib.rs_:"

#: src/android/build-rules/library.md:50
msgid ""
"```rust,ignore\n"
"//! Greeting library.\n"
"\n"
"/// Greet `name`.\n"
"pub fn greeting(name: &str) -> String {\n"
"    format!(\"Hello {name}, it is very nice to meet you!\")\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"//! Greeting library.\n"
"\n"
"/// Saludar a `name`.\n"
"pub fn greeting(name: &str) -> String {\n"
"    format!(\"Hello {name}, it is very nice to meet you!\")\n"
"}\n"
"```"

#: src/android/build-rules/library.md:59
msgid "You build, push, and run the binary like before:"
msgstr "Puedes compilar, insertar y ejecutar el binario como antes:"

#: src/android/build-rules/library.md:61
msgid ""
"```shell\n"
"m hello_rust_with_dep\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/hello_rust_with_dep\n"
"```"
msgstr ""
"```shell\n"
"m hello_rust_with_dep\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/hello_rust_with_dep\n"
"```"

#: src/android/build-rules/library.md:67
msgid ""
"```text\n"
"Hello Bob, it is very\n"
"nice to meet you!\n"
"```"
msgstr ""
"```text\n"
"Hello Bob, it is very\n"
"nice to meet you!\n"
"```"

#: src/android/aidl.md:3
msgid ""
"The [Android Interface Definition Language (AIDL)](https://developer.android."
"com/guide/components/aidl) is supported in Rust:"
msgstr ""
"El [lenguaje de definici√≥n de la interfaz de Android (AIDL)](https://"
"developer.android.com/guide/components/aidl) es compatible con Rust:"

#: src/android/aidl.md:6
msgid "Rust code can call existing AIDL servers,"
msgstr ""
"El c√≥digo de Rust puede llamar a servidores AIDL que ya se hayan creado."

#: src/android/aidl.md:7
msgid "You can create new AIDL servers in Rust."
msgstr "Puedes crear servidores de AIDL en Rust."

#: src/android/aidl/interface.md:1
msgid "AIDL Interfaces"
msgstr "Interfaces de AIDL"

#: src/android/aidl/interface.md:3
msgid "You declare the API of your service using an AIDL interface:"
msgstr "La API de tu servicio se declara mediante una interfaz de AIDL:"

#: src/android/aidl/interface.md:5
msgid ""
"_birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl_:"
msgstr ""
"_birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl_:"

#: src/android/aidl/interface.md:7
msgid ""
"```java\n"
"package com.example.birthdayservice;\n"
"\n"
"/** Birthday service interface. */\n"
"interface IBirthdayService {\n"
"    /** Generate a Happy Birthday message. */\n"
"    String wishHappyBirthday(String name, int years);\n"
"}\n"
"```"
msgstr ""
"```java\n"
"package com.example.birthdayservice;\n"
"\n"
"/** Birthday service interface. */\n"
"interface IBirthdayService {\n"
"    /** Generate a Happy Birthday message. */\n"
"    String wishHappyBirthday(String name, int years);\n"
"}\n"
"```"

#: src/android/aidl/interface.md:17
msgid "_birthday_service/aidl/Android.bp_:"
msgstr "_birthday_service/aidl/Android.bp_:"

#: src/android/aidl/interface.md:19
msgid ""
"```javascript\n"
"aidl_interface {\n"
"    name: \"com.example.birthdayservice\",\n"
"    srcs: [\"com/example/birthdayservice/*.aidl\"],\n"
"    unstable: true,\n"
"    backend: {\n"
"        rust: { // Rust is not enabled by default\n"
"            enabled: true,\n"
"        },\n"
"    },\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"aidl_interface {\n"
"    name: \"com.example.birthdayservice\",\n"
"    srcs: [\"com/example/birthdayservice/*.aidl\"],\n"
"    unstable: true,\n"
"    backend: {\n"
"        rust: { // Rust is not enabled by default\n"
"            enabled: true,\n"
"        },\n"
"    },\n"
"}\n"
"```"

#: src/android/aidl/interface.md:32
msgid ""
"Add `vendor_available: true` if your AIDL file is used by a binary in the "
"vendor partition."
msgstr ""
"A√±ade `vendor_available: true` si un binario de la partici√≥n del proveedor "
"utiliza tu archivo de AIDL."

#: src/android/aidl/implementation.md:1
msgid "Service Implementation"
msgstr "Implementaci√≥n del servicio"

#: src/android/aidl/implementation.md:3
msgid "We can now implement the AIDL service:"
msgstr "Ahora podemos implementar el servicio de AIDL:"

#: src/android/aidl/implementation.md:5
msgid "_birthday_service/src/lib.rs_:"
msgstr "_birthday_service/src/lib.rs_:"

#: src/android/aidl/implementation.md:7
msgid ""
"```rust,ignore\n"
"//! Implementation of the `IBirthdayService` AIDL interface.\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::"
"IBirthdayService::IBirthdayService;\n"
"use com_example_birthdayservice::binder;\n"
"\n"
"/// The `IBirthdayService` implementation.\n"
"pub struct BirthdayService;\n"
"\n"
"impl binder::Interface for BirthdayService {}\n"
"\n"
"impl IBirthdayService for BirthdayService {\n"
"    fn wishHappyBirthday(&self, name: &str, years: i32) -> binder::"
"Result<String> {\n"
"        Ok(format!(\n"
"            \"Happy Birthday {name}, congratulations with the {years} years!"
"\"\n"
"        ))\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/implementation.md:26 src/android/aidl/server.md:28
#: src/android/aidl/client.md:37
msgid "_birthday_service/Android.bp_:"
msgstr "_birthday_service/Android.bp_:"

#: src/android/aidl/implementation.md:28
msgid ""
"```javascript\n"
"rust_library {\n"
"    name: \"libbirthdayservice\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    crate_name: \"birthdayservice\",\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/server.md:1
msgid "AIDL Server"
msgstr "Servidor de AIDL"

#: src/android/aidl/server.md:3
msgid "Finally, we can create a server which exposes the service:"
msgstr "Por √∫ltimo, podemos crear un servidor que exponga el servicio:"

#: src/android/aidl/server.md:5
msgid "_birthday_service/src/server.rs_:"
msgstr "_birthday_service/src/server.rs_:"

#: src/android/aidl/server.md:7
msgid ""
"```rust,ignore\n"
"//! Birthday service.\n"
"use birthdayservice::BirthdayService;\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::"
"IBirthdayService::BnBirthdayService;\n"
"use com_example_birthdayservice::binder;\n"
"\n"
"const SERVICE_IDENTIFIER: &str = \"birthdayservice\";\n"
"\n"
"/// Entry point for birthday service.\n"
"fn main() {\n"
"    let birthday_service = BirthdayService;\n"
"    let birthday_service_binder = BnBirthdayService::new_binder(\n"
"        birthday_service,\n"
"        binder::BinderFeatures::default(),\n"
"    );\n"
"    binder::add_service(SERVICE_IDENTIFIER, birthday_service_binder."
"as_binder())\n"
"        .expect(\"Failed to register service\");\n"
"    binder::ProcessState::join_thread_pool()\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/server.md:30
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_server\",\n"
"    crate_name: \"birthday_server\",\n"
"    srcs: [\"src/server.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"        \"libbirthdayservice\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:3
msgid "We can now build, push, and start the service:"
msgstr "Ahora podemos crear, insertar e iniciar el servicio:"

#: src/android/aidl/deploy.md:5
msgid ""
"```shell\n"
"m birthday_server\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/birthday_server\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:11
msgid "In another terminal, check that the service runs:"
msgstr "Comprueba que el servicio funciona en otra terminal:"

#: src/android/aidl/deploy.md:13
msgid ""
"```shell\n"
"adb shell service check birthdayservice\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:17
msgid ""
"```text\n"
"Service birthdayservice: found\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:21
msgid "You can also call the service with `service call`:"
msgstr "Tambi√©n puedes llamar al servicio con `service call`:"

#: src/android/aidl/deploy.md:23
msgid ""
"```shell\n"
"adb shell service call birthdayservice 1 s16 Bob i32 24\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:27
msgid ""
"```text\n"
"Result: Parcel(\n"
"  0x00000000: 00000000 00000036 00610048 00700070 '....6...H.a.p.p.'\n"
"  0x00000010: 00200079 00690042 00740072 00640068 'y. .B.i.r.t.h.d.'\n"
"  0x00000020: 00790061 00420020 0062006f 0020002c 'a.y. .B.o.b.,. .'\n"
"  0x00000030: 006f0063 0067006e 00610072 00750074 'c.o.n.g.r.a.t.u.'\n"
"  0x00000040: 0061006c 00690074 006e006f 00200073 'l.a.t.i.o.n.s. .'\n"
"  0x00000050: 00690077 00680074 00740020 00650068 'w.i.t.h. .t.h.e.'\n"
"  0x00000060: 00320020 00200034 00650079 00720061 ' .2.4. .y.e.a.r.'\n"
"  0x00000070: 00210073 00000000                   's.!.....        ')\n"
"```"
msgstr ""

#: src/android/aidl/client.md:1
msgid "AIDL Client"
msgstr "Cliente de AIDL"

#: src/android/aidl/client.md:3
msgid "Finally, we can create a Rust client for our new service."
msgstr ""
"Por √∫ltimo, podemos crear un cliente de Rust para nuestro nuevo servicio."

#: src/android/aidl/client.md:5
msgid "_birthday_service/src/client.rs_:"
msgstr "_birthday_service/src/client.rs_:"

#: src/android/aidl/client.md:7
msgid ""
"```rust,ignore\n"
"//! Birthday service.\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::"
"IBirthdayService::IBirthdayService;\n"
"use com_example_birthdayservice::binder;\n"
"\n"
"const SERVICE_IDENTIFIER: &str = \"birthdayservice\";\n"
"\n"
"/// Connect to the BirthdayService.\n"
"pub fn connect() -> Result<binder::Strong<dyn IBirthdayService>, binder::"
"StatusCode> {\n"
"    binder::get_interface(SERVICE_IDENTIFIER)\n"
"}\n"
"\n"
"/// Call the birthday service.\n"
"fn main() -> Result<(), binder::Status> {\n"
"    let name = std::env::args()\n"
"        .nth(1)\n"
"        .unwrap_or_else(|| String::from(\"Bob\"));\n"
"    let years = std::env::args()\n"
"        .nth(2)\n"
"        .and_then(|arg| arg.parse::<i32>().ok())\n"
"        .unwrap_or(42);\n"
"\n"
"    binder::ProcessState::start_thread_pool();\n"
"    let service = connect().expect(\"Failed to connect to "
"BirthdayService\");\n"
"    let msg = service.wishHappyBirthday(&name, years)?;\n"
"    println!(\"{msg}\");\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/client.md:39
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_client\",\n"
"    crate_name: \"birthday_client\",\n"
"    srcs: [\"src/client.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/client.md:52
msgid "Notice that the client does not depend on `libbirthdayservice`."
msgstr "Ten en cuenta que el cliente no depende de `libbirthdayservice`."

#: src/android/aidl/client.md:54
msgid "Build, push, and run the client on your device:"
msgstr "Compila, inserta y ejecuta el cliente en tu dispositivo:"

#: src/android/aidl/client.md:56
msgid ""
"```shell\n"
"m birthday_client\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_client /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/birthday_client Charlie 60\n"
"```"
msgstr ""

#: src/android/aidl/client.md:62
msgid ""
"```text\n"
"Happy Birthday Charlie, congratulations with the 60 years!\n"
"```"
msgstr ""

#: src/android/aidl/changing.md:3
msgid ""
"Let us extend the API with more functionality: we want to let clients "
"specify a list of lines for the birthday card:"
msgstr ""
"Ampliemos la API con m√°s funciones. Queremos que los clientes puedan indicar "
"una lista de l√≠neas para la tarjeta de cumplea√±os:"

#: src/android/aidl/changing.md:6
msgid ""
"```java\n"
"package com.example.birthdayservice;\n"
"\n"
"/** Birthday service interface. */\n"
"interface IBirthdayService {\n"
"    /** Generate a Happy Birthday message. */\n"
"    String wishHappyBirthday(String name, int years, in String[] text);\n"
"}\n"
"```"
msgstr ""

#: src/android/logging.md:3
msgid ""
"You should use the `log` crate to automatically log to `logcat` (on-device) "
"or `stdout` (on-host):"
msgstr ""
"Utiliza el crate `log` para que se registre autom√°ticamente en `logcat` (en "
"el dispositivo) o `stdout` (en el host):"

#: src/android/logging.md:6
msgid "_hello_rust_logs/Android.bp_:"
msgstr "_hello_rust_logs/Android.bp_:"

#: src/android/logging.md:8
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_logs\",\n"
"    crate_name: \"hello_rust_logs\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"liblog_rust\",\n"
"        \"liblogger\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"    host_supported: true,\n"
"}\n"
"```"
msgstr ""

#: src/android/logging.md:22
msgid "_hello_rust_logs/src/main.rs_:"
msgstr "_hello_rust_logs/src/main.rs_:"

#: src/android/logging.md:24
msgid ""
"```rust,ignore\n"
"//! Rust logging demo.\n"
"\n"
"use log::{debug, error, info};\n"
"\n"
"/// Logs a greeting.\n"
"fn main() {\n"
"    logger::init(\n"
"        logger::Config::default()\n"
"            .with_tag_on_device(\"rust\")\n"
"            .with_min_level(log::Level::Trace),\n"
"    );\n"
"    debug!(\"Starting program.\");\n"
"    info!(\"Things are going fine.\");\n"
"    error!(\"Something went wrong!\");\n"
"}\n"
"```"
msgstr ""

#: src/android/logging.md:42 src/android/interoperability/with-c/bindgen.md:98
#: src/android/interoperability/with-c/rust.md:73
msgid "Build, push, and run the binary on your device:"
msgstr "Compila, inserta y ejecuta el binario en tu dispositivo:"

#: src/android/logging.md:44
msgid ""
"```shell\n"
"m hello_rust_logs\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/hello_rust_logs\n"
"```"
msgstr ""

#: src/android/logging.md:50
msgid "The logs show up in `adb logcat`:"
msgstr "Los registros se muestran en `adb logcat`:"

#: src/android/logging.md:52
msgid ""
"```shell\n"
"adb logcat -s rust\n"
"```"
msgstr ""

#: src/android/logging.md:56
msgid ""
"```text\n"
"09-08 08:38:32.454  2420  2420 D rust: hello_rust_logs: Starting program.\n"
"09-08 08:38:32.454  2420  2420 I rust: hello_rust_logs: Things are going "
"fine.\n"
"09-08 08:38:32.454  2420  2420 E rust: hello_rust_logs: Something went "
"wrong!\n"
"```"
msgstr ""

#: src/android/interoperability.md:3
msgid ""
"Rust has excellent support for interoperability with other languages. This "
"means that you can:"
msgstr ""
"Rust admite sin problemas la interoperabilidad con otros lenguajes. Esto "
"significa que puedes hacer lo siguiente:"

#: src/android/interoperability.md:6
msgid "Call Rust functions from other languages."
msgstr "Llamar a funciones de Rust desde otros lenguajes."

#: src/android/interoperability.md:7
msgid "Call functions written in other languages from Rust."
msgstr "Llamar a funciones escritas en otros lenguajes desde Rust."

#: src/android/interoperability.md:9
msgid ""
"When you call functions in a foreign language we say that you're using a "
"_foreign function interface_, also known as FFI."
msgstr ""
"Cuando llamas a funciones en otro lenguaje, se dice que est√°s usando una "
"_interfaz de funci√≥n externa_, tambi√©n denominada FFI."

#: src/android/interoperability/with-c.md:1
msgid "Interoperability with C"
msgstr "Interoperabilidad con C"

#: src/android/interoperability/with-c.md:3
msgid ""
"Rust has full support for linking object files with a C calling convention. "
"Similarly, you can export Rust functions and call them from C."
msgstr ""
"Rust admite vincular archivos de objetos con una convenci√≥n de llamada de C. "
"Del mismo modo, puedes exportar funciones de Rust y llamarlas desde C."

#: src/android/interoperability/with-c.md:6
msgid "You can do it by hand if you want:"
msgstr "Si quieres, puedes hacerlo de forma manual:"

#: src/android/interoperability/with-c.md:8
msgid ""
"```rust\n"
"extern \"C\" {\n"
"    fn abs(x: i32) -> i32;\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = -42;\n"
"    let abs_x = unsafe { abs(x) };\n"
"    println!(\"{x}, {abs_x}\");\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c.md:20
msgid ""
"We already saw this in the [Safe FFI Wrapper exercise](../../exercises/day-3/"
"safe-ffi-wrapper.md)."
msgstr ""
"Ya lo hemos visto en el ejercicio [Envoltorio de FFI seguro](../../exercises/"
"day-3/safe-ffi-wrapper.md)."

#: src/android/interoperability/with-c.md:23
msgid ""
"This assumes full knowledge of the target platform. Not recommended for "
"production."
msgstr ""
"Esto supone un conocimiento completo de la plataforma objetivo. No se "
"recomienda para producci√≥n."

#: src/android/interoperability/with-c.md:26
msgid "We will look at better options next."
msgstr "A continuaci√≥n, estudiaremos otras opciones mejores."

#: src/android/interoperability/with-c/bindgen.md:1
msgid "Using Bindgen"
msgstr "Uso de Bindgen"

#: src/android/interoperability/with-c/bindgen.md:3
msgid ""
"The [bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html) "
"tool can auto-generate bindings from a C header file."
msgstr ""
"La herramienta [bindgen](https://rust-lang.github.io/rust-bindgen/"
"introduction.html) puede generar autom√°ticamente enlaces desde un archivo de "
"encabezado de C."

#: src/android/interoperability/with-c/bindgen.md:6
msgid "First create a small C library:"
msgstr "En primer lugar, crea una biblioteca de C peque√±a:"

#: src/android/interoperability/with-c/bindgen.md:8
msgid "_interoperability/bindgen/libbirthday.h_:"
msgstr "_interoperability/bindgen/libbirthday.h_:"

#: src/android/interoperability/with-c/bindgen.md:10
msgid ""
"```c\n"
"typedef struct card {\n"
"  const char* name;\n"
"  int years;\n"
"} card;\n"
"\n"
"void print_card(const card* card);\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:19
msgid "_interoperability/bindgen/libbirthday.c_:"
msgstr "_interoperability/bindgen/libbirthday.c_:"

#: src/android/interoperability/with-c/bindgen.md:21
msgid ""
"```c\n"
"#include <stdio.h>\n"
"#include \"libbirthday.h\"\n"
"\n"
"void print_card(const card* card) {\n"
"  printf(\"+--------------\\n\");\n"
"  printf(\"| Happy Birthday %s!\\n\", card->name);\n"
"  printf(\"| Congratulations with the %i years!\\n\", card->years);\n"
"  printf(\"+--------------\\n\");\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:33
msgid "Add this to your `Android.bp` file:"
msgstr "A√±ade lo siguiente a tu archivo `Android.bp`:"

#: src/android/interoperability/with-c/bindgen.md:35
#: src/android/interoperability/with-c/bindgen.md:55
#: src/android/interoperability/with-c/bindgen.md:69
#: src/android/interoperability/with-c/bindgen.md:108
msgid "_interoperability/bindgen/Android.bp_:"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:37
msgid ""
"```javascript\n"
"cc_library {\n"
"    name: \"libbirthday\",\n"
"    srcs: [\"libbirthday.c\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:44
msgid ""
"Create a wrapper header file for the library (not strictly needed in this "
"example):"
msgstr ""
"Crea un archivo de encabezado de envoltorio para la biblioteca (no es "
"estrictamente necesario en este ejemplo):"

#: src/android/interoperability/with-c/bindgen.md:47
msgid "_interoperability/bindgen/libbirthday_wrapper.h_:"
msgstr "_interoperability/bindgen/libbirthday_wrapper.h_:"

#: src/android/interoperability/with-c/bindgen.md:49
msgid ""
"```c\n"
"#include \"libbirthday.h\"\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:53
msgid "You can now auto-generate the bindings:"
msgstr "Ahora puedes generar autom√°ticamente los enlaces:"

#: src/android/interoperability/with-c/bindgen.md:57
msgid ""
"```javascript\n"
"rust_bindgen {\n"
"    name: \"libbirthday_bindgen\",\n"
"    crate_name: \"birthday_bindgen\",\n"
"    wrapper_src: \"libbirthday_wrapper.h\",\n"
"    source_stem: \"bindings\",\n"
"    static_libs: [\"libbirthday\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:67
msgid "Finally, we can use the bindings in our Rust program:"
msgstr "Por √∫ltimo, podemos utilizar los enlaces de nuestro programa de Rust:"

#: src/android/interoperability/with-c/bindgen.md:71
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"print_birthday_card\",\n"
"    srcs: [\"main.rs\"],\n"
"    rustlibs: [\"libbirthday_bindgen\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:79
msgid "_interoperability/bindgen/main.rs_:"
msgstr "_interoperability/bindgen/main.rs_:"

#: src/android/interoperability/with-c/bindgen.md:81
msgid ""
"```rust,compile_fail\n"
"//! Bindgen demo.\n"
"\n"
"use birthday_bindgen::{card, print_card};\n"
"\n"
"fn main() {\n"
"    let name = std::ffi::CString::new(\"Peter\").unwrap();\n"
"    let card = card {\n"
"        name: name.as_ptr(),\n"
"        years: 42,\n"
"    };\n"
"    unsafe {\n"
"        print_card(&card as *const card);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:100
msgid ""
"```shell\n"
"m print_birthday_card\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/print_birthday_card\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:106
msgid "Finally, we can run auto-generated tests to ensure the bindings work:"
msgstr ""
"Por √∫ltimo, podemos ejecutar pruebas generadas autom√°ticamente para "
"comprobar que los enlaces funcionan:"

#: src/android/interoperability/with-c/bindgen.md:110
msgid ""
"```javascript\n"
"rust_test {\n"
"    name: \"libbirthday_bindgen_test\",\n"
"    srcs: [\":libbirthday_bindgen\"],\n"
"    crate_name: \"libbirthday_bindgen_test\",\n"
"    test_suites: [\"general-tests\"],\n"
"    auto_gen_config: true,\n"
"    clippy_lints: \"none\", // Generated file, skip linting\n"
"    lints: \"none\",\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:122
msgid ""
"```shell\n"
"atest libbirthday_bindgen_test\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:1
msgid "Calling Rust"
msgstr "Llamar a Rust"

#: src/android/interoperability/with-c/rust.md:3
msgid "Exporting Rust functions and types to C is easy:"
msgstr "Es f√°cil exportar las funciones y los tipos de Rust a C:"

#: src/android/interoperability/with-c/rust.md:5
msgid "_interoperability/rust/libanalyze/analyze.rs_"
msgstr "_interoperability/rust/libanalyze/analyze.rs_"

#: src/android/interoperability/with-c/rust.md:7
msgid ""
"```rust,editable\n"
"//! Rust FFI demo.\n"
"#![deny(improper_ctypes_definitions)]\n"
"\n"
"use std::os::raw::c_int;\n"
"\n"
"/// Analyze the numbers.\n"
"#[no_mangle]\n"
"pub extern \"C\" fn analyze_numbers(x: c_int, y: c_int) {\n"
"    if x < y {\n"
"        println!(\"x ({x}) is smallest!\");\n"
"    } else {\n"
"        println!(\"y ({y}) is probably larger than x ({x})\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:24
msgid "_interoperability/rust/libanalyze/analyze.h_"
msgstr "_interoperability/rust/libanalyze/analyze.h_"

#: src/android/interoperability/with-c/rust.md:26
msgid ""
"```c\n"
"#ifndef ANALYSE_H\n"
"#define ANALYSE_H\n"
"\n"
"extern \"C\" {\n"
"void analyze_numbers(int x, int y);\n"
"}\n"
"\n"
"#endif\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:37
msgid "_interoperability/rust/libanalyze/Android.bp_"
msgstr "_interoperability/rust/libanalyze/Android.bp_"

#: src/android/interoperability/with-c/rust.md:39
msgid ""
"```javascript\n"
"rust_ffi {\n"
"    name: \"libanalyze_ffi\",\n"
"    crate_name: \"analyze_ffi\",\n"
"    srcs: [\"analyze.rs\"],\n"
"    include_dirs: [\".\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:48
msgid "We can now call this from a C binary:"
msgstr "Ahora podemos llamarlo desde un binario de C:"

#: src/android/interoperability/with-c/rust.md:50
msgid "_interoperability/rust/analyze/main.c_"
msgstr "_interoperability/rust/analyze/main.c_"

#: src/android/interoperability/with-c/rust.md:52
msgid ""
"```c\n"
"#include \"analyze.h\"\n"
"\n"
"int main() {\n"
"  analyze_numbers(10, 20);\n"
"  analyze_numbers(123, 123);\n"
"  return 0;\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:62
msgid "_interoperability/rust/analyze/Android.bp_"
msgstr "_interoperability/rust/analyze/Android.bp_"

#: src/android/interoperability/with-c/rust.md:64
msgid ""
"```javascript\n"
"cc_binary {\n"
"    name: \"analyze_numbers\",\n"
"    srcs: [\"main.c\"],\n"
"    static_libs: [\"libanalyze_ffi\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:75
msgid ""
"```shell\n"
"m analyze_numbers\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/analyze_numbers\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:83
msgid ""
"`#[no_mangle]` disables Rust's usual name mangling, so the exported symbol "
"will just be the name of the function. You can also use `#[export_name = "
"\"some_name\"]` to specify whatever name you want."
msgstr ""
"\"#\\[no_mangle\\]\" inhabilita la modificaci√≥n de nombres habitual de Rust, "
"por lo que el s√≠mbolo exportado ser√° el nombre de la funci√≥n. Tambi√©n puedes "
"utilizar `#[export_name = \"some_name\"]` para especificar el nombre que "
"quieras."

#: src/android/interoperability/cpp.md:3
msgid ""
"The [CXX crate](https://cxx.rs/) makes it possible to do safe "
"interoperability between Rust and C++."
msgstr ""
"El [crate CXX](https://cxx.rs/) permite una interoperabilidad segura entre "
"Rust y C++."

#: src/android/interoperability/cpp.md:6
msgid "The overall approach looks like this:"
msgstr "El enfoque general es el siguiente:"

#: src/android/interoperability/cpp.md:10
msgid ""
"See the [CXX tutorial](https://cxx.rs/tutorial.html) for an full example of "
"using this."
msgstr ""
"Consulta el [tutorial de CXX](https://cxx.rs/tutorial.html) para ver un "
"ejemplo completo de su uso."

#: src/android/interoperability/cpp.md:14
msgid ""
"At this point, the instructor should switch to the [CXX tutorial](https://"
"cxx.rs/tutorial.html)."
msgstr ""
"En este punto, el instructor deber√≠a cambiar al [tutorial de CXX](https://"
"cxx.rs/tutorial.html)."

#: src/android/interoperability/cpp.md:16
msgid "Walk the students through the tutorial step by step."
msgstr "Gu√≠a a los estudiantes a trav√©s del tutorial paso a paso."

#: src/android/interoperability/cpp.md:18
msgid ""
"Highlight how CXX presents a clean interface without unsafe code in _both "
"languages_."
msgstr ""
"Destaca c√≥mo CXX presenta una interfaz limpia sin c√≥digo inseguro en _ambos "
"lenguajes_."

#: src/android/interoperability/cpp.md:20
msgid ""
"Show the correspondence between [Rust and C++ types](https://cxx.rs/bindings."
"html):"
msgstr ""
"Muestra la correspondencia entre [los tipos de Rust y C++](https://cxx.rs/"
"bindings.html):"

#: src/android/interoperability/cpp.md:22
msgid ""
"Explain how a Rust `String` cannot map to a C++ `std::string` (the latter "
"does not uphold the UTF-8 invariant). Show that despite being different "
"types, `rust::String` in C++ can be easily constructed from a C++ `std::"
"string`, making it very ergonomic to use."
msgstr ""
"Explica que una `String` de Rust no puede asignarse a una `std::string` de C+"
"+ (esta √∫ltima no mantiene la invariante UTF-8). Muestra que, a pesar de ser "
"tipos diferentes, `rust::String` en C++ se puede construir f√°cilmente a "
"partir de una `std::string` de C++, lo que la hace muy ergon√≥mica de usar."

#: src/android/interoperability/cpp.md:28
msgid ""
"Explain that a Rust function returning `Result<T, E>` becomes a function "
"which throws a `E` exception in C++ (and vice versa)."
msgstr ""
"Explica que una funci√≥n de Rust que devuelve `Result<T, E>` se convierte en "
"una funci√≥n que lanza una excepci√≥n `E` en C++ (y viceversa)."

#: src/android/interoperability/java.md:1
msgid "Interoperability with Java"
msgstr "Interoperabilidad con Java"

#: src/android/interoperability/java.md:3
msgid ""
"Java can load shared objects via [Java Native Interface (JNI)](https://en."
"wikipedia.org/wiki/Java_Native_Interface). The [`jni` crate](https://docs.rs/"
"jni/) allows you to create a compatible library."
msgstr ""
"Java puede cargar objetos compartidos a trav√©s de la [interfaz nativa de "
"Java (JNI)](https://es.wikipedia.org/wiki/Java_Native_Interface). [El crate "
"`jni`](https://docs.rs/jni/) permite crear una biblioteca compatible."

#: src/android/interoperability/java.md:7
msgid "First, we create a Rust function to export to Java:"
msgstr "En primer lugar, creamos una funci√≥n de Rust para exportar a Java:"

#: src/android/interoperability/java.md:9
msgid "_interoperability/java/src/lib.rs_:"
msgstr "_interoperability/java/src/lib.rs_:"

#: src/android/interoperability/java.md:11
msgid ""
"```rust,compile_fail\n"
"//! Rust <-> Java FFI demo.\n"
"\n"
"use jni::objects::{JClass, JString};\n"
"use jni::sys::jstring;\n"
"use jni::JNIEnv;\n"
"\n"
"/// HelloWorld::hello method implementation.\n"
"#[no_mangle]\n"
"pub extern \"system\" fn Java_HelloWorld_hello(\n"
"    env: JNIEnv,\n"
"    _class: JClass,\n"
"    name: JString,\n"
") -> jstring {\n"
"    let input: String = env.get_string(name).unwrap().into();\n"
"    let greeting = format!(\"Hello, {input}!\");\n"
"    let output = env.new_string(greeting).unwrap();\n"
"    output.into_inner()\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:32
#: src/android/interoperability/java.md:62
msgid "_interoperability/java/Android.bp_:"
msgstr "_interoperability/java/Android.bp_:"

#: src/android/interoperability/java.md:34
msgid ""
"```javascript\n"
"rust_ffi_shared {\n"
"    name: \"libhello_jni\",\n"
"    crate_name: \"hello_jni\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    rustlibs: [\"libjni\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:43
msgid "Finally, we can call this function from Java:"
msgstr "Por √∫ltimo, podemos llamar a esta funci√≥n desde Java:"

#: src/android/interoperability/java.md:45
msgid "_interoperability/java/HelloWorld.java_:"
msgstr "_interoperability/java/HelloWorld.java_:"

#: src/android/interoperability/java.md:47
msgid ""
"```java\n"
"class HelloWorld {\n"
"    private static native String hello(String name);\n"
"\n"
"    static {\n"
"        System.loadLibrary(\"hello_jni\");\n"
"    }\n"
"\n"
"    public static void main(String[] args) {\n"
"        String output = HelloWorld.hello(\"Alice\");\n"
"        System.out.println(output);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:64
msgid ""
"```javascript\n"
"java_binary {\n"
"    name: \"helloworld_jni\",\n"
"    srcs: [\"HelloWorld.java\"],\n"
"    main_class: \"HelloWorld\",\n"
"    required: [\"libhello_jni\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:73
msgid "Finally, you can build, sync, and run the binary:"
msgstr "Ahora puedes compilar, sincronizar y ejecutar el binario:"

#: src/android/interoperability/java.md:75
msgid ""
"```shell\n"
"m helloworld_jni\n"
"adb sync  # requires adb root && adb remount\n"
"adb shell /system/bin/helloworld_jni\n"
"```"
msgstr ""

#: src/exercises/android/morning.md:3
msgid ""
"This is a group exercise: We will look at one of the projects you work with "
"and try to integrate some Rust into it. Some suggestions:"
msgstr ""
"Este es un ejercicio de grupo: escogeremos uno de los proyectos con los que "
"se est√© trabajando e intentaremos integrar Rust en √©l. Algunas sugerencias:"

#: src/exercises/android/morning.md:6
msgid "Call your AIDL service with a client written in Rust."
msgstr "Llama a tu servicio de AIDL con un cliente escrito en Rust."

#: src/exercises/android/morning.md:8
msgid "Move a function from your project to Rust and call it."
msgstr "Mueve una funci√≥n desde tu proyecto a Rust y ll√°mala."

#: src/exercises/android/morning.md:12
msgid ""
"No solution is provided here since this is open-ended: it relies on someone "
"in the class having a piece of code which you can turn in to Rust on the fly."
msgstr ""
"Aqu√≠ la soluci√≥n es abierta, ya que depende de que alguno de los asistentes "
"tenga un fragmento de c√≥digo que se pueda convertir en Rust sobre la marcha."

#: src/bare-metal.md:1
msgid "Welcome to Bare Metal Rust"
msgstr "Te damos la bienvenida a Bare Metal Rust"

#: src/bare-metal.md:3
msgid ""
"This is a standalone one-day course about bare-metal Rust, aimed at people "
"who are familiar with the basics of Rust (perhaps from completing the "
"Comprehensive Rust course), and ideally also have some experience with bare-"
"metal programming in some other language such as C."
msgstr ""
"Este es un curso independiente de un d√≠a sobre Rust bare-metal, dirigido a "
"personas que est√°n familiarizadas con los conceptos b√°sicos de Rust (tal vez "
"despu√©s de completar el curso Comprehensive Rust). Lo ideal ser√≠a que "
"tambi√©n tuvieran experiencia con la programaci√≥n bare-metal en otros "
"lenguajes, como C."

#: src/bare-metal.md:7
msgid ""
"Today we will talk about 'bare-metal' Rust: running Rust code without an OS "
"underneath us. This will be divided into several parts:"
msgstr ""
"Hoy vamos a hablar de Rust \"bare-metal\": ejecutar c√≥digo de Rust sin un "
"sistema operativo. Se dividir√° en varias partes:"

#: src/bare-metal.md:10
msgid "What is `no_std` Rust?"
msgstr "¬øQu√© es `no_std` en Rust?"

#: src/bare-metal.md:11
msgid "Writing firmware for microcontrollers."
msgstr "Escribir firmware para microcontroladores."

#: src/bare-metal.md:12
msgid "Writing bootloader / kernel code for application processors."
msgstr "Escribir c√≥digo bootloader o kernel para procesadores de aplicaciones."

#: src/bare-metal.md:13
msgid "Some useful crates for bare-metal Rust development."
msgstr "Algunos crates √∫tiles para el desarrollo de Rust bare-metal."

#: src/bare-metal.md:15
msgid ""
"For the microcontroller part of the course we will use the [BBC micro:bit]"
"(https://microbit.org/) v2 as an example. It's a [development board](https://"
"tech.microbit.org/hardware/) based on the Nordic nRF51822 microcontroller "
"with some LEDs and buttons, an I2C-connected accelerometer and compass, and "
"an on-board SWD debugger."
msgstr ""
"En la parte del curso dedicada a los microcontroladores, utilizaremos la "
"versi√≥n 2 de [BBC micro:bit](https://microbit.org/) como ejemplo. Es una "
"[placa de desarrollo](https://tech.microbit.org/hardware/) basada en el "
"microcontrolador Nordic nRF51822 con algunos LED y botones, un aceler√≥metro "
"y una br√∫jula conectados mediante I2C y un depurador SWD integrado."

#: src/bare-metal.md:20
msgid ""
"To get started, install some tools we'll need later. On gLinux or Debian:"
msgstr ""
"Para empezar, instala algunas de las herramientas que necesitar√°s m√°s "
"adelante. En gLinux o Debian:"

#: src/bare-metal.md:22
msgid ""
"```bash\n"
"sudo apt install gcc-aarch64-linux-gnu gdb-multiarch libudev-dev picocom pkg-"
"config qemu-system-arm\n"
"rustup update\n"
"rustup target add aarch64-unknown-none thumbv7em-none-eabihf\n"
"rustup component add llvm-tools-preview\n"
"cargo install cargo-binutils cargo-embed\n"
"```"
msgstr ""
"```bash\n"
"sudo apt install gcc-aarch64-linux-gnu gdb-multiarch libudev-dev picocom pkg-"
"config qemu-system-arm\n"
"rustup update\n"
"rustup target add aarch64-unknown-none thumbv7em-none-eabihf\n"
"rustup component add llvm-tools-preview\n"
"cargo install cargo-binutils cargo-embed\n"
"```"

#: src/bare-metal.md:30
msgid ""
"And give users in the `plugdev` group access to the micro:bit programmer:"
msgstr ""
"Permite a los usuarios del grupo `plugdev` acceder al programador micro:bit:"

#: src/bare-metal.md:32
msgid ""
"```bash\n"
"echo 'SUBSYSTEM==\"usb\", ATTR{idVendor}==\"0d28\", MODE=\"0664\", "
"GROUP=\"plugdev\"' |\\\n"
"  sudo tee /etc/udev/rules.d/50-microbit.rules\n"
"sudo udevadm control --reload-rules\n"
"```"
msgstr ""
"```bash\n"
"echo 'SUBSYSTEM==\"usb\", ATTR{idVendor}==\"0d28\", MODE=\"0664\", "
"GROUP=\"plugdev\"' |\\\n"
"  sudo tee /etc/udev/rules.d/50-microbit.rules\n"
"sudo udevadm control --reload-rules\n"
"```"

#: src/bare-metal.md:38
msgid "On MacOS:"
msgstr "En MacOS:"

#: src/bare-metal.md:40
msgid ""
"```bash\n"
"xcode-select --install\n"
"brew install gdb picocom qemu\n"
"brew install --cask gcc-aarch64-embedded\n"
"rustup update\n"
"rustup target add aarch64-unknown-none thumbv7em-none-eabihf\n"
"rustup component add llvm-tools-preview\n"
"cargo install cargo-binutils cargo-embed\n"
"```"
msgstr ""
"```bash\n"
"xcode-select --install\n"
"brew install gdb picocom qemu\n"
"brew install --cask gcc-aarch64-embedded\n"
"rustup update\n"
"rustup target add aarch64-unknown-none thumbv7em-none-eabihf\n"
"rustup component add llvm-tools-preview\n"
"cargo install cargo-binutils cargo-embed\n"
"```"

#: src/bare-metal/no_std.md:1
msgid "`no_std`"
msgstr "`no_std`"

#: src/bare-metal/no_std.md:7
msgid "`core`"
msgstr "`core`"

#: src/bare-metal/no_std.md:12 src/bare-metal/alloc.md:1
msgid "`alloc`"
msgstr "`alloc`"

#: src/bare-metal/no_std.md:17
msgid "`std`"
msgstr "`std`"

#: src/bare-metal/no_std.md:24
msgid "Slices, `&str`, `CStr`"
msgstr "Slices, `&str`, `CStr`"

#: src/bare-metal/no_std.md:25
msgid "`NonZeroU8`..."
msgstr "`NonZeroU8`..."

#: src/bare-metal/no_std.md:26
msgid "`Option`, `Result`"
msgstr "`Option`, `Result`"

#: src/bare-metal/no_std.md:27
msgid "`Display`, `Debug`, `write!`..."
msgstr "`Display`, `Debug`, `write!`..."

#: src/bare-metal/no_std.md:29
msgid "`panic!`, `assert_eq!`..."
msgstr "`panic!`, `assert_eq!`..."

#: src/bare-metal/no_std.md:30
msgid "`NonNull` and all the usual pointer-related functions"
msgstr "`NonNull` y todas las funciones relacionadas con punteros habituales"

#: src/bare-metal/no_std.md:31
msgid "`Future` and `async`/`await`"
msgstr "`Future` and `async`/`await`"

#: src/bare-metal/no_std.md:32
msgid "`fence`, `AtomicBool`, `AtomicPtr`, `AtomicU32`..."
msgstr "`fence`, `AtomicBool`, `AtomicPtr`, `AtomicU32`..."

#: src/bare-metal/no_std.md:33
msgid "`Duration`"
msgstr "`Duration`"

#: src/bare-metal/no_std.md:38
msgid "`Box`, `Cow`, `Arc`, `Rc`"
msgstr "`Box`, `Cow`, `Arc`, `Rc`"

#: src/bare-metal/no_std.md:39
msgid "`Vec`, `BinaryHeap`, `BtreeMap`, `LinkedList`, `VecDeque`"
msgstr "`Vec`, `BinaryHeap`, `BtreeMap`, `LinkedList`, `VecDeque`"

#: src/bare-metal/no_std.md:40
msgid "`String`, `CString`, `format!`"
msgstr "`String`, `CString`, `format!`"

#: src/bare-metal/no_std.md:45
msgid "`Error`"
msgstr "`Error`"

#: src/bare-metal/no_std.md:47
msgid "`Mutex`, `Condvar`, `Barrier`, `Once`, `RwLock`, `mpsc`"
msgstr "`Mutex`, `Condvar`, `Barrier`, `Once`, `RwLock`, `mpsc`"

#: src/bare-metal/no_std.md:48
msgid "`File` and the rest of `fs`"
msgstr "`File` y el resto de `fs`"

#: src/bare-metal/no_std.md:49
msgid "`println!`, `Read`, `Write`, `Stdin`, `Stdout` and the rest of `io`"
msgstr "`println!`, `Read`, `Write`, `Stdin`, `Stdout` y el resto de `io`"

#: src/bare-metal/no_std.md:50
msgid "`Path`, `OsString`"
msgstr "`Path`, `OsString`"

#: src/bare-metal/no_std.md:51
msgid "`net`"
msgstr "`net`"

#: src/bare-metal/no_std.md:52
msgid "`Command`, `Child`, `ExitCode`"
msgstr "`Command`, `Child`, `ExitCode`"

#: src/bare-metal/no_std.md:53
msgid "`spawn`, `sleep` and the rest of `thread`"
msgstr "`spawn`, `sleep` y el resto de `thread`"

#: src/bare-metal/no_std.md:54
msgid "`SystemTime`, `Instant`"
msgstr "`SystemTime`, `Instant`"

#: src/bare-metal/no_std.md:62
msgid "`HashMap` depends on RNG."
msgstr "`HashMap` depende de RNG."

#: src/bare-metal/no_std.md:63
msgid "`std` re-exports the contents of both `core` and `alloc`."
msgstr "`std` vuelve a exportar el contenido de `core` y `alloc`."

#: src/bare-metal/minimal.md:1
msgid "A minimal `no_std` program"
msgstr "Un programa `no_std` m√≠nimo"

#: src/bare-metal/minimal.md:3
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"use core::panic::PanicInfo;\n"
"\n"
"#[panic_handler]\n"
"fn panic(_panic: &PanicInfo) -> ! {\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"use core::panic::PanicInfo;\n"
"\n"
"#[panic_handler]\n"
"fn panic(_panic: &PanicInfo) -> ! {\n"
"    loop {}\n"
"}\n"
"```"

#: src/bare-metal/minimal.md:17
msgid "This will compile to an empty binary."
msgstr "Se compilar√° en un binario vac√≠o."

#: src/bare-metal/minimal.md:18
msgid "`std` provides a panic handler; without it we must provide our own."
msgstr ""
"`std` proporciona un controlador de _panic_; sin no hay, debemos "
"proporcionar uno nuestro."

#: src/bare-metal/minimal.md:19
msgid "It can also be provided by another crate, such as `panic-halt`."
msgstr "Tambi√©n puede proporcionarlo otro crate, como `panic-halt`."

#: src/bare-metal/minimal.md:20
msgid ""
"Depending on the target, you may need to compile with `panic = \"abort\"` to "
"avoid an error about `eh_personality`."
msgstr ""
"Dependiendo del objetivo, es posible que tengas que compilar con `panic = "
"\"abort\"` para evitar un error sobre `eh_personality`."

#: src/bare-metal/minimal.md:22
msgid ""
"Note that there is no `main` or any other entry point; it's up to you to "
"define your own entry point. This will typically involve a linker script and "
"some assembly code to set things up ready for Rust code to run."
msgstr ""
"Ten en cuenta que no hay `main` ni ning√∫n otro punto de entrada; depende de "
"ti definir un punto de entrada propio. Esto suele implicar una secuencia de "
"comandos de enlazador y alg√∫n c√≥digo de ensamblado de forma que todo est√© "
"preparado para que se ejecute el c√≥digo de Rust."

#: src/bare-metal/alloc.md:3
msgid ""
"To use `alloc` you must implement a [global (heap) allocator](https://doc."
"rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html)."
msgstr ""
"Para utilizar `alloc`, debes implementar un [asignador global (de _heap_)]"
"(https://doc.rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html)."

#: src/bare-metal/alloc.md:6
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate alloc;\n"
"extern crate panic_halt as _;\n"
"\n"
"use alloc::string::ToString;\n"
"use alloc::vec::Vec;\n"
"use buddy_system_allocator::LockedHeap;\n"
"\n"
"#[global_allocator]\n"
"static HEAP_ALLOCATOR: LockedHeap<32> = LockedHeap::<32>::new();\n"
"\n"
"static mut HEAP: [u8; 65536] = [0; 65536];\n"
"\n"
"pub fn entry() {\n"
"    // Safe because `HEAP` is only used here and `entry` is only called "
"once.\n"
"    unsafe {\n"
"        // Give the allocator some memory to allocate.\n"
"        HEAP_ALLOCATOR\n"
"            .lock()\n"
"            .init(HEAP.as_mut_ptr() as usize, HEAP.len());\n"
"    }\n"
"\n"
"    // Now we can do things that require heap allocation.\n"
"    let mut v = Vec::new();\n"
"    v.push(\"A string\".to_string());\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate alloc;\n"
"extern crate panic_halt as _;\n"
"\n"
"use alloc::string::ToString;\n"
"use alloc::vec::Vec;\n"
"use buddy_system_allocator::LockedHeap;\n"
"\n"
"#[global_allocator]\n"
"static HEAP_ALLOCATOR: LockedHeap<32> = LockedHeap::<32>::new();\n"
"\n"
"static mut HEAP: [u8; 65536] = [0; 65536];\n"
"\n"
"pub fn entry() {\n"
"    // Safe because `HEAP` is only used here and `entry` is only called "
"once.\n"
"    unsafe {\n"
"        // Give the allocator some memory to allocate.\n"
"        HEAP_ALLOCATOR\n"
"            .lock()\n"
"            .init(HEAP.as_mut_ptr() as usize, HEAP.len());\n"
"    }\n"
"\n"
"    // Ahora podemos hacer cosas que requieran asignaci√≥n de _heap_.\n"
"    let mut v = Vec::new();\n"
"    v.push(\"A string\".to_string());\n"
"}\n"
"```"

#: src/bare-metal/alloc.md:39
msgid ""
"`buddy_system_allocator` is a third-party crate implementing a basic buddy "
"system allocator. Other crates are available, or you can write your own or "
"hook into your existing allocator."
msgstr ""
"`buddy_system_allocator` es un crate de terceros que implementa un _buddy "
"system allocator_ (una t√©cnica de asignaci√≥n de memoria) b√°sico. Hay otros "
"crates disponibles, pero tambi√©n puedes escribir el tuyo propio o conectarte "
"a tu asignador."

#: src/bare-metal/alloc.md:41
msgid ""
"The const parameter of `LockedHeap` is the max order of the allocator; i.e. "
"in this case it can allocate regions of up to 2\\*\\*32 bytes."
msgstr ""
"El par√°metro const de `LockedHeap` es el orden m√°ximo del asignador. Es "
"decir, en este caso, puede asignar regiones de hasta 2\\*\\*32 bytes."

#: src/bare-metal/alloc.md:43
msgid ""
"If any crate in your dependency tree depends on `alloc` then you must have "
"exactly one global allocator defined in your binary. Usually this is done in "
"the top-level binary crate."
msgstr ""
"Si alg√∫n crate del √°rbol de dependencias depende de `alloc`, debes tener "
"exactamente un asignador global definido en el binario. Esto se suele hacer "
"en el crate binario de nivel superior."

#: src/bare-metal/alloc.md:45
msgid ""
"`extern crate panic_halt as _` is necessary to ensure that the `panic_halt` "
"crate is linked in so we get its panic handler."
msgstr ""
"`extern crate panic_halt as _` es necesario para asegurar que el crate "
"`panic_halt` est√© vinculado y as√≠ podamos obtener su controlador de _panic_."

#: src/bare-metal/alloc.md:47
msgid "This example will build but not run, as it doesn't have an entry point."
msgstr ""
"Este ejemplo se compilar√° pero no se ejecutar√°, ya que no cuenta con un "
"punto de entrada."

#: src/bare-metal/microcontrollers.md:3
msgid ""
"The `cortex_m_rt` crate provides (among other things) a reset handler for "
"Cortex M microcontrollers."
msgstr ""
"El crate `cortex_m_rt` proporciona (entre otras cosas) un controlador de "
"reinicio para microcontroladores Cortex M."

#: src/bare-metal/microcontrollers.md:5
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"mod interrupts;\n"
"\n"
"use cortex_m_rt::entry;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers.md:21
msgid ""
"Next we'll look at how to access peripherals, with increasing levels of "
"abstraction."
msgstr ""
"A continuaci√≥n, veremos c√≥mo se accede a los perif√©ricos con niveles de "
"abstracci√≥n cada vez mayores."

#: src/bare-metal/microcontrollers.md:25
msgid ""
"The `cortex_m_rt::entry` macro requires that the function have type `fn() -"
"> !`, because returning to the reset handler doesn't make sense."
msgstr ""
"La macro `cortex_m_rt::entry` requiere que la funci√≥n tenga el tipo `fn() -"
"> !`, ya que no tiene sentido devolver resultados al controlador de reinicio."

#: src/bare-metal/microcontrollers.md:27
msgid "Run the example with `cargo embed --bin minimal`"
msgstr "Ejecuta el ejemplo con `cargo embed --bin minimal`."

#: src/bare-metal/microcontrollers/mmio.md:3
msgid ""
"Most microcontrollers access peripherals via memory-mapped IO. Let's try "
"turning on an LED on our micro:bit:"
msgstr ""
"La mayor√≠a de los microcontroladores acceden a los perif√©ricos a trav√©s de E/"
"S asignada a la memoria. Vamos a probar a encender un LED en nuestro micro:"
"bit:"

#: src/bare-metal/microcontrollers/mmio.md:6
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"mod interrupts;\n"
"\n"
"use core::mem::size_of;\n"
"use cortex_m_rt::entry;\n"
"\n"
"/// GPIO port 0 peripheral address\n"
"const GPIO_P0: usize = 0x5000_0000;\n"
"\n"
"// GPIO peripheral offsets\n"
"const PIN_CNF: usize = 0x700;\n"
"const OUTSET: usize = 0x508;\n"
"const OUTCLR: usize = 0x50c;\n"
"\n"
"// PIN_CNF fields\n"
"const DIR_OUTPUT: u32 = 0x1;\n"
"const INPUT_DISCONNECT: u32 = 0x1 << 1;\n"
"const PULL_DISABLED: u32 = 0x0 << 2;\n"
"const DRIVE_S0S1: u32 = 0x0 << 8;\n"
"const SENSE_DISABLED: u32 = 0x0 << 16;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
"    let pin_cnf_21 = (GPIO_P0 + PIN_CNF + 21 * size_of::<u32>()) as *mut "
"u32;\n"
"    let pin_cnf_28 = (GPIO_P0 + PIN_CNF + 28 * size_of::<u32>()) as *mut "
"u32;\n"
"    // Safe because the pointers are to valid peripheral control registers, "
"and\n"
"    // no aliases exist.\n"
"    unsafe {\n"
"        pin_cnf_21.write_volatile(\n"
"            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | "
"SENSE_DISABLED,\n"
"        );\n"
"        pin_cnf_28.write_volatile(\n"
"            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | "
"SENSE_DISABLED,\n"
"        );\n"
"    }\n"
"\n"
"    // Set pin 28 low and pin 21 high to turn the LED on.\n"
"    let gpio0_outset = (GPIO_P0 + OUTSET) as *mut u32;\n"
"    let gpio0_outclr = (GPIO_P0 + OUTCLR) as *mut u32;\n"
"    // Safe because the pointers are to valid peripheral control registers, "
"and\n"
"    // no aliases exist.\n"
"    unsafe {\n"
"        gpio0_outclr.write_volatile(1 << 28);\n"
"        gpio0_outset.write_volatile(1 << 21);\n"
"    }\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:64
msgid ""
"GPIO 0 pin 21 is connected to the first column of the LED matrix, and pin 28 "
"to the first row."
msgstr ""
"El pin 21 de GPIO 0 est√° conectado a la primera columna de la matriz de LED "
"y el pin 28 a la primera fila."

#: src/bare-metal/microcontrollers/mmio.md:66
#: src/bare-metal/microcontrollers/pacs.md:59
#: src/bare-metal/microcontrollers/hals.md:43
#: src/bare-metal/microcontrollers/board-support.md:34
msgid "Run the example with:"
msgstr "Ejecuta el ejemplo con:"

#: src/bare-metal/microcontrollers/mmio.md:68
msgid ""
"```sh\n"
"cargo embed --bin mmio\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/pacs.md:1
msgid "Peripheral Access Crates"
msgstr "Crates de Acceso Perif√©rico"

#: src/bare-metal/microcontrollers/pacs.md:3
msgid ""
"[`svd2rust`](https://crates.io/crates/svd2rust) generates mostly-safe Rust "
"wrappers for memory-mapped peripherals from [CMSIS-SVD](https://www.keil.com/"
"pack/doc/CMSIS/SVD/html/index.html) files."
msgstr ""
"[`svd2rust`](https://crates.io/crates/svd2rust) genera, en su gran mayor√≠a, "
"envoltorios seguros de Rust para perif√©ricos asignados a la memoria a partir "
"de archivos [CMSIS-SVD](https://www.keil.com/pack/doc/CMSIS/SVD/html/index."
"html)."

#: src/bare-metal/microcontrollers/pacs.md:7
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use cortex_m_rt::entry;\n"
"use nrf52833_pac::Peripherals;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let p = Peripherals::take().unwrap();\n"
"    let gpio0 = p.P0;\n"
"\n"
"    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
"    gpio0.pin_cnf[21].write(|w| {\n"
"        w.dir().output();\n"
"        w.input().disconnect();\n"
"        w.pull().disabled();\n"
"        w.drive().s0s1();\n"
"        w.sense().disabled();\n"
"        w\n"
"    });\n"
"    gpio0.pin_cnf[28].write(|w| {\n"
"        w.dir().output();\n"
"        w.input().disconnect();\n"
"        w.pull().disabled();\n"
"        w.drive().s0s1();\n"
"        w.sense().disabled();\n"
"        w\n"
"    });\n"
"\n"
"    // Set pin 28 low and pin 21 high to turn the LED on.\n"
"    gpio0.outclr.write(|w| w.pin28().clear());\n"
"    gpio0.outset.write(|w| w.pin21().set());\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/pacs.md:49
msgid ""
"SVD (System View Description) files are XML files typically provided by "
"silicon vendors which describe the memory map of the device."
msgstr ""
"Los archivos SVD (System View Description) son archivos XML que suelen "
"proporcionar los proveedores de silicio y que describen el mapa de memoria "
"del dispositivo."

#: src/bare-metal/microcontrollers/pacs.md:51
msgid ""
"They are organised by peripheral, register, field and value, with names, "
"descriptions, addresses and so on."
msgstr ""
"Se organizan por perif√©rico, registro, campo y valor, con nombres, "
"descripciones y direcciones, etc."

#: src/bare-metal/microcontrollers/pacs.md:53
msgid ""
"SVD files are often buggy and incomplete, so there are various projects "
"which patch the mistakes, add missing details, and publish the generated "
"crates."
msgstr ""
"Los archivos SVD suelen tener errores y estar incompletos, por lo que "
"existen varios proyectos que aplican parches a los errores, a√±aden detalles "
"que faltan y publican los crates generados."

#: src/bare-metal/microcontrollers/pacs.md:55
msgid "`cortex-m-rt` provides the vector table, among other things."
msgstr "`cortex-m-rt` proporciona la tabla de vectores, entre otras cosas."

#: src/bare-metal/microcontrollers/pacs.md:56
msgid ""
"If you `cargo install cargo-binutils` then you can run `cargo objdump --bin "
"pac -- -d --no-show-raw-insn` to see the resulting binary."
msgstr ""
"Si instalas `cargo install cargo-binutils` puedes ejecutar `cargo objdump --"
"bin pac -- -d --no-show-raw-insn` para ver el binario resultante."

#: src/bare-metal/microcontrollers/pacs.md:61
msgid ""
"```sh\n"
"cargo embed --bin pac\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/hals.md:1
msgid "HAL crates"
msgstr "Crates HAL"

#: src/bare-metal/microcontrollers/hals.md:3
msgid ""
"[HAL crates](https://github.com/rust-embedded/awesome-embedded-rust#hal-"
"implementation-crates) for many microcontrollers provide wrappers around "
"various peripherals. These generally implement traits from [`embedded-hal`]"
"(https://crates.io/crates/embedded-hal)."
msgstr ""
"[Los crates HAL](https://github.com/rust-embedded/awesome-embedded-rust#hal-"
"implementation-crates) de muchos microcontroladores incluyen envoltorios "
"alrededor de varios perif√©ricos. Por lo general, implementan traits de "
"[`embedded-hal`](https://crates.io/crates/embedded-hal)."

#: src/bare-metal/microcontrollers/hals.md:7
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use cortex_m_rt::entry;\n"
"use nrf52833_hal::gpio::{p0, Level};\n"
"use nrf52833_hal::pac::Peripherals;\n"
"use nrf52833_hal::prelude::*;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let p = Peripherals::take().unwrap();\n"
"\n"
"    // Create HAL wrapper for GPIO port 0.\n"
"    let gpio0 = p0::Parts::new(p.P0);\n"
"\n"
"    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
"    let mut col1 = gpio0.p0_28.into_push_pull_output(Level::High);\n"
"    let mut row1 = gpio0.p0_21.into_push_pull_output(Level::Low);\n"
"\n"
"    // Set pin 28 low and pin 21 high to turn the LED on.\n"
"    col1.set_low().unwrap();\n"
"    row1.set_high().unwrap();\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/hals.md:39
msgid ""
"`set_low` and `set_high` are methods on the `embedded_hal` `OutputPin` trait."
msgstr ""
"`set_low` y `set_high` son m√©todos del trait `OutputPin` de `embedded_hal`."

#: src/bare-metal/microcontrollers/hals.md:40
msgid ""
"HAL crates exist for many Cortex-M and RISC-V devices, including various "
"STM32, GD32, nRF, NXP, MSP430, AVR and PIC microcontrollers."
msgstr ""
"Hay crates HAL para muchos dispositivos Cortex-M y RISC-V, incluidos varios "
"microcontroladores STM32, GD32, nRF, NXP, MSP430, AVR y PIC."

#: src/bare-metal/microcontrollers/hals.md:45
msgid ""
"```sh\n"
"cargo embed --bin hal\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/board-support.md:1
msgid "Board support crates"
msgstr "Crates de compatibilidad de placa"

#: src/bare-metal/microcontrollers/board-support.md:3
msgid ""
"Board support crates provide a further level of wrapping for a specific "
"board for convenience."
msgstr ""
"Los crates de compatibilidad de placa proporcionan un nivel adicional de "
"envoltorio a una placa espec√≠fica para mayor comodidad."

#: src/bare-metal/microcontrollers/board-support.md:5
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use cortex_m_rt::entry;\n"
"use microbit::hal::prelude::*;\n"
"use microbit::Board;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let mut board = Board::take().unwrap();\n"
"\n"
"    board.display_pins.col1.set_low().unwrap();\n"
"    board.display_pins.row1.set_high().unwrap();\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/board-support.md:28
msgid ""
"In this case the board support crate is just providing more useful names, "
"and a bit of initialisation."
msgstr ""
"En este caso, el crate de compatibilidad de placa proporciona solo nombres "
"m√°s √∫tiles y un poco de inicializaci√≥n."

#: src/bare-metal/microcontrollers/board-support.md:30
msgid ""
"The crate may also include drivers for some on-board devices outside of the "
"microcontroller itself."
msgstr ""
"El crate tambi√©n puede incluir controladores para algunos dispositivos "
"integrados fuera del propio microcontrolador ."

#: src/bare-metal/microcontrollers/board-support.md:32
msgid "`microbit-v2` includes a simple driver for the LED matrix."
msgstr "`microbit-v2` incluye un controlador sencillo para la matriz de LED."

#: src/bare-metal/microcontrollers/board-support.md:36
msgid ""
"```sh\n"
"cargo embed --bin board_support\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/type-state.md:1
msgid "The type state pattern"
msgstr "El patr√≥n de tipo de estado"

#: src/bare-metal/microcontrollers/type-state.md:3
msgid ""
"```rust,editable,compile_fail\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let p = Peripherals::take().unwrap();\n"
"    let gpio0 = p0::Parts::new(p.P0);\n"
"\n"
"    let pin: P0_01<Disconnected> = gpio0.p0_01;\n"
"\n"
"    // let gpio0_01_again = gpio0.p0_01; // Error, moved.\n"
"    let pin_input: P0_01<Input<Floating>> = pin.into_floating_input();\n"
"    if pin_input.is_high().unwrap() {\n"
"        // ...\n"
"    }\n"
"    let mut pin_output: P0_01<Output<OpenDrain>> = pin_input\n"
"        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, "
"Level::Low);\n"
"    pin_output.set_high().unwrap();\n"
"    // pin_input.is_high(); // Error, moved.\n"
"\n"
"    let _pin2: P0_02<Output<OpenDrain>> = gpio0\n"
"        .p0_02\n"
"        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, "
"Level::Low);\n"
"    let _pin3: P0_03<Output<PushPull>> = gpio0.p0_03."
"into_push_pull_output(Level::Low);\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/type-state.md:32
msgid ""
"Pins don't implement `Copy` or `Clone`, so only one instance of each can "
"exist. Once a pin is moved out of the port struct nobody else can take it."
msgstr ""
"Los pines no implementan `Copy` ni `Clone`, por lo que solo puede haber una "
"instancia de cada uno. Cuando se quita un pin de la estructura del puerto, "
"nadie m√°s puede usarlo."

#: src/bare-metal/microcontrollers/type-state.md:34
msgid ""
"Changing the configuration of a pin consumes the old pin instance, so you "
"can‚Äôt keep use the old instance afterwards."
msgstr ""
"Si cambias la configuraci√≥n de un pin, se consumir√° la instancia del pin "
"anterior y no podr√°s seguir usando la instancia previa."

#: src/bare-metal/microcontrollers/type-state.md:36
msgid ""
"The type of a value indicates the state that it is in: e.g. in this case, "
"the configuration state of a GPIO pin. This encodes the state machine into "
"the type system, and ensures that you don't try to use a pin in a certain "
"way without properly configuring it first. Illegal state transitions are "
"caught at compile time."
msgstr ""
"El tipo de un valor indica el estado en el que se encuentra: por ejemplo, en "
"este caso, el estado de configuraci√≥n de un pin de GPIO. De esta manera, se "
"codifica la m√°quina de estados en el sistema de tipos, asegurando as√≠ que no "
"se use un pin de cierta forma sin antes configurarlo correctamente. Las "
"transiciones de estado ilegales se detectan durante el tiempo de compilaci√≥n."

#: src/bare-metal/microcontrollers/type-state.md:40
msgid ""
"You can call `is_high` on an input pin and `set_high` on an output pin, but "
"not vice-versa."
msgstr ""
"Puedes llamar a `is_high` en un pin de entrada y a `set_high` en un pin de "
"salida, pero no al rev√©s."

#: src/bare-metal/microcontrollers/type-state.md:41
msgid "Many HAL crates follow this pattern."
msgstr "Muchos crates HAL siguen este patr√≥n."

#: src/bare-metal/microcontrollers/embedded-hal.md:1
msgid "`embedded-hal`"
msgstr "`embedded-hal`"

#: src/bare-metal/microcontrollers/embedded-hal.md:3
msgid ""
"The [`embedded-hal`](https://crates.io/crates/embedded-hal) crate provides a "
"number of traits covering common microcontroller peripherals."
msgstr ""
"El crate [`embedded-hal`](https://crates.io/crates/embedded-hal) proporciona "
"una serie de traits que cubren los perif√©ricos habituales de los "
"microcontroladores."

#: src/bare-metal/microcontrollers/embedded-hal.md:6
msgid "GPIO"
msgstr "GPIO"

#: src/bare-metal/microcontrollers/embedded-hal.md:7
msgid "ADC"
msgstr "ADC"

#: src/bare-metal/microcontrollers/embedded-hal.md:8
msgid "I2C, SPI, UART, CAN"
msgstr "I2C, SPI, UART, CAN"

#: src/bare-metal/microcontrollers/embedded-hal.md:9
msgid "RNG"
msgstr "RNG"

#: src/bare-metal/microcontrollers/embedded-hal.md:10
msgid "Timers"
msgstr "Temporizadores"

#: src/bare-metal/microcontrollers/embedded-hal.md:11
msgid "Watchdogs"
msgstr "Watchdogs"

#: src/bare-metal/microcontrollers/embedded-hal.md:13
msgid ""
"Other crates then implement [drivers](https://github.com/rust-embedded/"
"awesome-embedded-rust#driver-crates) in terms of these traits, e.g. an "
"accelerometer driver might need an I2C or SPI bus implementation."
msgstr ""
"Es entonces cuando otros crates implementan \\[controladores\\][drivers]"
"(https://github.com/rust-embedded/awesome-embedded-rust#driver-crates) en "
"funci√≥n de estos traits. Por ejemplo, un controlador de aceler√≥metro podr√≠a "
"necesitar una implementaci√≥n de bus I2C o SPI."

#: src/bare-metal/microcontrollers/embedded-hal.md:19
msgid ""
"There are implementations for many microcontrollers, as well as other "
"platforms such as Linux on Raspberry Pi."
msgstr ""
"Hay implementaciones para muchos microcontroladores, as√≠ como otras "
"plataformas como Linux en Raspberry Pi."

#: src/bare-metal/microcontrollers/embedded-hal.md:21
msgid ""
"There is work in progress on an `async` version of `embedded-hal`, but it "
"isn't stable yet."
msgstr ""
"Se est√° trabajando en una versi√≥n `async` de `embedded-hal`, pero a√∫n no es "
"estable."

#: src/bare-metal/microcontrollers/probe-rs.md:1
msgid "`probe-rs`, `cargo-embed`"
msgstr "`probe-rs`, `cargo-embed`"

#: src/bare-metal/microcontrollers/probe-rs.md:3
msgid ""
"[probe-rs](https://probe.rs/) is a handy toolset for embedded debugging, "
"like OpenOCD but better integrated."
msgstr ""
"[probe-rs](https://probe.rs/) es un conjunto de herramientas de depuraci√≥n "
"integradas muy √∫til, como OpenOCD, pero mejor integrado."

#: src/bare-metal/microcontrollers/probe-rs.md:6
msgid "SWD"
msgstr "SWD"

#: src/bare-metal/microcontrollers/probe-rs.md:6
msgid " and JTAG via CMSIS-DAP, ST-Link and J-Link probes"
msgstr " y JTAG a trav√©s de comprobaciones CMSIS-DAP, ST-Link y J-Link"

#: src/bare-metal/microcontrollers/probe-rs.md:7
msgid "GDB stub and Microsoft "
msgstr "GDB stub y el servidor "

#: src/bare-metal/microcontrollers/probe-rs.md:7
msgid "DAP"
msgstr "DAP"

#: src/bare-metal/microcontrollers/probe-rs.md:7
msgid " server"
msgstr " de Microsoft"

#: src/bare-metal/microcontrollers/probe-rs.md:8
msgid "Cargo integration"
msgstr "Integraci√≥n de Cargo"

#: src/bare-metal/microcontrollers/probe-rs.md:10
msgid "`cargo-embed` is a cargo subcommand to build and flash binaries, log "
msgstr ""
"`cargo-embed` es un subcomando de Cargo para compilar e instalar binarios, "
"registrar salidas "

#: src/bare-metal/microcontrollers/probe-rs.md:11
msgid "RTT"
msgstr "TTR"

#: src/bare-metal/microcontrollers/probe-rs.md:11
msgid ""
" output and connect GDB. It's configured by an `Embed.toml` file in your "
"project directory."
msgstr ""
" y conectar GDB. Se configura mediante un archivo `Embed.toml` en el "
"directorio del proyecto."

#: src/bare-metal/microcontrollers/probe-rs.md:16
msgid ""
"[CMSIS-DAP](https://arm-software.github.io/CMSIS_5/DAP/html/index.html) is "
"an Arm standard protocol over USB for an in-circuit debugger to access the "
"CoreSight Debug Access Port of various Arm Cortex processors. It's what the "
"on-board debugger on the BBC micro:bit uses."
msgstr ""
"[CMSIS-DAP](https://arm-software.github.io/CMSIS_5/DAP/html/index.html) es "
"un protocolo est√°ndar de Arm mediante USB que permite que un depurador en "
"circuito acceda al puerto de acceso de depuraci√≥n CoreSight de varios "
"procesadores Cortex de Arm. Es lo que utiliza el depurador integrado en el "
"BBC micro:bit"

#: src/bare-metal/microcontrollers/probe-rs.md:19
msgid ""
"ST-Link is a range of in-circuit debuggers from ST Microelectronics, J-Link "
"is a range from SEGGER."
msgstr ""
"ST-Link es una gama de depuradores en circuito de ST Microelectronics. J-"
"Link es una gama de SEGGER."

#: src/bare-metal/microcontrollers/probe-rs.md:21
msgid ""
"The Debug Access Port is usually either a 5-pin JTAG interface or 2-pin "
"Serial Wire Debug."
msgstr ""
"El puerto de acceso de depuraci√≥n suele ser una interfaz JTAG de 5 pines o "
"una SWD de 2 pines."

#: src/bare-metal/microcontrollers/probe-rs.md:22
msgid ""
"probe-rs is a library which you can integrate into your own tools if you "
"want to."
msgstr ""
"probe-rs es una biblioteca que puedes integrar en tus propias herramientas."

#: src/bare-metal/microcontrollers/probe-rs.md:23
msgid ""
"The [Microsoft Debug Adapter Protocol](https://microsoft.github.io/debug-"
"adapter-protocol/) lets VSCode and other IDEs debug code running on any "
"supported microcontroller."
msgstr ""
"[El protocolo de adaptador de depuraci√≥n de Microsoft](https://microsoft."
"github.io/debug-adapter-protocol/) permite que VSCode y otros IDEs depuren "
"el c√≥digo que se ejecuta en cualquier microcontrolador compatible."

#: src/bare-metal/microcontrollers/probe-rs.md:25
msgid "cargo-embed is a binary built using the probe-rs library."
msgstr "cargo-embed es un binario compilado con la biblioteca probe-rs."

#: src/bare-metal/microcontrollers/probe-rs.md:26
msgid ""
"RTT (Real Time Transfers) is a mechanism to transfer data between the debug "
"host and the target through a number of ringbuffers."
msgstr ""
"TTR (transferencias en tiempo real) es un mecanismo para transferir datos "
"entre el host de depuraci√≥n y el objetivo a trav√©s de una serie de b√∫feres "
"circulares."

#: src/bare-metal/microcontrollers/debugging.md:3
msgid "Embed.toml:"
msgstr "Embed.toml:"

#: src/bare-metal/microcontrollers/debugging.md:5
msgid ""
"```toml\n"
"[default.general]\n"
"chip = \"nrf52833_xxAA\"\n"
"\n"
"[debug.gdb]\n"
"enabled = true\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md:13
msgid "In one terminal under `src/bare-metal/microcontrollers/examples/`:"
msgstr "En un terminal en `src/bare-metal/microcontrollers/examples/`:"

#: src/bare-metal/microcontrollers/debugging.md:15
msgid ""
"```sh\n"
"cargo embed --bin board_support debug\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md:19
msgid "In another terminal in the same directory:"
msgstr "En otro terminal del mismo directorio:"

#: src/bare-metal/microcontrollers/debugging.md:21
msgid ""
"```sh\n"
"gdb-multiarch target/thumbv7em-none-eabihf/debug/board_support --eval-"
"command=\"target remote :1337\"\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md:27
msgid "In GDB, try running:"
msgstr "En GDB, prueba a ejecutar:"

#: src/bare-metal/microcontrollers/debugging.md:29
msgid ""
"```gdb\n"
"b src/bin/board_support.rs:29\n"
"b src/bin/board_support.rs:30\n"
"b src/bin/board_support.rs:32\n"
"c\n"
"c\n"
"c\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md:1
#: src/bare-metal/aps/other-projects.md:1
msgid "Other projects"
msgstr "Otros proyectos"

#: src/bare-metal/microcontrollers/other-projects.md:3
msgid "[RTIC](https://rtic.rs/)"
msgstr "[RTIC](https://rtic.rs/)"

#: src/bare-metal/microcontrollers/other-projects.md:4
msgid "\"Real-Time Interrupt-driven Concurrency\""
msgstr "\"Concurrencia en tiempo real basada en interrupciones\""

#: src/bare-metal/microcontrollers/other-projects.md:5
msgid ""
"Shared resource management, message passing, task scheduling, timer queue"
msgstr ""
"Gesti√≥n de recursos compartidos, env√≠o de mensajes, programaci√≥n de tareas, "
"cola del temporizador, etc."

#: src/bare-metal/microcontrollers/other-projects.md:6
msgid "[Embassy](https://embassy.dev/)"
msgstr "[Embassy](https://embassy.dev/)"

#: src/bare-metal/microcontrollers/other-projects.md:7
msgid "`async` executors with priorities, timers, networking, USB"
msgstr "Ejecutores `async` con prioridades, temporizadores, redes, USB, etc."

#: src/bare-metal/microcontrollers/other-projects.md:8
msgid "[TockOS](https://www.tockos.org/documentation/getting-started)"
msgstr "[TockOS](https://www.tockos.org/documentation/getting-started)"

#: src/bare-metal/microcontrollers/other-projects.md:9
msgid ""
"Security-focused RTOS with preemptive scheduling and Memory Protection Unit "
"support"
msgstr ""
"RTOS centrado en la seguridad con programaci√≥n interrumpible y "
"compatibilidad con la unidad de protecci√≥n de memoria."

#: src/bare-metal/microcontrollers/other-projects.md:10
msgid "[Hubris](https://hubris.oxide.computer/)"
msgstr "[Hubris](https://hubris.oxide.computer/)"

#: src/bare-metal/microcontrollers/other-projects.md:11
msgid ""
"Microkernel RTOS from Oxide Computer Company with memory protection, "
"unprivileged drivers, IPC"
msgstr ""
"RTOS de microkernel de Oxide Computer Company con protecci√≥n de memoria, "
"controladores sin privilegios, IPC, etc."

#: src/bare-metal/microcontrollers/other-projects.md:12
msgid "[Bindings for FreeRTOS](https://github.com/lobaro/FreeRTOS-rust)"
msgstr "[Enlaces para FreeRTOS](https://github.com/lobaro/FreeRTOS-rust)"

#: src/bare-metal/microcontrollers/other-projects.md:13
msgid ""
"Some platforms have `std` implementations, e.g. [esp-idf](https://esp-rs."
"github.io/book/overview/using-the-standard-library.html)."
msgstr ""
"Algunas plataformas tienen implementaciones `std`, como [esp-idf](https://"
"esp-rs.github.io/book/overview/using-the-standard-library.html)."

#: src/bare-metal/microcontrollers/other-projects.md:18
msgid "RTIC can be considered either an RTOS or a concurrency framework."
msgstr "RTIC se puede considerar un RTOS o un framework de concurrencia."

#: src/bare-metal/microcontrollers/other-projects.md:19
msgid "It doesn't include any HALs."
msgstr "No incluye ning√∫n HAL."

#: src/bare-metal/microcontrollers/other-projects.md:20
msgid ""
"It uses the Cortex-M NVIC (Nested Virtual Interrupt Controller) for "
"scheduling rather than a proper kernel."
msgstr ""
"Usa el NVIC (controlador de interrupci√≥n virtual anidado) Cortex‚ÄêM para la "
"programaci√≥n en lugar de un kernel propio."

#: src/bare-metal/microcontrollers/other-projects.md:22
msgid "Cortex-M only."
msgstr "Solo Cortex-M."

#: src/bare-metal/microcontrollers/other-projects.md:23
msgid ""
"Google uses TockOS on the Haven microcontroller for Titan security keys."
msgstr ""
"Google utiliza TockOS en el microcontrolador Haven para las llaves de "
"seguridad Titan."

#: src/bare-metal/microcontrollers/other-projects.md:24
msgid ""
"FreeRTOS is mostly written in C, but there are Rust bindings for writing "
"applications."
msgstr ""
"FreeRTOS est√° escrito principalmente en C, pero hay enlaces de Rust para "
"aplicaciones de escritura."

#: src/exercises/bare-metal/morning.md:3
msgid ""
"We will read the direction from an I2C compass, and log the readings to a "
"serial port."
msgstr ""
"Leeremos la direcci√≥n desde una br√∫jula I2C, y registraremos las lecturas en "
"un puerto serie."

#: src/exercises/bare-metal/compass.md:3
msgid ""
"We will read the direction from an I2C compass, and log the readings to a "
"serial port. If you have time, try displaying it on the LEDs somehow too, or "
"use the buttons somehow."
msgstr ""
"Leeremos la direcci√≥n desde una br√∫jula I2C, y registraremos las lecturas en "
"un puerto serie. Si tienes tiempo, prueba a mostrarlo tambi√©n en los LED o "
"usa los botones de alguna forma."

#: src/exercises/bare-metal/compass.md:6
msgid "Hints:"
msgstr "Sugerencias:"

#: src/exercises/bare-metal/compass.md:8
msgid ""
"Check the documentation for the [`lsm303agr`](https://docs.rs/lsm303agr/"
"latest/lsm303agr/) and [`microbit-v2`](https://docs.rs/microbit-v2/latest/"
"microbit/) crates, as well as the [micro:bit hardware](https://tech.microbit."
"org/hardware/)."
msgstr ""
"Consulta la documentaci√≥n sobre los crates [`lsm303agr`](https://docs.rs/"
"lsm303agr/latest/lsm303agr/) y [`microbit-v2`](https://docs.rs/microbit-v2/"
"latest/microbit/), as√≠ como [el hardware de micro:bit](https://tech.microbit."
"org/hardware/)."

#: src/exercises/bare-metal/compass.md:11
msgid ""
"The LSM303AGR Inertial Measurement Unit is connected to the internal I2C bus."
msgstr ""
"La unidad de medici√≥n inercial LSM303AGR est√° conectada al bus I2C interno."

#: src/exercises/bare-metal/compass.md:12
msgid ""
"TWI is another name for I2C, so the I2C master peripheral is called TWIM."
msgstr ""
"TWI es otro nombre para I2C, por lo que el perif√©rico I2C maestro se llama "
"TWIM."

#: src/exercises/bare-metal/compass.md:13
msgid ""
"The LSM303AGR driver needs something implementing the `embedded_hal::"
"blocking::i2c::WriteRead` trait. The [`microbit::hal::Twim`](https://docs.rs/"
"microbit-v2/latest/microbit/hal/struct.Twim.html) struct implements this."
msgstr ""
"El controlador LSM303AGR necesita algo que implemente  el trait "
"`embedded_hal::blocking::i2c::WriteRead`. La estructura [`microbit::hal::"
"Twim`](https://docs.rs/microbit-v2/latest/microbit/hal/struct.Twim.html) "
"implementa esto."

#: src/exercises/bare-metal/compass.md:17
msgid ""
"You have a [`microbit::Board`](https://docs.rs/microbit-v2/latest/microbit/"
"struct.Board.html) struct with fields for the various pins and peripherals."
msgstr ""
"Tienes una estructura [`microbit::Board`](https://docs.rs/microbit-v2/latest/"
"microbit/struct.Board.html) con campos para los distintos pines y "
"perif√©ricos."

#: src/exercises/bare-metal/compass.md:19
msgid ""
"You can also look at the [nRF52833 datasheet](https://infocenter.nordicsemi."
"com/pdf/nRF52833_PS_v1.5.pdf) if you want, but it shouldn't be necessary for "
"this exercise."
msgstr ""
"Tambi√©n puedes consultar la \\[hoja de datos nRF52833\\][nRF52833 datasheet]"
"(https://infocenter.nordicsemi.com/pdf/nRF52833_PS_v1.5.pdf) si quieres, "
"pero no deber√≠a ser necesario para este ejercicio."

#: src/exercises/bare-metal/compass.md:23
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and "
"look in the `compass` directory for the following files."
msgstr ""
"Descarga la [plantilla de ejercicio](../../comprehensive-rust-exercises.zip) "
"y busca los siguientes archivos en el directorio `compass`."

#: src/exercises/bare-metal/compass.md:26 src/exercises/bare-metal/rtc.md:19
msgid "`src/main.rs`:"
msgstr "`src/main.rs`:"

#: src/exercises/bare-metal/compass.md:30
msgid ""
"```rust,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use core::fmt::Write;\n"
"use cortex_m_rt::entry;\n"
"use microbit::{hal::uarte::{Baudrate, Parity, Uarte}, Board};\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let board = Board::take().unwrap();\n"
"\n"
"    // Configure serial port.\n"
"    let mut serial = Uarte::new(\n"
"        board.UARTE0,\n"
"        board.uart.into(),\n"
"        Parity::EXCLUDED,\n"
"        Baudrate::BAUD115200,\n"
"    );\n"
"\n"
"    // Set up the I2C controller and Inertial Measurement Unit.\n"
"    // TODO\n"
"\n"
"    writeln!(serial, \"Ready.\").unwrap();\n"
"\n"
"    loop {\n"
"        // Read compass data and log it to the serial port.\n"
"        // TODO\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:64 src/exercises/bare-metal/rtc.md:385
msgid "`Cargo.toml` (you shouldn't need to change this):"
msgstr "`Cargo.toml` (no deber√≠a ser necesario cambiarlo):"

#: src/exercises/bare-metal/compass.md:68
msgid ""
"```toml\n"
"[workspace]\n"
"\n"
"[package]\n"
"name = \"compass\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"cortex-m-rt = \"0.7.3\"\n"
"embedded-hal = \"0.2.6\"\n"
"lsm303agr = \"0.2.2\"\n"
"microbit-v2 = \"0.13.0\"\n"
"panic-halt = \"0.2.0\"\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:85
msgid "`Embed.toml` (you shouldn't need to change this):"
msgstr "`Embed.toml` (no deber√≠a ser necesario cambiarlo):"

#: src/exercises/bare-metal/compass.md:89
msgid ""
"```toml\n"
"[default.general]\n"
"chip = \"nrf52833_xxAA\"\n"
"\n"
"[debug.gdb]\n"
"enabled = true\n"
"\n"
"[debug.reset]\n"
"halt_afterwards = true\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:100 src/exercises/bare-metal/rtc.md:985
msgid "`.cargo/config.toml` (you shouldn't need to change this):"
msgstr "`.cargo/config.toml` (no deber√≠a ser necesario cambiarlo):"

#: src/exercises/bare-metal/compass.md:104
msgid ""
"```toml\n"
"[build]\n"
"target = \"thumbv7em-none-eabihf\" # Cortex-M4F\n"
"\n"
"[target.'cfg(all(target_arch = \"arm\", target_os = \"none\"))']\n"
"rustflags = [\"-C\", \"link-arg=-Tlink.x\"]\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:112
msgid "See the serial output on Linux with:"
msgstr "Consulta la salida de serie en Linux con:"

#: src/exercises/bare-metal/compass.md:114
msgid ""
"```sh\n"
"picocom --baud 115200 --imap lfcrlf /dev/ttyACM0\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:118
msgid ""
"Or on Mac OS something like (the device name may be slightly different):"
msgstr ""
"En Mac OS deber√≠a ser algo como lo siguiente (el nombre del dispositivo "
"puede ser algo diferente):"

#: src/exercises/bare-metal/compass.md:120
msgid ""
"```sh\n"
"picocom --baud 115200 --imap lfcrlf /dev/tty.usbmodem14502\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:124
msgid "Use Ctrl+A Ctrl+Q to quit picocom."
msgstr "Pulsa Ctrl+A Ctrl+Q para salir de Picocom."

#: src/bare-metal/aps.md:1
msgid "Application processors"
msgstr "Procesadores de aplicaciones"

#: src/bare-metal/aps.md:3
msgid ""
"So far we've talked about microcontrollers, such as the Arm Cortex-M series. "
"Now let's try writing something for Cortex-A. For simplicity we'll just work "
"with QEMU's aarch64 ['virt'](https://qemu-project.gitlab.io/qemu/system/arm/"
"virt.html) board."
msgstr ""
"Hasta ahora hemos hablado de microcontroladores, como la serie Cortex‚ÄêM de "
"Arm. Ahora vamos a probar a escribir algo para Cortex-A. Para simplificar, "
"solo trabajaremos con la placa ['virt'](https://qemu-project.gitlab.io/qemu/"
"system/arm/virt.html) aarch64 de QEMU."

#: src/bare-metal/aps.md:9
msgid ""
"Broadly speaking, microcontrollers don't have an MMU or multiple levels of "
"privilege (exception levels on Arm CPUs, rings on x86), while application "
"processors do."
msgstr ""
"En t√©rminos generales, los microcontroladores no tienen un MMU ni varios "
"niveles de privilegio (niveles de excepci√≥n en las CPU de Arm, anillos en "
"x86), mientras que los procesadores de aplicaciones s√≠ los tienen."

#: src/bare-metal/aps.md:11
msgid ""
"QEMU supports emulating various different machines or board models for each "
"architecture. The 'virt' board doesn't correspond to any particular real "
"hardware, but is designed purely for virtual machines."
msgstr ""
"QEMU permite emular varias m√°quinas o modelos de placa diferentes para cada "
"arquitectura. La placa \"virt\" no se corresponde con ning√∫n hardware real "
"concreto, pero est√° dise√±ada exclusivamente para m√°quinas virtuales."

#: src/bare-metal/aps/entry-point.md:3
msgid ""
"Before we can start running Rust code, we need to do some initialisation."
msgstr ""
"Antes de que podamos empezar a ejecutar c√≥digo de Rust, tenemos que hacer "
"alguna inicializaci√≥n."

#: src/bare-metal/aps/entry-point.md:5
msgid ""
"```armasm\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"    /*\n"
"     * Load and apply the memory management configuration, ready to enable "
"MMU and\n"
"     * caches.\n"
"     */\n"
"    adrp x30, idmap\n"
"    msr ttbr0_el1, x30\n"
"\n"
"    mov_i x30, .Lmairval\n"
"    msr mair_el1, x30\n"
"\n"
"    mov_i x30, .Ltcrval\n"
"    /* Copy the supported PA range into TCR_EL1.IPS. */\n"
"    mrs x29, id_aa64mmfr0_el1\n"
"    bfi x30, x29, #32, #4\n"
"\n"
"    msr tcr_el1, x30\n"
"\n"
"    mov_i x30, .Lsctlrval\n"
"\n"
"    /*\n"
"     * Ensure everything before this point has completed, then invalidate "
"any\n"
"     * potentially stale local TLB entries before they start being used.\n"
"     */\n"
"    isb\n"
"    tlbi vmalle1\n"
"    ic iallu\n"
"    dsb nsh\n"
"    isb\n"
"\n"
"    /*\n"
"     * Configure sctlr_el1 to enable MMU and cache and don't proceed until "
"this\n"
"     * has completed.\n"
"     */\n"
"    msr sctlr_el1, x30\n"
"    isb\n"
"\n"
"    /* Disable trapping floating point access in EL1. */\n"
"    mrs x30, cpacr_el1\n"
"    orr x30, x30, #(0x3 << 20)\n"
"    msr cpacr_el1, x30\n"
"    isb\n"
"\n"
"    /* Zero out the bss section. */\n"
"    adr_l x29, bss_begin\n"
"    adr_l x30, bss_end\n"
"0:  cmp x29, x30\n"
"    b.hs 1f\n"
"    stp xzr, xzr, [x29], #16\n"
"    b 0b\n"
"\n"
"1:  /* Prepare the stack. */\n"
"    adr_l x30, boot_stack_end\n"
"    mov sp, x30\n"
"\n"
"    /* Set up exception vector. */\n"
"    adr x30, vector_table_el1\n"
"    msr vbar_el1, x30\n"
"\n"
"    /* Call into Rust code. */\n"
"    bl main\n"
"\n"
"    /* Loop forever waiting for interrupts. */\n"
"2:  wfi\n"
"    b 2b\n"
"```"
msgstr ""

#: src/bare-metal/aps/entry-point.md:77
msgid ""
"This is the same as it would be for C: initialising the processor state, "
"zeroing the BSS, and setting up the stack pointer."
msgstr ""
"Es lo mismo que en C: inicializar el estado del procesador, poner a cero el "
"BSS y configurar el puntero de la _stack_."

#: src/bare-metal/aps/entry-point.md:79
msgid ""
"The BSS (block starting symbol, for historical reasons) is the part of the "
"object file which containing statically allocated variables which are "
"initialised to zero. They are omitted from the image, to avoid wasting space "
"on zeroes. The compiler assumes that the loader will take care of zeroing "
"them."
msgstr ""
"El BSS (s√≠mbolo de inicio del bloque, por motivos hist√≥ricos) es la parte "
"del objeto que contiene variables asignadas de forma est√°tica que se "
"inicializan a cero. Se omiten en la imagen para evitar malgastar espacio con "
"ceros. El compilador asume que el cargador se encargar√° de ponerlos a cero."

#: src/bare-metal/aps/entry-point.md:83
msgid ""
"The BSS may already be zeroed, depending on how memory is initialised and "
"the image is loaded, but we zero it to be sure."
msgstr ""
"Es posible que el BSS ya est√© a cero, dependiendo de c√≥mo se inicialice la "
"memoria y c√≥mo se cargue la imagen, aunque se pone igualmente a cero para "
"estar seguros."

#: src/bare-metal/aps/entry-point.md:85
msgid ""
"We need to enable the MMU and cache before reading or writing any memory. If "
"we don't:"
msgstr ""
"Necesitamos habilitar la MMU y la cach√© antes de leer o escribir memoria. Si "
"no lo hacemos, suceder√° lo siguiente:"

#: src/bare-metal/aps/entry-point.md:86
msgid ""
"Unaligned accesses will fault. We build the Rust code for the `aarch64-"
"unknown-none` target which sets `+strict-align` to prevent the compiler "
"generating unaligned accesses, so it should be fine in this case, but this "
"is not necessarily the case in general."
msgstr ""
"Los accesos no alineados fallar√°n. Compilamos el c√≥digo Rust para el "
"objetivo `aarch64-unknown-none`, que define `+strict-align` para evitar que "
"el compilador genere accesos no alineados. En este caso deber√≠a estar bien, "
"pero no tiene por qu√© ser as√≠ en general."

#: src/bare-metal/aps/entry-point.md:89
msgid ""
"If it were running in a VM, this can lead to cache coherency issues. The "
"problem is that the VM is accessing memory directly with the cache disabled, "
"while the host has cacheable aliases to the same memory. Even if the host "
"doesn't explicitly access the memory, speculative accesses can lead to cache "
"fills, and then changes from one or the other will get lost when the cache "
"is cleaned or the VM enables the cache. (Cache is keyed by physical address, "
"not VA or IPA.)"
msgstr ""
"Si se estuviera ejecutando en una m√°quina virtual, podr√≠a provocar problemas "
"de coherencia en la cach√©. El problema es que la m√°quina virtual accede a la "
"memoria directamente con la cach√© inhabilitada, mientras que el host cuenta "
"con alias que se pueden almacenar en cach√© en la misma memoria. Incluso si "
"el host no accede expl√≠citamente a la memoria, los accesos especulativos "
"pueden provocar que se llene la cach√©, haciendo que los cambios de uno u "
"otro se pierdan cuando se borre la cach√© o cuando la m√°quina virtual la "
"habilite. (La cach√© est√° codificada por direcci√≥n f√≠sica, no por VA ni IPA)."

#: src/bare-metal/aps/entry-point.md:94
msgid ""
"For simplicity, we just use a hardcoded pagetable (see `idmap.S`) which "
"identity maps the first 1 GiB of address space for devices, the next 1 GiB "
"for DRAM, and another 1 GiB higher up for more devices. This matches the "
"memory layout that QEMU uses."
msgstr ""
"Para simplificar, solo se utiliza una tabla de p√°ginas codificada (consulta "
"`idmap.S`) que mapea la identidad del primer GiB de espacio de direcciones "
"para dispositivos, el siguiente GiB para DRAM y otro GiB m√°s para m√°s "
"dispositivos. Esto coincide con la disposici√≥n de memoria que utiliza QEMU."

#: src/bare-metal/aps/entry-point.md:97
msgid ""
"We also set up the exception vector (`vbar_el1`), which we'll see more about "
"later."
msgstr ""
"Tambi√©n configuramos el vector de excepci√≥n (`vbar_el1`), del que veremos "
"m√°s contenido en pr√≥ximas dipositivas."

#: src/bare-metal/aps/entry-point.md:98
msgid ""
"All examples this afternoon assume we will be running at exception level 1 "
"(EL1). If you need to run at a different exception level you'll need to "
"modify `entry.S` accordingly."
msgstr ""
"Todos los ejemplos de esta tarde se ejecutar√°n en el nivel de excepci√≥n 1 "
"(EL1). Si necesitas ejecutar en un nivel de excepci√≥n diferente, deber√°s "
"modificar `entry.S` seg√∫n corresponda."

#: src/bare-metal/aps/inline-assembly.md:1
msgid "Inline assembly"
msgstr "Ensamblaje integrado"

#: src/bare-metal/aps/inline-assembly.md:3
msgid ""
"Sometimes we need to use assembly to do things that aren't possible with "
"Rust code. For example, to make an "
msgstr ""
"A veces necesitamos usar el ensamblador para hacer cosas que no son posibles "
"con c√≥digo Rust. Por ejemplo, hacer un "

#: src/bare-metal/aps/inline-assembly.md:4
msgid "HVC"
msgstr "HVC"

#: src/bare-metal/aps/inline-assembly.md:4
msgid " to tell the firmware to power off the system:"
msgstr " para decirle al firmware que apague el sistema:"

#: src/bare-metal/aps/inline-assembly.md:6
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"use core::arch::asm;\n"
"use core::panic::PanicInfo;\n"
"\n"
"mod exceptions;\n"
"\n"
"const PSCI_SYSTEM_OFF: u32 = 0x84000008;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(_x0: u64, _x1: u64, _x2: u64, _x3: u64) {\n"
"    // Safe because this only uses the declared registers and doesn't do\n"
"    // anything with memory.\n"
"    unsafe {\n"
"        asm!(\"hvc #0\",\n"
"            inout(\"w0\") PSCI_SYSTEM_OFF => _,\n"
"            inout(\"w1\") 0 => _,\n"
"            inout(\"w2\") 0 => _,\n"
"            inout(\"w3\") 0 => _,\n"
"            inout(\"w4\") 0 => _,\n"
"            inout(\"w5\") 0 => _,\n"
"            inout(\"w6\") 0 => _,\n"
"            inout(\"w7\") 0 => _,\n"
"            options(nomem, nostack)\n"
"        );\n"
"    }\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:39
msgid ""
"(If you actually want to do this, use the [`smccc`](https://crates.io/crates/"
"smccc) crate which has wrappers for all these functions.)"
msgstr ""
"(Si realmente quieres hacer esto, utiliza el crate [`smccc`](https://crates."
"io/crates/smccc) que tiene envoltorios para todas estas funciones)."

#: src/bare-metal/aps/inline-assembly.md:43
msgid ""
"PSCI is the Arm Power State Coordination Interface, a standard set of "
"functions to manage system and CPU power states, among other things. It is "
"implemented by EL3 firmware and hypervisors on many systems."
msgstr ""
"PSCI es la interfaz de coordinaci√≥n de estado de alimentaci√≥n de Arm, un "
"conjunto est√°ndar de funciones para gestionar los estados de alimentaci√≥n "
"del sistema y de la CPU, entre otras cosas. Lo implementan el firmware EL3 y "
"los hipervisores en muchos sistemas."

#: src/bare-metal/aps/inline-assembly.md:46
msgid ""
"The `0 => _` syntax means initialise the register to 0 before running the "
"inline assembly code, and ignore its contents afterwards. We need to use "
"`inout` rather than `in` because the call could potentially clobber the "
"contents of the registers."
msgstr ""
"La sintaxis `0 => _` significa inicializar el registro a 0 antes de ejecutar "
"el c√≥digo de ensamblaje integrado e ignorar su contenido despu√©s. "
"Necesitamos utilizar `inout` en lugar de `in` porque la llamada podr√≠a "
"alterar el contenido de los registros."

#: src/bare-metal/aps/inline-assembly.md:49
msgid ""
"This `main` function needs to be `#[no_mangle]` and `extern \"C\"` because "
"it is called from our entry point in `entry.S`."
msgstr ""
"Esta funci√≥n `main` debe ser `#[no_mangle]` y `extern \"C\"`, ya que se "
"llama desde nuestro punto de entrada en `entry.S`."

#: src/bare-metal/aps/inline-assembly.md:51
msgid ""
"`_x0`‚Äì`_x3` are the values of registers `x0`‚Äì`x3`, which are conventionally "
"used by the bootloader to pass things like a pointer to the device tree. "
"According to the standard aarch64 calling convention (which is what `extern "
"\"C\"` specifies to use), registers `x0`‚Äì`x7` are used for the first 8 "
"arguments passed to a function, so `entry.S` doesn't need to do anything "
"special except make sure it doesn't change these registers."
msgstr ""
"`_x0`‚Äì`_x3` son los valores de los registros `x0`‚Äì`x3`, que el bootloader "
"utiliza habitualmente para pasar elementos al √°rbol de dispositivos, como un "
"puntero. De acuerdo con la convenci√≥n de llamadas est√°ndar de aarch64 (que "
"es lo que `extern \"C\"` usa), los registros `x0`‚Äì`x7` se utilizan para los "
"primeros ocho argumentos que se pasan a una funci√≥n, de modo que `entry.S` "
"no tiene que hacer nada especial, salvo asegurarse de que no cambia estos "
"registros."

#: src/bare-metal/aps/inline-assembly.md:56
msgid ""
"Run the example in QEMU with `make qemu_psci` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"Ejecuta el ejemplo en QEMU con `make qemu_psci` en `src/bare-metal/aps/"
"examples`."

#: src/bare-metal/aps/mmio.md:1
msgid "Volatile memory access for MMIO"
msgstr "Acceso a la memoria vol√°til para MMIO"

#: src/bare-metal/aps/mmio.md:3
msgid "Use `pointer::read_volatile` and `pointer::write_volatile`."
msgstr "Se puede usar `pointer::read_volatile` y `pointer::write_volatile`."

#: src/bare-metal/aps/mmio.md:4
msgid "Never hold a reference."
msgstr "Nunca retengas una referencia."

#: src/bare-metal/aps/mmio.md:5
msgid ""
"`addr_of!` lets you get fields of structs without creating an intermediate "
"reference."
msgstr ""
"`addr_of!` permite obtener campos de estructuras sin crear una referencia "
"intermedia."

#: src/bare-metal/aps/mmio.md:9
msgid ""
"Volatile access: read or write operations may have side-effects, so prevent "
"the compiler or hardware from reordering, duplicating or eliding them."
msgstr ""
"Acceso vol√°til: las operaciones de lectura o escritura pueden tener efectos "
"secundarios, por lo que se debe evitar que el compilador o el hardware las "
"reordene, duplique u omita."

#: src/bare-metal/aps/mmio.md:11
msgid ""
"Usually if you write and then read, e.g. via a mutable reference, the "
"compiler may assume that the value read is the same as the value just "
"written, and not bother actually reading memory."
msgstr ""
"Normalmente, si escribes y luego lees (por ejemplo, a trav√©s de una "
"referencia mutable), el compilador puede suponer que el valor le√≠do es el "
"mismo que el que se acaba de escribir, sin molestarse si quiera en leer "
"realmente la memoria."

#: src/bare-metal/aps/mmio.md:13
msgid ""
"Some existing crates for volatile access to hardware do hold references, but "
"this is unsound. Whenever a reference exist, the compiler may choose to "
"dereference it."
msgstr ""
"Algunos crates para el acceso vol√°til al hardware s√≠ mantienen referencias, "
"aunque no es seguro. Siempre que exista una referencia, el compilador puede "
"desreferenciarla."

#: src/bare-metal/aps/mmio.md:15
msgid ""
"Use the `addr_of!` macro to get struct field pointers from a pointer to the "
"struct."
msgstr ""
"Utiliza la macro `addr_of!` para obtener punteros de campos de estructuras a "
"partir de un puntero en la estructura."

#: src/bare-metal/aps/uart.md:1
msgid "Let's write a UART driver"
msgstr "Vamos a escribir un controlador de UART"

#: src/bare-metal/aps/uart.md:3
msgid ""
"The QEMU 'virt' machine has a [PL011](https://developer.arm.com/"
"documentation/ddi0183/g) UART, so let's write a driver for that."
msgstr ""
"La m√°quina \"virt\" de QEMU tiene una UART [PL011]https://developer.arm.com/"
"documentation/ddi0183/g), as√≠ que vamos a escribir un controlador para ella."

#: src/bare-metal/aps/uart.md:5
msgid ""
"```rust,editable\n"
"const FLAG_REGISTER_OFFSET: usize = 0x18;\n"
"const FR_BUSY: u8 = 1 << 3;\n"
"const FR_TXFF: u8 = 1 << 5;\n"
"\n"
"/// Minimal driver for a PL011 UART.\n"
"#[derive(Debug)]\n"
"pub struct Uart {\n"
"    base_address: *mut u8,\n"
"}\n"
"\n"
"impl Uart {\n"
"    /// Constructs a new instance of the UART driver for a PL011 device at "
"the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the 8 MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
"    pub unsafe fn new(base_address: *mut u8) -> Self {\n"
"        Self { base_address }\n"
"    }\n"
"\n"
"    /// Writes a single byte to the UART.\n"
"    pub fn write_byte(&self, byte: u8) {\n"
"        // Wait until there is room in the TX buffer.\n"
"        while self.read_flag_register() & FR_TXFF != 0 {}\n"
"\n"
"        // Safe because we know that the base address points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe {\n"
"            // Write to the TX buffer.\n"
"            self.base_address.write_volatile(byte);\n"
"        }\n"
"\n"
"        // Wait until the UART is no longer busy.\n"
"        while self.read_flag_register() & FR_BUSY != 0 {}\n"
"    }\n"
"\n"
"    fn read_flag_register(&self) -> u8 {\n"
"        // Safe because we know that the base address points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe { self.base_address.add(FLAG_REGISTER_OFFSET)."
"read_volatile() }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/uart.md:55
msgid ""
"Note that `Uart::new` is unsafe while the other methods are safe. This is "
"because as long as the caller of `Uart::new` guarantees that its safety "
"requirements are met (i.e. that there is only ever one instance of the "
"driver for a given UART, and nothing else aliasing its address space), then "
"it is always safe to call `write_byte` later because we can assume the "
"necessary preconditions."
msgstr ""
"Ten en cuenta que `Uart::new` no es seguro, mientras que los otros m√©todos "
"s√≠ lo son. Esto se debe a que mientras que el llamador de `Uart::new` "
"asegure que se cumplan sus requisitos de seguridad (es decir, que solo haya "
"una instancia del controlador para una UART determinada y que nada m√°s "
"asigne alias a su espacio de direcciones), siempre es m√°s seguro llamar a "
"`write_byte` m√°s adelante, ya que podemos asumir\\ las condiciones previas "
"necesarias."

#: src/bare-metal/aps/uart.md:60
msgid ""
"We could have done it the other way around (making `new` safe but "
"`write_byte` unsafe), but that would be much less convenient to use as every "
"place that calls `write_byte` would need to reason about the safety"
msgstr ""
"Podr√≠amos haberlo hecho al rev√©s (haciendo que `new` fuese seguro y "
"`write_byte` no seguro), pero\\ser√≠a mucho menos c√≥modo de usar, ya que cada "
"lugar que llamase a `write_byte` tendr√≠a que pensar en la seguridad"

#: src/bare-metal/aps/uart.md:63
msgid ""
"This is a common pattern for writing safe wrappers of unsafe code: moving "
"the burden of proof for soundness from a large number of places to a smaller "
"number of places."
msgstr ""
"Este es un patr√≥n com√∫n para escribir envoltorios seguros de c√≥digo "
"inseguro: mover la carga de la prueba de seguridad de un gran n√∫mero de "
"lugares a otro m√°s peque√±o."

#: src/bare-metal/aps/uart/traits.md:1
msgid "More traits"
msgstr "M√°s traits"

#: src/bare-metal/aps/uart/traits.md:3
msgid ""
"We derived the `Debug` trait. It would be useful to implement a few more "
"traits too."
msgstr ""
"Hemos derivado el trait `Debug`. Tambi√©n ser√≠a √∫til implementar algunos "
"traits m√°s."

#: src/bare-metal/aps/uart/traits.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use core::fmt::{self, Write};\n"
"\n"
"impl Write for Uart {\n"
"    fn write_str(&mut self, s: &str) -> fmt::Result {\n"
"        for c in s.as_bytes() {\n"
"            self.write_byte(*c);\n"
"        }\n"
"        Ok(())\n"
"    }\n"
"}\n"
"\n"
"// Safe because it just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
"unsafe impl Send for Uart {}\n"
"```"
msgstr ""

#: src/bare-metal/aps/uart/traits.md:24
msgid ""
"Implementing `Write` lets us use the `write!` and `writeln!` macros with our "
"`Uart` type."
msgstr ""
"Implementar `Write` nos permite utilizar las macros `write!` y `writeln!` "
"con nuestro tipo `Uart`."

#: src/bare-metal/aps/uart/traits.md:25
msgid ""
"Run the example in QEMU with `make qemu_minimal` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"Ejecuta el ejemplo en QEMU con `make qemu_minimal` en `src/bare-metal/aps/"
"examples`."

#: src/bare-metal/aps/better-uart.md:1
msgid "A better UART driver"
msgstr "Un controlador UART mejor"

#: src/bare-metal/aps/better-uart.md:3
msgid ""
"The PL011 actually has [a bunch more registers](https://developer.arm.com/"
"documentation/ddi0183/g/programmers-model/summary-of-registers), and adding "
"offsets to construct pointers to access them is error-prone and hard to "
"read. Plus, some of them are bit fields which would be nice to access in a "
"structured way."
msgstr ""
"En realidad, PL011 tiene [muchos registros m√°s](https://developer.arm.com/"
"documentation/ddi0183/g/programmers-model/summary-of-registers), por lo que "
"a√±adir desplazamientos para crear punteros que les permita acceder a ellos "
"da lugar a errores y dificulta la lectura. Adem√°s, algunos de ellos son "
"campos de bits a los que estar√≠a bien acceder de forma estructurada."

#: src/bare-metal/aps/better-uart.md:7
msgid "Offset"
msgstr "Desplazamiento"

#: src/bare-metal/aps/better-uart.md:7
msgid "Register name"
msgstr "Nombre de registro"

#: src/bare-metal/aps/better-uart.md:7
msgid "Width"
msgstr "Ancho"

#: src/bare-metal/aps/better-uart.md:9
msgid "0x00"
msgstr "0x00"

#: src/bare-metal/aps/better-uart.md:9
msgid "DR"
msgstr "DR"

#: src/bare-metal/aps/better-uart.md:9
msgid "12"
msgstr "12"

#: src/bare-metal/aps/better-uart.md:10
msgid "0x04"
msgstr "0x04"

#: src/bare-metal/aps/better-uart.md:10
msgid "RSR"
msgstr "RSR"

#: src/bare-metal/aps/better-uart.md:10
msgid "4"
msgstr "4"

#: src/bare-metal/aps/better-uart.md:11
msgid "0x18"
msgstr "0x18"

#: src/bare-metal/aps/better-uart.md:11
msgid "FR"
msgstr "FR"

#: src/bare-metal/aps/better-uart.md:11
msgid "9"
msgstr "9"

#: src/bare-metal/aps/better-uart.md:12
msgid "0x20"
msgstr "0x20"

#: src/bare-metal/aps/better-uart.md:12
msgid "ILPR"
msgstr "ILPR"

#: src/bare-metal/aps/better-uart.md:12 src/bare-metal/aps/better-uart.md:15
msgid "8"
msgstr "8"

#: src/bare-metal/aps/better-uart.md:13
msgid "0x24"
msgstr "0x24"

#: src/bare-metal/aps/better-uart.md:13
msgid "IBRD"
msgstr "IBRD"

#: src/bare-metal/aps/better-uart.md:13 src/bare-metal/aps/better-uart.md:16
msgid "16"
msgstr "16"

#: src/bare-metal/aps/better-uart.md:14
msgid "0x28"
msgstr "0x28"

#: src/bare-metal/aps/better-uart.md:14
msgid "FBRD"
msgstr "FBRD"

#: src/bare-metal/aps/better-uart.md:14 src/bare-metal/aps/better-uart.md:17
msgid "6"
msgstr "6"

#: src/bare-metal/aps/better-uart.md:15
msgid "0x2c"
msgstr "0x2c"

#: src/bare-metal/aps/better-uart.md:15
msgid "LCR_H"
msgstr "LCR_H"

#: src/bare-metal/aps/better-uart.md:16
msgid "0x30"
msgstr "0x30"

#: src/bare-metal/aps/better-uart.md:16
msgid "CR"
msgstr "CR"

#: src/bare-metal/aps/better-uart.md:17
msgid "0x34"
msgstr "0x34"

#: src/bare-metal/aps/better-uart.md:17
msgid "IFLS"
msgstr "IFLS"

#: src/bare-metal/aps/better-uart.md:18
msgid "0x38"
msgstr "0x38"

#: src/bare-metal/aps/better-uart.md:18
msgid "IMSC"
msgstr "IMSC"

#: src/bare-metal/aps/better-uart.md:18 src/bare-metal/aps/better-uart.md:19
#: src/bare-metal/aps/better-uart.md:20 src/bare-metal/aps/better-uart.md:21
msgid "11"
msgstr "11"

#: src/bare-metal/aps/better-uart.md:19
msgid "0x3c"
msgstr "0x3c"

#: src/bare-metal/aps/better-uart.md:19
msgid "RIS"
msgstr "RIS"

#: src/bare-metal/aps/better-uart.md:20
msgid "0x40"
msgstr "0x40"

#: src/bare-metal/aps/better-uart.md:20
msgid "MIS"
msgstr "MIS"

#: src/bare-metal/aps/better-uart.md:21
msgid "0x44"
msgstr "0x44"

#: src/bare-metal/aps/better-uart.md:21
msgid "ICR"
msgstr "ICR"

#: src/bare-metal/aps/better-uart.md:22
msgid "0x48"
msgstr "0x48"

#: src/bare-metal/aps/better-uart.md:22
msgid "DMACR"
msgstr "DMACR"

#: src/bare-metal/aps/better-uart.md:22
msgid "3"
msgstr "3"

#: src/bare-metal/aps/better-uart.md:26
msgid "There are also some ID registers which have been omitted for brevity."
msgstr "Tambi√©n hay algunos registros de ID que se han omitido para abreviar."

#: src/bare-metal/aps/better-uart/bitflags.md:3
msgid ""
"The [`bitflags`](https://crates.io/crates/bitflags) crate is useful for "
"working with bitflags."
msgstr ""
"El crate [`bitflags`](https://crates.io/crates/bitflags) resulta √∫til para "
"trabajar con bitflags."

#: src/bare-metal/aps/better-uart/bitflags.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use bitflags::bitflags;\n"
"\n"
"bitflags! {\n"
"    /// Flags from the UART flag register.\n"
"    #[repr(transparent)]\n"
"    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n"
"    struct Flags: u16 {\n"
"        /// Clear to send.\n"
"        const CTS = 1 << 0;\n"
"        /// Data set ready.\n"
"        const DSR = 1 << 1;\n"
"        /// Data carrier detect.\n"
"        const DCD = 1 << 2;\n"
"        /// UART busy transmitting data.\n"
"        const BUSY = 1 << 3;\n"
"        /// Receive FIFO is empty.\n"
"        const RXFE = 1 << 4;\n"
"        /// Transmit FIFO is full.\n"
"        const TXFF = 1 << 5;\n"
"        /// Receive FIFO is full.\n"
"        const RXFF = 1 << 6;\n"
"        /// Transmit FIFO is empty.\n"
"        const TXFE = 1 << 7;\n"
"        /// Ring indicator.\n"
"        const RI = 1 << 8;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:37
msgid ""
"The `bitflags!` macro creates a newtype something like `Flags(u16)`, along "
"with a bunch of method implementations to get and set flags."
msgstr ""
"La macro `bitflags!` crea un newtype, como `Flags(u16)`, junto con un mont√≥n "
"de implementaciones de m√©todos para obtener y definir _flags_ (banderas)."

#: src/bare-metal/aps/better-uart/registers.md:1
msgid "Multiple registers"
msgstr "Varios registros"

#: src/bare-metal/aps/better-uart/registers.md:3
msgid ""
"We can use a struct to represent the memory layout of the UART's registers."
msgstr ""
"Podemos utilizar una estructura para representar la disposici√≥n de la "
"memoria de los registros de UART."

#: src/bare-metal/aps/better-uart/registers.md:5
msgid ""
"```rust,editable,compile_fail\n"
"#[repr(C, align(4))]\n"
"struct Registers {\n"
"    dr: u16,\n"
"    _reserved0: [u8; 2],\n"
"    rsr: ReceiveStatus,\n"
"    _reserved1: [u8; 19],\n"
"    fr: Flags,\n"
"    _reserved2: [u8; 6],\n"
"    ilpr: u8,\n"
"    _reserved3: [u8; 3],\n"
"    ibrd: u16,\n"
"    _reserved4: [u8; 2],\n"
"    fbrd: u8,\n"
"    _reserved5: [u8; 3],\n"
"    lcr_h: u8,\n"
"    _reserved6: [u8; 3],\n"
"    cr: u16,\n"
"    _reserved7: [u8; 3],\n"
"    ifls: u8,\n"
"    _reserved8: [u8; 3],\n"
"    imsc: u16,\n"
"    _reserved9: [u8; 2],\n"
"    ris: u16,\n"
"    _reserved10: [u8; 2],\n"
"    mis: u16,\n"
"    _reserved11: [u8; 2],\n"
"    icr: u16,\n"
"    _reserved12: [u8; 2],\n"
"    dmacr: u8,\n"
"    _reserved13: [u8; 3],\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/better-uart/registers.md:41
msgid ""
"[`#[repr(C)]`](https://doc.rust-lang.org/reference/type-layout.html#the-c-"
"representation) tells the compiler to lay the struct fields out in order, "
"following the same rules as C. This is necessary for our struct to have a "
"predictable layout, as default Rust representation allows the compiler to "
"(among other things) reorder fields however it sees fit."
msgstr ""
"[`#[repr(C)]`](https://doc.rust-lang.org/reference/type-layout.html#the-c-"
"representation) indica al compilador que ordene los campos de la estructura "
"siguiendo las mismas reglas que en C. Esto es necesario para que nuestra "
"estructura tenga un dise√±o predecible, ya que la representaci√≥n "
"predeterminada de Rust permite que el compilador (entre otras cosas) "
"reordene los campos como crea conveniente."

#: src/bare-metal/aps/better-uart/driver.md:3
msgid "Now let's use the new `Registers` struct in our driver."
msgstr ""
"Ahora vamos a utilizar la nueva estructura de `Registers` en nuestro "
"controlador."

#: src/bare-metal/aps/better-uart/driver.md:5
msgid ""
"```rust,editable,compile_fail\n"
"/// Driver for a PL011 UART.\n"
"#[derive(Debug)]\n"
"pub struct Uart {\n"
"    registers: *mut Registers,\n"
"}\n"
"\n"
"impl Uart {\n"
"    /// Constructs a new instance of the UART driver for a PL011 device at "
"the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the 8 MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
"    pub unsafe fn new(base_address: *mut u32) -> Self {\n"
"        Self {\n"
"            registers: base_address as *mut Registers,\n"
"        }\n"
"    }\n"
"\n"
"    /// Writes a single byte to the UART.\n"
"    pub fn write_byte(&self, byte: u8) {\n"
"        // Wait until there is room in the TX buffer.\n"
"        while self.read_flag_register().contains(Flags::TXFF) {}\n"
"\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe {\n"
"            // Write to the TX buffer.\n"
"            addr_of_mut!((*self.registers).dr).write_volatile(byte.into());\n"
"        }\n"
"\n"
"        // Wait until the UART is no longer busy.\n"
"        while self.read_flag_register().contains(Flags::BUSY) {}\n"
"    }\n"
"\n"
"    /// Reads and returns a pending byte, or `None` if nothing has been "
"received.\n"
"    pub fn read_byte(&self) -> Option<u8> {\n"
"        if self.read_flag_register().contains(Flags::RXFE) {\n"
"            None\n"
"        } else {\n"
"            let data = unsafe { addr_of!((*self.registers).dr)."
"read_volatile() };\n"
"            // TODO: Check for error conditions in bits 8-11.\n"
"            Some(data as u8)\n"
"        }\n"
"    }\n"
"\n"
"    fn read_flag_register(&self) -> Flags {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe { addr_of!((*self.registers).fr).read_volatile() }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md:64
msgid ""
"Note the use of `addr_of!` / `addr_of_mut!` to get pointers to individual "
"fields without creating an intermediate reference, which would be unsound."
msgstr ""
"F√≠jate en el uso de `addr_of!` y `addr_of_mut!` para llevar punteros a "
"campos individuales sin crear una referencia intermedia. Ser√≠a una acci√≥n "
"insegura."

#: src/bare-metal/aps/better-uart/using.md:1
#: src/bare-metal/aps/logging/using.md:1
msgid "Using it"
msgstr "Uso"

#: src/bare-metal/aps/better-uart/using.md:3
msgid ""
"Let's write a small program using our driver to write to the serial console, "
"and echo incoming bytes."
msgstr ""
"Vamos a crear un peque√±o programa con nuestro controlador para escribir en "
"la consola serie y compartir los bytes entrantes."

#: src/bare-metal/aps/better-uart/using.md:6
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"mod exceptions;\n"
"mod pl011;\n"
"\n"
"use crate::pl011::Uart;\n"
"use core::fmt::Write;\n"
"use core::panic::PanicInfo;\n"
"use log::error;\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Base address of the primary PL011 UART.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 "
"device,\n"
"    // and nothing else accesses that address range.\n"
"    let mut uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"\n"
"    writeln!(uart, \"main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})\").unwrap();\n"
"\n"
"    loop {\n"
"        if let Some(byte) = uart.read_byte() {\n"
"            uart.write_byte(byte);\n"
"            match byte {\n"
"                b'\\r' => {\n"
"                    uart.write_byte(b'\\n');\n"
"                }\n"
"                b'q' => break,\n"
"                _ => {}\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    writeln!(uart, \"Bye!\").unwrap();\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:51
msgid ""
"As in the [inline assembly](../inline-assembly.md) example, this `main` "
"function is called from our entry point code in `entry.S`. See the speaker "
"notes there for details."
msgstr ""
"Al igual que en el ejemplo de [ensamblaje integrado](../inline-assembly.md), "
"esta funci√≥n `main` se llama desde nuestro c√≥digo de punto de entrada en "
"`entry.S`. Consulta las notas del orador para obtener m√°s informaci√≥n."

#: src/bare-metal/aps/better-uart/using.md:53
msgid ""
"Run the example in QEMU with `make qemu` under `src/bare-metal/aps/examples`."
msgstr ""
"Ejecuta el ejemplo en QEMU con `make qemu` en `src/bare-metal/aps/examples`."

#: src/bare-metal/aps/logging.md:3
msgid ""
"It would be nice to be able to use the logging macros from the [`log`]"
"(https://crates.io/crates/log) crate. We can do this by implementing the "
"`Log` trait."
msgstr ""
"Estar√≠a bien poder utilizar las macros de registro del crate [`log`](https://"
"crates.io/crates/log). Podemos hacerlo implementando el trait `Log`."

#: src/bare-metal/aps/logging.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use crate::pl011::Uart;\n"
"use core::fmt::Write;\n"
"use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};\n"
"use spin::mutex::SpinMutex;\n"
"\n"
"static LOGGER: Logger = Logger {\n"
"    uart: SpinMutex::new(None),\n"
"};\n"
"\n"
"struct Logger {\n"
"    uart: SpinMutex<Option<Uart>>,\n"
"}\n"
"\n"
"impl Log for Logger {\n"
"    fn enabled(&self, _metadata: &Metadata) -> bool {\n"
"        true\n"
"    }\n"
"\n"
"    fn log(&self, record: &Record) {\n"
"        writeln!(\n"
"            self.uart.lock().as_mut().unwrap(),\n"
"            \"[{}] {}\",\n"
"            record.level(),\n"
"            record.args()\n"
"        )\n"
"        .unwrap();\n"
"    }\n"
"\n"
"    fn flush(&self) {}\n"
"}\n"
"\n"
"/// Initialises UART logger.\n"
"pub fn init(uart: Uart, max_level: LevelFilter) -> Result<(), "
"SetLoggerError> {\n"
"    LOGGER.uart.lock().replace(uart);\n"
"\n"
"    log::set_logger(&LOGGER)?;\n"
"    log::set_max_level(max_level);\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/logging.md:50
msgid ""
"The unwrap in `log` is safe because we initialise `LOGGER` before calling "
"`set_logger`."
msgstr ""
"La desenvoltura en `log` es segura porque inicializamos `LOGGER` antes de "
"llamar a `set_logger`."

#: src/bare-metal/aps/logging/using.md:3
msgid "We need to initialise the logger before we use it."
msgstr "Debemos inicializar el registrador antes de utilizarlo."

#: src/bare-metal/aps/logging/using.md:5
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"mod exceptions;\n"
"mod logger;\n"
"mod pl011;\n"
"\n"
"use crate::pl011::Uart;\n"
"use core::panic::PanicInfo;\n"
"use log::{error, info, LevelFilter};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Base address of the primary PL011 UART.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 "
"device,\n"
"    // and nothing else accesses that address range.\n"
"    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"    logger::init(uart, LevelFilter::Trace).unwrap();\n"
"\n"
"    info!(\"main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})\");\n"
"\n"
"    assert_eq!(x1, 42);\n"
"\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[panic_handler]\n"
"fn panic(info: &PanicInfo) -> ! {\n"
"    error!(\"{info}\");\n"
"    system_off::<Hvc>().unwrap();\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/logging/using.md:46
msgid "Note that our panic handler can now log details of panics."
msgstr ""
"Ten en cuenta que nuestro controlador de _panic_ ahora ya puede registrar la "
"informaci√≥n de los p√°nicos."

#: src/bare-metal/aps/logging/using.md:47
msgid ""
"Run the example in QEMU with `make qemu_logger` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"Ejecuta el ejemplo en QEMU con `make qemu_logger` en `src/bare-metal/aps/"
"examples`."

#: src/bare-metal/aps/exceptions.md:3
msgid ""
"AArch64 defines an exception vector table with 16 entries, for 4 types of "
"exceptions (synchronous, IRQ, FIQ, SError) from 4 states (current EL with "
"SP0, current EL with SPx, lower EL using AArch64, lower EL using AArch32). "
"We implement this in assembly to save volatile registers to the stack before "
"calling into Rust code:"
msgstr ""
"AArch64 define una tabla de vectores de excepci√≥n con 16 entradas, para 4 "
"tipos de excepciones (synchronous, IRQ, FIQ, SError) desde 4 estados (EL "
"actual con SP0, EL actual con SPx, EL inferior con AArch64 y EL inferior con "
"AArch32). Implementamos esto en el ensamblaje para guardar los registros "
"vol√°tiles en la _stack_ antes de llamar al c√≥digo de Rust:"

#: src/bare-metal/aps/exceptions.md:8
msgid ""
"```rust,editable,compile_fail\n"
"use log::error;\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn sync_exception_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"sync_exception_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn irq_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"irq_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn fiq_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"fiq_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn serr_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"serr_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn sync_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"sync_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn irq_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"irq_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn fiq_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"fiq_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn serr_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"serr_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/exceptions.md:64
msgid "EL is exception level; all our examples this afternoon run in EL1."
msgstr ""
"EL significa nivel de excepci√≥n (por sus siglas en ingl√©s); todos nuestros "
"ejemplos de esta tarde se ejecutan en EL1."

#: src/bare-metal/aps/exceptions.md:65
msgid ""
"For simplicity we aren't distinguishing between SP0 and SPx for the current "
"EL exceptions, or between AArch32 and AArch64 for the lower EL exceptions."
msgstr ""
"Para simplificar, no distinguimos entre SP0 y SPx para las excepciones del "
"EL actual, ni entre AArch32 y AArch64 para las excepciones de EL inferiores."

#: src/bare-metal/aps/exceptions.md:67
msgid ""
"For this example we just log the exception and power down, as we don't "
"expect any of them to actually happen."
msgstr ""
"En este ejemplo, nos limitaremos a registrar la excepci√≥n y a apagarla, ya "
"que no esperamos que se produzca ninguna."

#: src/bare-metal/aps/exceptions.md:69
msgid ""
"We can think of exception handlers and our main execution context more or "
"less like different threads. [`Send` and `Sync`](../../concurrency/send-sync."
"md) will control what we can share between them, just like with threads. For "
"example, if we want to share some value between exception handlers and the "
"rest of the program, and it's `Send` but not `Sync`, then we'll need to wrap "
"it in something like a `Mutex` and put it in a static."
msgstr ""
"Podr√≠amos pensar en los controladores de excepciones y en nuestro contexto "
"de ejecuci√≥n principal como si fueran hilos diferentes. [`Send` y `Sync`]"
"(../../concurrency/send-sync.md) controlar√°n lo que podemos compartir entre "
"ellos, igual que con los hilos. Por ejemplo, si queremos compartir alg√∫n "
"valor entre los controladores de excepciones y el resto del programa, y es "
"`Send`en vez de `Sync`, necesitaremos envolverlo en un `Mutex`, por ejemplo, "
"y ponerlo en un est√°tico."

#: src/bare-metal/aps/other-projects.md:3
msgid "[oreboot](https://github.com/oreboot/oreboot)"
msgstr "[oreboot](https://github.com/oreboot/oreboot)"

#: src/bare-metal/aps/other-projects.md:4
msgid "\"coreboot without the C\""
msgstr "\"coreboot sin la C\"."

#: src/bare-metal/aps/other-projects.md:5
msgid "Supports x86, aarch64 and RISC-V."
msgstr "Compatible con x86, aarch64 y RISC-V."

#: src/bare-metal/aps/other-projects.md:6
msgid "Relies on LinuxBoot rather than having many drivers itself."
msgstr "Depende de LinuxBoot en lugar de tener controladores propios."

#: src/bare-metal/aps/other-projects.md:7
msgid ""
"[Rust RaspberryPi OS tutorial](https://github.com/rust-embedded/rust-"
"raspberrypi-OS-tutorials)"
msgstr ""
"[Tutorial del SO de Rust en RaspberryPi][Rust RaspberryPi OS tutorial]"
"(https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials)"

#: src/bare-metal/aps/other-projects.md:8
msgid ""
"Initialisation, UART driver, simple bootloader, JTAG, exception levels, "
"exception handling, page tables"
msgstr ""
"Inicializaci√≥n, controlador de UART, bootloader sencillo, JTAG, niveles de "
"excepci√≥n, gesti√≥n de excepciones, tablas de p√°ginas, etc."

#: src/bare-metal/aps/other-projects.md:10
msgid ""
"Some dodginess around cache maintenance and initialisation in Rust, not "
"necessarily a good example to copy for production code."
msgstr ""
"Algunas dudas sobre el mantenimiento de la cach√© y la inicializaci√≥n en "
"Rust, aunque no es precisamente un buen ejemplo para copiar en c√≥digo de "
"producci√≥n."

#: src/bare-metal/aps/other-projects.md:12
msgid "[`cargo-call-stack`](https://crates.io/crates/cargo-call-stack)"
msgstr "[`cargo-call-stack`](https://crates.io/crates/cargo-call-stack)"

#: src/bare-metal/aps/other-projects.md:13
msgid "Static analysis to determine maximum stack usage."
msgstr "An√°lisis est√°tico para determinar el uso m√°ximo de la _stack_."

#: src/bare-metal/aps/other-projects.md:17
msgid ""
"The RaspberryPi OS tutorial runs Rust code before the MMU and caches are "
"enabled. This will read and write memory (e.g. the stack). However:"
msgstr ""
"El tutorial del sistema operativo en RaspberryPi ejecuta c√≥digo de Rust "
"antes de que la MMU y las cach√©s se habiliten. De este modo, se leer√° y "
"escribir√° memoria (por ejemplo, la _stack_). Sin embargo:"

#: src/bare-metal/aps/other-projects.md:19
msgid ""
"Without the MMU and cache, unaligned accesses will fault. It builds with "
"`aarch64-unknown-none` which sets `+strict-align` to prevent the compiler "
"generating unaligned accesses so it should be alright, but this is not "
"necessarily the case in general."
msgstr ""
"Sin la MMU y la cach√©, los accesos no alineados fallar√°n. Se compila con "
"`aarch64-unknown-none`, que define `+strict-align` para evitar que el "
"compilador genere accesos no alineados. Deber√≠a estar bien, pero no tiene "
"por qu√© ser as√≠, en general."

#: src/bare-metal/aps/other-projects.md:22
msgid ""
"If it were running in a VM, this can lead to cache coherency issues. The "
"problem is that the VM is accessing memory directly with the cache disabled, "
"while the host has cacheable aliases to the same memory. Even if the host "
"doesn't explicitly access the memory, speculative accesses can lead to cache "
"fills, and then changes from one or the other will get lost. Again this is "
"alright in this particular case (running directly on the hardware with no "
"hypervisor), but isn't a good pattern in general."
msgstr ""
"Si se estuviera ejecutando en una m√°quina virtual, podr√≠a provocar problemas "
"de coherencia en la cach√©. El problema es que la m√°quina virtual accede a la "
"memoria directamente con la cach√© inhabilitada, mientras que el host cuenta "
"con alias que se pueden almacenar en cach√© en la misma memoria. Incluso si "
"el host no accede expl√≠citamente a la memoria, los accesos especulativos "
"pueden provocar que se llene la cach√©, haciendo que los cambios de uno u "
"otro se pierdan. De nuevo, es correcto en este caso particular (si se "
"ejecuta directamente en el hardware sin hipervisor) pero, por lo general, no "
"es un buen patr√≥n."

#: src/bare-metal/useful-crates.md:3
msgid ""
"We'll go over a few crates which solve some common problems in bare-metal "
"programming."
msgstr ""
"A continuaci√≥n, repasaremos algunos crates que resuelven ciertos problemas "
"comunes en la programaci√≥n bare-metal."

#: src/bare-metal/useful-crates/zerocopy.md:1
msgid "`zerocopy`"
msgstr "`zerocopy`"

#: src/bare-metal/useful-crates/zerocopy.md:3
msgid ""
"The [`zerocopy`](https://docs.rs/zerocopy/) crate (from Fuchsia) provides "
"traits and macros for safely converting between byte sequences and other "
"types."
msgstr ""
"El crate [`zerocopy`](https://docs.rs/zerocopy/) (de Fuchsia) proporciona "
"traits y macros para realizar conversiones seguras entre secuencias de bytes "
"y otros tipos."

#: src/bare-metal/useful-crates/zerocopy.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use zerocopy::AsBytes;\n"
"\n"
"#[repr(u32)]\n"
"#[derive(AsBytes, Debug, Default)]\n"
"enum RequestType {\n"
"    #[default]\n"
"    In = 0,\n"
"    Out = 1,\n"
"    Flush = 4,\n"
"}\n"
"\n"
"#[repr(C)]\n"
"#[derive(AsBytes, Debug, Default)]\n"
"struct VirtioBlockRequest {\n"
"    request_type: RequestType,\n"
"    reserved: u32,\n"
"    sector: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let request = VirtioBlockRequest {\n"
"        request_type: RequestType::Flush,\n"
"        sector: 42,\n"
"        ..Default::default()\n"
"    };\n"
"\n"
"    assert_eq!(\n"
"        request.as_bytes(),\n"
"        &[4, 0, 0, 0, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0]\n"
"    );\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/useful-crates/zerocopy.md:40
msgid ""
"This is not suitable for MMIO (as it doesn't use volatile reads and writes), "
"but can be useful for working with structures shared with hardware e.g. by "
"DMA, or sent over some external interface."
msgstr ""
"No es adecuado para MMIO (ya que no utiliza lecturas y escrituras "
"vol√°tiles), pero puede ser √∫til para trabajar con estructuras compartidas "
"con hardware (por ejemplo, mediante DMA) o enviadas a trav√©s de alguna "
"interfaz externa."

#: src/bare-metal/useful-crates/zerocopy.md:45
msgid ""
"`FromBytes` can be implemented for types for which any byte pattern is "
"valid, and so can safely be converted from an untrusted sequence of bytes."
msgstr ""
"`FromBytes` se puede implementar en tipos en los que cualquier patr√≥n de "
"bytes es v√°lido, por lo que se puede convertir de forma segura a partir de "
"una secuencia de bytes que no es fiable."

#: src/bare-metal/useful-crates/zerocopy.md:47
msgid ""
"Attempting to derive `FromBytes` for these types would fail, because "
"`RequestType` doesn't use all possible u32 values as discriminants, so not "
"all byte patterns are valid."
msgstr ""
"Si se intenta derivar `FromBytes` para estos tipos, se producir√≠a un error, "
"pues `RequestType` no utiliza todos los valores u32 posibles como "
"discriminantes y, por tanto, todos los patrones de bytes son v√°lidos."

#: src/bare-metal/useful-crates/zerocopy.md:49
msgid ""
"`zerocopy::byteorder` has types for byte-order aware numeric primitives."
msgstr ""
"`zerocopy::byteorder` tiene tipos para primitivos num√©ricos conscientes del "
"orden de bytes."

#: src/bare-metal/useful-crates/zerocopy.md:50
msgid ""
"Run the example with `cargo run` under `src/bare-metal/useful-crates/"
"zerocopy-example/`. (It won't run in the Playground because of the crate "
"dependency.)"
msgstr ""
"Ejecuta el ejemplo con `cargo run` en `src/bare-metal/useful-crates/zerocopy-"
"example/`. (No se ejecutar√° en  el playground debido a la dependencia del "
"crate)."

#: src/bare-metal/useful-crates/aarch64-paging.md:1
msgid "`aarch64-paging`"
msgstr "`aarch64-paging`"

#: src/bare-metal/useful-crates/aarch64-paging.md:3
msgid ""
"The [`aarch64-paging`](https://crates.io/crates/aarch64-paging) crate lets "
"you create page tables according to the AArch64 Virtual Memory System "
"Architecture."
msgstr ""
"El crate [`aarch64-paging`](https://crates.io/crates/aarch64-paging) permite "
"crear tablas de p√°ginas de acuerdo con la arquitectura del sistema de "
"memoria virtual AArch64."

#: src/bare-metal/useful-crates/aarch64-paging.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use aarch64_paging::{\n"
"    idmap::IdMap,\n"
"    paging::{Attributes, MemoryRegion},\n"
"};\n"
"\n"
"const ASID: usize = 1;\n"
"const ROOT_LEVEL: usize = 1;\n"
"\n"
"// Create a new page table with identity mapping.\n"
"let mut idmap = IdMap::new(ASID, ROOT_LEVEL);\n"
"// Map a 2 MiB region of memory as read-only.\n"
"idmap.map_range(\n"
"    &MemoryRegion::new(0x80200000, 0x80400000),\n"
"    Attributes::NORMAL | Attributes::NON_GLOBAL | Attributes::READ_ONLY,\n"
").unwrap();\n"
"// Set `TTBR0_EL1` to activate the page table.\n"
"idmap.activate();\n"
"```"
msgstr ""

#: src/bare-metal/useful-crates/aarch64-paging.md:28
msgid ""
"For now it only supports EL1, but support for other exception levels should "
"be straightforward to add."
msgstr ""
"Por ahora, solo es compatible con EL1, pero deber√≠a ser sencillo a√±adir "
"compatibilidad con otros niveles de excepci√≥n."

#: src/bare-metal/useful-crates/aarch64-paging.md:30
msgid ""
"This is used in Android for the [Protected VM Firmware](https://cs.android."
"com/android/platform/superproject/+/master:packages/modules/Virtualization/"
"pvmfw/)."
msgstr ""
"Se utiliza en Android para el [Firmware de M√°quina Virtual Protegida]"
"(https://cs.android.com/android/platform/superproject/+/master:packages/"
"modules/Virtualization/pvmfw/)."

#: src/bare-metal/useful-crates/aarch64-paging.md:31
msgid ""
"There's no easy way to run this example, as it needs to run on real hardware "
"or under QEMU."
msgstr ""
"No hay una forma sencilla de ejecutar este ejemplo, ya que debe hacerse en "
"hardware real o en QEMU."

#: src/bare-metal/useful-crates/buddy_system_allocator.md:1
msgid "`buddy_system_allocator`"
msgstr "`buddy_system_allocator`"

#: src/bare-metal/useful-crates/buddy_system_allocator.md:3
msgid ""
"[`buddy_system_allocator`](https://crates.io/crates/buddy_system_allocator) "
"is a third-party crate implementing a basic buddy system allocator. It can "
"be used both for [`LockedHeap`](https://docs.rs/buddy_system_allocator/0.9.0/"
"buddy_system_allocator/struct.LockedHeap.html) implementing [`GlobalAlloc`]"
"(https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html) so you can use "
"the standard `alloc` crate (as we saw [before](../alloc.md)), or for "
"allocating other address space. For example, we might want to allocate MMIO "
"space for PCI BARs:"
msgstr ""
"[`buddy_system_allocator`](https://crates.io/crates/buddy_system_allocator) "
"es un crate de terceros que implementa un asignador b√°sico del sistema "
"buddy. Se puede utilizar tanto para [`LockedHeap`](https://docs.rs/"
"buddy_system_allocator/0.9.0/buddy_system_allocator/struct.LockedHeap.html) "
"implementando [`GlobalAlloc`](https://doc.rust-lang.org/core/alloc/trait."
"GlobalAlloc.html), de forma que puedas usar el crate `alloc` est√°ndar (tal y "
"como vimos [antes](../alloc.md)), o para asignar otro espacio de "
"direcciones. Por ejemplo, podr√≠amos querer asignar espacio MMIO para los "
"registros de direcci√≥n base (BAR) de PCI:"

#: src/bare-metal/useful-crates/buddy_system_allocator.md:8
msgid ""
"```rust,editable,compile_fail\n"
"use buddy_system_allocator::FrameAllocator;\n"
"use core::alloc::Layout;\n"
"\n"
"fn main() {\n"
"    let mut allocator = FrameAllocator::<32>::new();\n"
"    allocator.add_frame(0x200_0000, 0x400_0000);\n"
"\n"
"    let layout = Layout::from_size_align(0x100, 0x100).unwrap();\n"
"    let bar = allocator\n"
"        .alloc_aligned(layout)\n"
"        .expect(\"Failed to allocate 0x100 byte MMIO region\");\n"
"    println!(\"Allocated 0x100 byte MMIO region at {:#x}\", bar);\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/useful-crates/buddy_system_allocator.md:26
msgid "PCI BARs always have alignment equal to their size."
msgstr "Los BAR de PCI siempre tienen una alineaci√≥n igual a su tama√±o."

#: src/bare-metal/useful-crates/buddy_system_allocator.md:27
msgid ""
"Run the example with `cargo run` under `src/bare-metal/useful-crates/"
"allocator-example/`. (It won't run in the Playground because of the crate "
"dependency.)"
msgstr ""
"Ejecuta el ejemplo con `cargo run` en `src/bare-metal/useful-crates/"
"allocator-example/`. (No se ejecutar√° en el playground debido a la "
"dependencia del crate)."

#: src/bare-metal/useful-crates/tinyvec.md:1
msgid "`tinyvec`"
msgstr "`tinyvec`"

#: src/bare-metal/useful-crates/tinyvec.md:3
msgid ""
"Sometimes you want something which can be resized like a `Vec`, but without "
"heap allocation. [`tinyvec`](https://crates.io/crates/tinyvec) provides "
"this: a vector backed by an array or slice, which could be statically "
"allocated or on the stack, which keeps track of how many elements are used "
"and panics if you try to use more than are allocated."
msgstr ""
"A veces, se necesita algo que se pueda cambiar de tama√±o, como `Vec`, pero "
"sin asignaci√≥n de _heap_. [`tinyvec`](https://crates.io/crates/tinyvec) "
"ofrece un vector respaldado por un array o slice, que se podr√≠a asignar "
"est√°ticamente o en la _stack_, y que hace un seguimiento de cu√°ntos "
"elementos se usan, entrando en _panic_ si intentas utilizar m√°s elementos de "
"los asignados."

#: src/bare-metal/useful-crates/tinyvec.md:8
msgid ""
"```rust,editable,compile_fail\n"
"use tinyvec::{array_vec, ArrayVec};\n"
"\n"
"fn main() {\n"
"    let mut numbers: ArrayVec<[u32; 5]> = array_vec!(42, 66);\n"
"    println!(\"{numbers:?}\");\n"
"    numbers.push(7);\n"
"    println!(\"{numbers:?}\");\n"
"    numbers.remove(1);\n"
"    println!(\"{numbers:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/useful-crates/tinyvec.md:23
msgid ""
"`tinyvec` requires that the element type implement `Default` for "
"initialisation."
msgstr ""
"`tinyvec` requiere que el tipo de elemento implemente `Default` para la "
"inicializaci√≥n."

#: src/bare-metal/useful-crates/tinyvec.md:24
msgid ""
"The Rust Playground includes `tinyvec`, so this example will run fine inline."
msgstr ""
"El playground de Rust incluye `tinyvec`, por lo que este ejemplo se "
"ejecutar√° bien aunque est√© insertado."

#: src/bare-metal/useful-crates/spin.md:1
msgid "`spin`"
msgstr "`spin`"

#: src/bare-metal/useful-crates/spin.md:3
msgid ""
"`std::sync::Mutex` and the other synchronisation primitives from `std::sync` "
"are not available in `core` or `alloc`. How can we manage synchronisation or "
"interior mutability, such as for sharing state between different CPUs?"
msgstr ""
"`std::sync::Mutex` y el resto de los primitivos de sincronizaci√≥n de `std::"
"sync` no est√°n disponibles en `core` o `alloc`. ¬øC√≥mo podemos gestionar la "
"sincronizaci√≥n o la mutabilidad interior para, por ejemplo, compartir el "
"estado entre diferentes CPUs?"

#: src/bare-metal/useful-crates/spin.md:7
msgid ""
"The [`spin`](https://crates.io/crates/spin) crate provides spinlock-based "
"equivalents of many of these primitives."
msgstr ""
"El crate [`spin`](https://crates.io/crates/spin) proporciona equivalentes "
"basados en spinlocks de muchos de estos primitivos."

#: src/bare-metal/useful-crates/spin.md:9
msgid ""
"```rust,editable,compile_fail\n"
"use spin::mutex::SpinMutex;\n"
"\n"
"static counter: SpinMutex<u32> = SpinMutex::new(0);\n"
"\n"
"fn main() {\n"
"    println!(\"count: {}\", counter.lock());\n"
"    *counter.lock() += 2;\n"
"    println!(\"count: {}\", counter.lock());\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/useful-crates/spin.md:23
msgid "Be careful to avoid deadlock if you take locks in interrupt handlers."
msgstr ""
"Intenta evitar interbloqueos si usas bloqueos en los controladores de las "
"interrupciones."

#: src/bare-metal/useful-crates/spin.md:24
msgid ""
"`spin` also has a ticket lock mutex implementation; equivalents of `RwLock`, "
"`Barrier` and `Once` from `std::sync`;  and `Lazy` for lazy initialisation."
msgstr ""
"`spin` tambi√©n cuenta con una implementaci√≥n de exclusi√≥n mutua de bloqueo "
"de tickets; equivalentes de `RwLock`, `Barrier` y `Once` de `std::sync`, y "
"`Lazy` para inicializaci√≥n perezosa"

#: src/bare-metal/useful-crates/spin.md:26
msgid ""
"The [`once_cell`](https://crates.io/crates/once_cell) crate also has some "
"useful types for late initialisation with a slightly different approach to "
"`spin::once::Once`."
msgstr ""
"El crate [`once_cell`](https://crates.io/crates/once_cell) tambi√©n tiene "
"algunos tipos √∫tiles de inicializaci√≥n tard√≠a con un enfoque ligeramente "
"distinto al de `spin::once::Once`."

#: src/bare-metal/useful-crates/spin.md:28
msgid ""
"The Rust Playground includes `spin`, so this example will run fine inline."
msgstr ""
"El playground de Rust incluye `spin`, por lo que este ejemplo se ejecutar√° "
"bien aunque est√° insertado."

#: src/bare-metal/android.md:3
msgid ""
"To build a bare-metal Rust binary in AOSP, you need to use a "
"`rust_ffi_static` Soong rule to build your Rust code, then a `cc_binary` "
"with a linker script to produce the binary itself, and then a `raw_binary` "
"to convert the ELF to a raw binary ready to be run."
msgstr ""
"Para compilar un binario de Rust bare-metal en AOSP, tienes que usar una "
"regla `rust_ffi_static` de Soong para crear tu c√≥digo Rust y, seguidamente, "
"un `cc_binary` con una secuencia de comandos de enlazador para producir el "
"binario en s√≠. Por √∫ltimo, un `raw_binary` para convertir el ELF en un "
"binario sin formato que pueda ejecutarse."

#: src/bare-metal/android.md:7
msgid ""
"```soong\n"
"rust_ffi_static {\n"
"    name: \"libvmbase_example\",\n"
"    defaults: [\"vmbase_ffi_defaults\"],\n"
"    crate_name: \"vmbase_example\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"libvmbase\",\n"
"    ],\n"
"}\n"
"\n"
"cc_binary {\n"
"    name: \"vmbase_example\",\n"
"    defaults: [\"vmbase_elf_defaults\"],\n"
"    srcs: [\n"
"        \"idmap.S\",\n"
"    ],\n"
"    static_libs: [\n"
"        \"libvmbase_example\",\n"
"    ],\n"
"    linker_scripts: [\n"
"        \"image.ld\",\n"
"        \":vmbase_sections\",\n"
"    ],\n"
"}\n"
"\n"
"raw_binary {\n"
"    name: \"vmbase_example_bin\",\n"
"    stem: \"vmbase_example.bin\",\n"
"    src: \":vmbase_example\",\n"
"    enabled: false,\n"
"    target: {\n"
"        android_arm64: {\n"
"            enabled: true,\n"
"        },\n"
"    },\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/android/vmbase.md:3
msgid ""
"For VMs running under crosvm on aarch64, the [vmbase](https://android."
"googlesource.com/platform/packages/modules/Virtualization/+/refs/heads/"
"master/vmbase/) library provides a linker script and useful defaults for the "
"build rules, along with an entry point, UART console logging and more."
msgstr ""
"En el caso de las m√°quinas virtuales que se ejecutan con crosvm en aarch64, "
"la biblioteca [vmbase](https://android.googlesource.com/platform/packages/"
"modules/Virtualization/+/refs/heads/master/vmbase/) proporciona una "
"secuencia de comandos de enlazador y valores predeterminados √∫tiles para las "
"reglas de compilaci√≥n, adem√°s de un punto de entrada, registro de la consola "
"UART y mucho m√°s."

#: src/bare-metal/android/vmbase.md:6
msgid ""
"```rust,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"use vmbase::{main, println};\n"
"\n"
"main!(main);\n"
"\n"
"pub fn main(arg0: u64, arg1: u64, arg2: u64, arg3: u64) {\n"
"    println!(\"Hello world\");\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/android/vmbase.md:21
msgid ""
"The `main!` macro marks your main function, to be called from the `vmbase` "
"entry point."
msgstr ""
"La macro `main!` indica tu funci√≥n principal, que se llama desde el punto de "
"entrada `vmbase`."

#: src/bare-metal/android/vmbase.md:22
msgid ""
"The `vmbase` entry point handles console initialisation, and issues a "
"PSCI_SYSTEM_OFF to shutdown the VM if your main function returns."
msgstr ""
"El punto de entrada `vmbase` gestiona la inicializaci√≥n de la consola y "
"emite PSCI_SYSTEM_OFF para apagar la m√°quina virtual si tu funci√≥n principal "
"devuelve un resultado."

#: src/exercises/bare-metal/afternoon.md:3
msgid "We will write a driver for the PL031 real-time clock device."
msgstr ""
"Escribiremos un controlador para el dispositivo de reloj en tiempo real "
"PL031."

#: src/exercises/bare-metal/rtc.md:1
#: src/exercises/bare-metal/solutions-afternoon.md:3
msgid "RTC driver"
msgstr "Controlador RTC"

#: src/exercises/bare-metal/rtc.md:3
msgid ""
"The QEMU aarch64 virt machine has a [PL031](https://developer.arm.com/"
"documentation/ddi0224/c) real-time clock at 0x9010000. For this exercise, "
"you should write a driver for it."
msgstr ""
"La m√°quina virtual aarch64 de QEMU tiene un reloj en tiempo real [PL031]"
"(https://developer.arm.com/documentation/ddi0224/c) en 0x9010000. En este "
"ejercicio, debes escribir un controlador para el reloj."

#: src/exercises/bare-metal/rtc.md:6
msgid ""
"Use it to print the current time to the serial console. You can use the "
"[`chrono`](https://crates.io/crates/chrono) crate for date/time formatting."
msgstr ""
"√ösalo para imprimir la hora en la consola serie. Puedes usar el crate "
"[`chrono`](https://crates.io/crates/chrono) para dar formato a la fecha y la "
"hora."

#: src/exercises/bare-metal/rtc.md:8
msgid ""
"Use the match register and raw interrupt status to busy-wait until a given "
"time, e.g. 3 seconds in the future. (Call [`core::hint::spin_loop`](https://"
"doc.rust-lang.org/core/hint/fn.spin_loop.html) inside the loop.)"
msgstr ""
"Utiliza el registro de coincidencias y el estado de interrupci√≥n sin formato "
"para esperar hasta un momento dado, por ejemplo, un adelanto de 3 segundos. "
"(Llama a [`core::hint::spin_loop`](https://doc.rust-lang.org/core/hint/fn."
"spin_loop.html) dentro d+el bucle)."

#: src/exercises/bare-metal/rtc.md:10
msgid ""
"_Extension if you have time:_ Enable and handle the interrupt generated by "
"the RTC match. You can use the driver provided in the [`arm-gic`](https://"
"docs.rs/arm-gic/) crate to configure the Arm Generic Interrupt Controller."
msgstr ""
"_Ampliaci√≥n si hay tiempo:_ habilita y gestiona la interrupci√≥n que genera "
"la coincidencia de RTC. Puedes usar el controlador que se proporciona con el "
"crate [`arm-gic`](https://docs.rs/arm-gic/) para configurar el controlador "
"de interrupciones gen√©rico (GIC) de Arm."

#: src/exercises/bare-metal/rtc.md:12
msgid "Use the RTC interrupt, which is wired to the GIC as `IntId::spi(2)`."
msgstr ""
"Utiliza la interrupci√≥n de RTC, que est√° conectada al GIC como `IntId::"
"spi(2)`."

#: src/exercises/bare-metal/rtc.md:13
msgid ""
"Once the interrupt is enabled, you can put the core to sleep via `arm_gic::"
"wfi()`, which will cause the core to sleep until it receives an interrupt."
msgstr ""
"Despu√©s de habilitar la interrupci√≥n, puedes poner el n√∫cleo en suspensi√≥n "
"mediante `arm_gic::wfi()`, lo que har√° que entre en suspensi√≥n hasta que "
"reciba una interrupci√≥n."

#: src/exercises/bare-metal/rtc.md:16
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and "
"look in the `rtc` directory for the following files."
msgstr ""
"Descarga la [plantilla de ejercicio](../../comprehensive-rust-exercises.zip) "
"y busca en el directorio `rtc` los siguientes archivos."

#: src/exercises/bare-metal/rtc.md:23
msgid ""
"```rust,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"mod exceptions;\n"
"mod logger;\n"
"mod pl011;\n"
"\n"
"use crate::pl011::Uart;\n"
"use arm_gic::gicv3::GicV3;\n"
"use core::panic::PanicInfo;\n"
"use log::{error, info, trace, LevelFilter};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Base addresses of the GICv3.\n"
"const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;\n"
"const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 as _;\n"
"\n"
"/// Base address of the primary PL011 UART.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 "
"device,\n"
"    // and nothing else accesses that address range.\n"
"    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"    logger::init(uart, LevelFilter::Trace).unwrap();\n"
"\n"
"    info!(\"main({:#x}, {:#x}, {:#x}, {:#x})\", x0, x1, x2, x3);\n"
"\n"
"    // Safe because `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the "
"base\n"
"    // addresses of a GICv3 distributor and redistributor respectively, and\n"
"    // nothing else accesses those address ranges.\n"
"    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, "
"GICR_BASE_ADDRESS) };\n"
"    gic.setup();\n"
"\n"
"    // TODO: Create instance of RTC driver and print current time.\n"
"\n"
"    // TODO: Wait for 3 seconds.\n"
"\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[panic_handler]\n"
"fn panic(info: &PanicInfo) -> ! {\n"
"    error!(\"{info}\");\n"
"    system_off::<Hvc>().unwrap();\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:75
msgid ""
"`src/exceptions.rs` (you should only need to change this for the 3rd part of "
"the exercise):"
msgstr ""
"`src/exceptions.rs` (solo se deber√≠a cambiar esto en la tercera parte del "
"ejercicio):"

#: src/exercises/bare-metal/rtc.md:79
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"use arm_gic::gicv3::GicV3;\n"
"use log::{error, info, trace};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn sync_exception_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"sync_exception_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn irq_current(_elr: u64, _spsr: u64) {\n"
"    trace!(\"irq_current\");\n"
"    let intid = GicV3::get_and_acknowledge_interrupt().expect(\"No pending "
"interrupt\");\n"
"    info!(\"IRQ {intid:?}\");\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn fiq_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"fiq_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn serr_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"serr_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn sync_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"sync_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn irq_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"irq_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn fiq_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"fiq_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn serr_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"serr_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:149
msgid "`src/logger.rs` (you shouldn't need to change this):"
msgstr "`src/logger.rs` (no deber√≠a ser necesario cambiarlo):"

#: src/exercises/bare-metal/rtc.md:153
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: main\n"
"use crate::pl011::Uart;\n"
"use core::fmt::Write;\n"
"use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};\n"
"use spin::mutex::SpinMutex;\n"
"\n"
"static LOGGER: Logger = Logger {\n"
"    uart: SpinMutex::new(None),\n"
"};\n"
"\n"
"struct Logger {\n"
"    uart: SpinMutex<Option<Uart>>,\n"
"}\n"
"\n"
"impl Log for Logger {\n"
"    fn enabled(&self, _metadata: &Metadata) -> bool {\n"
"        true\n"
"    }\n"
"\n"
"    fn log(&self, record: &Record) {\n"
"        writeln!(\n"
"            self.uart.lock().as_mut().unwrap(),\n"
"            \"[{}] {}\",\n"
"            record.level(),\n"
"            record.args()\n"
"        )\n"
"        .unwrap();\n"
"    }\n"
"\n"
"    fn flush(&self) {}\n"
"}\n"
"\n"
"/// Initialises UART logger.\n"
"pub fn init(uart: Uart, max_level: LevelFilter) -> Result<(), "
"SetLoggerError> {\n"
"    LOGGER.uart.lock().replace(uart);\n"
"\n"
"    log::set_logger(&LOGGER)?;\n"
"    log::set_max_level(max_level);\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:210
msgid "`src/pl011.rs` (you shouldn't need to change this):"
msgstr "`src/pl011.rs` (no deber√≠a ser necesario cambiarlo):"

#: src/exercises/bare-metal/rtc.md:214
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"#![allow(unused)]\n"
"\n"
"use core::fmt::{self, Write};\n"
"use core::ptr::{addr_of, addr_of_mut};\n"
"\n"
"// ANCHOR: Flags\n"
"use bitflags::bitflags;\n"
"\n"
"bitflags! {\n"
"    /// Flags from the UART flag register.\n"
"    #[repr(transparent)]\n"
"    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n"
"    struct Flags: u16 {\n"
"        /// Clear to send.\n"
"        const CTS = 1 << 0;\n"
"        /// Data set ready.\n"
"        const DSR = 1 << 1;\n"
"        /// Data carrier detect.\n"
"        const DCD = 1 << 2;\n"
"        /// UART busy transmitting data.\n"
"        const BUSY = 1 << 3;\n"
"        /// Receive FIFO is empty.\n"
"        const RXFE = 1 << 4;\n"
"        /// Transmit FIFO is full.\n"
"        const TXFF = 1 << 5;\n"
"        /// Receive FIFO is full.\n"
"        const RXFF = 1 << 6;\n"
"        /// Transmit FIFO is empty.\n"
"        const TXFE = 1 << 7;\n"
"        /// Ring indicator.\n"
"        const RI = 1 << 8;\n"
"    }\n"
"}\n"
"// ANCHOR_END: Flags\n"
"\n"
"bitflags! {\n"
"    /// Flags from the UART Receive Status Register / Error Clear Register.\n"
"    #[repr(transparent)]\n"
"    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n"
"    struct ReceiveStatus: u16 {\n"
"        /// Framing error.\n"
"        const FE = 1 << 0;\n"
"        /// Parity error.\n"
"        const PE = 1 << 1;\n"
"        /// Break error.\n"
"        const BE = 1 << 2;\n"
"        /// Overrun error.\n"
"        const OE = 1 << 3;\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Registers\n"
"#[repr(C, align(4))]\n"
"struct Registers {\n"
"    dr: u16,\n"
"    _reserved0: [u8; 2],\n"
"    rsr: ReceiveStatus,\n"
"    _reserved1: [u8; 19],\n"
"    fr: Flags,\n"
"    _reserved2: [u8; 6],\n"
"    ilpr: u8,\n"
"    _reserved3: [u8; 3],\n"
"    ibrd: u16,\n"
"    _reserved4: [u8; 2],\n"
"    fbrd: u8,\n"
"    _reserved5: [u8; 3],\n"
"    lcr_h: u8,\n"
"    _reserved6: [u8; 3],\n"
"    cr: u16,\n"
"    _reserved7: [u8; 3],\n"
"    ifls: u8,\n"
"    _reserved8: [u8; 3],\n"
"    imsc: u16,\n"
"    _reserved9: [u8; 2],\n"
"    ris: u16,\n"
"    _reserved10: [u8; 2],\n"
"    mis: u16,\n"
"    _reserved11: [u8; 2],\n"
"    icr: u16,\n"
"    _reserved12: [u8; 2],\n"
"    dmacr: u8,\n"
"    _reserved13: [u8; 3],\n"
"}\n"
"// ANCHOR_END: Registers\n"
"\n"
"// ANCHOR: Uart\n"
"/// Driver for a PL011 UART.\n"
"#[derive(Debug)]\n"
"pub struct Uart {\n"
"    registers: *mut Registers,\n"
"}\n"
"\n"
"impl Uart {\n"
"    /// Constructs a new instance of the UART driver for a PL011 device at "
"the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
"    pub unsafe fn new(base_address: *mut u32) -> Self {\n"
"        Self {\n"
"            registers: base_address as *mut Registers,\n"
"        }\n"
"    }\n"
"\n"
"    /// Writes a single byte to the UART.\n"
"    pub fn write_byte(&self, byte: u8) {\n"
"        // Wait until there is room in the TX buffer.\n"
"        while self.read_flag_register().contains(Flags::TXFF) {}\n"
"\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe {\n"
"            // Write to the TX buffer.\n"
"            addr_of_mut!((*self.registers).dr).write_volatile(byte.into());\n"
"        }\n"
"\n"
"        // Wait until the UART is no longer busy.\n"
"        while self.read_flag_register().contains(Flags::BUSY) {}\n"
"    }\n"
"\n"
"    /// Reads and returns a pending byte, or `None` if nothing has been "
"received.\n"
"    pub fn read_byte(&self) -> Option<u8> {\n"
"        if self.read_flag_register().contains(Flags::RXFE) {\n"
"            None\n"
"        } else {\n"
"            let data = unsafe { addr_of!((*self.registers).dr)."
"read_volatile() };\n"
"            // TODO: Check for error conditions in bits 8-11.\n"
"            Some(data as u8)\n"
"        }\n"
"    }\n"
"\n"
"    fn read_flag_register(&self) -> Flags {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe { addr_of!((*self.registers).fr).read_volatile() }\n"
"    }\n"
"}\n"
"// ANCHOR_END: Uart\n"
"\n"
"impl Write for Uart {\n"
"    fn write_str(&mut self, s: &str) -> fmt::Result {\n"
"        for c in s.as_bytes() {\n"
"            self.write_byte(*c);\n"
"        }\n"
"        Ok(())\n"
"    }\n"
"}\n"
"\n"
"// Safe because it just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
"unsafe impl Send for Uart {}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:389
msgid ""
"```toml\n"
"[workspace]\n"
"\n"
"[package]\n"
"name = \"rtc\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"arm-gic = \"0.1.0\"\n"
"bitflags = \"2.0.0\"\n"
"chrono = { version = \"0.4.24\", default-features = false }\n"
"log = \"0.4.17\"\n"
"smccc = \"0.1.1\"\n"
"spin = \"0.9.8\"\n"
"\n"
"[build-dependencies]\n"
"cc = \"1.0.73\"\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:410
msgid "`build.rs` (you shouldn't need to change this):"
msgstr "`build.rs` (no deber√≠a ser necesario cambiarlo):"

#: src/exercises/bare-metal/rtc.md:414
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"use cc::Build;\n"
"use std::env;\n"
"\n"
"fn main() {\n"
"    #[cfg(target_os = \"linux\")]\n"
"    env::set_var(\"CROSS_COMPILE\", \"aarch64-linux-gnu\");\n"
"    #[cfg(not(target_os = \"linux\"))]\n"
"    env::set_var(\"CROSS_COMPILE\", \"aarch64-none-elf\");\n"
"\n"
"    Build::new()\n"
"        .file(\"entry.S\")\n"
"        .file(\"exceptions.S\")\n"
"        .file(\"idmap.S\")\n"
"        .compile(\"empty\")\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:446
msgid "`entry.S` (you shouldn't need to change this):"
msgstr "`entry.S` (no deber√≠a ser necesario cambiarlo):"

#: src/exercises/bare-metal/rtc.md:450
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
".macro adr_l, reg:req, sym:req\n"
"\tadrp \\reg, \\sym\n"
"\tadd \\reg, \\reg, :lo12:\\sym\n"
".endm\n"
"\n"
".macro mov_i, reg:req, imm:req\n"
"\tmovz \\reg, :abs_g3:\\imm\n"
"\tmovk \\reg, :abs_g2_nc:\\imm\n"
"\tmovk \\reg, :abs_g1_nc:\\imm\n"
"\tmovk \\reg, :abs_g0_nc:\\imm\n"
".endm\n"
"\n"
".set .L_MAIR_DEV_nGnRE,\t0x04\n"
".set .L_MAIR_MEM_WBWA,\t0xff\n"
".set .Lmairval, .L_MAIR_DEV_nGnRE | (.L_MAIR_MEM_WBWA << 8)\n"
"\n"
"/* 4 KiB granule size for TTBR0_EL1. */\n"
".set .L_TCR_TG0_4KB, 0x0 << 14\n"
"/* 4 KiB granule size for TTBR1_EL1. */\n"
".set .L_TCR_TG1_4KB, 0x2 << 30\n"
"/* Disable translation table walk for TTBR1_EL1, generating a translation "
"fault instead. */\n"
".set .L_TCR_EPD1, 0x1 << 23\n"
"/* Translation table walks for TTBR0_EL1 are inner sharable. */\n"
".set .L_TCR_SH_INNER, 0x3 << 12\n"
"/*\n"
" * Translation table walks for TTBR0_EL1 are outer write-back read-allocate "
"write-allocate\n"
" * cacheable.\n"
" */\n"
".set .L_TCR_RGN_OWB, 0x1 << 10\n"
"/*\n"
" * Translation table walks for TTBR0_EL1 are inner write-back read-allocate "
"write-allocate\n"
" * cacheable.\n"
" */\n"
".set .L_TCR_RGN_IWB, 0x1 << 8\n"
"/* Size offset for TTBR0_EL1 is 2**39 bytes (512 GiB). */\n"
".set .L_TCR_T0SZ_512, 64 - 39\n"
".set .Ltcrval, .L_TCR_TG0_4KB | .L_TCR_TG1_4KB | .L_TCR_EPD1 | ."
"L_TCR_RGN_OWB\n"
".set .Ltcrval, .Ltcrval | .L_TCR_RGN_IWB | .L_TCR_SH_INNER | ."
"L_TCR_T0SZ_512\n"
"\n"
"/* Stage 1 instruction access cacheability is unaffected. */\n"
".set .L_SCTLR_ELx_I, 0x1 << 12\n"
"/* SP alignment fault if SP is not aligned to a 16 byte boundary. */\n"
".set .L_SCTLR_ELx_SA, 0x1 << 3\n"
"/* Stage 1 data access cacheability is unaffected. */\n"
".set .L_SCTLR_ELx_C, 0x1 << 2\n"
"/* EL0 and EL1 stage 1 MMU enabled. */\n"
".set .L_SCTLR_ELx_M, 0x1 << 0\n"
"/* Privileged Access Never is unchanged on taking an exception to EL1. */\n"
".set .L_SCTLR_EL1_SPAN, 0x1 << 23\n"
"/* SETEND instruction disabled at EL0 in aarch32 mode. */\n"
".set .L_SCTLR_EL1_SED, 0x1 << 8\n"
"/* Various IT instructions are disabled at EL0 in aarch32 mode. */\n"
".set .L_SCTLR_EL1_ITD, 0x1 << 7\n"
".set .L_SCTLR_EL1_RES1, (0x1 << 11) | (0x1 << 20) | (0x1 << 22) | (0x1 << "
"28) | (0x1 << 29)\n"
".set .Lsctlrval, .L_SCTLR_ELx_M | .L_SCTLR_ELx_C | .L_SCTLR_ELx_SA | ."
"L_SCTLR_EL1_ITD | .L_SCTLR_EL1_SED\n"
".set .Lsctlrval, .Lsctlrval | .L_SCTLR_ELx_I | .L_SCTLR_EL1_SPAN | ."
"L_SCTLR_EL1_RES1\n"
"\n"
"/**\n"
" * This is a generic entry point for an image. It carries out the operations "
"required to prepare the\n"
" * loaded image to be run. Specifically, it zeroes the bss section using "
"registers x25 and above,\n"
" * prepares the stack, enables floating point, and sets up the exception "
"vector. It preserves x0-x3\n"
" * for the Rust entry point, as these may contain boot parameters.\n"
" */\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"\t/* Load and apply the memory management configuration, ready to enable MMU "
"and caches. */\n"
"\tadrp x30, idmap\n"
"\tmsr ttbr0_el1, x30\n"
"\n"
"\tmov_i x30, .Lmairval\n"
"\tmsr mair_el1, x30\n"
"\n"
"\tmov_i x30, .Ltcrval\n"
"\t/* Copy the supported PA range into TCR_EL1.IPS. */\n"
"\tmrs x29, id_aa64mmfr0_el1\n"
"\tbfi x30, x29, #32, #4\n"
"\n"
"\tmsr tcr_el1, x30\n"
"\n"
"\tmov_i x30, .Lsctlrval\n"
"\n"
"\t/*\n"
"\t * Ensure everything before this point has completed, then invalidate any "
"potentially stale\n"
"\t * local TLB entries before they start being used.\n"
"\t */\n"
"\tisb\n"
"\ttlbi vmalle1\n"
"\tic iallu\n"
"\tdsb nsh\n"
"\tisb\n"
"\n"
"\t/*\n"
"\t * Configure sctlr_el1 to enable MMU and cache and don't proceed until "
"this has completed.\n"
"\t */\n"
"\tmsr sctlr_el1, x30\n"
"\tisb\n"
"\n"
"\t/* Disable trapping floating point access in EL1. */\n"
"\tmrs x30, cpacr_el1\n"
"\torr x30, x30, #(0x3 << 20)\n"
"\tmsr cpacr_el1, x30\n"
"\tisb\n"
"\n"
"\t/* Zero out the bss section. */\n"
"\tadr_l x29, bss_begin\n"
"\tadr_l x30, bss_end\n"
"0:\tcmp x29, x30\n"
"\tb.hs 1f\n"
"\tstp xzr, xzr, [x29], #16\n"
"\tb 0b\n"
"\n"
"1:\t/* Prepare the stack. */\n"
"\tadr_l x30, boot_stack_end\n"
"\tmov sp, x30\n"
"\n"
"\t/* Set up exception vector. */\n"
"\tadr x30, vector_table_el1\n"
"\tmsr vbar_el1, x30\n"
"\n"
"\t/* Call into Rust code. */\n"
"\tbl main\n"
"\n"
"\t/* Loop forever waiting for interrupts. */\n"
"2:\twfi\n"
"\tb 2b\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:595
msgid "`exceptions.S` (you shouldn't need to change this):"
msgstr "`exceptions.S` (no deber√≠a ser necesario cambiarlo):"

#: src/exercises/bare-metal/rtc.md:599
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"/**\n"
" * Saves the volatile registers onto the stack. This currently takes 14\n"
" * instructions, so it can be used in exception handlers with 18 "
"instructions\n"
" * left.\n"
" *\n"
" * On return, x0 and x1 are initialised to elr_el2 and spsr_el2 "
"respectively,\n"
" * which can be used as the first and second arguments of a subsequent "
"call.\n"
" */\n"
".macro save_volatile_to_stack\n"
"\t/* Reserve stack space and save registers x0-x18, x29 & x30. */\n"
"\tstp x0, x1, [sp, #-(8 * 24)]!\n"
"\tstp x2, x3, [sp, #8 * 2]\n"
"\tstp x4, x5, [sp, #8 * 4]\n"
"\tstp x6, x7, [sp, #8 * 6]\n"
"\tstp x8, x9, [sp, #8 * 8]\n"
"\tstp x10, x11, [sp, #8 * 10]\n"
"\tstp x12, x13, [sp, #8 * 12]\n"
"\tstp x14, x15, [sp, #8 * 14]\n"
"\tstp x16, x17, [sp, #8 * 16]\n"
"\tstr x18, [sp, #8 * 18]\n"
"\tstp x29, x30, [sp, #8 * 20]\n"
"\n"
"\t/*\n"
"\t * Save elr_el1 & spsr_el1. This such that we can take nested exception\n"
"\t * and still be able to unwind.\n"
"\t */\n"
"\tmrs x0, elr_el1\n"
"\tmrs x1, spsr_el1\n"
"\tstp x0, x1, [sp, #8 * 22]\n"
".endm\n"
"\n"
"/**\n"
" * Restores the volatile registers from the stack. This currently takes 14\n"
" * instructions, so it can be used in exception handlers while still leaving "
"18\n"
" * instructions left; if paired with save_volatile_to_stack, there are 4\n"
" * instructions to spare.\n"
" */\n"
".macro restore_volatile_from_stack\n"
"\t/* Restore registers x2-x18, x29 & x30. */\n"
"\tldp x2, x3, [sp, #8 * 2]\n"
"\tldp x4, x5, [sp, #8 * 4]\n"
"\tldp x6, x7, [sp, #8 * 6]\n"
"\tldp x8, x9, [sp, #8 * 8]\n"
"\tldp x10, x11, [sp, #8 * 10]\n"
"\tldp x12, x13, [sp, #8 * 12]\n"
"\tldp x14, x15, [sp, #8 * 14]\n"
"\tldp x16, x17, [sp, #8 * 16]\n"
"\tldr x18, [sp, #8 * 18]\n"
"\tldp x29, x30, [sp, #8 * 20]\n"
"\n"
"\t/* Restore registers elr_el1 & spsr_el1, using x0 & x1 as scratch. */\n"
"\tldp x0, x1, [sp, #8 * 22]\n"
"\tmsr elr_el1, x0\n"
"\tmsr spsr_el1, x1\n"
"\n"
"\t/* Restore x0 & x1, and release stack space. */\n"
"\tldp x0, x1, [sp], #8 * 24\n"
".endm\n"
"\n"
"/**\n"
" * This is a generic handler for exceptions taken at the current EL while "
"using\n"
" * SP0. It behaves similarly to the SPx case by first switching to SPx, "
"doing\n"
" * the work, then switching back to SP0 before returning.\n"
" *\n"
" * Switching to SPx and calling the Rust handler takes 16 instructions. To\n"
" * restore and return we need an additional 16 instructions, so we can "
"implement\n"
" * the whole handler within the allotted 32 instructions.\n"
" */\n"
".macro current_exception_sp0 handler:req\n"
"\tmsr spsel, #1\n"
"\tsave_volatile_to_stack\n"
"\tbl \\handler\n"
"\trestore_volatile_from_stack\n"
"\tmsr spsel, #0\n"
"\teret\n"
".endm\n"
"\n"
"/**\n"
" * This is a generic handler for exceptions taken at the current EL while "
"using\n"
" * SPx. It saves volatile registers, calls the Rust handler, restores "
"volatile\n"
" * registers, then returns.\n"
" *\n"
" * This also works for exceptions taken from EL0, if we don't care about\n"
" * non-volatile registers.\n"
" *\n"
" * Saving state and jumping to the Rust handler takes 15 instructions, and\n"
" * restoring and returning also takes 15 instructions, so we can fit the "
"whole\n"
" * handler in 30 instructions, under the limit of 32.\n"
" */\n"
".macro current_exception_spx handler:req\n"
"\tsave_volatile_to_stack\n"
"\tbl \\handler\n"
"\trestore_volatile_from_stack\n"
"\teret\n"
".endm\n"
"\n"
".section .text.vector_table_el1, \"ax\"\n"
".global vector_table_el1\n"
".balign 0x800\n"
"vector_table_el1:\n"
"sync_cur_sp0:\n"
"\tcurrent_exception_sp0 sync_exception_current\n"
"\n"
".balign 0x80\n"
"irq_cur_sp0:\n"
"\tcurrent_exception_sp0 irq_current\n"
"\n"
".balign 0x80\n"
"fiq_cur_sp0:\n"
"\tcurrent_exception_sp0 fiq_current\n"
"\n"
".balign 0x80\n"
"serr_cur_sp0:\n"
"\tcurrent_exception_sp0 serr_current\n"
"\n"
".balign 0x80\n"
"sync_cur_spx:\n"
"\tcurrent_exception_spx sync_exception_current\n"
"\n"
".balign 0x80\n"
"irq_cur_spx:\n"
"\tcurrent_exception_spx irq_current\n"
"\n"
".balign 0x80\n"
"fiq_cur_spx:\n"
"\tcurrent_exception_spx fiq_current\n"
"\n"
".balign 0x80\n"
"serr_cur_spx:\n"
"\tcurrent_exception_spx serr_current\n"
"\n"
".balign 0x80\n"
"sync_lower_64:\n"
"\tcurrent_exception_spx sync_lower\n"
"\n"
".balign 0x80\n"
"irq_lower_64:\n"
"\tcurrent_exception_spx irq_lower\n"
"\n"
".balign 0x80\n"
"fiq_lower_64:\n"
"\tcurrent_exception_spx fiq_lower\n"
"\n"
".balign 0x80\n"
"serr_lower_64:\n"
"\tcurrent_exception_spx serr_lower\n"
"\n"
".balign 0x80\n"
"sync_lower_32:\n"
"\tcurrent_exception_spx sync_lower\n"
"\n"
".balign 0x80\n"
"irq_lower_32:\n"
"\tcurrent_exception_spx irq_lower\n"
"\n"
".balign 0x80\n"
"fiq_lower_32:\n"
"\tcurrent_exception_spx fiq_lower\n"
"\n"
".balign 0x80\n"
"serr_lower_32:\n"
"\tcurrent_exception_spx serr_lower\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:780
msgid "`idmap.S` (you shouldn't need to change this):"
msgstr "`idmap.S` (no deber√≠a ser necesario cambiarlo):"

#: src/exercises/bare-metal/rtc.md:784
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
".set .L_TT_TYPE_BLOCK, 0x1\n"
".set .L_TT_TYPE_PAGE,  0x3\n"
".set .L_TT_TYPE_TABLE, 0x3\n"
"\n"
"/* Access flag. */\n"
".set .L_TT_AF, 0x1 << 10\n"
"/* Not global. */\n"
".set .L_TT_NG, 0x1 << 11\n"
".set .L_TT_XN, 0x3 << 53\n"
"\n"
".set .L_TT_MT_DEV, 0x0 << 2\t\t\t// MAIR #0 (DEV_nGnRE)\n"
".set .L_TT_MT_MEM, (0x1 << 2) | (0x3 << 8)\t// MAIR #1 (MEM_WBWA), inner "
"shareable\n"
"\n"
".set .L_BLOCK_DEV, .L_TT_TYPE_BLOCK | .L_TT_MT_DEV | .L_TT_AF | .L_TT_XN\n"
".set .L_BLOCK_MEM, .L_TT_TYPE_BLOCK | .L_TT_MT_MEM | .L_TT_AF | .L_TT_NG\n"
"\n"
".section \".rodata.idmap\", \"a\", %progbits\n"
".global idmap\n"
".align 12\n"
"idmap:\n"
"\t/* level 1 */\n"
"\t.quad\t\t.L_BLOCK_DEV | 0x0\t\t    // 1 GiB of device mappings\n"
"\t.quad\t\t.L_BLOCK_MEM | 0x40000000\t// 1 GiB of DRAM\n"
"\t.fill\t\t254, 8, 0x0\t\t\t// 254 GiB of unmapped VA space\n"
"\t.quad\t\t.L_BLOCK_DEV | 0x4000000000 // 1 GiB of device mappings\n"
"\t.fill\t\t255, 8, 0x0\t\t\t// 255 GiB of remaining VA space\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:829
msgid "`image.ld` (you shouldn't need to change this):"
msgstr "`image.ld` (no deber√≠a ser necesario cambiarlo):"

#: src/exercises/bare-metal/rtc.md:833
msgid ""
"```ld\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"/*\n"
" * Code will start running at this symbol which is placed at the start of "
"the\n"
" * image.\n"
" */\n"
"ENTRY(entry)\n"
"\n"
"MEMORY\n"
"{\n"
"\timage : ORIGIN = 0x40080000, LENGTH = 2M\n"
"}\n"
"\n"
"SECTIONS\n"
"{\n"
"\t/*\n"
"\t * Collect together the code.\n"
"\t */\n"
"\t.init : ALIGN(4096) {\n"
"\t\ttext_begin = .;\n"
"\t\t*(.init.entry)\n"
"\t\t*(.init.*)\n"
"\t} >image\n"
"\t.text : {\n"
"\t\t*(.text.*)\n"
"\t} >image\n"
"\ttext_end = .;\n"
"\n"
"\t/*\n"
"\t * Collect together read-only data.\n"
"\t */\n"
"\t.rodata : ALIGN(4096) {\n"
"\t\trodata_begin = .;\n"
"\t\t*(.rodata.*)\n"
"\t} >image\n"
"\t.got : {\n"
"\t\t*(.got)\n"
"\t} >image\n"
"\trodata_end = .;\n"
"\n"
"\t/*\n"
"\t * Collect together the read-write data including .bss at the end which\n"
"\t * will be zero'd by the entry code.\n"
"\t */\n"
"\t.data : ALIGN(4096) {\n"
"\t\tdata_begin = .;\n"
"\t\t*(.data.*)\n"
"\t\t/*\n"
"\t\t * The entry point code assumes that .data is a multiple of 32\n"
"\t\t * bytes long.\n"
"\t\t */\n"
"\t\t. = ALIGN(32);\n"
"\t\tdata_end = .;\n"
"\t} >image\n"
"\n"
"\t/* Everything beyond this point will not be included in the binary. */\n"
"\tbin_end = .;\n"
"\n"
"\t/* The entry point code assumes that .bss is 16-byte aligned. */\n"
"\t.bss : ALIGN(16)  {\n"
"\t\tbss_begin = .;\n"
"\t\t*(.bss.*)\n"
"\t\t*(COMMON)\n"
"\t\t. = ALIGN(16);\n"
"\t\tbss_end = .;\n"
"\t} >image\n"
"\n"
"\t.stack (NOLOAD) : ALIGN(4096) {\n"
"\t\tboot_stack_begin = .;\n"
"\t\t. += 40 * 4096;\n"
"\t\t. = ALIGN(4096);\n"
"\t\tboot_stack_end = .;\n"
"\t} >image\n"
"\n"
"\t. = ALIGN(4K);\n"
"\tPROVIDE(dma_region = .);\n"
"\n"
"\t/*\n"
"\t * Remove unused sections from the image.\n"
"\t */\n"
"\t/DISCARD/ : {\n"
"\t\t/* The image loads itself so doesn't need these sections. */\n"
"\t\t*(.gnu.hash)\n"
"\t\t*(.hash)\n"
"\t\t*(.interp)\n"
"\t\t*(.eh_frame_hdr)\n"
"\t\t*(.eh_frame)\n"
"\t\t*(.note.gnu.build-id)\n"
"\t}\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:940
msgid "`Makefile` (you shouldn't need to change this):"
msgstr "`Makefile` (no deber√≠a ser necesario cambiarlo):"

#: src/exercises/bare-metal/rtc.md:944
msgid ""
"```makefile\n"
"# Copyright 2023 Google LLC\n"
"#\n"
"# Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"# you may not use this file except in compliance with the License.\n"
"# You may obtain a copy of the License at\n"
"#\n"
"#      http://www.apache.org/licenses/LICENSE-2.0\n"
"#\n"
"# Unless required by applicable law or agreed to in writing, software\n"
"# distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"# See the License for the specific language governing permissions and\n"
"# limitations under the License.\n"
"\n"
"UNAME := $(shell uname -s)\n"
"ifeq ($(UNAME),Linux)\n"
"\tTARGET = aarch64-linux-gnu\n"
"else\n"
"\tTARGET = aarch64-none-elf\n"
"endif\n"
"OBJCOPY = $(TARGET)-objcopy\n"
"\n"
".PHONY: build qemu_minimal qemu qemu_logger\n"
"\n"
"all: rtc.bin\n"
"\n"
"build:\n"
"\tcargo build\n"
"\n"
"rtc.bin: build\n"
"\t$(OBJCOPY) -O binary target/aarch64-unknown-none/debug/rtc $@\n"
"\n"
"qemu: rtc.bin\n"
"\tqemu-system-aarch64 -machine virt,gic-version=3 -cpu max -serial mon:stdio "
"-display none -kernel $< -s\n"
"\n"
"clean:\n"
"\tcargo clean\n"
"\trm -f *.bin\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:989
msgid ""
"```toml\n"
"[build]\n"
"target = \"aarch64-unknown-none\"\n"
"rustflags = [\"-C\", \"link-arg=-Timage.ld\"]\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:995
msgid "Run the code in QEMU with `make qemu`."
msgstr "Ejecuta el c√≥digo en QEMU con `make qemu`."

#: src/concurrency.md:1
msgid "Welcome to Concurrency in Rust"
msgstr "Te Damos la Bienvenida a Concurrencia en Rust"

#: src/concurrency.md:3
msgid ""
"Rust has full support for concurrency using OS threads with mutexes and "
"channels."
msgstr ""
"Rust es totalmente compatible con la concurrencia mediante hilos del SO con "
"exclusiones mutuas y canales."

#: src/concurrency.md:6
msgid ""
"The Rust type system plays an important role in making many concurrency bugs "
"compile time bugs. This is often referred to as _fearless concurrency_ since "
"you can rely on the compiler to ensure correctness at runtime."
msgstr ""
"El sistema de tipos de Rust desempe√±a un papel importante al hacer que "
"muchos errores de concurrencia sean errores en tiempo de compilaci√≥n. A "
"menudo, esto se conoce como _concurrencia sin miedo_, ya que puedes confiar "
"en el compilador para asegurar la correcci√≥n en el tiempo de ejecuci√≥n."

#: src/concurrency/threads.md:3
msgid "Rust threads work similarly to threads in other languages:"
msgstr "Los hilos de Rust funcionan de forma similar a los de otros lenguajes:"

#: src/concurrency/threads.md:5
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    thread::spawn(|| {\n"
"        for i in 1..10 {\n"
"            println!(\"Count in thread: {i}!\");\n"
"            thread::sleep(Duration::from_millis(5));\n"
"        }\n"
"    });\n"
"\n"
"    for i in 1..5 {\n"
"        println!(\"Main thread: {i}\");\n"
"        thread::sleep(Duration::from_millis(5));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/threads.md:24
msgid "Threads are all daemon threads, the main thread does not wait for them."
msgstr ""
"Los hilos son todos hilos daemon, y el hilo principal no espera por ellos."

#: src/concurrency/threads.md:25
msgid "Thread panics are independent of each other."
msgstr "Los p√°nicos de los hilos son independientes entre s√≠."

#: src/concurrency/threads.md:26
msgid "Panics can carry a payload, which can be unpacked with `downcast_ref`."
msgstr ""
"Los p√°nicos pueden transportar una carga √∫til, que se puede desempaquetar "
"con `downcast_ref`."

#: src/concurrency/threads.md:32
msgid ""
"Notice that the thread is stopped before it reaches 10 ‚Äî the main thread is "
"not waiting."
msgstr ""
"Observa que el hilo se detiene antes de llegar a 10; el hilo principal no "
"est√° esperando."

#: src/concurrency/threads.md:35
msgid ""
"Use `let handle = thread::spawn(...)` and later `handle.join()` to wait for "
"the thread to finish."
msgstr ""
"Utiliza `let handle = thread::spawn(...)` y, despu√©s, `handle.join()` para "
"esperar a que el hilo termine."

#: src/concurrency/threads.md:38
msgid "Trigger a panic in the thread, notice how this doesn't affect `main`."
msgstr "Activa un p√°nico en el hilo y observa c√≥mo esto no afecta a `main`."

#: src/concurrency/threads.md:40
msgid ""
"Use the `Result` return value from `handle.join()` to get access to the "
"panic payload. This is a good time to talk about [`Any`](https://doc.rust-"
"lang.org/std/any/index.html)."
msgstr ""
"Usa el valor devuelto `Result` de `handle.join.()` para acceder a la carga "
"√∫til del p√°nico. Este es un buen momento para hablar sobre [`Any`](https://"
"doc.rust-lang.org/std/any/index.html)."

#: src/concurrency/scoped-threads.md:3
msgid "Normal threads cannot borrow from their environment:"
msgstr "Los hilos normales no pueden tomar nada prestado de su entorno:"

#: src/concurrency/scoped-threads.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use std::thread;\n"
"\n"
"fn foo() {\n"
"    let s = String::from(\"Hello\");\n"
"    thread::spawn(|| {\n"
"        println!(\"Length: {}\", s.len());\n"
"    });\n"
"}\n"
"\n"
"fn main() {\n"
"    foo();\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/scoped-threads.md:20
msgid ""
"However, you can use a [scoped thread](https://doc.rust-lang.org/std/thread/"
"fn.scope.html) for this:"
msgstr ""
"Sin embargo, puedes usar un [hilo con √°mbito](https://doc.rust-lang.org/std/"
"thread/fn.scope.html) para lo siguiente:"

#: src/concurrency/scoped-threads.md:22
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let s = String::from(\"Hello\");\n"
"\n"
"    thread::scope(|scope| {\n"
"        scope.spawn(|| {\n"
"            println!(\"Length: {}\", s.len());\n"
"        });\n"
"    });\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/scoped-threads.md:40
msgid ""
"The reason for that is that when the `thread::scope` function completes, all "
"the threads are guaranteed to be joined, so they can return borrowed data."
msgstr ""
"La raz√≥n es que, cuando se completa la funci√≥n `thread::scope`, se asegura "
"que todos los hilos est√°n unidos, por lo que pueden devolver datos prestados."

#: src/concurrency/scoped-threads.md:41
msgid ""
"Normal Rust borrowing rules apply: you can either borrow mutably by one "
"thread, or immutably by any number of threads."
msgstr ""
"Se aplican las reglas normales de pr√©stamo de Rust: un hilo puede tomar "
"datos prestados de manera mutable o cualquier n√∫mero de hilos puede tomar "
"datos prestados de manera inmutable."

#: src/concurrency/channels.md:3
msgid ""
"Rust channels have two parts: a `Sender<T>` and a `Receiver<T>`. The two "
"parts are connected via the channel, but you only see the end-points."
msgstr ""
"Los canales de Rust tienen dos partes: `Sender<T>` y `Receiver<T>`. Las dos "
"partes est√°n conectadas a trav√©s del canal, pero solo se ven los puntos "
"finales."

#: src/concurrency/channels.md:6
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::channel();\n"
"\n"
"    tx.send(10).unwrap();\n"
"    tx.send(20).unwrap();\n"
"\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"\n"
"    let tx2 = tx.clone();\n"
"    tx2.send(30).unwrap();\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/channels.md:27
msgid ""
"`mpsc` stands for Multi-Producer, Single-Consumer. `Sender` and `SyncSender` "
"implement `Clone` (so you can make multiple producers) but `Receiver` does "
"not."
msgstr ""
"`mpsc` son las siglas de Multi-Producer, Single-Consumer (multiproductor, "
"consumidor √∫nico.) `Sender` y `SyncSender` implementan `Clone` (es decir, "
"puedes crear varios productores), pero `Receiver` no."

#: src/concurrency/channels.md:29
msgid ""
"`send()` and `recv()` return `Result`. If they return `Err`, it means the "
"counterpart `Sender` or `Receiver` is dropped and the channel is closed."
msgstr ""
"`send()` y `recv()` devuelven `Result`. Si devuelven `Err`, significa que el "
"hom√≥logo `Sender` o `Receiver` se ha eliminado y el canal se ha cerrado."

#: src/concurrency/channels/unbounded.md:3
msgid "You get an unbounded and asynchronous channel with `mpsc::channel()`:"
msgstr "Se obtiene un canal as√≠ncrono y sin l√≠mites con `mpsc::channel()`:"

#: src/concurrency/channels/unbounded.md:5
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::channel();\n"
"\n"
"    thread::spawn(move || {\n"
"        let thread_id = thread::current().id();\n"
"        for i in 1..10 {\n"
"            tx.send(format!(\"Message {i}\")).unwrap();\n"
"            println!(\"{thread_id:?}: sent Message {i}\");\n"
"        }\n"
"        println!(\"{thread_id:?}: done\");\n"
"    });\n"
"    thread::sleep(Duration::from_millis(100));\n"
"\n"
"    for msg in rx.iter() {\n"
"        println!(\"Main: got {msg}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/channels/bounded.md:3
msgid ""
"With bounded (synchronous) channels, `send` can block the current thread:"
msgstr "Con canales limitados (s√≠ncronos), `send` puede bloquear el hilo:"

#: src/concurrency/channels/bounded.md:5
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::sync_channel(3);\n"
"\n"
"    thread::spawn(move || {\n"
"        let thread_id = thread::current().id();\n"
"        for i in 1..10 {\n"
"            tx.send(format!(\"Message {i}\")).unwrap();\n"
"            println!(\"{thread_id:?}: sent Message {i}\");\n"
"        }\n"
"        println!(\"{thread_id:?}: done\");\n"
"    });\n"
"    thread::sleep(Duration::from_millis(100));\n"
"\n"
"    for msg in rx.iter() {\n"
"        println!(\"Main: got {msg}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/channels/bounded.md:31
msgid ""
"Calling `send` will block the current thread until there is space in the "
"channel for the new message. The thread can be blocked indefinitely if there "
"is nobody who reads from the channel."
msgstr ""
"Al llamar a `send`, se bloquear√° el hilo hasta que haya espacio suficiente "
"en el canal para el mensaje nuevo. El hilo se puede bloquear de forma "
"indefinida si no hay nadie que lea el canal."

#: src/concurrency/channels/bounded.md:32
msgid ""
"A call to `send` will abort with an error (that is why it returns `Result`) "
"if the channel is closed. A channel is closed when the receiver is dropped."
msgstr ""
"Si se cierra el canal, se anular√° la llamada a `send` y se producir√° un "
"error (por eso devuelve `Result`). Un canal se cierra cuando se elimina el "
"receptor."

#: src/concurrency/channels/bounded.md:33
msgid ""
"A bounded channel with a size of zero is called a \"rendezvous channel\". "
"Every send will block the current thread until another thread calls `read`."
msgstr ""
"Un canal delimitado con un tama√±o de cero se denomina \"canal rendezvous\". "
"Cada env√≠o bloquear√° el hilo actual hasta que otro hilo llame a `read`."

#: src/concurrency/send-sync.md:1
msgid "`Send` and `Sync`"
msgstr "`Send` y `Sync`"

#: src/concurrency/send-sync.md:3
msgid ""
"How does Rust know to forbid shared access across thread? The answer is in "
"two traits:"
msgstr ""
"¬øC√≥mo sabe Rust que debe prohibir el acceso compartido entre hilos? La "
"respuesta est√° en dos traits:"

#: src/concurrency/send-sync.md:5
msgid ""
"[`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html): a type `T` "
"is `Send` if it is safe to move a `T` across a thread boundary."
msgstr ""
"[`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html): un tipo `T` "
"es `Send` si es seguro mover un `T` entre los l√≠mites de un hilo."

#: src/concurrency/send-sync.md:7
msgid ""
"[`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html): a type `T` "
"is `Sync` if it is safe to move a `&T` across a thread boundary."
msgstr ""
"[`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html): un tipo `T` "
"es `Sync` si es seguro mover un `&T` entre los l√≠mites de un hilo."

#: src/concurrency/send-sync.md:10
msgid ""
"`Send` and `Sync` are [unsafe traits](../unsafe/unsafe-traits.md). The "
"compiler will automatically derive them for your types as long as they only "
"contain `Send` and `Sync` types. You can also implement them manually when "
"you know it is valid."
msgstr ""
"`Send` y `Sync` son [traits inseguros](../unsafe/unsafe-traits.md). El "
"compilador los derivar√° autom√°ticamente a tus tipos siempre que solo "
"contengan los tipos `Send` y `Sync`. Tambi√©n puedes implementarlos de forma "
"manual cuando sepas que es v√°lido."

#: src/concurrency/send-sync.md:20
msgid ""
"One can think of these traits as markers that the type has certain thread-"
"safety properties."
msgstr ""
"Se podr√≠a pensar en estos traits como marcadores que indican que el tipo "
"tiene ciertas propiedades de seguridad en hilos."

#: src/concurrency/send-sync.md:21
msgid "They can be used in the generic constraints as normal traits."
msgstr ""
"Se pueden utilizar en las restricciones gen√©ricas como traits normales."

#: src/concurrency/send-sync/send.md:1
msgid "`Send`"
msgstr "`Send`"

#: src/concurrency/send-sync/send.md:3
msgid ""
"A type `T` is [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html) "
"if it is safe to move a `T` value to another thread."
msgstr ""
"Un tipo `T` es [`Send`](https://doc.rust-lang.org/std/marker/trait.Send."
"html) si es seguro mover un valor `T` a otro hilo."

#: src/concurrency/send-sync/send.md:5
msgid ""
"The effect of moving ownership to another thread is that _destructors_ will "
"run in that thread. So the question is when you can allocate a value in one "
"thread and deallocate it in another."
msgstr ""
"El efecto de mover la propiedad a otro hilo es que los _destructores_ se "
"ejecutar√°n en ese hilo. Por tanto, la cuestion es cu√°ndo se puede asignar un "
"valor a un hilo y desasignarlo en otro."

#: src/concurrency/send-sync/send.md:13
msgid ""
"As an example, a connection to the SQLite library must only be accessed from "
"a single thread."
msgstr ""
"Por ejemplo, solo se puede acceder a una conexi√≥n a la biblioteca SQLite "
"desde un √∫nico hilo."

#: src/concurrency/send-sync/sync.md:1
msgid "`Sync`"
msgstr "`Sync`"

#: src/concurrency/send-sync/sync.md:3
msgid ""
"A type `T` is [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) "
"if it is safe to access a `T` value from multiple threads at the same time."
msgstr ""
"Un tipo `T` es [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync."
"html) si es seguro acceder a un valor `T` desde varios hilos al mismo tiempo."

#: src/concurrency/send-sync/sync.md:6
msgid "More precisely, the definition is:"
msgstr "En concreto, la definici√≥n es la siguiente:"

#: src/concurrency/send-sync/sync.md:8
msgid "`T` is `Sync` if and only if `&T` is `Send`"
msgstr "`T` es `Sync` √∫nicamente si `&T` es `Send`."

#: src/concurrency/send-sync/sync.md:14
msgid ""
"This statement is essentially a shorthand way of saying that if a type is "
"thread-safe for shared use, it is also thread-safe to pass references of it "
"across threads."
msgstr ""
"Esta instrucci√≥n es, b√°sicamente, una forma resumida de indicar que, si un "
"tipo es seguro para los hilos en uso compartido, tambi√©n lo es para pasar "
"referencias de √©l a trav√©s de los hilos."

#: src/concurrency/send-sync/sync.md:16
msgid ""
"This is because if a type is Sync it means that it can be shared across "
"multiple threads without the risk of data races or other synchronization "
"issues, so it is safe to move it to another thread. A reference to the type "
"is also safe to move to another thread, because the data it references can "
"be accessed from any thread safely."
msgstr ""
"Esto se debe a que, si el tipo es Sync, significa que se puede compartir "
"entre m√∫ltiples hilos sin el riesgo de que haya carreras de datos u otros "
"problemas de sincronizaci√≥n, por lo que es seguro moverlo a otro hilo. "
"Tambi√©n es seguro mover una referencia al tipo a otro hilo, ya que se puede "
"acceder de forma segura a los datos a los que hace referencia desde "
"cualquier hilo."

#: src/concurrency/send-sync/examples.md:3
msgid "`Send + Sync`"
msgstr "`Send + Sync`"

#: src/concurrency/send-sync/examples.md:5
msgid "Most types you come across are `Send + Sync`:"
msgstr "La mayor√≠a de los tipos que encuentras son `Send + Sync`:"

#: src/concurrency/send-sync/examples.md:7
msgid "`i8`, `f32`, `bool`, `char`, `&str`, ..."
msgstr "`i8`, `f32`, `bool`, `char`, `&str`, etc."

#: src/concurrency/send-sync/examples.md:8
msgid "`(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ..."
msgstr "`(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, etc."

#: src/concurrency/send-sync/examples.md:9
msgid "`String`, `Option<T>`, `Vec<T>`, `Box<T>`, ..."
msgstr "`String`, `Option<T>`, `Vec<T>`, `Box<T>`, etc."

#: src/concurrency/send-sync/examples.md:10
msgid "`Arc<T>`: Explicitly thread-safe via atomic reference count."
msgstr ""
"`Arc<T>`: expl√≠citamente seguro para los hilos mediante el recuento at√≥mico "
"de referencias."

#: src/concurrency/send-sync/examples.md:11
msgid "`Mutex<T>`: Explicitly thread-safe via internal locking."
msgstr ""
"`Mutex<T>`: expl√≠citamente seguro para los hilos mediante bloqueo interno."

#: src/concurrency/send-sync/examples.md:12
msgid "`AtomicBool`, `AtomicU8`, ...: Uses special atomic instructions."
msgstr ""
"`AtomicBool`, `AtomicU8`, etc.: utiliza instrucciones at√≥micas especiales."

#: src/concurrency/send-sync/examples.md:14
msgid ""
"The generic types are typically `Send + Sync` when the type parameters are "
"`Send + Sync`."
msgstr ""
"Los tipos gen√©ricos suelen ser `Send + Sync` cuando los par√°metros del tipo "
"son `Send + Sync`."

#: src/concurrency/send-sync/examples.md:17
msgid "`Send + !Sync`"
msgstr "`Send + !Sync`"

#: src/concurrency/send-sync/examples.md:19
msgid ""
"These types can be moved to other threads, but they're not thread-safe. "
"Typically because of interior mutability:"
msgstr ""
"Estos tipos se pueden mover a otros hilos, pero no son seguros para los "
"hilos. Normalmente, esto se debe a la mutabilidad interior:"

#: src/concurrency/send-sync/examples.md:22
msgid "`mpsc::Sender<T>`"
msgstr "`mpsc::Sender<T>`"

#: src/concurrency/send-sync/examples.md:23
msgid "`mpsc::Receiver<T>`"
msgstr "`mpsc::Receiver<T>`"

#: src/concurrency/send-sync/examples.md:24
msgid "`Cell<T>`"
msgstr "`Cell<T>`"

#: src/concurrency/send-sync/examples.md:25
msgid "`RefCell<T>`"
msgstr "`RefCell<T>`"

#: src/concurrency/send-sync/examples.md:27
msgid "`!Send + Sync`"
msgstr "`!Send + Sync`"

#: src/concurrency/send-sync/examples.md:29
msgid ""
"These types are thread-safe, but they cannot be moved to another thread:"
msgstr ""
"Estos tipos son seguros para los hilos _(thread safe)_, pero no se pueden "
"mover a otro hilo:"

#: src/concurrency/send-sync/examples.md:31
msgid ""
"`MutexGuard<T>`: Uses OS level primitives which must be deallocated on the "
"thread which created them."
msgstr ""
"`MutexGuard<T>`: utiliza primitivos de nivel SO que se deben desasignar en "
"el hilo que los cre√≥."

#: src/concurrency/send-sync/examples.md:34
msgid "`!Send + !Sync`"
msgstr "`!Send + !Sync`"

#: src/concurrency/send-sync/examples.md:36
msgid "These types are not thread-safe and cannot be moved to other threads:"
msgstr ""
"Estos tipos no son seguros para los hilos y no se pueden mover a otros hilos:"

#: src/concurrency/send-sync/examples.md:38
msgid ""
"`Rc<T>`: each `Rc<T>` has a reference to an `RcBox<T>`, which contains a non-"
"atomic reference count."
msgstr ""
"`Rc<T>`: cada `Rc<T>` tiene una referencia a un `RcBox<T>`, que contiene un "
"recuento de referencias no at√≥mico."

#: src/concurrency/send-sync/examples.md:40
msgid ""
"`*const T`, `*mut T`: Rust assumes raw pointers may have special concurrency "
"considerations."
msgstr ""
"`*const T`, `*mut T`: Rust asume que los punteros sin procesar pueden tener "
"consideraciones especiales de concurrencia."

#: src/concurrency/shared_state.md:3
msgid ""
"Rust uses the type system to enforce synchronization of shared data. This is "
"primarily done via two types:"
msgstr ""
"Rust utiliza el sistema de tipos para implementar la sincronizaci√≥n de los "
"datos compartidos. Esto se hace principalmente a trav√©s de dos tipos:"

#: src/concurrency/shared_state.md:6
msgid ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html), atomic "
"reference counted `T`: handles sharing between threads and takes care to "
"deallocate `T` when the last reference is dropped,"
msgstr ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html), recuento "
"at√≥mico de referencias `T`: gestiona el uso compartido entre hilos y se "
"encarga de desasignar `T` cuando se elimina la √∫ltima referencia."

#: src/concurrency/shared_state.md:8
msgid ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html): ensures "
"mutually exclusive access to the `T` value."
msgstr ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html): asegura "
"el acceso mutuamente excluyente al valor `T`."

#: src/concurrency/shared_state/arc.md:1
msgid "`Arc`"
msgstr "`Arc`"

#: src/concurrency/shared_state/arc.md:3
msgid ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html) allows shared "
"read-only access via `Arc::clone`:"
msgstr ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html) permite el "
"acceso compartido de solo lectura a trav√©s de `Arc::clone`:"

#: src/concurrency/shared_state/arc.md:5
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"use std::sync::Arc;\n"
"\n"
"fn main() {\n"
"    let v = Arc::new(vec![10, 20, 30]);\n"
"    let mut handles = Vec::new();\n"
"    for _ in 1..5 {\n"
"        let v = Arc::clone(&v);\n"
"        handles.push(thread::spawn(move || {\n"
"            let thread_id = thread::current().id();\n"
"            println!(\"{thread_id:?}: {v:?}\");\n"
"        }));\n"
"    }\n"
"\n"
"    handles.into_iter().for_each(|h| h.join().unwrap());\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/arc.md:29
msgid ""
"`Arc` stands for \"Atomic Reference Counted\", a thread safe version of `Rc` "
"that uses atomic operations."
msgstr ""
"`Arc` son las siglas de \"Atomic Reference Counted\" (recuento at√≥mico de "
"referencias), una versi√≥n de `Rc` segura para los hilos que utiliza "
"operaciones at√≥micas."

#: src/concurrency/shared_state/arc.md:31
msgid ""
"`Arc<T>` implements `Clone` whether or not `T` does. It implements `Send` "
"and `Sync` if and only if `T` implements them both."
msgstr ""
"`Arc<T>` implementa `Clone`, independientemente de si `T` lo hace o no. "
"Implementa `Send` y `Sync` si `T` implementa ambos."

#: src/concurrency/shared_state/arc.md:33
msgid ""
"`Arc::clone()` has the cost of atomic operations that get executed, but "
"after that the use of the `T` is free."
msgstr ""
"`Arc::clone()` tiene el coste de las operaciones at√≥micas que se ejecutan; "
"despu√©s el uso de `T` es libre."

#: src/concurrency/shared_state/arc.md:35
msgid ""
"Beware of reference cycles, `Arc` does not use a garbage collector to detect "
"them."
msgstr ""
"Hay que prestar atenci√≥n a los ciclos de referencia, ya que `Arc` no usa un "
"recolector de memoria residual para detectarlos."

#: src/concurrency/shared_state/arc.md:36
msgid "`std::sync::Weak` can help."
msgstr "`std::sync::Weak` puede resultar √∫til."

#: src/concurrency/shared_state/mutex.md:1
msgid "`Mutex`"
msgstr "`Mutex`"

#: src/concurrency/shared_state/mutex.md:3
msgid ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html) ensures "
"mutual exclusion _and_ allows mutable access to `T` behind a read-only "
"interface:"
msgstr ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html) asegura "
"la exclusi√≥n mutua _y_ permite un acceso mutable a `T` a trav√©s de una "
"interfaz de solo lectura:"

#: src/concurrency/shared_state/mutex.md:6
msgid ""
"```rust,editable\n"
"use std::sync::Mutex;\n"
"\n"
"fn main() {\n"
"    let v = Mutex::new(vec![10, 20, 30]);\n"
"    println!(\"v: {:?}\", v.lock().unwrap());\n"
"\n"
"    {\n"
"        let mut guard = v.lock().unwrap();\n"
"        guard.push(40);\n"
"    }\n"
"\n"
"    println!(\"v: {:?}\", v.lock().unwrap());\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/mutex.md:22
msgid ""
"Notice how we have a [`impl<T: Send> Sync for Mutex<T>`](https://doc.rust-"
"lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E) blanket "
"implementation."
msgstr ""
"F√≠jate en c√≥mo tenemos una implementaci√≥n general de [`impl<T: Send> Sync "
"for Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-"
"Sync-for-Mutex%3CT%3E)."

#: src/concurrency/shared_state/mutex.md:31
msgid ""
"`Mutex` in Rust looks like a collection with just one element - the "
"protected data."
msgstr ""
"`Mutex` en Rust parece una colecci√≥n con un solo elemento: los datos "
"protegidos."

#: src/concurrency/shared_state/mutex.md:32
msgid ""
"It is not possible to forget to acquire the mutex before accessing the "
"protected data."
msgstr ""
"No es posible olvidarse de adquirir la exclusi√≥n mutua antes de acceder a "
"los datos protegidos."

#: src/concurrency/shared_state/mutex.md:33
msgid ""
"You can get an `&mut T` from an `&Mutex<T>` by taking the lock. The "
"`MutexGuard` ensures that the `&mut T` doesn't outlive the lock being held."
msgstr ""
"Puedes obtener un `&mut T` de `Mutex<T>` mediante el bloqueo. El "
"`MutexGuard` asegura que `&mut T` no dure m√°s tiempo que el bloqueo que se "
"ha aplicado."

#: src/concurrency/shared_state/mutex.md:35
msgid ""
"`Mutex<T>` implements both `Send` and `Sync` iff (if and only if) `T` "
"implements `Send`."
msgstr ""
"`Mutex<T>` implementa tanto `Send` como `Sync` √∫nicamente si `T` implementa "
"`Send`."

#: src/concurrency/shared_state/mutex.md:36
msgid "A read-write lock counterpart - `RwLock`."
msgstr "Un equivalente de bloqueo de lectura y escritura: `RwLock`."

#: src/concurrency/shared_state/mutex.md:37
msgid "Why does `lock()` return a `Result`? "
msgstr "¬øPor qu√© `lock()` devuelve un `Result`? "

#: src/concurrency/shared_state/mutex.md:38
msgid ""
"If the thread that held the `Mutex` panicked, the `Mutex` becomes "
"\"poisoned\" to signal that the data it protected might be in an "
"inconsistent state. Calling `lock()` on a poisoned mutex fails with a "
"[`PoisonError`](https://doc.rust-lang.org/std/sync/struct.PoisonError.html). "
"You can call `into_inner()` on the error to recover the data regardless."
msgstr ""
"Si el hilo que contiene `Mutex` entra en p√°nico, `Mutex` se \"envenena\" "
"para indicar que los datos que proteg√≠a pueden estar en un estado "
"incoherente. Llamar a `lock()` en una exclusi√≥n mutua envenenada da el error "
"[`PoisonError`](https://doc.rust-lang.org/std/sync/struct.PoisonError.html). "
"Puedes llamar a `into_inner()` en el error para recuperar los datos de todos "
"modos."

#: src/concurrency/shared_state/example.md:3
msgid "Let us see `Arc` and `Mutex` in action:"
msgstr "Veamos c√≥mo funcionan `Arc` y `Mutex`:"

#: src/concurrency/shared_state/example.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use std::thread;\n"
"// use std::sync::{Arc, Mutex};\n"
"\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let handle = thread::spawn(|| {\n"
"        v.push(10);\n"
"    });\n"
"    v.push(1000);\n"
"\n"
"    handle.join().unwrap();\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/example.md:23
msgid "Possible solution:"
msgstr "Soluci√≥n posible:"

#: src/concurrency/shared_state/example.md:25
msgid ""
"```rust,editable\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let v = Arc::new(Mutex::new(vec![10, 20, 30]));\n"
"\n"
"    let v2 = Arc::clone(&v);\n"
"    let handle = thread::spawn(move || {\n"
"        let mut v2 = v2.lock().unwrap();\n"
"        v2.push(10);\n"
"    });\n"
"\n"
"    {\n"
"        let mut v = v.lock().unwrap();\n"
"        v.push(1000);\n"
"    }\n"
"\n"
"    handle.join().unwrap();\n"
"\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/example.md:49
msgid "Notable parts:"
msgstr "Puntos a destacar:"

#: src/concurrency/shared_state/example.md:51
msgid ""
"`v` is wrapped in both `Arc` and `Mutex`, because their concerns are "
"orthogonal."
msgstr ""
"`v` se envuelve tanto en `Arc` como en `Mutex`, porque sus preocupaciones "
"son ortogonales."

#: src/concurrency/shared_state/example.md:52
msgid ""
"Wrapping a `Mutex` in an `Arc` is a common pattern to share mutable state "
"between threads."
msgstr ""
"Envolver un `Mutex` en un `Arc` es un patr√≥n habitual para compartir el "
"estado mutable entre hilos."

#: src/concurrency/shared_state/example.md:53
msgid ""
"`v: Arc<_>` needs to be cloned as `v2` before it can be moved into another "
"thread. Note `move` was added to the lambda signature."
msgstr ""
"`v: Arc<_>` se debe clonar como `v2` antes de poder moverlo a otro hilo. Ten "
"en cuenta que `move` se ha a√±adido a la firma lambda."

#: src/concurrency/shared_state/example.md:54
msgid ""
"Blocks are introduced to narrow the scope of the `LockGuard` as much as "
"possible."
msgstr ""
"Se introducen bloqueos para limitar al m√°ximo el √°mbito de `LockGuard`."

#: src/exercises/concurrency/morning.md:3
msgid "Let us practice our new concurrency skills with"
msgstr "Vamos a practicar nuestras nuevas habilidades de concurrencia con"

#: src/exercises/concurrency/morning.md:5
msgid "Dining philosophers: a classic problem in concurrency."
msgstr "La cena de los fil√≥sofos: un problema cl√°sico de concurrencia."

#: src/exercises/concurrency/morning.md:7
msgid ""
"Multi-threaded link checker: a larger project where you'll use Cargo to "
"download dependencies and then check links in parallel."
msgstr ""
"El comprobador de enlaces multihilo: un proyecto m√°s grande donde utilizar√°s "
"Cargo para descargar dependencias y luego comprobar los enlaces en paralelo."

#: src/exercises/concurrency/dining-philosophers.md:3
msgid "The dining philosophers problem is a classic problem in concurrency:"
msgstr ""
"El problema de la cena de los fil√≥sofos es un problema cl√°sico de "
"concurrencia:"

#: src/exercises/concurrency/dining-philosophers.md:5
msgid ""
"Five philosophers dine together at the same table. Each philosopher has "
"their own place at the table. There is a fork between each plate. The dish "
"served is a kind of spaghetti which has to be eaten with two forks. Each "
"philosopher can only alternately think and eat. Moreover, a philosopher can "
"only eat their spaghetti when they have both a left and right fork. Thus two "
"forks will only be available when their two nearest neighbors are thinking, "
"not eating. After an individual philosopher finishes eating, they will put "
"down both forks."
msgstr ""
"Cinco fil√≥sofos cenan juntos en la misma mesa. Cada fil√≥sofo tiene su propio "
"sitio en ella. Hay un tenedor entre cada plato. El plato que van a degustar "
"es una especie de espaguetis que hay que comer con dos tenedores. Los "
"fil√≥sofos solo pueden pensar y comer alternativamente. Adem√°s, solo pueden "
"comer sus espaguetis cuando disponen de un tenedor a la izquierda y otro a "
"la derecha. Por tanto, los dos tenedores solo estar√°n disponibles cuando su "
"dos vecinos m√°s cercanos est√©n pensando y no comiendo. Cuando un fil√≥sofo "
"termina de comer, deja los dos tenedores en la mesa."

#: src/exercises/concurrency/dining-philosophers.md:13
msgid ""
"You will need a local [Cargo installation](../../cargo/running-locally.md) "
"for this exercise. Copy the code below to a file called `src/main.rs`, fill "
"out the blanks, and test that `cargo run` does not deadlock:"
msgstr ""
"Para realizar este ejercicio necesitar√°s una \\[instalaci√≥n local de "
"Cargo\\] (../../cargo/running-locally.md). Copia el fragmento de c√≥digo que "
"aparece m√°s abajo en un archivo denominado `src/main.rs`, rellena los "
"espacios en blanco y comprueba que `cargo run` no presenta interbloqueos:"

#: src/exercises/concurrency/dining-philosophers.md:19
msgid ""
"```rust,compile_fail\n"
"use std::sync::{mpsc, Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    // left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
"}\n"
"\n"
"impl Philosopher {\n"
"    fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))\n"
"            .unwrap();\n"
"    }\n"
"\n"
"    fn eat(&self) {\n"
"        // Pick up forks...\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];\n"
"\n"
"fn main() {\n"
"    // Create forks\n"
"\n"
"    // Create philosophers\n"
"\n"
"    // Make each of them think and eat 100 times\n"
"\n"
"    // Output their thoughts\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:61
msgid "You can use the following `Cargo.toml`:"
msgstr "Puedes usar el siguiente archivo `Cargo.toml`:"

#: src/exercises/concurrency/dining-philosophers.md:65
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:3
msgid ""
"Let us use our new knowledge to create a multi-threaded link checker. It "
"should start at a webpage and check that links on the page are valid. It "
"should recursively check other pages on the same domain and keep doing this "
"until all pages have been validated."
msgstr ""
"Utilicemos nuestros nuevos conocimientos para crear un comprobador de "
"enlaces multihilo. Deber√≠a empezar en una p√°gina web y comprobar que los "
"enlaces de la p√°gina son v√°lidos. Deber√≠a consultar otras p√°ginas del mismo "
"dominio y seguir haci√©ndolo hasta que todas las p√°ginas se hayan validado."

#: src/exercises/concurrency/link-checker.md:8
msgid ""
"For this, you will need an HTTP client such as [`reqwest`](https://docs.rs/"
"reqwest/). Create a new Cargo project and `reqwest` it as a dependency with:"
msgstr ""
"Para ello, necesitar√°s un cliente HTTP como [`reqwest`](https://docs.rs/"
"reqwest/). Crea un proyecto de Cargo y aplica `reqwest` como una dependencia "
"con:"

#: src/exercises/concurrency/link-checker.md:11
msgid ""
"```shell\n"
"cargo new link-checker\n"
"cd link-checker\n"
"cargo add --features blocking,rustls-tls reqwest\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:17
msgid ""
"If `cargo add` fails with `error: no such subcommand`, then please edit the "
"`Cargo.toml` file by hand. Add the dependencies listed below."
msgstr ""
"Si `cargo add` da `error: no such subcommand`, edita el archivo `Cargo.toml` "
"de forma manual. A√±ade las dependencias que se indican m√°s abajo."

#: src/exercises/concurrency/link-checker.md:20
msgid ""
"You will also need a way to find links. We can use [`scraper`](https://docs."
"rs/scraper/) for that:"
msgstr ""
"Tambi√©n necesitar√°s una forma de encontrar enlaces. Podemos usar [`scraper`]"
"(https://docs.rs/scraper/) para eso:"

#: src/exercises/concurrency/link-checker.md:22
msgid ""
"```shell\n"
"cargo add scraper\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:26
msgid ""
"Finally, we'll need some way of handling errors. We use [`thiserror`]"
"(https://docs.rs/thiserror/) for that:"
msgstr ""
"Por √∫ltimo, necesitaremos alg√∫n m√©todo para gestionar los errores. Para "
"ello, usaremos [`thiserror`](https://docs.rs/thiserror/):"

#: src/exercises/concurrency/link-checker.md:29
msgid ""
"```shell\n"
"cargo add thiserror\n"
"```"
msgstr ""
"```shell\n"
"cargo add thiserror\n"
"```"

#: src/exercises/concurrency/link-checker.md:33
msgid ""
"The `cargo add` calls will update the `Cargo.toml` file to look like this:"
msgstr ""
"Las llamadas a `cargo add` actualizar√°n el archivo `Cargo.toml` para que "
"tenga este aspecto:"

#: src/exercises/concurrency/link-checker.md:37
msgid ""
"```toml\n"
"[package]\n"
"name = \"link-checker\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-"
"tls\"] }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"link-checker\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-"
"tls\"] }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"

#: src/exercises/concurrency/link-checker.md:50
msgid ""
"You can now download the start page. Try with a small site such as `https://"
"www.google.org/`."
msgstr ""
"Ya puedes descargar la p√°gina de inicio. Prueba con un sitio peque√±o, como "
"`https://www.google.org/`."

#: src/exercises/concurrency/link-checker.md:53
msgid "Your `src/main.rs` file should look something like this:"
msgstr "El archivo `src/main.rs` deber√≠a tener un aspecto similar a este:"

#: src/exercises/concurrency/link-checker.md:57
msgid ""
"```rust,compile_fail\n"
"use reqwest::{blocking::Client, Url};\n"
"use scraper::{Html, Selector};\n"
"use thiserror::Error;\n"
"\n"
"#[derive(Error, Debug)]\n"
"enum Error {\n"
"    #[error(\"request error: {0}\")]\n"
"    ReqwestError(#[from] reqwest::Error),\n"
"    #[error(\"bad http response: {0}\")]\n"
"    BadResponse(String),\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"struct CrawlCommand {\n"
"    url: Url,\n"
"    extract_links: bool,\n"
"}\n"
"\n"
"fn visit_page(client: &Client, command: &CrawlCommand) -> Result<Vec<Url>, "
"Error> {\n"
"    println!(\"Checking {:#}\", command.url);\n"
"    let response = client.get(command.url.clone()).send()?;\n"
"    if !response.status().is_success() {\n"
"        return Err(Error::BadResponse(response.status().to_string()));\n"
"    }\n"
"\n"
"    let mut link_urls = Vec::new();\n"
"    if !command.extract_links {\n"
"        return Ok(link_urls);\n"
"    }\n"
"\n"
"    let base_url = response.url().to_owned();\n"
"    let body_text = response.text()?;\n"
"    let document = Html::parse_document(&body_text);\n"
"\n"
"    let selector = Selector::parse(\"a\").unwrap();\n"
"    let href_values = document\n"
"        .select(&selector)\n"
"        .filter_map(|element| element.value().attr(\"href\"));\n"
"    for href in href_values {\n"
"        match base_url.join(href) {\n"
"            Ok(link_url) => {\n"
"                link_urls.push(link_url);\n"
"            }\n"
"            Err(err) => {\n"
"                println!(\"On {base_url:#}: ignored unparsable {href:?}: "
"{err}\");\n"
"            }\n"
"        }\n"
"    }\n"
"    Ok(link_urls)\n"
"}\n"
"\n"
"fn main() {\n"
"    let client = Client::new();\n"
"    let start_url = Url::parse(\"https://www.google.org\").unwrap();\n"
"    let crawl_command = CrawlCommand{ url: start_url, extract_links: "
"true };\n"
"    match visit_page(&client, &crawl_command) {\n"
"        Ok(links) => println!(\"Links: {links:#?}\"),\n"
"        Err(err) => println!(\"Could not extract links: {err:#}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,compile_fail\n"
"use reqwest::{blocking::Client, Url};\n"
"use scraper::{Html, Selector};\n"
"use thiserror::Error;\n"
"\n"
"#[derive(Error, Debug)]\n"
"enum Error {\n"
"    #[error(\"request error: {0}\")]\n"
"    ReqwestError(#[from] reqwest::Error),\n"
"    #[error(\"bad http response: {0}\")]\n"
"    BadResponse(String),\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"struct CrawlCommand {\n"
"    url: Url,\n"
"    extract_links: bool,\n"
"}\n"
"\n"
"fn visit_page(client: &Client, command: &CrawlCommand) -> Result<Vec<Url>, "
"Error> {\n"
"    println!(\"Checking {:#}\", command.url);\n"
"    let response = client.get(command.url.clone()).send()?;\n"
"    if !response.status().is_success() {\n"
"        return Err(Error::BadResponse(response.status().to_string()));\n"
"    }\n"
"\n"
"    let mut link_urls = Vec::new();\n"
"    if !command.extract_links {\n"
"        return Ok(link_urls);\n"
"    }\n"
"\n"
"    let base_url = response.url().to_owned();\n"
"    let body_text = response.text()?;\n"
"    let document = Html::parse_document(&body_text);\n"
"\n"
"    let selector = Selector::parse(\"a\").unwrap();\n"
"    let href_values = document\n"
"        .select(&selector)\n"
"        .filter_map(|element| element.value().attr(\"href\"));\n"
"    for href in href_values {\n"
"        match base_url.join(href) {\n"
"            Ok(link_url) => {\n"
"                link_urls.push(link_url);\n"
"            }\n"
"            Err(err) => {\n"
"                println!(\"On {base_url:#}: ignored unparsable {href:?}: "
"{err}\");\n"
"            }\n"
"        }\n"
"    }\n"
"    Ok(link_urls)\n"
"}\n"
"\n"
"fn main() {\n"
"    let client = Client::new();\n"
"    let start_url = Url::parse(\"https://www.google.org\").unwrap();\n"
"    let crawl_command = CrawlCommand{ url: start_url, extract_links: "
"true };\n"
"    match visit_page(&client, &crawl_command) {\n"
"        Ok(links) => println!(\"Links: {links:#?}\"),\n"
"        Err(err) => println!(\"Could not extract links: {err:#}\"),\n"
"    }\n"
"}\n"
"```"

#: src/exercises/concurrency/link-checker.md:120
msgid "Run the code in `src/main.rs` with"
msgstr "Ejecuta el c√≥digo en `src/main.rs` con"

#: src/exercises/concurrency/link-checker.md:122
msgid ""
"```shell\n"
"cargo run\n"
"```"
msgstr ""
"```shell\n"
"cargo run\n"
"```"

#: src/exercises/concurrency/link-checker.md:128
msgid ""
"Use threads to check the links in parallel: send the URLs to be checked to a "
"channel and let a few threads check the URLs in parallel."
msgstr ""
"Comprueba los enlaces en paralelo con los hilos: env√≠a las URLs que se van a "
"comprobar a un canal y deja que varios hilos comprueben las URLs en paralelo."

#: src/exercises/concurrency/link-checker.md:130
msgid ""
"Extend this to recursively extract links from all pages on the `www.google."
"org` domain. Put an upper limit of 100 pages or so so that you don't end up "
"being blocked by the site."
msgstr ""
"Ampl√≠a esta opci√≥n para extraer enlaces de todas las p√°ginas del dominio "
"`www.google.org`. Define un l√≠mite m√°ximo de 100 p√°ginas para que el sitio "
"no te bloquee."

#: src/async.md:1
msgid "Async Rust"
msgstr "Async en Rust"

#: src/async.md:3
msgid ""
"\"Async\" is a concurrency model where multiple tasks are executed "
"concurrently by executing each task until it would block, then switching to "
"another task that is ready to make progress. The model allows running a "
"larger number of tasks on a limited number of threads. This is because the "
"per-task overhead is typically very low and operating systems provide "
"primitives for efficiently identifying I/O that is able to proceed."
msgstr ""
"\"Async\" es un modelo de concurrencia en el que se ejecutan varias tareas "
"al mismo tiempo. Se ejecuta cada una de ellas hasta que se bloquea y, a "
"continuaci√≥n, se cambia a otra tarea que est√° lista para progresar. El "
"modelo permite ejecutar un mayor n√∫mero de tareas en un n√∫mero limitado de "
"hilos. Esto se debe a que la sobrecarga por tarea suele ser muy baja y los "
"sistemas operativos proporcionan primitivos para identificar de forma "
"eficiente las E/S que pueden continuar."

#: src/async.md:10
msgid ""
"Rust's asynchronous operation is based on \"futures\", which represent work "
"that may be completed in the future. Futures are \"polled\" until they "
"signal that they are complete."
msgstr ""
"La operaci√≥n as√≠ncrona de Rust se basa en \"valores futuros\", que "
"representan el trabajo que puede completarse m√°s adelante. Los futuros se "
"\"sondean\" hasta que indican que se han completado."

#: src/async.md:14
msgid ""
"Futures are polled by an async runtime, and several different runtimes are "
"available."
msgstr ""
"Los futuros se sondean mediante un tiempo de ejecuci√≥n as√≠ncrono y hay "
"disponibles varios tiempos de ejecuci√≥n diferentes."

#: src/async.md:17
msgid "Comparisons"
msgstr "Comparaciones"

#: src/async.md:19
msgid ""
"Python has a similar model in its `asyncio`. However, its `Future` type is "
"callback-based, and not polled. Async Python programs require a \"loop\", "
"similar to a runtime in Rust."
msgstr ""
"Python tiene un modelo similar en su `asyncio`. Sin embargo, su tipo "
"`Future` est√° basado en retrollamadas y no se sondea. Los programas "
"as√≠ncronos de Python requieren un \"bucle\", similar a un tiempo de "
"ejecuci√≥n en Rust."

#: src/async.md:23
msgid ""
"JavaScript's `Promise` is similar, but again callback-based. The language "
"runtime implements the event loop, so many of the details of Promise "
"resolution are hidden."
msgstr ""
"`Promise` de JavaScript es parecido, pero tambi√©n se basa en retrollamadas. "
"El tiempo de ejecuci√≥n del lenguaje implementa el bucle de eventos, por lo "
"que muchos de los detalles de la resoluci√≥n de Promise est√°n ocultos."

#: src/async/async-await.md:1
msgid "`async`/`await`"
msgstr "`async`/`await`"

#: src/async/async-await.md:3
msgid ""
"At a high level, async Rust code looks very much like \"normal\" sequential "
"code:"
msgstr ""
"En general, el c√≥digo as√≠ncrono de Rust se parece mucho al c√≥digo secuencial "
"\"normal\":"

#: src/async/async-await.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use futures::executor::block_on;\n"
"\n"
"async fn count_to(count: i32) {\n"
"    for i in 1..=count {\n"
"        println!(\"Count is: {i}!\");\n"
"    }\n"
"}\n"
"\n"
"async fn async_main(count: i32) {\n"
"    count_to(count).await;\n"
"}\n"
"\n"
"fn main() {\n"
"    block_on(async_main(10));\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"use futures::executor::block_on;\n"
"\n"
"async fn count_to(count: i32) {\n"
"    for i in 1..=count {\n"
"        println!(\"Count is: {i}!\");\n"
"    }\n"
"}\n"
"\n"
"async fn async_main(count: i32) {\n"
"    count_to(count).await;\n"
"}\n"
"\n"
"fn main() {\n"
"    block_on(async_main(10));\n"
"}\n"
"```"

#: src/async/async-await.md:27
msgid ""
"Note that this is a simplified example to show the syntax. There is no long "
"running operation or any real concurrency in it!"
msgstr ""
"Ten en cuenta que este es un ejemplo simplificado para mostrar la sintaxis. "
"No hay ninguna operaci√≥n de larga duraci√≥n ni concurrencia real."

#: src/async/async-await.md:30
msgid "What is the return type of an async call?"
msgstr "¬øCu√°l es el tipo de resultado devuelto de una llamada as√≠ncrona?"

#: src/async/async-await.md:31
msgid "Use `let future: () = async_main(10);` in `main` to see the type."
msgstr "Consulta el tipo con `let future: () = async_main(10);` en `main` ."

#: src/async/async-await.md:33
msgid ""
"The \"async\" keyword is syntactic sugar. The compiler replaces the return "
"type with a future. "
msgstr ""
"La palabra clave \"async\" es az√∫car sint√°ctico. El compilador sustituye el "
"tipo de resultado devuelto por un futuro. "

#: src/async/async-await.md:36
msgid ""
"You cannot make `main` async, without additional instructions to the "
"compiler on how to use the returned future."
msgstr ""
"No se puede hacer que `main` sea as√≠ncrono sin dar instrucciones adicionales "
"al compilador sobre c√≥mo usar el futuro devuelto."

#: src/async/async-await.md:39
msgid ""
"You need an executor to run async code. `block_on` blocks the current thread "
"until the provided future has run to completion. "
msgstr ""
"Se necesita un ejecutor para ejecutar el c√≥digo as√≠ncrono. `block_on` "
"bloquea el hilo hasta que se complete el futuro proporcionado. "

#: src/async/async-await.md:42
msgid ""
"`.await` asynchronously waits for the completion of another operation. "
"Unlike `block_on`, `.await` doesn't block the current thread."
msgstr ""
"`.await` espera de forma as√≠ncrona la finalizaci√≥n de otra operaci√≥n. A "
"diferencia de `block_on`, `.await` no bloquea el hilo."

#: src/async/async-await.md:45
msgid ""
"`.await` can only be used inside an `async` function (or block; these are "
"introduced later). "
msgstr ""
"`.await` solo se puede usar dentro de una funci√≥n `async` (o bloqueo; estos "
"se ver√°n m√°s tarde). "

#: src/async/futures.md:3
msgid ""
"[`Future`](https://doc.rust-lang.org/std/future/trait.Future.html) is a "
"trait, implemented by objects that represent an operation that may not be "
"complete yet. A future can be polled, and `poll` returns a [`Poll`](https://"
"doc.rust-lang.org/std/task/enum.Poll.html)."
msgstr ""
"[`Future`](https://doc.rust-lang.org/std/future/trait.Future.html) es un "
"trait implementado por objetos que representan una operaci√≥n que puede que "
"a√∫n no se haya completado. Se puede sondear un futuro y `poll` devuelve un "
"[`Poll`](https://doc.rust-lang.org/std/task/enum.Poll.html)."

#: src/async/futures.md:8
msgid ""
"```rust\n"
"use std::pin::Pin;\n"
"use std::task::Context;\n"
"\n"
"pub trait Future {\n"
"    type Output;\n"
"    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::"
"Output>;\n"
"}\n"
"\n"
"pub enum Poll<T> {\n"
"    Ready(T),\n"
"    Pending,\n"
"}\n"
"```"
msgstr ""

#: src/async/futures.md:23
msgid ""
"An async function returns an `impl Future`. It's also possible (but "
"uncommon) to implement `Future` for your own types. For example, the "
"`JoinHandle` returned from `tokio::spawn` implements `Future` to allow "
"joining to it."
msgstr ""
"Una funci√≥n as√≠ncrona devuelve `impl Future`. Tambi√©n es posible (aunque no "
"es habitual) implementar `Future` para tus propios tipos. Por ejemplo, el "
"`JoinHandle` devuelto por `tokio::spawn` implementa `Future` para permitir "
"que se una a √©l."

#: src/async/futures.md:27
msgid ""
"The `.await` keyword, applied to a Future, causes the current async function "
"to pause until that Future is ready, and then evaluates to its output."
msgstr ""
"La palabra clave `.await`, aplicada a un futuro, provoca que la funci√≥n "
"as√≠ncrona se detenga hasta que dicho futuro est√© listo y, a continuaci√≥n, se "
"eval√∫a su salida."

#: src/async/futures.md:32
msgid ""
"The `Future` and `Poll` types are implemented exactly as shown; click the "
"links to show the implementations in the docs."
msgstr ""
"Los tipos `Future` y `Polll` se implementan exactamente como se indica. Haz "
"clic en los enlaces para mostrar las implementaciones en los documentos."

#: src/async/futures.md:35
msgid ""
"We will not get to `Pin` and `Context`, as we will focus on writing async "
"code, rather than building new async primitives. Briefly:"
msgstr ""
"No trataremos `Pin` ni `Context`, ya que nos centraremos en escribir c√≥digo "
"as√≠ncrono en lugar de compilar nuevos primitivos as√≠ncronos. Brevemente:"

#: src/async/futures.md:38
msgid ""
"`Context` allows a Future to schedule itself to be polled again when an "
"event occurs."
msgstr ""
"`Context` permite que un futuro se programe a s√≠ mismo para que se vuelva a "
"sondear cuando se produzca un evento."

#: src/async/futures.md:41
msgid ""
"`Pin` ensures that the Future isn't moved in memory, so that pointers into "
"that future remain valid. This is required to allow references to remain "
"valid after an `.await`."
msgstr ""
"`Pin` asegura que el futuro no se mueva en la memoria, de forma que los "
"punteros en ese futuro siguen siendo v√°lidos. Esto es necesario para que las "
"referencias sigan siendo v√°lidas despu√©s de `.await`."

#: src/async/runtimes.md:3
msgid ""
"A _runtime_ provides support for performing operations asynchronously (a "
"_reactor_) and is responsible for executing futures (an _executor_). Rust "
"does not have a \"built-in\" runtime, but several options are available:"
msgstr ""
"Un _runtime_ ofrece asistencia para realizar operaciones de forma as√≠ncrona "
"(un _reactor_) y es responsable de ejecutar futuros (un _ejecutor_). Rust no "
"cuenta con un tiempo de ejecuci√≥n \"integrado\", pero hay varias opciones "
"disponibles:"

#: src/async/runtimes.md:7
msgid ""
"[Tokio](https://tokio.rs/): performant, with a well-developed ecosystem of "
"functionality like [Hyper](https://hyper.rs/) for HTTP or [Tonic](https://"
"github.com/hyperium/tonic) for gRPC."
msgstr ""
"[Tokio](https://tokio.rs/): eficaz, con un ecosistema bien desarrollado de "
"funciones, como [Hyper](https://hyper.rs/) para HTTP o [Tonic](https://"
"github.com/hyperium/tonic) para usar gRPC."

#: src/async/runtimes.md:10
msgid ""
"[async-std](https://async.rs/): aims to be a \"std for async\", and includes "
"a basic runtime in `async::task`."
msgstr ""
"[async-std](https://async.rs/): se trata de un \"std para async\" e incluye "
"un tiempo de ejecuci√≥n b√°sico en `async::task`."

#: src/async/runtimes.md:12
msgid "[smol](https://docs.rs/smol/latest/smol/): simple and lightweight"
msgstr "[smol](https://docs.rs/smol/latest/smol/): sencillo y ligero."

#: src/async/runtimes.md:14
msgid ""
"Several larger applications have their own runtimes. For example, [Fuchsia]"
"(https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/lib/fuchsia-"
"async/src/lib.rs) already has one."
msgstr ""
"Varias aplicaciones de mayor tama√±o tienen sus propios tiempos de ejecuci√≥n. "
"Por ejemplo, [Fuchsia](https://fuchsia.googlesource.com/fuchsia/+/refs/heads/"
"main/src/lib/fuchsia-async/src/lib.rs) ya tiene uno."

#: src/async/runtimes.md:20
msgid ""
"Note that of the listed runtimes, only Tokio is supported in the Rust "
"playground. The playground also does not permit any I/O, so most interesting "
"async things can't run in the playground."
msgstr ""
"Ten en cuenta que, de los tiempos de ejecuci√≥n enumerados, el playground de "
"Rust solo admite Tokio. El playground tampoco permite ning√∫n tipo de E/S, "
"por lo que la mayor√≠a de elementos as√≠ncronos interesantes no se pueden "
"ejecutar. en √©l."

#: src/async/runtimes.md:24
msgid ""
"Futures are \"inert\" in that they do not do anything (not even start an I/O "
"operation) unless there is an executor polling them. This differs from JS "
"Promises, for example, which will run to completion even if they are never "
"used."
msgstr ""
"Los futuros son \"inertes\", ya que no realizan ninguna acci√≥n (ni siquiera "
"iniciar una operaci√≥n de E/S) a menos que haya un ejecutor que los sondee. "
"Muy diferente de las promesas de JavaScript, por ejemplo, que se ejecutan "
"hasta su finalizaci√≥n, aunque nunca se utilicen."

#: src/async/runtimes/tokio.md:4
msgid "Tokio provides: "
msgstr "Tokio ofrece lo siguiente: "

#: src/async/runtimes/tokio.md:6
msgid "A multi-threaded runtime for executing asynchronous code."
msgstr "Un tiempo de ejecuci√≥n multihilo para ejecutar c√≥digo as√≠ncrono."

#: src/async/runtimes/tokio.md:7
msgid "An asynchronous version of the standard library."
msgstr "Una versi√≥n as√≠ncrona de la biblioteca est√°ndar."

#: src/async/runtimes/tokio.md:8
msgid "A large ecosystem of libraries."
msgstr "Un amplio ecosistema de bibliotecas."

#: src/async/runtimes/tokio.md:10
msgid ""
"```rust,editable,compile_fail\n"
"use tokio::time;\n"
"\n"
"async fn count_to(count: i32) {\n"
"    for i in 1..=count {\n"
"        println!(\"Count in task: {i}!\");\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"    }\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    tokio::spawn(count_to(10));\n"
"\n"
"    for i in 1..5 {\n"
"        println!(\"Main task: {i}\");\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/async/runtimes/tokio.md:33
msgid "With the `tokio::main` macro we can now make `main` async."
msgstr "Con la macro `tokio::main`, podemos hacer que `main` sea as√≠ncrono."

#: src/async/runtimes/tokio.md:35
msgid "The `spawn` function creates a new, concurrent \"task\"."
msgstr "La funci√≥n `spawn` crea una \"tarea\" simult√°nea."

#: src/async/runtimes/tokio.md:37
msgid "Note: `spawn` takes a `Future`, you don't call `.await` on `count_to`."
msgstr ""
"Nota: `spawn` utiliza un `Future`, no se llama a `.await` en `count_to`."

#: src/async/runtimes/tokio.md:39
msgid "**Further exploration:**"
msgstr "**M√°s informaci√≥n:**"

#: src/async/runtimes/tokio.md:41
msgid ""
"Why does `count_to` not (usually) get to 10? This is an example of async "
"cancellation. `tokio::spawn` returns a handle which can be awaited to wait "
"until it finishes."
msgstr ""
"¬øPor qu√© `count_to` no suele llegar a 10? Se trata de un ejemplo de "
"cancelaci√≥n as√≠ncrona. `tokio::spawn` devuelve un controlador que puede "
"esperarse hasta que termine."

#: src/async/runtimes/tokio.md:45
msgid "Try `count_to(10).await` instead of spawning."
msgstr "Prueba `count_to(10).await` en lugar de usar spawn."

#: src/async/runtimes/tokio.md:47
msgid "Try awaiting the task returned from `tokio::spawn`."
msgstr "Intenta esperar a la correci√≥n de la tarea de `tokio::spawn`."

#: src/async/tasks.md:3
msgid "Rust has a task system, which is a form of lightweight threading."
msgstr "Rust tiene un sistema de tareas, que es una forma de hilo ligero."

#: src/async/tasks.md:5
msgid ""
"A task has a single top-level future which the executor polls to make "
"progress. That future may have one or more nested futures that its `poll` "
"method polls, corresponding loosely to a call stack. Concurrency within a "
"task is possible by polling multiple child futures, such as racing a timer "
"and an I/O operation."
msgstr ""
"Una tarea tiene un solo futuro de nivel superior que el ejecutor sondea para "
"hacer que progrese. El futuro puede tener uno o varios futuros anidados que "
"su m√©todo `poll` sondea, lo que se corresponde con una pila de llamadas. La "
"concurrencia dentro de una tarea es posible mediante el sondeo de varios "
"futuros secundarios , como una carrera de un temporizador y una operaci√≥n de "
"E/S."

#: src/async/tasks.md:10
msgid ""
"```rust,compile_fail\n"
"use tokio::io::{self, AsyncReadExt, AsyncWriteExt};\n"
"use tokio::net::TcpListener;\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> io::Result<()> {\n"
"    let listener = TcpListener::bind(\"127.0.0.1:6142\").await?;\n"
"\tprintln!(\"listening on port 6142\");\n"
"\n"
"    loop {\n"
"        let (mut socket, addr) = listener.accept().await?;\n"
"\n"
"        println!(\"connection from {addr:?}\");\n"
"\n"
"        tokio::spawn(async move {\n"
"            if let Err(e) = socket.write_all(b\"Who are you?\\n\").await {\n"
"                println!(\"socket error: {e:?}\");\n"
"                return;\n"
"            }\n"
"\n"
"            let mut buf = vec![0; 1024];\n"
"            let reply = match socket.read(&mut buf).await {\n"
"                Ok(n) => {\n"
"                    let name = std::str::from_utf8(&buf[..n]).unwrap()."
"trim();\n"
"                    format!(\"Thanks for dialing in, {name}!\\n\")\n"
"                }\n"
"                Err(e) => {\n"
"                    println!(\"socket error: {e:?}\");\n"
"                    return;\n"
"                }\n"
"            };\n"
"\n"
"            if let Err(e) = socket.write_all(reply.as_bytes()).await {\n"
"                println!(\"socket error: {e:?}\");\n"
"            }\n"
"        });\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/async/tasks.md:52 src/async/control-flow/join.md:36
msgid ""
"Copy this example into your prepared `src/main.rs` and run it from there."
msgstr ""
"Copia este ejemplo en el archivo `src/main.rs` que has preparado y ejec√∫talo "
"desde ah√≠."

#: src/async/tasks.md:54
msgid ""
"Ask students to visualize what the state of the example server would be with "
"a few connected clients. What tasks exist? What are their Futures?"
msgstr ""
"Pide a los alumnos que vean cu√°l ser√≠a el estado del servidor de ejemplo con "
"algunos clientes conectados. ¬øQu√© tareas hay? ¬øCu√°les son sus futuros?"

#: src/async/tasks.md:57
msgid ""
"This is the first time we've seen an `async` block. This is similar to a "
"closure, but does not take any arguments. Its return value is a Future, "
"similar to an `async fn`. "
msgstr ""
"Esta es la primera vez que vemos un bloque `async`. Es similar a un cierre, "
"pero no acepta argumentos. Su valor devuelto es un futuro, similar a `async "
"fn`. "

#: src/async/tasks.md:61
msgid ""
"Refactor the async block into a function, and improve the error handling "
"using `?`."
msgstr ""
"Refactoriza el bloque as√≠ncrono en una funci√≥n y mejora la gesti√≥n de "
"errores con `?`."

#: src/async/channels.md:3
msgid ""
"Several crates have support for asynchronous channels. For instance `tokio`:"
msgstr "Varios crates admiten canales as√≠ncronos. Por ejemplo, `tokio`:"

#: src/async/channels.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use tokio::sync::mpsc::{self, Receiver};\n"
"\n"
"async fn ping_handler(mut input: Receiver<()>) {\n"
"    let mut count: usize = 0;\n"
"\n"
"    while let Some(_) = input.recv().await {\n"
"        count += 1;\n"
"        println!(\"Received {count} pings so far.\");\n"
"    }\n"
"\n"
"    println!(\"ping_handler complete\");\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let (sender, receiver) = mpsc::channel(32);\n"
"    let ping_handler_task = tokio::spawn(ping_handler(receiver));\n"
"    for i in 0..10 {\n"
"        sender.send(()).await.expect(\"Failed to send ping.\");\n"
"        println!(\"Sent {} pings so far.\", i + 1);\n"
"    }\n"
"\n"
"    drop(sender);\n"
"    ping_handler_task.await.expect(\"Something went wrong in ping handler "
"task.\");\n"
"}\n"
"```"
msgstr ""

#: src/async/channels.md:35
msgid "Change the channel size to `3` and see how it affects the execution."
msgstr ""
"Cambia el tama√±o del canal a `3` y comprueba c√≥mo afecta a la ejecuci√≥n."

#: src/async/channels.md:37
msgid ""
"Overall, the interface is similar to the `sync` channels as seen in the "
"[morning class](concurrency/channels.md)."
msgstr ""
"En general, la interfaz es similar a los canales `sync`, tal como se ha "
"visto ver en la [clase de la ma√±ana](concurrency/channels.md)."

#: src/async/channels.md:40
msgid "Try removing the `std::mem::drop` call. What happens? Why?"
msgstr "Prueba a quitar la llamada a `std::mem::drop`. ¬øQu√© sucede? ¬øPor qu√©?"

#: src/async/channels.md:42
msgid ""
"The [Flume](https://docs.rs/flume/latest/flume/) crate has channels that "
"implement both `sync` and `async` `send` and `recv`. This can be convenient "
"for complex applications with both IO and heavy CPU processing tasks."
msgstr ""
"El crate [Flume](https://docs.rs/flume/latest/flume/) tiene canales que "
"implementan `sync` y `async`,`send` y `recv`. Esto puede resultar pr√°ctico "
"para aplicaciones complejas con tareas de E/S y tareas pesadas de "
"procesamiento de CPU."

#: src/async/channels.md:46
msgid ""
"What makes working with `async` channels preferable is the ability to "
"combine them with other `future`s to combine them and create complex control "
"flow."
msgstr ""
"Es preferible trabajar con canales `async` por la capacidad de combinarlos "
"con otros `future` para poder crear un flujo de control complejo."

#: src/async/control-flow.md:1
msgid "Futures Control Flow"
msgstr "Flujo de Control de Futuros"

#: src/async/control-flow.md:3
msgid ""
"Futures can be combined together to produce concurrent compute flow graphs. "
"We have already seen tasks, that function as independent threads of "
"execution."
msgstr ""
"Los futuros pueden combinarse para producir gr√°ficos de flujo de computaci√≥n "
"simult√°neos. Ya hemos visto tareas que funcionan como hilos de ejecuci√≥n "
"independientes."

#: src/async/control-flow.md:6
msgid "[Join](control-flow/join.md)"
msgstr "[Join](control-flow/join.md)"

#: src/async/control-flow.md:7
msgid "[Select](control-flow/select.md)"
msgstr "[Select](control-flow/select.md)"

#: src/async/control-flow/join.md:3
msgid ""
"A join operation waits until all of a set of futures are ready, and returns "
"a collection of their results. This is similar to `Promise.all` in "
"JavaScript or `asyncio.gather` in Python."
msgstr ""
"Una operaci√≥n join espera hasta que todos los futuros est√©n listos y "
"devuelve una colecci√≥n de sus resultados. Es similar a `Promise.all` en "
"JavaScript o `asyncio.gather` en Python."

#: src/async/control-flow/join.md:7
msgid ""
"```rust,editable,compile_fail\n"
"use anyhow::Result;\n"
"use futures::future;\n"
"use reqwest;\n"
"use std::collections::HashMap;\n"
"\n"
"async fn size_of_page(url: &str) -> Result<usize> {\n"
"    let resp = reqwest::get(url).await?;\n"
"    Ok(resp.text().await?.len())\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let urls: [&str; 4] = [\n"
"        \"https://google.com\",\n"
"        \"https://httpbin.org/ip\",\n"
"        \"https://play.rust-lang.org/\",\n"
"        \"BAD_URL\",\n"
"    ];\n"
"    let futures_iter = urls.into_iter().map(size_of_page);\n"
"    let results = future::join_all(futures_iter).await;\n"
"    let page_sizes_dict: HashMap<&str, Result<usize>> =\n"
"        urls.into_iter().zip(results.into_iter()).collect();\n"
"    println!(\"{:?}\", page_sizes_dict);\n"
"}\n"
"```"
msgstr ""

#: src/async/control-flow/join.md:38
msgid ""
"For multiple futures of disjoint types, you can use `std::future::join!` but "
"you must know how many futures you will have at compile time. This is "
"currently in the `futures` crate, soon to be stabilised in `std::future`."
msgstr ""
"En el caso de varios futuros de tipos distintos, puedes utilizar `std::"
"future::join!`, pero debes saber cu√°ntos futuros tendr√°s en el tiempo de "
"compilaci√≥n. Esto se encuentra actualmente en el crate `futures`, que pronto "
"se estabilizar√° en `std::future`."

#: src/async/control-flow/join.md:42
msgid ""
"The risk of `join` is that one of the futures may never resolve, this would "
"cause your program to stall. "
msgstr ""
"El riesgo que supone 'join' es que puede que uno de los futuros no se "
"resuelva nunca, causando que el programa se bloquee. "

#: src/async/control-flow/join.md:45
msgid ""
"You can also combine `join_all` with `join!` for instance to join all "
"requests to an http service as well as a database query. Try adding a "
"`tokio::time::sleep` to the future, using `futures::join!`. This is not a "
"timeout (that requires `select!`, explained in the next chapter), but "
"demonstrates `join!`."
msgstr ""
"Tambi√©n puedes combinar `join_all` con `join!`, por ejemplo, para unir todas "
"las solicitudes a un servicio HTTP, as√≠ como una consulta a la base de "
"datos. Prueba a a√±adir un tokio::time::sleep`al futuro mediante`futures::"
"join!`. No se trata de un tiempo de espera (para eso se requiere `select!`, "
"que se explica en el siguiente cap√≠tulo), sino que muestra `join!\\`."

#: src/async/control-flow/select.md:3
msgid ""
"A select operation waits until any of a set of futures is ready, and "
"responds to that future's result. In JavaScript, this is similar to `Promise."
"race`. In Python, it compares to `asyncio.wait(task_set, return_when=asyncio."
"FIRST_COMPLETED)`."
msgstr ""
"Una operaci√≥n select espera hasta que un conjunto de futuros est√© listo y "
"responde al resultado de ese futuro. En JavaScript, esto es similar a "
"`Promise.race`. En Python, se compara con `asyncio.wait(task_set, "
"return_when=asyncio.FIRST_COMPLETED)`."

#: src/async/control-flow/select.md:8
msgid ""
"Similar to a match statement, the body of `select!` has a number of arms, "
"each of the form `pattern = future => statement`. When the `future` is "
"ready, the `statement` is executed with the variables in `pattern` bound to "
"the `future`'s result."
msgstr ""
"Al igual que en el caso de una instrucci√≥n _match_, el cuerpo de `select!` "
"tiene una serie de brazos, cada uno de los cuales tiene la forma `pattern = "
"future => statement`. Cuando `future` est√° listo, la instrucci√≥n se ejecuta "
"con las variables de `pattern` vinculadas al resultado de `future`."

#: src/async/control-flow/select.md:13
msgid ""
"```rust,editable,compile_fail\n"
"use tokio::sync::mpsc::{self, Receiver};\n"
"use tokio::time::{sleep, Duration};\n"
"\n"
"#[derive(Debug, PartialEq)]\n"
"enum Animal {\n"
"    Cat { name: String },\n"
"    Dog { name: String },\n"
"}\n"
"\n"
"async fn first_animal_to_finish_race(\n"
"    mut cat_rcv: Receiver<String>,\n"
"    mut dog_rcv: Receiver<String>,\n"
") -> Option<Animal> {\n"
"    tokio::select! {\n"
"        cat_name = cat_rcv.recv() => Some(Animal::Cat { name: cat_name? }),\n"
"        dog_name = dog_rcv.recv() => Some(Animal::Dog { name: dog_name? })\n"
"    }\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let (cat_sender, cat_receiver) = mpsc::channel(32);\n"
"    let (dog_sender, dog_receiver) = mpsc::channel(32);\n"
"    tokio::spawn(async move {\n"
"        sleep(Duration::from_millis(500)).await;\n"
"        cat_sender\n"
"            .send(String::from(\"Felix\"))\n"
"            .await\n"
"            .expect(\"Failed to send cat.\");\n"
"    });\n"
"    tokio::spawn(async move {\n"
"        sleep(Duration::from_millis(50)).await;\n"
"        dog_sender\n"
"            .send(String::from(\"Rex\"))\n"
"            .await\n"
"            .expect(\"Failed to send dog.\");\n"
"    });\n"
"\n"
"    let winner = first_animal_to_finish_race(cat_receiver, dog_receiver)\n"
"        .await\n"
"        .expect(\"Failed to receive winner\");\n"
"\n"
"    println!(\"Winner is {winner:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/async/control-flow/select.md:62
msgid ""
"In this example, we have a race between a cat and a dog. "
"`first_animal_to_finish_race` listens to both channels and will pick "
"whichever arrives first. Since the dog takes 50ms, it wins against the cat "
"that take 500ms."
msgstr ""
"En este ejemplo, tenemos una carrera entre un gato y un perro. "
"`first_animal_to_finish_race` escucha a ambos canales y elige el que llegue "
"primero. Como el perro tarda 50¬†ms, gana al gato, que tarda 500¬†ms."

#: src/async/control-flow/select.md:67
msgid ""
"You can use `oneshot` channels in this example as the channels are supposed "
"to receive only one `send`."
msgstr ""
"En este ejemplo, puedes usar canales `oneshot`, ya que se supone que solo "
"recibir√°n un `send`."

#: src/async/control-flow/select.md:70
msgid ""
"Try adding a deadline to the race, demonstrating selecting different sorts "
"of futures."
msgstr ""
"Prueba a a√±adir un l√≠mite a la carrera y demuestra c√≥mo se seleccionan "
"distintos tipos de futuros."

#: src/async/control-flow/select.md:73
msgid ""
"Note that `select!` drops unmatched branches, which cancels their futures. "
"It is easiest to use when every execution of `select!` creates new futures."
msgstr ""
"Ten en cuenta que `select!` elimina las ramas sin coincidencias, cancelando "
"as√≠ sus futuros. Es m√°s f√°cil de usar cuando cada ejecuci√≥n de `select!` "
"crea futuros."

#: src/async/control-flow/select.md:76
msgid ""
"An alternative is to pass `&mut future` instead of the future itself, but "
"this can lead to issues, further discussed in the pinning slide."
msgstr ""
"Tambi√©n puedes enviar `&mut future` en lugar del futuro en s√≠, pero esto "
"podr√≠a provocar problemas, como se explica m√°s adelante en la diapositiva "
"sobre pines."

#: src/async/pitfalls.md:1
msgid "Pitfalls of async/await"
msgstr "Inconvenientes de async/await"

#: src/async/pitfalls.md:3
msgid ""
"Async / await provides convenient and efficient abstraction for concurrent "
"asynchronous programming. However, the async/await model in Rust also comes "
"with its share of pitfalls and footguns. We illustrate some of them in this "
"chapter:"
msgstr ""
"Async/await ofrece una abstracci√≥n pr√°ctica y eficiente para la programaci√≥n "
"as√≠ncrona simult√°nea. Sin embargo, el modelo async/await de Rust tambi√©n "
"viene acompa√±ado de errores y footguns. En este cap√≠tulo veremos algunos de "
"ellos:"

#: src/async/pitfalls.md:5
msgid "[Blocking the Executor](pitfalls/blocking-executor.md)"
msgstr "[Bloqueo del ejecutor](pitfalls/blocking-executor.md)"

#: src/async/pitfalls.md:6
msgid "[Pin](pitfalls/pin.md)"
msgstr "[Pin](pitfalls/pin.md)"

#: src/async/pitfalls.md:7
msgid "[Async Traits](pitfalls/async-traits.md)"
msgstr "[Traits as√≠ncronos](pitfalls/async-traits.md)"

#: src/async/pitfalls.md:8
msgid "[Cancellation](pitfalls/cancellation.md)"
msgstr "[Cancelaci√≥n](pitfalls/cancellation.md)"

#: src/async/pitfalls/blocking-executor.md:1
msgid "Blocking the executor"
msgstr "Bloqueo del ejecutor"

#: src/async/pitfalls/blocking-executor.md:3
msgid ""
"Most async runtimes only allow IO tasks to run concurrently. This means that "
"CPU blocking tasks will block the executor and prevent other tasks from "
"being executed. An easy workaround is to use async equivalent methods where "
"possible."
msgstr ""
"La mayor√≠a de los tiempos de ejecuci√≥n as√≠ncronos solo permiten que las "
"tareas de E/S se ejecuten de forma simult√°nea. Esto significa que las tareas "
"que bloquean la CPU bloquear√°n el ejecutor e impedir√°n que se ejecuten otras "
"tareas. Una soluci√≥n alternativa y sencilla es utilizar m√©todos as√≠ncronos "
"equivalentes siempre que sea posible."

#: src/async/pitfalls/blocking-executor.md:7
msgid ""
"```rust,editable,compile_fail\n"
"use futures::future::join_all;\n"
"use std::time::Instant;\n"
"\n"
"async fn sleep_ms(start: &Instant, id: u64, duration_ms: u64) {\n"
"    std::thread::sleep(std::time::Duration::from_millis(duration_ms));\n"
"    println!(\n"
"        \"future {id} slept for {duration_ms}ms, finished after {}ms\",\n"
"        start.elapsed().as_millis()\n"
"    );\n"
"}\n"
"\n"
"#[tokio::main(flavor = \"current_thread\")]\n"
"async fn main() {\n"
"    let start = Instant::now();\n"
"    let sleep_futures = (1..=10).map(|t| sleep_ms(&start, t, t * 10));\n"
"    join_all(sleep_futures).await;\n"
"}\n"
"```"
msgstr ""

#: src/async/pitfalls/blocking-executor.md:29
msgid ""
"Run the code and see that the sleeps happen consecutively rather than "
"concurrently."
msgstr ""
"Ejecuta el c√≥digo y comprueba que las suspensiones se producen de forma "
"consecutiva y no simult√°nea."

#: src/async/pitfalls/blocking-executor.md:32
msgid ""
"The `\"current_thread\"` flavor puts all tasks on a single thread. This "
"makes the effect more obvious, but the bug is still present in the multi-"
"threaded flavor."
msgstr ""
"La versi√≥n `\"current_thread\"` re√∫ne todas las tareas en un solo hilo. Esto "
"consigue que el efecto sea m√°s obvio, pero el error sigue estando presente "
"en la versi√≥n multihilo."

#: src/async/pitfalls/blocking-executor.md:36
msgid ""
"Switch the `std::thread::sleep` to `tokio::time::sleep` and await its result."
msgstr ""
"Cambia `std::thread::sleep` a `tokio::time::sleep`. y espera su resultado."

#: src/async/pitfalls/blocking-executor.md:38
msgid ""
"Another fix would be to `tokio::task::spawn_blocking` which spawns an actual "
"thread and transforms its handle into a future without blocking the executor."
msgstr ""
"Otra soluci√≥n ser√≠a `tokio::task::spawn_blocking`, que genera un hilo real y "
"transforma su controlador en un futuro sin bloquear el ejecutor."

#: src/async/pitfalls/blocking-executor.md:41
msgid ""
"You should not think of tasks as OS threads. They do not map 1 to 1 and most "
"executors will allow many tasks to run on a single OS thread. This is "
"particularly problematic when interacting with other libraries via FFI, "
"where that library might depend on thread-local storage or map to specific "
"OS threads (e.g., CUDA). Prefer `tokio::task::spawn_blocking` in such "
"situations."
msgstr ""
"No debes pensar en las tareas como hilos del sistema operativo. No se "
"asignan 1 a 1 y la mayor√≠a de los ejecutores permitir√°n que se ejecuten "
"muchas tareas en un solo hilo del sistema operativo. Esta situaci√≥n es "
"especialmente problem√°tica cuando se interact√∫a con otras bibliotecas a "
"trav√©s de FFI, donde dicha biblioteca puede depender del almacenamiento "
"local de hilos o puede asignarse a hilos espec√≠ficos del sistema operativo "
"(por ejemplo, CUDA). En estos casos es preferible usar `tokio::task::"
"spawn_blocking`."

#: src/async/pitfalls/blocking-executor.md:47
msgid ""
"Use sync mutexes with care. Holding a mutex over an `.await` may cause "
"another task to block, and that task may be running on the same thread."
msgstr ""
"Utiliza las exclusi√≥n mutuas de sincronizaci√≥n con cuidado. Si mantienes una "
"exclusi√≥n mutua sobre un `.await`, puede que se bloquee otra tarea y que "
"esta se est√© ejecutando en el mismo hilo."

#: src/async/pitfalls/pin.md:3
msgid ""
"When you await a future, all local variables (that would ordinarily be "
"stored on a stack frame) are instead stored in the Future for the current "
"async block. If your future has pointers to data on the stack, those "
"pointers might get invalidated. This is unsafe."
msgstr ""
"Cuando esperas un futuro, todas las variables locales (que normalmente se "
"almacenar√≠an en un marco de pila) se almacenan en el futuro del bloque "
"as√≠ncrono. Si tu futuro tiene punteros en datos de la pila, podr√≠an "
"invalidarse. Es una acci√≥n insegura."

#: src/async/pitfalls/pin.md:8
msgid ""
"Therefore, you must guarantee that the addresses your future points to don't "
"change. That is why we need to `pin` futures. Using the same future "
"repeatedly in a `select!` often leads to issues with pinned values."
msgstr ""
"Por lo tanto, debes asegurarte de que las direcciones a las que apunta el "
"futuro no cambien. Por ese motivo debemos fijar (`pin`) los futuros. Si se "
"usa el mismo futuro varias veces en un `select!`, se suelen producir "
"problemas en los valores fijados."

#: src/async/pitfalls/pin.md:12
msgid ""
"```rust,editable,compile_fail\n"
"use tokio::sync::{mpsc, oneshot};\n"
"use tokio::task::spawn;\n"
"use tokio::time::{sleep, Duration};\n"
"\n"
"// A work item. In this case, just sleep for the given time and respond\n"
"// with a message on the `respond_on` channel.\n"
"#[derive(Debug)]\n"
"struct Work {\n"
"    input: u32,\n"
"    respond_on: oneshot::Sender<u32>,\n"
"}\n"
"\n"
"// A worker which listens for work on a queue and performs it.\n"
"async fn worker(mut work_queue: mpsc::Receiver<Work>) {\n"
"    let mut iterations = 0;\n"
"    loop {\n"
"        tokio::select! {\n"
"            Some(work) = work_queue.recv() => {\n"
"                sleep(Duration::from_millis(10)).await; // Pretend to work.\n"
"                work.respond_on\n"
"                    .send(work.input * 1000)\n"
"                    .expect(\"failed to send response\");\n"
"                iterations += 1;\n"
"            }\n"
"            // TODO: report number of iterations every 100ms\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// A requester which requests work and waits for it to complete.\n"
"async fn do_work(work_queue: &mpsc::Sender<Work>, input: u32) -> u32 {\n"
"    let (tx, rx) = oneshot::channel();\n"
"    work_queue\n"
"        .send(Work {\n"
"            input,\n"
"            respond_on: tx,\n"
"        })\n"
"        .await\n"
"        .expect(\"failed to send on work queue\");\n"
"    rx.await.expect(\"failed waiting for response\")\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let (tx, rx) = mpsc::channel(10);\n"
"    spawn(worker(rx));\n"
"    for i in 0..100 {\n"
"        let resp = do_work(&tx, i).await;\n"
"        println!(\"work result for iteration {i}: {resp}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/async/pitfalls/pin.md:68
msgid ""
"You may recognize this as an example of the actor pattern. Actors typically "
"call `select!` in a loop."
msgstr ""
"Puede que reconozcas esto como un ejemplo del patr√≥n actor. Los actores "
"suelen llamar a `select!` en un bucle."

#: src/async/pitfalls/pin.md:71
msgid ""
"This serves as a summation of a few of the previous lessons, so take your "
"time with it."
msgstr ""
"Esta secci√≥n es un resumen de algunas de las lecciones anteriores, as√≠ que "
"t√≥mate tu tiempo ."

#: src/async/pitfalls/pin.md:74
msgid ""
"Naively add a `_ = sleep(Duration::from_millis(100)) => { println!(..) }` to "
"the `select!`. This will never execute. Why?"
msgstr ""
"Si a√±ade un `_ = sleep(Duration::from_millis(100)) => { println!(..) }` a "
"`select!`, nunca se ejecutar√°. ¬øPor qu√©?"

#: src/async/pitfalls/pin.md:77
msgid ""
"Instead, add a `timeout_fut` containing that future outside of the `loop`:"
msgstr ""
"En su lugar, a√±ade un `timeout_fut` que contenga ese futuro fuera de `loop`:"

#: src/async/pitfalls/pin.md:79
msgid ""
"```rust,compile_fail\n"
"let mut timeout_fut = sleep(Duration::from_millis(100));\n"
"loop {\n"
"    select! {\n"
"        ..,\n"
"        _ = timeout_fut => { println!(..); },\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/async/pitfalls/pin.md:88
msgid ""
"This still doesn't work. Follow the compiler errors, adding `&mut` to the "
"`timeout_fut` in the `select!` to work around the move, then using `Box::"
"pin`:"
msgstr ""
"Continuar√° sin funcionar. Sigue los errores del compilador y a√±ade `&mut` a "
"`timeout_fut` en `select!` para ir despejando el problema. A continuaci√≥n, "
"usa `Box::pin`:"

#: src/async/pitfalls/pin.md:92
msgid ""
"```rust,compile_fail\n"
"let mut timeout_fut = Box::pin(sleep(Duration::from_millis(100)));\n"
"loop {\n"
"    select! {\n"
"        ..,\n"
"        _ = &mut timeout_fut => { println!(..); },\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/async/pitfalls/pin.md:102
msgid ""
"This compiles, but once the timeout expires it is `Poll::Ready` on every "
"iteration (a fused future would help with this). Update to reset "
"`timeout_fut` every time it expires."
msgstr ""
"Se puede compilar, pero una vez que vence el tiempo de espera, aparece "
"`Poll::Ready` en cada iteraci√≥n (un futuro fusionado podr√≠a resultar √∫til). "
"Actualiza para restablecer `timeout_fut` cada vez que expire."

#: src/async/pitfalls/pin.md:106
msgid ""
"Box allocates on the heap. In some cases, `std::pin::pin!` (only recently "
"stabilized, with older code often using `tokio::pin!`) is also an option, "
"but that is difficult to use for a future that is reassigned."
msgstr ""
"Box se asigna en el mont√≠culo. En algunos casos, `std::pin::pin!` (solo si "
"se ha estabilizado recientemente, con c√≥digo antiguo que suele utilizar "
"`tokio::pin!`) tambi√©n es una opci√≥n, pero dif√≠cil de utilizar en un futuro "
"que se reasigna."

#: src/async/pitfalls/pin.md:110
msgid ""
"Another alternative is to not use `pin` at all but spawn another task that "
"will send to a `oneshot` channel every 100ms."
msgstr ""
"Otra alternativa es no utilizar `pin`, sino generar otra tarea que se "
"enviar√° a un canal de `oneshot` cada 100¬†ms."

#: src/async/pitfalls/async-traits.md:3
msgid ""
"Async methods in traits are not yet supported in the stable channel ([An "
"experimental feature exists in nightly and should be stabilized in the mid "
"term.](https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-"
"nightly.html))"
msgstr ""
"Los m√©todos as√≠ncronos en traits todav√≠a no son compatibles con el canal "
"estable. ([Existe una caracter√≠stica experimental en nightly que deber√≠a "
"estabilizarse a medio plazo.](https://blog.rust-lang.org/inside-"
"rust/2022/11/17/async-fn-in-trait-nightly.html))"

#: src/async/pitfalls/async-traits.md:5
msgid ""
"The crate [async_trait](https://docs.rs/async-trait/latest/async_trait/) "
"provides a workaround through a macro:"
msgstr ""
"El crate [async_trait](https://docs.rs/async-trait/latest/async_trait/) "
"proporciona una soluci√≥n mediante una macro:"

#: src/async/pitfalls/async-traits.md:7
msgid ""
"```rust,editable,compile_fail\n"
"use async_trait::async_trait;\n"
"use std::time::Instant;\n"
"use tokio::time::{sleep, Duration};\n"
"\n"
"#[async_trait]\n"
"trait Sleeper {\n"
"    async fn sleep(&self);\n"
"}\n"
"\n"
"struct FixedSleeper {\n"
"    sleep_ms: u64,\n"
"}\n"
"\n"
"#[async_trait]\n"
"impl Sleeper for FixedSleeper {\n"
"    async fn sleep(&self) {\n"
"        sleep(Duration::from_millis(self.sleep_ms)).await;\n"
"    }\n"
"}\n"
"\n"
"async fn run_all_sleepers_multiple_times(sleepers: Vec<Box<dyn Sleeper>>, "
"n_times: usize) {\n"
"    for _ in 0..n_times {\n"
"        println!(\"running all sleepers..\");\n"
"        for sleeper in &sleepers {\n"
"            let start = Instant::now();\n"
"            sleeper.sleep().await;\n"
"            println!(\"slept for {}ms\", start.elapsed().as_millis());\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let sleepers: Vec<Box<dyn Sleeper>> = vec![\n"
"        Box::new(FixedSleeper { sleep_ms: 50 }),\n"
"        Box::new(FixedSleeper { sleep_ms: 100 }),\n"
"    ];\n"
"    run_all_sleepers_multiple_times(sleepers, 5).await;\n"
"}\n"
"```"
msgstr ""

#: src/async/pitfalls/async-traits.md:51
msgid ""
"`async_trait` is easy to use, but note that it's using heap allocations to "
"achieve this. This heap allocation has performance overhead."
msgstr ""
"`async_trait` es f√°cil de usar, pero ten en cuenta que utiliza asignaciones "
"de mont√≠culos para conseguirlo. Esta asignaci√≥n de mont√≠culo tiene una "
"sobrecarga de rendimiento."

#: src/async/pitfalls/async-traits.md:54
msgid ""
"The challenges in language support for `async trait` are deep Rust and "
"probably not worth describing in-depth. Niko Matsakis did a good job of "
"explaining them in [this post](https://smallcultfollowing.com/babysteps/"
"blog/2019/10/26/async-fn-in-traits-are-hard/) if you are interested in "
"digging deeper."
msgstr ""
"Los problemas de compatibilidad del lenguaje con `async trait` son muy "
"complejos y no vale la pena describirlos en profundidad. Niko Matsakis lo "
"explica muy bien en [esta publicaci√≥n](https://smallcultfollowing.com/"
"babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/), por si te interesa "
"investigar m√°s a fondo."

#: src/async/pitfalls/async-traits.md:60
msgid ""
"Try creating a new sleeper struct that will sleep for a random amount of "
"time and adding it to the Vec."
msgstr ""
"Prueba a crear una estructura que entre en suspensi√≥n durante un periodo "
"aleatorio y a√±√°dela a Vec."

#: src/async/pitfalls/cancellation.md:3
msgid ""
"Dropping a future implies it can never be polled again. This is called "
"_cancellation_ and it can occur at any `await` point. Care is needed to "
"ensure the system works correctly even when futures are cancelled. For "
"example, it shouldn't deadlock or lose data."
msgstr ""
"Si eliminas un futuro, no se podr√° volver a sondear. Este fen√≥meno se "
"denomina _cancelaci√≥n_ y puede producirse en cualquier momento de `await`. "
"Hay que tener cuidado para asegurar que el sistema funcione correctamente, "
"incluso cuando se cancelen los futuros. Por ejemplo, no deber√≠a sufrir "
"interbloqueos o perder datos."

#: src/async/pitfalls/cancellation.md:8
msgid ""
"```rust,editable,compile_fail\n"
"use std::io::{self, ErrorKind};\n"
"use std::time::Duration;\n"
"use tokio::io::{AsyncReadExt, AsyncWriteExt, DuplexStream};\n"
"\n"
"struct LinesReader {\n"
"    stream: DuplexStream,\n"
"}\n"
"\n"
"impl LinesReader {\n"
"    fn new(stream: DuplexStream) -> Self {\n"
"        Self { stream }\n"
"    }\n"
"\n"
"    async fn next(&mut self) -> io::Result<Option<String>> {\n"
"        let mut bytes = Vec::new();\n"
"        let mut buf = [0];\n"
"        while self.stream.read(&mut buf[..]).await? != 0 {\n"
"            bytes.push(buf[0]);\n"
"            if buf[0] == b'\\n' {\n"
"                break;\n"
"            }\n"
"        }\n"
"        if bytes.is_empty() {\n"
"            return Ok(None)\n"
"        }\n"
"        let s = String::from_utf8(bytes)\n"
"            .map_err(|_| io::Error::new(ErrorKind::InvalidData, \"not "
"UTF-8\"))?;\n"
"        Ok(Some(s))\n"
"    }\n"
"}\n"
"\n"
"async fn slow_copy(source: String, mut dest: DuplexStream) -> std::io::"
"Result<()> {\n"
"    for b in source.bytes() {\n"
"        dest.write_u8(b).await?;\n"
"        tokio::time::sleep(Duration::from_millis(10)).await\n"
"    }\n"
"    Ok(())\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> std::io::Result<()> {\n"
"    let (client, server) = tokio::io::duplex(5);\n"
"    let handle = tokio::spawn(slow_copy(\"hi\\nthere\\n\".to_owned(), "
"client));\n"
"\n"
"    let mut lines = LinesReader::new(server);\n"
"    let mut interval = tokio::time::interval(Duration::from_millis(60));\n"
"    loop {\n"
"        tokio::select! {\n"
"            _ = interval.tick() => println!(\"tick!\"),\n"
"            line = lines.next() => if let Some(l) = line? {\n"
"                print!(\"{}\", l)\n"
"            } else {\n"
"                break\n"
"            },\n"
"        }\n"
"    }\n"
"    handle.await.unwrap()?;\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/async/pitfalls/cancellation.md:72
msgid ""
"The compiler doesn't help with cancellation-safety. You need to read API "
"documentation and consider what state your `async fn` holds."
msgstr ""
"El compilador no ayuda con la seguridad de la cancelaci√≥n. Debes leer la "
"documentaci√≥n de la API y tener en cuenta el estado de tu `async fn`."

#: src/async/pitfalls/cancellation.md:75
msgid ""
"Unlike `panic` and `?`, cancellation is part of normal control flow (vs "
"error-handling)."
msgstr ""
"A diferencia de `panic` y `?`, la cancelaci√≥n forma parte del flujo de "
"control normal (en contraposici√≥n a la gesti√≥n de errores)."

#: src/async/pitfalls/cancellation.md:78
msgid "The example loses parts of the string."
msgstr "En el ejemplo se pierden partes de la cadena."

#: src/async/pitfalls/cancellation.md:80
msgid ""
"Whenever the `tick()` branch finishes first, `next()` and its `buf` are "
"dropped."
msgstr ""
"Cuando la rama `tick()` termina primero, se eliminan `next()` y su `buf`."

#: src/async/pitfalls/cancellation.md:82
msgid ""
"`LinesReader` can be made cancellation-safe by making `buf` part of the "
"struct:"
msgstr ""
"`LinesReader` se puede configurar para que no se cancele marcando `buf` como "
"parte del _struct_:"

#: src/async/pitfalls/cancellation.md:83
msgid ""
"```rust,compile_fail\n"
"struct LinesReader {\n"
"    stream: DuplexStream,\n"
"    bytes: Vec<u8>,\n"
"    buf: [u8; 1],\n"
"}\n"
"\n"
"impl LinesReader {\n"
"    fn new(stream: DuplexStream) -> Self {\n"
"        Self { stream, bytes: Vec::new(), buf: [0] }\n"
"    }\n"
"    async fn next(&mut self) -> io::Result<Option<String>> {\n"
"        // prefix buf and bytes with self.\n"
"        // ...\n"
"        let raw = std::mem::take(&mut self.bytes);\n"
"        let s = String::from_utf8(raw)\n"
"        // ...\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/async/pitfalls/cancellation.md:104
msgid ""
"[`Interval::tick`](https://docs.rs/tokio/latest/tokio/time/struct.Interval."
"html#method.tick) is cancellation-safe because it keeps track of whether a "
"tick has been 'delivered'."
msgstr ""
"[`Interval::tick`](https://docs.rs/tokio/latest/tokio/time/struct.Interval."
"html#method.tick) es a prueba de cancelaciones, ya que registra si una marca "
"se ha 'entregado'."

#: src/async/pitfalls/cancellation.md:107
msgid ""
"[`AsyncReadExt::read`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncReadExt.html#method.read) is cancellation-safe because it either "
"returns or doesn't read data."
msgstr ""
"[`AsyncReadExt::read`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncReadExt.html#method.read) es a prueba de cancelaciones porque o "
"devuelve los datos o no los lee."

#: src/async/pitfalls/cancellation.md:110
msgid ""
"[`AsyncBufReadExt::read_line`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncBufReadExt.html#method.read_line) is similar to the example and _isn't_ "
"cancellation-safe. See its documentation for details and alternatives."
msgstr ""
"[`AsyncBufReadExt::read_line`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncBufReadExt.html#method.read_line) es similar al ejemplo y _no est√°_ "
"configurado a prueba de cancelaciones. Consulta su documentaci√≥n para "
"obtener informaci√≥n detallada y alternativas."

#: src/exercises/concurrency/afternoon.md:3
msgid ""
"To practice your Async Rust skills, we have again two exercises for you:"
msgstr ""
"Para practicar tus habilidades con async de Rust, tenemos otros dos nuevos "
"ejercicios:"

#: src/exercises/concurrency/afternoon.md:5
msgid ""
"Dining philosophers: we already saw this problem in the morning. This time "
"you are going to implement it with Async Rust."
msgstr ""
"La cena de los fil√≥sofos: ya hemos visto este problema por la ma√±ana. Esta "
"vez vas a implementarlo con async de Rust."

#: src/exercises/concurrency/afternoon.md:8
msgid ""
"A Broadcast Chat Application: this is a larger project that allows you "
"experiment with more advanced Async Rust features."
msgstr ""
"Una aplicaci√≥n de chat de difusi√≥n: se trata de un proyecto m√°s grande que "
"te permite experimentar con caracter√≠sticas m√°s avanzadas de async de Rust."

#: src/exercises/concurrency/dining-philosophers-async.md:1
#: src/exercises/concurrency/solutions-afternoon.md:3
msgid "Dining Philosophers - Async"
msgstr "La Cena de Fil√≥sofos - Async"

#: src/exercises/concurrency/dining-philosophers-async.md:3
msgid ""
"See [dining philosophers](dining-philosophers.md) for a description of the "
"problem."
msgstr ""
"Consulta la descripci√≥n del problema en la secci√≥n sobre [la cena de "
"fil√≥sofos](dining-philosophers.md)."

#: src/exercises/concurrency/dining-philosophers-async.md:6
msgid ""
"As before, you will need a local [Cargo installation](../../cargo/running-"
"locally.md) for this exercise. Copy the code below to a file called `src/"
"main.rs`, fill out the blanks, and test that `cargo run` does not deadlock:"
msgstr ""
"Como antes, necesitar√°s una [instalaci√≥n local de Cargo](../../cargo/running-"
"locally.md) para realizar el ejercicio. Copia el fragmento de c√≥digo que "
"aparece m√°s abajo en un archivo denominado `src/main.rs`, rellena los "
"espacios en blanco y comprueba que `cargo run` no presenta interbloqueos:"

#: src/exercises/concurrency/dining-philosophers-async.md:13
msgid ""
"```rust,compile_fail\n"
"use std::sync::Arc;\n"
"use tokio::time;\n"
"use tokio::sync::mpsc::{self, Sender};\n"
"use tokio::sync::Mutex;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    // left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
"}\n"
"\n"
"impl Philosopher {\n"
"    async fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))."
"await\n"
"            .unwrap();\n"
"    }\n"
"\n"
"    async fn eat(&self) {\n"
"        // Pick up forks...\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    // Create forks\n"
"\n"
"    // Create philosophers\n"
"\n"
"    // Make them think and eat\n"
"\n"
"    // Output their thoughts\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:57
msgid ""
"Since this time you are using Async Rust, you'll need a `tokio` dependency. "
"You can use the following `Cargo.toml`:"
msgstr ""
"Dado que esta vez usas async, necesitar√°s una dependencia `tokio`. Puedes "
"usar el siguiente `Cargo.toml`:"

#: src/exercises/concurrency/dining-philosophers-async.md:62
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers-async-dine\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"tokio = {version = \"1.26.0\", features = [\"sync\", \"time\", \"macros\", "
"\"rt-multi-thread\"]}\n"
"```"
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:72
msgid ""
"Also note that this time you have to use the `Mutex` and the `mpsc` module "
"from the `tokio` crate."
msgstr ""
"Adem√°s, ten en cuenta que esta vez tienes que utilizar `Mutex` y el m√≥dulo "
"`mpsc` del crate `tokio`."

#: src/exercises/concurrency/dining-philosophers-async.md:77
msgid "Can you make your implementation single-threaded? "
msgstr "¬øPuedes conseguir que tu implementaci√≥n tenga un solo hilo? "

#: src/exercises/concurrency/chat-app.md:3
msgid ""
"In this exercise, we want to use our new knowledge to implement a broadcast "
"chat application. We have a chat server that the clients connect to and "
"publish their messages. The client reads user messages from the standard "
"input, and sends them to the server. The chat server broadcasts each message "
"that it receives to all the clients."
msgstr ""
"En este ejercicio, queremos usar nuestros nuevos conocimientos para "
"implementar una aplicaci√≥n de chat de difusi√≥n. Disponemos de un servidor de "
"chat al que los clientes se conectan y publican sus mensajes. El cliente lee "
"los mensajes de usuario de la entrada est√°ndar y los env√≠a al servidor. El "
"servidor del chat transmite cada mensaje que recibe a todos los clientes."

#: src/exercises/concurrency/chat-app.md:9
#, fuzzy
msgid ""
"For this, we use [a broadcast channel](https://docs.rs/tokio/latest/tokio/"
"sync/broadcast/fn.channel.html) on the server, and [`tokio_websockets`]"
"(https://docs.rs/tokio-websockets/0.4.0/tokio_websockets/) for the "
"communication between the client and the server."
msgstr ""
"Para ello, usaremos \\[un canal en abierto](https://docs.rs/tokio/latest/"
"tokio/sync/broadcast/fn.channel.html) en el servidor y [`tokio_websockets`]"
"(https://docs.rs/tokio-websockets/0.3.2/tokio_websockets/) para la "
"comunicaci√≥n entre el cliente y el servidor."

#: src/exercises/concurrency/chat-app.md:13
msgid "Create a new Cargo project and add the following dependencies:"
msgstr "Crea un proyecto de Cargo y a√±ade las siguientes dependencias:"

#: src/exercises/concurrency/chat-app.md:15
msgid "`Cargo.toml`:"
msgstr "`Cargo.toml`:"

#: src/exercises/concurrency/chat-app.md:19
#, fuzzy
msgid ""
"```toml\n"
"[package]\n"
"name = \"chat-async\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"futures-util = { version = \"0.3.28\", features = [\"sink\"] }\n"
"http = \"0.2.9\"\n"
"tokio = { version = \"1.28.1\", features = [\"full\"] }\n"
"tokio-websockets = { version = \"0.4.0\", features = [\"client\", "
"\"fastrand\", \"server\", \"sha1_smol\"] }\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"link-checker\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-"
"tls\"] }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"

#: src/exercises/concurrency/chat-app.md:32
msgid "The required APIs"
msgstr "Las APIs necesarias"

#: src/exercises/concurrency/chat-app.md:33
#, fuzzy
msgid ""
"You are going to need the following functions from `tokio` and "
"[`tokio_websockets`](https://docs.rs/tokio-websockets/0.4.0/"
"tokio_websockets/). Spend a few minutes to familiarize yourself with the "
"API. "
msgstr ""
"Necesitar√°s las siguientes funciones de `tokio` y [`tokio_websockets`]"
"(https://docs.rs/tokio-websockets/0.3.2/tokio_websockets/). Dedica unos "
"minutos a familiarizarte con la API. "

#: src/exercises/concurrency/chat-app.md:37
#, fuzzy
msgid ""
"[StreamExt::next()](https://docs.rs/futures-util/0.3.28/futures_util/stream/"
"trait.StreamExt.html#method.next) implemented by `WebsocketStream`: for "
"asynchronously reading messages from a Websocket Stream."
msgstr ""
"[SinkExt::send()](https://docs.rs/futures-util/0.3.28/futures_util/sink/"
"trait.SinkExt.html#method.send) implementado por `WebsocketStream`: permite "
"enviar mensajes de forma as√≠ncrona a trav√©s de un flujo WebSocket."

#: src/exercises/concurrency/chat-app.md:39
msgid ""
"[SinkExt::send()](https://docs.rs/futures-util/0.3.28/futures_util/sink/"
"trait.SinkExt.html#method.send) implemented by `WebsocketStream`: for "
"asynchronously sending messages on a Websocket Stream."
msgstr ""
"[SinkExt::send()](https://docs.rs/futures-util/0.3.28/futures_util/sink/"
"trait.SinkExt.html#method.send) implementado por `WebsocketStream`: permite "
"enviar mensajes de forma as√≠ncrona a trav√©s de un flujo WebSocket."

#: src/exercises/concurrency/chat-app.md:41
msgid ""
"[Lines::next_line()](https://docs.rs/tokio/latest/tokio/io/struct.Lines."
"html#method.next_line): for asynchronously reading user messages from the "
"standard input."
msgstr ""
"[Lines::next_line()](https://docs.rs/tokio/latest/tokio/io/struct.Lines."
"html#method.next_line): para la lectura as√≠ncrona de mensajes de usuario de "
"la entrada est√°ndar."

#: src/exercises/concurrency/chat-app.md:43
msgid ""
"[Sender::subscribe()](https://docs.rs/tokio/latest/tokio/sync/broadcast/"
"struct.Sender.html#method.subscribe): for subscribing to a broadcast channel."
msgstr ""
"[Sender::subscribe()](https://docs.rs/tokio/latest/tokio/sync/broadcast/"
"struct.Sender.html#method.subscribe): para suscribirse a un canal en abierto."

#: src/exercises/concurrency/chat-app.md:46
msgid "Two binaries"
msgstr "Dos binarios"

#: src/exercises/concurrency/chat-app.md:48
msgid ""
"Normally in a Cargo project, you can have only one binary, and one `src/main."
"rs` file. In this project, we need two binaries. One for the client, and one "
"for the server. You could potentially make them two separate Cargo projects, "
"but we are going to put them in a single Cargo project with two binaries. "
"For this to work, the client and the server code should go under `src/bin` "
"(see the [documentation](https://doc.rust-lang.org/cargo/reference/cargo-"
"targets.html#binaries)). "
msgstr ""
"Normalmente, en un proyecto de Cargo, solo puedes tener un archivo binario y "
"un archivo `src/main.rs`. En este proyecto, se necesitan dos binarios, uno "
"para el cliente y otro para el servidor. Puedes convertirlos en dos "
"proyectos de Cargo independientes, pero los incluiremos en un solo proyecto "
"de Cargo con dos binarios. Para que funcione, el c√≥digo del cliente y del "
"servidor deben aparecer en `src/bin` (consulta la [documentaci√≥n](https://"
"doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries)). "

#: src/exercises/concurrency/chat-app.md:55
msgid ""
"Copy the following server and client code into `src/bin/server.rs` and `src/"
"bin/client.rs`, respectively. Your task is to complete these files as "
"described below. "
msgstr ""
"Copia el fragmento de c√≥digo del servidor y del cliente que aparecen m√°s "
"abajo en `src/bin/server.rs` y `src/bin/client.rs`, respectivamente. Tu "
"tarea es completar estos archivos como se describe a continuaci√≥n. "

#: src/exercises/concurrency/chat-app.md:59
#: src/exercises/concurrency/solutions-afternoon.md:123
msgid "`src/bin/server.rs`:"
msgstr "`src/bin/server.rs`:"

#: src/exercises/concurrency/chat-app.md:63
msgid ""
"```rust,compile_fail\n"
"use futures_util::sink::SinkExt;\n"
"use futures_util::stream::StreamExt;\n"
"use std::error::Error;\n"
"use std::net::SocketAddr;\n"
"use tokio::net::{TcpListener, TcpStream};\n"
"use tokio::sync::broadcast::{channel, Sender};\n"
"use tokio_websockets::{Message, ServerBuilder, WebsocketStream};\n"
"\n"
"async fn handle_connection(\n"
"    addr: SocketAddr,\n"
"    mut ws_stream: WebsocketStream<TcpStream>,\n"
"    bcast_tx: Sender<String>,\n"
") -> Result<(), Box<dyn Error + Send + Sync>> {\n"
"\n"
"    // TODO: For a hint, see the description of the task below.\n"
"\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> Result<(), Box<dyn Error + Send + Sync>> {\n"
"    let (bcast_tx, _) = channel(16);\n"
"\n"
"    let listener = TcpListener::bind(\"127.0.0.1:2000\").await?;\n"
"    println!(\"listening on port 2000\");\n"
"\n"
"    loop {\n"
"        let (socket, addr) = listener.accept().await?;\n"
"        println!(\"New connection from {addr:?}\");\n"
"        let bcast_tx = bcast_tx.clone();\n"
"        tokio::spawn(async move {\n"
"            // Wrap the raw TCP stream into a websocket.\n"
"            let ws_stream = ServerBuilder::new().accept(socket).await?;\n"
"\n"
"            handle_connection(addr, ws_stream, bcast_tx).await\n"
"        });\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/chat-app.md:103
#: src/exercises/concurrency/solutions-afternoon.md:210
msgid "`src/bin/client.rs`:"
msgstr "`src/bin/client.rs`:"

#: src/exercises/concurrency/chat-app.md:107
msgid ""
"```rust,compile_fail\n"
"use futures_util::stream::StreamExt;\n"
"use futures_util::SinkExt;\n"
"use http::Uri;\n"
"use tokio::io::{AsyncBufReadExt, BufReader};\n"
"use tokio_websockets::{ClientBuilder, Message};\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> Result<(), tokio_websockets::Error> {\n"
"    let (mut ws_stream, _) =\n"
"        ClientBuilder::from_uri(Uri::from_static(\"ws://127.0.0.1:2000\"))\n"
"            .connect()\n"
"            .await?;\n"
"\n"
"    let stdin = tokio::io::stdin();\n"
"    let mut stdin = BufReader::new(stdin).lines();\n"
"\n"
"\n"
"    // TODO: For a hint, see the description of the task below.\n"
"\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/chat-app.md:130
msgid "Running the binaries"
msgstr "Ejecutar los binarios"

#: src/exercises/concurrency/chat-app.md:131
msgid "Run the server with:"
msgstr "Ejecuta el servidor con:"

#: src/exercises/concurrency/chat-app.md:133
msgid ""
"```shell\n"
"cargo run --bin server\n"
"```"
msgstr ""

#: src/exercises/concurrency/chat-app.md:137
msgid "and the client with:"
msgstr "y el cliente con:"

#: src/exercises/concurrency/chat-app.md:139
msgid ""
"```shell\n"
"cargo run --bin client\n"
"```"
msgstr ""

#: src/exercises/concurrency/chat-app.md:145
msgid "Implement the `handle_connection` function in `src/bin/server.rs`."
msgstr "Implementa la funci√≥n `handle_connection` en `src/bin/server.rs`."

#: src/exercises/concurrency/chat-app.md:146
msgid ""
"Hint: Use `tokio::select!` for concurrently performing two tasks in a "
"continuous loop. One task receives messages from the client and broadcasts "
"them. The other sends messages received by the server to the client."
msgstr ""
"Sugerencia: usa `tokio::select!` para realizar dos tareas simult√°neamente en "
"un bucle continuo. Una tarea recibe mensajes del cliente y los transmite. La "
"otra env√≠a los mensajes que recibe el servidor al cliente."

#: src/exercises/concurrency/chat-app.md:149
msgid "Complete the main function in `src/bin/client.rs`."
msgstr "Completa la funci√≥n principal en `src/bin/client.rs`."

#: src/exercises/concurrency/chat-app.md:150
msgid ""
"Hint: As before, use `tokio::select!` in a continuous loop for concurrently "
"performing two tasks: (1) reading user messages from standard input and "
"sending them to the server, and (2) receiving messages from the server, and "
"displaying them for the user."
msgstr ""
"Sugerencia: al igual que antes, usa `tokio::select!` en un bucle continuo "
"para realizar dos tareas simult√°neamente: (1) leer los mensajes del usuario "
"desde la entrada est√°ndar y enviarlos al servidor, y (2) recibir mensajes "
"del servidor y mostr√°rselos al usuario."

#: src/exercises/concurrency/chat-app.md:154
msgid ""
"Optional: Once you are done, change the code to broadcast messages to all "
"clients, but the sender of the message."
msgstr ""
"Opcional: cuando termines, cambia el c√≥digo para difundir mensajes a todos "
"los clientes, excepto al remitente."

#: src/thanks.md:3
msgid ""
"_Thank you for taking Comprehensive Rust ü¶Ä!_ We hope you enjoyed it and "
"that it was useful."
msgstr ""
"_Gracias por realizar el curso Comprehensive Rust ü¶Ä._ Esperamos que te haya "
"gustado y que te haya resultado √∫til."

#: src/thanks.md:6
msgid ""
"We've had a lot of fun putting the course together. The course is not "
"perfect, so if you spotted any mistakes or have ideas for improvements, "
"please get in [contact with us on GitHub](https://github.com/google/"
"comprehensive-rust/discussions). We would love to hear from you."
msgstr ""
"Nos lo hemos pasado muy bien preparando el curso. Sabemos que no es "
"perfecto, as√≠ que si has detectado alg√∫n error o tienes ideas para "
"mejorarlo, [ponte en contacto con nosotros en GitHub](https://github.com/"
"google/comprehensive-rust/discussions). Nos encantar√≠a saber tu opini√≥n."

#: src/other-resources.md:1
msgid "Other Rust Resources"
msgstr "Otros recursos de Rust"

#: src/other-resources.md:3
msgid ""
"The Rust community has created a wealth of high-quality and free resources "
"online."
msgstr ""
"La comunidad de Rust ha creado una gran cantidad de recursos online sin "
"coste y de gran calidad."

#: src/other-resources.md:6
msgid "Official Documentation"
msgstr "Documentaci√≥n oficial"

#: src/other-resources.md:8
msgid "The Rust project hosts many resources. These cover Rust in general:"
msgstr ""
"El proyecto Rust cuenta con muchos recursos. Estos tratan sobre Rust en "
"general:"

#: src/other-resources.md:10
msgid ""
"[The Rust Programming Language](https://doc.rust-lang.org/book/): the "
"canonical free book about Rust. Covers the language in detail and includes a "
"few projects for people to build."
msgstr ""
"[The Rust Programming Language](https://doc.rust-lang.org/book/): el libro "
"can√≥nico sobre Rust sin coste alguno. Trata el lenguaje de forma detallada e "
"incluye algunos proyectos que los usuarios pueden compilar."

#: src/other-resources.md:13
msgid ""
"[Rust By Example](https://doc.rust-lang.org/rust-by-example/): covers the "
"Rust syntax via a series of examples which showcase different constructs. "
"Sometimes includes small exercises where you are asked to expand on the code "
"in the examples."
msgstr ""
"[Rust by Example](https://doc.rust-lang.org/rust-by-example/): trata la "
"sintaxis de Rust a trav√©s de una serie de ejemplos que muestran distintas "
"construcciones. A veces incluye peque√±os ejercicios en los que se te pide "
"que ampl√≠es el c√≥digo de los ejemplos."

#: src/other-resources.md:17
msgid ""
"[Rust Standard Library](https://doc.rust-lang.org/std/): full documentation "
"of the standard library for Rust."
msgstr ""
"\\[La biblioteca est√°ndar de Rust\\][Rust Standard Library](https://doc.rust-"
"lang.org/std/): documentaci√≥n completa de la biblioteca est√°ndar de Rust."

#: src/other-resources.md:19
msgid ""
"[The Rust Reference](https://doc.rust-lang.org/reference/): an incomplete "
"book which describes the Rust grammar and memory model."
msgstr ""
"[The Rust Reference](https://doc.rust-lang.org/reference/): un libro "
"incompleto que describe la gram√°tica y el modelo de memoria de Rust."

#: src/other-resources.md:22
msgid "More specialized guides hosted on the official Rust site:"
msgstr "Consulta gu√≠as m√°s especializadas en el sitio oficial de Rust:"

#: src/other-resources.md:24
msgid ""
"[The Rustonomicon](https://doc.rust-lang.org/nomicon/): covers unsafe Rust, "
"including working with raw pointers and interfacing with other languages "
"(FFI)."
msgstr ""
"[The Rustonomicon](https://doc.rust-lang.org/nomicon/): trata de Rust "
"inseguro, incluido c√≥mo trabajar con punteros sin formato e interactuar con "
"otros lenguajes (FFI)."

#: src/other-resources.md:27
msgid ""
"[Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/): "
"covers the new asynchronous programming model which was introduced after the "
"Rust Book was written."
msgstr ""
"[Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/): "
"incluye el nuevo modelo de programaci√≥n as√≠ncrona que se introdujo despu√©s "
"de que se escribiera el libro de Rust."

#: src/other-resources.md:30
msgid ""
"[The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): "
"an introduction to using Rust on embedded devices without an operating "
"system."
msgstr ""
"[The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): "
"una introducci√≥n sobre el uso de Rust en dispositivos integrados sin sistema "
"operativo."

#: src/other-resources.md:33
msgid "Unofficial Learning Material"
msgstr "Material de formaci√≥n no oficial"

#: src/other-resources.md:35
msgid "A small selection of other guides and tutorial for Rust:"
msgstr "Una peque√±a selecci√≥n de otras gu√≠as y tutoriales sobre Rust:"

#: src/other-resources.md:37
msgid ""
"[Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): covers Rust "
"from the perspective of low-level C programmers."
msgstr ""
"[Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): trata Rust "
"desde la perspectiva de los programadores de C de bajo nivel."

#: src/other-resources.md:39
msgid ""
"[Rust for Embedded C Programmers](https://docs.opentitan.org/doc/ug/"
"rust_for_c/): covers Rust from the perspective of developers who write "
"firmware in C."
msgstr ""
"[Rust for Embedded C Programmers](https://docs.opentitan.org/doc/ug/"
"rust_for_c/): explica Rust desde la perspectiva de los desarrolladores que "
"escriben _firmware_ en C."

#: src/other-resources.md:42
msgid ""
"[Rust for professionals](https://overexact.com/rust-for-professionals/): "
"covers the syntax of Rust using side-by-side comparisons with other "
"languages such as C, C++, Java, JavaScript, and Python."
msgstr ""
"[Rust for professonals](https://overexact.com/rust-for-professionals/): "
"trata la sintaxis de Rust compar√°ndola con otros lenguajes, como C, C++, "
"Java, JavaScript y Python."

#: src/other-resources.md:45
msgid ""
"[Rust on Exercism](https://exercism.org/tracks/rust): 100+ exercises to help "
"you learn Rust."
msgstr ""
"[Rust on Exercism](https://exercism.org/tracks/rust): m√°s de 100 ejercicios "
"para aprender Rust."

#: src/other-resources.md:47
msgid ""
"[Ferrous Teaching Material](https://ferrous-systems.github.io/teaching-"
"material/index.html): a series of small presentations covering both basic "
"and advanced part of the Rust language. Other topics such as WebAssembly, "
"and async/await are also covered."
msgstr ""
"[Ferrous Teaching Material](https://ferrous-systems.github.io/teaching-"
"material/index.html): una serie de peque√±as presentaciones que cubren tanto "
"la parte b√°sica como la parte m√°s avanzada del lenguaje Rust. Tambi√©n se "
"tratan otros temas como WebAssembly y async/await."

#: src/other-resources.md:52
msgid ""
"[Beginner's Series to Rust](https://docs.microsoft.com/en-us/shows/beginners-"
"series-to-rust/) and [Take your first steps with Rust](https://docs."
"microsoft.com/en-us/learn/paths/rust-first-steps/): two Rust guides aimed at "
"new developers. The first is a set of 35 videos and the second is a set of "
"11 modules which covers Rust syntax and basic constructs."
msgstr ""
"[Beginner's Series to Rust](https://docs.microsoft.com/es/shows/beginners-"
"series-to-rust/) y [Take your first steps with Rust](https://docs.microsoft."
"com/es/learn/paths/rust-first-steps/): dos gu√≠as de Rust dirigidas a nuevos "
"desarrolladores. La primera es un conjunto de 35 v√≠deos y la segunda es un "
"conjunto de 11 m√≥dulos que cubren la sintaxis y las construcciones b√°sicas "
"de Rust."

#: src/other-resources.md:58
msgid ""
"[Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial."
"github.io/too-many-lists/): in-depth exploration of Rust's memory management "
"rules, through implementing a few different types of list structures."
msgstr ""
"[Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial."
"github.io/too-many-lists/): exploraci√≥n detallada de las reglas de gesti√≥n "
"de la memoria de Rust a trav√©s de la implementaci√≥n de algunos tipos "
"diferentes de estructuras de listas."

#: src/other-resources.md:63
msgid ""
"Please see the [Little Book of Rust Books](https://lborb.github.io/book/) "
"for even more Rust books."
msgstr ""
"Consulta [The Little Book of Rust Books](https://lborb.github.io/book/) para "
"ver m√°s libros de Rust."

#: src/credits.md:3
msgid ""
"The material here builds on top of the many great sources of Rust "
"documentation. See the page on [other resources](other-resources.md) for a "
"full list of useful resources."
msgstr ""
"Este material se basa en las numerosas fuentes de documentaci√≥n sobre Rust. "
"Consulta la p√°gina de [otros recursos](other-resources.md) para ver una "
"lista completa de recursos √∫tiles."

#: src/credits.md:7
msgid ""
"The material of Comprehensive Rust is licensed under the terms of the Apache "
"2.0 license, please see [`LICENSE`](https://github.com/google/comprehensive-"
"rust/blob/main/LICENSE) for details."
msgstr ""
"El material de Comprehensive Rust est√° sujeto a los t√©rminos de la licencia "
"Apache 2.0. Para obtener m√°s informaci√≥n, consulta [`LICENSE`](https://"
"github.com/google/comprehensive-rust/blob/main/LICENSE)."

#: src/credits.md:12
msgid "Rust by Example"
msgstr "Rust by Example"

#: src/credits.md:14
msgid ""
"Some examples and exercises have been copied and adapted from [Rust by "
"Example](https://doc.rust-lang.org/rust-by-example/). Please see the "
"`third_party/rust-by-example/` directory for details, including the license "
"terms."
msgstr ""
"Algunos ejemplos y ejercicios se han copiado y adaptado del libro [Rust by "
"Example](https://doc.rust-lang.org/rust-by-example/). Consulta el directorio "
"`third_party/rust-by-example/` para obtener m√°s informaci√≥n, incluidos los "
"t√©rminos de la licencia."

#: src/credits.md:19
msgid "Rust on Exercism"
msgstr "Rust on Exercism"

#: src/credits.md:21
msgid ""
"Some exercises have been copied and adapted from [Rust on Exercism](https://"
"exercism.org/tracks/rust). Please see the `third_party/rust-on-exercism/` "
"directory for details, including the license terms."
msgstr ""
"Se han copiado y adaptado algunos ejercicios del recurso [Rust on Exercism]"
"(https://exercism.org/tracks/rust). Consulta el directorio `third_party/rust-"
"on-exercism/` para obtener m√°s informaci√≥n, incluidos los t√©rminos de la "
"licencia."

#: src/credits.md:26
msgid "CXX"
msgstr "CXX"

#: src/credits.md:28
msgid ""
"The [Interoperability with C++](android/interoperability/cpp.md) section "
"uses an image from [CXX](https://cxx.rs/). Please see the `third_party/cxx/` "
"directory for details, including the license terms."
msgstr ""
"En la secci√≥n [Interoperabilidad con C++](android/Interop/cpp.md) se usa una "
"imagen de [CXX](https://cxx.rs/). Consulta el directorio `third_party/cxx/` "
"para obtener m√°s informaci√≥n, incluidos los t√©rminos de la licencia."

#: src/exercises/solutions.md:3
msgid "You will find solutions to the exercises on the following pages."
msgstr "En las p√°ginas siguientes encontrar√°s las soluciones a los ejercicios."

#: src/exercises/solutions.md:5
msgid ""
"Feel free to ask questions about the solutions [on GitHub](https://github."
"com/google/comprehensive-rust/discussions). Let us know if you have a "
"different or better solution than what is presented here."
msgstr ""
"No dudes en hacer preguntas sobre las soluciones [en GitHub](https://github."
"com/google/comprehensive-rust/discussions). Ponte en contacto con nosotros "
"si tienes una soluci√≥n distinta o mejor de la que se presenta aqu√≠."

#: src/exercises/solutions.md:10
msgid ""
"**Note:** Please ignore the `// ANCHOR: label` and `// ANCHOR_END: label` "
"comments you see in the solutions. They are there to make it possible to re-"
"use parts of the solutions as the exercises."
msgstr ""
"**Nota:** Ignora los comentarios `// ANCHOR: label` y `// ANCHOR_END: label` "
"que aparecen en las soluciones. Est√°n ah√≠ para que sea posible reutilizar "
"algunas partes de las soluciones de los ejercicios."

#: src/exercises/day-1/solutions-morning.md:1
msgid "Day 1 Morning Exercises"
msgstr "D√≠a 1: Ejercicios de la Ma√±ana"

#: src/exercises/day-1/solutions-morning.md:5
msgid "([back to exercise](for-loops.md))"
msgstr "([Volver al ejercicio](for-loops.md))"

#: src/exercises/day-1/solutions-morning.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: transpose\n"
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    // ANCHOR_END: transpose\n"
"    let mut result = [[0; 3]; 3];\n"
"    for i in 0..3 {\n"
"        for j in 0..3 {\n"
"            result[j][i] = matrix[i][j];\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n"
"// ANCHOR: pretty_print\n"
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    // ANCHOR_END: pretty_print\n"
"    for row in matrix {\n"
"        println!(\"{row:?}\");\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: tests\n"
"#[test]\n"
"fn test_transpose() {\n"
"    let matrix = [\n"
"        [101, 102, 103], //\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"    let transposed = transpose(matrix);\n"
"    assert_eq!(\n"
"        transposed,\n"
"        [\n"
"            [101, 201, 301], //\n"
"            [102, 202, 302],\n"
"            [103, 203, 303],\n"
"        ]\n"
"    );\n"
"}\n"
"// ANCHOR_END: tests\n"
"\n"
"// ANCHOR: main\n"
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"\n"
"    println!(\"matrix:\");\n"
"    pretty_print(&matrix);\n"
"\n"
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:78
msgid "Bonus question"
msgstr "Pregunta extra"

#: src/exercises/day-1/solutions-morning.md:80
msgid ""
"It requires more advanced concepts. It might seem that we could use a slice-"
"of-slices (`&[&[i32]]`) as the input type to transpose and thus make our "
"function handle any size of matrix. However, this quickly breaks down: the "
"return type cannot be `&[&[i32]]` since it needs to own the data you return."
msgstr ""
"Requiere conceptos m√°s avanzados. Es posible que parezca que se puede "
"utilizar un slice de slices (`&[&[i32]]`) como tipo de entrada para hacer "
"una trasposici√≥n y as√≠ lograr que nuestra funci√≥n controle cualquier tama√±o "
"de matriz. Sin embargo, esto se viene abajo r√°pidamente: el tipo de "
"resultado devuelto no puede ser `&[&[i32]]`, ya que necesita ser el "
"propietario de los datos que devuelve."

#: src/exercises/day-1/solutions-morning.md:82
msgid ""
"You can attempt to use something like `Vec<Vec<i32>>`, but this doesn't work "
"out-of-the-box either: it's hard to convert from `Vec<Vec<i32>>` to "
"`&[&[i32]]` so now you cannot easily use `pretty_print` either."
msgstr ""
"Puedes probar a utilizar algo como `Vec<Vec<i32>>`, pero esto tampoco "
"funciona desde el principio: es dif√≠cil cambiar de `Vec<Vec<i32>>` a "
"`&[&[i32]]`, por lo que tampoco puedes usar `pretty_print` de forma sencilla."

#: src/exercises/day-1/solutions-morning.md:84
msgid ""
"Once we get to traits and generics, we'll be able to use the [`std::convert::"
"AsRef`](https://doc.rust-lang.org/std/convert/trait.AsRef.html) trait to "
"abstract over anything that can be referenced as a slice."
msgstr ""
"Una vez que veamos los traits y los gen√©ricos, podremos usar el trait [`std::"
"convert::AsRef`](https://doc.rust-lang.org/std/convert/trait.AsRef.html) "
"para abstraer cualquier elemento que se pueda referenciar, como un slice."

#: src/exercises/day-1/solutions-morning.md:86
msgid ""
"```rust\n"
"use std::convert::AsRef;\n"
"use std::fmt::Debug;\n"
"\n"
"fn pretty_print<T, Line, Matrix>(matrix: Matrix)\n"
"where\n"
"    T: Debug,\n"
"    // A line references a slice of items\n"
"    Line: AsRef<[T]>,\n"
"    // A matrix references a slice of lines\n"
"    Matrix: AsRef<[Line]>\n"
"{\n"
"    for row in matrix.as_ref() {\n"
"        println!(\"{:?}\", row.as_ref());\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    // &[&[i32]]\n"
"    pretty_print(&[&[1, 2, 3], &[4, 5, 6], &[7, 8, 9]]);\n"
"    // [[&str; 2]; 2]\n"
"    pretty_print([[\"a\", \"b\"], [\"c\", \"d\"]]);\n"
"    // Vec<Vec<i32>>\n"
"    pretty_print(vec![vec![1, 2], vec![3, 4]]);\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:113
msgid ""
"In addition, the type itself would not enforce that the child slices are of "
"the same length, so such variable could contain an invalid matrix."
msgstr ""
"Adem√°s, el propio tipo no requerir√≠a que los slices secundarios fueran de la "
"misma longitud, por lo que dicha variable podr√≠a contener una matriz no "
"v√°lida."

#: src/exercises/day-1/solutions-afternoon.md:1
msgid "Day 1 Afternoon Exercises"
msgstr "D√≠a 1: Ejercicios de la Tarde"

#: src/exercises/day-1/solutions-afternoon.md:5
msgid "([back to exercise](luhn.md))"
msgstr "([volver al ejercicio](luhn.md))"

#: src/exercises/day-1/solutions-afternoon.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: luhn\n"
"pub fn luhn(cc_number: &str) -> bool {\n"
"    // ANCHOR_END: luhn\n"
"    let mut digits_seen = 0;\n"
"    let mut sum = 0;\n"
"    for (i, ch) in cc_number.chars().rev().filter(|&ch| ch != ' ')."
"enumerate() {\n"
"        match ch.to_digit(10) {\n"
"            Some(d) => {\n"
"                sum += if i % 2 == 1 {\n"
"                    let dd = d * 2;\n"
"                    dd / 10 + dd % 10\n"
"                } else {\n"
"                    d\n"
"                };\n"
"                digits_seen += 1;\n"
"            }\n"
"            None => return false,\n"
"        }\n"
"    }\n"
"\n"
"    if digits_seen < 2 {\n"
"        return false;\n"
"    }\n"
"\n"
"    sum % 10 == 0\n"
"}\n"
"\n"
"fn main() {\n"
"    let cc_number = \"1234 5678 1234 5670\";\n"
"    println!(\n"
"        \"Is {cc_number} a valid credit card number? {}\",\n"
"        if luhn(cc_number) { \"yes\" } else { \"no\" }\n"
"    );\n"
"}\n"
"\n"
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\"));\n"
"    assert!(!luhn(\"foo 0 0\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_empty_cc_number() {\n"
"    assert!(!luhn(\"\"));\n"
"    assert!(!luhn(\" \"));\n"
"    assert!(!luhn(\"  \"));\n"
"    assert!(!luhn(\"    \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_single_digit_cc_number() {\n"
"    assert!(!luhn(\"0\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_two_digit_cc_number() {\n"
"    assert!(luhn(\" 0 0 \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_valid_cc_number() {\n"
"    assert!(luhn(\"4263 9826 4026 9299\"));\n"
"    assert!(luhn(\"4539 3195 0343 6467\"));\n"
"    assert!(luhn(\"7992 7398 713\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_invalid_cc_number() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}\n"
"// ANCHOR_END: unit-tests\n"
"```"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:98
msgid "Pattern matching"
msgstr "Correspondencia de Patrones"

#: src/exercises/day-1/solutions-afternoon.md:100
msgid "TBD."
msgstr ""

#: src/exercises/day-2/solutions-morning.md:1
msgid "Day 2 Morning Exercises"
msgstr "D√≠a 2: Ejercicios de la Ma√±ana"

#: src/exercises/day-2/solutions-morning.md:3
msgid "Designing a Library"
msgstr "Dise√±ando una Librer√≠a"

#: src/exercises/day-2/solutions-morning.md:5
msgid "([back to exercise](book-library.md))"
msgstr "([volver al ejercicio](book-library.md))"

#: src/exercises/day-2/solutions-morning.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: setup\n"
"struct Library {\n"
"    books: Vec<Book>,\n"
"}\n"
"\n"
"struct Book {\n"
"    title: String,\n"
"    year: u16,\n"
"}\n"
"\n"
"impl Book {\n"
"    // This is a constructor, used below.\n"
"    fn new(title: &str, year: u16) -> Book {\n"
"        Book {\n"
"            title: String::from(title),\n"
"            year,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Implement the methods below. Update the `self` parameter to\n"
"// indicate the method's required level of ownership over the object:\n"
"//\n"
"// - `&self` for shared read-only access,\n"
"// - `&mut self` for unique and mutable access,\n"
"// - `self` for unique access by value.\n"
"impl Library {\n"
"    // ANCHOR_END: setup\n"
"\n"
"    // ANCHOR: Library_new\n"
"    fn new() -> Library {\n"
"        // ANCHOR_END: Library_new\n"
"        Library { books: Vec::new() }\n"
"    }\n"
"\n"
"    // ANCHOR: Library_len\n"
"    //fn len(self) -> usize {\n"
"    //    todo!(\"Return the length of `self.books`\")\n"
"    //}\n"
"    // ANCHOR_END: Library_len\n"
"    fn len(&self) -> usize {\n"
"        self.books.len()\n"
"    }\n"
"\n"
"    // ANCHOR: Library_is_empty\n"
"    //fn is_empty(self) -> bool {\n"
"    //    todo!(\"Return `true` if `self.books` is empty\")\n"
"    //}\n"
"    // ANCHOR_END: Library_is_empty\n"
"    fn is_empty(&self) -> bool {\n"
"        self.books.is_empty()\n"
"    }\n"
"\n"
"    // ANCHOR: Library_add_book\n"
"    //fn add_book(self, book: Book) {\n"
"    //    todo!(\"Add a new book to `self.books`\")\n"
"    //}\n"
"    // ANCHOR_END: Library_add_book\n"
"    fn add_book(&mut self, book: Book) {\n"
"        self.books.push(book)\n"
"    }\n"
"\n"
"    // ANCHOR: Library_print_books\n"
"    //fn print_books(self) {\n"
"    //    todo!(\"Iterate over `self.books` and each book's title and "
"year\")\n"
"    //}\n"
"    // ANCHOR_END: Library_print_books\n"
"    fn print_books(&self) {\n"
"        for book in &self.books {\n"
"            println!(\"{}, published in {}\", book.title, book.year);\n"
"        }\n"
"    }\n"
"\n"
"    // ANCHOR: Library_oldest_book\n"
"    //fn oldest_book(self) -> Option<&Book> {\n"
"    //    todo!(\"Return a reference to the oldest book (if any)\")\n"
"    //}\n"
"    // ANCHOR_END: Library_oldest_book\n"
"    fn oldest_book(&self) -> Option<&Book> {\n"
"        // Using a closure and a built-in method:\n"
"        // self.books.iter().min_by_key(|book| book.year)\n"
"\n"
"        // Longer hand-written solution:\n"
"        let mut oldest: Option<&Book> = None;\n"
"        for book in self.books.iter() {\n"
"            if oldest.is_none() || book.year < oldest.unwrap().year {\n"
"                oldest = Some(book);\n"
"            }\n"
"        }\n"
"\n"
"        oldest\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: main\n"
"// This shows the desired behavior. Uncomment the code below and\n"
"// implement the missing methods. You will need to update the\n"
"// method signatures, including the \"self\" parameter! You may\n"
"// also need to update the variable bindings within main.\n"
"fn main() {\n"
"    let library = Library::new();\n"
"\n"
"    //println!(\"The library is empty: library.is_empty() -> {}\", library."
"is_empty());\n"
"    //\n"
"    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    //\n"
"    //println!(\"The library is no longer empty: library.is_empty() -> {}\", "
"library.is_empty());\n"
"    //\n"
"    //\n"
"    //library.print_books();\n"
"    //\n"
"    //match library.oldest_book() {\n"
"    //    Some(book) => println!(\"The oldest book is {}\", book.title),\n"
"    //    None => println!(\"The library is empty!\"),\n"
"    //}\n"
"    //\n"
"    //println!(\"The library has {} books\", library.len());\n"
"    //library.print_books();\n"
"}\n"
"// ANCHOR_END: main\n"
"\n"
"#[test]\n"
"fn test_library_len() {\n"
"    let mut library = Library::new();\n"
"    assert_eq!(library.len(), 0);\n"
"    assert!(library.is_empty());\n"
"\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    assert_eq!(library.len(), 2);\n"
"    assert!(!library.is_empty());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_library_is_empty() {\n"
"    let mut library = Library::new();\n"
"    assert!(library.is_empty());\n"
"\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    assert!(!library.is_empty());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_library_print_books() {\n"
"    let mut library = Library::new();\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    // We could try and capture stdout, but let us just call the\n"
"    // method to start with.\n"
"    library.print_books();\n"
"}\n"
"\n"
"#[test]\n"
"fn test_library_oldest_book() {\n"
"    let mut library = Library::new();\n"
"    assert!(library.oldest_book().is_none());\n"
"\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    assert_eq!(\n"
"        library.oldest_book().map(|b| b.title.as_str()),\n"
"        Some(\"Lord of the Rings\")\n"
"    );\n"
"\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    assert_eq!(\n"
"        library.oldest_book().map(|b| b.title.as_str()),\n"
"        Some(\"Alice's Adventures in Wonderland\")\n"
"    );\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:1
msgid "Day 2 Afternoon Exercises"
msgstr "D√≠a 2: Ejercicios de la tarde"

#: src/exercises/day-2/solutions-afternoon.md:5
msgid "([back to exercise](strings-iterators.md))"
msgstr "([volver al ejercicio](strings-iterators.md))"

#: src/exercises/day-2/solutions-afternoon.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: prefix_matches\n"
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    // ANCHOR_END: prefix_matches\n"
"\n"
"    let mut request_segments = request_path.split('/');\n"
"\n"
"    for prefix_segment in prefix.split('/') {\n"
"        let Some(request_segment) = request_segments.next() else {\n"
"            return false;\n"
"        };\n"
"        if request_segment != prefix_segment && prefix_segment != \"*\" {\n"
"            return false;\n"
"        }\n"
"    }\n"
"    true\n"
"\n"
"    // Alternatively, Iterator::zip() lets us iterate simultaneously over "
"prefix\n"
"    // and request segments. The zip() iterator is finished as soon as one "
"of\n"
"    // the source iterators is finished, but we need to iterate over all "
"request\n"
"    // segments. A neat trick that makes zip() work is to use map() and "
"chain()\n"
"    // to produce an iterator that returns Some(str) for each pattern "
"segments,\n"
"    // and then returns None indefinitely.\n"
"}\n"
"\n"
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/"
"abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/"
"books\"));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/publishersBooks\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/parent/"
"publishers\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_matches_with_wildcard() {\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/bar/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books/book1\"\n"
"    ));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/"
"publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"// ANCHOR_END: unit-tests\n"
"\n"
"fn main() {}\n"
"```"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:1
msgid "Day 3 Morning Exercise"
msgstr "D√≠a 3: Ejercicios de la ma√±ana"

#: src/exercises/day-3/solutions-morning.md:5
msgid "([back to exercise](simple-gui.md))"
msgstr "([volver al ejercicio](simple-gui.md))"

#: src/exercises/day-3/solutions-morning.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: setup\n"
"pub trait Widget {\n"
"    /// Natural width of `self`.\n"
"    fn width(&self) -> usize;\n"
"\n"
"    /// Draw the widget into a buffer.\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);\n"
"\n"
"    /// Draw the widget on standard output.\n"
"    fn draw(&self) {\n"
"        let mut buffer = String::new();\n"
"        self.draw_into(&mut buffer);\n"
"        println!(\"{buffer}\");\n"
"    }\n"
"}\n"
"\n"
"pub struct Label {\n"
"    label: String,\n"
"}\n"
"\n"
"impl Label {\n"
"    fn new(label: &str) -> Label {\n"
"        Label {\n"
"            label: label.to_owned(),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Button {\n"
"    label: Label,\n"
"    callback: Box<dyn FnMut()>,\n"
"}\n"
"\n"
"impl Button {\n"
"    fn new(label: &str, callback: Box<dyn FnMut()>) -> Button {\n"
"        Button {\n"
"            label: Label::new(label),\n"
"            callback,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Window {\n"
"    title: String,\n"
"    widgets: Vec<Box<dyn Widget>>,\n"
"}\n"
"\n"
"impl Window {\n"
"    fn new(title: &str) -> Window {\n"
"        Window {\n"
"            title: title.to_owned(),\n"
"            widgets: Vec::new(),\n"
"        }\n"
"    }\n"
"\n"
"    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
"        self.widgets.push(widget);\n"
"    }\n"
"\n"
"    fn inner_width(&self) -> usize {\n"
"        std::cmp::max(\n"
"            self.title.chars().count(),\n"
"            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
"        )\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR_END: setup\n"
"\n"
"// ANCHOR: Window-width\n"
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Window-width\n"
"        // Add 4 paddings for borders\n"
"        self.inner_width() + 4\n"
"    }\n"
"\n"
"    // ANCHOR: Window-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Window-draw_into\n"
"        let mut inner = String::new();\n"
"        for widget in &self.widgets {\n"
"            widget.draw_into(&mut inner);\n"
"        }\n"
"\n"
"        let inner_width = self.inner_width();\n"
"\n"
"        // TODO: after learning about error handling, you can change\n"
"        // draw_into to return Result<(), std::fmt::Error>. Then use\n"
"        // the ?-operator here instead of .unwrap().\n"
"        writeln!(buffer, \"+-{:-<inner_width$}-+\", \"\").unwrap();\n"
"        writeln!(buffer, \"| {:^inner_width$} |\", &self.title).unwrap();\n"
"        writeln!(buffer, \"+={:=<inner_width$}=+\", \"\").unwrap();\n"
"        for line in inner.lines() {\n"
"            writeln!(buffer, \"| {:inner_width$} |\", line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+-{:-<inner_width$}-+\", \"\").unwrap();\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Button-width\n"
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Button-width\n"
"        self.label.width() + 8 // add a bit of padding\n"
"    }\n"
"\n"
"    // ANCHOR: Button-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Button-draw_into\n"
"        let width = self.width();\n"
"        let mut label = String::new();\n"
"        self.label.draw_into(&mut label);\n"
"\n"
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"        for line in label.lines() {\n"
"            writeln!(buffer, \"|{:^width$}|\", &line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Label-width\n"
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Label-width\n"
"        self.label\n"
"            .lines()\n"
"            .map(|line| line.chars().count())\n"
"            .max()\n"
"            .unwrap_or(0)\n"
"    }\n"
"\n"
"    // ANCHOR: Label-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Label-draw_into\n"
"        writeln!(buffer, \"{}\", &self.label).unwrap();\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: main\n"
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"This is a small text GUI demo."
"\")));\n"
"    window.add_widget(Box::new(Button::new(\n"
"        \"Click me!\",\n"
"        Box::new(|| println!(\"You clicked the button!\")),\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"// ANCHOR_END: main\n"
"```"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:177
msgid "([back to exercise](points-polygons.md))"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:179
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n"
"// ANCHOR: Point\n"
"pub struct Point {\n"
"    // ANCHOR_END: Point\n"
"    x: i32,\n"
"    y: i32,\n"
"}\n"
"\n"
"// ANCHOR: Point-impl\n"
"impl Point {\n"
"    // ANCHOR_END: Point-impl\n"
"    pub fn new(x: i32, y: i32) -> Point {\n"
"        Point { x, y }\n"
"    }\n"
"\n"
"    pub fn magnitude(self) -> f64 {\n"
"        f64::from(self.x.pow(2) + self.y.pow(2)).sqrt()\n"
"    }\n"
"\n"
"    pub fn dist(self, other: Point) -> f64 {\n"
"        (self - other).magnitude()\n"
"    }\n"
"}\n"
"\n"
"impl std::ops::Add for Point {\n"
"    type Output = Self;\n"
"\n"
"    fn add(self, other: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x + other.x,\n"
"            y: self.y + other.y,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl std::ops::Sub for Point {\n"
"    type Output = Self;\n"
"\n"
"    fn sub(self, other: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x - other.x,\n"
"            y: self.y - other.y,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Polygon\n"
"pub struct Polygon {\n"
"    // ANCHOR_END: Polygon\n"
"    points: Vec<Point>,\n"
"}\n"
"\n"
"// ANCHOR: Polygon-impl\n"
"impl Polygon {\n"
"    // ANCHOR_END: Polygon-impl\n"
"    pub fn new() -> Polygon {\n"
"        Polygon { points: Vec::new() }\n"
"    }\n"
"\n"
"    pub fn add_point(&mut self, point: Point) {\n"
"        self.points.push(point);\n"
"    }\n"
"\n"
"    pub fn left_most_point(&self) -> Option<Point> {\n"
"        self.points.iter().min_by_key(|p| p.x).copied()\n"
"    }\n"
"\n"
"    pub fn iter(&self) -> impl Iterator<Item = &Point> {\n"
"        self.points.iter()\n"
"    }\n"
"\n"
"    pub fn length(&self) -> f64 {\n"
"        if self.points.is_empty() {\n"
"            return 0.0;\n"
"        }\n"
"\n"
"        let mut result = 0.0;\n"
"        let mut last_point = self.points[0];\n"
"        for point in &self.points[1..] {\n"
"            result += last_point.dist(*point);\n"
"            last_point = *point;\n"
"        }\n"
"        result += last_point.dist(self.points[0]);\n"
"        result\n"
"        // Alternatively, Iterator::zip() lets us iterate over the points as "
"pairs\n"
"        // but we need to pair each point with the next one, and the last "
"point\n"
"        // with the first point. The zip() iterator is finished as soon as "
"one of \n"
"        // the source iterators is finished, a neat trick is to combine "
"Iterator::cycle\n"
"        // with Iterator::skip to create the second iterator for the zip and "
"using map \n"
"        // and sum to calculate the total length.\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Circle\n"
"pub struct Circle {\n"
"    // ANCHOR_END: Circle\n"
"    center: Point,\n"
"    radius: i32,\n"
"}\n"
"\n"
"// ANCHOR: Circle-impl\n"
"impl Circle {\n"
"    // ANCHOR_END: Circle-impl\n"
"    pub fn new(center: Point, radius: i32) -> Circle {\n"
"        Circle { center, radius }\n"
"    }\n"
"\n"
"    pub fn circumference(&self) -> f64 {\n"
"        2.0 * std::f64::consts::PI * f64::from(self.radius)\n"
"    }\n"
"\n"
"    pub fn dist(&self, other: &Self) -> f64 {\n"
"        self.center.dist(other.center)\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Shape\n"
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}\n"
"// ANCHOR_END: Shape\n"
"\n"
"impl From<Polygon> for Shape {\n"
"    fn from(poly: Polygon) -> Self {\n"
"        Shape::Polygon(poly)\n"
"    }\n"
"}\n"
"\n"
"impl From<Circle> for Shape {\n"
"    fn from(circle: Circle) -> Self {\n"
"        Shape::Circle(circle)\n"
"    }\n"
"}\n"
"\n"
"impl Shape {\n"
"    pub fn perimeter(&self) -> f64 {\n"
"        match self {\n"
"            Shape::Polygon(poly) => poly.length(),\n"
"            Shape::Circle(circle) => circle.circumference(),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: unit-tests\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    fn round_two_digits(x: f64) -> f64 {\n"
"        (x * 100.0).round() / 100.0\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_magnitude() {\n"
"        let p1 = Point::new(12, 13);\n"
"        assert_eq!(round_two_digits(p1.magnitude()), 17.69);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_dist() {\n"
"        let p1 = Point::new(10, 10);\n"
"        let p2 = Point::new(14, 13);\n"
"        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_add() {\n"
"        let p1 = Point::new(16, 16);\n"
"        let p2 = p1 + Point::new(-4, 3);\n"
"        assert_eq!(p2, Point::new(12, 19));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_left_most_point() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"        assert_eq!(poly.left_most_point(), Some(p1));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_iter() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"\n"
"        let points = poly.iter().cloned().collect::<Vec<_>>();\n"
"        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimeter)\n"
"            .map(round_two_digits)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}\n"
"// ANCHOR_END: unit-tests\n"
"\n"
"fn main() {}\n"
"```"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:1
msgid "Day 3 Afternoon Exercises"
msgstr "D√≠a 3: Ejercicios de la Tarde"

#: src/exercises/day-3/solutions-afternoon.md:5
msgid "([back to exercise](safe-ffi-wrapper.md))"
msgstr "([volver al ejercicio](safe-ffi-wrapper.md))"

#: src/exercises/day-3/solutions-afternoon.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: ffi\n"
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int};\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    use std::os::raw::{c_long, c_ulong, c_ushort, c_uchar};\n"
"\n"
"    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
"    #[repr(C)]\n"
"    pub struct DIR {\n"
"        _data: [u8; 0],\n"
"        _marker: core::marker::PhantomData<(*mut u8, core::marker::"
"PhantomPinned)>,\n"
"    }\n"
"\n"
"    // Layout according to the Linux man page for readdir(3), where ino_t "
"and\n"
"    // off_t are resolved according to the definitions in\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_ino: c_ulong,\n"
"        pub d_off: c_long,\n"
"        pub d_reclen: c_ushort,\n"
"        pub d_type: c_uchar,\n"
"        pub d_name: [c_char; 256],\n"
"    }\n"
"\n"
"    // Layout according to the macOS man page for dir(5).\n"
"    #[cfg(all(target_os = \"macos\"))]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_fileno: u64,\n"
"        pub d_seekoff: u64,\n"
"        pub d_reclen: u16,\n"
"        pub d_namlen: u16,\n"
"        pub d_type: u8,\n"
"        pub d_name: [c_char; 1024],\n"
"    }\n"
"\n"
"    extern \"C\" {\n"
"        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
"\n"
"        #[cfg(not(all(target_os = \"macos\", target_arch = \"x86_64\")))]\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"\n"
"        // See https://github.com/rust-lang/libc/issues/414 and the section "
"on\n"
"        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).\n"
"        //\n"
"        // \"Platforms that existed before these updates were available\" "
"refers\n"
"        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and "
"PowerPC.\n"
"        #[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n"
"        #[link_name = \"readdir$INODE64\"]\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"\n"
"        pub fn closedir(s: *mut DIR) -> c_int;\n"
"    }\n"
"}\n"
"\n"
"use std::ffi::{CStr, CString, OsStr, OsString};\n"
"use std::os::unix::ffi::OsStrExt;\n"
"\n"
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}\n"
"// ANCHOR_END: ffi\n"
"\n"
"// ANCHOR: DirectoryIterator\n"
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
"        // ANCHOR_END: DirectoryIterator\n"
"        let path = CString::new(path).map_err(|err| format!(\"Invalid path: "
"{err}\"))?;\n"
"        // SAFETY: path.as_ptr() cannot be NULL.\n"
"        let dir = unsafe { ffi::opendir(path.as_ptr()) };\n"
"        if dir.is_null() {\n"
"            Err(format!(\"Could not open {:?}\", path))\n"
"        } else {\n"
"            Ok(DirectoryIterator { path, dir })\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Iterator\n"
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Keep calling readdir until we get a NULL pointer back.\n"
"        // ANCHOR_END: Iterator\n"
"        // SAFETY: self.dir is never NULL.\n"
"        let dirent = unsafe { ffi::readdir(self.dir) };\n"
"        if dirent.is_null() {\n"
"            // We have reached the end of the directory.\n"
"            return None;\n"
"        }\n"
"        // SAFETY: dirent is not NULL and dirent.d_name is NUL\n"
"        // terminated.\n"
"        let d_name = unsafe { CStr::from_ptr((*dirent).d_name.as_ptr()) };\n"
"        let os_str = OsStr::from_bytes(d_name.to_bytes());\n"
"        Some(os_str.to_owned())\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Drop\n"
"impl Drop for DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Call closedir as needed.\n"
"        // ANCHOR_END: Drop\n"
"        if !self.dir.is_null() {\n"
"            // SAFETY: self.dir is not NULL.\n"
"            if unsafe { ffi::closedir(self.dir) } != 0 {\n"
"                panic!(\"Could not close {:?}\", self.path);\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: main\n"
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"// ANCHOR_END: main\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"    use std::error::Error;\n"
"\n"
"    #[test]\n"
"    fn test_nonexisting_directory() {\n"
"        let iter = DirectoryIterator::new(\"no-such-directory\");\n"
"        assert!(iter.is_err());\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_empty_directory() -> Result<(), Box<dyn Error>> {\n"
"        let tmp = tempfile::TempDir::new()?;\n"
"        let iter = DirectoryIterator::new(\n"
"            tmp.path().to_str().ok_or(\"Non UTF-8 character in path\")?,\n"
"        )?;\n"
"        let mut entries = iter.collect::<Vec<_>>();\n"
"        entries.sort();\n"
"        assert_eq!(entries, &[\".\", \"..\"]);\n"
"        Ok(())\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_nonempty_directory() -> Result<(), Box<dyn Error>> {\n"
"        let tmp = tempfile::TempDir::new()?;\n"
"        std::fs::write(tmp.path().join(\"foo.txt\"), \"The Foo "
"Diaries\\n\")?;\n"
"        std::fs::write(tmp.path().join(\"bar.png\"), \"<PNG>\\n\")?;\n"
"        std::fs::write(tmp.path().join(\"crab.rs\"), \"//! Crab\\n\")?;\n"
"        let iter = DirectoryIterator::new(\n"
"            tmp.path().to_str().ok_or(\"Non UTF-8 character in path\")?,\n"
"        )?;\n"
"        let mut entries = iter.collect::<Vec<_>>();\n"
"        entries.sort();\n"
"        assert_eq!(entries, &[\".\", \"..\", \"bar.png\", \"crab.rs\", \"foo."
"txt\"]);\n"
"        Ok(())\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md:1
msgid "Bare Metal Rust Morning Exercise"
msgstr "Rust Bare Metal: Ejercicio de la Ma√±ana"

#: src/exercises/bare-metal/solutions-morning.md:5
msgid "([back to exercise](compass.md))"
msgstr "([volver al ejercicio](compass.md))"

#: src/exercises/bare-metal/solutions-morning.md:7
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: top\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use core::fmt::Write;\n"
"use cortex_m_rt::entry;\n"
"// ANCHOR_END: top\n"
"use core::cmp::{max, min};\n"
"use lsm303agr::{AccelOutputDataRate, Lsm303agr, MagOutputDataRate};\n"
"use microbit::display::blocking::Display;\n"
"use microbit::hal::prelude::*;\n"
"use microbit::hal::twim::Twim;\n"
"use microbit::hal::uarte::{Baudrate, Parity, Uarte};\n"
"use microbit::hal::Timer;\n"
"use microbit::pac::twim0::frequency::FREQUENCY_A;\n"
"use microbit::Board;\n"
"\n"
"const COMPASS_SCALE: i32 = 30000;\n"
"const ACCELEROMETER_SCALE: i32 = 700;\n"
"\n"
"// ANCHOR: main\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let board = Board::take().unwrap();\n"
"\n"
"    // Configure serial port.\n"
"    let mut serial = Uarte::new(\n"
"        board.UARTE0,\n"
"        board.uart.into(),\n"
"        Parity::EXCLUDED,\n"
"        Baudrate::BAUD115200,\n"
"    );\n"
"\n"
"    // Set up the I2C controller and Inertial Measurement Unit.\n"
"    // ANCHOR_END: main\n"
"    writeln!(serial, \"Setting up IMU...\").unwrap();\n"
"    let i2c = Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::"
"K100);\n"
"    let mut imu = Lsm303agr::new_with_i2c(i2c);\n"
"    imu.init().unwrap();\n"
"    imu.set_mag_odr(MagOutputDataRate::Hz50).unwrap();\n"
"    imu.set_accel_odr(AccelOutputDataRate::Hz50).unwrap();\n"
"    let mut imu = imu.into_mag_continuous().ok().unwrap();\n"
"\n"
"    // Set up display and timer.\n"
"    let mut timer = Timer::new(board.TIMER0);\n"
"    let mut display = Display::new(board.display_pins);\n"
"\n"
"    let mut mode = Mode::Compass;\n"
"    let mut button_pressed = false;\n"
"\n"
"    // ANCHOR: loop\n"
"    writeln!(serial, \"Ready.\").unwrap();\n"
"\n"
"    loop {\n"
"        // Read compass data and log it to the serial port.\n"
"        // ANCHOR_END: loop\n"
"        while !(imu.mag_status().unwrap().xyz_new_data\n"
"            && imu.accel_status().unwrap().xyz_new_data)\n"
"        {}\n"
"        let compass_reading = imu.mag_data().unwrap();\n"
"        let accelerometer_reading = imu.accel_data().unwrap();\n"
"        writeln!(\n"
"            serial,\n"
"            \"{},{},{}\\t{},{},{}\",\n"
"            compass_reading.x,\n"
"            compass_reading.y,\n"
"            compass_reading.z,\n"
"            accelerometer_reading.x,\n"
"            accelerometer_reading.y,\n"
"            accelerometer_reading.z,\n"
"        )\n"
"        .unwrap();\n"
"\n"
"        let mut image = [[0; 5]; 5];\n"
"        let (x, y) = match mode {\n"
"            Mode::Compass => (\n"
"                scale(-compass_reading.x, -COMPASS_SCALE, COMPASS_SCALE, 0, "
"4) as usize,\n"
"                scale(compass_reading.y, -COMPASS_SCALE, COMPASS_SCALE, 0, "
"4) as usize,\n"
"            ),\n"
"            Mode::Accelerometer => (\n"
"                scale(\n"
"                    accelerometer_reading.x,\n"
"                    -ACCELEROMETER_SCALE,\n"
"                    ACCELEROMETER_SCALE,\n"
"                    0,\n"
"                    4,\n"
"                ) as usize,\n"
"                scale(\n"
"                    -accelerometer_reading.y,\n"
"                    -ACCELEROMETER_SCALE,\n"
"                    ACCELEROMETER_SCALE,\n"
"                    0,\n"
"                    4,\n"
"                ) as usize,\n"
"            ),\n"
"        };\n"
"        image[y][x] = 255;\n"
"        display.show(&mut timer, image, 100);\n"
"\n"
"        // If button A is pressed, switch to the next mode and briefly blink "
"all LEDs on.\n"
"        if board.buttons.button_a.is_low().unwrap() {\n"
"            if !button_pressed {\n"
"                mode = mode.next();\n"
"                display.show(&mut timer, [[255; 5]; 5], 200);\n"
"            }\n"
"            button_pressed = true;\n"
"        } else {\n"
"            button_pressed = false;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n"
"enum Mode {\n"
"    Compass,\n"
"    Accelerometer,\n"
"}\n"
"\n"
"impl Mode {\n"
"    fn next(self) -> Self {\n"
"        match self {\n"
"            Self::Compass => Self::Accelerometer,\n"
"            Self::Accelerometer => Self::Compass,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"fn scale(value: i32, min_in: i32, max_in: i32, min_out: i32, max_out: i32) -"
"> i32 {\n"
"    let range_in = max_in - min_in;\n"
"    let range_out = max_out - min_out;\n"
"    cap(\n"
"        min_out + range_out * (value - min_in) / range_in,\n"
"        min_out,\n"
"        max_out,\n"
"    )\n"
"}\n"
"\n"
"fn cap(value: i32, min_value: i32, max_value: i32) -> i32 {\n"
"    max(min_value, min(value, max_value))\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:5
msgid "([back to exercise](rtc.md))"
msgstr "([volver al ejercicio](rtc.md))"

#: src/exercises/bare-metal/solutions-afternoon.md:7
msgid "`main.rs`:"
msgstr "`main.rs`:"

#: src/exercises/bare-metal/solutions-afternoon.md:9
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: top\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"mod exceptions;\n"
"mod logger;\n"
"mod pl011;\n"
"// ANCHOR_END: top\n"
"mod pl031;\n"
"\n"
"use crate::pl031::Rtc;\n"
"use arm_gic::gicv3::{IntId, Trigger};\n"
"use arm_gic::{irq_enable, wfi};\n"
"use chrono::{TimeZone, Utc};\n"
"use core::hint::spin_loop;\n"
"// ANCHOR: imports\n"
"use crate::pl011::Uart;\n"
"use arm_gic::gicv3::GicV3;\n"
"use core::panic::PanicInfo;\n"
"use log::{error, info, trace, LevelFilter};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Base addresses of the GICv3.\n"
"const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;\n"
"const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 as _;\n"
"\n"
"/// Base address of the primary PL011 UART.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"// ANCHOR_END: imports\n"
"\n"
"/// Base address of the PL031 RTC.\n"
"const PL031_BASE_ADDRESS: *mut u32 = 0x901_0000 as _;\n"
"/// The IRQ used by the PL031 RTC.\n"
"const PL031_IRQ: IntId = IntId::spi(2);\n"
"\n"
"// ANCHOR: main\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 "
"device,\n"
"    // and nothing else accesses that address range.\n"
"    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"    logger::init(uart, LevelFilter::Trace).unwrap();\n"
"\n"
"    info!(\"main({:#x}, {:#x}, {:#x}, {:#x})\", x0, x1, x2, x3);\n"
"\n"
"    // Safe because `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the "
"base\n"
"    // addresses of a GICv3 distributor and redistributor respectively, and\n"
"    // nothing else accesses those address ranges.\n"
"    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, "
"GICR_BASE_ADDRESS) };\n"
"    gic.setup();\n"
"    // ANCHOR_END: main\n"
"\n"
"    // Safe because `PL031_BASE_ADDRESS` is the base address of a PL031 "
"device,\n"
"    // and nothing else accesses that address range.\n"
"    let mut rtc = unsafe { Rtc::new(PL031_BASE_ADDRESS) };\n"
"    let timestamp = rtc.read();\n"
"    let time = Utc.timestamp_opt(timestamp.into(), 0).unwrap();\n"
"    info!(\"RTC: {time}\");\n"
"\n"
"    GicV3::set_priority_mask(0xff);\n"
"    gic.set_interrupt_priority(PL031_IRQ, 0x80);\n"
"    gic.set_trigger(PL031_IRQ, Trigger::Level);\n"
"    irq_enable();\n"
"    gic.enable_interrupt(PL031_IRQ, true);\n"
"\n"
"    // Wait for 3 seconds, without interrupts.\n"
"    let target = timestamp + 3;\n"
"    rtc.set_match(target);\n"
"    info!(\n"
"        \"Waiting for {}\",\n"
"        Utc.timestamp_opt(target.into(), 0).unwrap()\n"
"    );\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    while !rtc.matched() {\n"
"        spin_loop();\n"
"    }\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    info!(\"Finished waiting\");\n"
"\n"
"    // Wait another 3 seconds for an interrupt.\n"
"    let target = timestamp + 6;\n"
"    info!(\n"
"        \"Waiting for {}\",\n"
"        Utc.timestamp_opt(target.into(), 0).unwrap()\n"
"    );\n"
"    rtc.set_match(target);\n"
"    rtc.clear_interrupt();\n"
"    rtc.enable_interrupt(true);\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    while !rtc.interrupt_pending() {\n"
"        wfi();\n"
"    }\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    info!(\"Finished waiting\");\n"
"\n"
"    // ANCHOR: main_end\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[panic_handler]\n"
"fn panic(info: &PanicInfo) -> ! {\n"
"    error!(\"{info}\");\n"
"    system_off::<Hvc>().unwrap();\n"
"    loop {}\n"
"}\n"
"// ANCHOR_END: main_end\n"
"```"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:149
msgid "`pl031.rs`:"
msgstr "`pl031.rs`:"

#: src/exercises/bare-metal/solutions-afternoon.md:151
msgid ""
"```rust\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"use core::ptr::{addr_of, addr_of_mut};\n"
"\n"
"#[repr(C, align(4))]\n"
"struct Registers {\n"
"    /// Data register\n"
"    dr: u32,\n"
"    /// Match register\n"
"    mr: u32,\n"
"    /// Load register\n"
"    lr: u32,\n"
"    /// Control register\n"
"    cr: u8,\n"
"    _reserved0: [u8; 3],\n"
"    /// Interrupt Mask Set or Clear register\n"
"    imsc: u8,\n"
"    _reserved1: [u8; 3],\n"
"    /// Raw Interrupt Status\n"
"    ris: u8,\n"
"    _reserved2: [u8; 3],\n"
"    /// Masked Interrupt Status\n"
"    mis: u8,\n"
"    _reserved3: [u8; 3],\n"
"    /// Interrupt Clear Register\n"
"    icr: u8,\n"
"    _reserved4: [u8; 3],\n"
"}\n"
"\n"
"/// Driver for a PL031 real-time clock.\n"
"#[derive(Debug)]\n"
"pub struct Rtc {\n"
"    registers: *mut Registers,\n"
"}\n"
"\n"
"impl Rtc {\n"
"    /// Constructs a new instance of the RTC driver for a PL031 device at "
"the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of "
"a\n"
"    /// PL031 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
"    pub unsafe fn new(base_address: *mut u32) -> Self {\n"
"        Self {\n"
"            registers: base_address as *mut Registers,\n"
"        }\n"
"    }\n"
"\n"
"    /// Reads the current RTC value.\n"
"    pub fn read(&self) -> u32 {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        unsafe { addr_of!((*self.registers).dr).read_volatile() }\n"
"    }\n"
"\n"
"    /// Writes a match value. When the RTC value matches this then an "
"interrupt\n"
"    /// will be generated (if it is enabled).\n"
"    pub fn set_match(&mut self, value: u32) {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        unsafe { addr_of_mut!((*self.registers).mr).write_volatile(value) }\n"
"    }\n"
"\n"
"    /// Returns whether the match register matches the RTC value, whether or "
"not\n"
"    /// the interrupt is enabled.\n"
"    pub fn matched(&self) -> bool {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        let ris = unsafe { addr_of!((*self.registers).ris)."
"read_volatile() };\n"
"        (ris & 0x01) != 0\n"
"    }\n"
"\n"
"    /// Returns whether there is currently an interrupt pending.\n"
"    ///\n"
"    /// This should be true if and only if `matched` returns true and the\n"
"    /// interrupt is masked.\n"
"    pub fn interrupt_pending(&self) -> bool {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        let ris = unsafe { addr_of!((*self.registers).mis)."
"read_volatile() };\n"
"        (ris & 0x01) != 0\n"
"    }\n"
"\n"
"    /// Sets or clears the interrupt mask.\n"
"    ///\n"
"    /// When the mask is true the interrupt is enabled; when it is false "
"the\n"
"    /// interrupt is disabled.\n"
"    pub fn enable_interrupt(&mut self, mask: bool) {\n"
"        let imsc = if mask { 0x01 } else { 0x00 };\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        unsafe { addr_of_mut!((*self.registers).imsc)."
"write_volatile(imsc) }\n"
"    }\n"
"\n"
"    /// Clears a pending interrupt, if any.\n"
"    pub fn clear_interrupt(&mut self) {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        unsafe { addr_of_mut!((*self.registers).icr).write_volatile(0x01) }\n"
"    }\n"
"}\n"
"\n"
"// Safe because it just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
"unsafe impl Send for Rtc {}\n"
"```"
msgstr ""

#: src/exercises/concurrency/solutions-morning.md:1
msgid "Concurrency Morning Exercise"
msgstr "Concurrencia: Ejercicios de la Ma√±ana"

#: src/exercises/concurrency/solutions-morning.md:5
msgid "([back to exercise](dining-philosophers.md))"
msgstr "([volver al ejercicio](dining-philosophers.md))"

#: src/exercises/concurrency/solutions-morning.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: Philosopher\n"
"use std::sync::{mpsc, Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    // ANCHOR_END: Philosopher\n"
"    left_fork: Arc<Mutex<Fork>>,\n"
"    right_fork: Arc<Mutex<Fork>>,\n"
"    thoughts: mpsc::SyncSender<String>,\n"
"}\n"
"\n"
"// ANCHOR: Philosopher-think\n"
"impl Philosopher {\n"
"    fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))\n"
"            .unwrap();\n"
"    }\n"
"    // ANCHOR_END: Philosopher-think\n"
"\n"
"    // ANCHOR: Philosopher-eat\n"
"    fn eat(&self) {\n"
"        // ANCHOR_END: Philosopher-eat\n"
"        println!(\"{} is trying to eat\", &self.name);\n"
"        let left = self.left_fork.lock().unwrap();\n"
"        let right = self.right_fork.lock().unwrap();\n"
"\n"
"        // ANCHOR: Philosopher-eat-end\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];\n"
"\n"
"fn main() {\n"
"    // ANCHOR_END: Philosopher-eat-end\n"
"    let (tx, rx) = mpsc::sync_channel(10);\n"
"\n"
"    let forks = (0..PHILOSOPHERS.len())\n"
"        .map(|_| Arc::new(Mutex::new(Fork)))\n"
"        .collect::<Vec<_>>();\n"
"\n"
"    for i in 0..forks.len() {\n"
"        let tx = tx.clone();\n"
"        let mut left_fork = Arc::clone(&forks[i]);\n"
"        let mut right_fork = Arc::clone(&forks[(i + 1) % forks.len()]);\n"
"\n"
"        // To avoid a deadlock, we have to break the symmetry\n"
"        // somewhere. This will swap the forks without deinitializing\n"
"        // either of them.\n"
"        if i == forks.len() - 1 {\n"
"            std::mem::swap(&mut left_fork, &mut right_fork);\n"
"        }\n"
"\n"
"        let philosopher = Philosopher {\n"
"            name: PHILOSOPHERS[i].to_string(),\n"
"            thoughts: tx,\n"
"            left_fork,\n"
"            right_fork,\n"
"        };\n"
"\n"
"        thread::spawn(move || {\n"
"            for _ in 0..100 {\n"
"                philosopher.eat();\n"
"                philosopher.think();\n"
"            }\n"
"        });\n"
"    }\n"
"\n"
"    drop(tx);\n"
"    for thought in rx {\n"
"        println!(\"{thought}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/solutions-morning.md:104
msgid "Link Checker"
msgstr "Comprobador de Enlaces"

#: src/exercises/concurrency/solutions-morning.md:106
msgid "([back to exercise](link-checker.md))"
msgstr "([volver al ejercicio](link-checker.md))"

#: src/exercises/concurrency/solutions-morning.md:108
msgid ""
"```rust,compile_fail\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"use std::{sync::Arc, sync::Mutex, sync::mpsc, thread};\n"
"\n"
"// ANCHOR: setup\n"
"use reqwest::{blocking::Client, Url};\n"
"use scraper::{Html, Selector};\n"
"use thiserror::Error;\n"
"\n"
"#[derive(Error, Debug)]\n"
"enum Error {\n"
"    #[error(\"request error: {0}\")]\n"
"    ReqwestError(#[from] reqwest::Error),\n"
"    #[error(\"bad http response: {0}\")]\n"
"    BadResponse(String),\n"
"}\n"
"// ANCHOR_END: setup\n"
"\n"
"// ANCHOR: visit_page\n"
"#[derive(Debug)]\n"
"struct CrawlCommand {\n"
"    url: Url,\n"
"    extract_links: bool,\n"
"}\n"
"\n"
"fn visit_page(client: &Client, command: &CrawlCommand) -> Result<Vec<Url>, "
"Error> {\n"
"    println!(\"Checking {:#}\", command.url);\n"
"    let response = client.get(command.url.clone()).send()?;\n"
"    if !response.status().is_success() {\n"
"        return Err(Error::BadResponse(response.status().to_string()));\n"
"    }\n"
"\n"
"    let mut link_urls = Vec::new();\n"
"    if !command.extract_links {\n"
"        return Ok(link_urls);\n"
"    }\n"
"\n"
"    let base_url = response.url().to_owned();\n"
"    let body_text = response.text()?;\n"
"    let document = Html::parse_document(&body_text);\n"
"\n"
"    let selector = Selector::parse(\"a\").unwrap();\n"
"    let href_values = document\n"
"        .select(&selector)\n"
"        .filter_map(|element| element.value().attr(\"href\"));\n"
"    for href in href_values {\n"
"        match base_url.join(href) {\n"
"            Ok(link_url) => {\n"
"                link_urls.push(link_url);\n"
"            }\n"
"            Err(err) => {\n"
"                println!(\"On {base_url:#}: ignored unparsable {href:?}: "
"{err}\");\n"
"            }\n"
"        }\n"
"    }\n"
"    Ok(link_urls)\n"
"}\n"
"// ANCHOR_END: visit_page\n"
"\n"
"struct CrawlState {\n"
"    domain: String,\n"
"    visited_pages: std::collections::HashSet<String>,\n"
"}\n"
"\n"
"impl CrawlState {\n"
"    fn new(start_url: &Url) -> CrawlState {\n"
"        let mut visited_pages = std::collections::HashSet::new();\n"
"        visited_pages.insert(start_url.as_str().to_string());\n"
"        CrawlState {\n"
"            domain: start_url.domain().unwrap().to_string(),\n"
"            visited_pages,\n"
"        }\n"
"    }\n"
"\n"
"    /// Determine whether links within the given page should be extracted.\n"
"    fn should_extract_links(&self, url: &Url) -> bool {\n"
"        let Some(url_domain) = url.domain() else {\n"
"            return false;\n"
"        };\n"
"        url_domain == self.domain\n"
"    }\n"
"\n"
"    /// Mark the given page as visited, returning true if it had already\n"
"    /// been visited.\n"
"    fn mark_visited(&mut self, url: &Url) -> bool {\n"
"        self.visited_pages.insert(url.as_str().to_string())\n"
"    }\n"
"}\n"
"\n"
"type CrawlResult = Result<Vec<Url>, (Url, Error)>;\n"
"fn spawn_crawler_threads(\n"
"    command_receiver: mpsc::Receiver<CrawlCommand>,\n"
"    result_sender: mpsc::Sender<CrawlResult>,\n"
"    thread_count: u32,\n"
") {\n"
"    let command_receiver = Arc::new(Mutex::new(command_receiver));\n"
"\n"
"    for _ in 0..thread_count {\n"
"        let result_sender = result_sender.clone();\n"
"        let command_receiver = command_receiver.clone();\n"
"        thread::spawn(move || {\n"
"            let client = Client::new();\n"
"            loop {\n"
"                let command_result = {\n"
"                    let receiver_guard = command_receiver.lock().unwrap();\n"
"                    receiver_guard.recv()\n"
"                };\n"
"                let Ok(crawl_command) = command_result else {\n"
"                    // The sender got dropped. No more commands coming in.\n"
"                    break;\n"
"                };\n"
"                let crawl_result = match visit_page(&client, &crawl_command) "
"{\n"
"                    Ok(link_urls) => Ok(link_urls),\n"
"                    Err(error) => Err((crawl_command.url, error)),\n"
"                };\n"
"                result_sender.send(crawl_result).unwrap();\n"
"            }\n"
"        });\n"
"    }\n"
"}\n"
"\n"
"fn control_crawl(\n"
"    start_url: Url,\n"
"    command_sender: mpsc::Sender<CrawlCommand>,\n"
"    result_receiver: mpsc::Receiver<CrawlResult>,\n"
") -> Vec<Url> {\n"
"    let mut crawl_state = CrawlState::new(&start_url);\n"
"    let start_command = CrawlCommand { url: start_url, extract_links: "
"true };\n"
"    command_sender.send(start_command).unwrap();\n"
"    let mut pending_urls = 1;\n"
"\n"
"    let mut bad_urls = Vec::new();\n"
"    while pending_urls > 0 {\n"
"        let crawl_result = result_receiver.recv().unwrap();\n"
"        pending_urls -= 1;\n"
"\n"
"        match crawl_result {\n"
"            Ok(link_urls) => {\n"
"                for url in link_urls {\n"
"                    if crawl_state.mark_visited(&url) {\n"
"                        let extract_links = crawl_state."
"should_extract_links(&url);\n"
"                        let crawl_command = CrawlCommand { url, "
"extract_links };\n"
"                        command_sender.send(crawl_command).unwrap();\n"
"                        pending_urls += 1;\n"
"                    }\n"
"                }\n"
"            }\n"
"            Err((url, error)) => {\n"
"                bad_urls.push(url);\n"
"                println!(\"Got crawling error: {:#}\", error);\n"
"                continue;\n"
"            }\n"
"        }\n"
"    }\n"
"    bad_urls\n"
"}\n"
"\n"
"fn check_links(start_url: Url) -> Vec<Url> {\n"
"    let (result_sender, result_receiver) = mpsc::channel::<CrawlResult>();\n"
"    let (command_sender, command_receiver) = mpsc::channel::"
"<CrawlCommand>();\n"
"    spawn_crawler_threads(command_receiver, result_sender, 16);\n"
"    control_crawl(start_url, command_sender, result_receiver)\n"
"}\n"
"\n"
"fn main() {\n"
"    let start_url = reqwest::Url::parse(\"https://www.google.org\")."
"unwrap();\n"
"    let bad_urls = check_links(start_url);\n"
"    println!(\"Bad URLs: {:#?}\", bad_urls);\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:1
msgid "Concurrency Afternoon Exercise"
msgstr "Concurrencia: Ejercicios de la Tarde"

#: src/exercises/concurrency/solutions-afternoon.md:5
msgid "([back to exercise](dining-philosophers-async.md))"
msgstr "([volver al ejercicio](dining-philosophers-async.md))"

#: src/exercises/concurrency/solutions-afternoon.md:7
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: Philosopher\n"
"use std::sync::Arc;\n"
"use tokio::time;\n"
"use tokio::sync::mpsc::{self, Sender};\n"
"use tokio::sync::Mutex;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    // ANCHOR_END: Philosopher\n"
"    left_fork: Arc<Mutex<Fork>>,\n"
"    right_fork: Arc<Mutex<Fork>>,\n"
"    thoughts: Sender<String>,\n"
"}\n"
"\n"
"// ANCHOR: Philosopher-think\n"
"impl Philosopher {\n"
"    async fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))."
"await\n"
"            .unwrap();\n"
"    }\n"
"    // ANCHOR_END: Philosopher-think\n"
"\n"
"    // ANCHOR: Philosopher-eat\n"
"    async fn eat(&self) {\n"
"        // Pick up forks...\n"
"        // ANCHOR_END: Philosopher-eat\n"
"        let _first_lock = self.left_fork.lock().await;\n"
"        // Add a delay before picking the second fork to allow the "
"execution\n"
"        // to transfer to another task\n"
"        time::sleep(time::Duration::from_millis(1)).await;\n"
"        let _second_lock = self.right_fork.lock().await;\n"
"\n"
"        // ANCHOR: Philosopher-eat-body\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"        // ANCHOR_END: Philosopher-eat-body\n"
"\n"
"        // The locks are dropped here\n"
"        // ANCHOR: Philosopher-eat-end\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    // ANCHOR_END: Philosopher-eat-end\n"
"    // Create forks\n"
"    let mut forks = vec![];\n"
"    (0..PHILOSOPHERS.len()).for_each(|_| forks.push(Arc::new(Mutex::"
"new(Fork))));\n"
"\n"
"    // Create philosophers\n"
"    let (philosophers, mut rx) = {\n"
"        let mut philosophers = vec![];\n"
"        let (tx, rx) = mpsc::channel(10);\n"
"        for (i, name) in PHILOSOPHERS.iter().enumerate() {\n"
"            let left_fork = Arc::clone(&forks[i]);\n"
"            let right_fork = Arc::clone(&forks[(i + 1) % PHILOSOPHERS."
"len()]);\n"
"            // To avoid a deadlock, we have to break the symmetry\n"
"            // somewhere. This will swap the forks without deinitializing\n"
"            // either of them.\n"
"            if i  == 0 {\n"
"                std::mem::swap(&mut left_fork, &mut right_fork);\n"
"            }\n"
"            philosophers.push(Philosopher {\n"
"                name: name.to_string(),\n"
"                left_fork,\n"
"                right_fork,\n"
"                thoughts: tx.clone(),\n"
"            });\n"
"        }\n"
"        (philosophers, rx)\n"
"        // tx is dropped here, so we don't need to explicitly drop it later\n"
"    };\n"
"\n"
"    // Make them think and eat\n"
"    for phil in philosophers {\n"
"        tokio::spawn(async move {\n"
"            for _ in 0..100 {\n"
"                phil.think().await;\n"
"                phil.eat().await;\n"
"            }\n"
"        });\n"
"\n"
"    }\n"
"\n"
"    // Output their thoughts\n"
"    while let Some(thought) = rx.recv().await {\n"
"        println!(\"Here is a thought: {thought}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:121
msgid "([back to exercise](chat-app.md))"
msgstr "([volver al ejercicio](chat-app.md))"

#: src/exercises/concurrency/solutions-afternoon.md:125
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: setup\n"
"use futures_util::sink::SinkExt;\n"
"use futures_util::stream::StreamExt;\n"
"use std::error::Error;\n"
"use std::net::SocketAddr;\n"
"use tokio::net::{TcpListener, TcpStream};\n"
"use tokio::sync::broadcast::{channel, Sender};\n"
"use tokio_websockets::{Message, ServerBuilder, WebsocketStream};\n"
"// ANCHOR_END: setup\n"
"\n"
"// ANCHOR: handle_connection\n"
"async fn handle_connection(\n"
"    addr: SocketAddr,\n"
"    mut ws_stream: WebsocketStream<TcpStream>,\n"
"    bcast_tx: Sender<String>,\n"
") -> Result<(), Box<dyn Error + Send + Sync>> {\n"
"    // ANCHOR_END: handle_connection\n"
"\n"
"    ws_stream\n"
"        .send(Message::text(\"Welcome to chat! Type a message\".into()))\n"
"        .await?;\n"
"    let mut bcast_rx = bcast_tx.subscribe();\n"
"\n"
"    // A continuous loop for concurrently performing two tasks: (1) "
"receiving\n"
"    // messages from `ws_stream` and broadcasting them, and (2) receiving\n"
"    // messages on `bcast_rx` and sending them to the client.\n"
"    loop {\n"
"        tokio::select! {\n"
"            incoming = ws_stream.next() => {\n"
"                match incoming {\n"
"                    Some(Ok(msg)) => {\n"
"                        if let Some(text) = msg.as_text() {\n"
"                            println!(\"From client {addr:?} {text:?}\");\n"
"                            bcast_tx.send(text.into())?;\n"
"                        }\n"
"                    }\n"
"                    Some(Err(err)) => return Err(err.into()),\n"
"                    None => return Ok(()),\n"
"                }\n"
"            }\n"
"            msg = bcast_rx.recv() => {\n"
"                ws_stream.send(Message::text(msg?)).await?;\n"
"            }\n"
"        }\n"
"    }\n"
"    // ANCHOR: main\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> Result<(), Box<dyn Error + Send + Sync>> {\n"
"    let (bcast_tx, _) = channel(16);\n"
"\n"
"    let listener = TcpListener::bind(\"127.0.0.1:2000\").await?;\n"
"    println!(\"listening on port 2000\");\n"
"\n"
"    loop {\n"
"        let (socket, addr) = listener.accept().await?;\n"
"        println!(\"New connection from {addr:?}\");\n"
"        let bcast_tx = bcast_tx.clone();\n"
"        tokio::spawn(async move {\n"
"            // Wrap the raw TCP stream into a websocket.\n"
"            let ws_stream = ServerBuilder::new().accept(socket).await?;\n"
"\n"
"            handle_connection(addr, ws_stream, bcast_tx).await\n"
"        });\n"
"    }\n"
"}\n"
"// ANCHOR_END: main\n"
"```"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:212
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: setup\n"
"use futures_util::stream::StreamExt;\n"
"use futures_util::SinkExt;\n"
"use http::Uri;\n"
"use tokio::io::{AsyncBufReadExt, BufReader};\n"
"use tokio_websockets::{ClientBuilder, Message};\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> Result<(), tokio_websockets::Error> {\n"
"    let (mut ws_stream, _) =\n"
"        ClientBuilder::from_uri(Uri::from_static(\"ws://127.0.0.1:2000\"))\n"
"            .connect()\n"
"            .await?;\n"
"\n"
"    let stdin = tokio::io::stdin();\n"
"    let mut stdin = BufReader::new(stdin).lines();\n"
"\n"
"    // ANCHOR_END: setup\n"
"    // Continuous loop for concurrently sending and receiving messages.\n"
"    loop {\n"
"        tokio::select! {\n"
"            incoming = ws_stream.next() => {\n"
"                match incoming {\n"
"                    Some(Ok(msg)) => {\n"
"                        if let Some(text) = msg.as_text() {\n"
"                            println!(\"From server: {}\", text);\n"
"                        }\n"
"                    },\n"
"                    Some(Err(err)) => return Err(err.into()),\n"
"                    None => return Ok(()),\n"
"                }\n"
"            }\n"
"            res = stdin.next_line() => {\n"
"                match res {\n"
"                    Ok(None) => return Ok(()),\n"
"                    Ok(Some(line)) => ws_stream.send(Message::text(line."
"to_string())).await?,\n"
"                    Err(err) => return Err(err.into()),\n"
"                }\n"
"            }\n"
"\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#~ msgid "Extra Work in Modern C++"
#~ msgstr "Trabajo adicional en C++ moderno"

#~ msgid ""
#~ "[WebsocketStream::next()](https://docs.rs/tokio-websockets/0.3.2/"
#~ "tokio_websockets/proto/struct.WebsocketStream.html#method.next): for "
#~ "asynchronously reading messages from a Websocket Stream."
#~ msgstr ""
#~ "[WebsocketStream::next()](https://docs.rs/tokio-websockets/0.3.2/"
#~ "tokio_websockets/proto/struct.WebsocketStream.html#method.next): para la "
#~ "lectura as√≠ncrona de mensajes de un flujo WebSocket."

#~ msgid "Comparison"
#~ msgstr "Comparaci√≥n"

#~ msgid "The course is fast paced and covers a lot of ground:"
#~ msgstr "El curso es r√°pido y abarca muchos temas:"

#~ msgid ""
#~ "Depending on which abstraction (or combination of abstractions) you "
#~ "choose, can be a single unique pointer, reference counted, or atomically "
#~ "reference counted."
#~ msgstr ""
#~ "Dependiendo de la abstracci√≥n (o combinaci√≥n de abstracciones) que "
#~ "elijas, puede ser un solo puntero √∫nico, de referencia contada, o de "
#~ "referencia at√≥mica contada."

#~ msgid "Here is a rough comparison of the memory management techniques."
#~ msgstr ""
#~ "A continuaci√≥n, se muestra una comparaci√≥n aproximada de las t√©cnicas de "
#~ "gesti√≥n de la memoria."

#~ msgid "Pros of Different Memory Management Techniques"
#~ msgstr "Ventajas de las diferentes t√©cnicas de gesti√≥n de la memoria"

#~ msgid "Manual like C:"
#~ msgstr "Manual, como en C:"

#~ msgid "No runtime overhead."
#~ msgstr "Sin sobrecarga en _runtime_."

#~ msgid "Automatic like Java:"
#~ msgstr "Autom√°tica, como en Java:"

#~ msgid "Fully automatic."
#~ msgstr "Totalmente autom√°tica."

#~ msgid "Safe and correct."
#~ msgstr "Segura y correcta."

#~ msgid "Scope-based like C++:"
#~ msgstr "Basada en el √°mbito, como en C++:"

#~ msgid "Partially automatic."
#~ msgstr "Parcialmente autom√°tica."

#~ msgid "Compiler-enforced scope-based like Rust:"
#~ msgstr "Basada en el √°mbito e implementada por el compilador, como en Rust:"

#~ msgid "Enforced by compiler."
#~ msgstr "Implementada por el compilador."

#~ msgid "Cons of Different Memory Management Techniques"
#~ msgstr "Inconvenientes de las diferentes t√©cnicas de gesti√≥n de la memoria"

#~ msgid "Use-after-free."
#~ msgstr "Errores use-after-free."

#~ msgid "Double-frees."
#~ msgstr "Errores double free."

#~ msgid "Memory leaks."
#~ msgstr "P√©rdidas de memoria."

#~ msgid "Garbage collection pauses."
#~ msgstr "Pausas en la recolecci√≥n de memoria residual."

#~ msgid "Destructor delays."
#~ msgstr "Retrasos del destructor."

#~ msgid "Complex, opt-in by programmer (on C++)."
#~ msgstr "Compleja, habilitada por el programador (en C++)."

#~ msgid "Circular references can lead to memory leaks"
#~ msgstr "Las referencias circulares pueden provocar p√©rdidas de memoria."

#~ msgid "Potential runtime overhead"
#~ msgstr "Posible sobrecarga en _runtime_ "

#~ msgid "Compiler-enforced and scope-based like Rust:"
#~ msgstr "Implementada por el compilador y basada en el √°mbito, como en Rust:"

#~ msgid "Some upfront complexity."
#~ msgstr "Cierta complejidad inicial."

#~ msgid "Can reject valid programs."
#~ msgstr "Puede rechazar programas v√°lidos."

#~ msgid "Simple struct which tracks health statistics."
#~ msgstr ""
#~ "Estructura simple que hace un seguimiento de las estad√≠sticas de salud."

#~ msgid "Multiple structs and enums for a drawing library."
#~ msgstr "Varias estructuras y enumeraciones para una biblioteca de planos."

#~ msgid "Day 4: Morning"
#~ msgstr "D√≠a 4: Ma√±ana"

#~ msgid "Day 4: Afternoon"
#~ msgstr "D√≠a 4: Tarde"

#~ msgid "Day 4 Morning"
#~ msgstr "D√≠a 4 Ma√±ana"

#~ msgid "On Day 4, we will cover Android-specific things such as:"
#~ msgstr "En el D√≠a 4, cubriremos cosas espec√≠ficas a Android como:"

#~ msgid "Building Android components in Rust."
#~ msgstr "Construir componentes en Rust."

#~ msgid "AIDL servers and clients."
#~ msgstr "Clientes y servidores AIDL. "

#~ msgid "Interoperability with C, C++, and Java."
#~ msgstr "Interoperabilidad con C, C++, y Java."

#~ msgid ""
#~ "It is important to note that this course does not cover Android "
#~ "**application**  development in Rust, and that the Android-specific parts "
#~ "are specifically about writing code for Android itself, the operating "
#~ "system. "
#~ msgstr ""
#~ "Es importante destacar que este curso no cubre desarrollo de "
#~ "**aplicaciones**  Android en Rust, y que las partes espec√≠ficas a Android "
#~ "son acerca de escribir c√≥digo para Android en s√≠, el sistema operativo. "

#~ msgid ""
#~ "Learn how to use async Rust --- we'll only mention async Rust when "
#~ "covering traditional concurrency primitives. Please see [Asynchronous "
#~ "Programming in Rust](https://rust-lang.github.io/async-book/) instead for "
#~ "details on this topic."
#~ msgstr ""
#~ "Aprender  c√≥mo usar Rust asincr√≥nico ‚Äîsolo mencionaremos Rust async "
#~ "cuando cubramos las primitivas de concurrencia tradicional. Por favor ver "
#~ "[Asynchronous Programming in Rust](https://rust-lang.github.io/async-"
#~ "book/) para m√°s detalles."

#~ msgid "Day 1: Basic Rust, ownership and the borrow checker."
#~ msgstr "D√≠a 1: Rust B√°sico, propiedad y chequeo de pr√©stamos."

#~ msgid "Day 4: Concurrency in Rust and interoperability with other languages"
#~ msgstr ""
#~ "D√≠a 4: Concurrencia en Rust e interoperatiblidad con otros lenguajes"

#~ msgid ""
#~ "**Exercise for Day 4:** Do you interface with some C/C++ code in your "
#~ "project which we could attempt to move to Rust? The fewer dependencies "
#~ "the better. Parsing code would be ideal."
#~ msgstr ""
#~ "**Ejecicio del D√≠a 4:** Comunicarte con alegan c√≥digo C/C++ en tu "
#~ "proyecto que podr√≠as migrar a Rust? Con menos dependencias es lo mejor. "
#~ "Parsear el c√≥digo ser√≠a lo ideal."

#~ msgid "Rustup (Recommended)"
#~ msgstr "Rustup (Recomendado)"

#~ msgid ""
#~ "You can follow the instructions to install cargo and rust compiler, among "
#~ "other standard ecosystem tools with the [rustup](https://rustup.rs/) "
#~ "tool, which is maintained by the Rust Foundation."
#~ msgstr ""
#~ "Puedes seguir las instrucciones para instalar cargo y el compilador de "
#~ "Rust, adem√°s de otras herramientas est√°ndar con la herramienta [rustup]"
#~ "(https://rust-analyzer.github.io/), que es mantenida por la Fundaci√≥n "
#~ "Rust."

#~ msgid "Package Managers"
#~ msgstr "Package Managers"

#~ msgid "}"
#~ msgstr "}"

#~ msgid ""
#~ "```\n"
#~ "```"
#~ msgstr ""
#~ "```\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    fizzbuzz_to(20);   // Defined below, no forward declaration needed\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    fizzbuzz_to(20);   // Definida abajo, no necesitas declararla antes\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "fn fizzbuzz(n: u32) -> () {  // No return value means returning the unit "
#~ "type `()` match (is_divisible_by(n, 3), is_divisible_by(n, 5)) { (true,  "
#~ "true)  => println!(\"fizzbuzz\"), (true,  false) => println!(\"fizz\"), "
#~ "(false, true)  => println!(\"buzz\"), (false, false) => println!"
#~ "(\"{n}\"), } }"
#~ msgstr ""
#~ "fn fizzbuzz(n: u32) -> () {  // No devolver valor implica devolver un "
#~ "tipo unit `()` match (is_divisible_by(n, 3), is_divisible_by(n, 5)) "
#~ "{ (true,  true)  => println!(\"fizzbuzz\"), (true,  false) => println!"
#~ "(\"fizz\"), (false, true)  => println!(\"buzz\"), (false, false) => "
#~ "println!(\"{n}\"), } }"

#~ msgid ""
#~ "fn fizzbuzz_to(n: u32) {  // `-> ()` is normally omitted for i in 1..=n "
#~ "{ fizzbuzz(i); } }"
#~ msgstr ""
#~ "fn fizzbuzz_to(n: u32) {  // `-> ()` por lo general se omite for i in 1.."
#~ "=n { fizzbuzz(i); } }"

#~ msgid ""
#~ "The `match` expression in `fizzbuzz()` is doing a lot of work. It is "
#~ "expanded below to show what is happening."
#~ msgstr "Los `match` en `fizzbuzz()` hacen mucho. Se detalla debajo."

#~ msgid "(Type annotations added for clarity, but they can be elided.)"
#~ msgstr "(Las anotaciones dan claridad, pero se pueden omitir)"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn pick_one<T>(a: T, b: T) -> T {\n"
#~ "    if std::process::id() % 2 == 0 { a } else { b }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn elegir_uno<T>(a: T, b: T) -> T {\n"
#~ "    if std::process::id() % 2 == 0 { a } else { b }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```\n"
#~ "print!(\"Iterating over range:\");\n"
#~ "for i in 0..3 {\n"
#~ "    print!(\" {}\", array[i]);\n"
#~ "}\n"
#~ "println!();\n"
#~ "```"
#~ msgstr ""
#~ "```\n"
#~ "print!(\"Iterando sobre el rango:\");\n"
#~ "for i in 0..3 {\n"
#~ "    print!(\" {}\", array[i]);\n"
#~ "}\n"
#~ "println!();\n"
#~ "```"

#~ msgid ""
#~ "```rust,should_panic\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_variables, dead_code)]\n"
#~ "```"
#~ msgstr ""
#~ "```rust,should_panic\n"
#~ "// TODO: borra esto cuando termines de implementarlo.\n"
#~ "#![allow(unused_variables, dead_code)]\n"
#~ "```"

#~ msgid ""
#~ "Note that since `println!` is a macro, `x` is not moved, even using the "
#~ "function like syntax of `println!(\"x: {}\", x)`"
#~ msgstr ""
#~ "Nota que a partir que `println!` es una macro, `x` no se mueve, incluso "
#~ "usando una funci√≥n como `println!(\"x: {}\", x)`"

#~ msgid "Global state is managed with static and constant variables."
#~ msgstr "El estado global es manejado con variables est√°ticas y constantes."

#~ msgid "You can declare compile-time constants:"
#~ msgstr "Puedes declarar constantes en tiempo de compilaci√≥n:"

#~ msgid ""
#~ "fn main() { let digest = compute_digest(\"Hello\"); println!(\"Digest: "
#~ "{digest:?}\"); }"
#~ msgstr ""
#~ "fn main() { let digest = compute_digest(\"Hola\"); println!(\"Digest: "
#~ "{digest:?}\"); }"

#~ msgid "You can also declare static variables:"
#~ msgstr "Tambi√©n puedes declarar variables est√°ticas:"

#~ msgid ""
#~ "We will look at mutating static data in the [chapter on Unsafe Rust](../"
#~ "unsafe.md)."
#~ msgstr ""
#~ "Veremos cambiar datos est√°ticos en el [cap√≠tulo Rust No Seguro](../unsafe."
#~ "md)."

#~ msgid "Potential for use-after-free."
#~ msgstr "Potencial de use-after-free."

#~ msgid "The data was _moved_ from `s1` and `s1` is no longer accessible."
#~ msgstr "Los datos se mueven de `s1` y `s2` si no se accede m√°s."

#~ msgid ""
#~ "fn main() { let p1 = Point(3, 4); let p2 = Point(10, 20); let p3 = "
#~ "add(&p1, &p2); println!(\"&p3.0: {:p}\", &p3.0); println!(\"{p1:?} + "
#~ "{p2:?} = {p3:?}\"); }"
#~ msgstr ""
#~ "fn main() { let p1 = Point(3, 4); let p2 = Point(10, 20); let p3 = "
#~ "add(&p1, &p2); println!(\"&p3.0: {:p}\", &p3.0); println!(\"{p1:?} + "
#~ "{p2:?} = {p3:?}\"); }"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point(i32, i32);\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point(i32, i32);\n"
#~ "```"

#~ msgid "A small book library,"
#~ msgstr "Un peque√±o libro de biblioteca,"

#~ msgid "Iterators and ownership (hard)."
#~ msgstr "Iteradores y propiedad (dif√≠cil)."

#~ msgid ""
#~ "impl Book { // This is a constructor, used below. fn new(title: &str, "
#~ "year: u16) -> Book { Book { title: String::from(title), year, } } }"
#~ msgstr ""
#~ "impl Book { // Este es el constructor, usado debajo. fn new(title: &str, "
#~ "year: u16) -> Book { Book { title: String::from(title), year, } } }"

#~ msgid ""
#~ "// This makes it possible to print Book values with {}. impl std::fmt::"
#~ "Display for Book { fn fmt(&self, f: &mut std::fmt::Formatter\\<'\\_\\>) -"
#~ "> std::fmt::Result { write!(f, \"{} ({})\", self.title, self.year) } }"
#~ msgstr ""
#~ "// Esto hace posible imprimir valores del libro con {}. impl std::fmt::"
#~ "Display for Book { fn fmt(&self, f: &mut std::fmt::Formatter\\<'\\_\\>) -"
#~ "> std::fmt::Result { write!(f, \"{} ({})\", self.title, self.year) } }"

#~ msgid ""
#~ "// This shows the desired behavior. Uncomment the code below and // "
#~ "implement the missing methods. You will need to update the // method "
#~ "signatures, including the \"self\" parameter! You may // also need to "
#~ "update the variable bindings within main. fn main() { let library = "
#~ "Library::new();"
#~ msgstr ""
#~ "// Esto muestra el estado deseado. Descomenta el c√≥digo debajo e // "
#~ "implementa el m√©todo que falta. Puedes necesitar actualizar el  // signo "
#~ "del m√©todo, incluyendo el par√°metro \"self\". Tambi√©n fn main() { let "
#~ "library = Library::new();"

#~ msgid ""
#~ "impl Person { fn say_hello(&self) { println!(\"Hello, my name is {}\", "
#~ "self.name); } }"
#~ msgstr ""
#~ "impl Person { fn say_hello(&self) { println!(\"Hola, mi nombre es {}\", "
#~ "self.name); } }"

#~ msgid "Welcome to Day 4"
#~ msgstr "Bienvenido al D√≠a 4"
