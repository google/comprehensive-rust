msgid ""
msgstr ""
"Project-Id-Version: Comprehensive Rust \n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2023-03-10 17:32+0100\n"
"Last-Translator: Kuba Jaroszewski <jakub.jaroszewski@gmail.com>\n"
"Language-Team: Polish <translation-team-pl@lists.sourceforge.net>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pl\n"
"Plural-Forms: nplurals=3; plural=(n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 "
"|| n%100>=20) ? 1 : 2);\n"

#: src/SUMMARY.md:3
msgid "Welcome to Comprehensive Rust "
msgstr "Witamy w Comprehensive Rust "

#: src/SUMMARY.md:4
msgid "Running the Course"
msgstr "Prowadzenie kursu"

#: src/SUMMARY.md:5
msgid "Course Structure"
msgstr "Struktura kursu"

#: src/SUMMARY.md:6
msgid "Keyboard Shortcuts"
msgstr "Skr贸ty klawiszowe"

#: src/SUMMARY.md:7
msgid "Translations"
msgstr "Tumaczenia"

#: src/SUMMARY.md:8
msgid "Using Cargo"
msgstr "Korzystanie z Cargo"

#: src/SUMMARY.md:9
msgid "Rust Ecosystem"
msgstr "Ekosystem Rust"

#: src/SUMMARY.md:10
msgid "Code Samples"
msgstr "Pr贸bki kodu"

#: src/SUMMARY.md:11
msgid "Running Cargo Locally"
msgstr "Lokalne uruchamianie Cargo"

#: src/SUMMARY.md:14
msgid "Day 1: Morning"
msgstr "Dzie 1: Rano"

#: src/SUMMARY.md:18 src/SUMMARY.md:74 src/SUMMARY.md:127 src/SUMMARY.md:183
msgid "Welcome"
msgstr "Witamy"

#: src/SUMMARY.md:19
msgid "What is Rust?"
msgstr "Co to jest Rust?"

#: src/SUMMARY.md:20
msgid "Hello World!"
msgstr "Witaj wiecie!"

#: src/SUMMARY.md:21
msgid "Small Example"
msgstr "May przykad"

#: src/SUMMARY.md:22
msgid "Why Rust?"
msgstr "Dlaczego Rust?"

#: src/SUMMARY.md:23
msgid "Compile Time Guarantees"
msgstr "Gwarancje w czasie kompilacji"

#: src/SUMMARY.md:24
msgid "Runtime Guarantees"
msgstr "Gwarancje podczas dziaania"

#: src/SUMMARY.md:25
msgid "Modern Features"
msgstr "Nowoczesne funkcjonalnoci"

#: src/SUMMARY.md:26
msgid "Basic Syntax"
msgstr "Podstawowa skadnia"

#: src/SUMMARY.md:27
msgid "Scalar Types"
msgstr "Typy skalarne"

#: src/SUMMARY.md:28
msgid "Compound Types"
msgstr "Typy zo偶one"

#: src/SUMMARY.md:29
msgid "References"
msgstr "Referencje"

#: src/SUMMARY.md:30
msgid "Dangling References"
msgstr "Wiszce referencje"

#: src/SUMMARY.md:31
msgid "Slices"
msgstr "Wycinki"

#: src/SUMMARY.md:32
msgid "String vs str"
msgstr "String a str"

#: src/SUMMARY.md:33
msgid "Functions"
msgstr "Funkcje"

#: src/SUMMARY.md:34 src/SUMMARY.md:81
msgid "Methods"
msgstr "Metody"

#: src/SUMMARY.md:35
msgid "Overloading"
msgstr "Przeci偶enie"

#: src/SUMMARY.md:36 src/SUMMARY.md:65 src/SUMMARY.md:89 src/SUMMARY.md:118 src/SUMMARY.md:147
#: src/SUMMARY.md:175 src/SUMMARY.md:198 src/SUMMARY.md:225
msgid "Exercises"
msgstr "wiczenia"

#: src/SUMMARY.md:37
msgid "Implicit Conversions"
msgstr "Niejawne konwersje"

#: src/SUMMARY.md:38
msgid "Arrays and for Loops"
msgstr "Tablice i ptle for"

#: src/SUMMARY.md:40
msgid "Day 1: Afternoon"
msgstr "Dzie 1: Popoudnie"

#: src/SUMMARY.md:42
msgid "Variables"
msgstr "Zmienne"

#: src/SUMMARY.md:43
msgid "Type Inference"
msgstr "Wnioskowanie typ贸w"

#: src/SUMMARY.md:44
msgid "static & const"
msgstr "static i const"

#: src/SUMMARY.md:45
msgid "Scopes and Shadowing"
msgstr "Zakresy i przesanianie"

#: src/SUMMARY.md:46
msgid "Memory Management"
msgstr "Zarzdzanie pamici"

#: src/SUMMARY.md:47
msgid "Stack vs Heap"
msgstr "Stos a sterta"

#: src/SUMMARY.md:48
msgid "Stack Memory"
msgstr "Pami stosu"

#: src/SUMMARY.md:49
msgid "Manual Memory Management"
msgstr "Rczne zarzdzanie pamici"

#: src/SUMMARY.md:50
msgid "Scope-Based Memory Management"
msgstr "Zarzdzanie pamici w oparciu o zakres"

#: src/SUMMARY.md:51
msgid "Garbage Collection"
msgstr "Odmiecanie pamici"

#: src/SUMMARY.md:52
msgid "Rust Memory Management"
msgstr "Zarzdzanie pamici w Rucie"

#: src/SUMMARY.md:53
msgid "Comparison"
msgstr "Por贸wnanie"

#: src/SUMMARY.md:54
msgid "Ownership"
msgstr "Wasno"

#: src/SUMMARY.md:55
msgid "Move Semantics"
msgstr "Semantyka przenoszenia"

#: src/SUMMARY.md:56
msgid "Moved Strings in Rust"
msgstr "Przenoszenie String w Rucie"

#: src/SUMMARY.md:57
msgid "Double Frees in Modern C++"
msgstr "Podw贸jne zwalnianie pamici w nowoczesnym C++"

#: src/SUMMARY.md:58
msgid "Moves in Function Calls"
msgstr "Przenoszenie w wywoaniach funkcji"

#: src/SUMMARY.md:59
msgid "Copying and Cloning"
msgstr "Kopiowanie i klonowanie"

#: src/SUMMARY.md:60
msgid "Borrowing"
msgstr "Po偶yczanie"

#: src/SUMMARY.md:61
msgid "Shared and Unique Borrows"
msgstr "Wsp贸lne i unikalne po偶yczenia"

#: src/SUMMARY.md:62
msgid "Lifetimes"
msgstr "Czas 偶ycia"

#: src/SUMMARY.md:63
#, fuzzy
msgid "Lifetimes in Function Calls"
msgstr "Czas 偶ycia w wywoaniach funkcji"

#: src/SUMMARY.md:64
#, fuzzy
msgid "Lifetimes in Data Structures"
msgstr "Czasy 偶ycia w strukturach danych"

#: src/SUMMARY.md:66
msgid "Designing a Library"
msgstr "Projektowanie biblioteki"

#: src/SUMMARY.md:67
msgid "Iterators and Ownership"
msgstr "Iteratory a wasno"

#: src/SUMMARY.md:70
msgid "Day 2: Morning"
msgstr "Dzie 2: Rano"

#: src/SUMMARY.md:75
msgid "Structs"
msgstr "Struktury"

#: src/SUMMARY.md:76
msgid "Tuple Structs"
msgstr "Struktury krotkowe"

#: src/SUMMARY.md:77
msgid "Field Shorthand Syntax"
msgstr "Skr贸cona skadnia pola"

#: src/SUMMARY.md:78
msgid "Enums"
msgstr "Wyliczenia"

#: src/SUMMARY.md:79
msgid "Variant Payloads"
msgstr "Dane w wariantach"

#: src/SUMMARY.md:80
msgid "Enum Sizes"
msgstr "Rozmiary wylicze"

#: src/SUMMARY.md:82
msgid "Method Receiver"
msgstr "Skadnia metody"

#: src/SUMMARY.md:83 src/SUMMARY.md:158 src/SUMMARY.md:193
msgid "Example"
msgstr "Przykad"

#: src/SUMMARY.md:84
msgid "Pattern Matching"
msgstr "Dopasowywanie wzorc贸w"

#: src/SUMMARY.md:85
msgid "Destructuring Enums"
msgstr "Destrukturyzacja wylicze"

#: src/SUMMARY.md:86
msgid "Destructuring Structs"
msgstr "Destrukturyzacja struktur"

#: src/SUMMARY.md:87
msgid "Destructuring Arrays"
msgstr "Destrukturyzacja tablic"

#: src/SUMMARY.md:88
msgid "Match Guards"
msgstr "Stra偶nicy w dopasowywaniu wzorc贸w"

#: src/SUMMARY.md:90
msgid "Health Statistics"
msgstr "Statystyki zdrowia"

#: src/SUMMARY.md:91
msgid "Points and Polygons"
msgstr "Punkty i wielokty"

#: src/SUMMARY.md:93
msgid "Day 2: Afternoon"
msgstr "Dzie 2: Popoudnie"

#: src/SUMMARY.md:95
msgid "Control Flow"
msgstr "Kontrola przepywu"

#: src/SUMMARY.md:96
msgid "Blocks"
msgstr "Bloki"

#: src/SUMMARY.md:97
msgid "if expressions"
msgstr "Wyra偶enia if"

#: src/SUMMARY.md:98
msgid "if let expressions"
msgstr "Wyra偶enia if let"

#: src/SUMMARY.md:99
msgid "while expressions"
msgstr "Wyra偶enia while"

#: src/SUMMARY.md:100
msgid "while let expressions"
msgstr "Wyra偶enia while let"

#: src/SUMMARY.md:101
msgid "for expressions"
msgstr "Wyra偶enia for"

#: src/SUMMARY.md:102
msgid "loop expressions"
msgstr "Wyra偶enia loop"

#: src/SUMMARY.md:103
msgid "match expressions"
msgstr "Wyra偶enia match"

#: src/SUMMARY.md:104
msgid "break & continue"
msgstr "break i continue"

#: src/SUMMARY.md:105
msgid "Standard Library"
msgstr "Biblioteka standardowa"

#: src/SUMMARY.md:106
msgid "Option and Result"
msgstr "Option i Result"

#: src/SUMMARY.md:107
msgid "String"
msgstr "String"

#: src/SUMMARY.md:108
msgid "Vec"
msgstr "Vec"

#: src/SUMMARY.md:109
msgid "HashMap"
msgstr "HashMap"

#: src/SUMMARY.md:110
msgid "Box"
msgstr "Box"

#: src/SUMMARY.md:111
msgid "Recursive Data Types"
msgstr "Rekurencyjne typy danych"

#: src/SUMMARY.md:112
msgid "Niche Optimization"
msgstr "Niszowa optymalizacja"

#: src/SUMMARY.md:113
msgid "Rc"
msgstr "Rc"

#: src/SUMMARY.md:114
msgid "Modules"
msgstr "Moduy"

#: src/SUMMARY.md:115
msgid "Visibility"
msgstr "Widoczno"

#: src/SUMMARY.md:116
msgid "Paths"
msgstr "cie偶ki"

#: src/SUMMARY.md:117
msgid "Filesystem Hierarchy"
msgstr "Hierarchia systemu plik贸w"

#: src/SUMMARY.md:119
msgid "Luhn Algorithm"
msgstr "Algorytm Luhna"

#: src/SUMMARY.md:120
msgid "Strings and Iterators"
msgstr "acuchy i iteratory"

#: src/SUMMARY.md:123
msgid "Day 3: Morning"
msgstr "Dzie 3: Rano"

#: src/SUMMARY.md:128
msgid "Traits"
msgstr "Cechy"

#: src/SUMMARY.md:129
msgid "Deriving Traits"
msgstr "Wyprowadzanie cech"

#: src/SUMMARY.md:130
msgid "Default Methods"
msgstr "Metody domylne"

#: src/SUMMARY.md:131
msgid "Important Traits"
msgstr "Wa偶ne cechy"

#: src/SUMMARY.md:132
msgid "Iterator"
msgstr "Iterator"

#: src/SUMMARY.md:133
msgid "FromIterator"
msgstr "FromIterator"

#: src/SUMMARY.md:134
msgid "From and Into"
msgstr "From i Into"

#: src/SUMMARY.md:135
msgid "Read and Write"
msgstr "Read i Write"

#: src/SUMMARY.md:136
msgid "Add, Mul, ..."
msgstr "Add, Mul, ..."

#: src/SUMMARY.md:137
msgid "Drop"
msgstr "Drop"

#: src/SUMMARY.md:138
msgid "Default"
msgstr "Default"

#: src/SUMMARY.md:139
msgid "Generics"
msgstr "Generyki"

#: src/SUMMARY.md:140
msgid "Generic Data Types"
msgstr "Generyczne typy danych"

#: src/SUMMARY.md:141
msgid "Generic Methods"
msgstr "Metody generyczne"

#: src/SUMMARY.md:142
#, fuzzy
msgid "Trait Bounds"
msgstr "Granice cech"

#: src/SUMMARY.md:143
msgid "impl Trait"
msgstr "Skadnia impl Cecha"

#: src/SUMMARY.md:144
msgid "Closures"
msgstr "Domknicia"

#: src/SUMMARY.md:145
msgid "Monomorphization"
msgstr "Monomorfizacja"

#: src/SUMMARY.md:146
#, fuzzy
msgid "Trait Objects"
msgstr "Obiekty cech"

#: src/SUMMARY.md:148
msgid "A Simple GUI Library"
msgstr "Prosta biblioteka GUI"

#: src/SUMMARY.md:150
msgid "Day 3: Afternoon"
msgstr "Dzie 3: Popoudnie"

#: src/SUMMARY.md:152
msgid "Error Handling"
msgstr "Obsuga bd贸w"

#: src/SUMMARY.md:153
msgid "Panics"
msgstr "Panikowanie"

#: src/SUMMARY.md:154
msgid "Catching Stack Unwinding"
msgstr "apanie rozwinicia stosu"

#: src/SUMMARY.md:155
msgid "Structured Error Handling"
msgstr "Strukturalna obsuga bd贸w"

#: src/SUMMARY.md:156
msgid "Propagating Errors with ?"
msgstr "Propagowanie bd贸w za pomoc ?"

#: src/SUMMARY.md:157
msgid "Converting Error Types"
msgstr "Konwersja typ贸w bd贸w"

#: src/SUMMARY.md:159
#, fuzzy
msgid "Deriving Error Enums"
msgstr "Wyprowadzanie wylicze bd贸w"

#: src/SUMMARY.md:160
msgid "Dynamic Error Types"
msgstr "Dynamiczne typy bd贸w"

#: src/SUMMARY.md:161
msgid "Adding Context to Errors"
msgstr "Dodawanie kontekstu do bd贸w"

#: src/SUMMARY.md:162
msgid "Testing"
msgstr "Testowanie"

#: src/SUMMARY.md:163
msgid "Unit Tests"
msgstr "Testy jednostkowe"

#: src/SUMMARY.md:164
msgid "Test Modules"
msgstr "Moduy testowe"

#: src/SUMMARY.md:165
msgid "Documentation Tests"
msgstr "Testy dokumentacyjne"

#: src/SUMMARY.md:166
msgid "Integration Tests"
msgstr "Testy integracyjne"

#: src/SUMMARY.md:167
msgid "Unsafe Rust"
msgstr "Niebezpieczny Rust"

#: src/SUMMARY.md:168
#, fuzzy
msgid "Dereferencing Raw Pointers"
msgstr "Dereferencja surowych wska藕nik贸w"

#: src/SUMMARY.md:169
msgid "Mutable Static Variables"
msgstr "Mutowalne zmienne statyczne"

#: src/SUMMARY.md:170
msgid "Unions"
msgstr "Unie"

#: src/SUMMARY.md:171
msgid "Calling Unsafe Functions"
msgstr "Wywoywanie niebezpiecznych funkcji"

#: src/SUMMARY.md:172
msgid "Writing Unsafe Functions"
msgstr "Pisanie niebezpiecznych funkcji"

#: src/SUMMARY.md:173
msgid "Extern Functions"
msgstr "Funkcje zewntrzne"

#: src/SUMMARY.md:174
#, fuzzy
msgid "Implementing Unsafe Traits"
msgstr "Wdra偶anie niebezpiecznych cech"

#: src/SUMMARY.md:176
msgid "Safe FFI Wrapper"
msgstr "Bezpieczne opakowanie FFI"

#: src/SUMMARY.md:179
msgid "Day 4: Morning"
msgstr "Dzie 4: Rano"

#: src/SUMMARY.md:184
msgid "Concurrency"
msgstr "Wsp贸bie偶no"

#: src/SUMMARY.md:185
msgid "Threads"
msgstr "Wtki"

#: src/SUMMARY.md:186
msgid "Scoped Threads"
msgstr "Wtki z zakresem"

#: src/SUMMARY.md:187
msgid "Channels"
msgstr "Kanay"

#: src/SUMMARY.md:188
msgid "Unbounded Channels"
msgstr "Nieograniczone kanay"

#: src/SUMMARY.md:189
msgid "Bounded Channels"
msgstr "Ograniczone kanay"

#: src/SUMMARY.md:190
msgid "Shared State"
msgstr "Wsp贸dzielony stan"

#: src/SUMMARY.md:191
msgid "Arc"
msgstr "Arc"

#: src/SUMMARY.md:192
msgid "Mutex"
msgstr "Mutex"

#: src/SUMMARY.md:194
msgid "Send and Sync"
msgstr "Send i Sync"

#: src/SUMMARY.md:194
msgid "Send"
msgstr "Send"

#: src/SUMMARY.md:194
msgid "Sync"
msgstr "Sync"

#: src/SUMMARY.md:197
msgid "Examples"
msgstr "Przykady"

#: src/SUMMARY.md:199
msgid "Dining Philosophers"
msgstr "Ucztujcy filozofowie"

#: src/SUMMARY.md:200
msgid "Multi-threaded Link Checker"
msgstr "Wielowtkowe narzdzie do sprawdzania link贸w"

#: src/SUMMARY.md:202
msgid "Day 4: Afternoon"
msgstr "Dzie 4: Popoudnie"

#: src/SUMMARY.md:206
msgid "Android"
msgstr "Android"

#: src/SUMMARY.md:207
msgid "Setup"
msgstr "Przygotowanie"

#: src/SUMMARY.md:208
msgid "Build Rules"
msgstr "Reguy budowania"

#: src/SUMMARY.md:209
msgid "Binary"
msgstr "Pliki binarne"

#: src/SUMMARY.md:210
msgid "Library"
msgstr "Biblioteka"

#: src/SUMMARY.md:211
msgid "AIDL"
msgstr "AIDL"

#: src/SUMMARY.md:212
msgid "Interface"
msgstr "Interfejs"

#: src/SUMMARY.md:213
msgid "Implementation"
msgstr "Implementacja"

#: src/SUMMARY.md:214
msgid "Server"
msgstr "Serwer"

#: src/SUMMARY.md:215
msgid "Deploy"
msgstr "Wdra偶anie"

#: src/SUMMARY.md:216
msgid "Client"
msgstr "Klient"

#: src/SUMMARY.md:217
msgid "Changing API"
msgstr "Zmiana API"

#: src/SUMMARY.md:218
msgid "Logging"
msgstr "Logowanie"

#: src/SUMMARY.md:219
msgid "Interoperability"
msgstr "Interoperacyjno"

#: src/SUMMARY.md:220
msgid "With C"
msgstr "Z jzykiem C"

#: src/SUMMARY.md:221
msgid "Calling C with Bindgen"
msgstr "Wywoanie C z Bindgenem"

#: src/SUMMARY.md:222
msgid "Calling Rust from C"
msgstr "Wywoanie Rusta z C"

#: src/SUMMARY.md:223
msgid "With C++"
msgstr "Z jzykiem C++"

#: src/SUMMARY.md:224
msgid "With Java"
msgstr "Z Jav"

#: src/SUMMARY.md:227
msgid "Final Words"
msgstr "Ostatnie sowa"

#: src/SUMMARY.md:229
msgid "Thanks!"
msgstr "Dziki!"

#: src/SUMMARY.md:230
msgid "Other Resources"
msgstr "Inne zasoby"

#: src/SUMMARY.md:231
msgid "Credits"
msgstr "Uznania"

#: src/SUMMARY.md:235
msgid "Solutions"
msgstr "Rozwizania"

#: src/SUMMARY.md:240
msgid "Day 1 Morning"
msgstr "Dzie 1 Rano"

#: src/SUMMARY.md:241
msgid "Day 1 Afternoon"
msgstr "Dzie 1 Popoudnie"

#: src/SUMMARY.md:242
msgid "Day 2 Morning"
msgstr "Dzie 2 Rano"

#: src/SUMMARY.md:243
msgid "Day 2 Afternoon"
msgstr "Dzie 2 Popoudnie"

#: src/SUMMARY.md:244
msgid "Day 3 Morning"
msgstr "Dzie 3 Rano"

#: src/SUMMARY.md:245
msgid "Day 3 Afternoon"
msgstr "Dzie 3 Popoudnie"

#: src/SUMMARY.md:246
msgid "Day 4 Morning"
msgstr "Dzie 4 Rano"

#: src/welcome.md:1
msgid "# Welcome to Comprehensive Rust "
msgstr "# Witamy w Comprehensive Rust "

#: src/welcome.md:3
msgid ""
"This is a four day Rust course developed by the Android team. The course "
"covers\n"
"the full spectrum of Rust, from basic syntax to advanced topics like "
"generics\n"
"and error handling. It also includes Android-specific content on the last "
"day."
msgstr ""
"To jest czterodniowy kurs Rust opracowany przez zesp贸 Androida. Kurs "
"obejmuje\n"
"pene spektrum Rusta, od podstawowej skadni po zaawansowane tematy, takie "
"jak programowanie uog贸lnione\n"
"i obsug bd贸w. Ostatni dzie obejmuje r贸wnie偶 treci specyficzne dla "
"Androida."

#: src/welcome.md:7
msgid ""
"The goal of the course is to teach you Rust. We assume you don't know "
"anything\n"
"about Rust and hope to:"
msgstr ""
"Celem kursu jest nauczenie Ci jzyka Rust. Zakadamy, 偶e nic nie wiesz\n"
"o Rucie i mamy nadziej, 偶e:"

#: src/welcome.md:10
msgid ""
"* Give you a comprehensive understanding of the Rust syntax and language.\n"
"* Enable you to modify existing programs and write new programs in Rust.\n"
"* Show you common Rust idioms."
msgstr ""
"* Damy Ci kompleksowe zrozumienie skadni i jzyka Rust.\n"
"* Umo偶liwimy modyfikowanie istniejcych program贸w i pisanie nowych program贸w "
"w Rucie.\n"
"* Poka偶emy powszechne idiomy Rusta."

#: src/welcome.md:14
msgid "On Day 4, we will cover Android-specific things such as:"
msgstr "W dniu 4 om贸wimy kwestie specyficzne dla Androida, takie jak:"

#: src/welcome.md:16
msgid ""
"* Building Android components in Rust.\n"
"* AIDL servers and clients.\n"
"* Interoperability with C, C++, and Java."
msgstr ""
"* Budowanie komponent贸w Androida w Rucie.\n"
"* Serwery i klienty AIDL.\n"
"* Interoperacyjno z C, C++ i Jav."

#: src/welcome.md:20
msgid ""
"It is important to note that this course does not cover Android "
"**application** \n"
"development in Rust, and that the Android-specific parts are specifically "
"about\n"
"writing code for Android itself, the operating system. "
msgstr ""
"Nale偶y zauwa偶y, 偶e ten kurs nie obejmuje rozwoju **aplikacji** na Androida\n"
"w Rucie i 偶e czci specyficzne dla Androida s o pisaniu kodu\n"
"dla samego Androida, systemu operacyjnego. "

#: src/welcome.md:24
msgid "## Non-Goals"
msgstr "## Poza zakresem"

#: src/welcome.md:26
msgid ""
"Rust is a large language and we won't be able to cover all of it in a few "
"days.\n"
"Some non-goals of this course are:"
msgstr ""
"Rust to du偶y jzyk i nie bdziemy w stanie om贸wi go w caoci w cigu kilku "
"dni.\n"
"Niekt贸re cele bdce poza zakresem tego kursu to:"

#: src/welcome.md:29
msgid ""
"* Learn how to use async Rust --- we'll only mention async Rust when\n"
"  covering traditional concurrency primitives. Please see [Asynchronous\n"
"  Programming in Rust](https://rust-lang.github.io/async-book/) instead for\n"
"  details on this topic.\n"
"* Learn how to develop macros, please see [Chapter 19.5 in the Rust\n"
"  Book](https://doc.rust-lang.org/book/ch19-06-macros.html) and [Rust by\n"
"  Example](https://doc.rust-lang.org/rust-by-example/macros.html) instead."
msgstr ""
"* U偶ywanie asynchronicznego Rusta --- wspomnimy o asynchronicznym Rucie "
"tylko wtedy, gdy\n"
"  obejmujce tradycyjne prymitywy wsp贸bie偶noci. Po wicej szczeg贸贸w w tym "
"temacie zobacz [Asynchronous\n"
"  Programming in Rust](https://rust-lang.github.io/async-book/).\n"
"* Tworzenie makr, zamiast tego zobacz [Rozdzia 19.5 w Jzyk Programowanie "
"Rust](http://rust.w8.pl/book/ch19-06-macros.html) i [Rust by\n"
"  Example](https://doc.rust-lang.org/rust-by-example/macros.html)."

#: src/welcome.md:37
msgid "## Assumptions"
msgstr "## Zao偶enia"

#: src/welcome.md:39
msgid ""
"The course assumes that you already know how to program. Rust is a "
"statically\n"
"typed language and we will sometimes make comparisons with C and C++ to "
"better\n"
"explain or contrast the Rust approach."
msgstr ""
"Kurs zakada, 偶e wiesz ju偶, jak programowa. Rust to statycznie\n"
"typowany jzyk i aby byo lepiej wyjani lub przeciwstawi podejcie Rusta\n"
"czasami bdziemy dokonywa por贸wna z C i C++."

#: src/welcome.md:43
msgid ""
"If you know how to program in a dynamically typed language such as Python "
"or\n"
"JavaScript, then you will be able to follow along just fine too."
msgstr ""
"Jeli wiesz, jak programowa w jzyku o dynamicznym typowaniu, takim jak "
"Python lub\n"
"JavaScript, to te偶 dasz sobie rad."

#: src/welcome.md:46 src/cargo/rust-ecosystem.md:19 src/cargo/code-samples.md:22
#: src/cargo/running-locally.md:68 src/welcome-day-1.md:14 src/welcome-day-1/what-is-rust.md:19
#: src/hello-world.md:20 src/hello-world/small-example.md:21 src/why-rust.md:9
#: src/why-rust/compile-time.md:14 src/why-rust/runtime.md:8 src/why-rust/modern.md:19
#: src/basic-syntax/compound-types.md:28 src/basic-syntax/slices.md:18
#: src/basic-syntax/string-slices.md:25 src/basic-syntax/functions.md:33
#: src/basic-syntax/functions-interlude.md:25 src/exercises/day-1/morning.md:9
#: src/exercises/day-1/for-loops.md:90 src/basic-syntax/variables.md:15
#: src/basic-syntax/type-inference.md:24 src/basic-syntax/static-and-const.md:46
#: src/basic-syntax/scopes-shadowing.md:23 src/memory-management/stack.md:26
#: src/memory-management/rust.md:12 src/ownership/move-semantics.md:20
#: src/ownership/moves-function-calls.md:18 src/ownership/copy-clone.md:33
#: src/ownership/borrowing.md:25 src/ownership/shared-unique-borrows.md:23
#: src/ownership/lifetimes-function-calls.md:27 src/ownership/lifetimes-data-structures.md:23
#: src/exercises/day-1/afternoon.md:9 src/structs/tuple-structs.md:35
#: src/structs/field-shorthand.md:25 src/enums/variant-payloads.md:33 src/methods.md:28
#: src/pattern-matching/destructuring-enums.md:33 src/pattern-matching/destructuring-arrays.md:19
#: src/pattern-matching/match-guards.md:20 src/exercises/day-2/morning.md:9
#: src/exercises/day-2/points-polygons.md:115 src/control-flow/blocks.md:40
#: src/control-flow/if-expressions.md:29 src/control-flow/if-let-expressions.md:19
#: src/control-flow/while-let-expressions.md:25 src/control-flow/match-expressions.md:25
#: src/std/option-result.md:16 src/std/string.md:28 src/std/vec.md:35 src/std/hashmap.md:36
#: src/std/box.md:32 src/std/box-recursive.md:31 src/std/rc.md:29 src/modules.md:26
#: src/modules/visibility.md:37 src/modules/filesystem.md:24 src/exercises/day-2/afternoon.md:5
#: src/traits.md:39 src/traits/iterator.md:30 src/traits/from-iterator.md:15
#: src/traits/operators.md:24 src/traits/drop.md:32 src/traits/default.md:38
#: src/generics/methods.md:23 src/generics/trait-bounds.md:33 src/generics/impl-trait.md:22
#: src/generics/closures.md:23 src/exercises/day-3/morning.md:5 src/error-handling/result.md:25
#: src/error-handling/try-operator.md:48 src/error-handling/converting-error-types-example.md:48
#: src/error-handling/deriving-error-enums.md:37 src/error-handling/dynamic-errors.md:34
#: src/error-handling/error-contexts.md:33 src/unsafe.md:26 src/unsafe/raw-pointers.md:24
#: src/unsafe/mutable-static-variables.md:30 src/unsafe/unions.md:19
#: src/unsafe/writing-unsafe-functions.md:31 src/unsafe/extern-functions.md:19
#: src/unsafe/unsafe-traits.md:28 src/exercises/day-3/afternoon.md:5 src/concurrency/threads.md:28
#: src/concurrency/channels.md:25 src/concurrency/shared_state/arc.md:27
#: src/concurrency/shared_state/example.md:21 src/concurrency/send-sync.md:18
#: src/concurrency/send-sync/sync.md:12 src/exercises/day-4/morning.md:10
#: src/android/interoperability/with-c/rust.md:81 src/exercises/day-4/afternoon.md:10
msgid "<details>"
msgstr "<details>"

#: src/welcome.md:48
msgid ""
"This is an example of a _speaker note_. We will use these to add additional\n"
"information to the slides. This could be key points which the instructor "
"should\n"
"cover as well as answers to typical questions which come up in class."
msgstr ""
"To jest przykad _notatki dla prowadzcego_. U偶yjemy ich, aby doda "
"dodatkowe\n"
"informacje do slajd贸w. Mog to by kluczowe punkty, kt贸re prowadzcy "
"powinien\n"
"om贸wi, a tak偶e odpowiedzi na typowe pytania, kt贸re pojawiaj si na "
"zajciach."

#: src/welcome.md:52 src/cargo/rust-ecosystem.md:67 src/cargo/code-samples.md:35
#: src/cargo/running-locally.md:74 src/welcome-day-1.md:42 src/welcome-day-1/what-is-rust.md:29
#: src/hello-world.md:36 src/hello-world/small-example.md:44 src/why-rust.md:24
#: src/why-rust/compile-time.md:35 src/why-rust/runtime.md:22 src/why-rust/modern.md:66
#: src/basic-syntax/compound-types.md:62 src/basic-syntax/references.md:28
#: src/basic-syntax/slices.md:36 src/basic-syntax/functions.md:54 src/exercises/day-1/morning.md:28
#: src/exercises/day-1/for-loops.md:95 src/basic-syntax/variables.md:20
#: src/basic-syntax/type-inference.md:48 src/basic-syntax/static-and-const.md:52
#: src/basic-syntax/scopes-shadowing.md:39 src/memory-management/stack.md:49
#: src/memory-management/rust.md:18 src/ownership/move-semantics.md:26
#: src/ownership/moves-function-calls.md:26 src/ownership/borrowing.md:51
#: src/ownership/shared-unique-borrows.md:29 src/ownership/lifetimes-function-calls.md:60
#: src/exercises/day-1/afternoon.md:15 src/exercises/day-1/book-library.md:103 src/structs.md:41
#: src/structs/field-shorthand.md:41 src/enums/sizes.md:136 src/methods/example.md:53
#: src/pattern-matching/destructuring-enums.md:39 src/pattern-matching/destructuring-arrays.md:46
#: src/exercises/day-2/morning.md:15 src/exercises/day-2/points-polygons.md:125
#: src/control-flow/if-let-expressions.md:26 src/control-flow/for-expressions.md:29
#: src/control-flow/loop-expressions.md:27 src/std.md:31 src/std/option-result.md:25
#: src/std/string.md:40 src/std/vec.md:49 src/std/hashmap.md:66 src/std/rc.md:66 src/modules.md:32
#: src/modules/visibility.md:48 src/modules/filesystem.md:53 src/exercises/day-2/afternoon.md:11
#: src/traits.md:54 src/traits/from-iterator.md:26 src/traits/operators.md:38 src/traits/drop.md:42
#: src/traits/default.md:47 src/generics/methods.md:31 src/generics/closures.md:38
#: src/exercises/day-3/morning.md:11 src/error-handling/try-operator.md:55
#: src/error-handling/converting-error-types-example.md:60
#: src/error-handling/deriving-error-enums.md:45 src/error-handling/dynamic-errors.md:41
#: src/error-handling/error-contexts.md:42 src/unsafe.md:32 src/unsafe/raw-pointers.md:42
#: src/unsafe/mutable-static-variables.md:35 src/unsafe/unions.md:28
#: src/unsafe/writing-unsafe-functions.md:38 src/unsafe/extern-functions.md:28
#: src/unsafe/unsafe-traits.md:37 src/exercises/day-3/afternoon.md:11 src/concurrency/threads.md:45
#: src/concurrency/channels.md:32 src/concurrency/shared_state/arc.md:38
#: src/concurrency/shared_state/example.md:60 src/concurrency/send-sync/sync.md:18
#: src/exercises/day-4/morning.md:16 src/android/interoperability/with-c/rust.md:86
#: src/exercises/day-4/afternoon.md:15
msgid "</details>"
msgstr "</details>"

#: src/running-the-course.md:1
msgid "# Running the Course"
msgstr "# Prowadzenie kursu"

#: src/running-the-course.md:3 src/running-the-course/course-structure.md:3
msgid "> This page is for the course instructor."
msgstr "> Ta strona jest dla prowadzcego kurs."

#: src/running-the-course.md:5
msgid ""
"Here is a bit of background information about how we've been running the "
"course\n"
"internally at Google."
msgstr ""
"Oto troch podstawowych informacji o tym, jak prowadzilimy ten kurs\n"
"wewntrznie w Google."

#: src/running-the-course.md:8
msgid "To run the course, you need to:"
msgstr "Aby prowadzi kurs nale偶y:"

#: src/running-the-course.md:10
msgid ""
"1. Make yourself familiar with the course material. We've included speaker "
"notes\n"
"   on some of the pages to help highlight the key points (please help us by\n"
"   contributing more speaker notes!). You should make sure to open the "
"speaker\n"
"   notes in a popup (click the link with a little arrow next to \"Speaker\n"
"   Notes\"). This way you have a clean screen to present to the class."
msgstr ""
"1. Zapoznaj si z materiaem kursu. Doczylimy notatki prowadzcego\n"
"   na niekt贸rych stronach, aby podkreli kluczowe punkty (pom贸偶 nam "
"dodajc\n"
"   wicej notatek dla prowadzcego!). Powiniene upewni si, 偶e notatki s "
"otwarte\n"
"   w wyskakujcym okienku (kliknij cze z ma strzak obok Notatki\n"
"   Prowadzcego\"). W ten spos贸b masz czysty ekran do zaprezentowania klasie."

#: src/running-the-course.md:16
msgid ""
"2. Decide on the dates. Since the course is large, we recommend that you\n"
"   schedule the four days over two weeks. Course participants have said "
"that\n"
"   they find it helpful to have a gap in the course since it helps them "
"process\n"
"   all the information we give them."
msgstr ""
"2. Zdecyduj o datach. Poniewa偶 kurs jest du偶y, zalecamy\n"
"   zaplanowanie czterech dni w przecigu dw贸ch tygodni. Uczestnicy kursu\n"
"   uwa偶aj, 偶e luka w kursie jest pomocna, poniewa偶 pomaga im przetworzy\n"
"   wszystkie informacje, kt贸re im przekazujemy."

#: src/running-the-course.md:21
msgid ""
"3. Find a room large enough for your in-person participants. We recommend a\n"
"   class size of 15-20 people. That's small enough that people are "
"comfortable\n"
"   asking questions --- it's also small enough that one instructor will "
"have\n"
"   time to answer the questions."
msgstr ""
"3. Znajd藕 pok贸j wystarczajco du偶y dla uczestnik贸w. Polecamy\n"
"   grupy w wielkoci 15-20 os贸b. To na tyle mao, 偶e ludzie czuj si "
"komfortowo\n"
"   w zadawaniu pyta --- jest r贸wnie偶 na tyle mao, 偶e jeden prowadzcy "
"bdzie mia\n"
"   czas na odpowiedzenie na pytania."

#: src/running-the-course.md:26
msgid ""
"4. On the day of your course, show up to the room a little early to set "
"things\n"
"   up. We recommend presenting directly using `mdbook serve` running on "
"your\n"
"   laptop (see the [installation instructions][5]). This ensures optimal "
"performance with no lag as you change pages.\n"
"   Using your laptop will also allow you to fix typos as you or the course\n"
"   participants spot them."
msgstr ""
"4. W dniu kursu przyjd藕 na sal nieco wczeniej, aby wszystko ustawi.\n"
"   Zalecamy prezentacj bezporednio przy u偶yciu `mdbook serve` "
"uruchomionego na twoim\n"
"   laptopie (zobacz [instrukcja instalacji][5]). Zapewnia to optymaln "
"wydajno bez op贸藕nie podczas zmiany stron.\n"
"   Korzystanie z laptopa pozwoli Ci r贸wnie偶 poprawia liter贸wki jak ty lub "
"uczestnicy kursu\n"
"   je dostrzeg."

#: src/running-the-course.md:32
msgid ""
"5. Let people solve the exercises by themselves or in small groups. Make "
"sure to\n"
"   ask people if they're stuck or if there is anything you can help with. "
"When\n"
"   you see that several people have the same problem, call it out to the "
"class\n"
"   and offer a solution, e.g., by showing people where to find the relevant\n"
"   information in the standard library."
msgstr ""
"5. Pozw贸l uczestnikom rozwizywa wiczenia samodzielnie lub w maych "
"grupach. Upewnij si,\n"
"   偶e pytasz uczestnik贸w, czy utknli lub czy jest co, w czym mo偶esz pom贸c. "
"Gdy\n"
"   widzisz, 偶e kilka os贸b ma ten sam problem, powiedz o tym klasie\n"
"   i zaoferuj rozwizanie, np. pokazujc gdzie znale藕 odpowiednie\n"
"   informacje w bibliotece standardowej."

#: src/running-the-course.md:38
msgid ""
"6. If you don't skip the Android specific parts on Day 4, you will need an "
"[AOSP\n"
"   checkout][1]. Make a checkout of the [course repository][2] on the same\n"
"   machine and move the `src/android/` directory into the root of your AOSP\n"
"   checkout. This will ensure that the Android build system sees the\n"
"   `Android.bp` files in `src/android/`."
msgstr ""
"6. Jeli nie pomijasz czci zwizanych z Androidem w dniu 4, bdziesz "
"potrzebowa [AOSP][1].\n"
"   cignij [repozytorium kursu][2] na tym samym komputerze\n"
"   i przenie katalog `src/android/` do katalogu g贸wnego AOSP.\n"
"   Zapewni to, 偶e system kompilacji Androida zobaczy pliki\n"
"   `Android.bp` w `src/android/`."

#: src/running-the-course.md:44
msgid ""
"   Ensure that `adb sync` works with your emulator or real device and "
"pre-build\n"
"   all Android examples using `src/android/build_all.sh`. Read the script to "
"see\n"
"   the commands it runs and make sure they work when you run them by hand."
msgstr ""
"   Upewnij si, 偶e `adb sync` dziaa z twoim emulatorem lub prawdziwym "
"urzdzeniem i prekompiluj\n"
"   wszystkie przykady Androida u偶ywajc `src/android/build_all.sh`. "
"Przeczytaj skrypt, 偶eby zobaczy\n"
"   polecenia, kt贸re uruchamia, i upewnij si, 偶e dziaaj, gdy uruchamiasz "
"je rcznie."

#: src/running-the-course.md:48
msgid ""
"That is all, good luck running the course! We hope it will be as much fun "
"for\n"
"you as it has been for us!"
msgstr ""
"To wszystko, powodzenia w prowadzeniu kursu! Mamy nadziej, 偶e bdzie to dla "
"Ciebie r贸wnie zabawne\n"
"jak dla nas!"

#: src/running-the-course.md:51
msgid ""
"Please [provide feedback][3] afterwards so that we can keep improving the\n"
"course. We would love to hear what worked well for you and what can be made\n"
"better. Your students are also very welcome to [send us feedback][4]!"
msgstr ""
"Prosimy o p贸藕niejsze [przekazanie opinii][3], abymy mogli dalej ulepsza\n"
"kurs. Chtnie dowiemy si, co sprawdzio si u Ciebie, a co mo偶na ulepszy.\n"
"Uczestnik贸w r贸wnie偶 zachcamy do [przesania nam swoich opinii][4]!"

#: src/running-the-course.md:55
msgid ""
"[1]: https://source.android.com/docs/setup/download/downloading\n"
"[2]: https://github.com/google/comprehensive-rust\n"
"[3]: https://github.com/google/comprehensive-rust/discussions/86\n"
"[4]: https://github.com/google/comprehensive-rust/discussions/100\n"
"[5]: https://github.com/google/comprehensive-rust#building"
msgstr ""
"[1]: https://source.android.com/docs/setup/download/downloading\n"
"[2]: https://github.com/google/comprehensive-rust\n"
"[3]: https://github.com/google/comprehensive-rust/discussions/86\n"
"[4]: https://github.com/google/comprehensive-rust/discussions/100\n"
"[5]: https://github.com/google/comprehensive-rust#building"

#: src/running-the-course/course-structure.md:1
msgid "# Course Structure"
msgstr "# Struktura kursu"

#: src/running-the-course/course-structure.md:5
msgid "The course is fast paced and covers a lot of ground:"
msgstr "Kurs jest prowadzony w szybkim tempie i obejmuje du偶o materiau:"

#: src/running-the-course/course-structure.md:7
msgid ""
"* Day 1: Basic Rust, ownership and the borrow checker.\n"
"* Day 2: Compound data types,  pattern matching, the standard library.\n"
"* Day 3: Traits and generics, error handling, testing, unsafe Rust.\n"
"* Day 4: Concurrency in Rust and interoperability with other languages"
msgstr ""
"* Dzie 1: Podstawowy Rust, wasno i nadzorca po偶yczania.\n"
"* Dzie 2: Typy danych zo偶onych, dopasowywanie wzorc贸w, biblioteka "
"standardowa.\n"
"* Dzie 3: Cechy i uog贸lnienia, obsuga bd贸w, testowanie, niebezpieczny "
"Rust.\n"
"* Dzie 4: Wsp贸bie偶no w Rucie i interoperacyjno z innymi jzykami"

#: src/running-the-course/course-structure.md:12
msgid ""
"> **Exercise for Day 4:** Do you interface with some C/C++ code in your "
"project\n"
"> which we could attempt to move to Rust? The fewer dependencies the "
"better.\n"
"> Parsing code would be ideal."
msgstr ""
"> **wiczenie na dzie 4:** Czy korzystasz z kodu C/C++ w swoim projekcie,\n"
"> kt贸ry moglibymy spr贸bowa przenie do Rusta? Im mniej zale偶noci, tym "
"lepiej.\n"
"> Kod parsujcy byby idealny."

#: src/running-the-course/course-structure.md:16
msgid "## Format"
msgstr "## Format"

#: src/running-the-course/course-structure.md:18
msgid ""
"The course is meant to be very interactive and we recommend letting the\n"
"questions drive the exploration of Rust!"
msgstr ""
"Kurs ma by bardzo interaktywny i zalecamy pozwalanie\n"
"偶eby pytania napdzay eksploracj Rusta!"

#: src/running-the-course/keyboard-shortcuts.md:1
msgid "# Keyboard Shortcuts"
msgstr "# Skr贸ty klawiszowe"

#: src/running-the-course/keyboard-shortcuts.md:3
msgid "There are several useful keyboard shortcuts in mdBook:"
msgstr "Istnieje kilka przydatnych skr贸t贸w klawiaturowych w mdBook:"

#: src/running-the-course/keyboard-shortcuts.md:5
msgid ""
"* <kbd>Arrow-Left</kbd>: Navigate to the previous page.\n"
"* <kbd>Arrow-Right</kbd>: Navigate to the next page.\n"
"* <kbd>Ctrl + Enter</kbd>: Execute the code sample that has focus.\n"
"* <kbd>s</kbd>: Activate the search bar."
msgstr ""
"* <kbd>Strzaka w lewo</kbd>: Przejd藕 do poprzedniej strony.\n"
"* <kbd>Strzaka w prawo</kbd>: Przejd藕 do nastpnej strony.\n"
"* <kbd>Ctrl + Enter</kbd>: Wykonaj przykadowy kod, kt贸ry ma fokus.\n"
"* <kbd>s</kbd>: Aktywuj pasek wyszukiwania."

#: src/running-the-course/translations.md:1
msgid "# Translations"
msgstr "# Tumaczenia"

#: src/running-the-course/translations.md:3
msgid ""
"The course has been translated into other languages by a set of wonderful\n"
"volunteers:"
msgstr ""
"Kurs zosta przetumaczony na inne jzyki przez zesp贸 cudownych\n"
"wolontariuszy:"

#: src/running-the-course/translations.md:6
msgid ""
"* [Brazilian Portuguese][pt-BR] by [@rastringer] and [@hugojacob].\n"
"* [Korean][ko] by [@keispace], [@jiyongp] and [@jooyunghan]."
msgstr ""
"* [brazylijski portugalski][pt-BR] autorstwa [@rastringer] i [@hugojacob].\n"
"* [koreaski][ko] autorstwa [@keispace], [@jiyongp] i [@jooyunghan]."

#: src/running-the-course/translations.md:9
msgid ""
"Use the language picker in the top-right corner to switch between languages."
msgstr ""
"U偶yj selektora jzyka w prawym g贸rnym rogu, aby przecza si midzy "
"jzykami."

#: src/running-the-course/translations.md:11
msgid ""
"If you want to help with this effort, please see [our instructions] for how "
"to\n"
"get going. Translations are coordinated on the [issue tracker]."
msgstr ""
"Jeli chcesz w tym pom贸c, zapoznaj si z [naszymi instrukcjami] aby "
"dowiedzie si, jak to zacz.\n"
"Tumaczenia s koordynowane w [narzdziu do ledzenia problem贸w]."

#: src/running-the-course/translations.md:14
msgid ""
"[pt-BR]: https://google.github.io/comprehensive-rust/pt-BR/\n"
"[ko]: https://google.github.io/comprehensive-rust/ko/\n"
"[@rastringer]: https://github.com/rastringer\n"
"[@hugojacob]: https://github.com/hugojacob\n"
"[@keispace]: https://github.com/keispace\n"
"[@jiyongp]: https://github.com/jiyongp\n"
"[@jooyunghan]: https://github.com/jooyunghan\n"
"[our instructions]: "
"https://github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md\n"
"[issue tracker]: https://github.com/google/comprehensive-rust/issues/282"
msgstr ""
"[pt-BR]: https://google.github.io/comprehensive-rust/pt-BR/\n"
"[ko]: https://google.github.io/comprehensive-rust/ko/\n"
"[@rastringer]: https://github.com/rastringer\n"
"[@hugojacob]: https://github.com/hugojacob\n"
"[@keispace]: https://github.com/keispace\n"
"[@jiyongp]: https://github.com/jiyongp\n"
"[@jooyunghan]: https://github.com/jooyunghan\n"
"[naszymi instrukcjami]: "
"https://github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md\n"
"[narzdziu do ledzenia problem贸w]: "
"https://github.com/google/comprehensive-rust/issues/282"

#: src/cargo.md:1
msgid "# Using Cargo"
msgstr "# Korzystanie z Cargo"

#: src/cargo.md:3
msgid ""
"When you start reading about Rust, you will soon meet "
"[Cargo](https://doc.rust-lang.org/cargo/), the standard tool\n"
"used in the Rust ecosystem to build and run Rust applications. Here we want "
"to\n"
"give a brief overview of what Cargo is and how it fits into the wider "
"ecosystem\n"
"and how it fits into this training."
msgstr ""
"Kiedy zaczniesz czyta o Rucie, wkr贸tce poznasz "
"[Cargo](https://doc.rust-lang.org/cargo/), jest to standardowe narzdzie\n"
"u偶ywany w ekosystemie Rusta do tworzenia i uruchamiania aplikacji Rusta. "
"Tutaj chcemy\n"
"kr贸tko opisa, czym jest Cargo i jak pasuje do szerszego ekosystemu\n"
"i do tego szkolenia."

#: src/cargo.md:8
msgid "## Installation"
msgstr "## Instalacja"

#: src/cargo.md:10
msgid "### Rustup (Recommended)"
msgstr "### Rustup (zalecane)"

#: src/cargo.md:12
msgid ""
"You can follow the instructions to install cargo and rust compiler, among "
"other standard ecosystem tools with the [rustup][3] tool, which is "
"maintained by the Rust Foundation."
msgstr ""
"Mo偶esz postpowa zgodnie z instrukcjami narzdzia [rustup][3], aby "
"zainstalowa Cargo, kompilator Rusta oraz inne standardowe narzdzia "
"ekosystemu Rusta. Narzdzie [rustup][3] jest utrzymywane przez Fundacj Rust."

#: src/cargo.md:14
msgid ""
"Along with cargo and rustc, Rustup will install itself as a command line "
"utility that you can use to install/switch toolchains, setup cross "
"compilation, etc."
msgstr ""
"Wraz z cargo i rustc, Rustup zainstaluje si jako narzdzie wiersza polece, "
"kt贸rego mo偶na u偶y do instalacji/przeczenia acuch贸w narzdzi, "
"konfiguracji skronej kompilacji itp."

#: src/cargo.md:16
msgid "### Package Managers"
msgstr "### Mened偶erowie pakiet贸w"

#: src/cargo.md:18
msgid "#### Debian"
msgstr "#### Debian"

#: src/cargo.md:20
msgid ""
"On Debian/Ubuntu, you can install Cargo, the Rust source and the [Rust "
"formatter][6] with"
msgstr ""
"Na Debianie/Ubuntu mo偶esz zainstalowa Cargo, 藕r贸do Rusta i [narzdzie do "
"formatowania Rusta][6] za pomoc"

#: src/cargo.md:22
msgid ""
"```shell\n"
"$ sudo apt install cargo rust-src rustfmt\n"
"```"
msgstr ""
"```shell\n"
"$ sudo apt install cargo rust-src rustfmt\n"
"```"

#: src/cargo.md:26
msgid ""
"This will allow [rust-analyzer][1] to jump to the definitions. We suggest "
"using\n"
"[VS Code][2] to edit the code (but any LSP compatible editor works)."
msgstr ""
"Umo偶liwi to narzdziu [rust-analyzer][1] przechodzenie do definicji. "
"Sugerujemy u偶ycie\n"
"[VS Code][2], aby edytowa kod (ale dziaa ka偶dy edytor kompatybilny z LSP)."

#: src/cargo.md:29
msgid ""
"Some folks also like to use the [JetBrains][4] family of IDEs, which do "
"their own analysis but have their own tradeoffs. If you prefer them, you can "
"install the [Rust Plugin][5]. Please take note that as of January 2023 "
"debugging only works on the CLion version of the JetBrains IDEA suite."
msgstr ""
"Niekt贸rzy ludzie lubi r贸wnie偶 korzysta z rodziny IDE [JetBrains][4], kt贸re "
"wykonuj wasne analizy, ale maj wasne kompromisy. Jeli wolisz je, mo偶esz "
"zainstalowa [wtyczk Rusta][5]. Nale偶y pamita, 偶e od stycznia 2023 r. "
"debugowanie dziaa tylko w wersji CLion pakietu JetBrains IDEA."

#: src/cargo.md:31
msgid ""
"[1]: https://rust-analyzer.github.io/\n"
"[2]: https://code.visualstudio.com/\n"
"[3]: https://rustup.rs/\n"
"[4]: https://www.jetbrains.com/clion/\n"
"[5]: https://www.jetbrains.com/rust/\n"
"[6]: https://github.com/rust-lang/rustfmt"
msgstr ""
"[1]: https://rust-analyzer.github.io/\n"
"[2]: https://code.visualstudio.com/\n"
"[3]: https://rustup.rs/\n"
"[4]: https://www.jetbrains.com/clion/\n"
"[5]: https://www.jetbrains.com/rust/\n"
"[6]: https://github.com/rust-lang/rustfmt"

#: src/cargo/rust-ecosystem.md:1
msgid "# The Rust Ecosystem"
msgstr "# Ekosystem Rusta"

#: src/cargo/rust-ecosystem.md:3
msgid ""
"The Rust ecosystem consists of a number of tools, of which the main ones are:"
msgstr "Ekosystem Rusta skada si z wielu narzdzi, z kt贸rych g贸wne to:"

#: src/cargo/rust-ecosystem.md:5
msgid ""
"* `rustc`: the Rust compiler which turns `.rs` files into binaries and "
"other\n"
"  intermediate formats."
msgstr ""
"* `rustc`: kompilator Rusta, kt贸ry zmienia pliki `.rs` na pliki binarne i "
"inne\n"
"  formaty porednie."

#: src/cargo/rust-ecosystem.md:8
msgid ""
"* `cargo`: the Rust dependency manager and build tool. Cargo knows how to\n"
"  download dependencies hosted on <https://crates.io> and it will pass them "
"to\n"
"  `rustc` when building your project. Cargo also comes with a built-in test\n"
"  runner which is used to execute unit tests."
msgstr ""
"* `cargo`: mened偶er zale偶noci Rusta i narzdzie do budowania. Cargo wie, "
"jak\n"
"  pobra zale偶noci hostowane na <https://crates.io> i przekaza je do\n"
"  `rustc` podczas budowania projektu. Cargo ma r贸wnie偶 wbudowane narzdzie "
"do uruchamiania test贸w,\n"
"  kt贸re jest u偶ywane do wykonywania test贸w jednostkowych."

#: src/cargo/rust-ecosystem.md:13
msgid ""
"* `rustup`: the Rust toolchain installer and updater. This tool is used to\n"
"  install and update `rustc` and `cargo` when new versions of Rust is "
"released.\n"
"  In addition, `rustup` can also download documentation for the standard\n"
"  library. You can have multiple versions of Rust installed at once and "
"`rustup`\n"
"  will let you switch between them as needed."
msgstr ""
"* `rustup`: instalator i aktualizator pakietu narzdzi Rusta. To narzdzie "
"su偶y do\n"
"  instalowania i aktualizacji `rustc` i `cargo`, gdy zostan wydane nowe "
"wersje Rusta.\n"
"  Ponadto `rustup` mo偶e r贸wnie偶 pobra dokumentacj biblioteki "
"standardowej.\n"
"  Mo偶esz mie jednoczenie zainstalowanych wiele wersji Rusta i `rustup`\n"
"  pozwoli ci przecza si midzy nimi w razie potrzeby."

#: src/cargo/rust-ecosystem.md:21 src/hello-world.md:25 src/hello-world/small-example.md:27
#: src/why-rust/runtime.md:10 src/why-rust/modern.md:21 src/basic-syntax/compound-types.md:30
#: src/error-handling/try-operator.md:50 src/error-handling/converting-error-types-example.md:50
#: src/concurrency/threads.md:30
msgid "Key points:"
msgstr "Kluczowe punkty:"

#: src/cargo/rust-ecosystem.md:23
msgid ""
"* Rust has a rapid release schedule with a new release coming out\n"
"  every six weeks. New releases maintain backwards compatibility with\n"
"  old releases --- plus they enable new functionality."
msgstr ""
"* Rust ma szybki harmonogram wyda z now wersj\n"
"  co sze tygodni. Nowe wersje zachowuj kompatybilno wsteczn z\n"
"  starymi wersjami --- plus umo偶liwiaj nowe funkcjonalnoci."

#: src/cargo/rust-ecosystem.md:27
msgid ""
"* There are three release channels: \"stable\", \"beta\", and \"nightly\"."
msgstr ""
"* Istniej trzy kanay wydania: \"stable\" (\"stabilny\"), \"beta\" i "
"\"nightly\" (\"nocny\")."

#: src/cargo/rust-ecosystem.md:29
msgid ""
"* New features are being tested on \"nightly\", \"beta\" is what becomes\n"
"  \"stable\" every six weeks."
msgstr ""
"* Nowe funkcje s testowane na \"nightly\", \"beta\" jest tym, co staje si\n"
"  \"stable\" co sze tygodni."

#: src/cargo/rust-ecosystem.md:32
msgid ""
"* Rust also has [editions]: the current edition is Rust 2021. Previous\n"
"  editions were Rust 2015 and Rust 2018."
msgstr ""
"* Rust ma r贸wnie偶 [edycje]: obecna edycja to Rust 2021. Poprzednie\n"
"  edycje to Rust 2015 i Rust 2018."

#: src/cargo/rust-ecosystem.md:35
msgid ""
"  * The editions are allowed to make backwards incompatible changes to\n"
"    the language."
msgstr "  * Edycje mog wprowadza do jzyka zmiany niekompatybilne wstecznie."

#: src/cargo/rust-ecosystem.md:38
msgid ""
"  * To prevent breaking code, editions are opt-in: you select the\n"
"    edition for your crate via the `Cargo.toml` file."
msgstr ""
"  * Aby zapobiec niekompatybilnoci kodu, edycje s opcjonalne: wybierasz\n"
"    edycj swojej skrzyni za pomoc pliku `Cargo.toml`."

#: src/cargo/rust-ecosystem.md:41
msgid ""
"  * To avoid splitting the ecosystem, Rust compilers can mix code\n"
"    written for different editions."
msgstr ""
"  * Aby unikn podziau ekosystemu, kompilatory Rusta mog miesza kod\n"
"    napisany dla r贸偶nych edycji."

#: src/cargo/rust-ecosystem.md:44
msgid ""
"  * Mention that it is quite rare to ever use the compiler directly not "
"through `cargo` (most users never do)."
msgstr ""
"  * Wspomnij, 偶e do rzadko u偶ywa si kompilatora bezporednio, a nie przez "
"`cargo` (wikszo u偶ytkownik贸w nigdy tego nie robi)."

#: src/cargo/rust-ecosystem.md:46
msgid ""
"  * It might be worth alluding that Cargo itself is an extremely powerful "
"and comprehensive tool.  It is capable of many advanced features including "
"but not limited to: \n"
"      * Project/package structure\n"
"      * [workspaces]\n"
"      * Dev Dependencies and Runtime Dependency management/caching\n"
"      * [build scripting]\n"
"      * [global installation]\n"
"      * It is also extensible with sub command plugins as well (such as "
"[cargo clippy]).\n"
"  * Read more from the [official Cargo Book]"
msgstr ""
"  * Warto wspomnie, 偶e samo Cargo jest niezwykle pot偶nym i wszechstronnym "
"narzdziem. Jest zdolne do wielu zaawansowanych funkcji, w tym midzy "
"innymi:\n"
"      * Struktura projektu/pakietu\n"
"      * [obszary robocze]\n"
"      * Zarzdzanie/buforowanie zale偶noci\n"
"      * [tworzenie skrypt贸w]\n"
"      * [instalacja globalna]\n"
"      * Jest r贸wnie偶 rozszerzalne za pomoc wtyczek polece podrzdnych "
"(takich jak [cargo clippy]).\n"
"  * Przeczytaj wicej w [oficjalnej ksidze Cargo]"

#: src/cargo/rust-ecosystem.md:55
msgid "[editions]: https://doc.rust-lang.org/edition-guide/"
msgstr "[edycje]: https://doc.rust-lang.org/edition-guide/"

#: src/cargo/rust-ecosystem.md:57
msgid "[workspaces]: https://doc.rust-lang.org/cargo/reference/workspaces.html"
msgstr ""
"[obszary robocze]: https://doc.rust-lang.org/cargo/reference/workspaces.html"

#: src/cargo/rust-ecosystem.md:59
msgid ""
"[build scripting]: "
"https://doc.rust-lang.org/cargo/reference/build-scripts.html"
msgstr ""
"[tworzenie skrypt贸w]: "
"https://doc.rust-lang.org/cargo/reference/build-scripts.html"

#: src/cargo/rust-ecosystem.md:61
msgid ""
"[global installation]: "
"https://doc.rust-lang.org/cargo/commands/cargo-install.html"
msgstr ""
"[instalacja globalna]: "
"https://doc.rust-lang.org/cargo/commands/cargo-install.html"

#: src/cargo/rust-ecosystem.md:63
msgid "[cargo clippy]: https://github.com/rust-lang/rust-clippy"
msgstr "[cargo clippy]: https://github.com/rust-lang/rust-clippy"

#: src/cargo/rust-ecosystem.md:65
msgid "[official Cargo Book]: https://doc.rust-lang.org/cargo/"
msgstr "[oficjalnej ksidze Cargo]: https://doc.rust-lang.org/cargo/"

#: src/cargo/code-samples.md:1
msgid "# Code Samples in This Training"
msgstr "# Pr贸bki kodu"

#: src/cargo/code-samples.md:3
msgid ""
"For this training, we will mostly explore the Rust language through "
"examples\n"
"which can be executed through your browser. This makes the setup much easier "
"and\n"
"ensures a consistent experience for everyone."
msgstr ""
"Na tym szkoleniu bdziemy g贸wnie poznawa jzyk Rust poprzez przykady\n"
"kt贸re mo偶na wykona za porednictwem przegldarki. To znacznie uatwia "
"konfiguracj i\n"
"zapewnia sp贸jne wra偶enia dla wszystkich."

#: src/cargo/code-samples.md:7
msgid ""
"Installing Cargo is still encouraged: it will make it easier for you to do "
"the\n"
"exercises. On the last day, we will do a larger exercise which shows you how "
"to\n"
"work with dependencies and for that you need Cargo."
msgstr ""
"Nadal zachcamy do instalowania Cargo: uatwi ci to wykonanie\n"
"wicze. Ostatniego dnia wykonamy wiksze wiczenie, kt贸re poka偶e ci, jak\n"
"pracowa z zale偶nociami i do tego potrzebujesz Cargo."

#: src/cargo/code-samples.md:11
msgid "The code blocks in this course are fully interactive:"
msgstr "Bloki kodu w tym kursie s w peni interaktywne:"

#: src/cargo/code-samples.md:13
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"Edit me!\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"Zmie mnie!\");\n"
"}\n"
"```"

#: src/cargo/code-samples.md:19
msgid ""
"You can use <kbd>Ctrl + Enter</kbd> to execute the code when focus is in "
"the\n"
"text box."
msgstr ""
"Mo偶esz u偶y <kbd>Ctrl + Enter</kbd>, aby wykona kod, gdy fokus znajduje si "
"w\n"
"polu tekstowym."

#: src/cargo/code-samples.md:24
msgid ""
"Most code samples are editable like shown above. A few code samples\n"
"are not editable for various reasons:"
msgstr ""
"Wikszo przykad贸w kodu mo偶na edytowa, jak pokazano powy偶ej. Kilku pr贸bek "
"kodu\n"
"nie mo偶na edytowa z r贸偶nych powod贸w:"

#: src/cargo/code-samples.md:27
msgid ""
"* The embedded playgrounds cannot execute unit tests. Copy-paste the\n"
"  code and open it in the real Playground to demonstrate unit tests."
msgstr ""
"* Wbudowane playground nie mog wykonywa test贸w jednostkowych. "
"Kopiuj-wklej\n"
"  kod i otw贸rz go na prawdziwym Playground, aby zademonstrowa testy "
"jednostkowe."

#: src/cargo/code-samples.md:30
msgid ""
"* The embedded playgrounds lose their state the moment you navigate\n"
"  away from the page! This is the reason that the students should\n"
"  solve the exercises using a local Rust installation or via the\n"
"  Playground."
msgstr ""
"* Wbudowane playground trac sw贸j stan w momencie nawigacji\n"
"  z dala od strony! To jest pow贸d, dla kt贸rego uczniowie powinni\n"
"  rozwizywa wiczenia korzystajc z lokalnej instalacji Rusta lub za "
"porednictwem\n"
"  prawdziwego Playground."

#: src/cargo/running-locally.md:1
msgid "# Running Code Locally with Cargo"
msgstr "# Uruchamianie kodu lokalnie z Cargo"

#: src/cargo/running-locally.md:3
msgid ""
"If you want to experiment with the code on your own system, then you will "
"need\n"
"to first install Rust. Do this by following the [instructions in the Rust\n"
"Book][1]. This should give you a working `rustc` and `cargo`. At the time "
"of\n"
"writing, the latest stable Rust release has these version numbers:"
msgstr ""
"Jeli chcesz eksperymentowa z kodem we wasnym systemie, bdziesz musie\n"
"najpierw zainstalowa Rusta. Zr贸b to, postpujc zgodnie z [instrukcjami w "
"ksi偶ce\n"
"Jzyk Programowania Rust][1]. To powinno da dziaajce `rustc` i `cargo`. "
"Aktualnie\n"
"najnowsza stabilna wersja Rusta ma nastpujce numery wersji:"

#: src/cargo/running-locally.md:8
msgid ""
"```shell\n"
"% rustc --version\n"
"rustc 1.61.0 (fe5b13d68 2022-05-18)\n"
"% cargo --version\n"
"cargo 1.61.0 (a028ae4 2022-04-29)\n"
"```"
msgstr ""
"```shell\n"
"% rustc --version\n"
"rustc 1.61.0 (fe5b13d68 2022-05-18)\n"
"% cargo --version\n"
"cargo 1.61.0 (a028ae4 2022-04-29)\n"
"```"

#: src/cargo/running-locally.md:15
msgid ""
"With this is in place, then follow these steps to build a Rust binary from "
"one\n"
"of the examples in this training:"
msgstr ""
"Nastpnie wykonaj nastpujce kroki, aby zbudowa plik binarny "
"Rusta z jednego\n"
"z przykad贸w w tym szkoleniu:"

#: src/cargo/running-locally.md:18
msgid ""
"1. Click the \"Copy to clipboard\" button on the example you want to copy."
msgstr ""
"1. Kliknij przycisk Kopiuj do schowka na przykadzie, kt贸ry chcesz "
"skopiowa."

#: src/cargo/running-locally.md:20
msgid ""
"2. Use `cargo new exercise` to create a new `exercise/` directory for your "
"code:"
msgstr ""
"2. U偶yj polecenia `cargo new exercise`, aby utworzy nowy katalog "
"`exercise/` dla swojego kodu:"

#: src/cargo/running-locally.md:22
msgid ""
"    ```shell\n"
"    $ cargo new exercise\n"
"         Created binary (application) `exercise` package\n"
"    ```"
msgstr ""
"    ```shell\n"
"    $ cargo new exercise\n"
"         Created binary (application) `exercise` package\n"
"    ```"

#: src/cargo/running-locally.md:27
msgid ""
"3. Navigate into `exercise/` and use `cargo run` to build and run your "
"binary:"
msgstr ""
"3. Przejd藕 do `exercise/` i u偶yj `cargo run`, aby zbudowa i uruchomi plik "
"binarny:"

#: src/cargo/running-locally.md:29
msgid ""
"    ```shell\n"
"    $ cd exercise\n"
"    $ cargo run\n"
"       Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"        Finished dev [unoptimized + debuginfo] target(s) in 0.75s\n"
"         Running `target/debug/exercise`\n"
"    Hello, world!\n"
"    ```"
msgstr ""
"    ```shell\n"
"    $ cd exercise\n"
"    $ cargo run\n"
"       Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"        Finished dev [unoptimized + debuginfo] target(s) in 0.75s\n"
"         Running `target/debug/exercise`\n"
"    Hello, world!\n"
"    ```"

#: src/cargo/running-locally.md:38
msgid ""
"4. Replace the boiler-plate code in `src/main.rs` with your own code. For\n"
"   example, using the example on the previous page, make `src/main.rs` look "
"like"
msgstr ""
"4. Zastp kod w `src/main.rs` wasnym kodem. Na\n"
"   przykad, korzystajc z przykadu na poprzedniej stronie, spraw, aby "
"`src/main.rs` wyglda tak"

#: src/cargo/running-locally.md:41
msgid ""
"    ```rust\n"
"    fn main() {\n"
"        println!(\"Edit me!\");\n"
"    }\n"
"    ```"
msgstr ""
"    ```rust\n"
"    fn main() {\n"
"        println!(\"Zmie mnie!\");\n"
"    }\n"
"    ```"

#: src/cargo/running-locally.md:47
msgid "5. Use `cargo run` to build and run your updated binary:"
msgstr ""
"5. U偶yj polecenia `cargo run`, aby zbudowa i uruchomi zaktualizowany plik "
"binarny:"

#: src/cargo/running-locally.md:49
msgid ""
"    ```shell\n"
"    $ cargo run\n"
"       Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"        Finished dev [unoptimized + debuginfo] target(s) in 0.24s\n"
"         Running `target/debug/exercise`\n"
"    Edit me!\n"
"    ```"
msgstr ""
"    ```shell\n"
"    $ cargo run\n"
"       Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"        Finished dev [unoptimized + debuginfo] target(s) in 0.24s\n"
"         Running `target/debug/exercise`\n"
"    Zmie mnie!\n"
"    ```"

#: src/cargo/running-locally.md:57
msgid ""
"6. Use `cargo check` to quickly check your project for errors, use `cargo "
"build`\n"
"   to compile it without running it. You will find the output in "
"`target/debug/`\n"
"   for a normal debug build. Use `cargo build --release` to produce an "
"optimized\n"
"   release build in `target/release/`."
msgstr ""
"6. U偶yj `cargo check`, aby szybko sprawdzi sw贸j projekt pod ktem bd贸w, "
"u偶yj `cargo build`\n"
"   aby skompilowa go bez uruchamiania. Dane wyjciowe znajdziesz w "
"`target/debug/`\n"
"   dla normalnej kompilacji do debugowania. U偶yj polecenia `cargo build "
"--release`, aby utworzy zoptymalizowany plik\n"
"   do wydania w `target/release/`."

#: src/cargo/running-locally.md:62
msgid ""
"7. You can add dependencies for your project by editing `Cargo.toml`. When "
"you\n"
"   run `cargo` commands, it will automatically download and compile missing\n"
"   dependencies for you."
msgstr ""
"7. Mo偶esz doda zale偶noci dla swojego projektu, edytujc `Cargo.toml`. "
"Kiedy\n"
"   uruchamiasz polecenia `cargo`, Cargo automatycznie pobierze i skompiluje "
"brakujce\n"
"   zale偶noci dla Ciebie."

#: src/cargo/running-locally.md:66
msgid "[1]: https://doc.rust-lang.org/book/ch01-01-installation.html"
msgstr "[1]: http://rust.w8.pl/book/ch01-01-installation.html"

#: src/cargo/running-locally.md:70
msgid ""
"Try to encourage the class participants to install Cargo and use a\n"
"local editor. It will make their life easier since they will have a\n"
"normal development environment."
msgstr ""
"Spr贸buj zachci uczestnik贸w zaj do zainstalowania Cargo i korzystania z\n"
"edytora tekstu. Uatwi im to 偶ycie, poniewa偶 bd mieli\n"
"normalne rodowisko programistyczne."

#: src/welcome-day-1.md:1
msgid "# Welcome to Day 1"
msgstr "# Witamy w dniu 1"

#: src/welcome-day-1.md:3
msgid ""
"This is the first day of Comprehensive Rust. We will cover a lot of ground\n"
"today:"
msgstr "To pierwszy dzie Comprehensive Rust. Przerobimy dzi du偶o materiau:"

#: src/welcome-day-1.md:6
msgid ""
"* Basic Rust syntax: variables, scalar and compound types, enums, structs,\n"
"  references, functions, and methods."
msgstr ""
"* Podstawowa skadnia Rusta: zmienne, typy skalarne i zo偶one, wyliczenia, "
"struktury,\n"
"  referencje, funkcje i metody."

#: src/welcome-day-1.md:9
msgid ""
"* Memory management: stack vs heap, manual memory management, scope-based "
"memory\n"
"  management, and garbage collection."
msgstr ""
"* Zarzdzanie pamici: stos a sterta, rczne zarzdzanie pamici, "
"zarzdzanie pamici oparte na zakresie i odmiecanie pamici."

#: src/welcome-day-1.md:12
msgid ""
"* Ownership: move semantics, copying and cloning, borrowing, and lifetimes."
msgstr ""
"* Wasno: semantyka przenoszenia, kopiowanie i klonowanie, po偶yczanie i "
"czasy 偶ycia."

#: src/welcome-day-1.md:16
msgid "Please remind the students that:"
msgstr "Prosz przypomnie uczniom, 偶e:"

#: src/welcome-day-1.md:18
msgid ""
"* They should ask questions when they get them, don't save them to the end.\n"
"* The class is meant to be interactive and discussions are very much "
"encouraged!\n"
"  * As an instructor, you should try to keep the discussions relevant, "
"i.e.,\n"
"    keep the related to how Rust does things vs some other language. It can "
"be\n"
"    hard to find the right balance, but err on the side of allowing "
"discussions\n"
"    since they engage people much more than one-way communication.\n"
"* The questions will likely mean that we talk about things ahead of the "
"slides.\n"
"  * This is perfectly okay! Repetition is an important part of learning. "
"Remember\n"
"    that the slides are just a support and you are free to skip them as you\n"
"    like."
msgstr ""
"* Powinni zadawa pytania, kiedy je dostan, nich ich nie zachowuj do "
"koca.\n"
"* Klasa ma by interaktywna, a dyskusje s bardzo mile widziane!\n"
"  * Jako prowadzcy powiniene stara si, aby dyskusje byy istotne, tj.\n"
"    zachowaj zwizek z tym, jak Rust robi rzeczy w por贸wnaniu z innym "
"jzykiem. Mo偶e by\n"
"    ci偶ko znale藕 waciw r贸wnowag, ale skaniaj si do zezwalania na "
"dyskusje\n"
"    poniewa偶 anga偶uj ludzi znacznie bardziej ni偶 jednokierunkowa "
"komunikacja.\n"
"* Pytania prawdopodobnie oznaczaj, 偶e rozmawiamy o rzeczach przed "
"slajdami.\n"
"  * To jest cakowicie w porzdku! Powtarzanie jest wa偶n czci uczenia "
"si. Pamitaj,\n"
"    偶e slajdy s tylko wsparciem i je偶eli chcesz to mo偶esz je pomin."

#: src/welcome-day-1.md:29
msgid ""
"The idea for the first day is to show _just enough_ of Rust to be able to "
"speak\n"
"about the famous borrow checker. The way Rust handles memory is a major "
"feature\n"
"and we should show students this right away."
msgstr ""
"Ide pierwszego dnia jest pokazanie _tylko tyle_ Rusta, 偶eby m贸c m贸wi\n"
"o synnym nadzorcu po偶yczania. Spos贸b, w jaki Rust obsuguje pami, jest "
"jego g贸wn cech\n"
"i powinnimy od razu pokaza to uczniom."

#: src/welcome-day-1.md:33
msgid ""
"If you're teaching this in a classroom, this is a good place to go over the\n"
"schedule. We suggest splitting the day into two parts (following the slides):"
msgstr ""
"Jeli uczysz tego w klasie, jest to dobre miejsce do przejrzenia\n"
"harmonogramu. Proponujemy podzieli dzie na dwie czci (wedug slajd贸w):"

#: src/welcome-day-1.md:36
msgid "* Morning: 9:00 to 12:00,\n* Afternoon: 13:00 to 16:00."
msgstr "* Rano: od 9:00 do 12:00,\n* Po poudniu: od 13:00 do 16:00."

#: src/welcome-day-1.md:39
msgid ""
"You can of course adjust this as necessary. Please make sure to include "
"breaks,\n"
"we recommend a break every hour!"
msgstr ""
"Mo偶na to oczywicie dostosowa w razie potrzeby. Prosz uwzgldni przerwy,\n"
"zalecamy przerw co godzin!"

#: src/welcome-day-1/what-is-rust.md:1
msgid "# What is Rust?"
msgstr "# Co to jest Rust?"

#: src/welcome-day-1/what-is-rust.md:3
msgid ""
"Rust is a new programming language which had its [1.0 release in 2015][1]:"
msgstr ""
"Rust to nowy jzyk programowania, kt贸ry mia swoje [wydanie 1.0 w 2015 "
"roku][1]:"

#: src/welcome-day-1/what-is-rust.md:5
msgid ""
"* Rust is a statically compiled language in a similar role as C++\n"
"  * `rustc` uses LLVM as its backend.\n"
"* Rust supports many [platforms and\n"
"  "
"architectures](https://doc.rust-lang.org/nightly/rustc/platform-support.html):\n"
"  * x86, ARM, WebAssembly, ...\n"
"  * Linux, Mac, Windows, ...\n"
"* Rust is used for a wide range of devices:\n"
"  * firmware and boot loaders,\n"
"  * smart displays,\n"
"  * mobile phones,\n"
"  * desktops,\n"
"  * servers."
msgstr ""
"* Rust to jzyk kompilowany statycznie, penicy podobn rol jak C++\n"
"  * `rustc` u偶ywa LLVM jako backendu.\n"
"* Rust obsuguje wiele [platform i\n"
"  "
"architektur](https://doc.rust-lang.org/nightly/rustc/platform-support.html):\n"
"  * x86, ARM, WebAssembly, ...\n"
"  * Linux, Mac, Windows,...\n"
"* Rust jest u偶ywany w szerokiej gamie urzdze:\n"
"  * firmware i bootloadery,\n"
"  * inteligentne wywietlacze,\n"
"  * telefony kom贸rkowe,\n"
"  * komputery stacjonarne,\n"
"  * serwery."

#: src/welcome-day-1/what-is-rust.md:21
msgid "Rust fits in the same area as C++:"
msgstr "Rust pasuje do tego samego obszaru co C++:"

#: src/welcome-day-1/what-is-rust.md:23
msgid ""
"* High flexibility.\n"
"* High level of control.\n"
"* Can be scaled down to very constrained devices like mobile phones.\n"
"* Has no runtime or garbage collection.\n"
"* Focuses on reliability and safety without sacrificing performance."
msgstr ""
"* Wysoka elastyczno.\n"
"* Wysoki poziom kontroli.\n"
"* Mo偶na skalowa do bardzo ograniczonych urzdze, takich jak telefony "
"kom贸rkowe.\n"
"* Nie ma biblioteki uruchomieniowej ani odmiecania pamici.\n"
"* Koncentruje si na niezawodnoci i bezpieczestwie bez powicania "
"wydajnoci."

#: src/welcome-day-1/what-is-rust.md:31
msgid "[1]: https://blog.rust-lang.org/2015/05/15/Rust-1.0.html"
msgstr "[1]: https://blog.rust-lang.org/2015/05/15/Rust-1.0.html"

#: src/hello-world.md:1
msgid "# Hello World!"
msgstr "# Witaj wiecie!"

#: src/hello-world.md:3
msgid ""
"Let us jump into the simplest possible Rust program, a classic Hello World\n"
"program:"
msgstr ""
"Przejd藕my do najprostszego mo偶liwego programu Rust, klasycznego Hello World\n"
"program:"

#: src/hello-world.md:6
msgid ""
"```rust\n"
"fn main() {\n"
"    println!(\"Hello !\");\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    println!(\"Witaj !\");\n"
"}\n"
"```"

#: src/hello-world.md:12
msgid "What you see:"
msgstr "Co wida:"

#: src/hello-world.md:14
msgid ""
"* Functions are introduced with `fn`.\n"
"* Blocks are delimited by curly braces like in C and C++.\n"
"* The `main` function is the entry point of the program.\n"
"* Rust has hygienic macros, `println!` is an example of this.\n"
"* Rust strings are UTF-8 encoded and can contain any Unicode character."
msgstr ""
"* Funkcje s wprowadzane za pomoc `fn`.\n"
"* Bloki s oddzielone nawiasami klamrowymi, jak w C i C++.\n"
"* Funkcja `main` jest punktem wejcia programu.\n"
"* Rust ma higieniczne makra, `println!` jest tego przykadem.\n"
"* acuchy znak贸w w Rucie s zakodowane w UTF-8 i mog zawiera dowolne "
"znaki Unicode."

#: src/hello-world.md:22
msgid ""
"This slide tries to make the students comfortable with Rust code. They will "
"see\n"
"a ton of it over the next four days so we start small with something "
"familiar."
msgstr ""
"Ten slajd ma na celu zapoznanie uczni贸w z kodem Rusta. Zobacz\n"
"tego du偶o w cigu nastpnych czterech dni, wic zaczniemy od czego "
"znajomego."

#: src/hello-world.md:27
msgid ""
"* Rust is very much like other languages in the C/C++/Java tradition. It is\n"
"  imperative (not functional) and it doesn't try to reinvent things unless\n"
"  absolutely necessary."
msgstr ""
"* Rust jest bardzo podobny do innych jzyk贸w w tradycji C/C++/Java. Jest\n"
"  imperatywny (nie funkcjonalny) i nie pr贸buje wymyla rzeczy na nowo jeli "
"nie ma takiej potrzeby."

#: src/hello-world.md:31
msgid "* Rust is modern with full support for things like Unicode."
msgstr "* Rust jest nowoczesny, ma pene wsparcie dla rzeczy takich jak Unicode."

#: src/hello-world.md:33
msgid ""
"* Rust uses macros for situations where you want to have a variable number "
"of\n"
"  arguments (no function [overloading](basic-syntax/functions-interlude.md))."
msgstr ""
"* Rust u偶ywa makr w sytuacjach, w kt贸rych chcesz mie zmienn liczb\n"
"  argumenty (brak [przeci偶ania "
"funkcji](basic-syntax/functions-interlude.md))."

#: src/hello-world/small-example.md:1
msgid "# Small Example"
msgstr "# May przykad"

#: src/hello-world/small-example.md:3
msgid "Here is a small example program in Rust:"
msgstr "Oto may przykadowy program w Rucie:"

#: src/hello-world/small-example.md:5
msgid ""
"```rust,editable\n"
"fn main() {              // Program entry point\n"
"    let mut x: i32 = 6;  // Mutable variable binding\n"
"    print!(\"{x}\");       // Macro for printing, like printf\n"
"    while x != 1 {       // No parenthesis around expression\n"
"        if x % 2 == 0 {  // Math like in other languages\n"
"            x = x / 2;\n"
"        } else {\n"
"            x = 3 * x + 1;\n"
"        }\n"
"        print!(\" -> {x}\");\n"
"    }\n"
"    println!();\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {              // Punkt wejcia do programu\n"
"    let mut x: i32 = 6;  // Zmienna mutowalna\n"
"    print!(\"{x}\");       // Makro do wypisywania tekstu, jak printf\n"
"    while x != 1 {       // Wyra偶enie bez nawias贸w\n"
"        if x % 2 == 0 {  // Obliczenia jak w innych jzykach\n"
"            x = x / 2;\n"
"        } else {\n"
"            x = 3 * x + 1;\n"
"        }\n"
"        print!(\" -> {x}\");\n"
"    }\n"
"    println!();\n"
"}\n"
"```"

#: src/hello-world/small-example.md:23
msgid ""
"The code implements the Collatz conjecture: it is believed that the loop "
"will\n"
"always end, but this is not yet proved. Edit the code and play with "
"different\n"
"inputs."
msgstr ""
"Kod implementuje hipotez Collatza: uwa偶a si, 偶e ptla zawsze\n"
"si koczy, ale nie zostao to jeszcze udowodnione. Edytuj kod i baw si "
"r贸偶nymi\n"
"danymi wejciowymi."

#: src/hello-world/small-example.md:29
msgid ""
"* Explain that all variables are statically typed. Try removing `i32` to "
"trigger\n"
"  type inference. Try with `i8` instead and trigger a runtime integer "
"overflow."
msgstr ""
"* Wyjanij, 偶e wszystkie zmienne s typowane statycznie. Spr贸buj usun "
"`i32`, aby uruchomi\n"
"  wnioskowanie typu. Zamiast tego spr贸buj z `i8` i wywoaj przepenienie "
"liczby cakowitej w czasie wykonywania."

#: src/hello-world/small-example.md:32
msgid "* Change `let mut x` to `let x`, discuss the compiler error."
msgstr "* Zmie `let mut x` na `let x`, om贸w bd kompilatora."

#: src/hello-world/small-example.md:34
msgid ""
"* Show how `print!` gives a compilation error if the arguments don't match "
"the\n"
"  format string."
msgstr ""
"* Poka偶, jak `print!` daje bd kompilacji, jeli argumenty nie pasuj do\n"
"  acucha formatujcego."

#: src/hello-world/small-example.md:37
msgid ""
"* Show how you need to use `{}` as a placeholder if you want to print an\n"
"  expression which is more complex than just a single variable."
msgstr ""
"* Poka偶, 偶e  musisz u偶y `{}` jako symbolu zastpczego, jeli chcesz "
"wypisa\n"
"  wyra偶enie, kt贸re jest bardziej zo偶one ni偶 tylko pojedyncza zmienna."

#: src/hello-world/small-example.md:40
msgid ""
"* Show the students the standard library, show them how to search for "
"`std::fmt`\n"
"  which has the rules of the formatting mini-language. It's important that "
"the\n"
"  students become familiar with searching in the standard library."
msgstr ""
"* Poka偶 uczniom standardow bibliotek, poka偶 im, jak szuka `std::fmt`\n"
"  kt贸ry ma zasady mini-jzyka formatowania. Wa偶ne jest, aby\n"
"  studenci zapoznaj si z wyszukiwaniem w bibliotece standardowej."

#: src/why-rust.md:1
msgid "# Why Rust?"
msgstr "# Dlaczego Rust?"

#: src/why-rust.md:3
msgid "Some unique selling points of Rust:"
msgstr "Niekt贸re unikalne zalety Rusta:"

#: src/why-rust.md:5
msgid ""
"* Compile time memory safety.\n"
"* Lack of undefined runtime behavior.\n"
"* Modern language features."
msgstr ""
"* Bezpieczestwo pamici w czasie kompilacji.\n"
"* Brak niezdefiniowanego zachowania w czasie wykonywania.\n"
"* Nowoczesne funkcje jzykowe."

#: src/why-rust.md:11
msgid ""
"Make sure to ask the class which languages they have experience with. "
"Depending\n"
"on the answer you can highlight different features of Rust:"
msgstr ""
"Pamitaj, aby zapyta klas, z jakimi jzykami maj dowiadczenie. W "
"zale偶noci\n"
"od odpowiedzi mo偶esz wyr贸偶ni r贸偶ne funkcje Rusta:"

#: src/why-rust.md:14
msgid ""
"* Experience with C or C++: Rust eliminates a whole class of _runtime "
"errors_\n"
"  via the borrow checker. You get performance like in C and C++, but you "
"don't\n"
"  have the memory unsafety issues. In addition, you get a modern language "
"with\n"
"  constructs like pattern matching and built-in dependency management."
msgstr ""
"* Dowiadczenie z C lub C++: Rust eliminuje ca klas bd贸w _w czasie "
"dziaania_\n"
"  za porednictwem nadzorcy po偶yczania. Otrzymujesz wydajno jak w C i C++, "
"ale bez\n"
"  problem贸w z bezpieczestwem pamici. Ponadto otrzymujesz nowoczesny jzyk "
"z\n"
"  konstrukcjami, jak dopasowywanie wzorc贸w i wbudowane zarzdzanie "
"zale偶nociami."

#: src/why-rust.md:19
msgid ""
"* Experience with Java, Go, Python, JavaScript...: You get the same memory "
"safety\n"
"  as in those languages, plus a similar high-level language feeling. In "
"addition\n"
"  you get fast and predictable performance like C and C++ (no garbage "
"collector)\n"
"  as well as access to low-level hardware (should you need it)"
msgstr ""
"* Dowiadczenie z Jav, Go, Pythonem, JavaScript...: Otrzymujesz takie samo "
"bezpieczestwo pamici\n"
"  jak w tych jzykach, plus podobne uczucie jzyka wysokiego poziomu. "
"Ponadto\n"
"  otrzymujesz szybk i przewidywaln wydajno jak w C i C++ (bez Garbage "
"Collectora)\n"
"  a tak偶e dostp do sprztu na niskim poziomie (jeli go potrzebujesz)"

#: src/why-rust/compile-time.md:1
msgid "# Compile Time Guarantees"
msgstr "# Gwarancje w czasie kompilacji"

#: src/why-rust/compile-time.md:3
msgid "Static memory management at compile time:"
msgstr "Statyczne zarzdzanie pamici w czasie kompilacji:"

#: src/why-rust/compile-time.md:5
msgid ""
"* No uninitialized variables.\n"
"* No memory leaks (_mostly_, see notes).\n"
"* No double-frees.\n"
"* No use-after-free.\n"
"* No `NULL` pointers.\n"
"* No forgotten locked mutexes.\n"
"* No data races between threads.\n"
"* No iterator invalidation."
msgstr ""
"* Brak niezainicjowanych zmiennych.\n"
"* Brak wyciek贸w pamici (_g贸wnie_, patrz uwagi).\n"
"* Brak podw贸jnych zwolnie pamici.\n"
"* Brak u偶ycia po zwolnieniu.\n"
"* Brak wska藕nik贸w `NULL`.\n"
"* 呕adnych zapomnianych zablokowanych muteks贸w.\n"
"* Brak wycig贸w danych midzy wtkami.\n"
"* Brak uniewa偶niania iteratora."

#: src/why-rust/compile-time.md:16
msgid ""
"It is possible to produce memory leaks in (safe) Rust. Some examples\n"
"are:"
msgstr ""
"Mo偶liwe jest generowanie wyciek贸w pamici w (bezpiecznym) Rucie. Kilka "
"przykad贸w:"

#: src/why-rust/compile-time.md:19
msgid ""
"* You can for use [`Box::leak`] to leak a pointer. A use of this could\n"
"  be to get runtime-initialized and runtime-sized static variables\n"
"* You can use [`std::mem::forget`] to make the compiler \"forget\" about\n"
"  a value (meaning the destructor is never run).\n"
"* You can also accidentally create a [reference cycle] with `Rc` or\n"
"  `Arc`.\n"
"* In fact, some will consider infinitely populating a collection a memory\n"
"  leak and Rust does not protect from those."
msgstr ""
"* Mo偶esz u偶y [`Box::leak`] do wycieku wska藕nika. Mo偶na to wykorzysta,\n"
"  aby uzyska zmienne statyczne inicjowane w czasie wykonywania i o "
"rozmiarze czasu wykonywania\n"
"* Mo偶esz u偶y [`std::mem::forget`], aby kompilator zapomnia o\n"
"  wartoci (co oznacza, 偶e destruktor nigdy nie jest uruchamiany).\n"
"* Mo偶esz tak偶e przypadkowo utworzy [cykl referencyjny] za pomoc `Rc` lub\n"
"  `Arc`.\n"
"* W rzeczywistoci niekt贸rzy uznaj zapenianie kolekcji w nieskoczono "
"za\n"
"  wyciek pamici, a Rust nie chroni przed nimi."

#: src/why-rust/compile-time.md:28
msgid ""
"For the purpose of this course, \"No memory leaks\" should be understood\n"
"as \"Pretty much no *accidental* memory leaks\"."
msgstr ""
"Na potrzeby tego kursu nale偶y rozumie Brak wyciek贸w pamici.\n"
"jako Prawie nie ma *przypadkowych* wyciek贸w pamici."

#: src/why-rust/compile-time.md:31
msgid ""
"[`Box::leak`]: "
"https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak\n"
"[`std::mem::forget`]: https://doc.rust-lang.org/std/mem/fn.forget.html\n"
"[reference cycle]: "
"https://doc.rust-lang.org/book/ch15-06-reference-cycles.html"
msgstr ""
"[`Box::leak`]: "
"https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak\n"
"[`std::mem::forget`]: https://doc.rust-lang.org/std/mem/fn.forget.html\n"
"[cykl referencyjny]: http://rust.w8.pl/book/ch15-06-reference-cycles.html"

#: src/why-rust/runtime.md:1
msgid "# Runtime Guarantees"
msgstr "# Gwarancje podczas dziaania"

#: src/why-rust/runtime.md:3
msgid "No undefined behavior at runtime:"
msgstr "Brak niezdefiniowanego zachowania w czasie wykonywania:"

#: src/why-rust/runtime.md:5
msgid "* Array access is bounds checked.\n* Integer overflow is defined."
msgstr ""
"* Zakres dostpu do tablicy jest sprawdzany.\n"
"* Zdefiniowano przepenienie cakowitoliczbowe."

#: src/why-rust/runtime.md:12
msgid ""
"* Integer overflow is defined via a compile-time flag. The options are\n"
"  either a panic (a controlled crash of the program) or wrap-around\n"
"  semantics. By default, you get panics in debug mode (`cargo build`)\n"
"  and wrap-around in release mode (`cargo build --release`)."
msgstr ""
"* Przepenienie liczb cakowitych jest definiowane za pomoc flagi czasu "
"kompilacji. Opcje to\n"
"  panika (kontrolowana awaria programu) lub zawijanie.\n"
"  Domylnie to panika w trybie debugowania (`cargo build`)\n"
"  i zawijanie w trybie produkcyjnym (`cargo build --release`)."

#: src/why-rust/runtime.md:17
msgid ""
"* Bounds checking cannot be disabled with a compiler flag. It can also\n"
"  not be disabled directly with the `unsafe` keyword. However,\n"
"  `unsafe` allows you to call functions such as `slice::get_unchecked`\n"
"  which does not do bounds checking."
msgstr ""
"* Sprawdzania granic nie mo偶na wyczy za pomoc flagi kompilatora. Nie "
"mo偶e te偶\n"
"  wyczy go bezporednio za pomoc sowa kluczowego `unsafe`. Jednak偶e,\n"
"  `unsafe` pozwala na wywoanie funkcji takich jak `slice::get_unchecked`,\n"
"  kt贸re nie sprawdzaj granic."

#: src/why-rust/modern.md:1
msgid "# Modern Features"
msgstr "# Nowoczesne funkcjonalnoci"

#: src/why-rust/modern.md:3
msgid "Rust is built with all the experience gained in the last 40 years."
msgstr ""
"Rust jest zbudowany z caym dowiadczeniem zdobytym w cigu ostatnich 40 lat."

#: src/why-rust/modern.md:5
msgid "## Language Features"
msgstr "## Funkcje jzyka"

#: src/why-rust/modern.md:7
msgid ""
"* Enums and pattern matching.\n"
"* Generics.\n"
"* No overhead FFI.\n"
"* Zero-cost abstractions."
msgstr ""
"* Wyliczenia i dopasowywanie wzorc贸w.\n"
"* Generyczne typy i funkcje.\n"
"* Brak narzutu przy FFI.\n"
"* Abstrakcje o zerowych kosztach."

#: src/why-rust/modern.md:12
msgid "## Tooling"
msgstr "## Narzdzia"

#: src/why-rust/modern.md:14
msgid ""
"* Great compiler errors.\n"
"* Built-in dependency manager.\n"
"* Built-in support for testing.\n"
"* Excellent Language Server Protocol support."
msgstr ""
"* wietne bdy kompilatora.\n"
"* Wbudowany mened偶er zale偶noci.\n"
"* Wbudowana obsuga test贸w.\n"
"* Doskonaa obsuga protokou serwera jzykowego."

#: src/why-rust/modern.md:23
msgid ""
"* Zero-cost abstractions, similar to C++, means that you don't have to "
"'pay'\n"
"  for higher-level programming constructs with memory or CPU. For example,\n"
"  writing a loop using `for` should result in roughly the same low level\n"
"  instructions as using the `.iter().fold()` construct."
msgstr ""
"* Abstrakcje o zerowych kosztach, podobne do C++, oznaczaj, 偶e nie musisz "
"paci\n"
"  za konstrukcje programistyczne wy偶szego poziomu pamici lub procesorem. "
"Na przykad,\n"
"  pisanie ptli przy u偶yciu `for` powinno da w przybli偶eniu te same "
"instrukcje niskiego poziomu\n"
"  jak przy u偶yciu konstrukcji `.iter().fold()`."

#: src/why-rust/modern.md:28
msgid ""
"* It may be worth mentioning that Rust enums are 'Algebraic Data Types', "
"also\n"
"  known as 'sum types', which allow the type system to express things like\n"
"  `Option<T>` and `Result<T, E>`."
msgstr ""
"* Warto wspomnie, 偶e wyliczenia w Rust r贸wnie偶 s algebraicznymi typami "
"danych,\n"
"  kt贸re pozwalaj systemowi typ贸w wyra偶a takie rzeczy jak\n"
"  `Option<T>` i `Result<T, E>`."

#: src/why-rust/modern.md:32
msgid ""
"* Remind people to read the errors --- many developers have gotten used to\n"
"  ignore lengthy compiler output. The Rust compiler is significantly more\n"
"  talkative than other compilers. It will often provide you with "
"_actionable_\n"
"  feedback, ready to copy-paste into your code."
msgstr ""
"* Przypomnij ludziom, aby przeczytali bdy --- wielu programist贸w "
"przyzwyczaio si do\n"
"  ignorowanie dugich danych wyjciowych kompilatora. Kompilator Rusta jest "
"znacznie bardziej\n"
"  rozmowny ni偶 inne kompilatory. Czsto da ci _u偶yteczne_ podpowiedzi,\n"
"  gotowe do skopiowania i wklejenia do kodu."

#: src/why-rust/modern.md:37
msgid ""
"* The Rust standard library is small compared to languages like Java, "
"Python,\n"
"  and Go. Rust does not come with several things you might consider standard "
"and\n"
"  essential:"
msgstr ""
"* Standardowa biblioteka Rusta jest niewielka w por贸wnaniu z jzykami takimi "
"jak Java, Python,\n"
"  i Go. Rust nie zawiera kilku rzeczy, kt贸re mo偶na by uzna za standardowe "
"i\n"
"  niezbdne:"

#: src/why-rust/modern.md:41
msgid ""
"  * a random number generator, but see [rand].\n"
"  * support for SSL or TLS, but see [rusttls].\n"
"  * support for JSON, but see [serde_json]."
msgstr ""
"  * generator liczb losowych, ale patrz [rand].\n"
"  * wsparcie dla SSL lub TLS, ale zobacz [rusttls].\n"
"  * wsparcie dla JSON, ale zobacz [serde_json]."

#: src/why-rust/modern.md:45
msgid ""
"  The reasoning behind this is that functionality in the standard library "
"cannot\n"
"  go away, so it has to be very stable. For the examples above, the Rust\n"
"  community is still working on finding the best solution --- and perhaps "
"there\n"
"  isn't a single \"best solution\" for some of these things."
msgstr ""
"  Powodem tego jest to, 偶e funkcjonalno w bibliotece standardowej nie "
"mo偶e\n"
"  odej, wic musi by bardzo stabilna. Dla powy偶szych przykad贸w "
"spoeczno Rusta\n"
"  wci偶 pracuje nad znalezieniem najlepszego rozwizania --- i by mo偶e nie "
"ma\n"
"  jednego najlepszego rozwizania dla niekt贸rych z tych rzeczy."

#: src/why-rust/modern.md:50
msgid ""
"  Rust comes with a built-in package manager in the form of Cargo and this "
"makes\n"
"  it trivial to download and compile third-party crates. A consequence of "
"this\n"
"  is that the standard library can be smaller."
msgstr ""
"  Rust ma wbudowanego mened偶era pakiet贸w w postaci Cargo i to sprawia, 偶e\n"
"  pobieranie i kompilowanie zewntrznych pakiet贸w jest trywialne. "
"Konsekwencj tego\n"
"  jest to, 偶e standardowa biblioteka mo偶e by mniejsza."

#: src/why-rust/modern.md:54
msgid ""
"  Discovering good third-party crates can be a problem. Sites like\n"
"  <https://lib.rs/> help with this by letting you compare health metrics "
"for\n"
"  crates to find a good and trusted one.\n"
"  \n"
"* [rust-analyzer] is a well supported LSP implementation used in major\n"
"  IDEs and text editors."
msgstr ""
"  Odkrywanie dobrych skrzynek mo偶e by problemem. Witryny takie jak\n"
"  <https://lib.rs/> w tym pomagaj, umo偶liwiajc por贸wnanie wska藕nik贸w "
"kondycji\n"
"  skrzynki, aby znale藕 te dobre i zaufane.\n"
"  \n"
"* [rust-analyzer] to dobrze obsugiwana implementacja LSP u偶ywana w "
"g贸wnych\n"
"  IDE i edytorach tekstu."

#: src/why-rust/modern.md:61
msgid ""
"[rand]: https://docs.rs/rand/\n"
"[rusttls]: https://docs.rs/rustls/\n"
"[serde_json]: https://docs.rs/serde_json/\n"
"[rust-analyzer]: https://rust-analyzer.github.io/"
msgstr ""
"[rand]: https://docs.rs/rand/\n"
"[rusttls]: https://docs.rs/rustls/\n"
"[serde_json]: https://docs.rs/serde_json/\n"
"[rust-analyzer]: https://rust-analyzer.github.io/"

#: src/basic-syntax.md:1
msgid "# Basic Syntax"
msgstr "# Podstawowa skadnia"

#: src/basic-syntax.md:3
msgid "Much of the Rust syntax will be familiar to you from C, C++ or Java:"
msgstr "Wikszo skadni Rusta bdzie Ci znana z C, C++ lub Javy:"

#: src/basic-syntax.md:5
msgid ""
"* Blocks and scopes are delimited by curly braces.\n"
"* Line comments are started with `//`, block comments are delimited by `/* "
"...\n"
"  */`.\n"
"* Keywords like `if` and `while` work the same.\n"
"* Variable assignment is done with `=`, comparison is done with `==`."
msgstr ""
"* Bloki i zakresy s oddzielone nawiasami klamrowymi.\n"
"* Komentarze wierszowe rozpoczynaj si od `//`, komentarze blokowe s "
"rozdzielane przez `/*...\n"
"  */`.\n"
"* Sowa kluczowe, takie jak `if` i `while`, dziaaj tak samo.\n"
"* Przypisanie zmiennej odbywa si za pomoc `=`, por贸wnanie za pomoc `==`."

#: src/basic-syntax/scalar-types.md:1
msgid "# Scalar Types"
msgstr "# Typy skalarne"

#: src/basic-syntax/scalar-types.md:3
msgid ""
"|                        | Types                                      | "
"Literals                      |\n"
"|------------------------|--------------------------------------------|-------------------------------|\n"
"| Signed integers        | `i8`, `i16`, `i32`, `i64`, `i128`, `isize` | "
"`-10`, `0`, `1_000`, `123i64` |\n"
"| Unsigned integers      | `u8`, `u16`, `u32`, `u64`, `u128`, `usize` | `0`, "
"`123`, `10u16`           |\n"
"| Floating point numbers | `f32`, `f64`                               | "
"`3.14`, `-10.0e20`, `2f32`    |\n"
"| Strings                | `&str`                                     | "
"`\"foo\"`, `r#\"\\\\\"#`            |\n"
"| Unicode scalar values  | `char`                                     | "
"`'a'`, `'伪'`, `''`           |\n"
"| Byte strings           | `&[u8]`                                    | "
"`b\"abc\"`, `br#\" \" \"#`         |\n"
"| Booleans               | `bool`                                     | "
"`true`, `false`               |"
msgstr ""
"| | Typy | Literay |\n"
"|------------------------|--------- --------------------|-------------- --|\n"
"| Liczby cakowite ze znakiem | `i8`, `i16`, `i32`, `i64`, `i128`, `isize` | "
"`-10`, `0`, `1_000`, `123i64` |\n"
"| Liczby cakowite bez znaku | `u8`, `u16`, `u32`, `u64`, `u128`, `usize` | "
"`0`, `123`, `10u16` |\n"
"| Liczby zmiennoprzecinkowe | `f32`, `f64` | `3.14`, `-10.0e20`, `2f32` |\n"
"| acuchy znak贸w | `&str` | `\"foo\"`, `r#\"\\\\\"#` |\n"
"| Wartoci skalarne Unicode | `char` | `'a'`, `'伪'`, `''` |\n"
"| Cigi bajt贸w | `&[u8]` | `b\"abc\"`, `br#\" \"\"#` |\n"
"| Logiczne | `bool` | `true`, `false` |"

#: src/basic-syntax/scalar-types.md:13
msgid "The types have widths as follows:"
msgstr "Typy maj nastpujce rozmiary:"

#: src/basic-syntax/scalar-types.md:15
msgid ""
"* `iN`, `uN`, and `fN` are _N_ bits wide,\n"
"* `isize` and `usize` are the width of a pointer,\n"
"* `char` is 32 bit wide,\n"
"* `bool` is 8 bit wide."
msgstr ""
"* `iN`, `uN` i `fN` maj wielko _N_ bit贸w,\n"
"* `isize` i `usize` maj wielko wska藕nika,\n"
"* `char` ma 32 bit贸w,\n"
"* `bool` ma 8 bit贸w."

#: src/basic-syntax/compound-types.md:1
msgid "# Compound Types"
msgstr "# Typy zo偶one"

#: src/basic-syntax/compound-types.md:3
msgid ""
"|        | Types                         | Literals                          "
"|\n"
"|--------|-------------------------------|-----------------------------------|\n"
"| Arrays | `[T; N]`                      | `[20, 30, 40]`, `[0; 3]`          "
"|\n"
"| Tuples | `()`, `(T,)`, `(T1, T2)`, ... | `()`, `('x',)`, `('x', 1.2)`, ... "
"|"
msgstr ""
"|        | Typy                         | Literay                          "
"|\n"
"|--------|-------------------------------|-----------------------------------|\n"
"| Tablice | `[T; N]`                      | `[20, 30, 40]`, `[0; 3]`         "
" |\n"
"| Krotki | `()`, `(T,)`, `(T1, T2)`, ... | `()`, `('x',)`, `('x', 1.2)`, ... "
"|"

#: src/basic-syntax/compound-types.md:8
msgid "Array assignment and access:"
msgstr "Przypisanie i dostp do tablicy:"

#: src/basic-syntax/compound-types.md:10
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut a: [i8; 10] = [42; 10];\n"
"    a[5] = 0;\n"
"    println!(\"a: {:?}\", a);\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let mut a: [i8; 10] = [42; 10];\n"
"    a[5] = 0;\n"
"    println!(\"a: {:?}\", a);\n"
"}\n"
"```"

#: src/basic-syntax/compound-types.md:18
msgid "Tuple assignment and access:"
msgstr "Przypisanie i dostp do krotki:"

#: src/basic-syntax/compound-types.md:20
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let t: (i8, bool) = (7, true);\n"
"    println!(\"1st index: {}\", t.0);\n"
"    println!(\"2nd index: {}\", t.1);\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let t: (i8, bool) = (7, true);\n"
"    println!(\"Pierwszy element: {}\", t.0);\n"
"    println!(\"Drugi element: {}\", t.1);\n"
"}\n"
"```"

#: src/basic-syntax/compound-types.md:32
msgid "Arrays:"
msgstr "Tablice:"

#: src/basic-syntax/compound-types.md:34
msgid ""
"* Arrays have elements of the same type, `T`, and length, `N`, which is a "
"compile-time constant.\n"
"  Note that the length of the array is *part of its type*, which means that "
"`[u8; 3]` and\n"
"  `[u8; 4]` are considered two different types."
msgstr ""
"* Tablice maj elementy tego samego typu, `T`, i dugo, `N`, kt贸ra jest "
"sta czasu kompilacji.\n"
"  Zauwa偶, 偶e dugo tablicy to *cz jej typu*, to znaczy, 偶e `[u8; 3]` i\n"
"  `[u8; 4]` to dwa r贸偶ne typy."

#: src/basic-syntax/compound-types.md:38
msgid "* We can use literals to assign values to arrays."
msgstr "* Mo偶emy u偶y litera贸w do przypisania wartoci do tablic."

#: src/basic-syntax/compound-types.md:40
msgid ""
"* In the main function, the print statement asks for the debug "
"implementation with the `?` format\n"
"  parameter: `{}` gives the default output, `{:?}` gives the debug output. "
"We\n"
"  could also have used `{a}` and `{a:?}` without specifying the value after "
"the\n"
"  format string."
msgstr ""
"* W funkcji main instrukcja print pyta o implementacj do debugowania za "
"pomoc parametru formatowania `?`:\n"
"  `{}` daje domylne wyjcie, `{:?}` daje wyjcie do debugowania. Moglimy\n"
"  r贸wnie偶 u偶y `{a}` i `{a:?}` bez okrelania wartoci po acuchu "
"formatujcym."

#: src/basic-syntax/compound-types.md:45
msgid ""
"* Adding `#`, eg `{a:#?}`, invokes a \"pretty printing\" format, which can "
"be easier to read."
msgstr ""
"* Dodanie `#`, np. `{a:#?}`, wywouje format \"adnego druku\", kt贸ry mo偶e "
"by atwiejszy do odczytania."

#: src/basic-syntax/compound-types.md:47
msgid "Tuples:"
msgstr "Krotki:"

#: src/basic-syntax/compound-types.md:49
msgid "* Like arrays, tuples have a fixed length."
msgstr "* Podobnie jak tablice, krotki maj sta dugo."

#: src/basic-syntax/compound-types.md:51
msgid "* Tuples group together values of different types into a compound type."
msgstr "* Krotki grupuj wartoci r贸偶nych typ贸w w typ zo偶ony."

#: src/basic-syntax/compound-types.md:53
msgid ""
"* Fields of a tuple can be accessed by the period and the index of the "
"value, e.g. `t.0`, `t.1`."
msgstr ""
"* Dostp do p贸l krotki mo偶na uzyska po kropce i indeksie wartoci, np. "
"`t.0`, `t.1`."

#: src/basic-syntax/compound-types.md:55
msgid ""
"* The empty tuple `()` is also known as the \"unit type\". It is both a "
"type, and\n"
"  the only valid value of that type - that is to say both the type and its "
"value\n"
"  are expressed as `()`. It is used to indicate, for example, that a "
"function or\n"
"  expression has no return value, as we'll see in a future slide. \n"
"    * You can think of it as `void` that can be familiar to you from other \n"
"      programming languages."
msgstr ""
"* Pusta krotka `()` jest r贸wnie偶 znana jako \"typ jednostkowy\". Jest to "
"zar贸wno typ, jak i\n"
"  jedyna poprawna warto tego typu  to znaczy zar贸wno typ, jak i jego "
"warto\n"
"  s wyra偶one jako `()`. Su偶y do wskazania, na przykad, 偶e funkcja lub\n"
"  wyra偶enie nie zwraca 偶adnej wartoci, co zobaczymy na kolejnym slajdzie.\n"
"    * Mo偶esz myle o tym jako o pustce (ang. `void`), kt贸ra mo偶e by ci "
"znana z innych\n"
"      jzyk贸w programowania."

#: src/basic-syntax/references.md:1
msgid "# References"
msgstr "# Referencje"

#: src/basic-syntax/references.md:3
msgid "Like C++, Rust has references:"
msgstr "Podobnie jak C++, Rust ma referencje:"

#: src/basic-syntax/references.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x: i32 = 10;\n"
"    let ref_x: &mut i32 = &mut x;\n"
"    *ref_x = 20;\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x: i32 = 10;\n"
"    let ref_x: &mut i32 = &mut x;\n"
"    *ref_x = 20;\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"

#: src/basic-syntax/references.md:14
msgid "Some notes:"
msgstr "Niekt贸re uwagi:"

#: src/basic-syntax/references.md:16
msgid ""
"* We must dereference `ref_x` when assigning to it, similar to C and C++ "
"pointers.\n"
"* Rust will auto-dereference in some cases, in particular when invoking\n"
"  methods (try `ref_x.count_ones()`).\n"
"* References that are declared as `mut` can be bound to different values "
"over their lifetime."
msgstr ""
"* Podczas przypisywania musimy wyuska referencj `ref_x`, podobnie jak w "
"przypadku wska藕nik贸w C i C++.\n"
"* W niekt贸rych przypadkach Rust dokona automatycznej dereferencji, w "
"szczeg贸lnoci podczas wywoywania\n"
"  metod (spr贸buj `ref_x.count_ones()`).\n"
"* Referencje zadeklarowane jako `mut` mog by powizane z r贸偶nymi "
"wartociami w czasie ich istnienia."

#: src/basic-syntax/references.md:21
msgid "<details>\nKey points:"
msgstr "<details>\nKluczowe punkty:"

#: src/basic-syntax/references.md:24
msgid ""
"* Be sure to note the difference between `let mut ref_x: &i32` and `let "
"ref_x:\n"
"  &mut i32`. The first one represents a mutable reference which can be bound "
"to\n"
"  different values, while the second represents a reference to a mutable "
"value."
msgstr ""
"* Pamitaj o r贸偶nicy midzy `let mut ref_x: &i32` i `let ref_x:\n"
"  &mut i32`. Pierwsza reprezentuje zmienn referencj, z kt贸r mo偶na "
"powiza\n"
"  r贸偶ne wartoci, podczas gdy druga reprezentuje odwoanie do zmiennej "
"wartoci."

#: src/basic-syntax/references-dangling.md:1
msgid "# Dangling References"
msgstr "# Wiszce referencje"

#: src/basic-syntax/references-dangling.md:3
msgid "Rust will statically forbid dangling references:"
msgstr "Rust bdzie statycznie zabrania wiszcych referencji:"

#: src/basic-syntax/references-dangling.md:5
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let ref_x: &i32;\n"
"    {\n"
"        let x: i32 = 10;\n"
"        ref_x = &x;\n"
"    }\n"
"    println!(\"ref_x: {ref_x}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let ref_x: &i32;\n"
"    {\n"
"        let x: i32 = 10;\n"
"        ref_x = &x;\n"
"    }\n"
"    println!(\"ref_x: {ref_x}\");\n"
"}\n"
"```"

#: src/basic-syntax/references-dangling.md:16
msgid ""
"* A reference is said to \"borrow\" the value it refers to.\n"
"* Rust is tracking the lifetimes of all references to ensure they live long\n"
"  enough.\n"
"* We will talk more about borrowing when we get to ownership."
msgstr ""
"* M贸wi si, 偶e referencja po偶ycza warto, do kt贸rej si odnosi.\n"
"* Rust ledzi czas 偶ycia wszystkich referencji, aby zapewni, 偶e maj "
"wystarczajco dugi czas 偶ycia.\n"
"* Porozmawiamy wicej o po偶yczaniu, kiedy przejdziemy do wasnoci."

#: src/basic-syntax/slices.md:1
msgid "# Slices"
msgstr "# Wycinki"

#: src/basic-syntax/slices.md:3
msgid "A slice gives you a view into a larger collection:"
msgstr "Wycinek daje wgld w wiksz kolekcj:"

#: src/basic-syntax/slices.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a: [i32; 6] = [10, 20, 30, 40, 50, 60];\n"
"    println!(\"a: {a:?}\");"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let a: [i32; 6] = [10, 20, 30, 40, 50, 60];\n"
"    println!(\"a: {a:?}\");"

#: src/basic-syntax/slices.md:10
msgid ""
"    let s: &[i32] = &a[2..4];\n"
"    println!(\"s: {s:?}\");\n"
"}\n"
"```"
msgstr ""
"    let s: &[i32] = &a[2..4];\n"
"    println!(\"s: {s:?}\");\n"
"}\n"
"```"

#: src/basic-syntax/slices.md:15
msgid ""
"* Slices borrow data from the sliced type.\n"
"* Question: What happens if you modify `a[3]`?"
msgstr ""
"* Wycinki po偶yczaj dane od citego typu.\n"
"* Pytanie: Co si stanie, jeli zmodyfikujesz `a[3]`?"

#: src/basic-syntax/slices.md:20
msgid ""
"* We create a slice by borrowing `a` and specifying the starting and ending "
"indexes in brackets."
msgstr ""
"* Tworzymy wycinek, po偶yczajc `a` i okrelajc indeksy pocztkowe i kocowe "
"w nawiasach."

#: src/basic-syntax/slices.md:22
msgid ""
"* If the slice starts at index 0, Rusts range syntax allows us to drop the "
"starting index, meaning that `&a[0..a.len()]` and `&a[..a.len()]` are "
"identical.\n"
"    \n"
"* The same is true for the last index, so `&a[2..a.len()]` and `&a[2..]` are "
"identical."
msgstr ""
"* Jeli wycinek zaczyna si od indeksu 0, skadnia zakresu Rusta pozwala nam "
"pomin indeks pocztkowy, co oznacza, 偶e `&a[0..a.len()]` i `&a[..a.len()]` "
"s identyczne .\n"
"    \n"
"* To samo dotyczy ostatniego indeksu, wic `&a[2..a.len()]` i `&a[2..]` s "
"identyczne."

#: src/basic-syntax/slices.md:26
msgid ""
"* To easily create a slice of the full array, we can therefore use `&a[..]`."
msgstr "* Aby atwo utworzy wycinek penej tablicy, mo偶emy zatem u偶y `&a[..]`."

#: src/basic-syntax/slices.md:28
msgid ""
"* `s` is a reference to a slice of `i32`s. Notice that the type of `s` "
"(`&[i32]`) no longer mentions the array length. This allows us to perform "
"computation on slices of different sizes.\n"
" \n"
"* Slices always borrow from another object. In this example, `a` has to "
"remain 'alive' (in scope) for at least as long as our slice. \n"
"    \n"
"* The question about modifying `a[3]` can spark an interesting discussion, "
"but the answer is that for memory safety reasons\n"
"  you cannot do it through `a` after you created a slice, but you can read "
"the data from both `a` and `s` safely. \n"
"  More details will be explained in the borrow checker section."
msgstr ""
"* `s` jest referencj do wycinka element贸w `i32`. Zauwa偶, 偶e typ `s` "
"(`&[i32]`) nie wspomina ju偶 o dugoci tablicy. To pozwala nam wykonywa "
"obliczenia na wycinkach o r贸偶nych rozmiarach.\n"
" \n"
"* Wycinki zawsze po偶yczaj od innego obiektu. W tym przykadzie `a` musi "
"pozosta '偶ywe' (w zakresie) przynajmniej tak dugo, jak nasz wycinek.\n"
"    \n"
"* Pytanie o modyfikacj `a[3]` mo偶e wywoa interesujc dyskusj, ale "
"odpowied藕 jest taka, 偶e ze wzgld贸w bezpieczestwa pamici\n"
"  nie mo偶esz tego zrobi przez `a` po utworzeniu wycinka, ale mo偶esz "
"bezpiecznie odczyta dane zar贸wno z `a` jak i `s`.\n"
"  Wicej szczeg贸贸w zostanie wyjanionych w sekcji o nadzorcy po偶yczania."

#: src/basic-syntax/string-slices.md:1
msgid "# `String` vs `str`"
msgstr "# `String` i `str`"

#: src/basic-syntax/string-slices.md:3
msgid "We can now understand the two string types in Rust:"
msgstr "Mo偶emy teraz zrozumie dwa typy acuch贸w w Rust:"

#: src/basic-syntax/string-slices.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: &str = \"World\";\n"
"    println!(\"s1: {s1}\");"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: &str = \"wiecie\";\n"
"    println!(\"s1: {s1}\");"

#: src/basic-syntax/string-slices.md:10
msgid ""
"    let mut s2: String = String::from(\"Hello \");\n"
"    println!(\"s2: {s2}\");\n"
"    s2.push_str(s1);\n"
"    println!(\"s2: {s2}\");\n"
"    \n"
"    let s3: &str = &s2[6..];\n"
"    println!(\"s3: {s3}\");\n"
"}\n"
"```"
msgstr ""
"    let mut s2: String = String::from(\"Witaj \");\n"
"    println!(\"s2: {s2}\");\n"
"    s2.push_str(s1);\n"
"    println!(\"s2: {s2}\");\n"
"    \n"
"    let s3: &str = &s2[6..];\n"
"    println!(\"s3: {s3}\");\n"
"}\n"
"```"

#: src/basic-syntax/string-slices.md:20
msgid "Rust terminology:"
msgstr "Terminologia Rusta:"

#: src/basic-syntax/string-slices.md:22
msgid ""
"* `&str` an immutable reference to a string slice.\n"
"* `String` a mutable string buffer."
msgstr ""
"* `&str` to niezmienna referencja do wycinka acucha.\n"
"* `String` to zmienny bufor acucha znak贸w."

#: src/basic-syntax/string-slices.md:27
msgid ""
"* `&str` introduces a string slice, which is an immutable reference to UTF-8 "
"encoded string data \n"
"  stored in a block of memory. String literals (`Hello`), are stored in "
"the programs binary."
msgstr ""
"* `&str` wprowadza fragment acucha, kt贸ry jest niezmiennym odniesieniem do "
"danych acuchowych zakodowanych w UTF-8\n"
"  przechowywanych w bloku pamici. Literay acuchowe (`\"Witaj\"`) s "
"przechowywane w pliku binarnym programu."

#: src/basic-syntax/string-slices.md:30
msgid ""
"* Rusts `String` type is a wrapper around a vector of bytes. As with a "
"`Vec<T>`, it is owned.\n"
"    \n"
"* As with many other types `String::from()` creates a string from a string "
"literal; `String::new()` \n"
"  creates a new empty string, to which string data can be added using the "
"`push()` and `push_str()` methods."
msgstr ""
"* Typ `String` to opakowanie dla wektora bajt贸w. Tak jak `Vec<T>`, ma dane na "
"wasno.\n"
"    \n"
"* Tak jak z wieloma innymi typami `String::from()` tworzy acuch z literau "
"znak贸w; `String::new()` \n"
"  tworzy pusty acuch, do kt贸rego mo偶na doda dane za pomoc metod `push()` "
"i `push_str()`."

#: src/basic-syntax/string-slices.md:35
msgid ""
"* The `format!()` macro is a convenient way to generate an owned string from "
"dynamic values. It \n"
"  accepts the same format specification as `println!()`.\n"
"    \n"
"* You can borrow `&str` slices from `String` via `&` and optionally range "
"selection.\n"
"    \n"
"* For C++ programmers: think of `&str` as `const char*` from C++, but the "
"one that always points \n"
"  to a valid string in memory. Rust `String` is a rough equivalent of "
"`std::string` from C++ \n"
"  (main difference: it can only contain UTF-8 encoded bytes and will never "
"use a small-string optimization).\n"
"    \n"
"</details>"
msgstr ""
"* Makro `format!()` jest wygodnym sposobem generowania posiadanego acucha "
"z wartoci dynamicznych.\n"
"  Akceptuje t sam specyfikacj formatu co `println!()`.\n"
"    \n"
"* Mo偶esz po偶yczy wycinki `&str` ze `String` za pomoc `&` i opcjonalnego "
"wyboru zakresu.\n"
"    \n"
"* Dla programist贸w C++: myl o `&str` jako o `const char*` z C++, ale tym, "
"kt贸re zawsze wskazuje\n"
"  do prawidowego cigu w pamici. Rust `String` jest przybli偶onym "
"odpowiednikiem `std::string` z C++\n"
"  (g贸wna r贸偶nica: mo偶e zawiera tylko bajty zakodowane w UTF-8 i nigdy nie "
"u偶yje optymalizacji maych cig贸w).\n"
"    \n"
"</details>"

#: src/basic-syntax/functions.md:1
msgid "# Functions"
msgstr "# Funkcje"

#: src/basic-syntax/functions.md:3
msgid ""
"A Rust version of the famous "
"[FizzBuzz](https://en.wikipedia.org/wiki/Fizz_buzz) interview question:"
msgstr ""
"Rustowa wersja synnego pytania z rozm贸w o prac "
"[FizzBuzz](https://en.wikipedia.org/wiki/Fizz_buzz):"

#: src/basic-syntax/functions.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    fizzbuzz_to(20);   // Defined below, no forward declaration needed\n"
"}"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    fizzbuzz_to(20);   // Zdefiniowany poni偶ej, nie ma potrzeby na "
"deklarowanie z g贸ry\n"
"}"

#: src/basic-syntax/functions.md:10
msgid ""
"fn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n"
"    if rhs == 0 {\n"
"        return false;  // Corner case, early return\n"
"    }\n"
"    lhs % rhs == 0     // The last expression in a block is the return "
"value\n"
"}"
msgstr ""
"fn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n"
"    if rhs == 0 {\n"
"        return false;  // Szczeg贸lny przypadek, wczesne wyjcie\n"
"    }\n"
"    lhs % rhs == 0     // Ostatnie wyra偶enie w bloku to zwracana warto\n"
"}"

#: src/basic-syntax/functions.md:17
msgid ""
"fn fizzbuzz(n: u32) -> () {  // No return value means returning the unit "
"type `()`\n"
"    match (is_divisible_by(n, 3), is_divisible_by(n, 5)) {\n"
"        (true,  true)  => println!(\"fizzbuzz\"),\n"
"        (true,  false) => println!(\"fizz\"),\n"
"        (false, true)  => println!(\"buzz\"),\n"
"        (false, false) => println!(\"{n}\"),\n"
"    }\n"
"}"
msgstr ""
"fn fizzbuzz(n: u32) -> () { // Brak wartoci zwracanej oznacza zwr贸cenie "
"typu jednostkowego `()`\n"
"    match (is_divisible_by(n, 3), is_divisible_by(n, 5)) {\n"
"        (true, true) => println!(\"fizzbuzz\"),\n"
"        (true, false) => println!(\"fizz\"),\n"
"        (false, true) => println!(\"buzz\"),\n"
"        (false, false) => println!(\"{n}\"),\n"
"    }\n"
"}"

#: src/basic-syntax/functions.md:26
msgid ""
"fn fizzbuzz_to(n: u32) {  // `-> ()` is normally omitted\n"
"    for i in 1..=n {\n"
"        fizzbuzz(i);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn fizzbuzz_to(n: u32) {  // `-> ()` jest zwykle pomijany\n"
"    for i in 1..=n {\n"
"        fizzbuzz(i);\n"
"    }\n"
"}\n"
"```"

#: src/basic-syntax/functions.md:35
msgid ""
"* We refer in `main` to a function written below. Neither forward "
"declarations nor headers are necessary. \n"
"* Declaration parameters are followed by a type (the reverse of some "
"programming languages), then a return type.\n"
"* The last expression in a function body (or any block) becomes the return "
"value. Simply omit the `;` at the end of the expression.\n"
"* Some functions have no return value, and return the 'unit type', `()`. The "
"compiler will infer this if the `-> ()` return type is omitted.\n"
"* The range expression in the `for` loop in `fizzbuzz_to()` contains `=n`, "
"which causes it to include the upper bound.\n"
"* The `match` expression in `fizzbuzz()` is doing a lot of work. It is "
"expanded below to show what is happening."
msgstr ""
"* W `main` odnosimy si do funkcji napisanej poni偶ej. Nie ma potrzeby na "
"deklaracje z gory lub na nag贸wki. \n"
"* Deklarowane parametry s poprzedzaj typ (na odwr贸t w por贸wnaniu do "
"niekt贸rych jzyk贸w programowania), potem zwracany typ.\n"
"* Ostatnie wyra偶enie w ciele funkcji (lub bloku) staje si zwracan "
"wartoci. Wystarczy pomin `;` na kocu wyra偶enia.\n"
"* Niekt贸re funkcje nie zwracaj wartoci, ich zwracany typ to 'typ "
"jednostkowy', `()`. Kompilator to wywnioskuje je偶eli `-> ()` jest "
"pominite.\n"
"* Wyra偶enie zakresu w ptli `for` w `fizzbuzz_to()` zawiera `=n`, powoduje "
"to zawarcie g贸rnego zakresu.\n"
"* Wyra偶enie `match` w `fizzbuzz()` wykonuje wiele pracy. Jest rozwinite "
"poni偶ej 偶eby pokaza co si dzieje."

#: src/basic-syntax/functions.md:42
msgid "  (Type annotations added for clarity, but they can be elided.)"
msgstr "  (Adnotacje typ贸w dodane dla przejrzystoci, ale mo偶na je pomin.)"

#: src/basic-syntax/functions.md:44
msgid ""
"  ```rust,ignore\n"
"  let by_3: bool = is_divisible_by(n, 3);\n"
"  let by_5: bool = is_divisible_by(n, 5);\n"
"  let by_35: (bool, bool) = (by_3, by_5);\n"
"  match by_35 {\n"
"    // ...\n"
"  ```"
msgstr ""
"  ```rust,ignore\n"
"  let by_3: bool = is_divisible_by(n, 3);\n"
"  let by_5: bool = is_divisible_by(n, 5);\n"
"  let by_35: (bool, bool) = (by_3, by_5);\n"
"  match by_35 {\n"
"    // ...\n"
"  ```"

#: src/basic-syntax/functions.md:52
msgid "  "
msgstr "  "

#: src/basic-syntax/methods.md:1 src/methods.md:1
msgid "# Methods"
msgstr "# Metody"

#: src/basic-syntax/methods.md:3
msgid ""
"Rust has methods, they are simply functions that are associated with a "
"particular type. The\n"
"first argument of a method is an instance of the type it is associated with:"
msgstr ""
"Rust ma metody, s to po prostu funkcje powizane z okrelonym typem.\n"
"Pierwszy argument metody jest instancj typu, z kt贸rym jest powizana:"

#: src/basic-syntax/methods.md:6
msgid ""
"```rust,editable\n"
"struct Rectangle {\n"
"    width: u32,\n"
"    height: u32,\n"
"}"
msgstr ""
"```rust,editable\n"
"struct Rectangle {\n"
"    width: u32,\n"
"    height: u32,\n"
"}"

#: src/basic-syntax/methods.md:12
msgid ""
"impl Rectangle {\n"
"    fn area(&self) -> u32 {\n"
"        self.width * self.height\n"
"    }"
msgstr ""
"impl Rectangle {\n"
"    fn area(&self) -> u32 {\n"
"        self.width * self.height\n"
"    }"

#: src/basic-syntax/methods.md:17
msgid ""
"    fn inc_width(&mut self, delta: u32) {\n"
"        self.width += delta;\n"
"    }\n"
"}"
msgstr ""
"    fn inc_width(&mut self, delta: u32) {\n"
"        self.width += delta;\n"
"    }\n"
"}"

#: src/basic-syntax/methods.md:22
msgid ""
"fn main() {\n"
"    let mut rect = Rectangle { width: 10, height: 5 };\n"
"    println!(\"old area: {}\", rect.area());\n"
"    rect.inc_width(5);\n"
"    println!(\"new area: {}\", rect.area());\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let mut rect = Rectangle { width: 10, height: 5 };\n"
"    println!(\"stare pole: {}\", rect.area());\n"
"    rect.inc_width(5);\n"
"    println!(\"nowe pole: {}\", rect.area());\n"
"}\n"
"```"

#: src/basic-syntax/methods.md:30
msgid ""
"* We will look much more at methods in today's exercise and in tomorrow's "
"class."
msgstr ""
"* W dzisiejszym wiczeniu i na jutrzejszych zajciach przyjrzymy si metodom "
"znacznie dokadniej."

#: src/basic-syntax/functions-interlude.md:1
msgid "# Function Overloading"
msgstr "# Przeci偶anie funkcji"

#: src/basic-syntax/functions-interlude.md:3
msgid "Overloading is not supported:"
msgstr "Przeci偶anie nie jest obsugiwane:"

#: src/basic-syntax/functions-interlude.md:5
msgid ""
"* Each function has a single implementation:\n"
"  * Always takes a fixed number of parameters.\n"
"  * Always takes a single set of parameter types.\n"
"* Default values are not supported:\n"
"  * All call sites have the same number of arguments.\n"
"  * Macros are sometimes used as an alternative."
msgstr ""
"* Ka偶da funkcja ma jedn implementacj:\n"
"  * Zawsze przyjmuje sta liczb parametr贸w.\n"
"  * Zawsze przyjmuje jeden zestaw typ贸w parametr贸w.\n"
"* Wartoci domylne nie s obsugiwane:\n"
"  * Wszystkie wywoania maj tak sam liczb argument贸w.\n"
"  * Makra s czasami u偶ywane jako alternatywa."

#: src/basic-syntax/functions-interlude.md:12
msgid "However, function parameters can be generic:"
msgstr "Jednak parametry funkcji mog by generyczne:"

#: src/basic-syntax/functions-interlude.md:14
msgid ""
"```rust,editable\n"
"fn pick_one<T>(a: T, b: T) -> T {\n"
"    if std::process::id() % 2 == 0 { a } else { b }\n"
"}"
msgstr ""
"```rust,editable\n"
"fn pick_one<T>(a: T, b: T) -> T {\n"
"    if std::process::id() % 2 == 0 { a } else { b }\n"
"}"

#: src/basic-syntax/functions-interlude.md:19
msgid ""
"fn main() {\n"
"    println!(\"coin toss: {}\", pick_one(\"heads\", \"tails\"));\n"
"    println!(\"cash prize: {}\", pick_one(500, 1000));\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    println!(\"rzut monet: {}\", pick_one(\"orze\", \"reszka\"));\n"
"    println!(\"nagroda: {}\", pick_one(500, 1000));\n"
"}\n"
"```"

#: src/basic-syntax/functions-interlude.md:27
msgid ""
"* When using generics, the standard library's `Into<T>` can provide a kind "
"of limited\n"
"  polymorphism on argument types. We will see more details in a later "
"section."
msgstr ""
"* Podczas korzystania z typ贸w generycznych, `Into<T>` z biblioteki "
"standardowej mo偶e zapewni pewnego rodzaju ograniczony\n"
"  polimorfizm typ贸w argument贸w. Wicej szczeg贸贸w zobaczymy w dalszej czci."

#: src/basic-syntax/functions-interlude.md:30
msgid "</defails>"
msgstr "</defails>"

#: src/exercises/day-1/morning.md:1
msgid "# Day 1: Morning Exercises"
msgstr "# Dzie 1: wiczenia poranne"

#: src/exercises/day-1/morning.md:3
msgid "In these exercises, we will explore two parts of Rust:"
msgstr "W tych wiczeniach przyjrzymy si dw贸m czciom Rusta:"

#: src/exercises/day-1/morning.md:5
msgid "* Implicit conversions between types."
msgstr "* Niejawne konwersje midzy typami."

#: src/exercises/day-1/morning.md:7
msgid "* Arrays and `for` loops."
msgstr "* Tablice i ptle `for`."

#: src/exercises/day-1/morning.md:11
msgid "A few things to consider while solving the exercises:"
msgstr ""
"Kilka rzeczy, kt贸re nale偶y wzi pod uwag podczas rozwizywania wicze:"

#: src/exercises/day-1/morning.md:13
msgid ""
"* Use a local Rust installation, if possible. This way you can get\n"
"  auto-completion in your editor. See the page about [Using Cargo] for "
"details\n"
"  on installing Rust."
msgstr ""
"* Jeli to mo偶liwe, u偶yj lokalnej instalacji Rusta. W ten spos贸b mo偶esz "
"dosta\n"
"  autouzupenianie w twoim edytorze. Wicej informacji o instalowaniu Rusta "
"znajdziesz na stronie o [Korzystaniu z Cargo]."

#: src/exercises/day-1/morning.md:17
msgid "* Alternatively, use the Rust Playground."
msgstr "* Ewentualnie skorzystaj z Rust Playground."

#: src/exercises/day-1/morning.md:19
msgid ""
"The code snippets are not editable on purpose: the inline code snippets "
"lose\n"
"their state if you navigate away from the page."
msgstr ""
"Fragment贸w kodu celowo nie mo偶na edytowa: wbudowane fragmenty kodu trac\n"
"stan, jeli opucisz stron."

#: src/exercises/day-1/morning.md:22 src/exercises/day-1/afternoon.md:11
#: src/exercises/day-2/morning.md:11 src/exercises/day-2/afternoon.md:7
#: src/exercises/day-3/morning.md:7 src/exercises/day-4/morning.md:12
msgid "After looking at the exercises, you can look at the [solutions] provided."
msgstr "Po obejrzeniu wicze mo偶esz spojrze na dostarczone [rozwizania]."

#: src/exercises/day-1/morning.md:24 src/exercises/day-2/morning.md:13
#: src/exercises/day-3/morning.md:9 src/exercises/day-4/morning.md:14
msgid "[solutions]: solutions-morning.md"
msgstr "[rozwizania]: solutions-morning.md"

#: src/exercises/day-1/morning.md:26
msgid "[Using Cargo]: ../../cargo.md"
msgstr "[Korzystaniu z Cargo]: ../../cargo.md"

#: src/exercises/day-1/implicit-conversions.md:1
msgid "# Implicit Conversions"
msgstr "# Niejawne konwersje"

#: src/exercises/day-1/implicit-conversions.md:3
msgid ""
"Rust will not automatically apply _implicit conversions_ between types "
"([unlike\n"
"C++][3]). You can see this in a program like this:"
msgstr ""
"Rust nie zastosuje automatycznie _niejawnych konwersji_ midzy typami ([w "
"przeciwiestwie do\n"
"C++][3]). Mo偶esz to zobaczy w takim programie:"

#: src/exercises/day-1/implicit-conversions.md:6
msgid ""
"```rust,editable,compile_fail\n"
"fn multiply(x: i16, y: i16) -> i16 {\n"
"    x * y\n"
"}"
msgstr ""
"```rust,editable,compile_fail\n"
"fn multiply(x: i16, y: i16) -> i16 {\n"
"    x * y\n"
"}"

#: src/exercises/day-1/implicit-conversions.md:11
msgid ""
"fn main() {\n"
"    let x: i8 = 15;\n"
"    let y: i16 = 1000;"
msgstr ""
"fn main() {\n"
"    let x: i8 = 15;\n"
"    let y: i16 = 1000;"

#: src/exercises/day-1/implicit-conversions.md:15
msgid ""
"    println!(\"{x} * {y} = {}\", multiply(x, y));\n"
"}\n"
"```"
msgstr ""
"    println!(\"{x} * {y} = {}\", multiply(x, y));\n"
"}\n"
"```"

#: src/exercises/day-1/implicit-conversions.md:19
msgid ""
"The Rust integer types all implement the [`From<T>`][1] and [`Into<T>`][2]\n"
"traits to let us convert between them. The `From<T>` trait has a single "
"`from()`\n"
"method and similarly, the `Into<T>` trait has a single `into()` method.\n"
"Implementing these traits is how a type expresses that it can be converted "
"into\n"
"another type."
msgstr ""
"Wszystkie typy cakowite w Rucie implementuj cechy [`From<T>`][1] i "
"[`Into<T>`][2]\n"
"aby umo偶liwi nam konwersj midzy nimi. Cecha `From<T>` ma jedn metod "
"`from()`\n"
"i podobnie cecha `Into<T>` ma jedn metod `into()`.\n"
"Implementacja tych cech to wyra偶enie, w jaki spos贸b mo偶na przeksztaci dany "
"typ\n"
"w inny typ."

#: src/exercises/day-1/implicit-conversions.md:25
msgid ""
"The standard library has an implementation of `From<i8> for i16`, which "
"means\n"
"that we can convert a variable `x` of type `i8` to an `i16` by calling \n"
"`i16::from(x)`. Or, simpler, with `x.into()`, because `From<i8> for i16`\n"
"implementation automatically create an implementation of `Into<i16> for i8`."
msgstr ""
"Standardowa biblioteka ma implementacj `From<i8>` dla `i16`, co oznacza\n"
"偶e mo偶emy zamieni zmienn `x` typu `i8` na `i16` przez wywoanie\n"
"`i16::from(x)`. Lub, prociej, za pomoc `x.into()`, poniewa偶 implementacja "
"`From<i8>` dla `i16`\n"
"automatycznie tworzy implementacj `Into<i16>` dla `i8`."

#: src/exercises/day-1/implicit-conversions.md:30
msgid ""
"The same applies for your own `From` implementations for your own types, so "
"it is\n"
"sufficient to only implement `From` to get a respective `Into` "
"implementation automatically."
msgstr ""
"To samo dotyczy twoich wasnych implementacji `From` dla twoich wasnych "
"typ贸w, wic\n"
"wystarczy zaimplementowa tylko `From`, aby automatycznie uzyska "
"odpowiedni implementacj `Into`."

#: src/exercises/day-1/implicit-conversions.md:33
msgid "1. Execute the above program and look at the compiler error."
msgstr "1. Uruchom powy偶szy program i sp贸jrz na bd kompilatora."

#: src/exercises/day-1/implicit-conversions.md:35
msgid "2. Update the code above to use `into()` to do the conversion."
msgstr ""
"2. Zaktualizuj powy偶szy kod, aby u偶y funkcji `into()` do przeprowadzenia "
"konwersji."

#: src/exercises/day-1/implicit-conversions.md:37
msgid ""
"3. Change the types of `x` and `y` to other things (such as `f32`, `bool`,\n"
"   `i128`) to see which types you can convert to which other types. Try\n"
"   converting small types to big types and the other way around. Check the\n"
"   [standard library documentation][1] to see if `From<T>` is implemented "
"for\n"
"   the pairs you check."
msgstr ""
"3. Zmie typy `x` i `y` na inne (takie jak `f32`, `bool`,\n"
"   `i128`), aby zobaczy, kt贸re typy mo偶na przekonwertowa na inne typy. "
"Spr贸buj\n"
"   konwertowa mae typy na du偶e i na odwr贸t. Sprawd藕\n"
"   [dokumentacj biblioteki standardowej][1], aby zobaczy, czy `From<T>` "
"jest zaimplementowane\n"
"   dla pary typ贸w, kt贸re sprawdzasz."

#: src/exercises/day-1/implicit-conversions.md:43
msgid ""
"[1]: https://doc.rust-lang.org/std/convert/trait.From.html\n"
"[2]: https://doc.rust-lang.org/std/convert/trait.Into.html\n"
"[3]: https://en.cppreference.com/w/cpp/language/implicit_conversion"
msgstr ""
"[1]: https://doc.rust-lang.org/std/convert/trait.From.html\n"
"[2]: https://doc.rust-lang.org/std/convert/trait.Into.html\n"
"[3]: https://en.cppreference.com/w/cpp/language/implicit_conversion"

#: src/exercises/day-1/for-loops.md:1
msgid "# Arrays and `for` Loops"
msgstr "# Tablice i ptle `for`"

#: src/exercises/day-1/for-loops.md:3
msgid "We saw that an array can be declared like this:"
msgstr "Widzielimy, 偶e tablic mo偶na zadeklarowa w nastpujcy spos贸b:"

#: src/exercises/day-1/for-loops.md:5
msgid ""
"```rust\n"
"let array = [10, 20, 30];\n"
"```"
msgstr ""
"```rust\n"
"let array = [10, 20, 30];\n"
"```"

#: src/exercises/day-1/for-loops.md:9
msgid ""
"You can print such an array by asking for its debug representation with "
"`{:?}`:"
msgstr ""
"Mo偶esz wydrukowa tak tablic, proszc o jej reprezentacj debugowania za "
"pomoc `{:?}`:"

#: src/exercises/day-1/for-loops.md:11
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    println!(\"array: {array:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    println!(\"array: {array:?}\");\n"
"}\n"
"```"

#: src/exercises/day-1/for-loops.md:18
msgid ""
"Rust lets you iterate over things like arrays and ranges using the `for`\n"
"keyword:"
msgstr ""
"Rust pozwala iterowa po takich rzeczach, jak tablice i zakresy, u偶ywajc "
"sowa kluczowego `for`:"

#: src/exercises/day-1/for-loops.md:21
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    print!(\"Iterating over array:\");\n"
"    for n in array {\n"
"        print!(\" {n}\");\n"
"    }\n"
"    println!();"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    print!(\"Iterowanie po tablicy:\");\n"
"    for n in array {\n"
"        print!(\" {n}\");\n"
"    }\n"
"    println!();"

#: src/exercises/day-1/for-loops.md:30
msgid ""
"    print!(\"Iterating over range:\");\n"
"    for i in 0..3 {\n"
"        print!(\" {}\", array[i]);\n"
"    }\n"
"    println!();\n"
"}\n"
"```"
msgstr ""
"    print!(\"Iterowanie po zakresie:\");\n"
"    for i in 0..3 {\n"
"        print!(\" {}\", array[i]);\n"
"    }\n"
"    println!();\n"
"}\n"
"```"

#: src/exercises/day-1/for-loops.md:38
msgid ""
"Use the above to write a function `pretty_print` which pretty-print a matrix "
"and\n"
"a function `transpose` which will transpose a matrix (turn rows into "
"columns):"
msgstr ""
"U偶yj powy偶szego, aby napisa funkcj `pretty_print`, kt贸ra adnie drukuje "
"macierz i\n"
"funkcj `transpose`, kt贸ra transponuje macierz (zamienia wiersze na kolumny):"

#: src/exercises/day-1/for-loops.md:41
msgid ""
"```bob\n"
"           1 2 3も      1 4 7\n"
"\"transpose\"4 5 6モ  \"==\"2 5 8\n"
"           7 8 9      3 6 9\n"
"```"
msgstr ""
"```bob\n"
"           1 2 3も      1 4 7\n"
"\"transpose\"4 5 6モ  \"==\"2 5 8\n"
"           7 8 9      3 6 9\n"
"```"

#: src/exercises/day-1/for-loops.md:47
msgid "Hard-code both functions to operate on 3  3 matrices."
msgstr "Zakoduj na stae obie funkcje, aby dziaay na macierzach 3  3."

#: src/exercises/day-1/for-loops.md:49
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and implement the\n"
"functions:"
msgstr ""
"Skopiuj poni偶szy kod do <https://play.rust-lang.org/> i zaimplementuj\n"
"funkcje:"

#: src/exercises/day-1/for-loops.md:52 src/exercises/day-1/book-library.md:20
#: src/exercises/day-2/health-statistics.md:13
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]"
msgstr ""
"```rust,should_panic\n"
"// TODO: usu to jak skoczysz implementacj.\n"
"#![allow(unused_variables, dead_code)]"

#: src/exercises/day-1/for-loops.md:56
msgid ""
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    unimplemented!()\n"
"}"
msgstr ""
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    unimplemented!()\n"
"}"

#: src/exercises/day-1/for-loops.md:60
msgid ""
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    unimplemented!()\n"
"}"
msgstr ""
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    unimplemented!()\n"
"}"

#: src/exercises/day-1/for-loops.md:64
msgid ""
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];"
msgstr ""
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- ten komentarz powoduje, 偶e rustfmt dodaje "
"now lini\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];"

#: src/exercises/day-1/for-loops.md:71 src/exercises/day-1/solutions-morning.md:70
msgid "    println!(\"matrix:\");\n    pretty_print(&matrix);"
msgstr "    println!(\"matrix:\");\n    pretty_print(&matrix);"

#: src/exercises/day-1/for-loops.md:74
msgid ""
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```"
msgstr ""
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```"

#: src/exercises/day-1/for-loops.md:80
msgid "## Bonus Question"
msgstr "## Dodatkowe pytanie"

#: src/exercises/day-1/for-loops.md:82
msgid ""
"Could you use `&[i32]` slices instead of hard-coded 3  3 matrices for your\n"
"argument and return types? Something like `&[&[i32]]` for a two-dimensional\n"
"slice-of-slices. Why or why not?"
msgstr ""
"Czy m贸gby u偶y wycink贸w `&[i32]` zamiast zakodowanych na stae macierzy 3 "
" 3 dla\n"
"typ贸w argument贸w i typ贸w zwracanych? Co w stylu `&[&[i32]]` dla "
"dwuwymiarowych\n"
"wycink贸w-wycink贸w. Dlaczego tak lub dlaczego nie?"

#: src/exercises/day-1/for-loops.md:87
msgid ""
"See the [`ndarray` crate](https://docs.rs/ndarray/) for a production "
"quality\n"
"implementation."
msgstr ""
"Zobacz [skrzyni `ndarray`](https://docs.rs/ndarray/) dla implementacji "
"produkcyjnej jakoci."

#: src/exercises/day-1/for-loops.md:92
msgid ""
"The solution and the answer to the bonus section are available in the \n"
"[Solution](solutions-morning.md#arrays-and-for-loops) section."
msgstr ""
"Rozwizanie i odpowied藕 do sekcji bonusowej s dostpne w\n"
"sekcji [Rozwizanie](solutions-morning.md#arrays-and-for-loops)."

#: src/basic-syntax/variables.md:1
msgid "# Variables"
msgstr "# Zmienne"

#: src/basic-syntax/variables.md:3
msgid ""
"Rust provides type safety via static typing. Variable bindings are immutable "
"by\n"
"default:"
msgstr ""
"Rust zapewnia bezpieczestwo typ贸w dziki statycznemu typowaniu. Wizania "
"zmiennych s domylnie niezmienne:"

#: src/basic-syntax/variables.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x: i32 = 10;\n"
"    println!(\"x: {x}\");\n"
"    // x = 20;\n"
"    // println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let x: i32 = 10;\n"
"    println!(\"x: {x}\");\n"
"    // x = 20;\n"
"    // println!(\"x: {x}\");\n"
"}\n"
"```"

#: src/basic-syntax/variables.md:17
msgid ""
"* Due to type inference the `i32` is optional. We will gradually show the "
"types less and less as the course progresses.\n"
"* Note that since `println!` is a macro, `x` is not moved, even using the "
"function like syntax of `println!(\"x: {}\", x)`"
msgstr ""
"* Ze wzgldu na wnioskowanie o typie `i32` jest opcjonalne. Stopniowo "
"bdziemy pokazywa mniej typ贸w w miar postp贸w w kursie.\n"
"* Zauwa偶, 偶e poniewa偶 `println!` jest makrem, `x` nie jest przenoszone, "
"nawet przy u偶yciu skadni podobnej do funkcji `println!(\"x: {}\", x)`"

#: src/basic-syntax/type-inference.md:1
msgid "# Type Inference"
msgstr "# Wnioskowanie typ贸w"

#: src/basic-syntax/type-inference.md:3
msgid "Rust will look at how the variable is _used_ to determine the type:"
msgstr "Rust sprawdzi, w jaki spos贸b zmienna jest _u偶ywana_ do okrelenia typu:"

#: src/basic-syntax/type-inference.md:5
msgid ""
"```rust,editable\n"
"fn takes_u32(x: u32) {\n"
"    println!(\"u32: {x}\");\n"
"}"
msgstr ""
"```rust,editable\n"
"fn takes_u32(x: u32) {\n"
"    println!(\"u32: {x}\");\n"
"}"

#: src/basic-syntax/type-inference.md:10
msgid ""
"fn takes_i8(y: i8) {\n"
"    println!(\"i8: {y}\");\n"
"}"
msgstr ""
"fn takes_i8(y: i8) {\n"
"    println!(\"i8: {y}\");\n"
"}"

#: src/basic-syntax/type-inference.md:14
msgid ""
"fn main() {\n"
"    let x = 10;\n"
"    let y = 20;"
msgstr ""
"fn main() {\n"
"    let x = 10;\n"
"    let y = 20;"

#: src/basic-syntax/type-inference.md:18
msgid ""
"    takes_u32(x);\n"
"    takes_i8(y);\n"
"    // takes_u32(y);\n"
"}\n"
"```"
msgstr ""
"    takes_u32(x);\n"
"    takes_i8(y);\n"
"    // takes_u32(y);\n"
"}\n"
"```"

#: src/basic-syntax/type-inference.md:26
msgid ""
"This slide demonstrates how the Rust compiler infers types based on "
"constraints given by variable declarations and usages.\n"
"    \n"
"It is very important to emphasize that variables declared like this are not "
"of some sort of dynamic \"any type\" that can\n"
"hold any data. The machine code generated by such declaration is identical "
"to the explicit declaration of a type.\n"
"The compiler does the job for us and helps us write more concise code."
msgstr ""
"Ten slajd pokazuje, w jaki spos贸b kompilator Rusta wnioskuje o typach na "
"podstawie ogranicze nao偶onych przez deklaracje i zastosowania zmiennych.\n"
"    \n"
"Bardzo wa偶ne jest podkrelenie, 偶e zmienne zadeklarowane w ten spos贸b nie s "
"jakim dynamicznym dowolnym typem, kt贸ry mo偶e\n"
"przechowywa dowolne dane. Kod maszynowy generowany przez tak deklaracj "
"jest identyczny z jawn deklaracj typu.\n"
"Kompilator wykonuje to za nas i pomaga nam pisa bardziej zwizy kod."

#: src/basic-syntax/type-inference.md:32
msgid ""
"The following code tells the compiler to copy into a certain generic "
"container without the code ever explicitly specifying the contained type, "
"using `_` as a placeholder:"
msgstr ""
"Poni偶szy kod m贸wi kompilatorowi, aby skopiowa do pewnego og贸lnego kontenera "
"bez jawnego okrelania typu zawartego w kodzie, u偶ywajc `_` jako symbolu "
"zastpczego:"

#: src/basic-syntax/type-inference.md:34
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v = Vec::new();\n"
"    v.push((10, false));\n"
"    v.push((20, true));\n"
"    println!(\"v: {v:?}\");"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v = Vec::new();\n"
"    v.push((10, false));\n"
"    v.push((20, true));\n"
"    println!(\"v: {v:?}\");"

#: src/basic-syntax/type-inference.md:41
msgid ""
"    let vv = v.iter().collect::<std::collections::HashSet<_>>();\n"
"    println!(\"vv: {vv:?}\");\n"
"}\n"
"```"
msgstr ""
"    let vv = v.iter().collect::<std::collections::HashSet<_>>();\n"
"    println!(\"vv: {vv:?}\");\n"
"}\n"
"```"

#: src/basic-syntax/type-inference.md:46
msgid ""
"[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.collect) "
"relies on `FromIterator`, which "
"[`HashSet`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html) "
"implements."
msgstr ""
"[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.collect) "
"polega na `FromIterator`, kt贸ry [`HashSet`](https:/ "
"/doc.rust-lang.org/std/iter/trait.FromIterator.html) implementuje."

#: src/basic-syntax/static-and-const.md:1
msgid "# Static and Constant Variables"
msgstr "# Zmienne statyczne i stae"

#: src/basic-syntax/static-and-const.md:3
msgid "Global state is managed with static and constant variables."
msgstr "Stan globalny jest zarzdzany za pomoc zmiennych statycznych i staych."

#: src/basic-syntax/static-and-const.md:5
msgid "## `const`"
msgstr "## `const`"

#: src/basic-syntax/static-and-const.md:7
msgid "You can declare compile-time constants:"
msgstr "Mo偶esz zadeklarowa stae czasu kompilacji:"

#: src/basic-syntax/static-and-const.md:9
msgid ""
"```rust,editable\n"
"const DIGEST_SIZE: usize = 3;\n"
"const ZERO: Option<u8> = Some(42);"
msgstr ""
"```rust,editable\n"
"const DIGEST_SIZE: usize = 3;\n"
"const ZERO: Option<u8> = Some(42);"

#: src/basic-syntax/static-and-const.md:13
msgid ""
"fn compute_digest(text: &str) -> [u8; DIGEST_SIZE] {\n"
"    let mut digest = [ZERO.unwrap_or(0); DIGEST_SIZE];\n"
"    for (idx, &b) in text.as_bytes().iter().enumerate() {\n"
"        digest[idx % DIGEST_SIZE] = digest[idx % "
"DIGEST_SIZE].wrapping_add(b);\n"
"    }\n"
"    digest\n"
"}"
msgstr ""
"fn compute_digest(text: &str) -> [u8; DIGEST_SIZE] {\n"
"    let mut digest = [ZERO.unwrap_or(0); DIGEST_SIZE];\n"
"    for (idx, &b) in text.as_bytes().iter().enumerate() {\n"
"        digest[idx % DIGEST_SIZE] = digest[idx % "
"DIGEST_SIZE].wrapping_add(b);\n"
"    }\n"
"    digest\n"
"}"

#: src/basic-syntax/static-and-const.md:21
msgid ""
"fn main() {\n"
"    let digest = compute_digest(\"Hello\");\n"
"    println!(\"Digest: {digest:?}\");\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let digest = compute_digest(\"Hello\");\n"
"    println!(\"Digest: {digest:?}\");\n"
"}\n"
"```"

#: src/basic-syntax/static-and-const.md:27
msgid "According the the [Rust RFC Book][1] these are inlined upon use."
msgstr "Zgodnie z [ksi偶k Rust RFC][1] s one wstawiane podczas u偶ycia."

#: src/basic-syntax/static-and-const.md:29
msgid "## `static`"
msgstr "## `static`"

#: src/basic-syntax/static-and-const.md:31
msgid "You can also declare static variables:"
msgstr "Mo偶esz tak偶e zadeklarowa zmienne statyczne:"

#: src/basic-syntax/static-and-const.md:33
msgid "```rust,editable\nstatic BANNER: &str = \"Welcome to RustOS 3.14\";"
msgstr "```rust,editable\nstatic BANNER: &str = \"Witamy w RustOS 3.14\";"

#: src/basic-syntax/static-and-const.md:36
msgid ""
"fn main() {\n"
"    println!(\"{BANNER}\");\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    println!(\"{BANNER}\");\n"
"}\n"
"```"

#: src/basic-syntax/static-and-const.md:41
msgid ""
"As noted in the [Rust RFC Book][1], these are not inlined upon use and have "
"an actual associated memory location.  This is useful for unsafe and "
"embedded code, and the variable lives through the entirety of the program "
"execution."
msgstr ""
"Jak zauwa偶ono w [ksi偶ce Rust RFC][1], nie s one wstawiane podczas u偶ycia i "
"maj rzeczywist powizan lokalizacj pamici. Jest to przydatne w "
"przypadku niebezpiecznego i osadzonego kodu, a zmienna 偶yje przez cae "
"wykonanie programu."

#: src/basic-syntax/static-and-const.md:44
msgid ""
"We will look at mutating static data in the [chapter on Unsafe "
"Rust](../unsafe.md)."
msgstr ""
"Przyjrzymy si zmienianiu danych statycznych w [rozdziale dotyczcym "
"niebezpiecznego Rusta](../unsafe.md)."

#: src/basic-syntax/static-and-const.md:48
msgid ""
"* Mention that `const` behaves semantically similar to C++'s `constexpr`.\n"
"* `static`, on the other hand, is much more similar to a `const` or mutable "
"global variable in C++.\n"
"* It isn't super common that one would need a runtime evaluated constant, "
"but it is helpful and safer than using a static."
msgstr ""
"* Wspomnij, 偶e `const` zachowuje si semantycznie podobnie do `constexpr` "
"C++.\n"
"* Z drugiej strony `static` jest znacznie bardziej podobny do `const` lub "
"mutowalnej zmiennej globalnej w C++.\n"
"* Nie jest bardzo powszechne, 偶e kto potrzebowaby staej wyliczanej w "
"czasie wykonywania, ale jest to pomocne i bezpieczniejsze ni偶 u偶ywanie "
"zmiennej statycznej."

#: src/basic-syntax/static-and-const.md:54
msgid "[1]: https://rust-lang.github.io/rfcs/0246-const-vs-static.html"
msgstr "[1]: https://rust-lang.github.io/rfcs/0246-const-vs-static.html"

#: src/basic-syntax/scopes-shadowing.md:1
msgid "# Scopes and Shadowing"
msgstr "# Zakresy i przesanianie"

#: src/basic-syntax/scopes-shadowing.md:3
msgid ""
"You can shadow variables, both those from outer scopes and variables from "
"the\n"
"same scope:"
msgstr ""
"Mo偶esz przesania zmienne, zar贸wno te z zakres贸w zewntrznych, jak i "
"zmienne z\n"
"tego samego zakresu:"

#: src/basic-syntax/scopes-shadowing.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 10;\n"
"    println!(\"before: {a}\");"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 10;\n"
"    println!(\"przedtem: {a}\");"

#: src/basic-syntax/scopes-shadowing.md:11
msgid ""
"    {\n"
"        let a = \"hello\";\n"
"        println!(\"inner scope: {a}\");"
msgstr ""
"    {\n"
"        let a = \"cze\";\n"
"        println!(\"wewntrzny zakres: {a}\");"

#: src/basic-syntax/scopes-shadowing.md:15
msgid ""
"        let a = true;\n"
"        println!(\"shadowed in inner scope: {a}\");\n"
"    }"
msgstr ""
"        let a = true;\n"
"        println!(\"przesonita w wewntrznym zakresie: {a}\");\n"
"    }"

#: src/basic-syntax/scopes-shadowing.md:19
msgid ""
"    println!(\"after: {a}\");\n"
"}\n"
"```"
msgstr ""
"    println!(\"potem: {a}\");\n"
"}\n"
"```"

#: src/basic-syntax/scopes-shadowing.md:25
msgid ""
"* Definition: Shadowing is different from mutation, because after shadowing "
"both variable's memory locations exist at the same time. Both are available "
"under the same name, depending where you use it in the code. \n"
"* A shadowing variable can have a different type. \n"
"* Shadowing looks obscure at first, but is convenient for holding on to "
"values after `.unwrap()`.\n"
"* The following code demonstrates why the compiler can't simply reuse memory "
"locations when shadowing an immutable variable in a scope, even if the type "
"does not change."
msgstr ""
"* Definicja: Przesanianie r贸偶ni si od mutacji, poniewa偶 po przesanianiu "
"obie lokalizacje pamici istniej w tym samym czasie. Obie s dostpne pod "
"t sam nazw, w zale偶noci od tego, gdzie u偶ywasz ich w kodzie.\n"
"* Zmienna przesaniajca mo偶e mie inny typ.\n"
"* Przesanianie na pierwszy rzut oka wyglda niejasno, ale jest wygodne do "
"trzymania wartoci po `.unwrap()`.\n"
"* Poni偶szy kod ilustruje, dlaczego kompilator nie mo偶e po prostu ponownie "
"u偶y lokalizacji pamici podczas przesaniania niemutowalnej zmiennej w "
"zakresie, nawet jeli typ si nie zmienia."

#: src/basic-syntax/scopes-shadowing.md:30
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 1;\n"
"    let b = &a;\n"
"    let a = a + 1;\n"
"    println!(\"{a} {b}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 1;\n"
"    let b = &a;\n"
"    let a = a + 1;\n"
"    println!(\"{a} {b}\");\n"
"}\n"
"```"

#: src/memory-management.md:1
msgid "# Memory Management"
msgstr "# Zarzdzanie pamici"

#: src/memory-management.md:3
msgid "Traditionally, languages have fallen into two broad categories:"
msgstr "Tradycyjnie jzyki dzieliy si na dwie szerokie kategorie:"

#: src/memory-management.md:5
msgid ""
"* Full control via manual memory management: C, C++, Pascal, ...\n"
"* Full safety via automatic memory management at runtime: Java, Python, Go, "
"Haskell, ..."
msgstr ""
"* Pena kontrola poprzez rczne zarzdzanie pamici: C, C++, Pascal, ...\n"
"* Pene bezpieczestwo dziki automatycznemu zarzdzaniu pamici w czasie "
"wykonywania: Java, Python, Go, Haskell, ..."

#: src/memory-management.md:8
msgid "Rust offers a new mix:"
msgstr "Rust oferuje now mieszank:"

#: src/memory-management.md:10
msgid ""
"> Full control *and* safety via compile time enforcement of correct memory\n"
"> management."
msgstr ""
"> Pena kontrola *i* bezpieczestwo poprzez egzekwowanie poprawnego "
"zarzdzania pamici w czasie kompilacji."

#: src/memory-management.md:13
msgid "It does this with an explicit ownership concept."
msgstr "Czyni to z wyra藕n koncepcj wasnoci."

#: src/memory-management.md:15
msgid "First, let's refresh how memory management works."
msgstr "Najpierw odwie偶my, jak dziaa zarzdzanie pamici."

#: src/memory-management/stack-vs-heap.md:1
msgid "# The Stack vs The Heap"
msgstr "# Stos a sterta"

#: src/memory-management/stack-vs-heap.md:3
msgid ""
"* Stack: Continuous area of memory for local variables.\n"
"  * Values have fixed sizes known at compile time.\n"
"  * Extremely fast: just move a stack pointer.\n"
"  * Easy to manage: follows function calls.\n"
"  * Great memory locality."
msgstr ""
"* Stos: cigy obszar pamici dla zmiennych lokalnych.\n"
"  * Wartoci maj stae rozmiary znane w czasie kompilacji.\n"
"  * Niezwykle szybki: wystarczy przesun wska藕nik stosu.\n"
"  * atwy w zarzdzaniu: pod偶a za wywoaniami funkcji.\n"
"  * wietna lokalno pamici."

#: src/memory-management/stack-vs-heap.md:9
msgid ""
"* Heap: Storage of values outside of function calls.\n"
"  * Values have dynamic sizes determined at runtime.\n"
"  * Slightly slower than the stack: some book-keeping needed.\n"
"  * No guarantee of memory locality."
msgstr ""
"* Sterta: Przechowywanie wartoci poza wywoaniami funkcji.\n"
"  * Wartoci maj dynamiczne rozmiary okrelone w czasie wykonywania.\n"
"  * Nieco wolniejsza ni偶 stos: potrzebne troch ksigowoci.\n"
"  * Brak gwarancji lokalnoci pamici."

#: src/memory-management/stack.md:1
msgid "# Stack Memory"
msgstr "# Pami stosu"

#: src/memory-management/stack.md:3
msgid ""
"Creating a `String` puts fixed-sized data on the stack and dynamically "
"sized\n"
"data on the heap:"
msgstr ""
"Utworzenie `String` powoduje umieszczenie danych o staym rozmiarze na "
"stosie i danych o dynamicznym rozmiarze\n"
"na stercie:"

#: src/memory-management/stack.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1 = String::from(\"Hello\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let s1 = String::from(\"Hello\");\n"
"}\n"
"```"

#: src/memory-management/stack.md:12
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - -.\n"
":                           :     :                               :\n"
":    s1                     :     :                               :\n"
":   +-----------+-------+   :     :   +----+----+----+----+----+  :\n"
":   | ptr       |   o---+---+-----+-->| H  | e  | l  | l  | o  |  :\n"
":   | len       |     5 |   :     :   +----+----+----+----+----+  :\n"
":   | capacity  |     5 |   :     :                               :\n"
":   +-----------+-------+   :     :                               :\n"
":                           :     `- - - - - - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stos                             Sterta\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - -.\n"
":                           :     :                               :\n"
":    s1                     :     :                               :\n"
":   +-----------+-------+   :     :   +----+----+----+----+----+  :\n"
":   | ptr       |   o---+---+-----+-->| H  | e  | l  | l  | o  |  :\n"
":   | len       |     5 |   :     :   +----+----+----+----+----+  :\n"
":   | capacity  |     5 |   :     :                               :\n"
":   +-----------+-------+   :     :                               :\n"
":                           :     `- - - - - - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/memory-management/stack.md:28
msgid ""
"* Mention that a `String` is backed by a `Vec`, so it has a capacity and "
"length and can grow if mutable via reallocation on the heap."
msgstr ""
"* Wspomnij, 偶e `String` jest oparty o `Vec`, wic ma pojemno i dugo, i "
"je偶eli jest mutowalny to mo偶e rosn poprzez realokacj na stercie."

#: src/memory-management/stack.md:30
msgid ""
"* If students ask about it, you can mention that the underlying memory is "
"heap allocated using the [System Allocator] and custom allocators can be "
"implemented using the [Allocator API]"
msgstr ""
"* Je偶eli uczniowie o to zapytaj to mo偶esz wspomnie, 偶e pami na stercie "
"jest alokowana za pomoc [alokatora systemowego] I wasny alokator mo偶e by "
"zaimplementowany u偶ywajc [API alokatora]"

#: src/memory-management/stack.md:32
msgid ""
"* We can inspect the memory layout with `unsafe` code. However, you should "
"point out that this is rightfully unsafe!"
msgstr ""
"* Mo偶emy zrobi inspekcj rozo偶enia pamici w niebezpiecznym (`unsafe`) "
"kodzie. Jednak nale偶y zauwa偶y, 偶e jest to niebezpieczne!"

#: src/memory-management/stack.md:34
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::from(\"Hello\");\n"
"    s1.push(' ');\n"
"    s1.push_str(\"world\");\n"
"    // DON'T DO THIS AT HOME! For educational purposes only.\n"
"    // String provides no guarantees about its layout, so this could lead "
"to\n"
"    // undefined behavior.\n"
"    unsafe {\n"
"        let (capacity, ptr, len): (usize, usize, usize) = "
"std::mem::transmute(s1);\n"
"        println!(\"ptr = {ptr:#x}, len = {len}, capacity = {capacity}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::from(\"Hello\");\n"
"    s1.push(' ');\n"
"    s1.push_str(\"world\");\n"
"    // NIE PRBUJCIE TEGO W DOMU! Tylko dla cel贸w edukacyjnych.\n"
"    // String nie gwarantuje rozo偶enia pamici wic to mo偶e prowadzi do\n"
"    // niezdefiniowanego zachowania.\n"
"    unsafe {\n"
"        let (capacity, ptr, len): (usize, usize, usize) = "
"std::mem::transmute(s1);\n"
"        println!(\"ptr = {ptr:#x}, len = {len}, capacity = {capacity}\");\n"
"    }\n"
"}\n"
"```"

#: src/memory-management/stack.md:51
msgid ""
"[System Allocator]: https://doc.rust-lang.org/std/alloc/struct.System.html\n"
"[Allocator API]: https://doc.rust-lang.org/std/alloc/index.html"
msgstr ""
"[alokatora systemowego]: "
"https://doc.rust-lang.org/std/alloc/struct.System.html\n"
"[API alokatora]: https://doc.rust-lang.org/std/alloc/index.html"

#: src/memory-management/manual.md:1
msgid "# Manual Memory Management"
msgstr "# Rczne zarzdzanie pamici"

#: src/memory-management/manual.md:3
msgid "You allocate and deallocate heap memory yourself."
msgstr "Mo偶esz wasnorcznie alokowa i zwalnia pami sterty."

#: src/memory-management/manual.md:5
msgid ""
"If not done with care, this can lead to crashes, bugs, security "
"vulnerabilities, and memory leaks."
msgstr ""
"Je偶eli nie jest to zrobione z uwag to mo偶e prowadzi do zaamania "
"(\"crash\"), bd贸w, problem贸w bezpieczestwa i wyciek贸w pamici."

#: src/memory-management/manual.md:7
msgid "## C Example"
msgstr "## Przykad C"

#: src/memory-management/manual.md:9
msgid "You must call `free` on every pointer you allocate with `malloc`:"
msgstr ""
"Musisz wywoa `free` na ka偶dym wska藕niku, kt贸ry alokujesz za pomoc "
"`malloc`:"

#: src/memory-management/manual.md:11
msgid ""
"```c\n"
"void foo(size_t n) {\n"
"    int* int_array = (int*)malloc(n * sizeof(int));\n"
"    //\n"
"    // ... lots of code\n"
"    //\n"
"    free(int_array);\n"
"}\n"
"```"
msgstr ""
"```c\n"
"void foo(size_t n) {\n"
"    int* int_array = (int*)malloc(n * sizeof(int));\n"
"    //\n"
"    // ... du偶o kodu\n"
"    //\n"
"    free(int_array);\n"
"}\n"
"```"

#: src/memory-management/manual.md:21
msgid ""
"Memory is leaked if the function returns early between `malloc` and `free`: "
"the\n"
"pointer is lost and we cannot deallocate the memory."
msgstr ""
"Pami wycieka je偶eli funkcja zwr贸ci pomidzy `malloc` i `free`:\n"
"wska藕nik jest stracony i nie mo偶emy zwolni pamici."

#: src/memory-management/scope-based.md:1
msgid "# Scope-Based Memory Management"
msgstr "# Zarzdzanie pamici w oparciu o zakres"

#: src/memory-management/scope-based.md:3
msgid "Constructors and destructors let you hook into the lifetime of an object."
msgstr "Konstruktory i destruktory pozwalaj wpi si do czasu 偶ycia obiektu."

#: src/memory-management/scope-based.md:5
msgid ""
"By wrapping a pointer in an object, you can free memory when the object is\n"
"destroyed. The compiler guarantees that this happens, even if an exception "
"is\n"
"raised."
msgstr ""
"Przez opakowania wska藕nika w obiekt, mo偶esz zwolni pami je偶eli obiekt "
"jest\n"
"zniszczony. Kompilator to gwarantuje, nawet je偶eli rzucony jest wyjtek."

#: src/memory-management/scope-based.md:9
msgid ""
"This is often called _resource acquisition is initialization_ (RAII) and "
"gives\n"
"you smart pointers."
msgstr ""
"Czsto jest to nazywane inicjowaniem przy pozyskaniu zasobu (ang. _resource "
"acquisition is initialization_ (RAII)) i pozwala nam na inteligentne "
"wska藕niki."

#: src/memory-management/scope-based.md:12
msgid "## C++ Example"
msgstr "## Przykad C++"

#: src/memory-management/scope-based.md:14
msgid ""
"```c++\n"
"void say_hello(std::unique_ptr<Person> person) {\n"
"  std::cout << \"Hello \" << person->name << std::endl;\n"
"}\n"
"```"
msgstr ""
"```c++\n"
"void say_hello(std::unique_ptr<Person> person) {\n"
"  std::cout << \"Hello \" << person->name << std::endl;\n"
"}\n"
"```"

#: src/memory-management/scope-based.md:20
msgid ""
"* The `std::unique_ptr` object is allocated on the stack, and points to\n"
"  memory allocated on the heap.\n"
"* At the end of `say_hello`, the `std::unique_ptr` destructor will run.\n"
"* The destructor frees the `Person` object it points to."
msgstr ""
"* Obiekt `std::unique_ptr` jest alokowany na stosie i wskazuje na pami "
"zaalokowan na stercie.\n"
"* Na kocu `say_hello` jest wywoywany destruktor `std::unique_ptr`.\n"
"* Destruktor zwalnia pami obiektu `Person` na kt贸ry wskazuje."

#: src/memory-management/scope-based.md:25
msgid "Special move constructors are used when passing ownership to a function:"
msgstr ""
"Specjalne konstruktory przenoszenia s u偶ywane kiedy wasno jest "
"przekazywana do funkcji:"

#: src/memory-management/scope-based.md:27
msgid ""
"```c++\n"
"std::unique_ptr<Person> person = find_person(\"Carla\");\n"
"say_hello(std::move(person));\n"
"```"
msgstr ""
"```c++\n"
"std::unique_ptr<Person> person = find_person(\"Carla\");\n"
"say_hello(std::move(person));\n"
"```"

#: src/memory-management/garbage-collection.md:1
msgid "# Automatic Memory Management"
msgstr "## Automatyczne zarzdzanie pamici"

#: src/memory-management/garbage-collection.md:3
msgid ""
"An alternative to manual and scope-based memory management is automatic "
"memory\n"
"management:"
msgstr ""
"Alternatyw do rcznego zarzdzania pamici i zarzdzania opartego o zasig "
"jest automatyczne zarzdzanie pamici:"

#: src/memory-management/garbage-collection.md:6
msgid ""
"* The programmer never allocates or deallocates memory explicitly.\n"
"* A garbage collector finds unused memory and deallocates it for the "
"programmer."
msgstr ""
"* Programista nigdy wyra藕nie nie alokuje i nie zwalnia pamici.\n"
"* Odmiecacz pamici znajduje nieu偶ywan pami i zwalnia j dla programisty."

#: src/memory-management/garbage-collection.md:9
msgid "## Java Example"
msgstr "## Przykad Javy"

#: src/memory-management/garbage-collection.md:11
msgid "The `person` object is not deallocated after `sayHello` returns:"
msgstr "Obiekt `person` nie jest zwalniany po zwr贸ceniu z `sayHello`:"

#: src/memory-management/garbage-collection.md:13
msgid ""
"```java\n"
"void sayHello(Person person) {\n"
"  System.out.println(\"Hello \" + person.getName());\n"
"}\n"
"```"
msgstr ""
"```java\n"
"void sayHello(Person person) {\n"
"  System.out.println(\"Hello \" + person.getName());\n"
"}\n"
"```"

#: src/memory-management/rust.md:1
msgid "# Memory Management in Rust"
msgstr "# Zarzdzanie pamici w Rucie"

#: src/memory-management/rust.md:3
msgid "Memory management in Rust is a mix:"
msgstr "Zarzdzanie pamici w Rucie to mieszanka:"

#: src/memory-management/rust.md:5
msgid ""
"* Safe and correct like Java, but without a garbage collector.\n"
"* Depending on which abstraction (or combination of abstractions) you "
"choose, can be a single unique pointer, reference counted, or atomically "
"reference counted.\n"
"* Scope-based like C++, but the compiler enforces full adherence.\n"
"* A Rust user can choose the right abstraction for the situation, some even "
"have no cost at runtime like C."
msgstr ""
"* Bezpieczne i prawidowe jak w Javie, ale bez odmiecania pamici.\n"
"* W zale偶noci kt贸r abstrakcj (lub kombinacj abstrakcji) wybierzesz to "
"mo偶e by pojedynczy unikalny wska偶nik, zliczanie referencji lub atomiczne "
"zliczanie referencji.\n"
"* Oparte o zakres jak w C++, ale kompilator egzekwuje pene przestrzeganie.\n"
"* U偶ytkownika Rusta wybiera waciw abstrakcj w zale偶noci od sytuacji, "
"niekt贸re nie maj nawet kosztu w czasie uruchomienia jak w C."

#: src/memory-management/rust.md:10
msgid "It achieves this by modeling _ownership_ explicitly."
msgstr "Osiga to przez wyra藕ne modelowanie _wasnoci_."

#: src/memory-management/rust.md:14
msgid ""
"* If asked how at this point, you can mention that in Rust this is usually "
"handled by RAII wrapper types such as [Box], [Vec], [Rc], or [Arc]. These "
"encapsulate ownership and memory allocation via various means, and prevent "
"the potential errors in C."
msgstr ""
"* Je偶eli uczniowie zapytaj w tym momencie jak, to wspomnij, 偶e w Rucie to "
"przewa偶nie jest zrobione za pomoc opakowa takich jak [Box], [Vec], [Rc], "
"czy [Arc]. Typy te zapewniaj wasno i alokacj pamici r贸偶nymi metodami i "
"zapobiegaj potencjalnym problemom w C."

#: src/memory-management/rust.md:16
msgid ""
"* You may be asked about destructors here, the [Drop] trait is the Rust "
"equivalent."
msgstr ""
"* Mo偶esz dosta pytanie o destruktory, cecha [Drop] to Rustowy odpowiednik."

#: src/memory-management/rust.md:20
msgid ""
"[Box]: https://doc.rust-lang.org/std/boxed/struct.Box.html\n"
"[Vec]: https://doc.rust-lang.org/std/vec/struct.Vec.html\n"
"[Rc]: https://doc.rust-lang.org/std/rc/struct.Rc.html\n"
"[Arc]: https://doc.rust-lang.org/std/sync/struct.Arc.html\n"
"[Drop]: https://doc.rust-lang.org/std/ops/trait.Drop.html"
msgstr ""
"[Box]: https://doc.rust-lang.org/std/boxed/struct.Box.html\n"
"[Vec]: https://doc.rust-lang.org/std/vec/struct.Vec.html\n"
"[Rc]: https://doc.rust-lang.org/std/rc/struct.Rc.html\n"
"[Arc]: https://doc.rust-lang.org/std/sync/struct.Arc.html\n"
"[Drop]: https://doc.rust-lang.org/std/ops/trait.Drop.html"

#: src/memory-management/comparison.md:1
msgid "# Comparison"
msgstr "# Por贸wnanie"

#: src/memory-management/comparison.md:3
msgid "Here is a rough comparison of the memory management techniques."
msgstr "Tutaj z grubsza por贸wnujemy techniki zarzdzania pamici."

#: src/memory-management/comparison.md:5
msgid "## Pros of Different Memory Management Techniques"
msgstr "## Zalety r贸偶nych technik zarzdzania pamici"

#: src/memory-management/comparison.md:7
msgid ""
"* Manual like C:\n"
"  * No runtime overhead.\n"
"* Automatic like Java:\n"
"  * Fully automatic.\n"
"  * Safe and correct.\n"
"* Scope-based like C++:\n"
"  * Partially automatic.\n"
"  * No runtime overhead.\n"
"* Compiler-enforced scope-based like Rust:\n"
"  * Enforced by compiler.\n"
"  * No runtime overhead.\n"
"  * Safe and correct."
msgstr ""
"* Rczne jak w C:\n"
"  * Brak kosztu w czasie dziaania.\n"
"* Automatyczne jak w Javie:\n"
"  * W penie automatyczne.\n"
"  * Bezpieczne i prawidowe.\n"
"* Oparte o zakres jak w C++:\n"
"  * Czciowo automatyczne.\n"
"  * Brak kosztu w czasie dziaania.\n"
"* Egzekwowane przez kompilator oparte o zakres jak w Rucie:\n"
"  * Egzekwowane przez kompilator.\n"
"  * Brak kosztu w czasie dziaania.\n"
"  * Bezpiecznie i prawidowe."

#: src/memory-management/comparison.md:20
msgid "## Cons of Different Memory Management Techniques"
msgstr "## Wady r贸偶nych technik zarzdzania pamici"

#: src/memory-management/comparison.md:22
msgid ""
"* Manual like C:\n"
"  * Use-after-free.\n"
"  * Double-frees.\n"
"  * Memory leaks.\n"
"* Automatic like Java:\n"
"  * Garbage collection pauses.\n"
"  * Destructor delays.\n"
"* Scope-based like C++:\n"
"  * Complex, opt-in by programmer.\n"
"  * Potential for use-after-free.\n"
"* Compiler-enforced and scope-based like Rust:\n"
"  * Some upfront complexity.\n"
"  * Can reject valid programs."
msgstr ""
"* Rczne jak w C:\n"
"  * U偶ycie po zwolnieniu.\n"
"  * Podw贸jne zwolnienie.\n"
"  * Wycieki pamici.\n"
"* Automatyczne jak w Javie:\n"
"  * Pauzy na odmiecanie pamici.\n"
"  * Op贸藕nienie destruktor贸w.\n"
"* Oparte o zakres jak w C++:\n"
"  * Skomplikowane, dobrowolnie u偶ywane przez programist.\n"
"  * Potencjalne u偶ycie po zwolnieniu.\n"
"* Egzekwowane przez kompilator oparte o zakres jak w Rucie:\n"
"  * Pewna zo偶ono z g贸ry.\n"
"  * Mo偶e odrzuci prawidowe programy."

#: src/ownership.md:1
msgid "# Ownership"
msgstr "# Wasno"

#: src/ownership.md:3
msgid ""
"All variable bindings have a _scope_ where they are valid and it is an error "
"to\n"
"use a variable outside its scope:"
msgstr ""
"Wszystkie przywizania zmiennych maj _zakres_, w kt贸rym s prawidowe. "
"U偶ycie zmiennej poza jej zakresem jest bdem:"

#: src/ownership.md:6
msgid "```rust,editable,compile_fail\nstruct Point(i32, i32);"
msgstr "```rust,editable,compile_fail\nstruct Point(i32, i32);"

#: src/ownership.md:9
msgid ""
"fn main() {\n"
"    {\n"
"        let p = Point(3, 4);\n"
"        println!(\"x: {}\", p.0);\n"
"    }\n"
"    println!(\"y: {}\", p.1);\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    {\n"
"        let p = Point(3, 4);\n"
"        println!(\"x: {}\", p.0);\n"
"    }\n"
"    println!(\"y: {}\", p.1);\n"
"}\n"
"```"

#: src/ownership.md:18
msgid ""
"* At the end of the scope, the variable is _dropped_ and the data is freed.\n"
"* A destructor can run here to free up resources.\n"
"* We say that the variable _owns_ the value."
msgstr ""
"* Na kocu zakresu, zmienna jest _upuszczana_ i dane s zwalniane.\n"
"* Destruktor mo偶e by uruchomiony 偶eby zwolni zasoby.\n"
"* M贸wi si, 偶e zmienna _posiada_ warto."

#: src/ownership/move-semantics.md:1
msgid "# Move Semantics"
msgstr "# Semantyka przenoszenia"

#: src/ownership/move-semantics.md:3
msgid "An assignment will transfer ownership between variables:"
msgstr "Przypisanie przeniesie wasno pomidzy zmiennymi:"

#: src/ownership/move-semantics.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Hello!\");\n"
"    let s2: String = s1;\n"
"    println!(\"s2: {s2}\");\n"
"    // println!(\"s1: {s1}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Cze!\");\n"
"    let s2: String = s1;\n"
"    println!(\"s2: {s2}\");\n"
"    // println!(\"s1: {s1}\");\n"
"}\n"
"```"

#: src/ownership/move-semantics.md:14
msgid ""
"* The assignment of `s1` to `s2` transfers ownership.\n"
"* The data was _moved_ from `s1` and `s1` is no longer accessible.\n"
"* When `s1` goes out of scope, nothing happens: it has no ownership.\n"
"* When `s2` goes out of scope, the string data is freed.\n"
"* There is always _exactly_ one variable binding which owns a value."
msgstr ""
"* Przypisanie `s1` do `s2` przenosi wasno.\n"
"* Dane s _przeniesione_ z `s1` i zmienna `s1` nie jest ju偶 dostpna.\n"
"* Kiedy zmienna `s1` wychodzi poza zakres, nic si nie dzieje: nie ma "
"wasnoci.\n"
"* Kiedy zmienna `s2` wychodzi poza zakres, dane acucha znak贸w s "
"zwalniane.\n"
"* Zawsze jest _dokadnie_ jedno przypisanie do zmiennej, kt贸re ma dane na "
"wasno."

#: src/ownership/move-semantics.md:22
msgid ""
"* Mention that this is the opposite of the defaults in C++, which copies by "
"value unless you use `std::move` (and the move constructor is defined!)."
msgstr ""
"* Wspomnij, 偶e jest to na odwr贸t ni偶 w C++, kt贸ry domylnie kopiuje wartoci "
"chyba, 偶e jest u偶yte `std::move` (i zdefiniowany konstruktor przenoszenia!)."

#: src/ownership/move-semantics.md:24
msgid "* In Rust, clones are explicit (by using `clone`)."
msgstr "* W Rucie, klonowanie jest jawne (za pomoc `clone`)."

#: src/ownership/moved-strings-rust.md:1
msgid "# Moved Strings in Rust"
msgstr "# Przenoszenie String w Rucie"

#: src/ownership/moved-strings-rust.md:3
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Rust\");\n"
"    let s2: String = s1;\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Rust\");\n"
"    let s2: String = s1;\n"
"}\n"
"```"

#: src/ownership/moved-strings-rust.md:10
msgid ""
"* The heap data from `s1` is reused for `s2`.\n"
"* When `s1` goes out of scope, nothing happens (it has been moved from)."
msgstr ""
"* Dane sterty z `s1` s u偶yte ponownie dla `s2`.\n"
"* Kiedy `s1` wychodzi poza zakres, nic si nie dzieje (dane zostay z niej "
"przeniesione)."

#: src/ownership/moved-strings-rust.md:13
msgid "Before move to `s2`:"
msgstr "Przed przeniesieniem do `s2`:"

#: src/ownership/moved-strings-rust.md:15
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1                     :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+-----+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :     :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :     :                           :\n"
":   +-----------+-------+   :     :                           :\n"
":                           :     `- - - - - - - - - - - - - -'\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stos                              Sterta\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1                     :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+-----+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :     :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :     :                           :\n"
":   +-----------+-------+   :     :                           :\n"
":                           :     `- - - - - - - - - - - - - -'\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/ownership/moved-strings-rust.md:30
msgid "After move to `s2`:"
msgstr "Po przeniesieniu do `s2`:"

#: src/ownership/moved-strings-rust.md:32
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"(inaccessible)\"    :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :  |  :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :  |  :                           :\n"
":   +-----------+-------+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     4 |   :\n"
":   | capacity  |     4 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stos                              Sterta\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"(inaccessible)\"    :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :  |  :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :  |  :                           :\n"
":   +-----------+-------+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     4 |   :\n"
":   | capacity  |     4 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/ownership/double-free-modern-cpp.md:1
msgid "# Double Frees in Modern C++"
msgstr "# Podw贸jne zwalnianie w nowoczesnym C++"

#: src/ownership/double-free-modern-cpp.md:3
msgid "Modern C++ solves this differently:"
msgstr "Nowoczesny C++ rozwizuje to inaczej:"

#: src/ownership/double-free-modern-cpp.md:5
msgid ""
"```c++\n"
"std::string s1 = \"Cpp\";\n"
"std::string s2 = s1;  // Duplicate the data in s1.\n"
"```"
msgstr ""
"```c++\n"
"std::string s1 = \"Cpp\";\n"
"std::string s2 = s1;  // Duplikowanie danych z s1.\n"
"```"

#: src/ownership/double-free-modern-cpp.md:10
msgid ""
"* The heap data from `s1` is duplicated and `s2` gets its own independent "
"copy.\n"
"* When `s1` and `s2` go out of scope, they each free their own memory."
msgstr ""
"* Dane sterty z `s1` s zduplikowane i `s2` dostaje swoj niezale偶n kopi.\n"
"* Kiedy `s1` i `s2` wychodz poza zakres, obydwie zmienne zwalniaj swoj "
"pami."

#: src/ownership/double-free-modern-cpp.md:13
msgid "Before copy-assignment:"
msgstr "Przed przypisywaniem kopiujcym:"

#: src/ownership/double-free-modern-cpp.md:16
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stos                              Sterta\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/ownership/double-free-modern-cpp.md:30
msgid "After copy-assignment:"
msgstr "Po przypisaniu kopiujcym:"

#: src/ownership/double-free-modern-cpp.md:32
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     :                       :\n"
":    s2                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+-----+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stos                              Sterta\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     :                       :\n"
":    s2                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+-----+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/ownership/moves-function-calls.md:1
msgid "# Moves in Function Calls"
msgstr "# Przenoszenie w wywoaniach funkcji"

#: src/ownership/moves-function-calls.md:3
msgid ""
"When you pass a value to a function, the value is assigned to the function\n"
"parameter. This transfers ownership:"
msgstr ""
"Kiedy przekazujesz warto do funkcji, warto jest przypisywana do "
"parametru funkcji. To przenosi wasno:"

#: src/ownership/moves-function-calls.md:6
msgid ""
"```rust,editable\n"
"fn say_hello(name: String) {\n"
"    println!(\"Hello {name}\")\n"
"}"
msgstr ""
"```rust,editable\n"
"fn say_hello(name: String) {\n"
"    println!(\"Cze {name}\")\n"
"}"

#: src/ownership/moves-function-calls.md:11
msgid ""
"fn main() {\n"
"    let name = String::from(\"Alice\");\n"
"    say_hello(name);\n"
"    // say_hello(name);\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let name = String::from(\"Alice\");\n"
"    say_hello(name);\n"
"    // say_hello(name);\n"
"}\n"
"```"

#: src/ownership/moves-function-calls.md:20
msgid ""
"* With the first call to `say_hello`, `main` gives up ownership of `name`. "
"Afterwards, `name` cannot be used anymore within `main`.\n"
"* The heap memory allocated for `name` will be freed at the end of the "
"`say_hello` function.\n"
"* `main` can retain ownership if it passes `name` as a reference (`&name`) "
"and if `say_hello` accepts a reference as a parameter.\n"
"* Alternatively, `main` can pass a clone of `name` in the first call "
"(`name.clone()`).\n"
"* Rust makes it harder than C++ to inadvertently create copies by making "
"move semantics the default, and by forcing programmers to make clones "
"explicit."
msgstr ""
"* Przy pierwszym wywoaniu `say_hello`, `main` oddaje wasno `name`. Potem "
"`name` nie mo偶e by ju偶 u偶yte wewntrz `main`.\n"
"* Dane zaalokowane na stercie dla `name` bd zwolnione na kocu wywoania "
"funkcji `say_hello`.\n"
"* `main` mo偶e zachowa wasno je偶eli przeka偶e `name` jako referencj "
"(`&name`) i je偶eli `say_hello` akceptuje referencj jako parameter.\n"
"* Alternatywnie, `main` mo偶e przekaza klona `name` w pierwszym wywoaniu "
"(`name.clone()`).\n"
"* Przez u偶ywanie semantyki przenoszenia domylnie i przez zmuszanie "
"programist贸w do jawnego tworzenia klon贸w, Rust powoduje, 偶e przypadkowe "
"tworzenie kopii jest trudniejsze ni偶 w C++."

#: src/ownership/copy-clone.md:1
msgid "# Copying and Cloning"
msgstr "# Kopiowanie i klonowanie"

#: src/ownership/copy-clone.md:3
msgid ""
"While move semantics are the default, certain types are copied by default:"
msgstr ""
"Semantyka przenoszenia jest domylna, ale niekt贸re typy s domylnie "
"kopiowane:"

#: src/ownership/copy-clone.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x = 42;\n"
"    let y = x;\n"
"    println!(\"x: {x}\");\n"
"    println!(\"y: {y}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let x = 42;\n"
"    let y = x;\n"
"    println!(\"x: {x}\");\n"
"    println!(\"y: {y}\");\n"
"}\n"
"```"

#: src/ownership/copy-clone.md:14
msgid "These types implement the `Copy` trait."
msgstr "Te typy implementuj cech `Copy`."

#: src/ownership/copy-clone.md:16
msgid "You can opt-in your own types to use copy semantics:"
msgstr ""
"Mo偶esz spowodowa 偶eby semantyka kopiowania bya u偶ywana dla twoich wasnych "
"typ贸w:"

#: src/ownership/copy-clone.md:18
msgid ""
"```rust,editable\n"
"#[derive(Copy, Clone, Debug)]\n"
"struct Point(i32, i32);"
msgstr ""
"```rust,editable\n"
"#[derive(Copy, Clone, Debug)]\n"
"struct Point(i32, i32);"

#: src/ownership/copy-clone.md:22
msgid ""
"fn main() {\n"
"    let p1 = Point(3, 4);\n"
"    let p2 = p1;\n"
"    println!(\"p1: {p1:?}\");\n"
"    println!(\"p2: {p2:?}\");\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let p1 = Point(3, 4);\n"
"    let p2 = p1;\n"
"    println!(\"p1: {p1:?}\");\n"
"    println!(\"p2: {p2:?}\");\n"
"}\n"
"```"

#: src/ownership/copy-clone.md:30
msgid ""
"* After the assignment, both `p1` and `p2` own their own data.\n"
"* We can also use `p1.clone()` to explicitly copy the data."
msgstr ""
"* Po przypisaniu, obydwie zmienne `p1` i `p2` maj swoje dane na wasno.\n"
"* Mo偶emy te偶 u偶y `p1.clone()` 偶eby jawnie skopiowa dane."

#: src/ownership/copy-clone.md:35
msgid "Copying and cloning are not the same thing:"
msgstr "Kopiowanie i klonowanie to nie to samo:"

#: src/ownership/copy-clone.md:37
msgid ""
"* Copying refers to bitwise copies of memory regions and does not work on "
"arbitrary objects.\n"
"* Copying does not allow for custom logic (unlike copy constructors in "
"C++).\n"
"* Cloning is a more general operation and also allows for custom behavior by "
"implementing the `Clone` trait.\n"
"* Copying does not work on types that implement the `Drop` trait."
msgstr ""
"* Kopiowanie odnosi si do bezporedniego kopiowania pamici i nie dziaa "
"dla wszystkich obiekt贸w.\n"
"* Kopiowanie nie pozwala na wasn logik (jak konstruktory kopiowania w "
"C++).\n"
"* Klonowanie jest og贸lniejsz operacj i pozwala na wasne zachowanie "
"poprzez implementacj cechy `Clone`.\n"
"* Kopiowanie nie dziaa na typach, kt贸re implementuj cech `Drop`."

#: src/ownership/copy-clone.md:42 src/ownership/lifetimes-function-calls.md:29
msgid "In the above example, try the following:"
msgstr "W powy偶szym przykadzie spr贸buj nastpujcego:"

#: src/ownership/copy-clone.md:44
msgid ""
"* Add a `String` field to `struct Point`. It will not compile because "
"`String` is not a `Copy` type.\n"
"* Remove `Copy` from the `derive` attribute. The compiler error is now in "
"the `println!` for  `p1`.\n"
"* Show that it works if you clone `p1` instead."
msgstr ""
"* Dodaj pole `String` do `struct Point`. Nie skompiluje si bo `String` nie "
"jest typem `Copy`.\n"
"* Usu `Copy` z atrybutu `derive`. Kompilator teraz zwr贸ci bd w `println!` "
"dla `p1`.\n"
"* Poka偶, 偶e zadziaa je偶eli zamiast tego sklonujesz `p1`."

#: src/ownership/copy-clone.md:48
msgid ""
"If students ask about `derive`, it is sufficient to say that this is a way "
"to generate code in Rust\n"
"at compile time. In this case the default implementations of `Copy` and "
"`Clone` traits are generated.\n"
"    \n"
"</details>"
msgstr ""
"Je偶eli studenci zapytaj o `derive`, to wystarczy powiedzie, 偶e to spos贸b "
"na generowanie kodu Rusta w czasie kompilacji.\n"
"W tym przypadku bd wygenerowane domylne implementacje cech `Copy` i "
"`Clone`.\n"
"    \n"
"</details>"

#: src/ownership/borrowing.md:1
msgid "# Borrowing"
msgstr "# Po偶yczanie"

#: src/ownership/borrowing.md:3
msgid ""
"Instead of transferring ownership when calling a function, you can let a\n"
"function _borrow_ the value:"
msgstr ""
"Zamiast przekazywania wasnoci w momencie wywoania funkcji, mo偶esz "
"_po偶yczy_ funkcji warto:"

#: src/ownership/borrowing.md:6 src/ownership/lifetimes-function-calls.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point(i32, i32);"
msgstr ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point(i32, i32);"

#: src/ownership/borrowing.md:10
msgid ""
"fn add(p1: &Point, p2: &Point) -> Point {\n"
"    Point(p1.0 + p2.0, p1.1 + p2.1)\n"
"}"
msgstr ""
"fn add(p1: &Point, p2: &Point) -> Point {\n"
"    Point(p1.0 + p2.0, p1.1 + p2.1)\n"
"}"

#: src/ownership/borrowing.md:14
msgid ""
"fn main() {\n"
"    let p1 = Point(3, 4);\n"
"    let p2 = Point(10, 20);\n"
"    let p3 = add(&p1, &p2);\n"
"    println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let p1 = Point(3, 4);\n"
"    let p2 = Point(10, 20);\n"
"    let p3 = add(&p1, &p2);\n"
"    println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"}\n"
"```"

#: src/ownership/borrowing.md:22
msgid ""
"* The `add` function _borrows_ two points and returns a new point.\n"
"* The caller retains ownership of the inputs."
msgstr ""
"* Funkcja `add` _po偶ycza_ dwa punkty i zwraca nowy punkt.\n"
"* Wywoujcy funkcj zachowuje wasno."

#: src/ownership/borrowing.md:27
msgid ""
"Notes on stack returns:\n"
"* Demonstrate that the return from `add` is cheap because the compiler can "
"eliminate the copy operation. Change the above code to print stack addresses "
"and run it on the [Playground]. In the \"DEBUG\" optimization level, the "
"addresses should change, while the stay the same when changing to the "
"\"RELEASE\" setting:"
msgstr ""
"Kilka notatek na temat zwracania przez stos:\n"
"* Poka偶, 偶e zwracanie z `add` jest tanie bo kompilator eliminuje kopiowanie. "
"Zmie powy偶szy kod 偶eby pokaza adresy na stosie i uruchom w [Playground]. W "
"optymalizacji \"DEBUG\" adresy powinny si zmieni, ale przy u偶yciu "
"ustawienia \"RELEASE\" powinny pozosta te same:"

#: src/ownership/borrowing.md:30
msgid ""
"  ```rust,editable\n"
"  #[derive(Debug)]\n"
"  struct Point(i32, i32);"
msgstr ""
"  ```rust,editable\n"
"  #[derive(Debug)]\n"
"  struct Point(i32, i32);"

#: src/ownership/borrowing.md:34
msgid ""
"  fn add(p1: &Point, p2: &Point) -> Point {\n"
"      let p = Point(p1.0 + p2.0, p1.1 + p2.1);\n"
"      println!(\"&p.0: {:p}\", &p.0);\n"
"      p\n"
"  }"
msgstr ""
"  fn add(p1: &Point, p2: &Point) -> Point {\n"
"      let p = Point(p1.0 + p2.0, p1.1 + p2.1);\n"
"      println!(\"&p.0: {:p}\", &p.0);\n"
"      p\n"
"  }"

#: src/ownership/borrowing.md:40
msgid ""
"  fn main() {\n"
"      let p1 = Point(3, 4);\n"
"      let p2 = Point(10, 20);\n"
"      let p3 = add(&p1, &p2);\n"
"      println!(\"&p3.0: {:p}\", &p3.0);\n"
"      println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"  }\n"
"  ```\n"
"* The Rust compiler can do return value optimization (RVO).\n"
"* In C++, copy elision has to be defined in the language specification "
"because constructors can have side effects. In Rust, this is not an issue at "
"all. If RVO did not happen, Rust will always performs a simple and efficient "
"`memcpy` copy."
msgstr ""
"  fn main() {\n"
"      let p1 = Point(3, 4);\n"
"      let p2 = Point(10, 20);\n"
"      let p3 = add(&p1, &p2);\n"
"      println!(\"&p3.0: {:p}\", &p3.0);\n"
"      println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"  }\n"
"  ```\n"
"* Kompilator Rusta mo偶e zoptymalizowa zwracanie przez warto (ang. _return "
"value optimization_ (RVO)).\n"
"* W C++, usuwanie kopii musi by zdefiniowane w specyfikacji jzyka bo "
"konstruktory mog mie skutki uboczne. W Rucie nie stanowi to problemu. "
"Je偶eli RVO nie byo zastosowane, to Rust u偶yje prostej i wydajnej kopii "
"`memcpy`."

#: src/ownership/borrowing.md:53
msgid "[Playground]: https://play.rust-lang.org/"
msgstr "[Playground]: https://play.rust-lang.org/"

#: src/ownership/shared-unique-borrows.md:1
msgid "# Shared and Unique Borrows"
msgstr "# Wsp贸lne i unikalne po偶yczenia"

#: src/ownership/shared-unique-borrows.md:3
msgid "Rust puts constraints on the ways you can borrow values:"
msgstr "Rust narzuca ograniczenia na spos贸b w jaki mo偶na po偶ycza wartoci:"

#: src/ownership/shared-unique-borrows.md:5
msgid ""
"* You can have one or more `&T` values at any given time, _or_\n"
"* You can have exactly one `&mut T` value."
msgstr ""
"* Mo偶esz mie jedno lub wicej po偶ycze wartoci `&T` w tym samym czasie, "
"_albo_\n"
"* Mo偶esz mie dokadnie jedno po偶yczenie wartoci `&mut T`."

#: src/ownership/shared-unique-borrows.md:8
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let mut a: i32 = 10;\n"
"    let b: &i32 = &a;"
msgstr ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let mut a: i32 = 10;\n"
"    let b: &i32 = &a;"

#: src/ownership/shared-unique-borrows.md:13
msgid ""
"    {\n"
"        let c: &mut i32 = &mut a;\n"
"        *c = 20;\n"
"    }"
msgstr ""
"    {\n"
"        let c: &mut i32 = &mut a;\n"
"        *c = 20;\n"
"    }"

#: src/ownership/shared-unique-borrows.md:18 src/std/rc.md:13
msgid ""
"    println!(\"a: {a}\");\n"
"    println!(\"b: {b}\");\n"
"}\n"
"```"
msgstr ""
"    println!(\"a: {a}\");\n"
"    println!(\"b: {b}\");\n"
"}\n"
"```"

#: src/ownership/shared-unique-borrows.md:25
msgid ""
"* The above code does not compile because `a` is borrowed as mutable "
"(through `c`) and as immutable (through `b`) at the same time.\n"
"* Move the `println!` statement for `b` before the scope that introduces `c` "
"to make the code compile.\n"
"* After that change, the compiler realizes that `b` is only ever used before "
"the new mutable borrow of `a` through `c`. This is a feature of the borrow "
"checker called \"non-lexical lifetimes\"."
msgstr ""
"* Powy偶szy kod si nie kompiluje poniewa偶 `a` jest po偶yczone jako mutowalne "
"(przez `c`) i jako niemutowalne (przez `b`) w tym samym czasie.\n"
"* Przenie instrukcj `println!` dla `b` przed zakres, kt贸ry wprowadza `c`, "
"偶eby kod si kompilowa.\n"
"* Po zmianie, kompilator uwiadomi sobie, 偶e `b` jest tylko u偶ywane przed "
"mutowalnym po偶yczeniem `a` przez `c`. Ta funkcja nadzorcy po偶yczania nazywa "
"si \"nieleksykalne czasy 偶ycia\" (ang. _non-lexical lifetimes_)."

#: src/ownership/lifetimes.md:1
msgid "# Lifetimes"
msgstr "# Czasy 偶ycia"

#: src/ownership/lifetimes.md:3
msgid "A borrowed value has a _lifetime_:"
msgstr "Po偶yczona warto ma _czas 偶ycia_:"

#: src/ownership/lifetimes.md:5
msgid ""
"* The lifetime can be elided: `add(p1: &Point, p2: &Point) -> Point`.\n"
"* Lifetimes can also be explicit: `&'a Point`, `&'document str`.\n"
"* Read `&'a Point` as \"a borrowed `Point` which is valid for at least the\n"
"  lifetime `a`\".\n"
"* Lifetimes are always inferred by the compiler: you cannot assign a "
"lifetime\n"
"  yourself.\n"
"  * Lifetime annotations create constraints; the compiler verifies that "
"there is\n"
"    a valid solution."
msgstr ""
"* Czas 偶ycia mo偶e by pominity: `add(p1: &Point, p2: &Point) -> Point`.\n"
"* Czasy 偶ycia mog te偶 by jawne: `&'a Point`, `&'document str`.\n"
"* Czytaj `&'a Point` jako \"po偶yczony `Point` kt贸ry jest wa偶ny co najmniej w "
"czasie 偶ycia `a`\".\n"
"* Czasy 偶ycia zawsze s wyliczane przez kompilator: nie mo偶na samemu "
"przypisa czasu 偶ycia.\n"
"* Adnotacje czasu 偶ycia tworz ograniczenia; kompilator weryfikuje, 偶e "
"istnieje prawidowe rozwizanie."

#: src/ownership/lifetimes-function-calls.md:1
msgid "# Lifetimes in Function Calls"
msgstr "# Czasy 偶ycia w wywoaniach funkcji"

#: src/ownership/lifetimes-function-calls.md:3
msgid ""
"In addition to borrowing its arguments, a function can return a borrowed "
"value:"
msgstr ""
"W dodatku do po偶yczania swoich argument贸w, funkcja mo偶e zwr贸ci po偶yczon "
"warto:"

#: src/ownership/lifetimes-function-calls.md:9
msgid ""
"fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
"    if p1.0 < p2.0 { p1 } else { p2 }\n"
"}"
msgstr ""
"fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
"    if p1.0 < p2.0 { p1 } else { p2 }\n"
"}"

#: src/ownership/lifetimes-function-calls.md:13
msgid ""
"fn main() {\n"
"    let p1: Point = Point(10, 10);\n"
"    let p2: Point = Point(20, 20);\n"
"    let p3: &Point = left_most(&p1, &p2);\n"
"    println!(\"left-most point: {:?}\", p3);\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let p1: Point = Point(10, 10);\n"
"    let p2: Point = Point(20, 20);\n"
"    let p3: &Point = left_most(&p1, &p2);\n"
"    println!(\"left-most point: {:?}\", p3);\n"
"}\n"
"```"

#: src/ownership/lifetimes-function-calls.md:21
msgid ""
"* `'a` is a generic parameter, it is inferred by the compiler.\n"
"* Lifetimes start with `'` and `'a` is a typical default name.\n"
"* Read `&'a Point` as \"a borrowed `Point` which is valid for at least the\n"
"  lifetime `a`\".\n"
"  * The _at least_ part is important when parameters are in different scopes."
msgstr ""
"* `'a` to parameter generyczny, jest wyliczany przez kompilator.\n"
"* Czas 偶ycia zaczyna si `'` i `'a` to typowa domylna nazwa.\n"
"* Czytaj `&'a Point` jako \"po偶yczony `Point` kt贸ry jest wa偶ny co najmniej w "
"czasie 偶ycia `a`\".\n"
"* To _co najmniej_ jest wa偶ne je偶eli parametry s w r贸偶nych zakresach."

#: src/ownership/lifetimes-function-calls.md:31
msgid ""
"* Move the declaration of `p2` and `p3` into a a new scope (`{ ... }`), "
"resulting in the following code:\n"
"  ```rust,ignore\n"
"  #[derive(Debug)]\n"
"  struct Point(i32, i32);"
msgstr ""
"* Przenie deklaracj `p2` i `p3` do nowego zakresu (`{ ... }`), powiniene "
"otrzyma poni偶szy kod:\n"
"  ```rust,ignore\n"
"  #[derive(Debug)]\n"
"  struct Point(i32, i32);"

#: src/ownership/lifetimes-function-calls.md:36
msgid ""
"  fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
"      if p1.0 < p2.0 { p1 } else { p2 }\n"
"  }"
msgstr ""
"  fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
"      if p1.0 < p2.0 { p1 } else { p2 }\n"
"  }"

#: src/ownership/lifetimes-function-calls.md:40
msgid ""
"  fn main() {\n"
"      let p1: Point = Point(10, 10);\n"
"      let p3: &Point;\n"
"      {\n"
"          let p2: Point = Point(20, 20);\n"
"          p3 = left_most(&p1, &p2);\n"
"      }\n"
"      println!(\"left-most point: {:?}\", p3);\n"
"  }\n"
"  ```\n"
"  Note how this does not compile since `p3` outlives `p2`."
msgstr ""
"  fn main() {\n"
"      let p1: Point = Point(10, 10);\n"
"      let p3: &Point;\n"
"      {\n"
"          let p2: Point = Point(20, 20);\n"
"          p3 = left_most(&p1, &p2);\n"
"      }\n"
"      println!(\"left-most point: {:?}\", p3);\n"
"  }\n"
"  ```\n"
"  Zauwa偶, 偶e teraz kod si nie kompiluje bo `p3` prze偶ywa `p2`."

#: src/ownership/lifetimes-function-calls.md:52
msgid ""
"* Reset the workspace and change the function signature to `fn left_most<'a, "
"'b>(p1: &'a Point, p2: &'a Point) -> &'b Point`. This will not compile "
"because the relationship between the lifetimes `'a` and `'b` is unclear.\n"
"* Another way to explain it:\n"
"  * Two references to two values are borrowed by a function and the function "
"returns\n"
"    another reference.\n"
"  * It must have come from one of those two inputs (or from a global "
"variable).\n"
"  * Which one is it? The compiler needs to to know, so at the call site the "
"returned reference is not used\n"
"    for longer than a variable from where the reference came from."
msgstr ""
"* Zresetuj edytor i zmie sygnatur funkcji na `fn left_most<'a, 'b>(p1: &'a "
"Point, p2: &'a Point) -> &'b Point`. To si nie skompiluje bo zale偶no "
"pomidzy czasami 偶ycia `'a` i `'b` jest niejasna.\n"
"* Inny spos贸b 偶eby to wytumaczy:\n"
"  * Dwie referencje do dw贸ch wartoci s po偶yczone przez funkcj i funkcja "
"musi zwr贸ci inn referencj.\n"
"  * Ta referencja musi pochodzi z jednego z dw贸ch wej(lub ze zmiennej "
"globalnej).\n"
"  * Kt贸ra to? Kompilator musi wiedzie, 偶eby w czasie wywoania zwracana "
"referencja nie jest u偶ywana du偶ej ni偶 zmienna z kt贸rej pochodzi ta "
"referencja."

#: src/ownership/lifetimes-data-structures.md:1
msgid "# Lifetimes in Data Structures"
msgstr "# Czasy 偶ycia w strukturach danych"

#: src/ownership/lifetimes-data-structures.md:3
msgid ""
"If a data type stores borrowed data, it must be annotated with a lifetime:"
msgstr ""
"Je偶eli typ danych przechowuje po偶yczone dane, to musz one mie adnotcj "
"czasu 偶ycia:"

#: src/ownership/lifetimes-data-structures.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Highlight<'doc>(&'doc str);"
msgstr ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Highlight<'doc>(&'doc str);"

#: src/ownership/lifetimes-data-structures.md:9
msgid ""
"fn erase(text: String) {\n"
"    println!(\"Bye {text}!\");\n"
"}"
msgstr ""
"fn erase(text: String) {\n"
"    println!(\"Bye {text}!\");\n"
"}"

#: src/ownership/lifetimes-data-structures.md:13
msgid ""
"fn main() {\n"
"    let text = String::from(\"The quick brown fox jumps over the lazy "
"dog.\");\n"
"    let fox = Highlight(&text[4..19]);\n"
"    let dog = Highlight(&text[35..43]);\n"
"    // erase(text);\n"
"    println!(\"{fox:?}\");\n"
"    println!(\"{dog:?}\");\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let text = String::from(\"The quick brown fox jumps over the lazy "
"dog.\");\n"
"    let fox = Highlight(&text[4..19]);\n"
"    let dog = Highlight(&text[35..43]);\n"
"    // erase(text);\n"
"    println!(\"{fox:?}\");\n"
"    println!(\"{dog:?}\");\n"
"}\n"
"```"

#: src/ownership/lifetimes-data-structures.md:25
msgid ""
"* In the above example, the annotation on `Highlight` enforces that the data "
"underlying the contained `&str` lives at least as long as any instance of "
"`Highlight` that uses that data.\n"
"* If `text` is consumed before the end of the lifetime of `fox` (or `dog`), "
"the borrow checker throws an error.\n"
"* Types with borrowed data force users to hold on to the original data. This "
"can be useful for creating lightweight views, but it generally makes them "
"somewhat harder to use.\n"
"* When possible, make data structures own their data directly.\n"
"* Some structs with multiple references inside can have more than one "
"lifetime annotation. This can be necessary if there is a need to describe "
"lifetime relationships between the references themselves, in addition to the "
"lifetime of the struct itself. Those are very advanced use cases.\n"
"</details>"
msgstr ""
"* W powy偶szym przykadzie, adnotacja na `Highlight` wymaga 偶eby dane w "
"zawartym `&str` 偶yy co najmniej tak dugo jak instancja `Highlight`, kt贸ra "
"u偶ywa tych danych.\n"
"* Je偶eli `text` jest skonsumowany przed kocem 偶ycia `fox` (lub `dog`), to "
"nadzorca po偶yczania poka偶e bd.\n"
"* Typy z po偶yczonymi danymi wymagaj od u偶ytkownik贸w utrzymywania "
"oryginalnych danych. Jest to przydatne przy tworzeniu lekkich widok贸w, ale "
"generalnie powoduje, 偶e s trudniejsze w u偶yciu.\n"
"* Je偶eli mo偶liwe tw贸rz struktury danych, kt贸re bezporednio s wacicielami "
"swoich danych.\n"
"* Niekt贸re struktury z wieloma referencjami mog mie wicej ni偶 jedn "
"adnotacj cyklu 偶ycia. To mo偶e by potrzebne je偶eli potrzebujesz opisa "
"relacj cyklu 偶ycia pomidzy referencjami w dodatku do cyklu 偶ycia samej "
"struktury. S to bardzo zaawansowane przypadki u偶ycia.\n"
"</details>"

#: src/exercises/day-1/afternoon.md:1
#, fuzzy
msgid "# Day 1: Afternoon Exercises"
msgstr "# Dzie 1: wiczenia popoudniowe"

#: src/exercises/day-1/afternoon.md:3
#, fuzzy
msgid "We will look at two things:"
msgstr "Przyjrzymy si dw贸m rzeczom:"

#: src/exercises/day-1/afternoon.md:5
#, fuzzy
msgid "* A small book library,"
msgstr "* Maa biblioteczka,"

#: src/exercises/day-1/afternoon.md:7
#, fuzzy
msgid "* Iterators and ownership (hard)."
msgstr "* Iteratory i wasno (trudne)."

#: src/exercises/day-1/afternoon.md:13 src/exercises/day-2/afternoon.md:9
#, fuzzy
msgid "[solutions]: solutions-afternoon.md"
msgstr "[rozwizania]: rozwizania-po poudniu.md"

#: src/exercises/day-1/book-library.md:1
#, fuzzy
msgid "# Designing a Library"
msgstr "# Projektowanie biblioteki"

#: src/exercises/day-1/book-library.md:3
#, fuzzy
msgid ""
"We will learn much more about structs and the `Vec<T>` type tomorrow. For "
"now,\n"
"you just need to know part of its API:"
msgstr ""
"Jutro dowiemy si znacznie wicej o strukturach i typie `Vec<T>`. Na razie,\n"
"wystarczy zna cz jego API:"

#: src/exercises/day-1/book-library.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut vec = vec![10, 20];\n"
"    vec.push(30);\n"
"    println!(\"middle value: {}\", vec[vec.len() / 2]);\n"
"    for item in vec.iter() {\n"
"        println!(\"item: {item}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let mut vec = vec![10, 20];\n"
"    vec.push(30);\n"
"    println!(\"middle value: {}\", vec[vec.len() / 2]);\n"
"    for item in vec.iter() {\n"
"        println!(\"item: {item}\");\n"
"    }\n"
"}\n"
"```"

#: src/exercises/day-1/book-library.md:17
#, fuzzy
msgid ""
"Use this to create a library application. Copy the code below to\n"
"<https://play.rust-lang.org/> and update the types to make it compile:"
msgstr ""
"U偶yj tego, aby utworzy aplikacj biblioteczn. Skopiuj poni偶szy kod do\n"
"<https://play.rust-lang.org/> i zaktualizuj typy, aby skompilowa:"

#: src/exercises/day-1/book-library.md:24
msgid ""
"struct Library {\n"
"    books: Vec<Book>,\n"
"}"
msgstr ""
"struct Library {\n"
"    books: Vec<Book>,\n"
"}"

#: src/exercises/day-1/book-library.md:28 src/exercises/day-1/solutions-afternoon.md:27
msgid ""
"struct Book {\n"
"    title: String,\n"
"    year: u16,\n"
"}"
msgstr ""
"struct Book {\n"
"    title: String,\n"
"    year: u16,\n"
"}"

#: src/exercises/day-1/book-library.md:33 src/exercises/day-1/solutions-afternoon.md:32
msgid ""
"impl Book {\n"
"    // This is a constructor, used below.\n"
"    fn new(title: &str, year: u16) -> Book {\n"
"        Book {\n"
"            title: String::from(title),\n"
"            year,\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"impl Book {\n"
"    // To jest konstruktor u偶ywany poni偶ej.\n"
"    fn new(title: &str, year: u16) -> Book {\n"
"        Book {\n"
"            title: String::from(title),\n"
"            year,\n"
"        }\n"
"    }\n"
"}"

#: src/exercises/day-1/book-library.md:43
msgid ""
"// This makes it possible to print Book values with {}.\n"
"impl std::fmt::Display for Book {\n"
"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n"
"        write!(f, \"{} ({})\", self.title, self.year)\n"
"    }\n"
"}"
msgstr ""
"// Umo偶liwia to drukowanie wartoci Book za pomoc {}.\n"
"impl std::fmt::Display for Book {\n"
"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n"
"        write!(f, \"{} ({})\", self.title, self.year)\n"
"    }\n"
"}"

#: src/exercises/day-1/book-library.md:50
msgid ""
"impl Library {\n"
"    fn new() -> Library {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"impl Library {\n"
"    fn new() -> Library {\n"
"        unimplemented!()\n"
"    }"

#: src/exercises/day-1/book-library.md:55
msgid ""
"    //fn len(self) -> usize {\n"
"    //    unimplemented!()\n"
"    //}"
msgstr ""
"    //fn len(self) -> usize {\n"
"    //    unimplemented!()\n"
"    //}"

#: src/exercises/day-1/book-library.md:59
msgid ""
"    //fn is_empty(self) -> bool {\n"
"    //    unimplemented!()\n"
"    //}"
msgstr ""
"    //fn is_empty(self) -> bool {\n"
"    //    unimplemented!()\n"
"    //}"

#: src/exercises/day-1/book-library.md:63
msgid ""
"    //fn add_book(self, book: Book) {\n"
"    //    unimplemented!()\n"
"    //}"
msgstr ""
"    //fn add_book(self, book: Book) {\n"
"    //    unimplemented!()\n"
"    //}"

#: src/exercises/day-1/book-library.md:67
msgid ""
"    //fn print_books(self) {\n"
"    //    unimplemented!()\n"
"    //}"
msgstr ""
"    //fn print_books(self) {\n"
"    //    unimplemented!()\n"
"    //}"

#: src/exercises/day-1/book-library.md:71
msgid ""
"    //fn oldest_book(self) -> Option<&Book> {\n"
"    //    unimplemented!()\n"
"    //}\n"
"}"
msgstr ""
"    //fn oldest_book(self) -> Option<&Book> {\n"
"    //    unimplemented!()\n"
"    //}\n"
"}"

#: src/exercises/day-1/book-library.md:76
msgid ""
"// This shows the desired behavior. Uncomment the code below and\n"
"// implement the missing methods. You will need to update the\n"
"// method signatures, including the \"self\" parameter! You may\n"
"// also need to update the variable bindings within main.\n"
"fn main() {\n"
"    let library = Library::new();"
msgstr ""

#: src/exercises/day-1/book-library.md:83
msgid ""
"    //println!(\"Our library is empty: {}\", library.is_empty());\n"
"    //\n"
"    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    //\n"
"    //library.print_books();\n"
"    //\n"
"    //match library.oldest_book() {\n"
"    //    Some(book) => println!(\"My oldest book is {book}\"),\n"
"    //    None => println!(\"My library is empty!\"),\n"
"    //}\n"
"    //\n"
"    //println!(\"Our library has {} books\", library.len());\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/book-library.md:99
msgid ""
"<details>\n"
"    \n"
"[Solution](solutions-afternoon.md#designing-a-library)"
msgstr ""
"<details>\n"
"    \n"
"[Rozwizanie](solutions-afternoon.md#designing-a-library)"

#: src/exercises/day-1/iterators-and-ownership.md:1
#, fuzzy
msgid "# Iterators and Ownership"
msgstr "# Iteratory i wasno"

#: src/exercises/day-1/iterators-and-ownership.md:3
#, fuzzy
msgid ""
"The ownership model of Rust affects many APIs. An example of this is the\n"
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) and\n"
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html)\n"
"traits."
msgstr ""
"Model wasnoci Rust wpywa na wiele interfejs贸w API. Przykadem tego jest "
"tzw\n"
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) i\n"
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html)\n"
"cechy."

#: src/exercises/day-1/iterators-and-ownership.md:8
msgid "## `Iterator`"
msgstr "## `Iterator`"

#: src/exercises/day-1/iterators-and-ownership.md:10
#, fuzzy
msgid ""
"Traits are like interfaces: they describe behavior (methods) for a type. "
"The\n"
"`Iterator` trait simply says that you can call `next` until you get `None` "
"back:"
msgstr ""
"Cechy s jak interfejsy: opisuj zachowanie (metody) dla typu. The\n"
"Cecha `Iterator` m贸wi po prostu, 偶e mo偶esz wywoywa `next`, dop贸ki nie "
"otrzymasz z powrotem `None`:"

#: src/exercises/day-1/iterators-and-ownership.md:13
msgid ""
"```rust\n"
"pub trait Iterator {\n"
"    type Item;\n"
"    fn next(&mut self) -> Option<Self::Item>;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"pub trait Iterator {\n"
"    type Item;\n"
"    fn next(&mut self) -> Option<Self::Item>;\n"
"}\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:20
#, fuzzy
msgid "You use this trait like this:"
msgstr "U偶ywasz tej cechy w ten spos贸b:"

#: src/exercises/day-1/iterators-and-ownership.md:22
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();"

#: src/exercises/day-1/iterators-and-ownership.md:27
msgid ""
"    println!(\"v[0]: {:?}\", iter.next());\n"
"    println!(\"v[1]: {:?}\", iter.next());\n"
"    println!(\"v[2]: {:?}\", iter.next());\n"
"    println!(\"No more items: {:?}\", iter.next());\n"
"}\n"
"```"
msgstr ""
"    println!(\"v[0]: {:?}\", iter.next());\n"
"    println!(\"v[1]: {:?}\", iter.next());\n"
"    println!(\"v[2]: {:?}\", iter.next());\n"
"    println!(\"Nie ma wicej element贸w: {:?}\", iter.next());\n"
"}\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:34
#, fuzzy
msgid "What is the type returned by the iterator? Test your answer here:"
msgstr "Jaki typ zwraca iterator? Sprawd藕 swoj odpowied藕 tutaj:"

#: src/exercises/day-1/iterators-and-ownership.md:36
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();"
msgstr ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();"

#: src/exercises/day-1/iterators-and-ownership.md:41
#: src/exercises/day-1/iterators-and-ownership.md:78
msgid ""
"    let v0: Option<..> = iter.next();\n"
"    println!(\"v0: {v0:?}\");\n"
"}\n"
"```"
msgstr ""
"    let v0: Option<..> = iter.next();\n"
"    println!(\"v0: {v0:?}\");\n"
"}\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:46
#, fuzzy
msgid "Why is this type used?"
msgstr "Dlaczego ten typ jest u偶ywany?"

#: src/exercises/day-1/iterators-and-ownership.md:48
msgid "## `IntoIterator`"
msgstr "## `IntoIterator`"

#: src/exercises/day-1/iterators-and-ownership.md:50
#, fuzzy
msgid ""
"The `Iterator` trait tells you how to _iterate_ once you have created an\n"
"iterator. The related trait `IntoIterator` tells you how to create the "
"iterator:"
msgstr ""
"Cecha `Iterator` m贸wi ci, jak _iterowa_ po utworzeniu\n"
"iterator. Powizana cecha `IntoIterator` m贸wi ci, jak stworzy iterator:"

#: src/exercises/day-1/iterators-and-ownership.md:53
msgid ""
"```rust\n"
"pub trait IntoIterator {\n"
"    type Item;\n"
"    type IntoIter: Iterator<Item = Self::Item>;"
msgstr ""
"```rust\n"
"pub trait IntoIterator {\n"
"    type Item;\n"
"    type IntoIter: Iterator<Item = Self::Item>;"

#: src/exercises/day-1/iterators-and-ownership.md:58
msgid ""
"    fn into_iter(self) -> Self::IntoIter;\n"
"}\n"
"```"
msgstr ""
"    fn into_iter(self) -> Self::IntoIter;\n"
"}\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:62
#, fuzzy
msgid ""
"The syntax here means that every implementation of `IntoIterator` must\n"
"declare two types:"
msgstr ""
"Skadnia tutaj oznacza, 偶e ka偶da implementacja `IntoIterator` musi\n"
"zadeklarowa dwa typy:"

#: src/exercises/day-1/iterators-and-ownership.md:65
#, fuzzy
msgid ""
"* `Item`: the type we iterate over, such as `i8`,\n"
"* `IntoIter`: the `Iterator` type returned by the `into_iter` method."
msgstr ""
"* `Item`: typ, kt贸ry iterujemy, na przykad `i8`,\n"
"* `IntoIter`: typ `Iterator` zwracany przez metod `into_iter`."

#: src/exercises/day-1/iterators-and-ownership.md:68
#, fuzzy
msgid ""
"Note that `IntoIter` and `Item` are linked: the iterator must have the same\n"
"`Item` type, which means that it returns `Option<Item>`"
msgstr ""
"Zauwa偶, 偶e `IntoIter` i `Item` s poczone: iterator musi mie to samo\n"
"Typ `Item`, co oznacza, 偶e zwraca `Option<Item>`"

#: src/exercises/day-1/iterators-and-ownership.md:71
#, fuzzy
msgid "Like before, what  is the type returned by the iterator?"
msgstr "Tak jak poprzednio, jaki typ jest zwracany przez iterator?"

#: src/exercises/day-1/iterators-and-ownership.md:73
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), "
"String::from(\"bar\")];\n"
"    let mut iter = v.into_iter();"
msgstr ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), "
"String::from(\"bar\")];\n"
"    let mut iter = v.into_iter();"

#: src/exercises/day-1/iterators-and-ownership.md:83
msgid "## `for` Loops"
msgstr "## Ptle `for`"

#: src/exercises/day-1/iterators-and-ownership.md:85
#, fuzzy
msgid ""
"Now that we know both `Iterator` and `IntoIterator`, we can build `for` "
"loops.\n"
"They call `into_iter()` on an expression and iterates over the resulting\n"
"iterator:"
msgstr ""
"Teraz, gdy znamy zar贸wno `Iterator`, jak i `IntoIterator`, mo偶emy budowa "
"ptle `for`.\n"
"Wywouj `into_iter()` na wyra偶eniu i iteruj wynik\n"
"iterator:"

#: src/exercises/day-1/iterators-and-ownership.md:89
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::from(\"bar\")];"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::from(\"bar\")];"

#: src/exercises/day-1/iterators-and-ownership.md:93
msgid ""
"    for word in &v {\n"
"        println!(\"word: {word}\");\n"
"    }"
msgstr ""
"    for word in &v {\n"
"        println!(\"word: {word}\");\n"
"    }"

#: src/exercises/day-1/iterators-and-ownership.md:97
msgid ""
"    for word in v {\n"
"        println!(\"word: {word}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    for word in v {\n"
"        println!(\"word: {word}\");\n"
"    }\n"
"}\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:103
#, fuzzy
msgid "What is the type of `word` in each loop?"
msgstr "Jaki jest typ sowa w ka偶dej ptli?"

#: src/exercises/day-1/iterators-and-ownership.md:105
#, fuzzy
msgid ""
"Experiment with the code above and then consult the documentation for "
"[`impl\n"
"IntoIterator for\n"
"&Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-%26%27a%20Vec%3CT%2C%20A%3E)\n"
"and [`impl IntoIterator for\n"
"Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-Vec%3CT%2C%20A%3E)\n"
"to check your answers."
msgstr ""
"Eksperymentuj z powy偶szym kodem, a nastpnie zapoznaj si z dokumentacj dla "
"[`impl\n"
"IntoIterator dla\n"
"&Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-%26%27a%20Vec%3CT%2C%20A%3E)\n"
"i [`impl IntoIterator dla\n"
"Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-Vec%3CT%2C%20A%3E)\n"
"aby sprawdzi swoje odpowiedzi."

#: src/welcome-day-2.md:1
msgid "# Welcome to Day 2"
msgstr "# Witamy w dniu 2"

#: src/welcome-day-2.md:3
#, fuzzy
msgid "Now that we have seen a fair amount of Rust, we will continue with:"
msgstr "Teraz, gdy widzielimy ju偶 sporo Rust, bdziemy kontynuowa:"

#: src/welcome-day-2.md:5
#, fuzzy
msgid "* Structs, enums, methods."
msgstr "* Struktury, wyliczenia, metody."

#: src/welcome-day-2.md:7
#, fuzzy
msgid "* Pattern matching: destructuring enums, structs, and arrays."
msgstr "* Dopasowywanie wzorc贸w: destrukturyzacja wylicze, struktur i tablic."

#: src/welcome-day-2.md:9
#, fuzzy
msgid ""
"* Control flow constructs: `if`, `if let`, `while`, `while let`, `break`, "
"and\n"
"  `continue`."
msgstr ""
"* Konstrukcje przepywu sterowania: `if`, `if let`, `while`, `while let`, "
"`break` i\n"
"  `kontynuuj`."

#: src/welcome-day-2.md:12
#, fuzzy
msgid ""
"* The Standard Library: `String`, `Option` and `Result`, `Vec`, `HashMap`, "
"`Rc`\n"
"  and `Arc`."
msgstr ""
"* Biblioteka standardowa: `String`, `Option` i `Result`, `Vec`, `HashMap`, "
"`Rc`\n"
"  i `uk`."

#: src/welcome-day-2.md:15
#, fuzzy
msgid "* Modules: visibility, paths, and filesystem hierarchy."
msgstr "* Moduy: widoczno, cie偶ki i hierarchia system贸w plik贸w."

#: src/structs.md:1
#, fuzzy
msgid "# Structs"
msgstr "# Struktury"

#: src/structs.md:3
#, fuzzy
msgid "Like C and C++, Rust has support for custom structs:"
msgstr "Podobnie jak C i C++, Rust obsuguje niestandardowe struktury:"

#: src/structs.md:5
msgid ""
"```rust,editable\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}"
msgstr ""
"```rust,editable\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}"

#: src/structs.md:11
msgid ""
"fn main() {\n"
"    let mut peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        age: 27,\n"
"    };\n"
"    println!(\"{} is {} years old\", peter.name, peter.age);\n"
"    \n"
"    peter.age = 28;\n"
"    println!(\"{} is {} years old\", peter.name, peter.age);\n"
"    \n"
"    let jackie = Person {\n"
"        name: String::from(\"Jackie\"),\n"
"        ..peter\n"
"    };\n"
"    println!(\"{} is {} years old\", jackie.name, jackie.age);\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let mut peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        age: 27,\n"
"    };\n"
"    println!(\"{} ma {} lat\", peter.name, peter.age);\n"
"    \n"
"    peter.age = 28;\n"
"    println!(\"{} ma {} lat\", peter.name, peter.age);\n"
"    \n"
"    let jackie = Person {\n"
"        name: String::from(\"Jackie\"),\n"
"        ..peter\n"
"    };\n"
"    println!(\"{} ma {} lat\", jackie.name, jackie.age);\n"
"}\n"
"```"

#: src/structs.md:29
#, fuzzy
msgid "<details>\nKey Points: "
msgstr "<details>\nKluczowe punkty:"

#: src/structs.md:32
msgid ""
"* Structs work like in C or C++.\n"
"  * Like in C++, and unlike in C, no typedef is needed to define a type.\n"
"  * Unlike in C++, there is no inheritance between structs.\n"
"* Methods are defined in an `impl` block, which we will see in following "
"slides.\n"
"* This may be a good time to let people know there are different types of "
"structs. \n"
"  * Zero-sized structs `e.g., struct Foo;` might be used when implementing a "
"trait on some type but dont have any data that you want to store in the "
"value itself. \n"
"  * The next slide will introduce Tuple structs, used when the field names "
"are not important.\n"
"* The syntax `..peter` allows us to copy the majority of the fields from the "
"old struct without having to explicitly type it all out. It must always be "
"the last element."
msgstr ""

#: src/structs/tuple-structs.md:1
#, fuzzy
msgid "# Tuple Structs"
msgstr "# Struktury krotkowe"

#: src/structs/tuple-structs.md:3
#, fuzzy
msgid "If the field names are unimportant, you can use a tuple struct:"
msgstr "Jeli nazwy p贸l s nieistotne, mo偶esz u偶y struktury krotki:"

#: src/structs/tuple-structs.md:5
msgid "```rust,editable\nstruct Point(i32, i32);"
msgstr "```rust,editable\nstruct Point(i32, i32);"

#: src/structs/tuple-structs.md:8
msgid ""
"fn main() {\n"
"    let p = Point(17, 23);\n"
"    println!(\"({}, {})\", p.0, p.1);\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let p = Point(17, 23);\n"
"    println!(\"({}, {})\", p.0, p.1);\n"
"}\n"
"```"

#: src/structs/tuple-structs.md:14
#, fuzzy
msgid "This is often used for single-field wrappers (called newtypes):"
msgstr ""
"Jest to czsto u偶ywane w przypadku opakowa z jednym polem (zwanych "
"newtypes):"

#: src/structs/tuple-structs.md:16
msgid ""
"```rust,editable,compile_fail\n"
"struct PoundOfForce(f64);\n"
"struct Newtons(f64);"
msgstr ""
"```rust,editable,compile_fail\n"
"struct PoundOfForce(f64);\n"
"struct Newtons(f64);"

#: src/structs/tuple-structs.md:20
msgid ""
"fn compute_thruster_force() -> PoundOfForce {\n"
"    todo!(\"Ask a rocket scientist at NASA\")\n"
"}"
msgstr ""
"fn compute_thruster_force() -> PoundOfForce {\n"
"    todo!(\"Zapytaj naukowca rakietowego z NASA\")\n"
"}"

#: src/structs/tuple-structs.md:24
msgid ""
"fn set_thruster_force(force: Newtons) {\n"
"    // ...\n"
"}"
msgstr ""
"fn set_thruster_force(force: Newtons) {\n"
"    // ...\n"
"}"

#: src/structs/tuple-structs.md:28
msgid ""
"fn main() {\n"
"    let force = compute_thruster_force();\n"
"    set_thruster_force(force);\n"
"}"
msgstr ""
"fn main() {\n"
"    let force = compute_thruster_force();\n"
"    set_thruster_force(force);\n"
"}"

#: src/structs/tuple-structs.md:33 src/traits/default.md:36 src/generics/trait-objects.md:86
msgid "```"
msgstr "```"

#: src/structs/tuple-structs.md:37
#, fuzzy
msgid ""
"* Newtypes are a great way to encode additional information about the value "
"in a primitive type, for example:\n"
"  * The number is measured in some units: `Newtons` in the example above.\n"
"  * The value passed some validation when it was created, so you no longer "
"have to validate it again at every use: 'PhoneNumber(String)` or "
"`OddNumber(u32)`.\n"
"* Demonstrate how to add a `f64` value to a `Newtons` type by accessing the "
"single field in the newtype.\n"
"  *  Rust generally doesnt like inexplicit things, like automatic "
"unwrapping or for instance using booleans as integers.\n"
"  *  Operator overloading is discussed on Day 3 (generics). \n"
"</details>"
msgstr ""
"* Nowe typy to wietny spos贸b na zakodowanie dodatkowych informacji o "
"wartoci w typie pierwotnym, na przykad:\n"
"  * Liczba jest mierzona w niekt贸rych jednostkach: Newtons w powy偶szym "
"przykadzie.\n"
"  * Warto przesza walidacj podczas tworzenia, wic nie musisz ju偶 "
"weryfikowa jej ponownie przy ka偶dym u偶yciu: PhoneNumber(String) lub "
"OddNumber(u32).\n"
"* Zademonstruj, jak doda warto `f64` do typu `Newtons`, uzyskujc dostp "
"do pojedynczego pola w newtype.\n"
"  * Rust generalnie nie lubi niejasnych rzeczy, takich jak automatyczne "
"rozpakowywanie lub na przykad u偶ywanie wartoci boolowskich jako liczb "
"cakowitych.\n"
"  * Przeci偶enie operatora jest om贸wione w dniu 3 (leki generyczne).\n"
"</details>"

#: src/structs/field-shorthand.md:1
#, fuzzy
msgid "# Field Shorthand Syntax"
msgstr "# Skr贸cona skadnia pola"

#: src/structs/field-shorthand.md:3
#, fuzzy
msgid ""
"If you already have variables with the right names, then you can create the\n"
"struct using a shorthand:"
msgstr ""
"Jeli masz ju偶 zmienne o odpowiednich nazwach, mo偶esz je utworzy\n"
"struct za pomoc skr贸tu:"

#: src/structs/field-shorthand.md:6 src/methods.md:6
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}"
msgstr ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}"

#: src/structs/field-shorthand.md:13
msgid ""
"impl Person {\n"
"    fn new(name: String, age: u8) -> Person {\n"
"        Person { name, age }\n"
"    }\n"
"}"
msgstr ""
"impl Person {\n"
"    fn new(name: String, age: u8) -> Person {\n"
"        Person { name, age }\n"
"    }\n"
"}"

#: src/structs/field-shorthand.md:19
msgid ""
"fn main() {\n"
"    let peter = Person::new(String::from(\"Peter\"), 27);\n"
"    println!(\"{peter:?}\");\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let peter = Person::new(String::from(\"Peter\"), 27);\n"
"    println!(\"{peter:?}\");\n"
"}\n"
"```"

#: src/structs/field-shorthand.md:27
#, fuzzy
msgid ""
"*  The `new` function could be written using `Self` as a type, as it is "
"interchangeable with the struct type name"
msgstr ""
"* Funkcja `new` mo偶e by napisana przy u偶yciu `Self` jako typu, poniewa偶 "
"jest wymienna z nazw typu struct"

#: src/structs/field-shorthand.md:29
msgid ""
"```rust,ignore\n"
"impl Person {\n"
"    fn new(name: String, age: u8) -> Self {\n"
"        Self { name, age }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"impl Person {\n"
"    fn new(name: String, age: u8) -> Self {\n"
"        Self { name, age }\n"
"    }\n"
"}\n"
"```"

#: src/structs/field-shorthand.md:37
#, fuzzy
msgid ""
"* Methods are defined in the `impl` block.\n"
"* Use struct update syntax to define a new structure using `peter`. Note "
"that the variable `peter` will no longer be accessible afterwards.\n"
"* Use `{:#?}` when printing structs to request the `Debug` representation."
msgstr ""
"* Metody s zdefiniowane w bloku `impl`.\n"
"* U偶yj skadni aktualizacji struktury, aby zdefiniowa now struktur za "
"pomoc `peter`. Zauwa偶, 偶e p贸藕niej zmienna `peter` nie bdzie ju偶 dostpna.\n"
"* U偶yj `{:#?}` podczas drukowania struktur, aby za偶da reprezentacji "
"`Debug`."

#: src/enums.md:1
#, fuzzy
msgid "# Enums"
msgstr "# Wyliczenia"

#: src/enums.md:3
#, fuzzy
msgid ""
"The `enum` keyword allows the creation of a type which has a few\n"
"different variants:"
msgstr ""
"Sowo kluczowe `enum` pozwala na utworzenie typu, kt贸ry ma kilka\n"
"r贸偶ne warianty:"

#: src/enums.md:6
msgid ""
"```rust,editable\n"
"fn generate_random_number() -> i32 {\n"
"    4  // Chosen by fair dice roll. Guaranteed to be random.\n"
"}"
msgstr ""
"```rust,editable\n"
"fn generate_random_number() -> i32 {\n"
"    4  // Wyznaczone rzutem koci. Gwarantowana losowo.\n"
"}"

#: src/enums.md:11
msgid ""
"#[derive(Debug)]\n"
"enum CoinFlip {\n"
"    Heads,\n"
"    Tails,\n"
"}"
msgstr ""
"#[derive(Debug)]\n"
"enum CoinFlip {\n"
"    Heads,\n"
"    Tails,\n"
"}"

#: src/enums.md:17
msgid ""
"fn flip_coin() -> CoinFlip {\n"
"    let random_number = generate_random_number();\n"
"    if random_number % 2 == 0 {\n"
"        return CoinFlip::Heads;\n"
"    } else {\n"
"        return CoinFlip::Tails;\n"
"    }\n"
"}"
msgstr ""
"fn flip_coin() -> CoinFlip {\n"
"    let random_number = generate_random_number();\n"
"    if random_number % 2 == 0 {\n"
"        return CoinFlip::Heads;\n"
"    } else {\n"
"        return CoinFlip::Tails;\n"
"    }\n"
"}"

#: src/enums.md:26
msgid ""
"fn main() {\n"
"    println!(\"You got: {:?}\", flip_coin());\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    println!(\"Wynik: {:?}\", flip_coin());\n"
"}\n"
"```"

#: src/enums.md:31
#, fuzzy
msgid ""
"<details>\n"
"    \n"
"Key Points:"
msgstr ""
"<details>\n"
"    \n"
"Kluczowe punkty:"

#: src/enums.md:35
#, fuzzy
msgid ""
"* Enumerations allow you to collect a set of values under one type\n"
"* This page offers an enum type `CoinFlip` with two variants `Heads` and "
"`Tail`. You might note the namespace when using variants.\n"
"* This might be a good time to compare Structs and Enums:\n"
"  * In both, you can have a simple version without fields (unit struct) or "
"one with different types of fields (variant payloads). \n"
"  * In both, associated functions are defined within an `impl` block.\n"
"  * You could even implement the different variants of an enum with separate "
"structs but then they wouldnt be the same type as they would if they were "
"all defined in an enum. \n"
"</details>"
msgstr ""
"* Wyliczenia umo偶liwiaj zebranie zestawu wartoci w ramach jednego typu\n"
"* Ta strona oferuje typ wyliczeniowy `CoinFlip` z dwoma wariantami `Heads` i "
"`Tail`. Podczas u偶ywania wariant贸w mo偶esz zwr贸ci uwag na przestrze nazw.\n"
"* To mo偶e by dobry moment na por贸wnanie Structs i Enums:\n"
"  * W obu przypadkach mo偶esz mie prost wersj bez p贸l (struktura "
"jednostek) lub wersj z r贸偶nymi typami p贸l (wariantowe adunki).\n"
"  * W obu przypadkach powizane funkcje s zdefiniowane w bloku `impl`.\n"
"  * Mo偶na nawet zaimplementowa r贸偶ne warianty wyliczenia z osobnymi "
"strukturami, ale wtedy nie byyby one tego samego typu, co gdyby wszystkie "
"byy zdefiniowane w wyliczeniu.\n"
"</details>"

#: src/enums/variant-payloads.md:1
#, fuzzy
msgid "# Variant Payloads"
msgstr "# Wariant adunki"

#: src/enums/variant-payloads.md:3
#, fuzzy
msgid ""
"You can define richer enums where the variants carry data. You can then use "
"the\n"
"`match` statement to extract the data from each variant:"
msgstr ""
"Mo偶esz zdefiniowa bogatsze wyliczenia, w kt贸rych warianty zawieraj dane. "
"Mo偶esz wtedy u偶y tzw\n"
"Instrukcja `match` w celu wyodrbnienia danych z ka偶dego wariantu:"

#: src/enums/variant-payloads.md:6
msgid ""
"```rust,editable\n"
"enum WebEvent {\n"
"    PageLoad,                 // Variant without payload\n"
"    KeyPress(char),           // Tuple struct variant\n"
"    Click { x: i64, y: i64 }, // Full struct variant\n"
"}"
msgstr ""

#: src/enums/variant-payloads.md:13
msgid ""
"#[rustfmt::skip]\n"
"fn inspect(event: WebEvent) {\n"
"    match event {\n"
"        WebEvent::PageLoad       => println!(\"page loaded\"),\n"
"        WebEvent::KeyPress(c)    => println!(\"pressed '{c}'\"),\n"
"        WebEvent::Click { x, y } => println!(\"clicked at x={x}, y={y}\"),\n"
"    }\n"
"}"
msgstr ""
"#[rustfmt::skip]\n"
"fn inspect(event: WebEvent) {\n"
"    match event {\n"
"        WebEvent::PageLoad       => println!(\"strona zaadowana\"),\n"
"        WebEvent::KeyPress(c)    => println!(\"przycinito '{c}'\"),\n"
"        WebEvent::Click { x, y } => println!(\"kliknito w x={x}, y={y}\"),\n"
"    }\n"
"}"

#: src/enums/variant-payloads.md:22
msgid ""
"fn main() {\n"
"    let load = WebEvent::PageLoad;\n"
"    let press = WebEvent::KeyPress('x');\n"
"    let click = WebEvent::Click { x: 20, y: 80 };"
msgstr ""
"fn main() {\n"
"    let load = WebEvent::PageLoad;\n"
"    let press = WebEvent::KeyPress('x');\n"
"    let click = WebEvent::Click { x: 20, y: 80 };"

#: src/enums/variant-payloads.md:27
msgid ""
"    inspect(load);\n"
"    inspect(press);\n"
"    inspect(click);\n"
"}\n"
"```"
msgstr ""
"    inspect(load);\n"
"    inspect(press);\n"
"    inspect(click);\n"
"}\n"
"```"

#: src/enums/variant-payloads.md:35
#, fuzzy
msgid ""
"* The values in the enum variants can only be accessed after being pattern "
"matched. The pattern binds references to the fields in the \"match arm\" "
"after the `=>`.\n"
"  * The expressions is matched against the patterns from top to bottom. "
"There is no fall-through like in C or C++.\n"
"  * The match expression has a value. The value is the last expression in "
"the match arm which was executed.\n"
"  * Starting from the top we look for what pattern matches the value then "
"run the code following the arrow. Once we find a match, we stop. \n"
"* Demonstrate what happens when the search is inexhaustive. Note the "
"advantage the Rust compiler provides by confirming when all cases are "
"handled. \n"
"* `match` inspects a hidden discriminant field in the `enum`.\n"
"* It is possible to retrieve the discriminant by calling "
"`std::mem::discriminant()`\n"
"  * This is useful, for example, if implementing `PartialEq` for structs "
"where comparing field values doesn't affect equality.\n"
"* `WebEvent::Click { ... }` is not exactly the same as "
"`WebEvent::Click(Click)` with a top level `struct Click { ... }`. The "
"inlined version cannot implement traits, for example.  \n"
"  \n"
"</details>"
msgstr ""
"* Dostp do wartoci w wariantach enum mo偶na uzyska dopiero po dopasowaniu "
"do wzorca. Wzorzec wi偶e odniesienia do p贸l w rami dopasowania po `=>`.\n"
"  * Wyra偶enia s dopasowywane do wzorc贸w od g贸ry do dou. Nie ma spadku, jak "
"w C lub C++.\n"
"  * Wyra偶enie dopasowania ma warto. Warto to ostatnie wyra偶enie w "
"ramieniu dopasowania, kt贸re zostao wykonane.\n"
"  * Zaczynajc od g贸ry, szukamy wzoru pasujcego do wartoci, a nastpnie "
"uruchamiamy kod pod偶ajcy za strzak. Gdy znajdziemy dopasowanie, "
"zatrzymujemy si.\n"
"* Zademonstruj, co si dzieje, gdy wyszukiwanie jest niewyczerpujce. Zwr贸 "
"uwag na zalety kompilatora Rusta, kt贸ry potwierdza, kiedy wszystkie "
"przypadki s obsugiwane.\n"
"* `match` sprawdza ukryte pole dyskryminujce w `enum`.\n"
"* Mo偶liwe jest odzyskanie wyr贸偶nika przez wywoanie "
"`std::mem::discriminant()`\n"
"  * Jest to przydatne na przykad przy implementacji `PartialEq` dla "
"struktur, w kt贸rych por贸wnywanie wartoci p贸l nie wpywa na r贸wno.\n"
"* `WebEvent::Click { ... }` nie jest dokadnie tym samym co "
"`WebEvent::Click(Click)` z najwy偶szym poziomem `struct Click { ... }`. "
"Wbudowana wersja nie mo偶e na przykad implementowa cech.\n"
"  \n"
"</details>"

#: src/enums/sizes.md:1
#, fuzzy
msgid "# Enum Sizes"
msgstr "# Wylicz rozmiary"

#: src/enums/sizes.md:3
#, fuzzy
msgid ""
"Rust enums are packed tightly, taking constraints due to alignment into "
"account:"
msgstr ""
"Wyliczenia Rust s ciasno upakowane, biorc pod uwag ograniczenia "
"wynikajce z wyr贸wnania:"

#: src/enums/sizes.md:5
msgid "```rust,editable\nuse std::mem::{align_of, size_of};"
msgstr "```rust,editable\nuse std::mem::{align_of, size_of};"

#: src/enums/sizes.md:8
msgid ""
"macro_rules! dbg_size {\n"
"    ($t:ty) => {\n"
"        println!(\"{}: size {} bytes, align: {} bytes\",\n"
"                 stringify!($t), size_of::<$t>(), align_of::<$t>());\n"
"    };\n"
"}"
msgstr ""
"macro_rules! dbg_size {\n"
"    ($t:ty) => {\n"
"        println!(\"{}: rozmiar {} bajt贸w, wyr贸wnanie: {} bytes\",\n"
"                 stringify!($t), size_of::<$t>(), align_of::<$t>());\n"
"    };\n"
"}"

#: src/enums/sizes.md:15
msgid ""
"enum Foo {\n"
"    A,\n"
"    B,\n"
"}"
msgstr ""
"enum Foo {\n"
"    A,\n"
"    B,\n"
"}"

#: src/enums/sizes.md:20
msgid ""
"#[repr(u32)]\n"
"enum Bar {\n"
"    A,  // 0\n"
"    B = 10000,\n"
"    C,  // 10001\n"
"}"
msgstr ""
"#[repr(u32)]\n"
"enum Bar {\n"
"    A,  // 0\n"
"    B = 10000,\n"
"    C,  // 10001\n"
"}"

#: src/enums/sizes.md:27
msgid ""
"fn main() {\n"
"    dbg_size!(Foo);\n"
"    dbg_size!(Bar);\n"
"    dbg_size!(bool);\n"
"    dbg_size!(Option<bool>);\n"
"    dbg_size!(&i32);\n"
"    dbg_size!(Option<&i32>);\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    dbg_size!(Foo);\n"
"    dbg_size!(Bar);\n"
"    dbg_size!(bool);\n"
"    dbg_size!(Option<bool>);\n"
"    dbg_size!(&i32);\n"
"    dbg_size!(Option<&i32>);\n"
"}\n"
"```"

#: src/enums/sizes.md:37
#, fuzzy
msgid ""
"* See the [Rust "
"Reference](https://doc.rust-lang.org/reference/type-layout.html)."
msgstr ""
"* Zobacz [Odniesienie do "
"Rust](https://doc.rust-lang.org/reference/type-layout.html)."

#: src/enums/sizes.md:39
#, fuzzy
msgid ""
"<details>\n"
"    \n"
"Key Points: \n"
" * Internally Rust is using a field (discriminant) to keep track of the enum "
"variant.\n"
" * `Bar` enum demonstrates that there is a way to control the discriminant "
"value and type. If `repr` is removed, the discriminant type takes 2 bytes, "
"becuase 10001 fits 2 bytes.\n"
" * As a niche optimization an enum discriminant is merged with the pointer "
"so that `Option<&Foo>` is the same size as `&Foo`.\n"
" * `Option<bool>` is another example of tight packing.\n"
" * For [some types](https://doc.rust-lang.org/std/option/#representation), "
"Rust guarantees that `size_of::<T>()` equals `size_of::<Option<T>>()`.\n"
" * Zero-sized types allow for efficient implementation of `HashSet` using "
"`HashMap` with `()` as the value."
msgstr ""
"<details>\n"
"    \n"
"Kluczowe punkty:\n"
" * Wewntrznie Rust u偶ywa pola (dyskryminacyjnego) do ledzenia wariantu "
"enum.\n"
" * Wyliczenie `Bar` pokazuje, 偶e istnieje spos贸b kontrolowania wartoci i "
"typu wyr贸偶nika. Jeli usunie si `repr`, typ dyskryminacyjny zajmuje 2 "
"bajty, poniewa偶 10001 mieci 2 bajty.\n"
" * Jako optymalizacja niszowa dyskryminator wyliczeniowy jest czony ze "
"wska藕nikiem, dziki czemu `Option<&Foo>` ma taki sam rozmiar jak `&Foo`.\n"
" * `Option<bool>` to kolejny przykad ciasnego upakowania.\n"
" * Dla [niekt贸rych "
"typ贸w](https://doc.rust-lang.org/std/option/#representation), Rust "
"gwarantuje, 偶e `size_of::<T>()` r贸wna si `size_of::<Option<T> >()`.\n"
" * Typy o zerowym rozmiarze pozwalaj na wydajn implementacj `HashSet` "
"przy u偶yciu `HashMap` z `()` jako wartoci."

#: src/enums/sizes.md:49
#, fuzzy
msgid ""
"Example code if you want to show how the bitwise representation *may* look "
"like in practice.\n"
"It's important to note that the compiler provides no guarantees regarding "
"this representation, therefore this is totally unsafe."
msgstr ""
"Przykadowy kod, jeli chcesz pokaza, jak reprezentacja bitowa *mo偶e* "
"wyglda w praktyce.\n"
"Nale偶y zauwa偶y, 偶e kompilator nie zapewnia 偶adnych gwarancji dotyczcych "
"tej reprezentacji, dlatego jest to cakowicie niebezpieczne."

#: src/enums/sizes.md:52
msgid "```rust,editable\nuse std::mem::transmute;"
msgstr "```rust,editable\nuse std::mem::transmute;"

#: src/enums/sizes.md:55 src/enums/sizes.md:94
msgid ""
"macro_rules! dbg_bits {\n"
"    ($e:expr, $bit_type:ty) => {\n"
"        println!(\"- {}: {:#x}\", stringify!($e), transmute::<_, "
"$bit_type>($e));\n"
"    };\n"
"}"
msgstr ""
"macro_rules! dbg_bits {\n"
"    ($e:expr, $bit_type:ty) => {\n"
"        println!(\"- {}: {:#x}\", stringify!($e), transmute::<_, "
"$bit_type>($e));\n"
"    };\n"
"}"

#: src/enums/sizes.md:61
msgid ""
"fn main() {\n"
"    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
"    // representation of types.\n"
"    unsafe {\n"
"        println!(\"Bitwise representation of bool\");\n"
"        dbg_bits!(false, u8);\n"
"        dbg_bits!(true, u8);"
msgstr ""
"fn main() {\n"
"    // NIEBEZPIECZNE. Rust nie daje gwarancji jak dany typ jest przedstawiony w pamici.\n"
"    unsafe {\n"
"        println!(\"Bitowa reprezentacja typu bool\");\n"
"        dbg_bits!(false, u8);\n"
"        dbg_bits!(true, u8);"

#: src/enums/sizes.md:69
msgid ""
"        println!(\"Bitwise representation of Option<bool>\");\n"
"        dbg_bits!(None::<bool>, u8);\n"
"        dbg_bits!(Some(false), u8);\n"
"        dbg_bits!(Some(true), u8);"
msgstr ""
"        println!(\"Bitowa reprezentacja Option<bool>\");\n"
"        dbg_bits!(None::<bool>, u8);\n"
"        dbg_bits!(Some(false), u8);\n"
"        dbg_bits!(Some(true), u8);"

#: src/enums/sizes.md:74
msgid ""
"        println!(\"Bitwise representation of Option<Option<bool>>\");\n"
"        dbg_bits!(Some(Some(false)), u8);\n"
"        dbg_bits!(Some(Some(true)), u8);\n"
"        dbg_bits!(Some(None::<bool>), u8);\n"
"        dbg_bits!(None::<Option<bool>>, u8);"
msgstr ""
"        println!(\"Bitowa reprezentacja Option<Option<bool>>\");\n"
"        dbg_bits!(Some(Some(false)), u8);\n"
"        dbg_bits!(Some(Some(true)), u8);\n"
"        dbg_bits!(Some(None::<bool>), u8);\n"
"        dbg_bits!(None::<Option<bool>>, u8);"

#: src/enums/sizes.md:80
msgid ""
"        println!(\"Bitwise representation of Option<&i32>\");\n"
"        dbg_bits!(None::<&i32>, usize);\n"
"        dbg_bits!(Some(&0i32), usize);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"        println!(\"Bitowa reprezentacja Option<&i32>\");\n"
"        dbg_bits!(None::<&i32>, usize);\n"
"        dbg_bits!(Some(&0i32), usize);\n"
"    }\n"
"}\n"
"```"

#: src/enums/sizes.md:87
#, fuzzy
msgid ""
"More complex example if you want to discuss what happens when we chain more "
"than 256 `Option`s together."
msgstr ""
"Bardziej zo偶ony przykad, jeli chcesz om贸wi, co si stanie, gdy poczymy "
"razem wicej ni偶 256 opcji."

#: src/enums/sizes.md:89
msgid "```rust,editable\n#![recursion_limit = \"1000\"]"
msgstr "```rust,editable\n#![recursion_limit = \"1000\"]"

#: src/enums/sizes.md:92
msgid "use std::mem::transmute;"
msgstr "use std::mem::transmute;"

#: src/enums/sizes.md:100
msgid ""
"// Macro to wrap a value in 2^n Some() where n is the number of \"@\" "
"signs.\n"
"// Increasing the recursion limit is required to evaluate this macro.\n"
"macro_rules! many_options {\n"
"    ($value:expr) => { Some($value) };\n"
"    ($value:expr, @) => {\n"
"        Some(Some($value))\n"
"    };\n"
"    ($value:expr, @ $($more:tt)+) => {\n"
"        many_options!(many_options!($value, $($more)+), $($more)+)\n"
"    };\n"
"}"
msgstr ""
"// Makro pakujce warto w 2^n Some() gdzie n to liczba znak贸w \"@\".\n"
"// Zwiksznie limitu rekurencji jest wymagane 偶eby wywoa to makro.\n"
"macro_rules! many_options {\n"
"    ($value:expr) => { Some($value) };\n"
"    ($value:expr, @) => {\n"
"        Some(Some($value))\n"
"    };\n"
"    ($value:expr, @ $($more:tt)+) => {\n"
"        many_options!(many_options!($value, $($more)+), $($more)+)\n"
"    };\n"
"}"

#: src/enums/sizes.md:112
msgid ""
"fn main() {\n"
"    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
"    // representation of types.\n"
"    unsafe {\n"
"        assert_eq!(many_options!(false), Some(false));\n"
"        assert_eq!(many_options!(false, @), Some(Some(false)));\n"
"        assert_eq!(many_options!(false, @@), Some(Some(Some(Some(false)))));"
msgstr ""
"fn main() {\n"
"    // NIEBEZPIECZNE. Rust nie daje gwarancji jak dany typ jest przedstawiony w pamici.\n"
"    unsafe {\n"
"        assert_eq!(many_options!(false), Some(false));\n"
"        assert_eq!(many_options!(false, @), Some(Some(false)));\n"
"        assert_eq!(many_options!(false, @@), Some(Some(Some(Some(false)))));"

#: src/enums/sizes.md:120
msgid ""
"        println!(\"Bitwise representation of a chain of 128 Option's.\");\n"
"        dbg_bits!(many_options!(false, @@@@@@@), u8);\n"
"        dbg_bits!(many_options!(true, @@@@@@@), u8);"
msgstr ""
"        println!(\"Bitowa reprezentacja acucha 128 Option.\");\n"
"        dbg_bits!(many_options!(false, @@@@@@@), u8);\n"
"        dbg_bits!(many_options!(true, @@@@@@@), u8);"

#: src/enums/sizes.md:124
msgid ""
"        println!(\"Bitwise representation of a chain of 256 Option's.\");\n"
"        dbg_bits!(many_options!(false, @@@@@@@@), u16);\n"
"        dbg_bits!(many_options!(true, @@@@@@@@), u16);"
msgstr ""
"        println!(\"Bitowa reprezentacja acucha 256 Option.\");\n"
"        dbg_bits!(many_options!(false, @@@@@@@@), u16);\n"
"        dbg_bits!(many_options!(true, @@@@@@@@), u16);"

#: src/enums/sizes.md:128
msgid ""
"        println!(\"Bitwise representation of a chain of 257 Option's.\");\n"
"        dbg_bits!(many_options!(Some(false), @@@@@@@@), u16);\n"
"        dbg_bits!(many_options!(Some(true), @@@@@@@@), u16);\n"
"        dbg_bits!(many_options!(None::<bool>, @@@@@@@@), u16);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"        println!(\"Bitowa reprezentacja acucha 257 Option.\");\n"
"        dbg_bits!(many_options!(Some(false), @@@@@@@@), u16);\n"
"        dbg_bits!(many_options!(Some(true), @@@@@@@@), u16);\n"
"        dbg_bits!(many_options!(None::<bool>, @@@@@@@@), u16);\n"
"    }\n"
"}\n"
"```"

#: src/methods.md:3
#, fuzzy
msgid ""
"Rust allows you to associate functions with your new types. You do this with "
"an\n"
"`impl` block:"
msgstr ""
"Rust umo偶liwia powizanie funkcji z nowymi typami. Robisz to z\n"
"blok `impl`:"

#: src/methods.md:13
msgid ""
"impl Person {\n"
"    fn say_hello(&self) {\n"
"        println!(\"Hello, my name is {}\", self.name);\n"
"    }\n"
"}"
msgstr ""
"impl Person {\n"
"    fn say_hello(&self) {\n"
"        println!(\"Cze, mam na imi {}\", self.name);\n"
"    }\n"
"}"

#: src/methods.md:19
msgid ""
"fn main() {\n"
"    let peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        age: 27,\n"
"    };\n"
"    peter.say_hello();\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        age: 27,\n"
"    };\n"
"    peter.say_hello();\n"
"}\n"
"```"

#: src/methods.md:30
#, fuzzy
msgid ""
"Key Points:\n"
"* It can be helpful to introduce methods by comparing them to functions.\n"
"  * Methods are called on an instance of a type (such as a struct or enum), "
"the first parameter represents the instance as `self`.\n"
"  * Developers may choose to use methods to take advantage of method "
"receiver syntax and to help keep them more organized. By using methods we "
"can keep all the implementation code in one predictable place.\n"
"* Point out the use of the keyword `self`, a method receiver. \n"
"  * Show that it is an abbreviated term for `self:&Self` and perhaps show "
"how the struct name could also be used. \n"
"  * Explain that `Self` is a type alias for the type the `impl` block is in "
"and can be used elsewhere in the block.\n"
"  * Note how `self` is used like other structs and dot notation can be used "
"to refer to individual fields.\n"
"  * This might be a good time to demonstrate how the `&self` differs from "
"`self` by modifying the code and trying to run say_hello twice.  \n"
"* We describe the distinction between method receivers next.\n"
"   \n"
"</details>"
msgstr ""
"Kluczowe punkty:\n"
"* Pomocne mo偶e by wprowadzenie metod poprzez por贸wnanie ich z funkcjami.\n"
"  * Metody s wywoywane na instancji typu (takiej jak struct lub enum), "
"pierwszy parametr reprezentuje instancj jako `self`.\n"
"  * Deweloperzy mog zdecydowa si na u偶ycie metod, aby skorzysta ze "
"skadni odbiornika metod i pom贸c w ich lepszej organizacji. Dziki metodom "
"mo偶emy przechowywa cay kod implementacji w jednym przewidywalnym miejscu.\n"
"* Zwr贸 uwag na u偶ycie sowa kluczowego `self`, odbiornika metody.\n"
"  * Poka偶, 偶e jest to skr贸cony termin dla `self:&Self` i by mo偶e poka偶, jak "
"mo偶na r贸wnie偶 u偶y nazwy struktury.\n"
"  * Wyjanij, 偶e `Self` jest aliasem typu dla typu, w kt贸rym znajduje si "
"blok `impl` i mo偶e by u偶yty w innym miejscu bloku.\n"
"  * Zwr贸 uwag, jak `self` jest u偶ywane jak inne struktury, a notacja "
"kropkowa mo偶e by u偶ywana do odwoywania si do poszczeg贸lnych p贸l.\n"
"  * To mo偶e by dobry moment, aby zademonstrowa, czym `&self` r贸偶ni si od "
"`self` poprzez modyfikacj kodu i pr贸b dwukrotnego uruchomienia say_hello.\n"
"* Nastpnie opiszemy rozr贸偶nienie midzy odbiornikami metod.\n"
"   \n"
"</details>"

#: src/methods/receiver.md:1
#, fuzzy
msgid "# Method Receiver"
msgstr "# Odbiornik metody"

#: src/methods/receiver.md:3
#, fuzzy
msgid ""
"The `&self` above indicates that the method borrows the object immutably. "
"There\n"
"are other possible receivers for a method:"
msgstr ""
"&self powy偶ej wskazuje, 偶e metoda niezmiennie po偶ycza obiekt. Tam\n"
"s innymi mo偶liwymi odbiorcami metody:"

#: src/methods/receiver.md:6
#, fuzzy
msgid ""
"* `&self`: borrows the object from the caller using a shared and immutable\n"
"  reference. The object can be used again afterwards.\n"
"* `&mut self`: borrows the object from the caller using a unique and "
"mutable\n"
"  reference. The object can be used again afterwards.\n"
"* `self`: takes ownership of the object and moves it away from the caller. "
"The\n"
"  method becomes the owner of the object. The object will be dropped "
"(deallocated)\n"
"  when the method returns, unless its ownership is explicitly\n"
"  transmitted.\n"
"* `mut self`: same as above, but while the method owns the object, it can\n"
"  mutate it too. Complete ownership does not automatically mean mutability.\n"
"* No receiver: this becomes a static method on the struct. Typically used "
"to\n"
"  create constructors which are called `new` by convention."
msgstr ""
"* `&self`: po偶ycza obiekt od dzwonicego za pomoc wsp贸dzielonego i "
"niezmiennego\n"
"  odniesienie. Obiekt mo偶e by p贸藕niej ponownie u偶yty.\n"
"* `&mut self`: po偶ycza obiekt od wywoujcego u偶ywajc unikalnego i "
"zmiennego\n"
"  odniesienie. Obiekt mo偶e by p贸藕niej ponownie u偶yty.\n"
"* `self`: przejmuje obiekt na wasno i oddala go od dzwonicego. The\n"
"  metoda staje si wacicielem obiektu. Obiekt zostanie usunity (cofnity "
"przydzia)\n"
"  gdy metoda zwraca, chyba 偶e jej wasno jest wyra藕nie okrelona\n"
"  przekazywane.\n"
"* `mut self`: to samo co powy偶ej, ale gdy metoda jest wacicielem obiektu, "
"mo偶e\n"
"  te偶 mutuj. Pena wasno nie oznacza automatycznie zmiennoci.\n"
"* Brak odbiornika: staje si to metod statyczn w strukturze. Zwykle "
"przyzwyczajony\n"
"  tworzy konstruktory, kt贸re zgodnie z konwencj nazywane s nowymi."

#: src/methods/receiver.md:19
#, fuzzy
msgid ""
"Beyond variants on `self`, there are also\n"
"[special wrapper "
"types](https://doc.rust-lang.org/reference/special-types-and-traits.html)\n"
"allowed to be receiver types, such as `Box<Self>`."
msgstr ""
"Opr贸cz wariant贸w na ja, istniej r贸wnie偶\n"
"[specjalne typy "
"opakowa](https://doc.rust-lang.org/reference/special-types-and-traits.html)\n"
"mog by typami odbiornik贸w, takimi jak `Box<Self>`."

#: src/methods/receiver.md:23
#, fuzzy
msgid ""
"<details>\n"
"  \n"
"Consider emphasizing \"shared and immutable\" and \"unique and mutable\". "
"These constraints always come\n"
"together in Rust due to borrow checker rules, and `self` is no exception. It "
"isn't possible to\n"
"reference a struct from multiple locations and call a mutating (`&mut self`) "
"method on it.\n"
"  \n"
"</details>"
msgstr ""
"<details>\n"
"  \n"
"Rozwa偶 podkrelenie s贸w wsp贸lny i niezmienny oraz unikatowy i zmienny. "
"Te ograniczenia pojawiaj si zawsze\n"
"razem w Rust ze wzgldu na zasady po偶yczania sprawdzania, a `self` nie jest "
"wyjtkiem. Nie mo偶na\n"
"odwoa si do struktury z wielu lokalizacji i wywoa na niej metod "
"mutacji (`&mut self`).\n"
"  \n"
"</details>"

#: src/methods/example.md:1 src/concurrency/shared_state/example.md:1
msgid "# Example"
msgstr "# Przykad"

#: src/methods/example.md:3
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Race {\n"
"    name: String,\n"
"    laps: Vec<i32>,\n"
"}"
msgstr ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Race {\n"
"    name: String,\n"
"    laps: Vec<i32>,\n"
"}"

#: src/methods/example.md:10
#, fuzzy
msgid ""
"impl Race {\n"
"    fn new(name: &str) -> Race {  // No receiver, a static method\n"
"        Race { name: String::from(name), laps: Vec::new() }\n"
"    }"
msgstr ""
"impl Wycig {\n"
"    fn new(name: &str) -> Race { // Brak odbiornika, metoda statyczna\n"
"        Wycig { nazwa: String::from(name), okr偶enia: Vec::new() }\n"
"    }"

#: src/methods/example.md:15
msgid ""
"    fn add_lap(&mut self, lap: i32) {  // Exclusive borrowed read-write "
"access to self\n"
"        self.laps.push(lap);\n"
"    }"
msgstr ""

#: src/methods/example.md:19
msgid ""
"    fn print_laps(&self) {  // Shared and read-only borrowed access to self\n"
"        println!(\"Recorded {} laps for {}:\", self.laps.len(), self.name);\n"
"        for (idx, lap) in self.laps.iter().enumerate() {\n"
"            println!(\"Lap {idx}: {lap} sec\");\n"
"        }\n"
"    }"
msgstr ""

#: src/methods/example.md:26
msgid ""
"    fn finish(self) {  // Exclusive ownership of self\n"
"        let total = self.laps.iter().sum::<i32>();\n"
"        println!(\"Race {} is finished, total lap time: {}\", self.name, "
"total);\n"
"    }\n"
"}"
msgstr ""

#: src/methods/example.md:32
msgid ""
"fn main() {\n"
"    let mut race = Race::new(\"Monaco Grand Prix\");\n"
"    race.add_lap(70);\n"
"    race.add_lap(68);\n"
"    race.print_laps();\n"
"    race.add_lap(71);\n"
"    race.print_laps();\n"
"    race.finish();\n"
"    // race.add_lap(42);\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let mut race = Race::new(\"Monaco Grand Prix\");\n"
"    race.add_lap(70);\n"
"    race.add_lap(68);\n"
"    race.print_laps();\n"
"    race.add_lap(71);\n"
"    race.print_laps();\n"
"    race.finish();\n"
"    // race.add_lap(42);\n"
"}\n"
"```"

#: src/methods/example.md:44
#, fuzzy
msgid ""
"<details>\n"
"    \n"
"Key Points:\n"
"* All four methods here use a different method receiver.\n"
"  * You can point out how that changes what the function can do with the "
"variable values and if/how it can be used again in `main`.\n"
"  * You can showcase the error that appears when trying to call `finish` "
"twice.\n"
"* Note that although the method receivers are different, the non-static "
"functions are called the same way in the main body. Rust enables automatic "
"referencing and dereferencing when calling methods. Rust automatically adds "
"in the `&`, `*`, `muts` so that that object matches the method signature.\n"
"* You might point out that `print_laps` is using a vector that is iterated "
"over. We describe vectors in more detail in the afternoon. "
msgstr ""
"<details>\n"
"    \n"
"Kluczowe punkty:\n"
"* Wszystkie cztery metody tutaj wykorzystuj inny odbiornik metody.\n"
"  * Mo偶esz wskaza, jak to zmienia to, co funkcja mo偶e zrobi z wartociami "
"zmiennych i czy/jak mo偶na jej ponownie u偶y w `main`.\n"
"  * Mo偶esz pokaza bd, kt贸ry pojawia si podczas pr贸by dwukrotnego "
"wywoania `finish`.\n"
"* Nale偶y zauwa偶y, 偶e chocia偶 odbiorniki metod s r贸偶ne, funkcje "
"niestatyczne s wywoywane w ten sam spos贸b w g贸wnej czci. Rust umo偶liwia "
"automatyczne odwoywanie si i usuwanie odwoa podczas wywoywania metod. "
"Rust automatycznie dodaje `&`, `*`, `muts`, aby ten obiekt pasowa do "
"sygnatury metody.\n"
"* Mo偶esz zauwa偶y, 偶e `print_laps` u偶ywa wektora, kt贸ry jest iterowany. "
"Wektory opiszemy bardziej szczeg贸owo po poudniu."

#: src/pattern-matching.md:1
#, fuzzy
msgid "# Pattern Matching"
msgstr "# Dopasowanie wzorca"

#: src/pattern-matching.md:3
#, fuzzy
msgid ""
"The `match` keyword let you match a value against one or more _patterns_. "
"The\n"
"comparisons are done from top to bottom and the first match wins."
msgstr ""
"Sowo kluczowe `match` pozwala dopasowa warto do jednego lub wicej "
"_wzorc贸w_. The\n"
"por贸wnania s wykonywane od g贸ry do dou, a pierwszy mecz wygrywa."

#: src/pattern-matching.md:6
#, fuzzy
msgid "The patterns can be simple values, similarly to `switch` in C and C++:"
msgstr "Wzorce mog by prostymi wartociami, podobnie jak `switch` w C i C++:"

#: src/pattern-matching.md:8
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let input = 'x';"
msgstr ""

#: src/pattern-matching.md:12
msgid ""
"    match input {\n"
"        'q'                   => println!(\"Quitting\"),\n"
"        'a' | 's' | 'w' | 'd' => println!(\"Moving around\"),\n"
"        '0'..='9'             => println!(\"Number input\"),\n"
"        _                     => println!(\"Something else\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching.md:21
#, fuzzy
msgid "The `_` pattern is a wildcard pattern which matches any value."
msgstr ""
"Wzorzec `_` jest wzorcem wieloznacznym, kt贸ry pasuje do dowolnej wartoci."

#: src/pattern-matching.md:23
#, fuzzy
msgid ""
"<details>\n"
"    \n"
"Key Points:\n"
"* You might point out how some specific characters are being used when in a "
"pattern\n"
"  * `|` as an `or`\n"
"  * `..` can expand as much as it needs to be\n"
"  * `1..=5` represents an inclusive range\n"
"  * `_` is a wild card\n"
"* It can be useful to show how binding works, by for instance replacing a "
"wildcard character with a variable, or removing the quotes around `q`.\n"
"* You can demonstrate matching on a reference.\n"
"* This might be a good time to bring up the concept of irrefutable patterns, "
"as the term can show up in error messages.\n"
"   \n"
"</details>"
msgstr ""
"<details>\n"
"    \n"
"Kluczowe punkty:\n"
"* Mo偶esz wskaza, w jaki spos贸b niekt贸re okrelone znaki s u偶ywane we "
"wzorcu\n"
"  * `|` jako `lub`\n"
"  * `..` mo偶e rozwin si tak bardzo, jak to konieczne\n"
"  * `1..=5` reprezentuje zakres wcznie\n"
"  * `_` to symbol wieloznaczny\n"
"* Przydatne mo偶e by pokazanie, jak dziaa wizanie, na przykad zastpujc "
"symbol wieloznaczny zmienn lub usuwajc cudzysowy wok贸 `q`.\n"
"* Mo偶esz zademonstrowa dopasowanie na podstawie referencji.\n"
"* To mo偶e by dobry moment, aby przywoa koncepcj niepodwa偶alnych wzorc贸w, "
"poniewa偶 termin ten mo偶e pojawia si w komunikatach o bdach.\n"
"   \n"
"</details>"

#: src/pattern-matching/destructuring-enums.md:1
#, fuzzy
msgid "# Destructuring Enums"
msgstr "# Niszczenie wylicze"

#: src/pattern-matching/destructuring-enums.md:3
#, fuzzy
msgid ""
"Patterns can also be used to bind variables to parts of your values. This is "
"how\n"
"you inspect the structure of your types. Let us start with a simple `enum` "
"type:"
msgstr ""
"Wzorc贸w mo偶na r贸wnie偶 u偶ywa do wizania zmiennych z czciami wartoci. Oto "
"jak\n"
"sprawdzasz struktur swoich typ贸w. Zacznijmy od prostego typu `enum`:"

#: src/pattern-matching/destructuring-enums.md:6
msgid ""
"```rust,editable\n"
"enum Result {\n"
"    Ok(i32),\n"
"    Err(String),\n"
"}"
msgstr ""

#: src/pattern-matching/destructuring-enums.md:12
#, fuzzy
msgid ""
"fn divide_in_two(n: i32) -> Result {\n"
"    if n % 2 == 0 {\n"
"        Result::Ok(n / 2)\n"
"    } else {\n"
"        Result::Err(format!(\"cannot divide {n} into two equal parts\"))\n"
"    }\n"
"}"
msgstr ""
"fn dzielenie_na_dwa(n: i32) -> Wynik {\n"
"    jeli n % 2 == 0 {\n"
"        Wynik::OK(n / 2)\n"
"    } w przeciwnym razie {\n"
"        Result::Err(format!(\"nie mo偶na podzieli {n} na dwie r贸wne "
"czci\"))\n"
"    }\n"
"}"

#: src/pattern-matching/destructuring-enums.md:20
msgid ""
"fn main() {\n"
"    let n = 100;\n"
"    match divide_in_two(n) {\n"
"        Result::Ok(half) => println!(\"{n} divided in two is {half}\"),\n"
"        Result::Err(msg) => println!(\"sorry, an error happened: {msg}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/destructuring-enums.md:29
#, fuzzy
msgid ""
"Here we have used the arms to _destructure_ the `Result` value. In the "
"first\n"
"arm, `half` is bound to the value inside the `Ok` variant. In the second "
"arm,\n"
"`msg` is bound to the error message."
msgstr ""
"Tutaj u偶ylimy ramion do _destrukturyzacji_ wartoci `Result`. Na pocztku\n"
"arm, `half` jest powizany z wartoci wewntrz wariantu `Ok`. W drugim "
"ramieniu\n"
"`msg` jest powizany z komunikatem o bdzie."

#: src/pattern-matching/destructuring-enums.md:35
#, fuzzy
msgid ""
"Key points:\n"
"* The `if`/`else` expression is returning an enum that is later unpacked "
"with a `match`.\n"
"* You can try adding a third variant to the enum definition and displaying "
"the errors when running the code. Point out the places where your code is "
"now inexhaustive and how the compiler tries to give you hints."
msgstr ""
"Kluczowe punkty:\n"
"* Wyra偶enie `if`/`else` zwraca wyliczenie, kt贸re jest p贸藕niej rozpakowywane "
"z `match`.\n"
"* Mo偶esz spr贸bowa doda trzeci wariant do definicji enum i wywietli bdy "
"podczas uruchamiania kodu. Wska偶 miejsca, w kt贸rych Tw贸j kod jest teraz "
"niewyczerpany i jak kompilator pr贸buje udzieli Ci wskaz贸wek."

#: src/pattern-matching/destructuring-structs.md:1
#, fuzzy
msgid "# Destructuring Structs"
msgstr "# Destrukcja struktur"

#: src/pattern-matching/destructuring-structs.md:3
#, fuzzy
msgid "You can also destructure `structs`:"
msgstr "Mo偶esz tak偶e zniszczy `struktury`:"

#: src/pattern-matching/destructuring-structs.md:5
msgid ""
"```rust,editable\n"
"struct Foo {\n"
"    x: (u32, u32),\n"
"    y: u32,\n"
"}"
msgstr ""

#: src/pattern-matching/destructuring-structs.md:11
msgid ""
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let foo = Foo { x: (1, 2), y: 3 };\n"
"    match foo {\n"
"        Foo { x: (1, b), y } => println!(\"x.0 = 1, b = {b}, y = {y}\"),\n"
"        Foo { y: 2, x: i }   => println!(\"y = 2, x = {i:?}\"),\n"
"        Foo { y, .. }        => println!(\"y = {y}, other fields were "
"ignored\"),\n"
"    }\n"
"}\n"
"```\n"
"<details>"
msgstr ""

#: src/pattern-matching/destructuring-structs.md:23
#, fuzzy
msgid ""
"* Change the literal values in `foo` to match with the other patterns.\n"
"* Add a new field to `Foo` and make changes to the pattern as needed.\n"
"</details>"
msgstr ""
"* Zmie wartoci literalne w `foo`, aby dopasowa je do innych wzorc贸w.\n"
"* Dodaj nowe pole do `Foo` i w razie potrzeby wprowad藕 zmiany we wzorcu.\n"
"</details>"

#: src/pattern-matching/destructuring-arrays.md:1
#, fuzzy
msgid "# Destructuring Arrays"
msgstr "# Destrukturyzacja tablic"

#: src/pattern-matching/destructuring-arrays.md:3
#, fuzzy
msgid ""
"You can destructure arrays, tuples, and slices by matching on their elements:"
msgstr "Mo偶esz niszczy tablice, krotki i plasterki, dopasowujc ich elementy:"

#: src/pattern-matching/destructuring-arrays.md:5
msgid ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let triple = [0, -2, 3];\n"
"    println!(\"Tell me about {triple:?}\");\n"
"    match triple {\n"
"        [0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"        [1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
"        _         => println!(\"All elements were ignored\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/destructuring-arrays.md:21
#, fuzzy
msgid ""
"* Destructuring of slices of unknown length also works with patterns of "
"fixed length."
msgstr ""
"* Destrukturyzacja plasterk贸w o nieznanej dugoci dziaa r贸wnie偶 z wzorami "
"o staej dugoci."

#: src/pattern-matching/destructuring-arrays.md:24
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    inspect(&[0, -2, 3]);\n"
"    inspect(&[0, -2, 3, 4]);\n"
"}"
msgstr ""

#: src/pattern-matching/destructuring-arrays.md:30
msgid ""
"#[rustfmt::skip]\n"
"fn inspect(slice: &[i32]) {\n"
"    println!(\"Tell me about {slice:?}\");\n"
"    match slice {\n"
"        &[0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"        &[1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
"        _          => println!(\"All elements were ignored\"),\n"
"    }\n"
"}\n"
"```\n"
"  \n"
"* Create a new pattern using `_` to represent an element. \n"
"* Add more values to the array.\n"
"* Point out that how `..` will expand to account for different number of "
"elements.\n"
"* Show matching against the tail with patterns `[.., b]` and `[a@..,b]`"
msgstr ""

#: src/pattern-matching/match-guards.md:1
msgid "# Match Guards"
msgstr "# Stra偶nicy w dopasowywaniu wzorc贸w"

#: src/pattern-matching/match-guards.md:3
#, fuzzy
msgid ""
"When matching, you can add a _guard_ to a pattern. This is an arbitrary "
"Boolean\n"
"expression which will be executed if the pattern matches:"
msgstr ""
"Podczas dopasowywania mo偶esz doda _guard_ do wzoru. To jest dowolna warto "
"logiczna\n"
"wyra偶enie, kt贸re zostanie wykonane, jeli wzorzec pasuje:"

#: src/pattern-matching/match-guards.md:6
msgid ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let pair = (2, -2);\n"
"    println!(\"Tell me about {pair:?}\");\n"
"    match pair {\n"
"        (x, y) if x == y     => println!(\"These are twins\"),\n"
"        (x, y) if x + y == 0 => println!(\"Antimatter, kaboom!\"),\n"
"        (x, _) if x % 2 == 1 => println!(\"The first one is odd\"),\n"
"        _                    => println!(\"No correlation...\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/match-guards.md:22
#, fuzzy
msgid ""
"Key Points:\n"
"* Match guards as a separate syntax feature are important and necessary when "
"we wish to concisely express more complex ideas than patterns alone would "
"allow.\n"
"* They are not the same as separate `if` expression inside of the match arm. "
"An `if` expression inside of the branch block (after `=>`) happens after the "
"match arm is selected. Failing the `if` condition inside of that block won't "
"result in other arms\n"
"of the original `match` expression being considered.  \n"
"* You can use the variables defined in the pattern in your if expression.\n"
"* The condition defined in the guard applies to every expression in a "
"pattern with an `|`.\n"
"</details>"
msgstr ""
"Kluczowe punkty:\n"
"* Osony dopasowujce jako oddzielna funkcja skadni s wa偶ne i konieczne, "
"gdy chcemy zwi藕le wyrazi bardziej zo偶one idee, ni偶 pozwalaj na to same "
"wzorce.\n"
"* Nie s tym samym, co osobne wyra偶enie `if` wewntrz ramienia dopasowania. "
"Wyra偶enie `if` wewntrz bloku rozgazienia (po `=>`) nastpuje po wybraniu "
"ramienia dopasowania. Niepowodzenie warunku `if` wewntrz tego bloku nie "
"spowoduje powstania innych ramion\n"
"oryginalnego wyra偶enia dopasuj, kt贸re jest brane pod uwag.\n"
"* Mo偶esz u偶y zmiennych zdefiniowanych we wzorcu w swoim wyra偶eniu if.\n"
"* Warunek zdefiniowany w stra偶niku dotyczy ka偶dego wyra偶enia we wzorcu ze "
"znakiem `|`.\n"
"</details>"

#: src/exercises/day-2/morning.md:1
#, fuzzy
msgid "# Day 2: Morning Exercises"
msgstr "# Dzie 2: wiczenia poranne"

#: src/exercises/day-2/morning.md:3
#, fuzzy
msgid "We will look at implementing methods in two contexts:"
msgstr "Przyjrzymy si metodom implementacji w dw贸ch kontekstach:"

#: src/exercises/day-2/morning.md:5
#, fuzzy
msgid "* Simple struct which tracks health statistics."
msgstr "* Prosta struktura, kt贸ra ledzi statystyki zdrowotne."

#: src/exercises/day-2/morning.md:7
#, fuzzy
msgid "* Multiple structs and enums for a drawing library."
msgstr "* Wiele struktur i wylicze dla biblioteki rysunk贸w."

#: src/exercises/day-2/health-statistics.md:1
#, fuzzy
msgid "# Health Statistics"
msgstr "# Statystyki zdrowia"

#: src/exercises/day-2/health-statistics.md:3
#, fuzzy
msgid ""
"You're working on implementing a health-monitoring system. As part of that, "
"you\n"
"need to keep track of users' health statistics."
msgstr ""
"Pracujesz nad wdro偶eniem systemu monitorowania stanu. W ramach tego ty\n"
"musz ledzi statystyki dotyczce zdrowia u偶ytkownik贸w."

#: src/exercises/day-2/health-statistics.md:6
#, fuzzy
msgid ""
"You'll start with some stubbed functions in an `impl` block as well as a "
"`User`\n"
"struct definition. Your goal is to implement the stubbed out methods on the\n"
"`User` `struct` defined in the `impl` block."
msgstr ""
"Zaczniesz od niekt贸rych funkcji skr贸towych w bloku `impl`, jak r贸wnie偶 "
"`U偶ytkownika`\n"
"definicja struktury. Twoim celem jest zaimplementowanie wygaszonych metod "
"na\n"
"`User` `struct` zdefiniowana w bloku `impl`."

#: src/exercises/day-2/health-statistics.md:10
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the "
"missing\n"
"methods:"
msgstr ""
"Skopiuj poni偶szy kod na <https://play.rust-lang.org/> i uzupenij brakujce\n"
"metody:"

#: src/exercises/day-2/health-statistics.md:17
msgid ""
"struct User {\n"
"    name: String,\n"
"    age: u32,\n"
"    weight: f32,\n"
"}"
msgstr ""
"struct User {\n"
"    name: String,\n"
"    age: u32,\n"
"    weight: f32,\n"
"}"

#: src/exercises/day-2/health-statistics.md:23
msgid ""
"impl User {\n"
"    pub fn new(name: String, age: u32, weight: f32) -> Self {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"impl User {\n"
"    pub fn new(name: String, age: u32, weight: f32) -> Self {\n"
"        unimplemented!()\n"
"    }"

#: src/exercises/day-2/health-statistics.md:28
msgid ""
"    pub fn name(&self) -> &str {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"    pub fn name(&self) -> &str {\n"
"        unimplemented!()\n"
"    }"

#: src/exercises/day-2/health-statistics.md:32
msgid ""
"    pub fn age(&self) -> u32 {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"    pub fn age(&self) -> u32 {\n"
"        unimplemented!()\n"
"    }"

#: src/exercises/day-2/health-statistics.md:36
msgid ""
"    pub fn weight(&self) -> f32 {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"    pub fn weight(&self) -> f32 {\n"
"        unimplemented!()\n"
"    }"

#: src/exercises/day-2/health-statistics.md:40
msgid ""
"    pub fn set_age(&mut self, new_age: u32) {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"    pub fn set_age(&mut self, new_age: u32) {\n"
"        unimplemented!()\n"
"    }"

#: src/exercises/day-2/health-statistics.md:44
msgid ""
"    pub fn set_weight(&mut self, new_weight: f32) {\n"
"        unimplemented!()\n"
"    }\n"
"}"
msgstr ""
"    pub fn set_weight(&mut self, new_weight: f32) {\n"
"        unimplemented!()\n"
"    }\n"
"}"

#: src/exercises/day-2/health-statistics.md:49
msgid ""
"fn main() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    println!(\"I'm {} and my age is {}\", bob.name(), bob.age());\n"
"}"
msgstr ""
"fn main() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    println!(\"Jestem {} i mam {} lat\", bob.name(), bob.age());\n"
"}"

#: src/exercises/day-2/health-statistics.md:54
msgid ""
"#[test]\n"
"fn test_weight() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.weight(), 155.2);\n"
"}"
msgstr ""
"#[test]\n"
"fn test_weight() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.weight(), 155.2);\n"
"}"

#: src/exercises/day-2/health-statistics.md:60
msgid ""
"#[test]\n"
"fn test_set_age() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.age(), 32);\n"
"    bob.set_age(33);\n"
"    assert_eq!(bob.age(), 33);\n"
"}\n"
"```"
msgstr ""
"#[test]\n"
"fn test_set_age() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.age(), 32);\n"
"    bob.set_age(33);\n"
"    assert_eq!(bob.age(), 33);\n"
"}\n"
"```"

#: src/exercises/day-2/points-polygons.md:1
#, fuzzy
msgid "# Polygon Struct"
msgstr "# Struktura wielokta"

#: src/exercises/day-2/points-polygons.md:3
#, fuzzy
msgid ""
"We will create a `Polygon` struct which contain some points. Copy the code "
"below\n"
"to <https://play.rust-lang.org/> and fill in the missing methods to make "
"the\n"
"tests pass:"
msgstr ""
"Stworzymy struktur `Polygon` zawierajc kilka punkt贸w. Skopiuj poni偶szy "
"kod\n"
"na <https://play.rust-lang.org/> i uzupenij brakujce metody, aby utworzy "
"plik\n"
"testy przechodz:"

#: src/exercises/day-2/points-polygons.md:7 src/exercises/day-2/luhn.md:23
#: src/exercises/day-2/strings-iterators.md:12
msgid ""
"```rust\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]"
msgstr ""
"```rust\n"
"// TODO: usu to jak skoczysz implementacj.\n"
"#![allow(unused_variables, dead_code)]"

#: src/exercises/day-2/points-polygons.md:11
msgid ""
"pub struct Point {\n"
"    // add fields\n"
"}"
msgstr ""
"pub struct Point {\n"
"    // dodaj pola\n"
"}"

#: src/exercises/day-2/points-polygons.md:15
msgid ""
"impl Point {\n"
"    // add methods\n"
"}"
msgstr ""
"impl Point {\n"
"    // dodaj metody\n"
"}"

#: src/exercises/day-2/points-polygons.md:19
msgid ""
"pub struct Polygon {\n"
"    // add fields\n"
"}"
msgstr ""
"pub struct Polygon {\n"
"    // dodaj pola\n"
"}"

#: src/exercises/day-2/points-polygons.md:23
msgid ""
"impl Polygon {\n"
"    // add methods\n"
"}"
msgstr ""
"impl Polygon {\n"
"    // dodaj metody\n"
"}"

#: src/exercises/day-2/points-polygons.md:27
msgid ""
"pub struct Circle {\n"
"    // add fields\n"
"}"
msgstr ""
"pub struct Circle {\n"
"    // dodaj pola\n"
"}"

#: src/exercises/day-2/points-polygons.md:31
msgid ""
"impl Circle {\n"
"    // add methods\n"
"}"
msgstr ""
"impl Circle {\n"
"    // dodaj metody\n"
"}"

#: src/exercises/day-2/points-polygons.md:35
msgid ""
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}"
msgstr ""
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}"

#: src/exercises/day-2/points-polygons.md:40 src/testing/test-modules.md:15
msgid ""
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;"
msgstr ""
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;"

#: src/exercises/day-2/points-polygons.md:44 src/exercises/day-2/solutions-morning.md:165
msgid ""
"    fn round_two_digits(x: f64) -> f64 {\n"
"        (x * 100.0).round() / 100.0\n"
"    }"
msgstr ""
"    fn round_two_digits(x: f64) -> f64 {\n"
"        (x * 100.0).round() / 100.0\n"
"    }"

#: src/exercises/day-2/points-polygons.md:48 src/exercises/day-2/solutions-morning.md:169
msgid ""
"    #[test]\n"
"    fn test_point_magnitude() {\n"
"        let p1 = Point::new(12, 13);\n"
"        assert_eq!(round_two_digits(p1.magnitude()), 17.69);\n"
"    }"
msgstr ""
"    #[test]\n"
"    fn test_point_magnitude() {\n"
"        let p1 = Point::new(12, 13);\n"
"        assert_eq!(round_two_digits(p1.magnitude()), 17.69);\n"
"    }"

#: src/exercises/day-2/points-polygons.md:54 src/exercises/day-2/solutions-morning.md:175
msgid ""
"    #[test]\n"
"    fn test_point_dist() {\n"
"        let p1 = Point::new(10, 10);\n"
"        let p2 = Point::new(14, 13);\n"
"        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);\n"
"    }"
msgstr ""
"    #[test]\n"
"    fn test_point_dist() {\n"
"        let p1 = Point::new(10, 10);\n"
"        let p2 = Point::new(14, 13);\n"
"        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);\n"
"    }"

#: src/exercises/day-2/points-polygons.md:61 src/exercises/day-2/solutions-morning.md:182
msgid ""
"    #[test]\n"
"    fn test_point_add() {\n"
"        let p1 = Point::new(16, 16);\n"
"        let p2 = p1 + Point::new(-4, 3);\n"
"        assert_eq!(p2, Point::new(12, 19));\n"
"    }"
msgstr ""
"    #[test]\n"
"    fn test_point_add() {\n"
"        let p1 = Point::new(16, 16);\n"
"        let p2 = p1 + Point::new(-4, 3);\n"
"        assert_eq!(p2, Point::new(12, 19));\n"
"    }"

#: src/exercises/day-2/points-polygons.md:68 src/exercises/day-2/solutions-morning.md:189
msgid ""
"    #[test]\n"
"    fn test_polygon_left_most_point() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);"
msgstr ""
"    #[test]\n"
"    fn test_polygon_left_most_point() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);"

#: src/exercises/day-2/points-polygons.md:73 src/exercises/day-2/solutions-morning.md:194
msgid ""
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"        assert_eq!(poly.left_most_point(), Some(p1));\n"
"    }"
msgstr ""
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"        assert_eq!(poly.left_most_point(), Some(p1));\n"
"    }"

#: src/exercises/day-2/points-polygons.md:79 src/exercises/day-2/solutions-morning.md:200
msgid ""
"    #[test]\n"
"    fn test_polygon_iter() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);"
msgstr ""
"    #[test]\n"
"    fn test_polygon_iter() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);"

#: src/exercises/day-2/points-polygons.md:84 src/exercises/day-2/solutions-morning.md:205
msgid ""
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);"
msgstr ""
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);"

#: src/exercises/day-2/points-polygons.md:88 src/exercises/day-2/solutions-morning.md:209
msgid ""
"        let points = poly.iter().cloned().collect::<Vec<_>>();\n"
"        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);\n"
"    }"
msgstr ""
"        let points = poly.iter().cloned().collect::<Vec<_>>();\n"
"        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);\n"
"    }"

#: src/exercises/day-2/points-polygons.md:92
msgid ""
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimeter)\n"
"            .map(round_two_digits)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}"
msgstr ""
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimeter)\n"
"            .map(round_two_digits)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}"

#: src/exercises/day-2/points-polygons.md:111 src/exercises/day-2/luhn.md:68
msgid ""
"#[allow(dead_code)]\n"
"fn main() {}\n"
"```"
msgstr ""
"#[allow(dead_code)]\n"
"fn main() {}\n"
"```"

#: src/exercises/day-2/points-polygons.md:117
#, fuzzy
msgid ""
"Since the method signatures are missing from the problem statements, the key "
"part\n"
"of the exercise is to specify those correctly. You don't have to modify the "
"tests."
msgstr ""
"Poniewa偶 w opisach problem贸w brakuje sygnatur metod, kluczowa cz\n"
"wiczenia polega na ich prawidowym okreleniu. Nie musisz modyfikowa "
"test贸w."

#: src/exercises/day-2/points-polygons.md:120
#, fuzzy
msgid ""
"Other interesting parts of the exercise:\n"
"    \n"
"* Derive a `Copy` trait for some structs, as in tests the methods sometimes "
"don't borrow their arguments.\n"
"* Discover that `Add` trait must be implemented for two objects to be "
"addable via \"+\". Note that we do not discuss generics until Day 3."
msgstr ""
"Inne ciekawe czci wiczenia:\n"
"    \n"
"* Wyprowad藕 cech `Kopiuj` dla niekt贸rych struktur, poniewa偶 w testach "
"metody czasami nie po偶yczaj swoich argument贸w.\n"
"* Odkryj, 偶e cecha `Dodaj` musi zosta zaimplementowana, aby dwa obiekty "
"mo偶na byo dodawa za pomoc +. Pamitaj, 偶e nie omawiamy lek贸w "
"generycznych a偶 do dnia 3."

#: src/control-flow.md:1
#, fuzzy
msgid "# Control Flow"
msgstr "# Kontrola przepywu"

#: src/control-flow.md:3
#, fuzzy
msgid ""
"As we have seen, `if` is an expression in Rust. It is used to conditionally\n"
"evaluate one of two blocks, but the blocks can have a value which then "
"becomes\n"
"the value of the `if` expression. Other control flow expressions work "
"similarly\n"
"in Rust."
msgstr ""
"Jak widzielimy, `if` jest wyra偶eniem w Rust. Su偶y do warunkowego\n"
"oceni jeden z dw贸ch blok贸w, ale bloki mog mie warto, kt贸ra nastpnie "
"staje si\n"
"warto wyra偶enia `if`. Inne wyra偶enia przepywu sterowania dziaaj "
"podobnie\n"
"w Rucie."

#: src/control-flow/blocks.md:1
#, fuzzy
msgid "# Blocks"
msgstr "# Bloki"

#: src/control-flow/blocks.md:3
#, fuzzy
msgid ""
"A block in Rust has a value and a type: the value is the last expression of "
"the\n"
"block:"
msgstr "Blok w Rust ma warto i typ: warto jest ostatnim wyra偶eniem\nblok:"

#: src/control-flow/blocks.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x = {\n"
"        let y = 10;\n"
"        println!(\"y: {y}\");\n"
"        let z = {\n"
"            let w = {\n"
"                3 + 4\n"
"            };\n"
"            println!(\"w: {w}\");\n"
"            y * w\n"
"        };\n"
"        println!(\"z: {z}\");\n"
"        z - y\n"
"    };\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/blocks.md:25
#, fuzzy
msgid ""
"The same rule is used for functions: the value of the function body is the\n"
"return value:"
msgstr ""
"Ta sama regua jest u偶ywana dla funkcji: wartoci ciaa funkcji jest\n"
"zwracana warto:"

#: src/control-flow/blocks.md:28
msgid ""
"```rust,editable\n"
"fn double(x: i32) -> i32 {\n"
"    x + x\n"
"}"
msgstr ""

#: src/control-flow/blocks.md:33
msgid ""
"fn main() {\n"
"    println!(\"doubled: {}\", double(7));\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/blocks.md:38
msgid ""
"However if the last expression ends with `;`, then the resulting value and "
"type is `()`."
msgstr ""

#: src/control-flow/blocks.md:42
#, fuzzy
msgid ""
"Key Points:\n"
"* The point of this slide is to show that blocks have a type and value in "
"Rust. \n"
"* You can show how the value of the block changes by changing the last line "
"in the block. For instance, adding/removing a semicolon or using a "
"`return`.\n"
"   \n"
"</details>"
msgstr ""
"Kluczowe punkty:\n"
"* Celem tego slajdu jest pokazanie, 偶e bloki maj typ i warto w Rust.\n"
"* Mo偶esz pokaza, jak zmienia si warto bloku, zmieniajc ostatni lini w "
"bloku. Na przykad dodanie/usunicie rednika lub u偶ycie zwrotu.\n"
"   \n"
"</details>"

#: src/control-flow/if-expressions.md:1
#, fuzzy
msgid "# `if` expressions"
msgstr "# wyra偶enia `jeli`"

#: src/control-flow/if-expressions.md:3
#, fuzzy
msgid "You use `if` very similarly to how you would in other languages:"
msgstr "U偶ywasz `if` bardzo podobnie jak w innych jzykach:"

#: src/control-flow/if-expressions.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    if x % 2 == 0 {\n"
"        x = x / 2;\n"
"    } else {\n"
"        x = 3 * x + 1;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/if-expressions.md:16
#, fuzzy
msgid ""
"In addition, you can use it as an expression. This does the same as above:"
msgstr "Ponadto mo偶esz u偶y go jako wyra偶enia. Robi to samo, co powy偶ej:"

#: src/control-flow/if-expressions.md:18
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    x = if x % 2 == 0 {\n"
"        x / 2\n"
"    } else {\n"
"        3 * x + 1\n"
"    };\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/if-expressions.md:31
msgid ""
"Because `if` is an expression and must have a particular type, both of its "
"branch blocks must have the same type. Consider showing what happens if you "
"add `;` after `x / 2` in the second example.\n"
"    \n"
"</details>"
msgstr ""

#: src/control-flow/if-let-expressions.md:1
#, fuzzy
msgid "# `if let` expressions"
msgstr "# wyra偶enia `if let`"

#: src/control-flow/if-let-expressions.md:3
#, fuzzy
msgid "If you want to match a value against a pattern, you can use `if let`:"
msgstr "Jeli chcesz dopasowa warto do wzorca, mo偶esz u偶y `if let`:"

#: src/control-flow/if-let-expressions.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let arg = std::env::args().next();\n"
"    if let Some(value) = arg {\n"
"        println!(\"Program name: {value}\");\n"
"    } else {\n"
"        println!(\"Missing name?\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/if-let-expressions.md:16 src/control-flow/while-let-expressions.md:21
#: src/control-flow/match-expressions.md:22
#, fuzzy
msgid ""
"See [pattern matching](../pattern-matching.md) for more details on patterns "
"in\n"
"Rust."
msgstr ""
"Zobacz [dopasowywanie wzorc贸w](../pattern-matching.md), aby uzyska wicej "
"informacji na temat wzorc贸w w\n"
"Rdza."

#: src/control-flow/if-let-expressions.md:21
#, fuzzy
msgid ""
"* `if let` can be more concise than `match`, e.g., when only one case is "
"interesting. In contrast, `match` requires all branches to be covered.\n"
"    * For the similar use case consider demonstrating a newly stabilized "
"[`let else`](https://github.com/rust-lang/rust/pull/93628) feature.\n"
"* A common usage is handling `Some` values when working with `Option`.\n"
"* Unlike `match`, `if let` does not support guard clauses for pattern "
"matching."
msgstr ""
"* `if let` mo偶e by bardziej zwize ni偶 `dopasuj`, np. gdy interesujcy "
"jest tylko jeden przypadek. Natomiast dopasowanie wymaga pokrycia "
"wszystkich gazi.\n"
"    * W przypadku podobnego przypadku rozwa偶 zademonstrowanie nowo "
"ustabilizowanej funkcji [`let "
"else`](https://github.com/rust-lang/rust/pull/93628).\n"
"* Typowym zastosowaniem jest obsuga wartoci `Some` podczas pracy z "
"`Option`.\n"
"* W przeciwiestwie do `match`, `if let` nie obsuguje klauzul ochronnych "
"dla dopasowywania wzorc贸w."

#: src/control-flow/while-expressions.md:1
#, fuzzy
msgid "# `while` expressions"
msgstr "# Wyra偶enia `while`"

#: src/control-flow/while-expressions.md:3
#, fuzzy
msgid "The `while` keyword works very similar to other languages:"
msgstr "Sowo kluczowe `while` dziaa bardzo podobnie do innych jzyk贸w:"

#: src/control-flow/while-expressions.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    while x != 1 {\n"
"        x = if x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"    }\n"
"    println!(\"Final x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/while-let-expressions.md:1
#, fuzzy
msgid "# `while let` expressions"
msgstr "# wyra偶enia `while let`"

#: src/control-flow/while-let-expressions.md:3
#, fuzzy
msgid ""
"Like with `if`, there is a `while let` variant which repeatedly tests a "
"value\n"
"against a pattern:"
msgstr ""
"Podobnie jak w przypadku `if`, istnieje wariant `while let`, kt贸ry "
"wielokrotnie sprawdza warto\n"
"wbrew wzorowi:"

#: src/control-flow/while-let-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();"
msgstr ""

#: src/control-flow/while-let-expressions.md:11
msgid ""
"    while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/while-let-expressions.md:17
#, fuzzy
msgid ""
"Here the iterator returned by `v.iter()` will return a `Option<i32>` on "
"every\n"
"call to `next()`. It returns `Some(x)` until it is done, after which it "
"will\n"
"return `None`. The `while let` lets us keep iterating through all items."
msgstr ""
"Tutaj iterator zwr贸cony przez `v.iter()` zwr贸ci `Option<i32>` przy ka偶dym\n"
"wywoanie funkcji nastpny(). Zwraca `Some(x)` dop贸ki nie skoczy, po czym "
"to zrobi\n"
"zwr贸 Brak. Polecenie while let pozwala nam przeglda wszystkie "
"elementy."

#: src/control-flow/while-let-expressions.md:27
#, fuzzy
msgid ""
"* Point out that the `while let` loop will keep going as long as the value "
"matches the pattern.\n"
"* You could rewrite the `while let` loop as an infinite loop with an if "
"statement that breaks when there is no value to unwrap for `iter.next()`. "
"The `while let` provides syntactic sugar for the above scenario.\n"
"    \n"
"</details>"
msgstr ""
"* Zwr贸 uwag, 偶e ptla while let bdzie dziaa tak dugo, jak dugo "
"warto bdzie pasowa do wzorca.\n"
"* Mo偶esz przepisa ptl `while let` jako ptl nieskoczon z instrukcj "
"if, kt贸ra przerywa dziaanie, gdy nie ma wartoci do rozpakowania dla "
"`iter.next()`. Opcja `while let` zapewnia cukier skadniowy dla powy偶szego "
"scenariusza.\n"
"    \n"
"</details>"

#: src/control-flow/for-expressions.md:1
#, fuzzy
msgid "# `for` expressions"
msgstr "# wyra偶enia `for`"

#: src/control-flow/for-expressions.md:3
#, fuzzy
msgid ""
"The `for` expression is closely related to the `while let` expression. It "
"will\n"
"automatically call `into_iter()` on the expression and then iterate over it:"
msgstr ""
"Wyra偶enie `for` jest blisko spokrewnione z wyra偶eniem `while let`. To "
"bdzie\n"
"automatycznie wywoaj `into_iter()` na wyra偶eniu, a nastpnie wykonaj "
"iteracj:"

#: src/control-flow/for-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];"
msgstr ""

#: src/control-flow/for-expressions.md:10
msgid ""
"    for x in v {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"    \n"
"    for i in (0..10).step_by(2) {\n"
"        println!(\"i: {i}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/for-expressions.md:20
#, fuzzy
msgid "You can use `break` and `continue` here as usual."
msgstr "Mo偶esz u偶y `break` i `continue` tutaj jak zwykle."

#: src/control-flow/for-expressions.md:22
#, fuzzy
msgid ""
"<details>\n"
"    \n"
"* Index iteration is not a special syntax in Rust for just that case.\n"
"* `(0..10)` is a range that implements an `Iterator` trait. \n"
"* `step_by` is a method that returns another `Iterator` that skips every "
"other element. \n"
"* Modify the elements in the vector and explain the compiler errors. Change "
"vector `v` to be mutable and the for loop to `for x in v.iter_mut()`."
msgstr ""
"<details>\n"
"    \n"
"* Iteracja indeksu nie jest specjaln skadni w Rust tylko w tym "
"przypadku.\n"
"* `(0..10)` to zakres implementujcy cech `Iterator`.\n"
"* `step_by` to metoda, kt贸ra zwraca kolejny `Iterator`, kt贸ry pomija ka偶dy "
"inny element.\n"
"* Zmodyfikuj elementy wektora i wyjanij bdy kompilatora. Zmie wektor `v` "
"na zmienny, a ptl for na `for x w v.iter_mut()`."

#: src/control-flow/loop-expressions.md:1
#, fuzzy
msgid "# `loop` expressions"
msgstr "# wyra偶enia `ptli`"

#: src/control-flow/loop-expressions.md:3
#, fuzzy
msgid ""
"Finally, there is a `loop` keyword which creates an endless loop. Here you "
"must\n"
"either `break` or `return` to stop the loop:"
msgstr ""
"Wreszcie istnieje sowo kluczowe `loop`, kt贸re tworzy nieskoczon ptl. "
"Tutaj musisz\n"
"albo `break` albo `return`, aby zatrzyma ptl:"

#: src/control-flow/loop-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    loop {\n"
"        x = if x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"        if x == 1 {\n"
"            break;\n"
"        }\n"
"    }\n"
"    println!(\"Final x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/loop-expressions.md:23
#, fuzzy
msgid ""
"<details>\n"
"    \n"
"* Break the `loop` with a value (e.g. `break 8`) and print it out."
msgstr ""
"<details>\n"
"    \n"
"* Przerwij `ptl` wartoci (np. `break 8`) i wypisz j."

#: src/control-flow/match-expressions.md:1
#, fuzzy
msgid "# `match` expressions"
msgstr "# `dopasuj` wyra偶enia"

#: src/control-flow/match-expressions.md:3
#, fuzzy
msgid ""
"The `match` keyword is used to match a value against one or more patterns. "
"In\n"
"that sense, it works like a series of `if let` expressions:"
msgstr ""
"Sowo kluczowe `match` su偶y do dopasowania wartoci do jednego lub wicej "
"wzorc贸w. W\n"
"w tym sensie dziaa jak seria wyra偶e if let:"

#: src/control-flow/match-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    match std::env::args().next().as_deref() {\n"
"        Some(\"cat\") => println!(\"Will do cat things\"),\n"
"        Some(\"ls\")  => println!(\"Will ls some files\"),\n"
"        Some(\"mv\")  => println!(\"Let's move some files\"),\n"
"        Some(\"rm\")  => println!(\"Uh, dangerous!\"),\n"
"        None        => println!(\"Hmm, no program name?\"),\n"
"        _           => println!(\"Unknown program name!\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/match-expressions.md:19
#, fuzzy
msgid ""
"Like `if let`, each match arm must have the same type. The type is the last\n"
"expression of the block, if any. In the example above, the type is `()`."
msgstr ""
"Podobnie jak `if let`, ka偶de rami dopasowania musi by tego samego typu. "
"Typ jest ostatni\n"
"wyra偶enie bloku, jeli istnieje. W powy偶szym przykadzie typem jest `()`."

#: src/control-flow/match-expressions.md:27
#, fuzzy
msgid ""
"* Save the match expression to a variable and print it out.\n"
"* Remove `.as_deref()` and explain the error.\n"
"    * `std::env::args().next()` returns an `Option<String>`, but we cannot "
"match against `String`.\n"
"    * `as_deref()` transforms an `Option<T>` to `Option<&T::Target>`. In our "
"case, this turns `Option<String>` into `Option<&str>`.\n"
"    * We can now use pattern matching to match against the `&str` inside "
"`Option`.\n"
"</details>"
msgstr ""
"* Zapisz wyra偶enie dopasowania do zmiennej i wydrukuj je.\n"
"* Usu `.as_deref()` i wyjanij bd.\n"
"    * `std::env::args().next()` zwraca `Option<String>`, ale nie mo偶emy "
"dopasowa do `String`.\n"
"    * `as_deref()` przeksztaca `Option<T>` w `Option<&T::Target>`. W naszym "
"przypadku zmienia to `Option<String>` w `Option<&str>`.\n"
"    * Mo偶emy teraz u偶y dopasowywania wzorc贸w, aby dopasowa si do `&str` "
"wewntrz `Option`.\n"
"</details>"

#: src/control-flow/break-continue.md:1
#, fuzzy
msgid "# `break` and `continue`"
msgstr "# `przerwij` i `kontynuuj`"

#: src/control-flow/break-continue.md:3
#, fuzzy
msgid ""
"If you want to exit a loop early, use `break`, if you want to immediately "
"start\n"
"the next iteration use `continue`. Both `continue` and `break` can "
"optionally\n"
"take a label argument which is used to break out of nested loops:"
msgstr ""
"Jeli chcesz wyj z ptli wczeniej, u偶yj `break`, jeli chcesz natychmiast "
"rozpocz\n"
"w nastpnej iteracji u偶yj polecenia kontynuuj. Zar贸wno `continue`, jak i "
"`break` mog opcjonalnie\n"
"we藕 argument etykiety, kt贸ry su偶y do wyrwania si z zagnie偶d偶onych ptli:"

#: src/control-flow/break-continue.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();\n"
"    'outer: while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"        let mut i = 0;\n"
"        while i < x {\n"
"            println!(\"x: {x}, i: {i}\");\n"
"            i += 1;\n"
"            if i == 3 {\n"
"                break 'outer;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/break-continue.md:25
#, fuzzy
msgid ""
"In this case we break the outer loop after 3 iterations of the inner loop."
msgstr ""
"W tym przypadku przerywamy zewntrzn ptl po 3 iteracjach wewntrznej "
"ptli."

#: src/std.md:1
#, fuzzy
msgid "# Standard Library"
msgstr "# Biblioteka standardowa"

#: src/std.md:3
#, fuzzy
msgid ""
"Rust comes with a standard library which helps establish a set of common "
"types\n"
"used by Rust library and programs. This way, two libraries can work "
"together\n"
"smoothly because they both use the same `String` type."
msgstr ""
"Rust jest dostarczany ze standardow bibliotek, kt贸ra pomaga ustali zestaw "
"typowych typ贸w\n"
"u偶ywany przez bibliotek i programy Rusta. W ten spos贸b dwie biblioteki mog "
"ze sob wsp贸pracowa\n"
"pynnie, poniewa偶 oba u偶ywaj tego samego typu `String`."

#: src/std.md:7
#, fuzzy
msgid "The common vocabulary types include:"
msgstr "Typowe typy sownictwa obejmuj:"

#: src/std.md:9
msgid ""
"* [`Option` and `Result`](std/option-result.md) types: used for optional "
"values\n"
"  and [error handling](error-handling.md)."
msgstr ""
"* Typy [`Option` i `Result`](std/option-result.md): u偶ywane dla wartoci "
"opcjonalnych\n"
"  i [obsugi bd贸w](error-handling.md)."

#: src/std.md:12
#, fuzzy
msgid "* [`String`](std/string.md): the default string type used for owned data."
msgstr ""
"* [`String`](std/string.md): domylny typ cigu u偶ywany dla posiadanych "
"danych."

#: src/std.md:14
#, fuzzy
msgid "* [`Vec`](std/vec.md): a standard extensible vector."
msgstr "* [`Vec`](std/vec.md): standardowy rozszerzalny wektor."

#: src/std.md:16
#, fuzzy
msgid ""
"* [`HashMap`](std/hashmap.md): a hash map type with a configurable hashing\n"
"  algorithm."
msgstr ""
"* [`HashMap`](std/hashmap.md): typ mapy mieszajcej z konfigurowalnym "
"haszowaniem\n"
"  algorytm."

#: src/std.md:19
#, fuzzy
msgid "* [`Box`](std/box.md): an owned pointer for heap-allocated data."
msgstr ""
"* [`Box`](std/box.md): wasny wska藕nik dla danych przydzielonych na stercie."

#: src/std.md:21
#, fuzzy
msgid ""
"* [`Rc`](std/rc.md): a shared reference-counted pointer for heap-allocated "
"data."
msgstr ""
"* [`Rc`](std/rc.md): wsp贸dzielony wska藕nik zliczania odwoa dla danych "
"alokowanych na stercie."

#: src/std.md:23
#, fuzzy
msgid ""
"<details>\n"
"  \n"
"  * In fact, Rust contains several layers of the Standard Library: `core`, "
"`alloc` and `std`. \n"
"  * `core` includes the most basic types and functions that don't depend on "
"`libc`, allocator or\n"
"    even the presence of an operating system. \n"
"  * `alloc` includes types which require a global heap allocator, such as "
"`Vec`, `Box` and `Arc`.\n"
"  * Embedded Rust applications often only use `core`, and sometimes `alloc`."
msgstr ""
"<details>\n"
"  \n"
"  * W rzeczywistoci Rust zawiera kilka warstw Biblioteki Standardowej: "
"`core`, `alloc` i `std`.\n"
"  * `core` zawiera najbardziej podstawowe typy i funkcje, kt贸re nie zale偶 "
"od `libc`, alokatora lub\n"
"    nawet obecno systemu operacyjnego.\n"
"  * `alloc` obejmuje typy, kt贸re wymagaj globalnego alokatora sterty, takie "
"jak `Vec`, `Box` i `Arc`.\n"
"  * Aplikacje Embedded Rust czsto u偶ywaj tylko `core`, a czasami `alloc`."

#: src/std/option-result.md:1
msgid "# `Option` and `Result`"
msgstr "# `Option` i `Result`"

#: src/std/option-result.md:3
#, fuzzy
msgid "The types represent optional data:"
msgstr "Typy reprezentuj dane opcjonalne:"

#: src/std/option-result.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let numbers = vec![10, 20, 30];\n"
"    let first: Option<&i8> = numbers.first();\n"
"    println!(\"first: {first:?}\");"
msgstr ""

#: src/std/option-result.md:11
msgid ""
"    let idx: Result<usize, usize> = numbers.binary_search(&10);\n"
"    println!(\"idx: {idx:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/option-result.md:18
#, fuzzy
msgid ""
"* `Option` and `Result` are widely used not just in the standard library.\n"
"* `Option<&T>` has zero space overhead compared to `&T`.\n"
"* `Result` is the standard type to implement error handling as we will see "
"on Day 3.\n"
"* `binary_search` returns `Result<usize, usize>`.\n"
"  * If found, `Result::Ok` holds the index where the element is found.\n"
"  * Otherwise, `Result::Err` contains the index where such an element should "
"be inserted."
msgstr ""
"* `Opcja` i `Wynik` s szeroko stosowane nie tylko w standardowej "
"bibliotece.\n"
"* `Option<&T>` ma zerowy narzut przestrzeni w por贸wnaniu z `&T`.\n"
"* `Result` to standardowy typ implementacji obsugi bd贸w, jak zobaczymy w "
"dniu 3.\n"
"* `binary_search` zwraca `Result<usize, use>`.\n"
"  * Jeli zostanie znaleziony, `Result::Ok` zawiera indeks, w kt贸rym element "
"zosta znaleziony.\n"
"  * W przeciwnym razie `Result::Err` zawiera indeks, w kt贸rym taki element "
"powinien zosta wstawiony."

#: src/std/string.md:1
#, fuzzy
msgid "# String"
msgstr "# Strunowy"

#: src/std/string.md:3
#, fuzzy
msgid ""
"[`String`][1] is the standard heap-allocated growable UTF-8 string buffer:"
msgstr ""
"[`String`][1] to standardowy bufor cig贸w znak贸w UTF-8 przydzielony na "
"stercie:"

#: src/std/string.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::new();\n"
"    s1.push_str(\"Hello\");\n"
"    println!(\"s1: len = {}, capacity = {}\", s1.len(), s1.capacity());"
msgstr ""

#: src/std/string.md:11
msgid ""
"    let mut s2 = String::with_capacity(s1.len() + 1);\n"
"    s2.push_str(&s1);\n"
"    s2.push('!');\n"
"    println!(\"s2: len = {}, capacity = {}\", s2.len(), s2.capacity());"
msgstr ""

#: src/std/string.md:16
msgid ""
"    let s3 = String::from(\"\");\n"
"    println!(\"s3: len = {}, number of chars = {}\", s3.len(),\n"
"             s3.chars().count());\n"
"}\n"
"```"
msgstr ""

#: src/std/string.md:22
#, fuzzy
msgid ""
"`String` implements [`Deref<Target = str>`][2], which means that you can "
"call all\n"
"`str` methods on a `String`."
msgstr ""
"`String` implementuje [`Deref<Target = str>`][2], co oznacza, 偶e mo偶esz "
"wywoa wszystkie\n"
"Metody `str` na `Stringu`."

#: src/std/string.md:25
#, fuzzy
msgid ""
"[1]: https://doc.rust-lang.org/std/string/struct.String.html\n"
"[2]: "
"https://doc.rust-lang.org/std/string/struct.String.html#deref-methods-str"
msgstr ""
"[1]: https://doc.rust-lang.org/std/string/struct.String.html\n"
"[2]: "
"https://doc.rust-lang.org/std/string/struct.String.html#deref-methods-str"

#: src/std/string.md:30
msgid ""
"* `String::new` returns a new empty string, use `String::with capacity` when "
"you know how much data you want to push to the string.\n"
"* `String::len` returns the size of the `String` in bytes (which can be "
"different from its length in characters).\n"
"* `String::chars` returns an iterator over the actual characters. Note that "
"a `char` can be different from what a human will consider a \"character\" "
"due to [grapheme "
"clusters](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.Graphemes.html).\n"
"*  When people refer to strings they could either be talking about `&str` or "
"`String`.  \n"
"* When a type implements `Deref<Target = T>`, the compiler will let you "
"transparently call methods from `T`.\n"
"    * `String` implements `Deref<Target = str>` which transparently gives it "
"access to `str`'s methods.\n"
"    * Write and compare `let s3 = s1.deref();` and  `let s3 = &*s1`;.\n"
"* `String` is implemented as a wrapper around a vector of bytes, many of the "
"operations you see supported on vectors are also supported on `String`, but "
"with some extra guarantees.\n"
"* Compare the different ways to inde a Strings by using `s3[i]` and "
"`s3.chars.nth(i).unwrap()` where `i` is in-bound, out-of-bounds, and \"on\" "
"the flag unicode character."
msgstr ""

#: src/std/vec.md:1
#, fuzzy
msgid "# `Vec`"
msgstr "# `Vec`"

#: src/std/vec.md:3
#, fuzzy
msgid "[`Vec`][1] is the standard resizable heap-allocated buffer:"
msgstr ""
"[`Vec`][1] to standardowy bufor alokowany na stercie o zmiennym rozmiarze:"

#: src/std/vec.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v1 = Vec::new();\n"
"    v1.push(42);\n"
"    println!(\"v1: len = {}, capacity = {}\", v1.len(), v1.capacity());"
msgstr ""

#: src/std/vec.md:11
msgid ""
"    let mut v2 = Vec::with_capacity(v1.len() + 1);\n"
"    v2.extend(v1.iter());\n"
"    v2.push(9999);\n"
"    println!(\"v2: len = {}, capacity = {}\", v2.len(), v2.capacity());"
msgstr ""

#: src/std/vec.md:16
msgid ""
"    // Canonical macro to initialize a vector with elements.\n"
"    let mut v3 = vec![0, 0, 1, 2, 3, 4];"
msgstr ""

#: src/std/vec.md:19
msgid ""
"    // Retain only the even elements.\n"
"    v3.retain(|x| x % 2 == 0);\n"
"    println!(\"{v3:?}\");"
msgstr ""

#: src/std/vec.md:23
msgid ""
"    // Remove consecutive duplicates.\n"
"    v3.dedup();\n"
"    println!(\"{v3:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/vec.md:29
#, fuzzy
msgid ""
"`Vec` implements [`Deref<Target = [T]>`][2], which means that you can call "
"slice\n"
"methods on a `Vec`."
msgstr ""
"`Vec` implementuje [`Deref<Target = [T]>`][2], co oznacza, 偶e mo偶esz wywoa "
"slice\n"
"metody na `Vec`."

#: src/std/vec.md:32
#, fuzzy
msgid ""
"[1]: https://doc.rust-lang.org/std/vec/struct.Vec.html\n"
"[2]: https://doc.rust-lang.org/std/vec/struct.Vec.html#deref-methods-[T]"
msgstr ""
"[1]: https://doc.rust-lang.org/std/vec/struct.Vec.html\n"
"[2]: https://doc.rust-lang.org/std/vec/struct.Vec.html#deref-methods-[T]"

#: src/std/vec.md:37
msgid ""
"* `Vec` is a type of collection, along with `String` and `HashMap`. The data "
"it contains is stored\n"
"  on the heap. This means the amount of data doesn't need to be  known at "
"compile time. It can grow\n"
"  or shrink at runtime.\n"
"* Notice how `Vec<T>` is a generic type too, but you don't have to specify "
"`T` explicitly. As always\n"
"  with Rust type inference, the `T` was established during the first `push` "
"call.\n"
"* `vec![...]` is a canonical macro to use instead of `Vec::new()` and it "
"supports adding initial\n"
"  elements to the vector.\n"
"* To index the vector you use `[` `]`, but they will panic if out of bounds. "
"Alternatively, using\n"
"  `get` will return an `Option`. The `pop` function will remove the last "
"element.\n"
"* Show iterating over a vector and mutating the value:\n"
"  `for e in &mut v { *e += 50; }`"
msgstr ""

#: src/std/hashmap.md:1
#, fuzzy
msgid "# `HashMap`"
msgstr "# `HashMap`"

#: src/std/hashmap.md:3
#, fuzzy
msgid "Standard hash map with protection against HashDoS attacks:"
msgstr "Standardowa mapa haszujca z ochron przed atakami HashDoS:"

#: src/std/hashmap.md:5
msgid "```rust,editable\nuse std::collections::HashMap;"
msgstr ""

#: src/std/hashmap.md:8
msgid ""
"fn main() {\n"
"    let mut page_counts = HashMap::new();\n"
"    page_counts.insert(\"Adventures of Huckleberry Finn\".to_string(), "
"207);\n"
"    page_counts.insert(\"Grimms' Fairy Tales\".to_string(), 751);\n"
"    page_counts.insert(\"Pride and Prejudice\".to_string(), 303);"
msgstr ""

#: src/std/hashmap.md:14
msgid ""
"    if !page_counts.contains_key(\"Les Mis茅rables\") {\n"
"        println!(\"We know about {} books, but not Les Mis茅rables.\",\n"
"                 page_counts.len());\n"
"    }"
msgstr ""

#: src/std/hashmap.md:19
#, fuzzy
msgid ""
"    for book in [\"Pride and Prejudice\", \"Alice's Adventure in "
"Wonderland\"] {\n"
"        match page_counts.get(book) {\n"
"            Some(count) => println!(\"{book}: {count} pages\"),\n"
"            None => println!(\"{book} is unknown.\")\n"
"        }\n"
"    }"
msgstr ""
"    za ksi偶k w [\"Duma i uprzedzenie\", \"Alicja w Krainie Czar贸w\"] {\n"
"        dopasuj page_counts.get(book) {\n"
"            Some(count) => println!(\"{ksi偶ka}: {count} stron\"),\n"
"            Brak => println!(\"{ksi偶ka} jest nieznana.\")\n"
"        }\n"
"    }"

#: src/std/hashmap.md:26
msgid ""
"    // Use the .entry() method to insert a value if nothing is found.\n"
"    for book in [\"Pride and Prejudice\", \"Alice's Adventure in "
"Wonderland\"] {\n"
"        let page_count: &mut i32 = "
"page_counts.entry(book.to_string()).or_insert(0);\n"
"        *page_count += 1;\n"
"    }"
msgstr ""

#: src/std/hashmap.md:32
msgid ""
"    println!(\"{page_counts:#?}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/hashmap.md:38
#, fuzzy
msgid ""
"* `HashMap` is not defined in the prelude and needs to be brought into "
"scope.\n"
"* Try the following lines of code. The first line will see if a book is in "
"the hashmap and if not return an alternative value. The second line will "
"insert the alternative value in the hashmap if the book is not found."
msgstr ""
"* `HashMap` nie jest zdefiniowany we wstpie i musi zosta uwzgldniony w "
"zakresie.\n"
"* Wypr贸buj nastpujce wiersze kodu. Pierwsza linia poka偶e, czy ksi偶ka "
"znajduje si w mapie skr贸t贸w, a jeli nie, zwr贸ci warto alternatywn. "
"Drugi wiersz wstawi alternatywn warto do mapy skr贸t贸w, jeli ksi偶ka nie "
"zostanie znaleziona."

#: src/std/hashmap.md:41
msgid ""
"  ```rust,ignore\n"
"  let pc1 = page_counts\n"
"      .get(\"Harry Potter and the Sorcerer's Stone \")\n"
"      .unwrap_or(&336);\n"
"  let pc2 = page_counts\n"
"      .entry(\"The Hunger Games\".to_string())\n"
"      .or_insert(374);\n"
"  ```\n"
"* Unlike `vec!`, there is unfortunately no standard `hashmap!` macro.\n"
"  * Although, since Rust 1.56, HashMap implements [`From<[(K, V); N]>`][1], "
"which allows us to easily initialize a hash map from a literal array:"
msgstr ""

#: src/std/hashmap.md:52
msgid ""
"  ```rust,ignore\n"
"  let page_counts = HashMap::from([\n"
"    (\"Harry Potter and the Sorcerer's Stone\".to_string(), 336),\n"
"    (\"The Hunger Games\".to_string(), 374),\n"
"  ]);\n"
"  ```"
msgstr ""

#: src/std/hashmap.md:59
#, fuzzy
msgid ""
" * Alternatively HashMap can be built from any `Iterator` which yields "
"key-value tuples.\n"
"* We are showing `HashMap<String, i32>`, and avoid using `&str` as key to "
"make examples easier. Using references in collections can, of course, be "
"done,\n"
"  but it can lead into complications with the borrow checker.\n"
"  * Try removing `to_string()` from the example above and see if it still "
"compiles. Where do you think we might run into issues?"
msgstr ""
" * Alternatywnie HashMap mo偶na zbudowa z dowolnego `Iteratora`, kt贸ry daje "
"krotki klucz-warto.\n"
"* Pokazujemy `HashMap<String, i32>` i unikamy u偶ywania `&str` jako klucza, "
"aby uatwi przykady. Korzystanie z referencji w kolekcjach jest oczywicie "
"mo偶liwe,\n"
"  ale mo偶e to prowadzi do komplikacji z sprawdzaniem po偶yczek.\n"
"  * Spr贸buj usun `to_string()` z powy偶szego przykadu i sprawd藕, czy nadal "
"si kompiluje. Jak mylisz, gdzie mo偶emy napotka problemy?"

#: src/std/hashmap.md:64
#, fuzzy
msgid ""
"[1]: "
"https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#impl-From%3C%5B(K%2C%20V)%3B%20N%5D%3E-for-HashMap%3CK%2C%20V%2C%20RandomState%3E"
msgstr ""
"[1]: "
"https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#impl-From%3C%5B(K%2C%20V)%3B%20N%5D%3E "
"-for-HashMap% 3CK% 2C% 20V% 2C% 20Losowy stan% 3E"

#: src/std/box.md:1
#, fuzzy
msgid "# `Box`"
msgstr "# `Pudeko`"

#: src/std/box.md:3
#, fuzzy
msgid "[`Box`][1] is an owned pointer to data on the heap:"
msgstr "[`Box`][1] jest posiadanym wska藕nikiem do danych na stercie:"

#: src/std/box.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let five = Box::new(5);\n"
"    println!(\"five: {}\", *five);\n"
"}\n"
"```"
msgstr ""

#: src/std/box.md:13
msgid ""
"```bob\n"
" Stack                     Heap\n"
".- - - - - - -.     .- - - - - - -.\n"
":             :     :             :\n"
":    five     :     :             :\n"
":   +-----+   :     :   +-----+   :\n"
":   | o---|---+-----+-->|  5  |   :\n"
":   +-----+   :     :   +-----+   :\n"
":             :     :             :\n"
":             :     :             :\n"
"`- - - - - - -'     `- - - - - - -'\n"
"```"
msgstr ""

#: src/std/box.md:26
#, fuzzy
msgid ""
"`Box<T>` implements `Deref<Target = T>`, which means that you can [call "
"methods\n"
"from `T` directly on a `Box<T>`][2]."
msgstr ""
"`Box<T>` implementuje `Deref<Target = T>`, co oznacza, 偶e mo偶esz [wywoywa "
"metody\n"
"z `T` bezporednio na `Box<T>`][2]."

#: src/std/box.md:29
#, fuzzy
msgid ""
"[1]: https://doc.rust-lang.org/std/boxed/struct.Box.html\n"
"[2]: "
"https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion"
msgstr ""
"[1]: https://doc.rust-lang.org/std/boxed/struct.Box.html\n"
"[2]: "
"https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion"

#: src/std/box.md:34
#, fuzzy
msgid ""
"* `Box` is like `std::unique_ptr` in C++, except that it's guaranteed to be "
"not null. \n"
"* In the above example, you can even leave out the `*` in the `println!` "
"statement thanks to `Deref`. \n"
"* A `Box` can be useful when you:\n"
"   * have a type whose size that can't be known at compile time, but the "
"Rust compiler wants to know an exact size.\n"
"   * want to transfer ownership of a large amount of data. To avoid copying "
"large amounts of data on the stack, instead store the data on the heap in a "
"`Box` so only the pointer is moved.\n"
"</details>"
msgstr ""
"* `Box` jest jak `std::unique_ptr` w C++, z t r贸偶nic, 偶e nie jest puste.\n"
"* W powy偶szym przykadzie mo偶esz nawet pomin `*` w instrukcji `println!` "
"dziki `Deref`.\n"
"* Pudeko mo偶e by przydatne, gdy:\n"
"   * mie typ, kt贸rego rozmiar nie mo偶e by znany w czasie kompilacji, ale "
"kompilator Rust chce zna dokadny rozmiar.\n"
"   * chcesz przenie wasno du偶ej iloci danych. Aby unikn kopiowania "
"du偶ych iloci danych na stosie, zamiast tego przechowuj dane na stercie w "
"`Box`, tak aby przesuwany by tylko wska藕nik.\n"
"</details>"

#: src/std/box-recursive.md:1
#, fuzzy
msgid "# Box with Recursive Data Structures"
msgstr "# Pudeko z rekurencyjnymi strukturami danych"

#: src/std/box-recursive.md:3
#, fuzzy
msgid ""
"Recursive data types or data types with dynamic sizes need to use a `Box`:"
msgstr ""
"Rekurencyjne typy danych lub typy danych o dynamicznych rozmiarach musz "
"u偶ywa `Box`:"

#: src/std/box-recursive.md:5 src/std/box-niche.md:3
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"enum List<T> {\n"
"    Cons(T, Box<List<T>>),\n"
"    Nil,\n"
"}"
msgstr ""

#: src/std/box-recursive.md:12 src/std/box-niche.md:10
msgid ""
"fn main() {\n"
"    let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, "
"Box::new(List::Nil))));\n"
"    println!(\"{list:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/box-recursive.md:18
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                         :     :                                            "
"   :\n"
":    list                 :     :                                            "
"   :\n"
":   +------+----+----+    :     :    +------+----+----+    "
"+------+----+----+   :\n"
":   | Cons | 1  | o--+----+-----+--->| Cons | 2  | o--+--->| Nil  | // | // "
"|   :\n"
":   +------+----+----+    :     :    +------+----+----+    "
"+------+----+----+   :\n"
":                         :     :                                            "
"   :\n"
":                         :     :                                            "
"   :\n"
"'- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"
msgstr ""

#: src/std/box-recursive.md:33
#, fuzzy
msgid ""
"* If the `Box` was not used here and we attempted to embed a `List` directly "
"into the `List`,\n"
"the compiler would not compute a fixed size of the struct in memory, it "
"would look infinite."
msgstr ""
"* Jeli `Box` nie zosta tutaj u偶yty i pr贸bowalimy osadzi `List` "
"bezporednio w `List`,\n"
"kompilator nie obliczyby staego rozmiaru struktury w pamici, wygldaby "
"na nieskoczony."

#: src/std/box-recursive.md:36
#, fuzzy
msgid ""
"* `Box` solves this problem as it has the same size as a regular pointer and "
"just points at the next\n"
"element of the `List` in the heap."
msgstr ""
"* `Box` rozwizuje ten problem, poniewa偶 ma taki sam rozmiar jak zwyky "
"wska藕nik i po prostu wskazuje nastpny\n"
"element Listy w stercie."

#: src/std/box-recursive.md:39
#, fuzzy
msgid ""
"* Remove the `Box` in the List definition and show the compiler error. "
"\"Recursive with indirection\" is a hint you might want to use a Box or "
"reference of some kind, instead of storing a value directly.   \n"
"    \n"
"</details>"
msgstr ""
"* Usu `Box` w definicji listy i poka偶 bd kompilatora. Rekurencyjne z "
"kierunkiem to wskaz贸wka, 偶e mo偶esz chcie u偶y pewnego rodzaju pudeka lub "
"odniesienia, zamiast bezporednio przechowywa warto.\n"
"    \n"
"</details>"

#: src/std/box-niche.md:1
#, fuzzy
msgid "# Niche Optimization"
msgstr "# Optymalizacja niszy"

#: src/std/box-niche.md:16
#, fuzzy
msgid ""
"A `Box` cannot be empty, so the pointer is always valid and non-`null`. "
"This\n"
"allows the compiler to optimize the memory layout:"
msgstr ""
"`Box` nie mo偶e by pusty, wic wska藕nik jest zawsze wa偶ny i nie ma wartoci "
"`null`. Ten\n"
"pozwala kompilatorowi zoptymalizowa ukad pamici:"

#: src/std/box-niche.md:19
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - "
"-.\n"
":                         :     :                                            "
" :\n"
":    list                 :     :                                            "
" :\n"
":   +----+----+           :     :    +----+----+    +----+------+            "
" :\n"
":   | 1  | o--+-----------+-----+--->| 2  | o--+--->| // | null |            "
" :\n"
":   +----+----+           :     :    +----+----+    +----+------+            "
" :\n"
":                         :     :                                            "
" :\n"
":                         :     :                                            "
" :\n"
"`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - "
"-'\n"
"```"
msgstr ""

#: src/std/rc.md:1
#, fuzzy
msgid "# `Rc`"
msgstr "# `Rc`"

#: src/std/rc.md:3
#, fuzzy
msgid ""
"[`Rc`][1] is a reference-counted shared pointer. Use this when you need to "
"refer\n"
"to the same data from multiple places:"
msgstr ""
"[`Rc`][1] jest wsp贸dzielonym wska藕nikiem zliczanym przez referencje. U偶yj "
"tego, gdy potrzebujesz si odnie\n"
"do tych samych danych z wielu miejsc:"

#: src/std/rc.md:6
msgid "```rust,editable\nuse std::rc::Rc;"
msgstr ""

#: src/std/rc.md:9
msgid ""
"fn main() {\n"
"    let mut a = Rc::new(10);\n"
"    let mut b = a.clone();"
msgstr ""

#: src/std/rc.md:18
#, fuzzy
msgid ""
"* If you need to mutate the data inside an `Rc`, you will need to wrap the "
"data in\n"
"  a type such as [`Cell` or `RefCell`][2].\n"
"* See [`Arc`][3] if you are in a multi-threaded context.\n"
"* You can *downgrade* a shared pointer into a [`Weak`][4] pointer to create "
"cycles\n"
"  that will get dropped."
msgstr ""
"* Jeli musisz zmutowa dane wewntrz `Rc`, bdziesz musia zawin dane\n"
"  typu takiego jak [`Cell` lub `RefCell`][2].\n"
"* Zobacz [`Arc`][3], jeli pracujesz w kontekcie wielowtkowym.\n"
"* Mo偶esz *zmniejszy* wsp贸dzielony wska藕nik do wska藕nika [`Weak`][4], aby "
"tworzy cykle\n"
"  偶e zostanie upuszczony."

#: src/std/rc.md:24
#, fuzzy
msgid ""
"[1]: https://doc.rust-lang.org/std/rc/struct.Rc.html\n"
"[2]: https://doc.rust-lang.org/std/cell/index.html\n"
"[3]: ../concurrency/shared_state/arc.md\n"
"[4]: https://doc.rust-lang.org/std/rc/struct.Weak.html"
msgstr ""
"[1]: https://doc.rust-lang.org/std/rc/struct.Rc.html\n"
"[2]: https://doc.rust-lang.org/std/cell/index.html\n"
"[3]: ../concurrency/shared_state/arc.md\n"
"[4]: https://doc.rust-lang.org/std/rc/struct.Weak.html"

#: src/std/rc.md:31
#, fuzzy
msgid ""
"* Like C++'s `std::shared_ptr`.\n"
"* `clone` is cheap: creates a pointer to the same allocation and increases "
"the reference count.\n"
"* `make_mut` actually clones the inner value if necessary "
"(\"clone-on-write\") and returns a mutable reference.\n"
"* You can `downgrade()` a `Rc` into a *weakly reference-counted* object to\n"
"  create cycles that will be dropped properly (likely in combination with\n"
"  `RefCell`)."
msgstr ""
"* Podobnie jak `std::shared_ptr` C++.\n"
"* `clone` jest tanie: tworzy wska藕nik do tej samej alokacji i zwiksza "
"liczb odwoa.\n"
"* `make_mut` faktycznie klonuje wewntrzn warto, jeli to konieczne "
"(clone-on-write) i zwraca mutowaln referencj.\n"
"* Mo偶esz `downgrade()` `Rc` do obiektu *sabo zliczanego*, aby\n"
"  tworzy cykle, kt贸re zostan poprawnie upuszczone (prawdopodobnie w "
"poczeniu z\n"
"  `Kom贸rka Ref`)."

#: src/std/rc.md:38
msgid ""
"```rust,editable\n"
"use std::rc::{Rc, Weak};\n"
"use std::cell::RefCell;"
msgstr ""

#: src/std/rc.md:42
msgid ""
"#[derive(Debug)]\n"
"struct Node {\n"
"    value: i64,\n"
"    parent: Option<Weak<RefCell<Node>>>,\n"
"    children: Vec<Rc<RefCell<Node>>>,\n"
"}"
msgstr ""
"#[derive(Debug)]\n"
"struct Node {\n"
"    value: i64,\n"
"    parent: Option<Weak<RefCell<Node>>>,\n"
"    children: Vec<Rc<RefCell<Node>>>,\n"
"}"

#: src/std/rc.md:49
msgid ""
"fn main() {\n"
"    let mut root = Rc::new(RefCell::new(Node {\n"
"        value: 42,\n"
"        parent: None,\n"
"        children: vec![],\n"
"    }));\n"
"    let child = Rc::new(RefCell::new(Node {\n"
"        value: 43,\n"
"        children: vec![],\n"
"        parent: Some(Rc::downgrade(&root))\n"
"    }));\n"
"    root.borrow_mut().children.push(child);"
msgstr ""

#: src/std/rc.md:62
msgid ""
"    println!(\"graph: {root:#?}\");\n"
"}\n"
"```"
msgstr ""

#: src/modules.md:1
#, fuzzy
msgid "# Modules"
msgstr "# Moduy"

#: src/modules.md:3
#, fuzzy
msgid "We have seen how `impl` blocks let us namespace functions to a type."
msgstr ""
"Widzielimy, jak bloki `impl` pozwalaj nam funkcjonowa w przestrzeni nazw "
"dla typu."

#: src/modules.md:5
#, fuzzy
msgid "Similarly, `mod` lets us namespace types and functions:"
msgstr "Podobnie `mod` pozwala nam na typy i funkcje przestrzeni nazw:"

#: src/modules.md:7
msgid ""
"```rust,editable\n"
"mod foo {\n"
"    pub fn do_something() {\n"
"        println!(\"In the foo module\");\n"
"    }\n"
"}"
msgstr ""

#: src/modules.md:14
msgid ""
"mod bar {\n"
"    pub fn do_something() {\n"
"        println!(\"In the bar module\");\n"
"    }\n"
"}"
msgstr ""

#: src/modules.md:20
msgid ""
"fn main() {\n"
"    foo::do_something();\n"
"    bar::do_something();\n"
"}\n"
"```"
msgstr ""

#: src/modules.md:28
#, fuzzy
msgid ""
"* Packages provide functionality and include a `Cargo.toml` file that "
"describes how to build a bundle of 1+ crates.\n"
"* Crates are a tree of modules, where a binary crate creates an executable "
"and a library crate compiles to a library.\n"
"* Modules define organization, scope, and are the focus of this section."
msgstr ""
"* Pakiety zapewniaj funkcjonalno i zawieraj plik `Cargo.toml`, kt贸ry "
"opisuje, jak zbudowa pakiet 1+ skrzynek.\n"
"* Skrzynki to drzewo modu贸w, w kt贸rym binarna skrzynia tworzy plik "
"wykonywalny, a skrzynka biblioteczna kompiluje si do biblioteki.\n"
"* Moduy okrelaj organizacj, zakres i s tematem tej sekcji."

#: src/modules/visibility.md:1
#, fuzzy
msgid "# Visibility"
msgstr "# Widoczno"

#: src/modules/visibility.md:3
#, fuzzy
msgid "Modules are a privacy boundary:"
msgstr "Moduy stanowi granic prywatnoci:"

#: src/modules/visibility.md:5
#, fuzzy
msgid ""
"* Module items are private by default (hides implementation details).\n"
"* Parent and sibling items are always visible.\n"
"* In other words, if an item is visible in module `foo`, it's visible in all "
"the\n"
"  descendants of `foo`."
msgstr ""
"* Elementy moduu s domylnie prywatne (ukrywa szczeg贸y implementacji).\n"
"* Elementy nadrzdne i rodzestwo s zawsze widoczne.\n"
"* Innymi sowy, jeli element jest widoczny w module `foo`, jest widoczny we "
"wszystkich moduach\n"
"  potomkowie `foo`."

#: src/modules/visibility.md:10
msgid ""
"```rust,editable\n"
"mod outer {\n"
"    fn private() {\n"
"        println!(\"outer::private\");\n"
"    }"
msgstr ""

#: src/modules/visibility.md:16
msgid ""
"    pub fn public() {\n"
"        println!(\"outer::public\");\n"
"    }"
msgstr ""

#: src/modules/visibility.md:20
msgid ""
"    mod inner {\n"
"        fn private() {\n"
"            println!(\"outer::inner::private\");\n"
"        }"
msgstr ""

#: src/modules/visibility.md:25
msgid ""
"        pub fn public() {\n"
"            println!(\"outer::inner::public\");\n"
"            super::private();\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: src/modules/visibility.md:32
msgid ""
"fn main() {\n"
"    outer::public();\n"
"}\n"
"```"
msgstr ""

#: src/modules/visibility.md:39
#, fuzzy
msgid "* Use the `pub` keyword to make modules public."
msgstr "* U偶yj sowa kluczowego `pub`, aby upubliczni moduy."

#: src/modules/visibility.md:41
#, fuzzy
msgid ""
"Additionally, there are advanced `pub(...)` specifiers to restrict the scope "
"of public visibility."
msgstr ""
"Dodatkowo istniej zaawansowane specyfikatory `pub(...)` ograniczajce "
"zakres publicznej widocznoci."

#: src/modules/visibility.md:43
#, fuzzy
msgid ""
"* See the [Rust "
"Reference](https://doc.rust-lang.org/reference/visibility-and-privacy.html#pubin-path-pubcrate-pubsuper-and-pubself)).\n"
"* Configuring `pub(crate)` visibility is a common pattern.\n"
"* Less commonly, you can give visibility to a specific path.\n"
"* In any case, visibility must be granted to an ancestor module (and all of "
"its descendants)."
msgstr ""
"* Zobacz [Odniesienie do "
"Rust](https://doc.rust-lang.org/reference/visibility-and-privacy.html#pubin-path-pubcrate-pubsuper-and-pubself)).\n"
"* Konfigurowanie widocznoci `pub(crate)` jest powszechnym wzorcem.\n"
"* Rzadziej mo偶na zapewni widoczno okrelonej cie偶ce.\n"
"* W ka偶dym przypadku widoczno musi by przyznana moduowi przodka (i "
"wszystkim jego potomkom)."

#: src/modules/paths.md:1
#, fuzzy
msgid "# Paths"
msgstr "# cie偶ki"

#: src/modules/paths.md:3
#, fuzzy
msgid "Paths are resolved as follows:"
msgstr "cie偶ki s rozstrzygane w nastpujcy spos贸b:"

#: src/modules/paths.md:5
#, fuzzy
msgid ""
"1. As a relative path:\n"
"   * `foo` or `self::foo` refers to `foo` in the current module,\n"
"   * `super::foo` refers to `foo` in the parent module."
msgstr ""
"1. Jako cie偶ka wzgldna:\n"
"   * `foo` lub `self::foo` odnosi si do `foo` w bie偶cym module,\n"
"   * `super::foo` odnosi si do `foo` w module nadrzdnym."

#: src/modules/paths.md:9
#, fuzzy
msgid ""
"2. As an absolute path:\n"
"   * `crate::foo` refers to `foo` in the root of the current crate,\n"
"   * `bar::foo` refers to `foo` in the `bar` crate."
msgstr ""
"2. Jako cie偶ka bezwzgldna:\n"
"   * `crate::foo` odnosi si do `foo` w katalogu g贸wnym bie偶cej skrzynki,\n"
"   * `bar::foo` odnosi si do `foo` w skrzynce `bar`."

#: src/modules/filesystem.md:1
#, fuzzy
msgid "# Filesystem Hierarchy"
msgstr "# Hierarchia systemu plik贸w"

#: src/modules/filesystem.md:3
#, fuzzy
msgid "The module content can be omitted:"
msgstr "Tre moduu mo偶na pomin:"

#: src/modules/filesystem.md:5
msgid ""
"```rust,editable,compile_fail\n"
"mod garden;\n"
"```"
msgstr ""

#: src/modules/filesystem.md:9
#, fuzzy
msgid "The `garden` module content is found at:"
msgstr "Zawarto moduu `garden` znajduje si pod adresem:"

#: src/modules/filesystem.md:11
#, fuzzy
msgid ""
"* `src/garden.rs` (modern Rust 2018 style)\n"
"* `src/garden/mod.rs` (older Rust 2015 style)"
msgstr ""
"* `src/garden.rs` (nowoczesny styl Rust 2018)\n"
"* `src/garden/mod.rs` (starszy styl Rust 2015)"

#: src/modules/filesystem.md:14
#, fuzzy
msgid "Similarly, a `garden::vegetables` module can be found at:"
msgstr "Podobnie modu `garden::vegetables` mo偶na znale藕 pod adresem:"

#: src/modules/filesystem.md:16
#, fuzzy
msgid ""
"* `src/garden/vegetables.rs` (modern Rust 2018 style)\n"
"* `src/garden/vegetables/mod.rs` (older Rust 2015 style)"
msgstr ""
"* `src/garden/vegetables.rs` (nowoczesny styl Rust 2018)\n"
"* `src/garden/vegetables/mod.rs` (starszy styl Rust 2015)"

#: src/modules/filesystem.md:19
#, fuzzy
msgid "The `crate` root is in:"
msgstr "Korze `crate` znajduje si w:"

#: src/modules/filesystem.md:21
#, fuzzy
msgid ""
"* `src/lib.rs` (for a library crate)\n"
"* `src/main.rs` (for a binary crate)"
msgstr ""
"* `src/lib.rs` (dla skrzynki bibliotecznej)\n"
"* `src/main.rs` (dla skrzynki binarnej)"

#: src/modules/filesystem.md:26
#, fuzzy
msgid ""
"* The change from `module/mod.rs` to `module.rs` doesn't preclude the use of "
"submodules in Rust 2018.\n"
"  (It was mandatory in Rust 2015.)"
msgstr ""
"* Zmiana z `module/mod.rs` na `module.rs` nie wyklucza u偶ycia submodu贸w w "
"Rust 2018.\n"
"  (Byo to obowizkowe w Rust 2015.)"

#: src/modules/filesystem.md:29
#, fuzzy
msgid "  The following is valid:"
msgstr "  Poni偶sze jest wa偶ne:"

#: src/modules/filesystem.md:31
msgid ""
"  ```ignore\n"
"  src/\n"
"   main.rs\n"
"   top_module.rs\n"
"   top_module/\n"
"       sub_module.rs\n"
"  ```"
msgstr ""

#: src/modules/filesystem.md:39
#, fuzzy
msgid ""
"* The main reason for the change is to prevent many files named `mod.rs`, "
"which can be hard\n"
"  to distinguish in IDEs."
msgstr ""
"* G贸wnym powodem zmiany jest uniemo偶liwienie wielu plik贸w o nazwie "
"`mod.rs`, co mo偶e by trudne\n"
"  rozr贸偶nia w IDE."

#: src/modules/filesystem.md:42
#, fuzzy
msgid ""
"* Rust will look for modules in `modulename/mod.rs` and `modulename.rs`, but "
"this can be changed\n"
"  with a compiler directive:"
msgstr ""
"* Rust bdzie szuka modu贸w w `modulename/mod.rs` i `modulename.rs`, ale "
"mo偶na to zmieni\n"
"  z dyrektyw kompilatora:"

#: src/modules/filesystem.md:45
msgid ""
"  ```rust,ignore\n"
"  #[path = \"some/path.rs\"]\n"
"  mod some_module { }\n"
"  ```"
msgstr ""

#: src/modules/filesystem.md:50
#, fuzzy
msgid ""
"  This is useful, for example, if you would like to place tests for a module "
"in a file named\n"
"  `some_module_test.rs`, similar to the convention in Go."
msgstr ""
"  Jest to przydatne na przykad, jeli chcesz umieci testy moduu w pliku "
"o nazwie\n"
"  `some_module_test.rs`, podobnie do konwencji w Go."

#: src/exercises/day-2/afternoon.md:1
#, fuzzy
msgid "# Day 2: Afternoon Exercises"
msgstr "# Dzie 2: wiczenia popoudniowe"

#: src/exercises/day-2/afternoon.md:3
#, fuzzy
msgid "The exercises for this afternoon will focus on strings and iterators."
msgstr "wiczenia na to popoudnie skupi si na cigach znak贸w i iteratorach."

#: src/exercises/day-2/luhn.md:1
#, fuzzy
msgid "# Luhn Algorithm"
msgstr "# Algorytm Luhna"

#: src/exercises/day-2/luhn.md:3
#, fuzzy
msgid ""
"The [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm) is used "
"to\n"
"validate credit card numbers. The algorithm takes a string as input and does "
"the\n"
"following to validate the credit card number:"
msgstr ""
"[Algorytm Luhna](https://en.wikipedia.org/wiki/Luhn_algorithm) su偶y do\n"
"zweryfikowa numery kart kredytowych. Algorytm pobiera cig jako dane "
"wejciowe i wykonuje\n"
"aby zweryfikowa numer karty kredytowej:"

#: src/exercises/day-2/luhn.md:7
#, fuzzy
msgid "* Ignore all spaces. Reject number with less than two digits."
msgstr ""
"* Zignoruj wszystkie spacje. Odrzu numer zawierajcy mniej ni偶 dwie cyfry."

#: src/exercises/day-2/luhn.md:9
#, fuzzy
msgid ""
"* Moving from right to left, double every second digit: for the number "
"`1234`,\n"
"  we double `3` and `1`."
msgstr ""
"* Przechodzc od prawej do lewej, podwajaj co drug cyfr: dla liczby "
"`1234`,\n"
"  podwajamy 3 i 1."

#: src/exercises/day-2/luhn.md:12
#, fuzzy
msgid ""
"* After doubling a digit, sum the digits. So doubling `7` becomes `14` "
"which\n"
"  becomes `5`."
msgstr ""
"* Po podwojeniu cyfry zsumuj cyfry. Wic podwojenie 7 daje 14, co\n"
"  staje si 5."

#: src/exercises/day-2/luhn.md:15
#, fuzzy
msgid "* Sum all the undoubled and doubled digits."
msgstr "* Zsumuj wszystkie niepodwojone i podwojone cyfry."

#: src/exercises/day-2/luhn.md:17
#, fuzzy
msgid "* The credit card number is valid if the sum ends with `0`."
msgstr "* Numer karty kredytowej jest wa偶ny, jeli suma koczy si na `0`."

#: src/exercises/day-2/luhn.md:19
#, fuzzy
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and implement the\n"
"function:"
msgstr ""
"Skopiuj poni偶szy kod do <https://play.rust-lang.org/> i zaimplementuj\n"
"funkcjonowa:"

#: src/exercises/day-2/luhn.md:27
msgid ""
"pub fn luhn(cc_number: &str) -> bool {\n"
"    unimplemented!()\n"
"}"
msgstr ""
"pub fn luhn(cc_number: &str) -> bool {\n"
"    unimplemented!()\n"
"}"

#: src/exercises/day-2/luhn.md:31
msgid ""
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\"));\n"
"}"
msgstr ""

#: src/exercises/day-2/luhn.md:36 src/exercises/day-2/solutions-afternoon.md:64
msgid ""
"#[test]\n"
"fn test_empty_cc_number() {\n"
"    assert!(!luhn(\"\"));\n"
"    assert!(!luhn(\" \"));\n"
"    assert!(!luhn(\"  \"));\n"
"    assert!(!luhn(\"    \"));\n"
"}"
msgstr ""

#: src/exercises/day-2/luhn.md:44 src/exercises/day-2/solutions-afternoon.md:72
msgid ""
"#[test]\n"
"fn test_single_digit_cc_number() {\n"
"    assert!(!luhn(\"0\"));\n"
"}"
msgstr ""

#: src/exercises/day-2/luhn.md:49 src/exercises/day-2/solutions-afternoon.md:77
msgid ""
"#[test]\n"
"fn test_two_digit_cc_number() {\n"
"    assert!(luhn(\" 0 0 \"));\n"
"}"
msgstr ""

#: src/exercises/day-2/luhn.md:54 src/exercises/day-2/solutions-afternoon.md:82
msgid ""
"#[test]\n"
"fn test_valid_cc_number() {\n"
"    assert!(luhn(\"4263 9826 4026 9299\"));\n"
"    assert!(luhn(\"4539 3195 0343 6467\"));\n"
"    assert!(luhn(\"7992 7398 713\"));\n"
"}"
msgstr ""

#: src/exercises/day-2/luhn.md:61
msgid ""
"#[test]\n"
"fn test_invalid_cc_number() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}"
msgstr ""

#: src/exercises/day-2/strings-iterators.md:1
#, fuzzy
msgid "# Strings and Iterators"
msgstr "# acuchy i iteratory"

#: src/exercises/day-2/strings-iterators.md:3
#, fuzzy
msgid ""
"In this exercise, you are implementing a routing component of a web server. "
"The\n"
"server is configured with a number of _path prefixes_ which are matched "
"against\n"
"_request paths_. The path prefixes can contain a wildcard character which\n"
"matches a full segment. See the unit tests below."
msgstr ""
"W tym wiczeniu implementujesz komponent routingu serwera WWW. The\n"
"serwer jest skonfigurowany z liczb _prefiks贸w cie偶ki_, z kt贸rymi s "
"dopasowywane\n"
"_za偶daj cie偶ek_. Prefiksy cie偶ki mog zawiera symbol wieloznaczny, "
"kt贸ry\n"
"pasuje do penego segmentu. Zobacz testy jednostkowe poni偶ej."

#: src/exercises/day-2/strings-iterators.md:8
#, fuzzy
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and make the tests\n"
"pass. Try avoiding allocating a `Vec` for your intermediate results:"
msgstr ""
"Skopiuj poni偶szy kod do <https://play.rust-lang.org/> i wykonaj testy\n"
"przechodzi. Staraj si unika przydzielania `Vec` dla wynik贸w porednich:"

#: src/exercises/day-2/strings-iterators.md:16
msgid ""
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    unimplemented!()\n"
"}"
msgstr ""
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    unimplemented!()\n"
"}"

#: src/exercises/day-2/strings-iterators.md:20
msgid ""
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", "
"\"/v1/publishers/abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", "
"\"/v1/publishers/abc/books\"));"
msgstr ""
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", "
"\"/v1/publishers/abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", "
"\"/v1/publishers/abc/books\"));"

#: src/exercises/day-2/strings-iterators.md:26 src/exercises/day-2/solutions-afternoon.md:146
msgid ""
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/publishersBooks\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", "
"\"/v1/parent/publishers\"));\n"
"}"
msgstr ""
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/publishersBooks\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", "
"\"/v1/parent/publishers\"));\n"
"}"

#: src/exercises/day-2/strings-iterators.md:31 src/exercises/day-2/solutions-afternoon.md:151
msgid ""
"#[test]\n"
"fn test_matches_with_wildcard() {\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/bar/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books/book1\"\n"
"    ));"
msgstr ""
"#[test]\n"
"fn test_matches_with_wildcard() {\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/bar/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books/book1\"\n"
"    ));"

#: src/exercises/day-2/strings-iterators.md:46
msgid ""
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", "
"\"/v1/publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"```"
msgstr ""
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", "
"\"/v1/publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"```"

#: src/welcome-day-3.md:1
msgid "# Welcome to Day 3"
msgstr "# Witamy w dniu 3"

#: src/welcome-day-3.md:3
#, fuzzy
msgid "Today, we will cover some more advanced topics of Rust:"
msgstr ""
"Dzisiaj om贸wimy kilka bardziej zaawansowanych zagadnie zwizanych z Rust:"

#: src/welcome-day-3.md:5
#, fuzzy
msgid ""
"* Traits: deriving traits, default methods, and important standard library\n"
"  traits."
msgstr ""
"* Cechy: wyprowadzanie cech, metody domylne i wa偶na biblioteka standardowa\n"
"  cechy."

#: src/welcome-day-3.md:8
#, fuzzy
msgid ""
"* Generics: generic data types, generic methods, monomorphization, and "
"trait\n"
"  objects."
msgstr ""
"* Rodzaje: og贸lne typy danych, metody og贸lne, monomorfizacja i cecha\n"
"  obiekty."

#: src/welcome-day-3.md:11
#, fuzzy
msgid "* Error handling: panics, `Result`, and the try operator `?`."
msgstr "* Obsuga bd贸w: paniki, `Result` i operator try `?`."

#: src/welcome-day-3.md:13
#, fuzzy
msgid "* Testing: unit tests, documentation tests, and integration tests."
msgstr ""
"* Testowanie: testy jednostkowe, testy dokumentacji i testy integracyjne."

#: src/welcome-day-3.md:15
#, fuzzy
msgid ""
"* Unsafe Rust: raw pointers, static variables, unsafe functions, and extern\n"
"  functions."
msgstr ""
"* Niebezpieczny Rust: surowe wska藕niki, zmienne statyczne, niebezpieczne "
"funkcje i extern\n"
"  Funkcje."

#: src/traits.md:1
#, fuzzy
msgid "# Traits"
msgstr "# Cechy"

#: src/traits.md:3
#, fuzzy
msgid ""
"Rust lets you abstract over types with traits. They're similar to interfaces:"
msgstr ""
"Rust pozwala na abstrakcj nad typami z cechami. S podobne do interfejs贸w:"

#: src/traits.md:5
msgid ""
"```rust,editable\n"
"trait Greet {\n"
"    fn say_hello(&self);\n"
"}"
msgstr ""

#: src/traits.md:10
#, fuzzy
msgid ""
"struct Dog {\n"
"    name: String,\n"
"}"
msgstr ""
"pies konstrukcyjny {\n"
"    imi: Cig,\n"
"}"

#: src/traits.md:14
msgid "struct Cat;  // No name, cats won't respond to it anyway."
msgstr ""

#: src/traits.md:16
msgid ""
"impl Greet for Dog {\n"
"    fn say_hello(&self) {\n"
"        println!(\"Wuf, my name is {}!\", self.name);\n"
"    }\n"
"}"
msgstr ""

#: src/traits.md:22
msgid ""
"impl Greet for Cat {\n"
"    fn say_hello(&self) {\n"
"        println!(\"Miau!\");\n"
"    }\n"
"}"
msgstr ""

#: src/traits.md:28
msgid ""
"fn main() {\n"
"    let pets: Vec<Box<dyn Greet>> = vec![\n"
"        Box::new(Dog { name: String::from(\"Fido\") }),\n"
"        Box::new(Cat),\n"
"    ];\n"
"    for pet in pets {\n"
"        pet.say_hello();\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/traits.md:41
#, fuzzy
msgid ""
"* Traits may specify pre-implemented (default) methods and methods that "
"users are required to implement themselves. Methods with default "
"implementations can rely on required methods.\n"
"* Types that implement a given trait may be of different sizes. This makes "
"it impossible to have things like `Vec<Greet>` in the example above.\n"
"* `dyn Greet` is a way to tell the compiler about a dynamically sized type "
"that implements `Greet`.\n"
"* In the example, `pets` holds Fat Pointers to objects that implement "
"`Greet`. The Fat Pointer consists of two components, a pointer to the actual "
"object and a pointer to the virtual method table for the `Greet` "
"implementation of that particular object."
msgstr ""
"* Cechy mog okrela wstpnie zaimplementowane (domylne) metody i metody, "
"kt贸re u偶ytkownicy musz sami zaimplementowa. Metody z domylnymi "
"implementacjami mog polega na metodach wymaganych.\n"
"* Typy realizujce dan cech mog mie r贸偶ne rozmiary. To sprawia, 偶e "
"niemo偶liwe jest posiadanie rzeczy takich jak `Vec<Greet>` w powy偶szym "
"przykadzie.\n"
"* `dyn Greet` to spos贸b poinformowania kompilatora o typie o dynamicznym "
"rozmiarze, kt贸ry implementuje `Greet`.\n"
"* W przykadzie `pets` przechowuje Fat Pointers do obiekt贸w, kt贸re "
"implementuj `Greet`. Fat Pointer skada si z dw贸ch komponent贸w, wska藕nika "
"do rzeczywistego obiektu i wska藕nika do wirtualnej tabeli metod dla "
"implementacji `Greet` tego konkretnego obiektu."

#: src/traits.md:46
msgid ""
"Compare these outputs in the above example:\n"
"```rust,ignore\n"
"    println!(\"{} {}\", std::mem::size_of::<Dog>(), "
"std::mem::size_of::<Cat>());\n"
"    println!(\"{} {}\", std::mem::size_of::<&Dog>(), "
"std::mem::size_of::<&Cat>());\n"
"    println!(\"{}\", std::mem::size_of::<&dyn Greet>());\n"
"    println!(\"{}\", std::mem::size_of::<Box<dyn Greet>>());\n"
"```"
msgstr ""

#: src/traits/deriving-traits.md:1
#, fuzzy
msgid "# Deriving Traits"
msgstr "# Wyprowadzanie cech"

#: src/traits/deriving-traits.md:3
#, fuzzy
msgid "You can let the compiler derive a number of traits:"
msgstr "Mo偶esz pozwoli kompilatorowi uzyska szereg cech:"

#: src/traits/deriving-traits.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Clone, PartialEq, Eq, Default)]\n"
"struct Player {\n"
"    name: String,\n"
"    strength: u8,\n"
"    hit_points: u8,\n"
"}"
msgstr ""

#: src/traits/deriving-traits.md:13
msgid ""
"fn main() {\n"
"    let p1 = Player::default();\n"
"    let p2 = p1.clone();\n"
"    println!(\"Is {:?}\\n"
"equal to {:?}?\\n"
"The answer is {}!\", &p1, &p2,\n"
"             if p1 == p2 { \"yes\" } else { \"no\" });\n"
"}\n"
"```"
msgstr ""

#: src/traits/default-methods.md:1
#, fuzzy
msgid "# Default Methods"
msgstr "# Metody domylne"

#: src/traits/default-methods.md:3
#, fuzzy
msgid "Traits can implement behavior in terms of other trait methods:"
msgstr "Cechy mog implementowa zachowanie w kategoriach innych metod cech:"

#: src/traits/default-methods.md:5
msgid ""
"```rust,editable\n"
"trait Equals {\n"
"    fn equal(&self, other: &Self) -> bool;\n"
"    fn not_equal(&self, other: &Self) -> bool {\n"
"        !self.equal(other)\n"
"    }\n"
"}"
msgstr ""

#: src/traits/default-methods.md:13
msgid "#[derive(Debug)]\nstruct Centimeter(i16);"
msgstr ""

#: src/traits/default-methods.md:16
#, fuzzy
msgid ""
"impl Equals for Centimeter {\n"
"    fn equal(&self, other: &Centimeter) -> bool {\n"
"        self.0 == other.0\n"
"    }\n"
"}"
msgstr ""
"impl R贸wna si dla centymetra {\n"
"    fn r贸wny(&ja; inny: &Centymetr) -> bool {\n"
"        sam.0 == inny.0\n"
"    }\n"
"}"

#: src/traits/default-methods.md:22
msgid ""
"fn main() {\n"
"    let a = Centimeter(10);\n"
"    let b = Centimeter(20);\n"
"    println!(\"{a:?} equals {b:?}: {}\", a.equal(&b));\n"
"    println!(\"{a:?} not_equals {b:?}: {}\", a.not_equal(&b));\n"
"}\n"
"```"
msgstr ""

#: src/traits/important-traits.md:1
#, fuzzy
msgid "# Important Traits"
msgstr "# Wa偶ne cechy"

#: src/traits/important-traits.md:3
#, fuzzy
msgid ""
"We will now look at some of the most common traits of the Rust standard "
"library:"
msgstr ""
"Przyjrzymy si teraz niekt贸rym z najczstszych cech standardowej biblioteki "
"Rust:"

#: src/traits/important-traits.md:5
#, fuzzy
msgid ""
"* [`Iterator`][1] and [`IntoIterator`][2] used in `for` loops,\n"
"* [`From`][3] and [`Into`][4] used to convert values,\n"
"* [`Read`][5] and [`Write`][6] used for IO,\n"
"* [`Add`][7], [`Mul`][8], ... used for operator overloading, and\n"
"* [`Drop`][9] used for defining destructors.\n"
"* [`Default`][10] used to construct a default instance of a type."
msgstr ""
"* [`Iterator`][1] i [`IntoIterator`][2] u偶ywane w ptlach `for`,\n"
"* [`From`][3] i [`Into`][4] u偶ywane do konwersji wartoci,\n"
"* [`Read`][5] i [`Write`][6] u偶ywane do IO,\n"
"* [`Add`][7], [`Mul`][8], ... u偶ywane do przeci偶ania operatora i\n"
"* [`Drop`][9] u偶ywane do definiowania destruktor贸w.\n"
"* [`Default`][10] u偶ywane do konstruowania domylnej instancji typu."

#: src/traits/important-traits.md:12
#, fuzzy
msgid ""
"[1]: https://doc.rust-lang.org/std/iter/trait.Iterator.html\n"
"[2]: https://doc.rust-lang.org/std/iter/trait.IntoIterator.html\n"
"[3]: https://doc.rust-lang.org/std/convert/trait.From.html\n"
"[4]: https://doc.rust-lang.org/std/convert/trait.Into.html\n"
"[5]: https://doc.rust-lang.org/std/io/trait.Read.html\n"
"[6]: https://doc.rust-lang.org/std/io/trait.Write.html\n"
"[7]: https://doc.rust-lang.org/std/ops/trait.Add.html\n"
"[8]: https://doc.rust-lang.org/std/ops/trait.Mul.html\n"
"[9]: https://doc.rust-lang.org/std/ops/trait.Drop.html\n"
"[10]: https://doc.rust-lang.org/std/default/trait.Default.html"
msgstr ""
"[1]: https://doc.rust-lang.org/std/iter/trait.Iterator.html\n"
"[2]: https://doc.rust-lang.org/std/iter/trait.IntoIterator.html\n"
"[3]: https://doc.rust-lang.org/std/convert/trait.From.html\n"
"[4]: https://doc.rust-lang.org/std/convert/trait.Into.html\n"
"[5]: https://doc.rust-lang.org/std/io/trait.Read.html\n"
"[6]: https://doc.rust-lang.org/std/io/trait.Write.html\n"
"[7]: https://doc.rust-lang.org/std/ops/trait.Add.html\n"
"[8]: https://doc.rust-lang.org/std/ops/trait.Mul.html\n"
"[9]: https://doc.rust-lang.org/std/ops/trait.Drop.html\n"
"[10]: https://doc.rust-lang.org/std/default/trait.Default.html"

#: src/traits/iterator.md:1
#, fuzzy
msgid "# Iterators"
msgstr "# Iteratory"

#: src/traits/iterator.md:3
#, fuzzy
msgid "You can implement the [`Iterator`][1] trait on your own types:"
msgstr "Mo偶esz zaimplementowa cech [`Iterator`][1] na swoich wasnych typach:"

#: src/traits/iterator.md:5
msgid ""
"```rust,editable\n"
"struct Fibonacci {\n"
"    curr: u32,\n"
"    next: u32,\n"
"}"
msgstr ""

#: src/traits/iterator.md:11
msgid "impl Iterator for Fibonacci {\n    type Item = u32;"
msgstr ""

#: src/traits/iterator.md:14
msgid ""
"    fn next(&mut self) -> Option<Self::Item> {\n"
"        let new_next = self.curr + self.next;\n"
"        self.curr = self.next;\n"
"        self.next = new_next;\n"
"        Some(self.curr)\n"
"    }\n"
"}"
msgstr ""

#: src/traits/iterator.md:22
msgid ""
"fn main() {\n"
"    let fib = Fibonacci { curr: 0, next: 1 };\n"
"    for (i, n) in fib.enumerate().take(5) {\n"
"        println!(\"fib({i}): {n}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/traits/iterator.md:32
#, fuzzy
msgid ""
"* `IntoIterator` is the trait that makes for loops work. It is implemented "
"by collection types such as\n"
"  `Vec<T>` and references to them such as `&Vec<T>` and `&[T]`. Ranges also "
"implement it.\n"
"* The `Iterator` trait implements many common functional programming "
"operations over collections \n"
"  (e.g. `map`, `filter`, `reduce`, etc). This is the trait where you can "
"find all the documentation\n"
"  about them. In Rust these functions should produce the code as efficient "
"as equivalent imperative\n"
"  implementations.\n"
"    \n"
"</details>"
msgstr ""
"* `IntoIterator` to cecha, kt贸ra sprawia, 偶e ptle for dziaaj. Jest "
"implementowany przez typy kolekcji, takie jak\n"
"  `Vec<T>` i odniesienia do nich, takie jak `&Vec<T>` i `&[T]`. Realizuj to "
"r贸wnie偶 zakresy.\n"
"* Cecha `Iterator` implementuje wiele typowych operacji programowania "
"funkcyjnego na kolekcjach\n"
"  (np. `mapa`, `filtr`, `zmniejsz` itp.). Jest to cecha, w kt贸rej mo偶na "
"znale藕 ca dokumentacj\n"
"  o nich. W Rust te funkcje powinny generowa kod tak wydajny, jak "
"r贸wnowa偶ny imperatyw\n"
"  wdro偶enia.\n"
"    \n"
"</details>"

#: src/traits/iterator.md:41
#, fuzzy
msgid "[1]: https://doc.rust-lang.org/std/iter/trait.Iterator.html"
msgstr "[1]: https://doc.rust-lang.org/std/iter/trait.Iterator.html"

#: src/traits/from-iterator.md:1
#, fuzzy
msgid "# FromIterator"
msgstr "# Z Iteratora"

#: src/traits/from-iterator.md:3
#, fuzzy
msgid "[`FromIterator`][1] lets you build a collection from an [`Iterator`][2]."
msgstr "[`FromIterator`][1] pozwala zbudowa kolekcj z [`Iterator`][2]."

#: src/traits/from-iterator.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let primes = vec![2, 3, 5, 7];\n"
"    let prime_squares = primes\n"
"        .into_iter()\n"
"        .map(|prime| prime * prime)\n"
"        .collect::<Vec<_>>();\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-iterator.md:17
#, fuzzy
msgid ""
"`Iterator` implements\n"
"`fn collect<B>(self) -> B\n"
"where\n"
"    B: FromIterator<Self::Item>,\n"
"    Self: Sized`"
msgstr ""
"Implementy `Iteratora`\n"
"`fn zbieraj<B>(ja) -> B\n"
"Gdzie\n"
"    B: FromIterator<Self::Item>,\n"
"    Wasny: Wielkoci`"

#: src/traits/from-iterator.md:23
#, fuzzy
msgid ""
"There are also implementations which let you do cool things like convert an\n"
"`Iterator<Item = Result<V, E>>` into a `Result<Vec<V>, E>`."
msgstr ""
"Istniej r贸wnie偶 implementacje, kt贸re pozwalaj robi fajne rzeczy, takie "
"jak konwersja pliku\n"
"`Iterator<Pozycja = Wynik<V, E>>` w `Wynik<Vec<V>, E>`."

#: src/traits/from-iterator.md:28
#, fuzzy
msgid ""
"[1]: https://doc.rust-lang.org/std/iter/trait.FromIterator.html\n"
"[2]: https://doc.rust-lang.org/std/iter/trait.Iterator.html"
msgstr ""
"[1]: https://doc.rust-lang.org/std/iter/trait.FromIterator.html\n"
"[2]: https://doc.rust-lang.org/std/iter/trait.Iterator.html"

#: src/traits/from-into.md:1
#, fuzzy
msgid "# `From` and `Into`"
msgstr "# `Od` i `do`"

#: src/traits/from-into.md:3
#, fuzzy
msgid ""
"Types implement [`From`][1] and [`Into`][2] to facilitate type conversions:"
msgstr ""
"Typy implementuj [`From`][1] i [`Into`][2] w celu uatwienia konwersji "
"typ贸w:"

#: src/traits/from-into.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s = String::from(\"hello\");\n"
"    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);\n"
"    let one = i16::from(true);\n"
"    let bigger = i32::from(123i16);\n"
"    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-into.md:15
#, fuzzy
msgid "[`Into`][2] is automatically implemented when [`From`][1] is implemented:"
msgstr ""
"[`Into`][2] jest automatycznie implementowane po zaimplementowaniu "
"[`From`][1]:"

#: src/traits/from-into.md:17
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s: String = \"hello\".into();\n"
"    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();\n"
"    let one: i16 = true.into();\n"
"    let bigger: i32 = 123i16.into();\n"
"    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-into.md:27
#, fuzzy
msgid ""
"<details>\n"
"  \n"
"* That's why it is common to only implement `From`, as your type will get "
"`Into` implementation too.\n"
"* When declaring a function argument input type like \"anything that can be "
"converted into a `String`\", the rule is opposite, you should use `Into`.\n"
"  Your function will accept types that implement `From` and those that "
"_only_ implement `Into`.\n"
"    \n"
"</details>"
msgstr ""
"<details>\n"
"  \n"
"* Dlatego czsto implementuje si tylko `From`, poniewa偶 tw贸j typ r贸wnie偶 "
"otrzyma implementacj `Into`.\n"
"* Deklarujc typ wejciowy argumentu funkcji, taki jak wszystko, co mo偶na "
"przekonwertowa na `String`, zasada jest odwrotna, nale偶y u偶y `Into`.\n"
"  Twoja funkcja akceptuje typy, kt贸re implementuj `From` i te, kt贸re "
"_tylko_ implementuj `Into`.\n"
"    \n"
"</details>"

#: src/traits/from-into.md:35
#, fuzzy
msgid ""
"[1]: https://doc.rust-lang.org/std/convert/trait.From.html\n"
"[2]: https://doc.rust-lang.org/std/convert/trait.Into.html"
msgstr ""
"[1]: https://doc.rust-lang.org/std/convert/trait.From.html\n"
"[2]: https://doc.rust-lang.org/std/convert/trait.Into.html"

#: src/traits/read-write.md:1
#, fuzzy
msgid "# `Read` and `Write`"
msgstr "# `Odczyt` i `Zapis`"

#: src/traits/read-write.md:3
#, fuzzy
msgid "Using [`Read`][1] and [`BufRead`][2], you can abstract over `u8` sources:"
msgstr "U偶ywajc [`Read`][1] i [`BufRead`][2], mo偶esz wyodrbni 藕r贸da `u8`:"

#: src/traits/read-write.md:5
msgid "```rust,editable\nuse std::io::{BufRead, BufReader, Read, Result};"
msgstr ""

#: src/traits/read-write.md:8
msgid ""
"fn count_lines<R: Read>(reader: R) -> usize {\n"
"    let buf_reader = BufReader::new(reader);\n"
"    buf_reader.lines().count()\n"
"}"
msgstr ""

#: src/traits/read-write.md:13
msgid ""
"fn main() -> Result<()> {\n"
"    let slice: &[u8] = b\"foo\\n"
"bar\\n"
"baz\\n"
"\";\n"
"    println!(\"lines in slice: {}\", count_lines(slice));"
msgstr ""

#: src/traits/read-write.md:17
msgid ""
"    let file = std::fs::File::open(std::env::current_exe()?)?;\n"
"    println!(\"lines in file: {}\", count_lines(file));\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/traits/read-write.md:23
#, fuzzy
msgid "Similarly, [`Write`][3] lets you abstract over `u8` sinks:"
msgstr "Podobnie, [`Write`][3] pozwala na abstrakcj nad ujciami `u8`:"

#: src/traits/read-write.md:25
msgid "```rust,editable\nuse std::io::{Result, Write};"
msgstr ""

#: src/traits/read-write.md:28
msgid ""
"fn log<W: Write>(writer: &mut W, msg: &str) -> Result<()> {\n"
"    writer.write_all(msg.as_bytes())?;\n"
"    writer.write_all(\"\\n"
"\".as_bytes())\n"
"}"
msgstr ""

#: src/traits/read-write.md:33
msgid ""
"fn main() -> Result<()> {\n"
"    let mut buffer = Vec::new();\n"
"    log(&mut buffer, \"Hello\")?;\n"
"    log(&mut buffer, \"World\")?;\n"
"    println!(\"Logged: {:?}\", buffer);\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/traits/read-write.md:42
#, fuzzy
msgid ""
"[1]: https://doc.rust-lang.org/std/io/trait.Read.html\n"
"[2]: https://doc.rust-lang.org/std/io/trait.BufRead.html\n"
"[3]: https://doc.rust-lang.org/std/io/trait.Write.html"
msgstr ""
"[1]: https://doc.rust-lang.org/std/io/trait.Read.html\n"
"[2]: https://doc.rust-lang.org/std/io/trait.BufRead.html\n"
"[3]: https://doc.rust-lang.org/std/io/trait.Write.html"

#: src/traits/operators.md:1
#, fuzzy
msgid "# `Add`, `Mul`, ..."
msgstr "# `Dodaj`, `Mul`, ..."

#: src/traits/operators.md:3
#, fuzzy
msgid "Operator overloading is implemented via traits in [`std::ops`][1]:"
msgstr "Przeci偶anie operatora jest realizowane poprzez cechy w [`std::ops`][1]:"

#: src/traits/operators.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Copy, Clone)]\n"
"struct Point { x: i32, y: i32 }"
msgstr ""

#: src/traits/operators.md:9 src/exercises/day-2/solutions-morning.md:46
msgid "impl std::ops::Add for Point {\n    type Output = Self;"
msgstr ""

#: src/traits/operators.md:12
#, fuzzy
msgid ""
"    fn add(self, other: Self) -> Self {\n"
"        Self {x: self.x + other.x, y: self.y + other.y}\n"
"    }\n"
"}"
msgstr ""
"    fn add(sam, inny: Wasny) -> Wasny {\n"
"        Ja {x: ja.x + inny.x, y: ja.y + inny.y}\n"
"    }\n"
"}"

#: src/traits/operators.md:17
msgid ""
"fn main() {\n"
"    let p1 = Point { x: 10, y: 20 };\n"
"    let p2 = Point { x: 100, y: 200 };\n"
"    println!(\"{:?} + {:?} = {:?}\", p1, p2, p1 + p2);\n"
"}\n"
"```"
msgstr ""

#: src/traits/operators.md:26 src/traits/drop.md:34
#, fuzzy
msgid "Discussion points:"
msgstr "Punkty dyskusji:"

#: src/traits/operators.md:28
#, fuzzy
msgid ""
"* You could implement `Add` for `&Point`. In which situations is that "
"useful? \n"
"    * Answer: `Add:add` consumes `self`. If type `T` for which you are\n"
"        overloading the operator is not `Copy`, you should consider "
"overloading\n"
"        the operator for `&T` as well. This avoids unnecessary cloning on "
"the\n"
"        call site.\n"
"* Why is `Output` an associated type? Could it be made a type parameter?\n"
"    * Short answer: Type parameters are controlled by the caller, but\n"
"        associated types (like `Output`) are controlled by the implementor "
"of a\n"
"        trait."
msgstr ""
"* Mo偶esz zaimplementowa `Add` dla `&Point`. W jakich sytuacjach jest to "
"przydatne?\n"
"    * Odpowied藕: `Add:add` zu偶ywa `self`. Jeli wpisz `T` za kt贸rym jeste\n"
"        przeci偶anie operatora nie jest `Kopiuj`, powiniene rozwa偶y "
"przeci偶anie\n"
"        operator dla `&T` r贸wnie偶. Pozwala to unikn niepotrzebnego "
"klonowania w pliku\n"
"        Zadzwo do serwisu.\n"
"* Dlaczego `Output` jest powizanym typem? Czy mo偶na go ustawi jako "
"parametr typu?\n"
"    * Kr贸tka odpowied藕: Parametry typu s kontrolowane przez dzwonicego, "
"ale\n"
"        powizane typy (takie jak `Output`) s kontrolowane przez "
"implementatora a\n"
"        cecha."

#: src/traits/operators.md:40
#, fuzzy
msgid "[1]: https://doc.rust-lang.org/std/ops/index.html"
msgstr "[1]: https://doc.rust-lang.org/std/ops/index.html"

#: src/traits/drop.md:1
#, fuzzy
msgid "# The `Drop` Trait"
msgstr "# Cecha Upu."

#: src/traits/drop.md:3
#, fuzzy
msgid ""
"Values which implement [`Drop`][1] can specify code to run when they go out "
"of scope:"
msgstr ""
"Wartoci, kt贸re implementuj [`Drop`][1], mog okrela kod do wykonania, "
"gdy wykraczaj poza zakres:"

#: src/traits/drop.md:5
msgid ""
"```rust,editable\n"
"struct Droppable {\n"
"    name: &'static str,\n"
"}"
msgstr ""

#: src/traits/drop.md:10
msgid ""
"impl Drop for Droppable {\n"
"    fn drop(&mut self) {\n"
"        println!(\"Dropping {}\", self.name);\n"
"    }\n"
"}"
msgstr ""

#: src/traits/drop.md:16
msgid ""
"fn main() {\n"
"    let a = Droppable { name: \"a\" };\n"
"    {\n"
"        let b = Droppable { name: \"b\" };\n"
"        {\n"
"            let c = Droppable { name: \"c\" };\n"
"            let d = Droppable { name: \"d\" };\n"
"            println!(\"Exiting block B\");\n"
"        }\n"
"        println!(\"Exiting block A\");\n"
"    }\n"
"    drop(a);\n"
"    println!(\"Exiting main\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/drop.md:36
#, fuzzy
msgid ""
"* Why does not `Drop::drop` take `self`?\n"
"    * Short-answer: If it did, `std::mem::drop` would be called at the end "
"of\n"
"        the block, resulting in another call to `Drop::drop`, and a stack\n"
"        overflow!\n"
"* Try replacing `drop(a)` with `a.drop()`."
msgstr ""
"* Dlaczego `Drop::drop` nie przyjmuje `self`?\n"
"    * Kr贸tka odpowied藕: gdyby tak byo, `std::mem::drop` zostaoby wywoane "
"na kocu\n"
"        blok, co skutkuje kolejnym wywoaniem `Drop::drop` i stosem\n"
"        przelewowy!\n"
"* Spr贸buj zamieni `drop(a)` na `a.drop()`."

#: src/traits/drop.md:44
#, fuzzy
msgid "[1]: https://doc.rust-lang.org/std/ops/trait.Drop.html"
msgstr "[1]: https://doc.rust-lang.org/std/ops/trait.Drop.html"

#: src/traits/default.md:1
#, fuzzy
msgid "# The `Default` Trait"
msgstr "# Cecha Domylna."

#: src/traits/default.md:3
#, fuzzy
msgid "[`Default`][1] trait provides a default implementation of a trait."
msgstr "Cecha [`Default`][1] zapewnia domyln implementacj cechy."

#: src/traits/default.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Default)]\n"
"struct Derived {\n"
"    x: u32,\n"
"    y: String,\n"
"    z: Implemented,\n"
"}"
msgstr ""

#: src/traits/default.md:13
msgid "#[derive(Debug)]\nstruct Implemented(String);"
msgstr ""

#: src/traits/default.md:16
#, fuzzy
msgid ""
"impl Default for Implemented {\n"
"    fn default() -> Self {\n"
"        Self(\"John Smith\".into())\n"
"    }\n"
"}"
msgstr ""
"impl Domylnie dla zaimplementowanych {\n"
"    fn default() -> Wasny {\n"
"        Self(\"Jan Kowalski\".do())\n"
"    }\n"
"}"

#: src/traits/default.md:22
msgid ""
"fn main() {\n"
"    let default_struct: Derived = Default::default();\n"
"    println!(\"{default_struct:#?}\");"
msgstr ""

#: src/traits/default.md:26
msgid ""
"    let almost_default_struct = Derived {\n"
"        y: \"Y is set!\".into(),\n"
"        ..Default::default()\n"
"    };\n"
"    println!(\"{almost_default_struct:#?}\");"
msgstr ""

#: src/traits/default.md:32
msgid ""
"    let nothing: Option<Derived> = None;\n"
"    println!(\"{:#?}\", nothing.unwrap_or_default());\n"
"}"
msgstr ""

#: src/traits/default.md:40
#, fuzzy
msgid ""
"  * It can be implemented directly or it can be derived via "
"`#[derive(Default)]`.\n"
"  * Derived implementation will produce an instance where all fields are set "
"to their default values.\n"
"    * This means all types in the struct must implement `Default` too.\n"
"  * Standard Rust types often implement `Default` with reasonable values "
"(e.g. `0`, `\"\"`, etc).\n"
"  * The partial struct copy works nicely with default.\n"
"  * Rust standard library is aware that types can implement `Default` and "
"provides convenience methods that use it."
msgstr ""
"  * Mo偶e by zaimplementowany bezporednio lub wyprowadzony przez "
"`#[derive(Default)]`.\n"
"  * Implementacja pochodna utworzy instancj, w kt贸rej wszystkie pola "
"zostan ustawione na wartoci domylne.\n"
"    * Oznacza to, 偶e wszystkie typy w strukturze musz r贸wnie偶 implementowa "
"`Default`.\n"
"  * Standardowe typy Rust czsto implementuj `Default` z rozsdnymi "
"wartociami (np. `0`, `\"\"` itp.).\n"
"  * Czciowa kopia struktury dobrze dziaa z ustawieniami domylnymi.\n"
"  * Standardowa biblioteka Rust jest wiadoma, 偶e typy mog implementowa "
"`Default` i zapewnia wygodne metody, kt贸re z niej korzystaj."

#: src/traits/default.md:49
#, fuzzy
msgid "[1]: https://doc.rust-lang.org/std/default/trait.Default.html"
msgstr "[1]: https://doc.rust-lang.org/std/default/trait.Default.html"

#: src/generics.md:1
#, fuzzy
msgid "# Generics"
msgstr "# Generyki"

#: src/generics.md:3
#, fuzzy
msgid ""
"Rust support generics, which lets you abstract an algorithm (such as "
"sorting)\n"
"over the types used in the algorithm."
msgstr ""
"Rust obsuguje typy og贸lne, kt贸re pozwalaj wyodrbni algorytm (taki jak "
"sortowanie)\n"
"nad typami u偶ywanymi w algorytmie."

#: src/generics/data-types.md:1
#, fuzzy
msgid "# Generic Data Types"
msgstr "# Og贸lne typy danych"

#: src/generics/data-types.md:3
#, fuzzy
msgid "You can use generics to abstract over the concrete field type:"
msgstr "Mo偶esz u偶y generycznych do abstrakcji nad konkretnym typem pola:"

#: src/generics/data-types.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point<T> {\n"
"    x: T,\n"
"    y: T,\n"
"}"
msgstr ""

#: src/generics/data-types.md:12
msgid ""
"fn main() {\n"
"    let integer = Point { x: 5, y: 10 };\n"
"    let float = Point { x: 1.0, y: 4.0 };\n"
"    println!(\"{integer:?} and {float:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/generics/methods.md:1
#, fuzzy
msgid "# Generic Methods"
msgstr "# Og贸lne metody"

#: src/generics/methods.md:3
#, fuzzy
msgid "You can declare a generic type on your `impl` block:"
msgstr "Mo偶esz zadeklarowa typ og贸lny w swoim bloku `impl`:"

#: src/generics/methods.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point<T>(T, T);"
msgstr ""

#: src/generics/methods.md:9
#, fuzzy
msgid ""
"impl<T> Point<T> {\n"
"    fn x(&self) -> &T {\n"
"        &self.0  // + 10\n"
"    }"
msgstr ""
"impl<T> Punkt<T> {\n"
"    fn x(&ja) -> &T {\n"
"        &sobie.0 // + 10\n"
"    }"

#: src/generics/methods.md:14
#, fuzzy
msgid "    // fn set_x(&mut self, x: T)\n}"
msgstr "    // fn set_x(&mut self, x: T)\n}"

#: src/generics/methods.md:17
msgid ""
"fn main() {\n"
"    let p = Point(5, 10);\n"
"    println!(\"p.x = {}\", p.x());\n"
"}\n"
"```"
msgstr ""

#: src/generics/methods.md:25
#, fuzzy
msgid ""
"* *Q:* Why `T` is specified twice in `impl<T> Point<T> {}`? Isn't that "
"redundant?\n"
"    * This is because it is a generic implementation section for generic "
"type. They are independently generic.\n"
"    * It means these methods are defined for any `T`.\n"
"    * It is possible to write `impl Point<u32> { .. }`. \n"
"      * `Point` is still generic and you can use `Point<f64>`, but methods "
"in this block will only be available for `Point<u32>`."
msgstr ""
"* *P:* Dlaczego `T` jest okrelone dwukrotnie w `impl<T> Point<T> {}`? Czy "
"to nie jest zbdne?\n"
"    * Dzieje si tak, poniewa偶 jest to og贸lna sekcja implementacji dla typu "
"og贸lnego. S niezale偶nie og贸lne.\n"
"    * Oznacza to, 偶e te metody s zdefiniowane dla dowolnego `T`.\n"
"    * Mo偶na napisa `impl Point<u32> { .. }`.\n"
"      * `Point` jest nadal og贸lny i mo偶esz u偶y `Point<f64>`, ale metody w "
"tym bloku bd dostpne tylko dla `Point<u32>`."

#: src/generics/trait-bounds.md:1
#, fuzzy
msgid "# Trait Bounds"
msgstr "# Granice cech"

#: src/generics/trait-bounds.md:3
#, fuzzy
msgid ""
"When working with generics, you often want to require the types to "
"implement\n"
"some trait, so that you can call this trait's methods."
msgstr ""
"Podczas pracy z typami og贸lnymi czsto chcesz wymaga implementacji typ贸w\n"
"jak cech, aby mo偶na byo wywoa metody tej cechy."

#: src/generics/trait-bounds.md:6
#, fuzzy
msgid "You can do this with `T: Trait` or `impl Trait`:"
msgstr "Mo偶esz to zrobi za pomoc `T: Cecha` lub `impl Cecha`:"

#: src/generics/trait-bounds.md:8
msgid ""
"```rust,editable\n"
"fn duplicate<T: Clone>(a: T) -> (T, T) {\n"
"    (a.clone(), a.clone())\n"
"}"
msgstr ""

#: src/generics/trait-bounds.md:13
#, fuzzy
msgid ""
"// Syntactic sugar for:\n"
"//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"
"fn add_42_millions(x: impl Into<i32>) -> i32 {\n"
"    x.into() + 42_000_000\n"
"}"
msgstr ""
"// Cukier syntaktyczny do:\n"
"// fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"
"fn add_42_milions(x: impl Into<i32>) -> i32 {\n"
"    x.do() + 42_000_000\n"
"}"

#: src/generics/trait-bounds.md:19
msgid "// struct NotClonable;"
msgstr ""

#: src/generics/trait-bounds.md:21
msgid ""
"fn main() {\n"
"    let foo = String::from(\"foo\");\n"
"    let pair = duplicate(foo);\n"
"    println!(\"{pair:?}\");"
msgstr ""

#: src/generics/trait-bounds.md:26
msgid ""
"    let many = add_42_millions(42_i8);\n"
"    println!(\"{many}\");\n"
"    let many_more = add_42_millions(10_000_000);\n"
"    println!(\"{many_more}\");\n"
"}\n"
"```"
msgstr ""

#: src/generics/trait-bounds.md:35
msgid ""
"Show a `where` clause, students will encounter it when reading code.\n"
"    \n"
"```rust,ignore\n"
"fn duplicate<T>(a: T) -> (T, T)\n"
"where\n"
"    T: Clone,\n"
"{\n"
"    (a.clone(), a.clone())\n"
"}\n"
"```"
msgstr ""

#: src/generics/trait-bounds.md:46
#, fuzzy
msgid ""
"* It declutters the function signature if you have many parameters.\n"
"* It has additional features making it more powerful.\n"
"    * If someone asks, the extra feature is that the type on the left of "
"\":\" can be arbitrary, like `Option<T>`.\n"
"    \n"
"</details>"
msgstr ""
"* Odczytuje sygnatur funkcji, jeli masz wiele parametr贸w.\n"
"* Posiada dodatkowe funkcje, dziki kt贸rym jest pot偶niejszy.\n"
"    * Jeli kto zapyta, dodatkow cech jest to, 偶e typ po lewej stronie "
": mo偶e by dowolny, na przykad `Option<T>`.\n"
"    \n"
"</details>"

#: src/generics/impl-trait.md:1
#, fuzzy
msgid "# `impl Trait`"
msgstr "# `impl Cecha`"

#: src/generics/impl-trait.md:3
#, fuzzy
msgid ""
"Similar to trait bounds, an `impl Trait` syntax can be used in function\n"
"arguments and return values:"
msgstr ""
"Podobnie jak w przypadku granic cech, skadnia `impl Trait` mo偶e by u偶ywana "
"w funkcji\n"
"argumenty i zwracane wartoci:"

#: src/generics/impl-trait.md:6 src/generics/trait-objects.md:5 src/generics/trait-objects.md:28
msgid "```rust,editable\nuse std::fmt::Display;"
msgstr ""

#: src/generics/impl-trait.md:9
#, fuzzy
msgid ""
"fn get_x(name: impl Display) -> impl Display {\n"
"    format!(\"Hello {name}\")\n"
"}"
msgstr ""
"fn get_x(nazwa: impl Wywietl) -> impl Wywietl {\n"
"    format!(\"Witaj {imi}\")\n"
"}"

#: src/generics/impl-trait.md:13
msgid ""
"fn main() {\n"
"    let x = get_x(\"foo\");\n"
"    println!(\"{x}\");\n"
"}\n"
"```"
msgstr ""

#: src/generics/impl-trait.md:19
#, fuzzy
msgid ""
"* `impl Trait` cannot be used with the `::<>` turbo fish syntax.\n"
"* `impl Trait` allows you to work with types which you cannot name."
msgstr ""
"* `impl Trait` nie mo偶e by u偶ywany ze skadni `::<>` turbofish.\n"
"* `impl Trait` umo偶liwia prac z typami, kt贸rych nie mo偶na nazwa."

#: src/generics/impl-trait.md:24
#, fuzzy
msgid ""
"The meaning of `impl Trait` is a bit different in the different positions."
msgstr "Znaczenie impl Cecha jest nieco inne w r贸偶nych pozycjach."

#: src/generics/impl-trait.md:26
#, fuzzy
msgid ""
"* For a parameter, `impl Trait` is like an anonymous generic parameter with "
"a trait bound.\n"
"* For a return type, it means that the return type is some concrete type "
"that implements the trait,\n"
"  without naming the type. This can be useful when you don't want to expose "
"the concrete type in a\n"
"  public API."
msgstr ""
"* W przypadku parametru impl Trait jest jak anonimowy parametr og贸lny z "
"powizaniem z cech.\n"
"* W przypadku typu zwracanego oznacza to, 偶e typ zwracany jest jakim "
"konkretnym typem, kt贸ry implementuje cech,\n"
"  bez okrelania rodzaju. Mo偶e to by przydatne, gdy nie chcesz ujawnia "
"konkretnego typu w pliku\n"
"  publiczne API."

#: src/generics/impl-trait.md:31
#, fuzzy
msgid ""
"This example is great, because it uses `impl Display` twice. It helps to "
"explain that\n"
"nothing here enforces that it is _the same_ `impl Display` type. If we used "
"a single \n"
"`T: Display`, it would enforce the constraint that input `T` and return `T` "
"type are the same type.\n"
"It would not work for this particular function, as the type we expect as "
"input is likely not\n"
"what `format!` returns. If we wanted to do the same via `: Display` syntax, "
"we'd need two\n"
"independent generic parameters.\n"
"    \n"
"</details>"
msgstr ""
"Ten przykad jest wietny, poniewa偶 dwukrotnie u偶ywa `impl Display`. Pomaga "
"to wyjani\n"
"nic tutaj nie wymusza, 偶e jest to _ten sam_ typ `impl Display`. Gdybymy "
"u偶yli jednego\n"
"`T: Display`, wymuszaoby ograniczenie, 偶e wejcie `T` i zwracany typ `T` s "
"tego samego typu.\n"
"Nie zadziaaoby to dla tej konkretnej funkcji, poniewa偶 typ, kt贸rego "
"oczekujemy jako dane wejciowe, prawdopodobnie nie\n"
"co zwraca `format!`. Gdybymy chcieli zrobi to samo za pomoc skadni `: "
"Display`, potrzebowalibymy dw贸ch\n"
"niezale偶ne parametry og贸lne.\n"
"    \n"
"</details>"

#: src/generics/closures.md:1
#, fuzzy
msgid "# Closures"
msgstr "# Domknicia"

#: src/generics/closures.md:3
#, fuzzy
msgid ""
"Closures or lambda expressions have types which cannot be named. However, "
"they\n"
"implement special [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html),\n"
"[`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), and\n"
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) traits:"
msgstr ""
"Domknicia lub wyra偶enia lambda maj typy, kt贸rych nie mo偶na nazwa. Jednak "
"oni\n"
"zaimplementowa specjalne "
"[`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html),\n"
"[`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html) oraz\n"
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) cechy:"

#: src/generics/closures.md:8
msgid ""
"```rust,editable\n"
"fn apply_with_log(func: impl FnOnce(i32) -> i32, input: i32) -> i32 {\n"
"    println!(\"Calling function on {input}\");\n"
"    func(input)\n"
"}"
msgstr ""

#: src/generics/closures.md:14
msgid ""
"fn main() {\n"
"    let add_3 = |x| x + 3;\n"
"    let mul_5 = |x| x * 5;"
msgstr ""

#: src/generics/closures.md:18
msgid ""
"    println!(\"add_3: {}\", apply_with_log(add_3, 10));\n"
"    println!(\"mul_5: {}\", apply_with_log(mul_5, 20));\n"
"}\n"
"```"
msgstr ""

#: src/generics/closures.md:25
#, fuzzy
msgid ""
"If you have an `FnOnce`, you may only call it once. It might consume "
"captured values."
msgstr ""
"Jeli masz `FnOnce`, mo偶esz wywoa go tylko raz. Mo偶e zu偶ywa przechwycone "
"wartoci."

#: src/generics/closures.md:27
#, fuzzy
msgid ""
"An `FnMut` might mutate captured values, so you can call it multiple times "
"but not concurrently."
msgstr ""
"`FnMut` mo偶e zmutowa przechwycone wartoci, wic mo偶esz go wywoywa wiele "
"razy, ale nie jednoczenie."

#: src/generics/closures.md:29
#, fuzzy
msgid ""
"An `Fn` neither consumes nor mutates captured values, or perhaps captures "
"nothing at all, so it can\n"
"be called multiple times concurrently."
msgstr ""
"`Fn` ani nie konsumuje, ani nie mutuje przechwyconych wartoci, a by mo偶e w "
"og贸le nie przechwytuje niczego, wic mo偶e\n"
"by wywoywane wiele razy jednoczenie."

#: src/generics/closures.md:32
#, fuzzy
msgid ""
"`FnMut` is a subtype of `FnOnce`. `Fn` is a subtype of `FnMut` and `FnOnce`. "
"I.e. you can use an\n"
"`FnMut` wherever an `FnOnce` is called for, and you can use an `Fn` wherever "
"an `FnMut` or `FnOnce`\n"
"is called for."
msgstr ""
"`FnMut` jest podtypem `FnOnce`. `Fn` jest podtypem `FnMut` i `FnOnce`. Tj. "
"mo偶esz u偶y\n"
"`FnMut` wszdzie tam, gdzie wymagane jest `FnOnce`, a `Fn` mo偶na u偶y "
"wszdzie tam, gdzie `FnMut` lub `FnOnce`\n"
"jest wezwany."

#: src/generics/closures.md:36
#, fuzzy
msgid "`move` closures only implement `FnOnce`."
msgstr "Zamknicia `move` implementuj tylko `FnOnce`."

#: src/generics/monomorphization.md:1
#, fuzzy
msgid "# Monomorphization"
msgstr "# Monomorfizacja"

#: src/generics/monomorphization.md:3
#, fuzzy
msgid "Generic code is turned into non-generic code based on the call sites:"
msgstr ""
"Kod og贸lny jest przeksztacany w kod nierodzajowy na podstawie witryn "
"wywoujcych:"

#: src/generics/monomorphization.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let integer = Some(5);\n"
"    let float = Some(5.0);\n"
"}\n"
"```"
msgstr ""

#: src/generics/monomorphization.md:12
#, fuzzy
msgid "behaves as if you wrote"
msgstr "zachowuje si tak, jakby napisa"

#: src/generics/monomorphization.md:14
msgid ""
"```rust,editable\n"
"enum Option_i32 {\n"
"    Some(i32),\n"
"    None,\n"
"}"
msgstr ""

#: src/generics/monomorphization.md:20
#, fuzzy
msgid ""
"enum Option_f64 {\n"
"    Some(f64),\n"
"    None,\n"
"}"
msgstr ""
"wyliczenie Option_f64 {\n"
"    Niekt贸re (f64),\n"
"    Nic,\n"
"}"

#: src/generics/monomorphization.md:25
msgid ""
"fn main() {\n"
"    let integer = Option_i32::Some(5);\n"
"    let float = Option_f64::Some(5.0);\n"
"}\n"
"```"
msgstr ""

#: src/generics/monomorphization.md:31
#, fuzzy
msgid ""
"This is a zero-cost abstraction: you get exactly the same result as if you "
"had\n"
"hand-coded the data structures without the abstraction."
msgstr ""
"Jest to abstrakcja o zerowych kosztach: otrzymujesz dokadnie taki sam "
"wynik, jakby mia\n"
"rcznie zakodowa struktury danych bez abstrakcji."

#: src/generics/trait-objects.md:1
#, fuzzy
msgid "# Trait Objects"
msgstr "# Obiekty cech"

#: src/generics/trait-objects.md:3
#, fuzzy
msgid "We've seen how a function can take arguments which implement a trait:"
msgstr ""
"Widzielimy, jak funkcja mo偶e przyjmowa argumenty, kt贸re implementuj cech:"

#: src/generics/trait-objects.md:8
msgid ""
"fn print<T: Display>(x: T) {\n"
"    println!(\"Your value: {x}\");\n"
"}"
msgstr ""

#: src/generics/trait-objects.md:12
msgid ""
"fn main() {\n"
"    print(123);\n"
"    print(\"Hello\");\n"
"}\n"
"```"
msgstr ""

#: src/generics/trait-objects.md:18
#, fuzzy
msgid ""
"However, how can we store a collection of mixed types which implement "
"`Display`?"
msgstr ""
"Jak jednak mo偶emy przechowywa kolekcj typ贸w mieszanych, kt贸re implementuj "
"`Display`?"

#: src/generics/trait-objects.md:20
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let xs = vec![123, \"Hello\"];\n"
"}\n"
"```"
msgstr ""

#: src/generics/trait-objects.md:26
#, fuzzy
msgid "For this, we need _trait objects_:"
msgstr "W tym celu potrzebujemy _obiekt贸w cech_:"

#: src/generics/trait-objects.md:31
msgid ""
"fn main() {\n"
"    let xs: Vec<Box<dyn Display>> = vec![Box::new(123), "
"Box::new(\"Hello\")];\n"
"    for x in xs {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/generics/trait-objects.md:39
#, fuzzy
msgid "Memory layout after allocating `xs`:"
msgstr "Ukad pamici po przydzieleniu `xs`:"

#: src/generics/trait-objects.md:41
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - "
"- - -.\n"
":                           :     :                                          "
"     :\n"
":    xs                     :     :                                          "
"     :\n"
":   +-----------+-------+   :     :   +-----+-----+                          "
"     :\n"
":   | ptr       |   o---+---+-----+-->| o o | o o |                          "
"     :\n"
":   | len       |     2 |   :     :   +-|-|-+-|-|-+                          "
"     :\n"
":   | capacity  |     2 |   :     :     | |   | |   "
"+----+----+----+----+----+    :\n"
":   +-----------+-------+   :     :     | |   | '-->| H  | e  | l  | l  | o  "
"|    :\n"
":                           :     :     | |   |     "
"+----+----+----+----+----+    :\n"
"`- - - - - - - - - - - - - -'     :     | |   |                              "
"     :\n"
"                                  :     | |   |     "
"+-------------------------+   :\n"
"                                  :     | |   '---->| \"<str as "
"Display>::fmt\" |   :\n"
"                                  :     | |         "
"+-------------------------+   :\n"
"                                  :     | |                                  "
"     :\n"
"                                  :     | |   +----+----+----+----+          "
"     :\n"
"                                  :     | '-->| 7b | 00 | 00 | 00 |          "
"     :\n"
"                                  :     |     +----+----+----+----+          "
"     :\n"
"                                  :     |                                    "
"     :\n"
"                                  :     |     +-------------------------+    "
"     :\n"
"                                  :     '---->| \"<i32 as Display>::fmt\" |  "
"       :\n"
"                                  :           +-------------------------+    "
"     :\n"
"                                  :                                          "
"     :\n"
"                                  :                                          "
"     :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - "
"- - -'\n"
"```"
msgstr ""

#: src/generics/trait-objects.md:69
#, fuzzy
msgid ""
"Similarly, you need a trait object if you want to return different types\n"
"implementing a trait:"
msgstr ""
"Podobnie potrzebujesz obiektu cechy, jeli chcesz zwr贸ci r贸偶ne typy\n"
"wdro偶enie cechy:"

#: src/generics/trait-objects.md:72
msgid ""
"```rust,editable\n"
"fn numbers(n: i32) -> Box<dyn Iterator<Item=i32>> {\n"
"    if n > 0 {\n"
"        Box::new(0..n)\n"
"    } else {\n"
"        Box::new((n..0).rev())\n"
"    }\n"
"}"
msgstr ""

#: src/generics/trait-objects.md:81
msgid ""
"fn main() {\n"
"    println!(\"{:?}\", numbers(-5).collect::<Vec<_>>());\n"
"    println!(\"{:?}\", numbers(5).collect::<Vec<_>>());\n"
"}"
msgstr ""

#: src/exercises/day-3/morning.md:1
#, fuzzy
msgid "# Day 3: Morning Exercises"
msgstr "# Dzie 3: wiczenia poranne"

#: src/exercises/day-3/morning.md:3
#, fuzzy
msgid "We will design a classical GUI library traits and trait objects."
msgstr "Zaprojektujemy klasyczn bibliotek GUI cech i obiekt贸w cech."

#: src/exercises/day-3/simple-gui.md:1
#, fuzzy
msgid "# A Simple GUI Library"
msgstr "# Prosta biblioteka GUI"

#: src/exercises/day-3/simple-gui.md:3
#, fuzzy
msgid ""
"Let us design a classical GUI library using our new knowledge of traits and\n"
"trait objects."
msgstr ""
"Zaprojektujmy klasyczn bibliotek GUI, korzystajc z naszej nowej wiedzy na "
"temat cech i\n"
"obiekty cech."

#: src/exercises/day-3/simple-gui.md:6
#, fuzzy
msgid "We will have a number of widgets in our library:"
msgstr "W naszej bibliotece bdziemy mie kilka wid偶et贸w:"

#: src/exercises/day-3/simple-gui.md:8
#, fuzzy
msgid ""
"* `Window`: has a `title` and contains other widgets.\n"
"* `Button`: has a `label` and a callback function which is invoked when the\n"
"  button is pressed.\n"
"* `Label`: has a `label`."
msgstr ""
"* `Okno`: ma `tytu` i zawiera inne wid偶ety.\n"
"* `Button`: ma `etykiet` i funkcj wywoania zwrotnego, kt贸ra jest "
"wywoywana, gdy\n"
"  przycisk jest wcinity.\n"
"* `Etykieta`: ma `etykiet`."

#: src/exercises/day-3/simple-gui.md:13
#, fuzzy
msgid "The widgets will implement a `Widget` trait, see below."
msgstr "Wid偶ety zaimplementuj cech `Widget`, patrz poni偶ej."

#: src/exercises/day-3/simple-gui.md:15
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/>, fill in the missing\n"
"`draw_into` methods so that you implement the `Widget` trait:"
msgstr ""
"Skopiuj poni偶szy kod na <https://play.rust-lang.org/>, uzupenij brakujce\n"
"metody `draw_into`, aby zaimplementowa cech `Widget`:"

#: src/exercises/day-3/simple-gui.md:18 src/exercises/day-3/safe-ffi-wrapper.md:25
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_imports, unused_variables, dead_code)]"
msgstr ""
"```rust,should_panic\n"
"// TODO: usu to jak skoczysz implementacj.\n"
"#![allow(unused_imports, unused_variables, dead_code)]"

#: src/exercises/day-3/simple-gui.md:22
msgid ""
"pub trait Widget {\n"
"    /// Natural width of `self`.\n"
"    fn width(&self) -> usize;"
msgstr ""
"pub trait Widget {\n"
"    /// Naturalna szeroko `self`.\n"
"    fn width(&self) -> usize;"

#: src/exercises/day-3/simple-gui.md:26 src/exercises/day-3/solutions-morning.md:27
msgid ""
"    /// Draw the widget into a buffer.\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);"
msgstr ""
"    /// Narysuj widget w buforze.\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);"

#: src/exercises/day-3/simple-gui.md:29 src/exercises/day-3/solutions-morning.md:30
msgid ""
"    /// Draw the widget on standard output.\n"
"    fn draw(&self) {\n"
"        let mut buffer = String::new();\n"
"        self.draw_into(&mut buffer);\n"
"        println!(\"{buffer}\");\n"
"    }\n"
"}"
msgstr ""
"    /// Narysuj widget na standardowym wyjciu.\n"
"    fn draw(&self) {\n"
"        let mut buffer = String::new();\n"
"        self.draw_into(&mut buffer);\n"
"        println!(\"{buffer}\");\n"
"    }\n"
"}"

#: src/exercises/day-3/simple-gui.md:37 src/exercises/day-3/solutions-morning.md:38
msgid ""
"pub struct Label {\n"
"    label: String,\n"
"}"
msgstr ""
"pub struct Label {\n"
"    label: String,\n"
"}"

#: src/exercises/day-3/simple-gui.md:41 src/exercises/day-3/solutions-morning.md:42
msgid ""
"impl Label {\n"
"    fn new(label: &str) -> Label {\n"
"        Label {\n"
"            label: label.to_owned(),\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"impl Label {\n"
"    fn new(label: &str) -> Label {\n"
"        Label {\n"
"            label: label.to_owned(),\n"
"        }\n"
"    }\n"
"}"

#: src/exercises/day-3/simple-gui.md:49 src/exercises/day-3/solutions-morning.md:50
msgid ""
"pub struct Button {\n"
"    label: Label,\n"
"    callback: Box<dyn FnMut()>,\n"
"}"
msgstr ""
"pub struct Button {\n"
"    label: Label,\n"
"    callback: Box<dyn FnMut()>,\n"
"}"

#: src/exercises/day-3/simple-gui.md:54 src/exercises/day-3/solutions-morning.md:55
msgid ""
"impl Button {\n"
"    fn new(label: &str, callback: Box<dyn FnMut()>) -> Button {\n"
"        Button {\n"
"            label: Label::new(label),\n"
"            callback,\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"impl Button {\n"
"    fn new(label: &str, callback: Box<dyn FnMut()>) -> Button {\n"
"        Button {\n"
"            label: Label::new(label),\n"
"            callback,\n"
"        }\n"
"    }\n"
"}"

#: src/exercises/day-3/simple-gui.md:63 src/exercises/day-3/solutions-morning.md:64
msgid ""
"pub struct Window {\n"
"    title: String,\n"
"    widgets: Vec<Box<dyn Widget>>,\n"
"}"
msgstr ""
"pub struct Window {\n"
"    title: String,\n"
"    widgets: Vec<Box<dyn Widget>>,\n"
"}"

#: src/exercises/day-3/simple-gui.md:68 src/exercises/day-3/solutions-morning.md:69
msgid ""
"impl Window {\n"
"    fn new(title: &str) -> Window {\n"
"        Window {\n"
"            title: title.to_owned(),\n"
"            widgets: Vec::new(),\n"
"        }\n"
"    }"
msgstr ""
"impl Window {\n"
"    fn new(title: &str) -> Window {\n"
"        Window {\n"
"            title: title.to_owned(),\n"
"            widgets: Vec::new(),\n"
"        }\n"
"    }"

#: src/exercises/day-3/simple-gui.md:76 src/exercises/day-3/solutions-morning.md:77
msgid ""
"    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
"        self.widgets.push(widget);\n"
"    }\n"
"}"
msgstr ""
"    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
"        self.widgets.push(widget);\n"
"    }\n"
"}"

#: src/exercises/day-3/simple-gui.md:82
msgid ""
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }"

#: src/exercises/day-3/simple-gui.md:87 src/exercises/day-3/simple-gui.md:97
#: src/exercises/day-3/simple-gui.md:107
msgid ""
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        unimplemented!()\n"
"    }\n"
"}"
msgstr ""
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        unimplemented!()\n"
"    }\n"
"}"

#: src/exercises/day-3/simple-gui.md:92
msgid ""
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }"

#: src/exercises/day-3/simple-gui.md:102
msgid ""
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }"

#: src/exercises/day-3/simple-gui.md:112
msgid ""
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"This is a small text GUI "
"demo.\")));\n"
"    window.add_widget(Box::new(Button::new(\n"
"        \"Click me!\",\n"
"        Box::new(|| println!(\"You clicked the button!\")),\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-3/simple-gui.md:123
#, fuzzy
msgid "The output of the above program can be something simple like this:"
msgstr "Wyjcie powy偶szego programu mo偶e by czym prostym, takim jak to:"

#: src/exercises/day-3/simple-gui.md:125
msgid ""
"```text\n"
"========\n"
"Rust GUI Demo 1.23\n"
"========"
msgstr ""

#: src/exercises/day-3/simple-gui.md:130
#, fuzzy
msgid "This is a small text GUI demo."
msgstr "To jest maa tekstowa demonstracja GUI."

#: src/exercises/day-3/simple-gui.md:132
msgid "| Click me! |\n```"
msgstr ""

#: src/exercises/day-3/simple-gui.md:135
#, fuzzy
msgid ""
"If you want to draw aligned text, you can use the\n"
"[fill/alignment](https://doc.rust-lang.org/std/fmt/index.html#fillalignment)\n"
"formatting operators. In particular, notice how you can pad with different\n"
"characters (here a `'/'`) and how you can control alignment:"
msgstr ""
"Jeli chcesz narysowa wyr贸wnany tekst, mo偶esz u偶y\n"
"[wypenienie/wyr贸wnanie](https://doc.rust-lang.org/std/fmt/index.html#wyr贸wnanie)\n"
"operatory formatowania. W szczeg贸lnoci zwr贸 uwag, jak mo偶esz wypeni "
"r贸偶ne\n"
"znaki (tutaj `'/'`) i jak mo偶esz kontrolowa wyr贸wnanie:"

#: src/exercises/day-3/simple-gui.md:140
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let width = 10;\n"
"    println!(\"left aligned:  |{:/<width$}|\", \"foo\");\n"
"    println!(\"centered:      |{:/^width$}|\", \"foo\");\n"
"    println!(\"right aligned: |{:/>width$}|\", \"foo\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-3/simple-gui.md:149
#, fuzzy
msgid ""
"Using such alignment tricks, you can for example produce output like this:"
msgstr ""
"Korzystajc z takich sztuczek zwizanych z wyr贸wnaniem, mo偶esz na przykad "
"uzyska takie dane wyjciowe:"

#: src/exercises/day-3/simple-gui.md:151
msgid ""
"```text\n"
"+--------------------------------+\n"
"|       Rust GUI Demo 1.23       |\n"
"+================================+\n"
"| This is a small text GUI demo. |\n"
"| +-----------+                  |\n"
"| | Click me! |                  |\n"
"| +-----------+                  |\n"
"+--------------------------------+\n"
"```"
msgstr ""

#: src/error-handling.md:1
msgid "# Error Handling"
msgstr "# Obsuga bd贸w"

#: src/error-handling.md:3
#, fuzzy
msgid "Error handling in Rust is done using explicit control flow:"
msgstr "Obsuga bd贸w w Rust odbywa si za pomoc jawnego przepywu sterowania:"

#: src/error-handling.md:5
#, fuzzy
msgid ""
"* Functions that can have errors list this in their return type,\n"
"* There are no exceptions."
msgstr ""
"* Funkcje, kt贸re mog mie bdy, wymieniaj to w zwracanym typie,\n"
"* Nie ma wyjtk贸w."

#: src/error-handling/panics.md:1
#, fuzzy
msgid "# Panics"
msgstr "# Paniki"

#: src/error-handling/panics.md:3
#, fuzzy
msgid "Rust will trigger a panic if a fatal error happens at runtime:"
msgstr "Rust wywoa panik, jeli w czasie wykonywania wystpi bd krytyczny:"

#: src/error-handling/panics.md:5
msgid ""
"```rust,editable,should_panic\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    println!(\"v[100]: {}\", v[100]);\n"
"}\n"
"```"
msgstr ""
"```rust,editable,should_panic\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    println!(\"v[100]: {}\", v[100]);\n"
"}\n"
"```"

#: src/error-handling/panics.md:12
#, fuzzy
msgid ""
"* Panics are for unrecoverable and unexpected errors.\n"
"  * Panics are symptoms of bugs in the program.\n"
"* Use non-panicking APIs (such as `Vec::get`) if crashing is not acceptable."
msgstr ""
"* Paniki dotycz nieodwracalnych i nieoczekiwanych bd贸w.\n"
"  * Paniki to objawy bd贸w w programie.\n"
"* U偶ywaj niepanikujcych interfejs贸w API (takich jak `Vec::get`), jeli "
"awaria jest nie do zaakceptowania."

#: src/error-handling/panic-unwind.md:1
#, fuzzy
msgid "# Catching the Stack Unwinding"
msgstr "# apanie rozwijajcego si stosu"

#: src/error-handling/panic-unwind.md:3
#, fuzzy
msgid ""
"By default, a panic will cause the stack to unwind. The unwinding can be "
"caught:"
msgstr "Domylnie panika spowoduje wycofanie stosu. Odwijanie mo偶na zapa:"

#: src/error-handling/panic-unwind.md:5
msgid "```rust\nuse std::panic;"
msgstr ""

#: src/error-handling/panic-unwind.md:8
msgid ""
"let result = panic::catch_unwind(|| {\n"
"    println!(\"hello!\");\n"
"});\n"
"assert!(result.is_ok());"
msgstr ""
"let result = panic::catch_unwind(|| {\n"
"    println!(\"cze!\");\n"
"});\n"
"assert!(result.is_ok());"

#: src/error-handling/panic-unwind.md:13
msgid ""
"let result = panic::catch_unwind(|| {\n"
"    panic!(\"oh no!\");\n"
"});\n"
"assert!(result.is_err());\n"
"```"
msgstr ""
"let result = panic::catch_unwind(|| {\n"
"    panic!(\"o nie!\");\n"
"});\n"
"assert!(result.is_err());\n"
"```"

#: src/error-handling/panic-unwind.md:19
#, fuzzy
msgid ""
"* This can be useful in servers which should keep running even if a single\n"
"  request crashes.\n"
"* This does not work if `panic = 'abort'` is set in your `Cargo.toml`."
msgstr ""
"* Mo偶e to by przydatne na serwerach, kt贸re powinny dziaa, nawet jeli s "
"pojedyncze\n"
"  偶dania awarii.\n"
"* To nie dziaa, jeli w twoim `Cargo.toml` ustawiono `panic = 'abort'`."

#: src/error-handling/result.md:1
#, fuzzy
msgid "# Structured Error Handling with `Result`"
msgstr "# Strukturalna obsuga bd贸w za pomoc `Result`"

#: src/error-handling/result.md:3
#, fuzzy
msgid ""
"We have already seen the `Result` enum. This is used pervasively when errors "
"are\n"
"expected as part of normal operation:"
msgstr ""
"Widzielimy ju偶 enum `Result`. Jest to powszechnie stosowane, gdy wystpuj "
"bdy\n"
"spodziewane w ramach normalnej eksploatacji:"

#: src/error-handling/result.md:6
msgid ""
"```rust\n"
"use std::fs::File;\n"
"use std::io::Read;"
msgstr ""
"```rust\n"
"use std::fs::File;\n"
"use std::io::Read;"

#: src/error-handling/result.md:10
msgid ""
"fn main() {\n"
"    let file = File::open(\"diary.txt\");\n"
"    match file {\n"
"        Ok(mut file) => {\n"
"            let mut contents = String::new();\n"
"            file.read_to_string(&mut contents);\n"
"            println!(\"Dear diary: {contents}\");\n"
"        },\n"
"        Err(err) => {\n"
"            println!(\"The diary could not be opened: {err}\");\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/result.md:27
#, fuzzy
msgid ""
"  * As with `Option`, the successful value sits inside of `Result`, forcing "
"the developer to\n"
"    explicitly extract it. This encourages error checking. In the case where "
"an error should never happen,\n"
"    `unwrap()` or `expect()` can be called, and this is a signal of the "
"developer intent too.  \n"
"  * `Result` documentation is a recommended read. Not during the course, but "
"it is worth mentioning. \n"
"    It contains a lot of convenience methods and functions that help "
"functional-style programming. \n"
"    \n"
"</details>"
msgstr ""
"  * Podobnie jak w przypadku `Opcji`, pomylna warto znajduje si wewntrz "
"`Result`, zmuszajc programist do tego\n"
"    wyra藕nie go wyodrbni. To zachca do sprawdzania bd贸w. W przypadku, "
"gdy bd nigdy nie powinien si wydarzy,\n"
"    Mo偶na wywoa `unwrap()` lub `expect()`, co r贸wnie偶 jest sygnaem "
"intencji programisty.\n"
"  * Dokumentacja `Result` jest zalecan lektur. Nie w trakcie kursu, ale "
"warto o tym wspomnie.\n"
"    Zawiera wiele wygodnych metod i funkcji, kt贸re pomagaj programowa w "
"stylu funkcjonalnym.\n"
"    \n"
"</details>"

#: src/error-handling/try-operator.md:1
#, fuzzy
msgid "# Propagating Errors with `?`"
msgstr "# Propagowanie bd贸w za pomoc `?`"

#: src/error-handling/try-operator.md:3
#, fuzzy
msgid ""
"The try-operator `?` is used to return errors to the caller. It lets you "
"turn\n"
"the common"
msgstr ""
"Operator try `?` su偶y do zwracania bd贸w do obiektu wywoujcego. Pozwala "
"si obr贸ci\n"
"wsp贸lne"

#: src/error-handling/try-operator.md:6
msgid ""
"```rust,ignore\n"
"match some_expression {\n"
"    Ok(value) => value,\n"
"    Err(err) => return Err(err),\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"match some_expression {\n"
"    Ok(value) => value,\n"
"    Err(err) => return Err(err),\n"
"}\n"
"```"

#: src/error-handling/try-operator.md:13
#, fuzzy
msgid "into the much simpler"
msgstr "w du偶o prostsze"

#: src/error-handling/try-operator.md:15
msgid ""
"```rust,ignore\n"
"some_expression?\n"
"```"
msgstr ""
"```rust,ignore\n"
"jakie_wyra偶enie?\n"
"```"

#: src/error-handling/try-operator.md:19
#, fuzzy
msgid "We can use this to simplify our error handing code:"
msgstr "Mo偶emy u偶y tego, aby uproci nasz kod przekazywania bd贸w:"

#: src/error-handling/try-operator.md:21
msgid ""
"```rust,editable\n"
"use std::fs;\n"
"use std::io::{self, Read};"
msgstr ""
"```rust,editable\n"
"use std::fs;\n"
"use std::io::{self, Read};"

#: src/error-handling/try-operator.md:25
msgid ""
"fn read_username(path: &str) -> Result<String, io::Error> {\n"
"    let username_file_result = fs::File::open(path);"
msgstr ""
"fn read_username(path: &str) -> Result<String, io::Error> {\n"
"    let username_file_result = fs::File::open(path);"

#: src/error-handling/try-operator.md:28
msgid ""
"    let mut username_file = match username_file_result {\n"
"        Ok(file) => file,\n"
"        Err(e) => return Err(e),\n"
"    };"
msgstr ""
"    let mut username_file = match username_file_result {\n"
"        Ok(file) => file,\n"
"        Err(e) => return Err(e),\n"
"    };"

#: src/error-handling/try-operator.md:33
msgid "    let mut username = String::new();"
msgstr "    let mut username = String::new();"

#: src/error-handling/try-operator.md:35
msgid ""
"    match username_file.read_to_string(&mut username) {\n"
"        Ok(_) => Ok(username),\n"
"        Err(e) => Err(e),\n"
"    }\n"
"}"
msgstr ""
"    match username_file.read_to_string(&mut username) {\n"
"        Ok(_) => Ok(username),\n"
"        Err(e) => Err(e),\n"
"    }\n"
"}"

#: src/error-handling/try-operator.md:41
msgid ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"alice\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"username or error: {username:?}\");\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"alice\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"nazwa u偶ytkownika lub bd: {username:?}\");\n"
"}\n"
"```"

#: src/error-handling/try-operator.md:52 src/error-handling/converting-error-types-example.md:52
#, fuzzy
msgid ""
"* The `username` variable can be either `Ok(string)` or `Err(error)`.\n"
"* Use the `fs::write` call to test out the different scenarios: no file, "
"empty file, file with username."
msgstr ""
"* Zmienna `username` mo偶e mie posta `Ok(string)` lub `Err(error)`.\n"
"* U偶yj wywoania `fs::write`, aby przetestowa r贸偶ne scenariusze: brak "
"pliku, pusty plik, plik z nazw u偶ytkownika."

#: src/error-handling/converting-error-types.md:1
#: src/error-handling/converting-error-types-example.md:1
#, fuzzy
msgid "# Converting Error Types"
msgstr "# Konwersja typ贸w bd贸w"

#: src/error-handling/converting-error-types.md:3
#, fuzzy
msgid ""
"The effective expansion of `?` is a little more complicated than previously "
"indicated:"
msgstr ""
"Efektywna interpretacja znaku `?` jest nieco bardziej skomplikowana ni偶 "
"wskazano wczeniej:"

#: src/error-handling/converting-error-types.md:5
msgid ""
"```rust,ignore\n"
"expression?\n"
"```"
msgstr ""
"```rust,ignore\n"
"wyra偶enie?\n"
"```"

#: src/error-handling/converting-error-types.md:9
#, fuzzy
msgid "works the same as"
msgstr "dziaa tak samo jak"

#: src/error-handling/converting-error-types.md:11
msgid ""
"```rust,ignore\n"
"match expression {\n"
"    Ok(value) => value,\n"
"    Err(err)  => return Err(From::from(err)),\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"match wyra偶enie {\n"
"    Ok(value) => value,\n"
"    Err(err)  => return Err(From::from(err)),\n"
"}\n"
"```"

#: src/error-handling/converting-error-types.md:18
#, fuzzy
msgid ""
"The `From::from` call here means we attempt to convert the error type to "
"the\n"
"type returned by the function:"
msgstr ""
"Wywoanie `From::from` oznacza, 偶e pr贸bujemy przekonwertowa typ bdu na\n"
"typ zwracany przez funkcj:"

#: src/error-handling/converting-error-types-example.md:3
msgid ""
"```rust,editable\n"
"use std::error::Error;\n"
"use std::fmt::{self, Display, Formatter};\n"
"use std::fs::{self, File};\n"
"use std::io::{self, Read};"
msgstr ""
"```rust,editable\n"
"use std::error::Error;\n"
"use std::fmt::{self, Display, Formatter};\n"
"use std::fs::{self, File};\n"
"use std::io::{self, Read};"

#: src/error-handling/converting-error-types-example.md:9
msgid ""
"#[derive(Debug)]\n"
"enum ReadUsernameError {\n"
"    IoError(io::Error),\n"
"    EmptyUsername(String),\n"
"}"
msgstr ""
"#[derive(Debug)]\n"
"enum ReadUsernameError {\n"
"    IoError(io::Error),\n"
"    EmptyUsername(String),\n"
"}"

#: src/error-handling/converting-error-types-example.md:15
msgid "impl Error for ReadUsernameError {}"
msgstr "impl Error for ReadUsernameError {}"

#: src/error-handling/converting-error-types-example.md:17
msgid ""
"impl Display for ReadUsernameError {\n"
"    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n"
"        match self {\n"
"            Self::IoError(e) => write!(f, \"IO error: {}\", e),\n"
"            Self::EmptyUsername(filename) => write!(f, \"Found no username "
"in {}\", filename),\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"impl Display for ReadUsernameError {\n"
"    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n"
"        match self {\n"
"            Self::IoError(e) => write!(f, \"Bd wejcia/wyjcia: {}\", e),\n"
"            Self::EmptyUsername(filename) => write!(f, \"Nie znaleziono nazwy u偶ytkownika "
"w {}\", filename),\n"
"        }\n"
"    }\n"
"}"

#: src/error-handling/converting-error-types-example.md:26
msgid ""
"impl From<io::Error> for ReadUsernameError {\n"
"    fn from(err: io::Error) -> ReadUsernameError {\n"
"        ReadUsernameError::IoError(err)\n"
"    }\n"
"}"
msgstr ""
"impl From<io::Error> for ReadUsernameError {\n"
"    fn from(err: io::Error) -> ReadUsernameError {\n"
"        ReadUsernameError::IoError(err)\n"
"    }\n"
"}"

#: src/error-handling/converting-error-types-example.md:32
msgid ""
"fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
"    let mut username = String::with_capacity(100);\n"
"    File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(ReadUsernameError::EmptyUsername(String::from(path)));\n"
"    }\n"
"    Ok(username)\n"
"}"
msgstr ""
"fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
"    let mut username = String::with_capacity(100);\n"
"    File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(ReadUsernameError::EmptyUsername(String::from(path)));\n"
"    }\n"
"    Ok(username)\n"
"}"

#: src/error-handling/converting-error-types-example.md:41
msgid ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"username or error: {username:?}\");\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"nazwa u偶ytkownika lub bd: {username:?}\");\n"
"}\n"
"```"

#: src/error-handling/converting-error-types-example.md:55
#, fuzzy
msgid ""
"It is good practice for all error types to implement `std::error::Error`, "
"which requires `Debug` and\n"
"`Display`. It's generally helpful for them to implement `Clone` and `Eq` too "
"where possible, to make\n"
"life easier for tests and consumers of your library. In this case we can't "
"easily do so, because\n"
"`io::Error` doesn't implement them."
msgstr ""
"Dobr praktyk dla wszystkich typ贸w bd贸w jest implementacja "
"`std::error::Error`, kt贸ra wymaga `Debugowania` i\n"
"`Wywietlanie`. Generalnie pomocne jest dla nich zaimplementowanie `Clone` i "
"`Eq` tam, gdzie to mo偶liwe\n"
"uatwi 偶ycie testerom i konsumentom Twojej biblioteki. W tym przypadku nie "
"mo偶emy tego atwo zrobi, poniewa偶\n"
"`io::Error` nie implementuje ich."

#: src/error-handling/deriving-error-enums.md:1
#, fuzzy
msgid "# Deriving Error Enums"
msgstr "# Wyprowadzanie wylicze bd贸w"

#: src/error-handling/deriving-error-enums.md:3
#, fuzzy
msgid ""
"The [thiserror](https://docs.rs/thiserror/) crate is a popular way to create "
"an\n"
"error enum like we did on the previous page:"
msgstr ""
"Skrzynka [thiserror](https://docs.rs/thiserror/) to popularny spos贸b "
"tworzenia\n"
"enum bdu, tak jak zrobilimy to na poprzedniej stronie:"

#: src/error-handling/deriving-error-enums.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use thiserror::Error;"
msgstr ""

#: src/error-handling/deriving-error-enums.md:11
msgid ""
"#[derive(Debug, Error)]\n"
"enum ReadUsernameError {\n"
"    #[error(\"Could not read: {0}\")]\n"
"    IoError(#[from] io::Error),\n"
"    #[error(\"Found no username in {0}\")]\n"
"    EmptyUsername(String),\n"
"}"
msgstr ""
"#[derive(Debug, Error)]\n"
"enum ReadUsernameError {\n"
"    #[error(\"Nie mo偶na odczyta: {0}\")]\n"
"    IoError(#[from] io::Error),\n"
"    #[error(\"Nie znaleziono nazwy u偶ytkownika w {0}\")]\n"
"    EmptyUsername(String),\n"
"}"

#: src/error-handling/deriving-error-enums.md:19
msgid ""
"fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
"    let mut username = String::with_capacity(100);\n"
"    fs::File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(ReadUsernameError::EmptyUsername(String::from(path)));\n"
"    }\n"
"    Ok(username)\n"
"}"
msgstr ""

#: src/error-handling/deriving-error-enums.md:28 src/error-handling/dynamic-errors.md:25
msgid ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/deriving-error-enums.md:39
#, fuzzy
msgid ""
"`thiserror`'s derive macro automatically implements `std::error::Error`, and "
"optionally `Display`\n"
"(if the `#[error(...)]` attributes are provided) and `From` (if the "
"`#[from]` attribute is added).\n"
"It also works for structs."
msgstr ""
"Makro pochodne `thiserror` automatycznie implementuje `std::error::Error` i "
"opcjonalnie `Display`\n"
"(jeli podano atrybuty `#[error(...)]`) i `From` (jeli dodano atrybut "
"`#[from]`).\n"
"Dziaa r贸wnie偶 dla struktur."

#: src/error-handling/deriving-error-enums.md:43
#, fuzzy
msgid "It doesn't affect your public API, which makes it good for libraries."
msgstr ""
"Nie wpywa na tw贸j publiczny interfejs API, co czyni go dobrym dla bibliotek."

#: src/error-handling/dynamic-errors.md:1
#, fuzzy
msgid "# Dynamic Error Types"
msgstr "# Typy bd贸w dynamicznych"

#: src/error-handling/dynamic-errors.md:3
#, fuzzy
msgid ""
"Sometimes we want to allow any type of error to be returned without writing "
"our own enum covering\n"
"all the different possibilities. `std::error::Error` makes this easy."
msgstr ""
"Czasami chcemy zezwoli na zwr贸cenie dowolnego rodzaju bdu bez pisania "
"wasnego pokrycia wyliczeniowego\n"
"wszystkie r贸偶ne mo偶liwoci. `std::error::Error` uatwia to zadanie."

#: src/error-handling/dynamic-errors.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use std::fs::{self, File};\n"
"use std::io::Read;\n"
"use thiserror::Error;\n"
"use std::error::Error;"
msgstr ""

#: src/error-handling/dynamic-errors.md:12
msgid ""
"#[derive(Clone, Debug, Eq, Error, PartialEq)]\n"
"#[error(\"Found no username in {0}\")]\n"
"struct EmptyUsernameError(String);"
msgstr ""

#: src/error-handling/dynamic-errors.md:16
msgid ""
"fn read_username(path: &str) -> Result<String, Box<dyn Error>> {\n"
"    let mut username = String::with_capacity(100);\n"
"    File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(EmptyUsernameError(String::from(path)).into());\n"
"    }\n"
"    Ok(username)\n"
"}"
msgstr ""

#: src/error-handling/dynamic-errors.md:36
#, fuzzy
msgid ""
"This saves on code, but gives up the ability to cleanly handle different "
"error cases differently in\n"
"the program. As such it's generally not a good idea to use `Box<dyn Error>` "
"in the public API of a\n"
"library, but it can be a good option in a program where you just want to "
"display the error message\n"
"somewhere."
msgstr ""
"Oszczdza to kod, ale rezygnuje z mo偶liwoci czystego radzenia sobie z "
"r贸偶nymi przypadkami bd贸w w inny spos贸b\n"
"program. W zwizku z tym generalnie nie jest dobrym pomysem u偶ywanie "
"`Box<dyn Error>` w publicznym API aplikacji a\n"
"Library, ale mo偶e to by dobra opcja w programie, w kt贸rym chcesz tylko "
"wywietli komunikat o bdzie\n"
"gdzie."

#: src/error-handling/error-contexts.md:1
#, fuzzy
msgid "# Adding Context to Errors"
msgstr "# Dodawanie kontekstu do bd贸w"

#: src/error-handling/error-contexts.md:3
#, fuzzy
msgid ""
"The widely used [anyhow](https://docs.rs/anyhow/) crate can help you add\n"
"contextual information to your errors and allows you to have fewer\n"
"custom error types:"
msgstr ""
"Powszechnie u偶ywana [mimo wszystko](https://docs.rs/anyhow/) skrzynka mo偶e "
"pom贸c w dodaniu\n"
"informacje kontekstowe do twoich bd贸w i pozwala mie ich mniej\n"
"niestandardowe typy bd贸w:"

#: src/error-handling/error-contexts.md:7
msgid ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use anyhow::{Context, Result, bail};"
msgstr ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use anyhow::{Context, Result, bail};"

#: src/error-handling/error-contexts.md:12
msgid ""
"fn read_username(path: &str) -> Result<String> {\n"
"    let mut username = String::with_capacity(100);\n"
"    fs::File::open(path)\n"
"        .context(format!(\"Failed to open {path}\"))?\n"
"        .read_to_string(&mut username)\n"
"        .context(\"Failed to read\")?;\n"
"    if username.is_empty() {\n"
"        bail!(\"Found no username in {path}\");\n"
"    }\n"
"    Ok(username)\n"
"}"
msgstr ""

#: src/error-handling/error-contexts.md:24
msgid ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err:?}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/error-contexts.md:35
#, fuzzy
msgid ""
"* `anyhow::Result<V>` is a type alias for `Result<V, anyhow::Error>`.\n"
"* `anyhow::Error` is essentially a wrapper around `Box<dyn Error>`. As such "
"it's again generally not\n"
"  a good choice for the public API of a library, but is widely used in "
"applications.\n"
"* Actual error type inside of it can be extracted for examination if "
"necessary.\n"
"* Functionality provided by `anyhow::Result<T>` may be familiar to Go "
"developers, as it provides\n"
"  similar usage patterns and ergonomics to `(T, error)` from Go."
msgstr ""
"* `anyhow::Result<V>` jest aliasem typu dla `Result<V, anyhow::Error>`.\n"
"* `w ka偶dym razie::Bd` jest zasadniczo opakowaniem wok贸 `Box<dyn Error>`. "
"Jako taki to znowu generalnie nie\n"
"  dobry wyb贸r dla publicznego interfejsu API biblioteki, ale jest szeroko "
"stosowany w aplikacjach.\n"
"* Rzeczywisty typ bdu w nim mo偶na wyodrbni w celu zbadania, jeli to "
"konieczne.\n"
"* Funkcjonalno zapewniana przez `anyhow::Result<T>` mo偶e by znana "
"programistom Go, poniewa偶 zapewnia\n"
"  podobne wzorce u偶ytkowania i ergonomia do `(T, error)` z Go."

#: src/testing.md:1
#, fuzzy
msgid "# Testing"
msgstr "# Testowanie"

#: src/testing.md:3
#, fuzzy
msgid "Rust and Cargo come with a simple unit test framework:"
msgstr ""
"Rust i Cargo s dostarczane z prostym frameworkiem do test贸w jednostkowych:"

#: src/testing.md:5
#, fuzzy
msgid "* Unit tests are supported throughout your code."
msgstr "* Testy jednostkowe s obsugiwane w caym kodzie."

#: src/testing.md:7
#, fuzzy
msgid "* Integration tests are supported via the `tests/` directory."
msgstr "* Testy integracyjne s obsugiwane przez katalog `tests/`."

#: src/testing/unit-tests.md:1
#, fuzzy
msgid "# Unit Tests"
msgstr "# Testy jednostkowe"

#: src/testing/unit-tests.md:3
#, fuzzy
msgid "Mark unit tests with `#[test]`:"
msgstr "Oznacz testy jednostkowe za pomoc `#[test]`:"

#: src/testing/unit-tests.md:5
msgid ""
"```rust,editable\n"
"fn first_word(text: &str) -> &str {\n"
"    match text.find(' ') {\n"
"        Some(idx) => &text[..idx],\n"
"        None => &text,\n"
"    }\n"
"}"
msgstr ""

#: src/testing/unit-tests.md:13
msgid ""
"#[test]\n"
"fn test_empty() {\n"
"    assert_eq!(first_word(\"\"), \"\");\n"
"}"
msgstr ""

#: src/testing/unit-tests.md:18
msgid ""
"#[test]\n"
"fn test_single_word() {\n"
"    assert_eq!(first_word(\"Hello\"), \"Hello\");\n"
"}"
msgstr ""

#: src/testing/unit-tests.md:23
msgid ""
"#[test]\n"
"fn test_multiple_words() {\n"
"    assert_eq!(first_word(\"Hello World\"), \"Hello\");\n"
"}\n"
"```"
msgstr ""

#: src/testing/unit-tests.md:29
#, fuzzy
msgid "Use `cargo test` to find and run the unit tests."
msgstr "U偶yj testu adunku, aby znale藕 i uruchomi testy jednostkowe."

#: src/testing/test-modules.md:1
#, fuzzy
msgid "# Test Modules"
msgstr "# Moduy testowe"

#: src/testing/test-modules.md:3
#, fuzzy
msgid ""
"Unit tests are often put in a nested module (run tests on the\n"
"[Playground](https://play.rust-lang.org/)):"
msgstr ""
"Testy jednostkowe s czsto umieszczane w zagnie偶d偶onym module (uruchamiaj "
"testy na\n"
"[Plac zabaw](https://play.rust-lang.org/)):"

#: src/testing/test-modules.md:6
msgid ""
"```rust,editable\n"
"fn helper(a: &str, b: &str) -> String {\n"
"    format!(\"{a} {b}\")\n"
"}"
msgstr ""

#: src/testing/test-modules.md:11
msgid ""
"pub fn main() {\n"
"    println!(\"{}\", helper(\"Hello\", \"World\"));\n"
"}"
msgstr ""

#: src/testing/test-modules.md:19
msgid ""
"    #[test]\n"
"    fn test_helper() {\n"
"        assert_eq!(helper(\"foo\", \"bar\"), \"foo bar\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/testing/test-modules.md:26
#, fuzzy
msgid ""
"* This lets you unit test private helpers.\n"
"* The `#[cfg(test)]` attribute is only active when you run `cargo test`."
msgstr ""
"* To pozwala testowa prywatnych pomocnik贸w jednostkowych.\n"
"* Atrybut `#[cfg(test)]` jest aktywny tylko po uruchomieniu `cargo test`."

#: src/testing/doc-tests.md:1
#, fuzzy
msgid "# Documentation Tests"
msgstr "# Testy dokumentacji"

#: src/testing/doc-tests.md:3
#, fuzzy
msgid "Rust has built-in support for documentation tests:"
msgstr "Rust ma wbudowan obsug test贸w dokumentacji:"

#: src/testing/doc-tests.md:5
msgid ""
"```rust\n"
"/// Shortens a string to the given length.\n"
"///\n"
"/// ```\n"
"/// use playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"
"pub fn shorten_string(s: &str, length: usize) -> &str {\n"
"    &s[..std::cmp::min(length, s.len())]\n"
"}\n"
"```"
msgstr ""

#: src/testing/doc-tests.md:18
#, fuzzy
msgid ""
"* Code blocks in `///` comments are automatically seen as Rust code.\n"
"* The code will be compiled and executed as part of `cargo test`.\n"
"* Test the above code on the [Rust "
"Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."
msgstr ""
"* Bloki kodu w komentarzach `///` s automatycznie postrzegane jako kod "
"Rusta.\n"
"* Kod zostanie skompilowany i wykonany w ramach testu adunku.\n"
"* Przetestuj powy偶szy kod na [Rust "
"Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."

#: src/testing/integration-tests.md:1
#, fuzzy
msgid "# Integration Tests"
msgstr "# Testy integracyjne"

#: src/testing/integration-tests.md:3
#, fuzzy
msgid "If you want to test your library as a client, use an integration test."
msgstr ""
"Jeli chcesz przetestowa swoj bibliotek jako klient, u偶yj testu "
"integracji."

#: src/testing/integration-tests.md:5
#, fuzzy
msgid "Create a `.rs` file under `tests/`:"
msgstr "Utw贸rz plik `.rs` w `tests/`:"

#: src/testing/integration-tests.md:7
msgid "```rust,ignore\nuse my_library::init;"
msgstr ""

#: src/testing/integration-tests.md:10
msgid ""
"#[test]\n"
"fn test_init() {\n"
"    assert!(init().is_ok());\n"
"}\n"
"```"
msgstr ""

#: src/testing/integration-tests.md:16
#, fuzzy
msgid "These tests only have access to the public API of your crate."
msgstr "Te testy maj dostp tylko do publicznego API Twojej skrzynki."

#: src/unsafe.md:1
#, fuzzy
msgid "# Unsafe Rust"
msgstr "Co to jest Rust?"

#: src/unsafe.md:3
#, fuzzy
msgid "The Rust language has two parts:"
msgstr "Jzyk Rust skada si z dw贸ch czci:"

#: src/unsafe.md:5
#, fuzzy
msgid ""
"* **Safe Rust:** memory safe, no undefined behavior possible.\n"
"* **Unsafe Rust:** can trigger undefined behavior if preconditions are "
"violated."
msgstr ""
"* **Bezpieczna rdza:** bezpieczna pami, niemo偶liwe niezdefiniowane "
"zachowanie.\n"
"* **Niebezpieczna rdza:** mo偶e wywoa niezdefiniowane zachowanie, jeli "
"zostan naruszone warunki wstpne."

#: src/unsafe.md:8
#, fuzzy
msgid ""
"We will be seeing mostly safe Rust in this course, but it's important to "
"know\n"
"what Unsafe Rust is."
msgstr ""
"W tym kursie zobaczymy g贸wnie bezpieczn Rust, ale wa偶ne jest, aby "
"wiedzie\n"
"czym jest niebezpieczna rdza."

#: src/unsafe.md:11
#, fuzzy
msgid ""
"Unsafe code is usually small and isolated, and its correctness should be "
"carefully\n"
"documented. It is usually wrapped in a safe abstraction layer."
msgstr ""
"Niebezpieczny kod jest zwykle may i izolowany, a jego poprawno powinna "
"by ostro偶na\n"
"udokumentowane. Zwykle jest opakowany w bezpieczn warstw abstrakcji."

#: src/unsafe.md:14
#, fuzzy
msgid "Unsafe Rust gives you access to five new capabilities:"
msgstr "Unsafe Rust zapewnia dostp do piciu nowych mo偶liwoci:"

#: src/unsafe.md:16
#, fuzzy
msgid ""
"* Dereference raw pointers.\n"
"* Access or modify mutable static variables.\n"
"* Access `union` fields.\n"
"* Call `unsafe` functions, including `extern` functions.\n"
"* Implement `unsafe` traits."
msgstr ""
"* Wyuskaj surowe wska藕niki.\n"
"* Uzyskaj dostp lub modyfikuj zmienne zmienne statyczne.\n"
"* Dostp do p贸l unii.\n"
"* Wywoaj funkcje `niebezpieczne`, w tym funkcje `extern`.\n"
"* Implementuj niebezpieczne cechy."

#: src/unsafe.md:22
#, fuzzy
msgid ""
"We will briefly cover unsafe capabilities next. For full details, please "
"see\n"
"[Chapter 19.1 in the Rust "
"Book](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)\n"
"and the [Rustonomicon](https://doc.rust-lang.org/nomicon/)."
msgstr ""
"W dalszej czci kr贸tko om贸wimy niebezpieczne mo偶liwoci. Aby uzyska "
"szczeg贸owe informacje, zobacz\n"
"[Rozdzia 19.1 w Ksidze "
"Rusta](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)\n"
"oraz [Rustonomicon](https://doc.rust-lang.org/nomicon/)."

#: src/unsafe.md:28
#, fuzzy
msgid ""
"Unsafe Rust does not mean the code is incorrect. It means that developers "
"have\n"
"turned off the compiler safety features and have to write correct code by\n"
"themselves. It means the compiler no longer enforces Rust's memory-safety "
"rules."
msgstr ""
"Niebezpieczny Rust nie oznacza, 偶e kod jest nieprawidowy. Oznacza to, 偶e "
"deweloperzy maj\n"
"wyczy funkcje bezpieczestwa kompilatora i musia napisa poprawny kod "
"wg\n"
"sobie. Oznacza to, 偶e kompilator nie egzekwuje ju偶 zasad bezpieczestwa "
"pamici Rusta."

#: src/unsafe/raw-pointers.md:1
#, fuzzy
msgid "# Dereferencing Raw Pointers"
msgstr "# Dereferencja surowych wska藕nik贸w"

#: src/unsafe/raw-pointers.md:3
#, fuzzy
msgid "Creating pointers is safe, but dereferencing them requires `unsafe`:"
msgstr ""
"Tworzenie wska藕nik贸w jest bezpieczne, ale dereferencja wymaga "
"niebezpiecznego:"

#: src/unsafe/raw-pointers.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut num = 5;"
msgstr ""

#: src/unsafe/raw-pointers.md:9
msgid "    let r1 = &mut num as *mut i32;\n    let r2 = &num as *const i32;"
msgstr ""

#: src/unsafe/raw-pointers.md:12
msgid ""
"    // Safe because r1 and r2 were obtained from references and so are "
"guaranteed to be non-null and\n"
"    // properly aligned, the objects underlying the references from which "
"they were obtained are\n"
"    // live throughout the whole unsafe block, and they are not accessed "
"either through the\n"
"    // references or concurrently through any other pointers.\n"
"    unsafe {\n"
"        println!(\"r1 is: {}\", *r1);\n"
"        *r1 = 10;\n"
"        println!(\"r2 is: {}\", *r2);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/raw-pointers.md:26
#, fuzzy
msgid ""
"It is good practice (and required by the Android Rust style guide) to write "
"a comment for each\n"
"`unsafe` block explaining how the code inside it satisfies the safety "
"requirements of the unsafe\n"
"operations it is doing."
msgstr ""
"Dobr praktyk (i wymagan przez przewodnik stylistyczny Android Rust) jest "
"napisanie komentarza dla ka偶dego\n"
"Blok `niebezpieczny` wyjaniajcy, w jaki spos贸b znajdujcy si w nim kod "
"spenia wymagania bezpieczestwa niebezpiecznego\n"
"operacje, kt贸re wykonuje."

#: src/unsafe/raw-pointers.md:30
#, fuzzy
msgid ""
"In the case of pointer dereferences, this means that the pointers must be\n"
"[_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), i.e.:"
msgstr ""
"W przypadku dereferencji wska藕nik贸w oznacza to, 偶e wska藕niki musz by\n"
"[_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), czyli:"

#: src/unsafe/raw-pointers.md:33
#, fuzzy
msgid ""
" * The pointer must be non-null.\n"
" * The pointer must be _dereferenceable_ (within the bounds of a single "
"allocated object).\n"
" * The object must not have been deallocated.\n"
" * There must not be concurrent accesses to the same location.\n"
" * If the pointer was obtained by casting a reference, the underlying object "
"must be live and no\n"
"   reference may be used to access the memory."
msgstr ""
" * Wska藕nik musi by inny ni偶 null.\n"
" * Wska藕nik musi by _dereferenceable_ (w granicach pojedynczego "
"przydzielonego obiektu).\n"
" * Obiekt nie mo偶e by cofnity.\n"
" * Nie mo偶e by jednoczesnych dostp贸w do tej samej lokalizacji.\n"
" * Jeli wska藕nik zosta uzyskany przez rzutowanie odniesienia, obiekt "
"le偶cy pod spodem musi by 偶ywy i nie\n"
"   odwoanie mo偶e by u偶yte do uzyskania dostpu do pamici."

#: src/unsafe/raw-pointers.md:40
#, fuzzy
msgid "In most cases the pointer must also be properly aligned."
msgstr "W wikszoci przypadk贸w wska藕nik musi by r贸wnie偶 odpowiednio wyr贸wnany."

#: src/unsafe/mutable-static-variables.md:1
#, fuzzy
msgid "# Mutable Static Variables"
msgstr "# Zmienne zmienne statyczne"

#: src/unsafe/mutable-static-variables.md:3
#, fuzzy
msgid "It is safe to read an immutable static variable:"
msgstr "Odczyt niezmiennej zmiennej statycznej jest bezpieczny:"

#: src/unsafe/mutable-static-variables.md:5
msgid "```rust,editable\nstatic HELLO_WORLD: &str = \"Hello, world!\";"
msgstr ""

#: src/unsafe/mutable-static-variables.md:8
msgid ""
"fn main() {\n"
"    println!(\"HELLO_WORLD: {HELLO_WORLD}\");\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/mutable-static-variables.md:13
#, fuzzy
msgid ""
"However, since data races can occur, it is unsafe to read and write mutable\n"
"static variables:"
msgstr ""
"Poniewa偶 jednak mog wystpi wycigi danych, odczytywanie i zapisywanie "
"zmiennych jest niebezpieczne\n"
"zmienne statyczne:"

#: src/unsafe/mutable-static-variables.md:16
msgid "```rust,editable\nstatic mut COUNTER: u32 = 0;"
msgstr ""

#: src/unsafe/mutable-static-variables.md:19
msgid ""
"fn add_to_counter(inc: u32) {\n"
"    unsafe { COUNTER += inc; }  // Potential data race!\n"
"}"
msgstr ""

#: src/unsafe/mutable-static-variables.md:23
msgid "fn main() {\n    add_to_counter(42);"
msgstr ""

#: src/unsafe/mutable-static-variables.md:26
msgid ""
"    unsafe { println!(\"COUNTER: {COUNTER}\"); }  // Potential data race!\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/mutable-static-variables.md:32
#, fuzzy
msgid ""
"Using a mutable static is generally a bad idea, but there are some cases "
"where it might make sense\n"
"in low-level `no_std` code, such as implementing a heap allocator or working "
"with some C APIs."
msgstr ""
"U偶ywanie zmiennej statyki jest generalnie zym pomysem, ale s przypadki, w "
"kt贸rych mo偶e to mie sens\n"
"w kodzie niskiego poziomu `no_std`, takim jak implementacja alokatora sterty "
"lub praca z niekt贸rymi interfejsami API C."

#: src/unsafe/unions.md:1
#, fuzzy
msgid "# Unions"
msgstr "# Zwizki"

#: src/unsafe/unions.md:3
#, fuzzy
msgid "Unions are like enums, but you need to track the active field yourself:"
msgstr "Unie s jak wyliczenia, ale musisz samodzielnie ledzi aktywne pole:"

#: src/unsafe/unions.md:5
msgid ""
"```rust,editable\n"
"#[repr(C)]\n"
"union MyUnion {\n"
"    i: u8,\n"
"    b: bool,\n"
"}"
msgstr ""

#: src/unsafe/unions.md:12
msgid ""
"fn main() {\n"
"    let u = MyUnion { i: 42 };\n"
"    println!(\"int: {}\", unsafe { u.i });\n"
"    println!(\"bool: {}\", unsafe { u.b });  // Undefined behavior!\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/unions.md:21
#, fuzzy
msgid ""
"Unions are very rarely needed in Rust as you can usually use an enum. They "
"are occasionally needed\n"
"for interacting with C library APIs."
msgstr ""
"Unie s bardzo rzadko potrzebne w Rust, poniewa偶 zwykle mo偶na u偶y "
"wyliczenia. Czasami s potrzebne\n"
"do interakcji z interfejsami API biblioteki C."

#: src/unsafe/unions.md:24
#, fuzzy
msgid ""
"If you just want to reinterpret bytes as a different type, you probably "
"want\n"
"[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn.transmute.html) "
"or a safe\n"
"wrapper such as the [`zerocopy`](https://crates.io/crates/zerocopy) crate."
msgstr ""
"Jeli chcesz po prostu ponownie zinterpretowa bajty jako inny typ, "
"prawdopodobnie chcesz\n"
"[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn.transmute.html) "
"lub sejf\n"
"opakowanie, takie jak skrzynka "
"[`zerocopy`](https://crates.io/crates/zerocopy)."

#: src/unsafe/calling-unsafe-functions.md:1
#, fuzzy
msgid "# Calling Unsafe Functions"
msgstr "# Wywoywanie niebezpiecznych funkcji"

#: src/unsafe/calling-unsafe-functions.md:3
#, fuzzy
msgid ""
"A function or method can be marked `unsafe` if it has extra preconditions "
"you\n"
"must uphold to avoid undefined behaviour:"
msgstr ""
"Funkcja lub metoda mo偶e zosta oznaczona jako niebezpieczna, jeli ma "
"dodatkowe warunki wstpne\n"
"kt贸rych nale偶y przestrzega, aby unikn niezdefiniowanych zachowa:"

#: src/unsafe/calling-unsafe-functions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let emojis = \"烩\";"
msgstr ""

#: src/unsafe/calling-unsafe-functions.md:10
msgid ""
"    // Safe because the indices are in the correct order, within the bounds "
"of\n"
"    // the string slice, and lie on UTF-8 sequence boundaries.\n"
"    unsafe {\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(0..4));\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(4..7));\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(7..11));\n"
"    }"
msgstr ""

#: src/unsafe/calling-unsafe-functions.md:18
msgid ""
"    println!(\"char count: {}\", count_chars(unsafe { "
"emojis.get_unchecked(0..7) }));"
msgstr ""

#: src/unsafe/calling-unsafe-functions.md:20
msgid ""
"    // Not upholding the UTF-8 encoding requirement breaks memory safety!\n"
"    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
"    // println!(\"char count: {}\", count_chars(unsafe { "
"emojis.get_unchecked(0..3) }));\n"
"}"
msgstr ""

#: src/unsafe/calling-unsafe-functions.md:25
msgid ""
"fn count_chars(s: &str) -> usize {\n"
"    s.chars().map(|_| 1).sum()\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:1
#, fuzzy
msgid "# Writing Unsafe Functions"
msgstr "# Pisanie niebezpiecznych funkcji"

#: src/unsafe/writing-unsafe-functions.md:3
#, fuzzy
msgid ""
"You can mark your own functions as `unsafe` if they require particular "
"conditions to avoid undefined\n"
"behaviour."
msgstr ""
"Mo偶esz oznaczy wasne funkcje jako niebezpieczne, jeli wymagaj "
"okrelonych warunk贸w, aby unikn niezdefiniowanych\n"
"zachowanie."

#: src/unsafe/writing-unsafe-functions.md:6
msgid ""
"```rust,editable\n"
"/// Swaps the values pointed to by the given pointers.\n"
"///\n"
"/// # Safety\n"
"///\n"
"/// The pointers must be valid and properly aligned.\n"
"unsafe fn swap(a: *mut u8, b: *mut u8) {\n"
"    let temp = *a;\n"
"    *a = *b;\n"
"    *b = temp;\n"
"}"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:18
msgid ""
"fn main() {\n"
"    let mut a = 42;\n"
"    let mut b = 66;"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:22
msgid ""
"    // Safe because ...\n"
"    unsafe {\n"
"        swap(&mut a, &mut b);\n"
"    }"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:27
msgid ""
"    println!(\"a = {}, b = {}\", a, b);\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:33
#, fuzzy
msgid ""
"We wouldn't actually use pointers for this because it can be done safely "
"with references."
msgstr ""
"W rzeczywistoci nie u偶ywalibymy do tego wska藕nik贸w, poniewa偶 mo偶na to "
"zrobi bezpiecznie za pomoc referencji."

#: src/unsafe/writing-unsafe-functions.md:35
#, fuzzy
msgid ""
"Note that unsafe code is allowed within an unsafe function without an "
"`unsafe` block. We can\n"
"prohibit this with `#[deny(unsafe_op_in_unsafe_fn)]`. Try adding it and see "
"what happens."
msgstr ""
"Nale偶y zauwa偶y, 偶e niebezpieczny kod jest dozwolony w niebezpiecznej "
"funkcji bez bloku `unsafe`. Mo偶emy\n"
"zabroni tego za pomoc `#[deny(unsafe_op_in_unsafe_fn)]`. Spr贸buj go doda "
"i zobacz, co si stanie."

#: src/unsafe/extern-functions.md:1
#, fuzzy
msgid "# Calling External Code"
msgstr "Pr贸bki kodu"

#: src/unsafe/extern-functions.md:3
#, fuzzy
msgid ""
"Functions from other languages might violate the guarantees of Rust. "
"Calling\n"
"them is thus unsafe:"
msgstr ""
"Funkcje z innych jzyk贸w mog narusza gwarancje Rusta. Powoanie\n"
"s wic niebezpieczne:"

#: src/unsafe/extern-functions.md:6
msgid ""
"```rust,editable\n"
"extern \"C\" {\n"
"    fn abs(input: i32) -> i32;\n"
"}"
msgstr ""

#: src/unsafe/extern-functions.md:11
msgid ""
"fn main() {\n"
"    unsafe {\n"
"        // Undefined behavior if abs misbehaves.\n"
"        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/extern-functions.md:21
#, fuzzy
msgid ""
"This is usually only a problem for extern functions which do things with "
"pointers which might\n"
"violate Rust's memory model, but in general any C function might have "
"undefined behaviour under any\n"
"arbitrary circumstances."
msgstr ""
"Zwykle jest to problem tylko w przypadku funkcji extern, kt贸re robi rzeczy "
"ze wska藕nikami, kt贸re mog\n"
"naruszaj model pamici Rusta, ale og贸lnie ka偶da funkcja C mo偶e mie "
"niezdefiniowane zachowanie pod dowolnym\n"
"arbitralne okolicznoci."

#: src/unsafe/extern-functions.md:25
msgid ""
"The `\"C\"` in this example is the ABI;\n"
"[other ABIs are available "
"too](https://doc.rust-lang.org/reference/items/external-blocks.html)."
msgstr ""

#: src/unsafe/unsafe-traits.md:1
#, fuzzy
msgid "# Implementing Unsafe Traits"
msgstr "# Wdra偶anie niebezpiecznych cech"

#: src/unsafe/unsafe-traits.md:3
#, fuzzy
msgid ""
"Like with functions, you can mark a trait as `unsafe` if the implementation "
"must guarantee\n"
"particular conditions to avoid undefined behaviour."
msgstr ""
"Podobnie jak w przypadku funkcji, mo偶esz oznaczy cech jako "
"niebezpieczn, jeli implementacja musi gwarantowa\n"
"szczeg贸lne warunki, aby unikn nieokrelonego zachowania."

#: src/unsafe/unsafe-traits.md:6
#, fuzzy
msgid ""
"For example, the `zerocopy` crate has an unsafe trait that looks\n"
"[something like "
"this](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html):"
msgstr ""
"Na przykad skrzynka zerocopy ma niebezpieczn cech, kt贸ra wyglda\n"
"[co takiego](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html):"

#: src/unsafe/unsafe-traits.md:9
msgid ""
"```rust,editable\n"
"use std::mem::size_of_val;\n"
"use std::slice;"
msgstr ""

#: src/unsafe/unsafe-traits.md:13
#, fuzzy
msgid ""
"/// ...\n"
"/// # Safety\n"
"/// The type must have a defined representation and no padding.\n"
"pub unsafe trait AsBytes {\n"
"    fn as_bytes(&self) -> &[u8] {\n"
"        unsafe {\n"
"            slice::from_raw_parts(self as *const Self as *const u8, "
"size_of_val(self))\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"/// ...\n"
"/// # Bezpieczestwo\n"
"/// Typ musi mie zdefiniowan reprezentacj i brak dopenienia.\n"
"niebezpieczna cecha publikacji AsBytes {\n"
"    fn as_bytes(&self) -> &[u8] {\n"
"        niebezpieczny {\n"
"            slice::from_raw_parts(self jako *const Self as *const u8, "
"size_of_val(self))\n"
"        }\n"
"    }\n"
"}"

#: src/unsafe/unsafe-traits.md:24
msgid ""
"// Safe because u32 has a defined representation and no padding.\n"
"unsafe impl AsBytes for u32 {}\n"
"```"
msgstr ""

#: src/unsafe/unsafe-traits.md:30
#, fuzzy
msgid ""
"There should be a `# Safety` section on the Rustdoc for the trait explaining "
"the requirements for\n"
"the trait to be safely implemented."
msgstr ""
"Powinna istnie sekcja `# Safety` w Rustdoc dla cechy wyjaniajcej "
"wymagania dla\n"
"cecha, kt贸r nale偶y bezpiecznie wdro偶y."

#: src/unsafe/unsafe-traits.md:33
#, fuzzy
msgid ""
"The actual safety section for `AsBytes` is rather longer and more "
"complicated."
msgstr ""
"Waciwa sekcja bezpieczestwa dla `AsBytes` jest raczej du偶sza i bardziej "
"skomplikowana."

#: src/unsafe/unsafe-traits.md:35
#, fuzzy
msgid "The built-in `Send` and `Sync` traits are unsafe."
msgstr "Wbudowane cechy Wylij i Synchronizacja s niebezpieczne."

#: src/exercises/day-3/afternoon.md:1
#, fuzzy
msgid "# Day 3: Afternoon Exercises"
msgstr "# Dzie 3: wiczenia popoudniowe"

#: src/exercises/day-3/afternoon.md:3
#, fuzzy
msgid "Let us build a safe wrapper for reading directory content!"
msgstr "Zbudujmy bezpieczne opakowanie do odczytu zawartoci katalogu!"

#: src/exercises/day-3/afternoon.md:7
#, fuzzy
msgid "After looking at the exercise, you can look at the [solution] provided."
msgstr "Po obejrzeniu wiczenia mo偶esz spojrze na podane [rozwizanie]."

#: src/exercises/day-3/afternoon.md:9
msgid "[solution]: solutions-afternoon.md"
msgstr "[rozwizanie]: solutions-afternoon.md"

#: src/exercises/day-3/safe-ffi-wrapper.md:1
#, fuzzy
msgid "# Safe FFI Wrapper"
msgstr "# Bezpieczne opakowanie FFI"

#: src/exercises/day-3/safe-ffi-wrapper.md:3
#, fuzzy
msgid ""
"Rust has great support for calling functions through a _foreign function\n"
"interface_ (FFI). We will use this to build a safe wrapper for the `libc`\n"
"functions you would use from C to read the filenames of a directory."
msgstr ""
"Rust ma wietne wsparcie dla wywoywania funkcji poprzez funkcj _foreign\n"
"interfejs_ (FFI). U偶yjemy tego do zbudowania bezpiecznego opakowania dla "
"`libc`\n"
"funkcje, kt贸rych u偶yby z C do odczytania nazw plik贸w z katalogu."

#: src/exercises/day-3/safe-ffi-wrapper.md:7
#, fuzzy
msgid "You will want to consult the manual pages:"
msgstr "Bdziesz chcia zapozna si ze stronami podrcznika:"

#: src/exercises/day-3/safe-ffi-wrapper.md:9
msgid ""
"* [`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)\n"
"* [`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)\n"
"* [`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"
msgstr ""
"* [`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)\n"
"* [`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)\n"
"* [`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"

#: src/exercises/day-3/safe-ffi-wrapper.md:13
#, fuzzy
msgid ""
"You will also want to browse the [`std::ffi`] module, particular for "
"[`CStr`]\n"
"and [`CString`] types which are used to hold NUL-terminated strings coming "
"from\n"
"C. The [Nomicon] also has a very useful chapter about FFI."
msgstr ""
"Bdziesz tak偶e chcia przejrze modu [`std::ffi`], w szczeg贸lnoci dla "
"[`CStr`]\n"
"i [`CString`], kt贸re s u偶ywane do przechowywania cig贸w znak贸w zakoczonych "
"znakiem NUL pochodzcych z\n"
"C. [Nomicon] zawiera r贸wnie偶 bardzo przydatny rozdzia o FFI."

#: src/exercises/day-3/safe-ffi-wrapper.md:17
#, fuzzy
msgid ""
"[`std::ffi`]: https://doc.rust-lang.org/std/ffi/\n"
"[`CStr`]: https://doc.rust-lang.org/std/ffi/struct.CStr.html\n"
"[`CString`]: https://doc.rust-lang.org/std/ffi/struct.CString.html\n"
"[Nomicon]: https://doc.rust-lang.org/nomicon/ffi.html"
msgstr ""
"[`std::ffi`]: https://doc.rust-lang.org/std/ffi/\n"
"[`CStr`]: https://doc.rust-lang.org/std/ffi/struct.CStr.html\n"
"[`CString`]: https://doc.rust-lang.org/std/ffi/struct.CString.html\n"
"[Nomicon]: https://doc.rust-lang.org/nomicon/ffi.html"

#: src/exercises/day-3/safe-ffi-wrapper.md:22
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the "
"missing\n"
"functions and methods:"
msgstr ""
"Skopiuj poni偶szy kod na <https://play.rust-lang.org/> i uzupenij brakujce\n"
"funkcje i metody:"

#: src/exercises/day-3/safe-ffi-wrapper.md:29
msgid ""
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int, c_long, c_ulong, c_ushort};"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:32 src/exercises/day-3/solutions-afternoon.md:26
msgid ""
"    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
"    #[repr(C)]\n"
"    pub struct DIR {\n"
"        _data: [u8; 0],\n"
"        _marker: core::marker::PhantomData<(*mut u8, "
"core::marker::PhantomPinned)>,\n"
"    }"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:39 src/exercises/day-3/solutions-afternoon.md:33
msgid ""
"    // Layout as per readdir(3) and definitions in "
"/usr/include/x86_64-linux-gnu.\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_ino: c_long,\n"
"        pub d_off: c_ulong,\n"
"        pub d_reclen: c_ushort,\n"
"        pub d_type: c_char,\n"
"        pub d_name: [c_char; 256],\n"
"    }"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:49 src/exercises/day-3/solutions-afternoon.md:43
msgid ""
"    extern \"C\" {\n"
"        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"        pub fn closedir(s: *mut DIR) -> c_int;\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:56 src/exercises/day-3/solutions-afternoon.md:50
msgid ""
"use std::ffi::{CStr, CString, OsStr, OsString};\n"
"use std::os::unix::ffi::OsStrExt;"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:59
msgid ""
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}"
msgstr ""
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}"

#: src/exercises/day-3/safe-ffi-wrapper.md:65
msgid ""
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
"        unimplemented!()\n"
"    }\n"
"}"
msgstr ""
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
"        unimplemented!()\n"
"    }\n"
"}"

#: src/exercises/day-3/safe-ffi-wrapper.md:73
msgid ""
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Keep calling readdir until we get a NULL pointer back.\n"
"        unimplemented!()\n"
"    }\n"
"}"
msgstr ""
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Wywouj readdir do uzyskania wska藕nika NULL.\n"
"        unimplemented!()\n"
"    }\n"
"}"

#: src/exercises/day-3/safe-ffi-wrapper.md:81
msgid ""
"impl Drop for DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Call closedir as needed.\n"
"        unimplemented!()\n"
"    }\n"
"}"
msgstr ""
"impl Drop for DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Wywoaj closedir.\n"
"        unimplemented!()\n"
"    }\n"
"}"

#: src/exercises/day-3/safe-ffi-wrapper.md:88
msgid ""
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"pliki: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"```"

#: src/welcome-day-4.md:1
msgid "# Welcome to Day 4"
msgstr "# Witamy w dniu 4"

#: src/welcome-day-4.md:3
#, fuzzy
msgid "Today we will look at two main topics:"
msgstr "Dzisiaj przyjrzymy si dw贸m g贸wnym tematom:"

#: src/welcome-day-4.md:5
#, fuzzy
msgid "* Concurrency: threads, channels, shared state, `Send` and `Sync`."
msgstr ""
"* Wsp贸bie偶no: wtki, kanay, wsp贸dzielony stan, `Wylij` i "
"`Synchronizacja`."

#: src/welcome-day-4.md:7
#, fuzzy
msgid ""
"* Android: building binaries and libraries, using AIDL, logging, and\n"
"  interoperability with C, C++, and Java."
msgstr ""
"* Android: tworzenie plik贸w binarnych i bibliotek przy u偶yciu AIDL, "
"logowanie i\n"
"  wsp贸dziaanie z C, C++ i Jav."

#: src/welcome-day-4.md:10
#, fuzzy
msgid ""
"> We will attempt to call Rust from one of your own projects today. So try "
"to\n"
"> find a little corner of your code base where we can move some lines of "
"code to\n"
"> Rust. The fewer dependencies and \"exotic\" types the better. Something "
"that\n"
"> parses some raw bytes would be ideal."
msgstr ""
"> Spr贸bujemy dzisiaj wywoa Rusta z jednego z twoich wasnych projekt贸w. "
"Wic spr贸buj\n"
"> znajd藕 may zaktek swojej bazy kodu, do kt贸rego mo偶emy przenie kilka "
"linii kodu\n"
"> Rdza. Im mniej zale偶noci i typ贸w egzotycznych, tym lepiej. Co takiego\n"
"> analizuje kilka nieprzetworzonych bajt贸w byoby idealnie."

#: src/concurrency.md:1
#, fuzzy
msgid "# Fearless Concurrency"
msgstr "# Nieustraszona wsp贸bie偶no"

#: src/concurrency.md:3
#, fuzzy
msgid ""
"Rust has full support for concurrency using OS threads with mutexes and\n"
"channels."
msgstr ""
"Rust ma pene wsparcie dla wsp贸bie偶noci przy u偶yciu wtk贸w systemu "
"operacyjnego z muteksami i\n"
"kanay."

#: src/concurrency.md:6
#, fuzzy
msgid ""
"The Rust type system plays an important role in making many concurrency "
"bugs\n"
"compile time bugs. This is often referred to as _fearless concurrency_ since "
"you\n"
"can rely on the compiler to ensure correctness at runtime."
msgstr ""
"System typu Rust odgrywa wa偶n rol w tworzeniu wielu bd贸w wsp贸bie偶noci\n"
"skompilowa bdy czasowe. Od tego czasu jest to czsto okrelane jako "
"_nieustraszona wsp贸bie偶no_\n"
"mo偶e polega na kompilatorze, aby zapewni poprawno w czasie wykonywania."

#: src/concurrency/threads.md:1
#, fuzzy
msgid "# Threads"
msgstr "# Wtki"

#: src/concurrency/threads.md:3
#, fuzzy
msgid "Rust threads work similarly to threads in other languages:"
msgstr "Wtki Rust dziaaj podobnie do wtk贸w w innych jzykach:"

#: src/concurrency/threads.md:5
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"use std::time::Duration;"
msgstr ""

#: src/concurrency/threads.md:9
msgid ""
"fn main() {\n"
"    thread::spawn(|| {\n"
"        for i in 1..10 {\n"
"            println!(\"Count in thread: {i}!\");\n"
"            thread::sleep(Duration::from_millis(5));\n"
"        }\n"
"    });"
msgstr ""

#: src/concurrency/threads.md:17
msgid ""
"    for i in 1..5 {\n"
"        println!(\"Main thread: {i}\");\n"
"        thread::sleep(Duration::from_millis(5));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/threads.md:24
#, fuzzy
msgid ""
"* Threads are all daemon threads, the main thread does not wait for them.\n"
"* Thread panics are independent of each other.\n"
"  * Panics can carry a payload, which can be unpacked with `downcast_ref`."
msgstr ""
"* Wtki to wszystkie wtki demon贸w, g贸wny wtek na nie nie czeka.\n"
"* Paniki wtk贸w s od siebie niezale偶ne.\n"
"  * Paniki mog przenosi adunek, kt贸ry mo偶na rozpakowa za pomoc "
"`downcast_ref`."

#: src/concurrency/threads.md:32
#, fuzzy
msgid ""
"* Notice that the thread is stopped before it reaches 10  the main thread "
"is\n"
"  not waiting."
msgstr ""
"* Zauwa偶, 偶e wtek jest zatrzymywany, zanim osignie 10  g贸wny wtek jest\n"
"  nie czeka."

#: src/concurrency/threads.md:35
#, fuzzy
msgid ""
"* Use `let handle = thread::spawn(...)` and later `handle.join()` to wait "
"for\n"
"  the thread to finish."
msgstr ""
"* U偶yj `let handle = thread::spawn(...)` a p贸藕niej `handle.join()` aby "
"czeka\n"
"  wtek do koca."

#: src/concurrency/threads.md:38
#, fuzzy
msgid "* Trigger a panic in the thread, notice how this doesn't affect `main`."
msgstr "* Wywoaj panik w wtku, zauwa偶, 偶e nie wpywa to na `main`."

#: src/concurrency/threads.md:40
#, fuzzy
msgid ""
"* Use the `Result` return value from `handle.join()` to get access to the "
"panic\n"
"  payload. This is a good time to talk about [`Any`]."
msgstr ""
"* U偶yj wartoci zwracanej przez `Result` z `handle.join()`, aby uzyska "
"dostp do paniki\n"
"  adunek. To dobry moment, aby porozmawia o [`Dowolny`]."

#: src/concurrency/threads.md:43
#, fuzzy
msgid "[`Any`]: https://doc.rust-lang.org/std/any/index.html"
msgstr "[`Dowolny`]: https://doc.rust-lang.org/std/any/index.html"

#: src/concurrency/scoped-threads.md:1
#, fuzzy
msgid "# Scoped Threads"
msgstr "# Wtki o ograniczonym zakresie"

#: src/concurrency/scoped-threads.md:3
#, fuzzy
msgid "Normal threads cannot borrow from their environment:"
msgstr "Normalne wtki nie mog po偶ycza ze swojego rodowiska:"

#: src/concurrency/scoped-threads.md:5
msgid "```rust,editable,compile_fail\nuse std::thread;"
msgstr ""

#: src/concurrency/scoped-threads.md:8 src/concurrency/scoped-threads.md:22
msgid "fn main() {\n    let s = String::from(\"Hello\");"
msgstr ""

#: src/concurrency/scoped-threads.md:11
msgid ""
"    thread::spawn(|| {\n"
"        println!(\"Length: {}\", s.len());\n"
"    });\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/scoped-threads.md:17
#, fuzzy
msgid "However, you can use a [scoped thread][1] for this:"
msgstr "W tym celu mo偶esz jednak u偶y [wtku z zakresem] [1]:"

#: src/concurrency/scoped-threads.md:19
msgid "```rust,editable\nuse std::thread;"
msgstr ""

#: src/concurrency/scoped-threads.md:25
msgid ""
"    thread::scope(|scope| {\n"
"        scope.spawn(|| {\n"
"            println!(\"Length: {}\", s.len());\n"
"        });\n"
"    });\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/scoped-threads.md:33
#, fuzzy
msgid "[1]: https://doc.rust-lang.org/std/thread/fn.scope.html"
msgstr "[1]: https://doc.rust-lang.org/std/thread/fn.scope.html"

#: src/concurrency/scoped-threads.md:35
#, fuzzy
msgid ""
"<details>\n"
"    \n"
"* The reason for that is that when the `thread::scope` function completes, "
"all the threads are guaranteed to be joined, so they can return borrowed "
"data.\n"
"* Normal Rust borrowing rules apply: you can either borrow mutably by one "
"thread, or immutably by any number of threads.\n"
"    \n"
"</details>"
msgstr ""
"<details>\n"
"    \n"
"* Powodem tego jest to, 偶e gdy funkcja `thread::scope` zakoczy dziaanie, "
"wszystkie wtki zostan poczone, wic bd mogy zwr贸ci po偶yczone dane.\n"
"* Obowizuj normalne zasady po偶yczania Rusta: mo偶esz po偶ycza zmiennie o "
"jeden wtek lub niezmiennie o dowoln liczb wtk贸w.\n"
"    \n"
"</details>"

#: src/concurrency/channels.md:1
#, fuzzy
msgid "# Channels"
msgstr "# Kanay"

#: src/concurrency/channels.md:3
#, fuzzy
msgid ""
"Rust channels have two parts: a `Sender<T>` and a `Receiver<T>`. The two "
"parts\n"
"are connected via the channel, but you only see the end-points."
msgstr ""
"Kanay Rusta maj dwie czci: `Sender<T>` i `Receiver<T>`. Dwie czci\n"
"s poczone kanaem, ale widzisz tylko punkty kocowe."

#: src/concurrency/channels.md:6
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;"
msgstr ""

#: src/concurrency/channels.md:10 src/concurrency/channels/unbounded.md:10
msgid "fn main() {\n    let (tx, rx) = mpsc::channel();"
msgstr ""

#: src/concurrency/channels.md:13
msgid "    tx.send(10).unwrap();\n    tx.send(20).unwrap();"
msgstr ""

#: src/concurrency/channels.md:16
msgid ""
"    println!(\"Received: {:?}\", rx.recv());\n"
"    println!(\"Received: {:?}\", rx.recv());"
msgstr ""

#: src/concurrency/channels.md:19
msgid ""
"    let tx2 = tx.clone();\n"
"    tx2.send(30).unwrap();\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/channels.md:27
#, fuzzy
msgid ""
"* `mpsc` stands for Multi-Producer, Single-Consumer. `Sender` and "
"`SyncSender` implement `Clone` (so\n"
"  you can make multiple producers) but `Receiver` does not.\n"
"* `send()` and `recv()` return `Result`. If they return `Err`, it means the "
"counterpart `Sender` or\n"
"  `Receiver` is dropped and the channel is closed."
msgstr ""
"* `mpsc` oznacza Multi-Producer, Single-Consumer. `Sender` i `SyncSender` "
"implementuj `Clone` (tzw\n"
"  mo偶esz stworzy wielu producent贸w), ale `Receiver` nie.\n"
"* `send()` i `recv()` zwracaj `Result`. Jeli zwracaj `Bd`, oznacza to "
"odpowiednik `Nadawca` lub\n"
"  `Odbiornik` jest odrzucany i kana jest zamykany."

#: src/concurrency/channels/unbounded.md:1
#, fuzzy
msgid "# Unbounded Channels"
msgstr "# Nieograniczone kanay"

#: src/concurrency/channels/unbounded.md:3
#, fuzzy
msgid "You get an unbounded and asynchronous channel with `mpsc::channel()`:"
msgstr "Otrzymujesz nieograniczony i asynchroniczny kana z `mpsc::channel()`:"

#: src/concurrency/channels/unbounded.md:5 src/concurrency/channels/bounded.md:5
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"use std::time::Duration;"
msgstr ""

#: src/concurrency/channels/unbounded.md:13 src/concurrency/channels/bounded.md:13
msgid ""
"    thread::spawn(move || {\n"
"        let thread_id = thread::current().id();\n"
"        for i in 1..10 {\n"
"            tx.send(format!(\"Message {i}\")).unwrap();\n"
"            println!(\"{thread_id:?}: sent Message {i}\");\n"
"        }\n"
"        println!(\"{thread_id:?}: done\");\n"
"    });\n"
"    thread::sleep(Duration::from_millis(100));"
msgstr ""

#: src/concurrency/channels/unbounded.md:23
msgid ""
"    for msg in rx.iter() {\n"
"        println!(\"Main: got {}\", msg);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/channels/bounded.md:1
#, fuzzy
msgid "# Bounded Channels"
msgstr "# Ograniczone kanay"

#: src/concurrency/channels/bounded.md:3
#, fuzzy
msgid "Bounded and synchronous channels make `send` block the current thread:"
msgstr ""
"Ograniczone i synchroniczne kanay sprawiaj, 偶e `send` blokuje bie偶cy "
"wtek:"

#: src/concurrency/channels/bounded.md:10
msgid "fn main() {\n    let (tx, rx) = mpsc::sync_channel(3);"
msgstr ""

#: src/concurrency/channels/bounded.md:23
msgid ""
"    for msg in rx.iter() {\n"
"        println!(\"Main: got {msg}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state.md:1
#, fuzzy
msgid "# Shared State"
msgstr "# stan udostpniony"

#: src/concurrency/shared_state.md:3
#, fuzzy
msgid ""
"Rust uses the type system to enforce synchronization of shared data. This "
"is\n"
"primarily done via two types:"
msgstr ""
"Rust u偶ywa systemu typ贸w do wymuszania synchronizacji wsp贸dzielonych "
"danych. To jest\n"
"odbywa si g贸wnie za pomoc dw贸ch typ贸w:"

#: src/concurrency/shared_state.md:6
#, fuzzy
msgid ""
"* [`Arc<T>`][1], atomic reference counted `T`: handles sharing between "
"threads and\n"
"  takes care to deallocate `T` when the last reference is dropped,\n"
"* [`Mutex<T>`][2]: ensures mutually exclusive access to the `T` value."
msgstr ""
"* [`Arc<T>`][1], referencja atomowa liczona `T`: obsuguje udostpnianie "
"midzy wtkami i\n"
"  dba o zwolnienie `T`, gdy ostatnie odwoanie zostanie usunite,\n"
"* [`Mutex<T>`][2]: zapewnia wzajemnie wykluczajcy si dostp do wartoci "
"`T`."

#: src/concurrency/shared_state.md:10
#, fuzzy
msgid ""
"[1]: https://doc.rust-lang.org/std/sync/struct.Arc.html\n"
"[2]: https://doc.rust-lang.org/std/sync/struct.Mutex.html"
msgstr ""
"[1]: https://doc.rust-lang.org/std/sync/struct.Arc.html\n"
"[2]: https://doc.rust-lang.org/std/sync/struct.Mutex.html"

#: src/concurrency/shared_state/arc.md:1
#, fuzzy
msgid "# `Arc`"
msgstr "# `uk`"

#: src/concurrency/shared_state/arc.md:3
#, fuzzy
msgid "[`Arc<T>`][1] allows shared read-only access via its `clone` method:"
msgstr ""
"[`Arc<T>`][1] umo偶liwia wsp贸dzielony dostp tylko do odczytu poprzez swoj "
"metod `clone`:"

#: src/concurrency/shared_state/arc.md:5
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"use std::sync::Arc;"
msgstr ""

#: src/concurrency/shared_state/arc.md:9
msgid ""
"fn main() {\n"
"    let v = Arc::new(vec![10, 20, 30]);\n"
"    let mut handles = Vec::new();\n"
"    for _ in 1..5 {\n"
"        let v = v.clone();\n"
"        handles.push(thread::spawn(move || {\n"
"            let thread_id = thread::current().id();\n"
"            println!(\"{thread_id:?}: {v:?}\");\n"
"        }));\n"
"    }"
msgstr ""

#: src/concurrency/shared_state/arc.md:20
msgid ""
"    handles.into_iter().for_each(|h| h.join().unwrap());\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/arc.md:25
#, fuzzy
msgid "[1]: https://doc.rust-lang.org/std/sync/struct.Arc.html"
msgstr "[1]: https://doc.rust-lang.org/std/sync/struct.Arc.html"

#: src/concurrency/shared_state/arc.md:29
#, fuzzy
msgid ""
"* `Arc` stands for \"Atomic Reference Counted\", a thread safe version of "
"`Rc` that uses atomic\n"
"  operations.\n"
"* `Arc<T>` implements `Clone` whether or not `T` does. It implements `Send` "
"and `Sync` iff `T`\n"
"  implements them both.\n"
"* `Arc::clone()` has the cost of atomic operations that get executed, but "
"after that the use of the\n"
"  `T` is free.\n"
"* Beware of reference cycles, `Arc` does not use a garbage collector to "
"detect them.\n"
"    * `std::sync::Weak` can help."
msgstr ""
"* `Arc` oznacza \"Atomic Reference Counted\", bezpieczn dla wtk贸w wersj "
"`Rc`, kt贸ra wykorzystuje\n"
"  operacje.\n"
"* `Arc<T>` implementuje `Clone` niezale偶nie od tego, czy `T` to robi. "
"Implementuje `Wylij` i `Sync` iff `T`\n"
"  realizuje je obie.\n"
"* `Arc::clone()` ma koszt wykonania operacji atomowych, ale p贸藕niej u偶ycie\n"
"  `T` jest darmowe.\n"
"* Uwa偶aj na cykle referencyjne, `Arc` nie u偶ywa moduu wyrzucania element贸w "
"bezu偶ytecznych do ich wykrywania.\n"
"    * `std::sync::Weak` mo偶e pom贸c."

#: src/concurrency/shared_state/mutex.md:1
#, fuzzy
msgid "# `Mutex`"
msgstr "# `Mutex`"

#: src/concurrency/shared_state/mutex.md:3
#, fuzzy
msgid ""
"[`Mutex<T>`][1] ensures mutual exclusion _and_ allows mutable access to `T`\n"
"behind a read-only interface:"
msgstr ""
"[`Mutex<T>`][1] zapewnia wzajemne wykluczanie _i_ umo偶liwia zmienny dostp "
"do `T`\n"
"za interfejsem tylko do odczytu:"

#: src/concurrency/shared_state/mutex.md:6
msgid "```rust,editable\nuse std::sync::Mutex;"
msgstr ""

#: src/concurrency/shared_state/mutex.md:9
msgid ""
"fn main() {\n"
"    let v = Mutex::new(vec![10, 20, 30]);\n"
"    println!(\"v: {:?}\", v.lock().unwrap());"
msgstr ""

#: src/concurrency/shared_state/mutex.md:13
msgid ""
"    {\n"
"        let mut guard = v.lock().unwrap();\n"
"        guard.push(40);\n"
"    }"
msgstr ""

#: src/concurrency/shared_state/mutex.md:18
msgid ""
"    println!(\"v: {:?}\", v.lock().unwrap());\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/mutex.md:22
#, fuzzy
msgid ""
"Notice how we have a [`impl<T: Send> Sync for Mutex<T>`][2] blanket\n"
"implementation."
msgstr "Zauwa偶, 偶e mamy koc [`impl<T:Send> Sync for Mutex<T>`][2].\nrealizacja."

#: src/concurrency/shared_state/mutex.md:25
#, fuzzy
msgid ""
"[1]: https://doc.rust-lang.org/std/sync/struct.Mutex.html\n"
"[2]: "
"https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E\n"
"[3]: https://doc.rust-lang.org/std/sync/struct.Arc.html"
msgstr ""
"[1]: https://doc.rust-lang.org/std/sync/struct.Mutex.html\n"
"[2]: "
"https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E\n"
"[3]: https://doc.rust-lang.org/std/sync/struct.Arc.html"

#: src/concurrency/shared_state/mutex.md:29
#, fuzzy
msgid ""
"<details>\n"
"    \n"
"* `Mutex` in Rust looks like a collection with just one element - the "
"protected data.\n"
"    * It is not possible to forget to acquire the mutex before accessing the "
"protected data.\n"
"* You can get an `&mut T` from an `&Mutex<T>` by taking the lock. The "
"`MutexGuard` ensures that the\n"
"  `&mut T` doesn't outlive the lock being held.\n"
"* `Mutex<T>` implements both `Send` and `Sync` iff `T` implements `Send`.\n"
"* A read-write lock counterpart - `RwLock`.\n"
"* Why does `lock()` return a `Result`? \n"
"    * If the thread that held the `Mutex` panicked, the `Mutex` becomes "
"\"poisoned\" to signal that\n"
"      the data it protected might be in an inconsistent state. Calling "
"`lock()` on a poisoned mutex\n"
"      fails with a [`PoisonError`]. You can call `into_inner()` on the error "
"to recover the data\n"
"      regardless."
msgstr ""
"<details>\n"
"    \n"
"* `Mutex` w Rust wyglda jak kolekcja z tylko jednym elementem - chronionymi "
"danymi.\n"
"    * Nie mo偶na zapomnie o zdobyciu muteksu przed uzyskaniem dostpu do "
"chronionych danych.\n"
"* Mo偶esz uzyska `&mut T` z `&Mutex<T>`, biorc blokad. `MutexGuard` "
"zapewnia, 偶e\n"
"  `&mut T` nie przetrwa utrzymywanej blokady.\n"
"* `Mutex<T>` implementuje zar贸wno `Send`, jak i `Sync`, jeli `T` "
"implementuje `Send`.\n"
"* Odpowiednik blokady odczytu i zapisu - `RwLock`.\n"
"* Dlaczego `lock()` zwraca `Result`?\n"
"    * Jeli wtek, kt贸ry zawiera `Mutex` wpad w panik, `Mutex` zostaje "
"zatruty, aby zasygnalizowa, 偶e\n"
"      chronione dane mog by w niesp贸jnym stanie. Wywoanie `lock()` na "
"zatrutym muteksie\n"
"      koczy si niepowodzeniem z bdem [`PoisonError`]. Mo偶esz wywoa "
"`into_inner()` w przypadku bdu, aby odzyska dane\n"
"      mimo wszystko."

#: src/concurrency/shared_state/mutex.md:43
#, fuzzy
msgid ""
"[`PoisonError`]: https://doc.rust-lang.org/std/sync/struct.PoisonError.html  "
"\n"
"    \n"
"</details>"
msgstr ""
"[`PoisonError`]: https://doc.rust-lang.org/std/sync/struct.PoisonError.html\n"
"    \n"
"</details>"

#: src/concurrency/shared_state/example.md:3
#, fuzzy
msgid "Let us see `Arc` and `Mutex` in action:"
msgstr "Zobaczmy `Arc` i `Mutex` w akcji:"

#: src/concurrency/shared_state/example.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use std::thread;\n"
"// use std::sync::{Arc, Mutex};"
msgstr ""

#: src/concurrency/shared_state/example.md:9
msgid ""
"fn main() {\n"
"    let mut v = vec![10, 20, 30];\n"
"    let handle = thread::spawn(|| {\n"
"        v.push(10);\n"
"    });\n"
"    v.push(1000);"
msgstr ""

#: src/concurrency/shared_state/example.md:16
msgid ""
"    handle.join().unwrap();\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/example.md:23
msgid ""
"Possible solution:\n"
"    \n"
"```rust,editable\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;"
msgstr ""

#: src/concurrency/shared_state/example.md:29
msgid "fn main() {\n    let v = Arc::new(Mutex::new(vec![10, 20, 30]));"
msgstr ""

#: src/concurrency/shared_state/example.md:32
msgid ""
"    let v2 = v.clone();\n"
"    let handle = thread::spawn(move || {\n"
"        let mut v2 = v2.lock().unwrap();\n"
"        v2.push(10);\n"
"    });"
msgstr ""

#: src/concurrency/shared_state/example.md:38
msgid ""
"    {\n"
"        let mut v = v.lock().unwrap();\n"
"        v.push(1000);\n"
"    }"
msgstr ""

#: src/concurrency/shared_state/example.md:43
msgid "    handle.join().unwrap();"
msgstr ""

#: src/concurrency/shared_state/example.md:45
msgid ""
"    {\n"
"        let v = v.lock().unwrap();\n"
"        println!(\"v: {v:?}\");\n"
"    }\n"
"}\n"
"```\n"
"    \n"
"Notable parts:"
msgstr ""

#: src/concurrency/shared_state/example.md:54
#, fuzzy
msgid ""
"* `v` is wrapped in both `Arc` and `Mutex`, because their concerns are "
"orthogonal.\n"
"  * Wrapping a `Mutex` in an `Arc` is a common pattern to share mutable "
"state between threads.\n"
"* `v: Arc<_>` needs to be cloned as `v2` before it can be moved into another "
"thread. Note `move` was added to the lambda signature.\n"
"* Blocks are introduced to narrow the scope of the `LockGuard` as much as "
"possible.\n"
"* We still need to acquire the `Mutex` to print our `Vec`."
msgstr ""
"* `v` jest opakowane zar贸wno w `Arc`, jak i `Mutex`, poniewa偶 ich "
"zainteresowania s ortogonalne.\n"
"  * Zawijanie `Mutex` w `Arc` to powszechny wzorzec udostpniania zmiennego "
"stanu midzy wtkami.\n"
"* `v: Arc<_>` musi zosta sklonowany jako `v2` zanim bdzie mo偶na go "
"przenie do innego wtku. Uwaga: do sygnatury lambda dodano sowo move.\n"
"* Blokady s wprowadzane w celu maksymalnego zaw偶enia zakresu `LockGuard`.\n"
"* Nadal musimy zdoby `Mutex`, aby wydrukowa nasz `Vec`."

#: src/concurrency/send-sync.md:1
#, fuzzy
msgid "# `Send` and `Sync`"
msgstr "# `Wylij` i `Synchronizacja`"

#: src/concurrency/send-sync.md:3
#, fuzzy
msgid ""
"How does Rust know to forbid shared access across thread? The answer is in "
"two traits:"
msgstr ""
"Skd Rust wie, jak zabroni wsp贸dzielonego dostpu midzy wtkami? "
"Odpowied藕 tkwi w dw贸ch cechach:"

#: src/concurrency/send-sync.md:5
#, fuzzy
msgid ""
"* [`Send`][1]: a type `T` is `Send` if it is safe to move a `T` across a "
"thread\n"
"  boundary.\n"
"* [`Sync`][2]: a type `T` is `Sync` if it is safe to move a `&T` across a "
"thread\n"
"  boundary."
msgstr ""
"* [`Wylij`][1]: typ `T` to `Wylij`, jeli bezpieczne jest przeniesienie "
"`T` w wtku\n"
"  granica.\n"
"* [`Sync`][2]: typ `T` to `Sync`, jeli bezpieczne jest przeniesienie `&T` w "
"wtku\n"
"  granica."

#: src/concurrency/send-sync.md:10
#, fuzzy
msgid ""
"`Send` and `Sync` are [unsafe traits][3]. The compiler will automatically "
"derive them for your types\n"
"as long as they only contain `Send` and `Sync` types. You can also implement "
"them manually when you\n"
"know it is valid."
msgstr ""
"`Wylij` i `Synchronizacja` to [niebezpieczne cechy][3]. Kompilator "
"automatycznie wyprowadzi je dla twoich typ贸w\n"
"o ile zawieraj tylko typy `Send` i `Sync`. Mo偶esz tak偶e zaimplementowa je "
"rcznie, gdy ty\n"
"wiedzie, 偶e jest wa偶ny."

#: src/concurrency/send-sync.md:14
#, fuzzy
msgid ""
"[1]: https://doc.rust-lang.org/std/marker/trait.Send.html\n"
"[2]: https://doc.rust-lang.org/std/marker/trait.Sync.html\n"
"[3]: ../unsafe/unsafe-traits.md"
msgstr ""
"[1]: https://doc.rust-lang.org/std/marker/trait.Send.html\n"
"[2]: https://doc.rust-lang.org/std/marker/trait.Sync.html\n"
"[3]: ../unsafe/unsafe-traits.md"

#: src/concurrency/send-sync.md:20
#, fuzzy
msgid ""
"* One can think of these traits as markers that the type has certain "
"thread-safety properties.\n"
"* They can be used in the generic constraints as normal traits.\n"
"  \n"
"</details>"
msgstr ""
"* Mo偶na myle o tych cechach jako o znacznikach, 偶e typ ma pewne "
"waciwoci bezpieczestwa wtk贸w.\n"
"* Mog by u偶ywane w og贸lnych ograniczeniach jako normalne cechy.\n"
"  \n"
"</details>"

#: src/concurrency/send-sync/send.md:1
#, fuzzy
msgid "# `Send`"
msgstr "# `Wylij`"

#: src/concurrency/send-sync/send.md:3
#, fuzzy
msgid ""
"> A type `T` is [`Send`][1] if it is safe to move a `T` value to another "
"thread."
msgstr ""
"> Typ `T` to [`Send`][1], jeli przeniesienie wartoci `T` do innego wtku "
"jest bezpieczne."

#: src/concurrency/send-sync/send.md:5
#, fuzzy
msgid ""
"The effect of moving ownership to another thread is that _destructors_ will "
"run\n"
"in that thread. So the question is when you can allocate a value in one "
"thread\n"
"and deallocate it in another."
msgstr ""
"Efektem przeniesienia wasnoci do innego wtku jest uruchomienie "
"_destruktor贸w_\n"
"w tym wtku. Pytanie brzmi, kiedy mo偶na przydzieli warto w jednym wtku\n"
"i zwolnij go w innym."

#: src/concurrency/send-sync/send.md:9
#, fuzzy
msgid "[1]: https://doc.rust-lang.org/std/marker/trait.Send.html"
msgstr "[1]: https://doc.rust-lang.org/std/marker/trait.Send.html"

#: src/concurrency/send-sync/sync.md:1
#, fuzzy
msgid "# `Sync`"
msgstr "# `Synchronizacja`"

#: src/concurrency/send-sync/sync.md:3
#, fuzzy
msgid ""
"> A type `T` is [`Sync`][1] if it is safe to access a `T` value from "
"multiple\n"
"> threads at the same time."
msgstr ""
"> Typ `T` to [`Sync`][1], jeli dostp do wartoci `T` z wielu\n"
"> wtk贸w jednoczenie."

#: src/concurrency/send-sync/sync.md:6
#, fuzzy
msgid "More precisely, the definition is:"
msgstr "Dokadniej, definicja brzmi:"

#: src/concurrency/send-sync/sync.md:8
#, fuzzy
msgid "> `T` is `Sync` if and only if `&T` is `Send`"
msgstr "> `T` to `Sync` wtedy i tylko wtedy, gdy `&T` to `Wylij`"

#: src/concurrency/send-sync/sync.md:10
#, fuzzy
msgid "[1]: https://doc.rust-lang.org/std/marker/trait.Sync.html"
msgstr "[1]: https://doc.rust-lang.org/std/marker/trait.Sync.html"

#: src/concurrency/send-sync/sync.md:14
#, fuzzy
msgid ""
"This statement is essentially a shorthand way of saying that if a type is "
"thread-safe for shared use, it is also thread-safe to pass references of it "
"across threads."
msgstr ""
"To stwierdzenie jest zasadniczo skr贸towym sposobem stwierdzenia, 偶e jeli "
"typ jest bezpieczny dla wtk贸w do wsp贸lnego u偶ytku, bezpieczne jest r贸wnie偶 "
"przekazywanie odwoa do niego midzy wtkami."

#: src/concurrency/send-sync/sync.md:16
#, fuzzy
msgid ""
"This is because if a type is Sync it means that it can be shared across "
"multiple threads without the risk of data races or other synchronization "
"issues, so it is safe to move it to another thread. A reference to the type "
"is also safe to move to another thread, because the data it references can "
"be accessed from any thread safely."
msgstr ""
"Dzieje si tak, poniewa偶 jeli typem jest synchronizacja, oznacza to, 偶e "
"mo偶na go udostpnia w wielu wtkach bez ryzyka wycigu danych lub innych "
"problem贸w z synchronizacj, wic przeniesienie go do innego wtku jest "
"bezpieczne. Odwoanie do typu mo偶na r贸wnie偶 bezpiecznie przenie do innego "
"wtku, poniewa偶 do danych, do kt贸rych si odwouje, mo偶na bezpiecznie "
"uzyska dostp z dowolnego wtku."

#: src/concurrency/send-sync/examples.md:1
#, fuzzy
msgid "# Examples"
msgstr "# Przykady"

#: src/concurrency/send-sync/examples.md:3
#, fuzzy
msgid "## `Send + Sync`"
msgstr "## `Wylij + synchronizuj`"

#: src/concurrency/send-sync/examples.md:5
#, fuzzy
msgid "Most types you come across are `Send + Sync`:"
msgstr "Wikszo spotykanych typ贸w to `Wylij + synchronizuj`:"

#: src/concurrency/send-sync/examples.md:7
msgid ""
"* `i8`, `f32`, `bool`, `char`, `&str`, ...\n"
"* `(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ...\n"
"* `String`, `Option<T>`, `Vec<T>`, `Box<T>`, ...\n"
"* `Arc<T>`: Explicitly thread-safe via atomic reference count.\n"
"* `Mutex<T>`: Explicitly thread-safe via internal locking.\n"
"* `AtomicBool`, `AtomicU8`, ...: Uses special atomic instructions."
msgstr ""

#: src/concurrency/send-sync/examples.md:14
#, fuzzy
msgid ""
"The generic types are typically `Send + Sync` when the type parameters are\n"
"`Send + Sync`."
msgstr ""
"Typy og贸lne to zazwyczaj `Wylij + synchronizacja`, gdy s to parametry "
"typu\n"
"`Wylij + synchronizuj`."

#: src/concurrency/send-sync/examples.md:17
#, fuzzy
msgid "## `Send + !Sync`"
msgstr "## `Wylij +!Synchronizacja`"

#: src/concurrency/send-sync/examples.md:19
#, fuzzy
msgid ""
"These types can be moved to other threads, but they're not thread-safe.\n"
"Typically because of interior mutability:"
msgstr ""
"Te typy mo偶na przenosi do innych wtk贸w, ale nie s one bezpieczne dla "
"wtk贸w.\n"
"Zazwyczaj z powodu wewntrznej zmiennoci:"

#: src/concurrency/send-sync/examples.md:22
#, fuzzy
msgid ""
"* `mpsc::Sender<T>`\n"
"* `mpsc::Receiver<T>`\n"
"* `Cell<T>`\n"
"* `RefCell<T>`"
msgstr ""
"* `mpsc::Nadawca<T>`\n"
"* `mpsc::Odbiornik<T>`\n"
"* `Kom贸rka<T>`\n"
"* `RefKom贸rka<T>`"

#: src/concurrency/send-sync/examples.md:27
#, fuzzy
msgid "## `!Send + Sync`"
msgstr "## `!Wylij + synchronizuj`"

#: src/concurrency/send-sync/examples.md:29
#, fuzzy
msgid "These types are thread-safe, but they cannot be moved to another thread:"
msgstr ""
"Te typy s bezpieczne dla wtk贸w, ale nie mo偶na ich przenie do innego "
"wtku:"

#: src/concurrency/send-sync/examples.md:31
#, fuzzy
msgid ""
"* `MutexGuard<T>`: Uses OS level primitives which must be deallocated on "
"the\n"
"  thread which created them."
msgstr ""
"* `MutexGuard<T>`: U偶ywa prymityw贸w na poziomie systemu operacyjnego, kt贸re "
"musz zosta zwolnione na\n"
"  wtek, kt贸ry je stworzy."

#: src/concurrency/send-sync/examples.md:34
#, fuzzy
msgid "## `!Send + !Sync`"
msgstr "## `!Wylij + !Sync`"

#: src/concurrency/send-sync/examples.md:36
#, fuzzy
msgid "These types are not thread-safe and cannot be moved to other threads:"
msgstr ""
"Te typy nie s bezpieczne dla wtk贸w i nie mo偶na ich przenosi do innych "
"wtk贸w:"

#: src/concurrency/send-sync/examples.md:38
#, fuzzy
msgid ""
"* `Rc<T>`: each `Rc<T>` has a reference to an `RcBox<T>`, which contains a\n"
"  non-atomic reference count.\n"
"* `*const T`, `*mut T`: Rust assumes raw pointers may have special\n"
"  concurrency considerations."
msgstr ""
"* `Rc<T>`: ka偶dy `Rc<T>` ma odniesienie do `RcBox<T>`, kt贸ry zawiera\n"
"  nieatomowa liczba referencji.\n"
"* `*const T`, `*mut T`: Rust zakada, 偶e surowe wska藕niki mog mie "
"specjalne\n"
"  wzgldy wsp贸bie偶noci."

#: src/exercises/day-4/morning.md:1 src/exercises/day-4/afternoon.md:1
#, fuzzy
msgid "# Exercises"
msgstr "# wiczenia"

#: src/exercises/day-4/morning.md:3
#, fuzzy
msgid "Let us practice our new concurrency skills with"
msgstr "Przewiczmy nasze nowe umiejtnoci wsp贸bie偶noci z"

#: src/exercises/day-4/morning.md:5
#, fuzzy
msgid "* Dining philosophers: a classic problem in concurrency."
msgstr "* Filozofowie jadalni: klasyczny problem wsp贸bie偶noci."

#: src/exercises/day-4/morning.md:7
#, fuzzy
msgid ""
"* Multi-threaded link checker: a larger project where you'll use Cargo to\n"
"  download dependencies and then check links in parallel."
msgstr ""
"* Wielowtkowe narzdzie do sprawdzania link贸w: wikszy projekt, do kt贸rego "
"u偶yjesz Cargo\n"
"  pobierz zale偶noci, a nastpnie sprawd藕 linki r贸wnolegle."

#: src/exercises/day-4/dining-philosophers.md:1
#, fuzzy
msgid "# Dining Philosophers"
msgstr "# Filozofowie jedzenia"

#: src/exercises/day-4/dining-philosophers.md:3
#, fuzzy
msgid "The dining philosophers problem is a classic problem in concurrency:"
msgstr "Problem filozof贸w jadalni jest klasycznym problemem wsp贸bie偶noci:"

#: src/exercises/day-4/dining-philosophers.md:5
#, fuzzy
msgid ""
"> Five philosophers dine together at the same table. Each philosopher has "
"their\n"
"> own place at the table. There is a fork between each plate. The dish "
"served is\n"
"> a kind of spaghetti which has to be eaten with two forks. Each philosopher "
"can\n"
"> only alternately think and eat. Moreover, a philosopher can only eat "
"their\n"
"> spaghetti when they have both a left and right fork. Thus two forks will "
"only\n"
"> be available when their two nearest neighbors are thinking, not eating. "
"After\n"
"> an individual philosopher finishes eating, they will put down both forks."
msgstr ""
"> Piciu filozof贸w je razem przy jednym stole. Ka偶dy filozof ma swoje\n"
"> wasne miejsce przy stole. Pomidzy ka偶dym talerzem znajduje si widelec. "
"Serwowane danie to\n"
"> rodzaj spaghetti, kt贸re trzeba je dwoma widelcami. Ka偶dy filozof mo偶e\n"
"> tylko na przemian myle i je. Co wicej, filozof mo偶e je tylko ich\n"
"> spaghetti, gdy maj lewy i prawy widelec. Tak wic tylko dwa widelce\n"
"> by dostpnym, gdy dwaj najbli偶si ssiedzi myl, a nie jedz. Po\n"
"> pojedynczy filozof skoczy je, odo偶y oba widelce."

#: src/exercises/day-4/dining-philosophers.md:13
#, fuzzy
msgid ""
"You will need a local [Cargo installation](../../cargo/running-locally.md) "
"for\n"
"this exercise. Copy the code below to `src/main.rs` file, fill out the "
"blanks,\n"
"and test that `cargo run` does not deadlock:"
msgstr ""
"Bdziesz potrzebowa lokalnej [instalacji "
"Cargo](../../cargo/running-locally.md) dla\n"
"to wiczenie. Skopiuj poni偶szy kod do pliku `src/main.rs`, wypenij puste "
"pola,\n"
"i sprawd藕, czy `cargo run` nie powoduje impasu:"

#: src/exercises/day-4/dining-philosophers.md:17
msgid ""
"```rust,compile_fail\n"
"use std::sync::mpsc;\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:23 src/exercises/day-4/solutions-morning.md:28
msgid "struct Fork;"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:25
#, fuzzy
msgid ""
"struct Philosopher {\n"
"    name: String,\n"
"    // left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
"}"
msgstr ""
"struktura Filozof {\n"
"    imi: Cig,\n"
"    // lewy_fork: ...\n"
"    // widelec_w prawo: ...\n"
"    // myli: ...\n"
"}"

#: src/exercises/day-4/dining-philosophers.md:32
msgid ""
"impl Philosopher {\n"
"    fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))\n"
"            .unwrap();\n"
"    }"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:39
msgid ""
"    fn eat(&self) {\n"
"        // Pick up forks...\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:46 src/exercises/day-4/solutions-morning.md:60
msgid ""
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:49
#, fuzzy
msgid "fn main() {\n    // Create forks"
msgstr "fn main() {\n    // Utw贸rz rozwidlenia"

#: src/exercises/day-4/dining-philosophers.md:52
#, fuzzy
msgid "    // Create philosophers"
msgstr "    // Tw贸rz filozof贸w"

#: src/exercises/day-4/dining-philosophers.md:54
#, fuzzy
msgid "    // Make them think and eat"
msgstr "    // Niech myl i jedz"

#: src/exercises/day-4/dining-philosophers.md:56
msgid ""
"    // Output their thoughts\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:1
#, fuzzy
msgid "# Multi-threaded Link Checker"
msgstr "# Wielowtkowe narzdzie do sprawdzania link贸w"

#: src/exercises/day-4/link-checker.md:3
#, fuzzy
msgid ""
"Let us use our new knowledge to create a multi-threaded link checker. It "
"should\n"
"start at a webpage and check that links on the page are valid. It should\n"
"recursively check other pages on the same domain and keep doing this until "
"all\n"
"pages have been validated."
msgstr ""
"Wykorzystajmy nasz now wiedz do stworzenia wielowtkowego narzdzia do "
"sprawdzania link贸w. Powinno\n"
"zacznij od strony internetowej i sprawd藕, czy linki na stronie s "
"prawidowe. Powinno\n"
"rekurencyjnie sprawdzaj inne strony w tej samej domenie i r贸b to, a偶 "
"wszystkie\n"
"strony zostay zweryfikowane."

#: src/exercises/day-4/link-checker.md:8
#, fuzzy
msgid ""
"For this, you will need an HTTP client such as [`reqwest`][1]. Create a new\n"
"Cargo project and `reqwest` it as a dependency with:"
msgstr ""
"Do tego potrzebny bdzie klient HTTP, taki jak [`reqwest`][1]. Stw贸rz nowy\n"
"Projekt Cargo i `reqwest` jako zale偶no z:"

#: src/exercises/day-4/link-checker.md:11
msgid ""
"```shell\n"
"$ cargo new link-checker\n"
"$ cd link-checker\n"
"$ cargo add --features blocking,rustls-tls reqwest\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:17
#, fuzzy
msgid ""
"> If `cargo add` fails with `error: no such subcommand`, then please edit "
"the\n"
"> `Cargo.toml` file by hand. Add the dependencies listed below."
msgstr ""
"> Jeli polecenie `cargo add` nie powiedzie si z komunikatem `error: no "
"such subcommand`, edytuj\n"
"> Plik `Cargo.toml` rcznie. Dodaj zale偶noci wymienione poni偶ej."

#: src/exercises/day-4/link-checker.md:20
#, fuzzy
msgid ""
"You will also need a way to find links. We can use [`scraper`][2] for that:"
msgstr ""
"Bdziesz tak偶e potrzebowa sposobu na znalezienie link贸w. Mo偶emy do tego "
"u偶y [`scraper`][2]:"

#: src/exercises/day-4/link-checker.md:22
msgid ""
"```shell\n"
"$ cargo add scraper\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:26
#, fuzzy
msgid ""
"Finally, we'll need some way of handling errors. We use [`thiserror`][3] "
"for\n"
"that:"
msgstr ""
"Na koniec bdziemy potrzebowa jakiego sposobu obsugi bd贸w. U偶ywamy "
"[`thiserror`][3] dla\n"
"To:"

#: src/exercises/day-4/link-checker.md:29
msgid ""
"```shell\n"
"$ cargo add thiserror\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:33
#, fuzzy
msgid ""
"The `cargo add` calls will update the `Cargo.toml` file to look like this:"
msgstr ""
"Wywoania `cargo add` zaktualizuj plik `Cargo.toml` tak, aby wyglda "
"nastpujco:"

#: src/exercises/day-4/link-checker.md:35
msgid ""
"```toml\n"
"[dependencies]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-tls\"] "
"}\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:42
#, fuzzy
msgid ""
"You can now download the start page. Try with a small site such as\n"
"`https://www.google.org/`."
msgstr ""
"Mo偶esz teraz pobra stron startow. Spr贸buj z ma witryn, tak jak\n"
"`https://www.google.org/`."

#: src/exercises/day-4/link-checker.md:45
#, fuzzy
msgid "Your `src/main.rs` file should look something like this:"
msgstr "Tw贸j plik `src/main.rs` powinien wyglda mniej wicej tak:"

#: src/exercises/day-4/link-checker.md:47
msgid ""
"```rust,compile_fail\n"
"use reqwest::blocking::{get, Response};\n"
"use reqwest::Url;\n"
"use scraper::{Html, Selector};\n"
"use thiserror::Error;"
msgstr ""

#: src/exercises/day-4/link-checker.md:53
msgid ""
"#[derive(Error, Debug)]\n"
"enum Error {\n"
"    #[error(\"request error: {0}\")]\n"
"    ReqwestError(#[from] reqwest::Error),\n"
"}"
msgstr ""
"#[derive(Error, Debug)]\n"
"enum Error {\n"
"    #[error(\"bd zapytania: {0}\")]\n"
"    ReqwestError(#[from] reqwest::Error),\n"
"}"

#: src/exercises/day-4/link-checker.md:59
msgid ""
"fn extract_links(response: Response) -> Result<Vec<Url>, Error> {\n"
"    let base_url = response.url().to_owned();\n"
"    let document = response.text()?;\n"
"    let html = Html::parse_document(&document);\n"
"    let selector = Selector::parse(\"a\").unwrap();"
msgstr ""

#: src/exercises/day-4/link-checker.md:65
msgid ""
"    let mut valid_urls = Vec::new();\n"
"    for element in html.select(&selector) {\n"
"        if let Some(href) = element.value().attr(\"href\") {\n"
"            match base_url.join(href) {\n"
"                Ok(url) => valid_urls.push(url),\n"
"                Err(err) => {\n"
"                    println!(\"On {base_url}: could not parse {href:?}: "
"{err} (ignored)\",);\n"
"                }\n"
"            }\n"
"        }\n"
"    }"
msgstr ""

#: src/exercises/day-4/link-checker.md:77
#, fuzzy
msgid "    Ok(valid_urls)\n}"
msgstr "    OK (prawidowe_adresy URL)\n}"

#: src/exercises/day-4/link-checker.md:80
msgid ""
"fn main() {\n"
"    let start_url = Url::parse(\"https://www.google.org\").unwrap();\n"
"    let response = get(start_url).unwrap();\n"
"    match extract_links(response) {\n"
"        Ok(links) => println!(\"Links: {links:#?}\"),\n"
"        Err(err) => println!(\"Could not extract links: {err:#}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:90
#, fuzzy
msgid "Run the code in `src/main.rs` with"
msgstr "Uruchom kod w `src/main.rs` za pomoc"

#: src/exercises/day-4/link-checker.md:92
#, fuzzy
msgid ""
"```shell\n"
"$ cargo run\n"
"```"
msgstr "Korzystanie z Cargo"

#: src/exercises/day-4/link-checker.md:96
#, fuzzy
msgid "## Tasks"
msgstr "## Zadania"

#: src/exercises/day-4/link-checker.md:98
#, fuzzy
msgid ""
"* Use threads to check the links in parallel: send the URLs to be checked to "
"a\n"
"  channel and let a few threads check the URLs in parallel.\n"
"* Extend this to recursively extract links from all pages on the\n"
"  `www.google.org` domain. Put an upper limit of 100 pages or so so that "
"you\n"
"  don't end up being blocked by the site."
msgstr ""
"* U偶ywaj wtk贸w do r贸wnolegego sprawdzania link贸w: wylij adresy URL do "
"sprawdzenia do a\n"
"  channel i pozw贸l kilku wtkom r贸wnolegle sprawdza adresy URL.\n"
"* Rozszerz to, aby rekurencyjnie wyodrbni linki ze wszystkich stron w "
"witrynie\n"
"  domena `www.google.org`. Ustaw g贸rny limit 100 stron lub tak, aby m贸g\n"
"  nie zosta zablokowany przez witryn."

#: src/exercises/day-4/link-checker.md:104
#, fuzzy
msgid ""
"[1]: https://docs.rs/reqwest/\n"
"[2]: https://docs.rs/scraper/\n"
"[3]: https://docs.rs/thiserror/"
msgstr ""
"[1]: https://docs.rs/reqwest/\n"
"[2]: https://docs.rs/scraper/\n"
"[3]: https://docs.rs/thiserror/"

#: src/android.md:1
#, fuzzy
msgid "# Android"
msgstr "# Androida"

#: src/android.md:3
#, fuzzy
msgid ""
"Rust is supported for native platform development on Android. This means "
"that\n"
"you can write new operating system services in Rust, as well as extending\n"
"existing services."
msgstr ""
"Rust jest obsugiwany w przypadku tworzenia natywnych platform na Androida. "
"To znaczy 偶e\n"
"mo偶esz pisa nowe usugi systemu operacyjnego w Rust, a tak偶e rozszerza\n"
"istniejce usugi."

#: src/android/setup.md:1
#, fuzzy
msgid "# Setup"
msgstr "# Organizowa co"

#: src/android/setup.md:3
#, fuzzy
msgid ""
"We will be using an Android Virtual Device to test our code. Make sure you "
"have\n"
"access to one or create a new one with:"
msgstr ""
"Bdziemy u偶ywa urzdzenia wirtualnego z Androidem do testowania naszego "
"kodu. Upewnij si 偶e masz\n"
"dostp do jednego lub utw贸rz nowy z:"

#: src/android/setup.md:6
msgid ""
"```shell\n"
"$ source build/envsetup.sh\n"
"$ lunch aosp_cf_x86_64_phone-userdebug\n"
"$ acloud create\n"
"```"
msgstr ""

#: src/android/setup.md:12
#, fuzzy
msgid ""
"Please see the [Android Developer\n"
"Codelab](https://source.android.com/docs/setup/start) for details."
msgstr ""
"Zobacz [Android Developer\n"
"Codelab](https://source.android.com/docs/setup/start), aby uzyska "
"szczeg贸owe informacje."

#: src/android/build-rules.md:1
#, fuzzy
msgid "# Build Rules"
msgstr "# Reguy budowania"

#: src/android/build-rules.md:3
#, fuzzy
msgid "The Android build system (Soong) supports Rust via a number of modules:"
msgstr ""
"System kompilacji Androida (Soong) obsuguje Rusta za porednictwem wielu "
"modu贸w:"

#: src/android/build-rules.md:5
#, fuzzy
msgid ""
"| Module Type       | Description                                            "
"                                            |\n"
"|-------------------|----------------------------------------------------------------------------------------------------|\n"
"| `rust_binary`     | Produces a Rust binary.                                "
"                                            |\n"
"| `rust_library`    | Produces a Rust library, and provides both `rlib` and "
"`dylib` variants.                            |\n"
"| `rust_ffi`        | Produces a Rust C library usable by `cc` modules, and "
"provides both static and shared variants.    |\n"
"| `rust_proc_macro` | Produces a `proc-macro` Rust library. These are "
"analogous to compiler plugins.                     |\n"
"| `rust_test`       | Produces a Rust test binary that uses the standard "
"Rust test harness.                              |\n"
"| `rust_fuzz`       | Produces a Rust fuzz binary leveraging `libfuzzer`.    "
"                                            |\n"
"| `rust_protobuf`   | Generates source and produces a Rust library that "
"provides an interface for a particular protobuf. |\n"
"| `rust_bindgen`    | Generates source and produces a Rust library "
"containing Rust bindings to C libraries.              |"
msgstr ""
"| Typ moduu | Opis |\n"
"|-------------------|-------------- "
"-------------------------------------------------- ---------------------|\n"
"| `rust_binary` | Tworzy plik binarny Rust. |\n"
"| `rust_biblioteka` | Tworzy bibliotek Rust i udostpnia zar贸wno warianty "
"`rlib`, jak i `dylib`. |\n"
"| `rust_ffi` | Tworzy bibliotek Rust C u偶ywan przez moduy `cc` i zapewnia "
"zar贸wno statyczne, jak i wsp贸dzielone warianty. |\n"
"| `rust_proc_macro` | Tworzy bibliotek `proc-macro` Rusta. S one "
"analogiczne do wtyczek kompilatora. |\n"
"| `test_rdzy` | Tworzy plik binarny testu Rust, kt贸ry u偶ywa standardowej "
"wizki testowej Rust. |\n"
"| `rust_fuzz` | Tworzy plik binarny Rust fuzz wykorzystujcy `libfuzzer`. |\n"
"| `rust_protobuf` | Generuje 藕r贸do i tworzy bibliotek Rust, kt贸ra zapewnia "
"interfejs dla okrelonego protobuf. |\n"
"| `rdza_powizanie` | Generuje 藕r贸do i tworzy bibliotek Rust zawierajc "
"powizania Rusta z bibliotekami C. |"

#: src/android/build-rules.md:16
#, fuzzy
msgid "We will look at `rust_binary` and `rust_library` next."
msgstr "Nastpnie przyjrzymy si `rust_binary` i `rust_library`."

#: src/android/build-rules/binary.md:1
msgid "# Rust Binaries"
msgstr "# Binaria Rusta"

#: src/android/build-rules/binary.md:3
#, fuzzy
msgid ""
"Let us start with a simple application. At the root of an AOSP checkout, "
"create\n"
"the following files:"
msgstr ""
"Zacznijmy od prostej aplikacji. W katalogu g贸wnym kasy AOSP utw贸rz\n"
"nastpujce pliki:"

#: src/android/build-rules/binary.md:6 src/android/build-rules/library.md:13
msgid "_hello_rust/Android.bp_:"
msgstr "_hello_rust/Android.bp_:"

#: src/android/build-rules/binary.md:8
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust\",\n"
"    crate_name: \"hello_rust\",\n"
"    srcs: [\"src/main.rs\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/binary.md:16 src/android/build-rules/library.md:34
#, fuzzy
msgid "_hello_rust/src/main.rs_:"
msgstr "_hello_rust/src/main.rs_:"

#: src/android/build-rules/binary.md:18
msgid "```rust\n//! Rust demo."
msgstr "```rust\n//! Rust demo."

#: src/android/build-rules/binary.md:21
msgid ""
"/// Prints a greeting to standard output.\n"
"fn main() {\n"
"    println!(\"Hello from Rust!\");\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/binary.md:27
#, fuzzy
msgid "You can now build, push, and run the binary:"
msgstr "Mo偶esz teraz budowa, przesya i uruchamia plik binarny:"

#: src/android/build-rules/binary.md:29
msgid ""
"```shell\n"
"$ m hello_rust\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust\n"
"Hello from Rust!\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:1
msgid "# Rust Libraries"
msgstr "# Biblioteki Rusta"

#: src/android/build-rules/library.md:3
#, fuzzy
msgid "You use `rust_library` to create a new Rust library for Android."
msgstr "U偶ywasz `rust_library` do tworzenia nowej biblioteki Rust dla Androida."

#: src/android/build-rules/library.md:5
#, fuzzy
msgid "Here we declare a dependency on two libraries:"
msgstr "Tutaj deklarujemy zale偶no od dw贸ch bibliotek:"

#: src/android/build-rules/library.md:7
#, fuzzy
msgid ""
"* `libgreeting`, which we define below,\n"
"* `libtextwrap`, which is a crate already vendored in\n"
"  [`external/rust/crates/`][crates]."
msgstr ""
"* `libgreeting`, kt贸re definiujemy poni偶ej,\n"
"* `libtextwrap`, kt贸ra jest ju偶 sprzedawan skrzynk\n"
"  [`zewntrzne/rdza/skrzynie/`][skrzynie]."

#: src/android/build-rules/library.md:11
#, fuzzy
msgid ""
"[crates]: "
"https://cs.android.com/android/platform/superproject/+/master:external/rust/crates/"
msgstr ""
"[skrzynie]: "
"https://cs.android.com/android/platform/superproject/+/master:external/rust/crates/"

#: src/android/build-rules/library.md:15
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_with_dep\",\n"
"    crate_name: \"hello_rust_with_dep\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"libgreetings\",\n"
"        \"libtextwrap\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}"
msgstr ""

#: src/android/build-rules/library.md:27
msgid ""
"rust_library {\n"
"    name: \"libgreetings\",\n"
"    crate_name: \"greetings\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:36
msgid "```rust,ignore\n//! Rust demo."
msgstr "```rust,ignore\n//! Rust demo."

#: src/android/build-rules/library.md:39
msgid "use greetings::greeting;\nuse textwrap::fill;"
msgstr ""

#: src/android/build-rules/library.md:42
msgid ""
"/// Prints a greeting to standard output.\n"
"fn main() {\n"
"    println!(\"{}\", fill(&greeting(\"Bob\"), 24));\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:48
#, fuzzy
msgid "_hello_rust/src/lib.rs_:"
msgstr "_hello_rust/src/lib.rs_:"

#: src/android/build-rules/library.md:50
msgid "```rust,ignore\n//! Greeting library."
msgstr ""

#: src/android/build-rules/library.md:53
msgid ""
"/// Greet `name`.\n"
"pub fn greeting(name: &str) -> String {\n"
"    format!(\"Hello {name}, it is very nice to meet you!\")\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:59
#, fuzzy
msgid "You build, push, and run the binary like before:"
msgstr "Budujesz, wypychasz i uruchamiasz plik binarny tak jak poprzednio:"

#: src/android/build-rules/library.md:61
msgid ""
"```shell\n"
"$ m hello_rust_with_dep\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep "
"/data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust_with_dep\n"
"Hello Bob, it is very\n"
"nice to meet you!\n"
"```"
msgstr ""

#: src/android/aidl.md:1
#, fuzzy
msgid "# AIDL"
msgstr "# AIDL"

#: src/android/aidl.md:3
#, fuzzy
msgid ""
"The [Android Interface Definition Language\n"
"(AIDL)](https://developer.android.com/guide/components/aidl) is supported in "
"Rust:"
msgstr ""
"[Jzyk definicji interfejsu Androida\n"
"(AIDL)](https://developer.android.com/guide/components/aidl) jest "
"obsugiwany w Rust:"

#: src/android/aidl.md:6
#, fuzzy
msgid ""
"* Rust code can call existing AIDL servers,\n"
"* You can create new AIDL servers in Rust."
msgstr ""
"* Kod Rusta mo偶e wywoywa istniejce serwery AIDL,\n"
"* Mo偶esz tworzy nowe serwery AIDL w Rust."

#: src/android/aidl/interface.md:1
#, fuzzy
msgid "# AIDL Interfaces"
msgstr "# Interfejsy AIDL"

#: src/android/aidl/interface.md:3
#, fuzzy
msgid "You declare the API of your service using an AIDL interface:"
msgstr "Deklarujesz API swojej usugi za pomoc interfejsu AIDL:"

#: src/android/aidl/interface.md:5
#, fuzzy
msgid ""
"*birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl*:"
msgstr ""
"*urodziny_serwis/aidl/com/example/birthdayservice/IBirthdayService.aidl*:"

#: src/android/aidl/interface.md:7 src/android/aidl/changing.md:6
msgid "```java\npackage com.example.birthdayservice;"
msgstr ""

#: src/android/aidl/interface.md:10
msgid ""
"/** Birthday service interface. */\n"
"interface IBirthdayService {\n"
"    /** Generate a Happy Birthday message. */\n"
"    String wishHappyBirthday(String name, int years);\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/interface.md:17
#, fuzzy
msgid "*birthday_service/aidl/Android.bp*:"
msgstr "*birthday_service/aidl/Android.bp*:"

#: src/android/aidl/interface.md:19
msgid ""
"```javascript\n"
"aidl_interface {\n"
"    name: \"com.example.birthdayservice\",\n"
"    srcs: [\"com/example/birthdayservice/*.aidl\"],\n"
"    unstable: true,\n"
"    backend: {\n"
"        rust: { // Rust is not enabled by default\n"
"            enabled: true,\n"
"        },\n"
"    },\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/interface.md:32
#, fuzzy
msgid ""
"Add `vendor_available: true` if your AIDL file is used by a binary in the "
"vendor\n"
"partition."
msgstr ""
"Dodaj vendor_available: true, jeli plik AIDL jest u偶ywany przez plik "
"binarny dostawcy\n"
"przegroda."

#: src/android/aidl/implementation.md:1
#, fuzzy
msgid "# Service Implementation"
msgstr "# Implementacja usugi"

#: src/android/aidl/implementation.md:3
#, fuzzy
msgid "We can now implement the AIDL service:"
msgstr "Mo偶emy teraz wdro偶y usug AIDL:"

#: src/android/aidl/implementation.md:5
#, fuzzy
msgid "*birthday_service/src/lib.rs*:"
msgstr "*birthday_service/src/lib.rs*:"

#: src/android/aidl/implementation.md:7
msgid ""
"```rust,ignore\n"
"//! Implementation of the `IBirthdayService` AIDL interface.\n"
"use "
"com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;\n"
"use com_example_birthdayservice::binder;"
msgstr ""

#: src/android/aidl/implementation.md:12
msgid "/// The `IBirthdayService` implementation.\npub struct BirthdayService;"
msgstr ""

#: src/android/aidl/implementation.md:15
#, fuzzy
msgid "impl binder::Interface for BirthdayService {}"
msgstr "impl binder::Interfejs dla BirthdayService {}"

#: src/android/aidl/implementation.md:17
msgid ""
"impl IBirthdayService for BirthdayService {\n"
"    fn wishHappyBirthday(&self, name: &str, years: i32) -> "
"binder::Result<String> {\n"
"        Ok(format!(\n"
"            \"Happy Birthday {name}, congratulations with the {years} "
"years!\"\n"
"        ))\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/implementation.md:26 src/android/aidl/server.md:28 src/android/aidl/client.md:37
#, fuzzy
msgid "*birthday_service/Android.bp*:"
msgstr "*birthday_service/Android.bp*:"

#: src/android/aidl/implementation.md:28
msgid ""
"```javascript\n"
"rust_library {\n"
"    name: \"libbirthdayservice\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    crate_name: \"birthdayservice\",\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/server.md:1
#, fuzzy
msgid "# AIDL Server"
msgstr "# Serwer AIDL"

#: src/android/aidl/server.md:3
#, fuzzy
msgid "Finally, we can create a server which exposes the service:"
msgstr "Na koniec mo偶emy stworzy serwer, kt贸ry eksponuje usug:"

#: src/android/aidl/server.md:5
#, fuzzy
msgid "*birthday_service/src/server.rs*:"
msgstr "*birthday_service/src/server.rs*:"

#: src/android/aidl/server.md:7
msgid ""
"```rust,ignore\n"
"//! Birthday service.\n"
"use birthdayservice::BirthdayService;\n"
"use "
"com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::BnBirthdayService;\n"
"use com_example_birthdayservice::binder;"
msgstr ""

#: src/android/aidl/server.md:13 src/android/aidl/client.md:12
msgid "const SERVICE_IDENTIFIER: &str = \"birthdayservice\";"
msgstr ""

#: src/android/aidl/server.md:15
msgid ""
"/// Entry point for birthday service.\n"
"fn main() {\n"
"    let birthday_service = BirthdayService;\n"
"    let birthday_service_binder = BnBirthdayService::new_binder(\n"
"        birthday_service,\n"
"        binder::BinderFeatures::default(),\n"
"    );\n"
"    binder::add_service(SERVICE_IDENTIFIER, "
"birthday_service_binder.as_binder())\n"
"        .expect(\"Failed to register service\");\n"
"    binder::ProcessState::join_thread_pool()\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/server.md:30
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_server\",\n"
"    crate_name: \"birthday_server\",\n"
"    srcs: [\"src/server.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"        \"libbirthdayservice\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:1
#, fuzzy
msgid "# Deploy"
msgstr "# Wdro偶y"

#: src/android/aidl/deploy.md:3
#, fuzzy
msgid "We can now build, push, and start the service:"
msgstr "Mo偶emy teraz zbudowa, wypchn i uruchomi usug:"

#: src/android/aidl/deploy.md:5
msgid ""
"```shell\n"
"$ m birthday_server\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/tmp\n"
"$ adb shell /data/local/tmp/birthday_server\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:11
#, fuzzy
msgid "In another terminal, check that the service runs:"
msgstr "W innym terminalu sprawd藕, czy usuga dziaa:"

#: src/android/aidl/deploy.md:13
msgid ""
"```shell\n"
"$ adb shell service check birthdayservice\n"
"Service birthdayservice: found\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:18
#, fuzzy
msgid "You can also call the service with `service call`:"
msgstr "Mo偶esz r贸wnie偶 zadzwoni do serwisu za pomoc `wezwania serwisowego`:"

#: src/android/aidl/deploy.md:20
msgid ""
"```shell\n"
"$ $ adb shell service call birthdayservice 1 s16 Bob i32 24\n"
"Result: Parcel(\n"
"  0x00000000: 00000000 00000036 00610048 00700070 '....6...H.a.p.p.'\n"
"  0x00000010: 00200079 00690042 00740072 00640068 'y. .B.i.r.t.h.d.'\n"
"  0x00000020: 00790061 00420020 0062006f 0020002c 'a.y. .B.o.b.,. .'\n"
"  0x00000030: 006f0063 0067006e 00610072 00750074 'c.o.n.g.r.a.t.u.'\n"
"  0x00000040: 0061006c 00690074 006e006f 00200073 'l.a.t.i.o.n.s. .'\n"
"  0x00000050: 00690077 00680074 00740020 00650068 'w.i.t.h. .t.h.e.'\n"
"  0x00000060: 00320020 00200034 00650079 00720061 ' .2.4. .y.e.a.r.'\n"
"  0x00000070: 00210073 00000000                   's.!.....        ')\n"
"```"
msgstr ""

#: src/android/aidl/client.md:1
#, fuzzy
msgid "# AIDL Client"
msgstr "# Klient AIDL"

#: src/android/aidl/client.md:3
#, fuzzy
msgid "Finally, we can create a Rust client for our new service."
msgstr "Wreszcie mo偶emy stworzy klienta Rust dla naszej nowej usugi."

#: src/android/aidl/client.md:5
#, fuzzy
msgid "*birthday_service/src/client.rs*:"
msgstr "*birthday_service/src/client.rs*:"

#: src/android/aidl/client.md:7
msgid ""
"```rust,ignore\n"
"//! Birthday service.\n"
"use "
"com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;\n"
"use com_example_birthdayservice::binder;"
msgstr ""

#: src/android/aidl/client.md:14
#, fuzzy
msgid ""
"/// Connect to the BirthdayService.\n"
"pub fn connect() -> Result<binder::Strong<dyn IBirthdayService>, "
"binder::StatusCode> {\n"
"    binder::get_interface(SERVICE_IDENTIFIER)\n"
"}"
msgstr ""
"/// Pocz si z usug BirthdayService.\n"
"pub fn connect() -> Wynik<binder::Strong<dyn IBirthdayService>, "
"binder::StatusCode> {\n"
"    binder::get_interface(SERVICE_IDENTIFIER)\n"
"}"

#: src/android/aidl/client.md:19
msgid ""
"/// Call the birthday service.\n"
"fn main() -> Result<(), binder::Status> {\n"
"    let name = std::env::args()\n"
"        .nth(1)\n"
"        .unwrap_or_else(|| String::from(\"Bob\"));\n"
"    let years = std::env::args()\n"
"        .nth(2)\n"
"        .and_then(|arg| arg.parse::<i32>().ok())\n"
"        .unwrap_or(42);"
msgstr ""

#: src/android/aidl/client.md:29
msgid ""
"    binder::ProcessState::start_thread_pool();\n"
"    let service = connect().expect(\"Failed to connect to "
"BirthdayService\");\n"
"    let msg = service.wishHappyBirthday(&name, years)?;\n"
"    println!(\"{msg}\");\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/client.md:39
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_client\",\n"
"    crate_name: \"birthday_client\",\n"
"    srcs: [\"src/client.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/client.md:52
#, fuzzy
msgid "Notice that the client does not depend on `libbirthdayservice`."
msgstr "Zauwa偶, 偶e klient nie jest zale偶ny od `libbirthdayservice`."

#: src/android/aidl/client.md:54
#, fuzzy
msgid "Build, push, and run the client on your device:"
msgstr "Zbuduj, wypchnij i uruchom klienta na swoim urzdzeniu:"

#: src/android/aidl/client.md:56
msgid ""
"```shell\n"
"$ m birthday_client\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/birthday_client /data/local/tmp\n"
"$ adb shell /data/local/tmp/birthday_client Charlie 60\n"
"Happy Birthday Charlie, congratulations with the 60 years!\n"
"```"
msgstr ""

#: src/android/aidl/changing.md:1
#, fuzzy
msgid "# Changing API"
msgstr "# Zmiana API"

#: src/android/aidl/changing.md:3
#, fuzzy
msgid ""
"Let us extend the API with more functionality: we want to let clients "
"specify a\n"
"list of lines for the birthday card:"
msgstr ""
"Rozszerzmy API o wicej funkcji: chcemy pozwoli klientom okreli\n"
"lista wierszy na kartk urodzinow:"

#: src/android/aidl/changing.md:9
msgid ""
"/** Birthday service interface. */\n"
"interface IBirthdayService {\n"
"    /** Generate a Happy Birthday message. */\n"
"    String wishHappyBirthday(String name, int years, in String[] text);\n"
"}\n"
"```"
msgstr ""

#: src/android/logging.md:1
#, fuzzy
msgid "# Logging"
msgstr "# Logowanie"

#: src/android/logging.md:3
#, fuzzy
msgid ""
"You should use the `log` crate to automatically log to `logcat` (on-device) "
"or\n"
"`stdout` (on-host):"
msgstr ""
"Powiniene u偶y skrzynki `log`, aby automatycznie zalogowa si do `logcat` "
"(na urzdzeniu) lub\n"
"`stdout` (na hocie):"

#: src/android/logging.md:6
#, fuzzy
msgid "_hello_rust_logs/Android.bp_:"
msgstr "_hello_rust_logs/Android.bp_:"

#: src/android/logging.md:8
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_logs\",\n"
"    crate_name: \"hello_rust_logs\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"liblog_rust\",\n"
"        \"liblogger\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"    host_supported: true,\n"
"}\n"
"```"
msgstr ""

#: src/android/logging.md:22
#, fuzzy
msgid "_hello_rust_logs/src/main.rs_:"
msgstr "_hello_rust_logs/src/main.rs_:"

#: src/android/logging.md:24
msgid "```rust,ignore\n//! Rust logging demo."
msgstr ""

#: src/android/logging.md:27
msgid "use log::{debug, error, info};"
msgstr ""

#: src/android/logging.md:29
msgid ""
"/// Logs a greeting.\n"
"fn main() {\n"
"    logger::init(\n"
"        logger::Config::default()\n"
"            .with_tag_on_device(\"rust\")\n"
"            .with_min_level(log::Level::Trace),\n"
"    );\n"
"    debug!(\"Starting program.\");\n"
"    info!(\"Things are going fine.\");\n"
"    error!(\"Something went wrong!\");\n"
"}\n"
"```"
msgstr ""

#: src/android/logging.md:42 src/android/interoperability/with-c/bindgen.md:98
#: src/android/interoperability/with-c/rust.md:73
#, fuzzy
msgid "Build, push, and run the binary on your device:"
msgstr "Zbuduj, wypchnij i uruchom plik binarny na swoim urzdzeniu:"

#: src/android/logging.md:44
msgid ""
"```shell\n"
"$ m hello_rust_logs\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust_logs\n"
"```"
msgstr ""

#: src/android/logging.md:50
#, fuzzy
msgid "The logs show up in `adb logcat`:"
msgstr "Dzienniki pojawiaj si w `adb logcat`:"

#: src/android/logging.md:52
msgid ""
"```shell\n"
"$ adb logcat -s rust\n"
"09-08 08:38:32.454  2420  2420 D rust: hello_rust_logs: Starting program.\n"
"09-08 08:38:32.454  2420  2420 I rust: hello_rust_logs: Things are going "
"fine.\n"
"09-08 08:38:32.454  2420  2420 E rust: hello_rust_logs: Something went "
"wrong!\n"
"```"
msgstr ""

#: src/android/interoperability.md:1
#, fuzzy
msgid "# Interoperability"
msgstr "# Interoperacyjno"

#: src/android/interoperability.md:3
#, fuzzy
msgid ""
"Rust has excellent support for interoperability with other languages. This "
"means\n"
"that you can:"
msgstr ""
"Rust ma doskonae wsparcie dla interoperacyjnoci z innymi jzykami. To "
"znaczy\n"
"偶e mo偶esz:"

#: src/android/interoperability.md:6
#, fuzzy
msgid ""
"* Call Rust functions from other languages.\n"
"* Call functions written in other languages from Rust."
msgstr ""
"* Wywoaj funkcje Rust z innych jzyk贸w.\n"
"* Funkcje wywoania napisane w innych jzykach z Rust."

#: src/android/interoperability.md:9
#, fuzzy
msgid ""
"When you call functions in a foreign language we say that you're using a\n"
"_foreign function interface_, also known as FFI."
msgstr ""
"Kiedy wywoujesz funkcje w jzyku obcym, m贸wimy, 偶e u偶ywasz a\n"
"_interfejs funkcji obcych_, znany r贸wnie偶 jako FFI."

#: src/android/interoperability/with-c.md:1
#, fuzzy
msgid "# Interoperability with C"
msgstr "# Interoperacyjno z C"

#: src/android/interoperability/with-c.md:3
#, fuzzy
msgid ""
"Rust has full support for linking object files with a C calling convention.\n"
"Similarly, you can export Rust functions and call them from C."
msgstr ""
"Rust ma pene wsparcie dla czenia plik贸w obiektowych z konwencj "
"wywoywania C.\n"
"Podobnie mo偶esz eksportowa funkcje Rust i wywoywa je z C."

#: src/android/interoperability/with-c.md:6
#, fuzzy
msgid "You can do it by hand if you want:"
msgstr "Mo偶esz to zrobi rcznie, jeli chcesz:"

#: src/android/interoperability/with-c.md:8
msgid ""
"```rust\n"
"extern \"C\" {\n"
"    fn abs(x: i32) -> i32;\n"
"}"
msgstr ""

#: src/android/interoperability/with-c.md:13
msgid ""
"fn main() {\n"
"    let x = -42;\n"
"    let abs_x = unsafe { abs(x) };\n"
"    println!(\"{x}, {abs_x}\");\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c.md:20
#, fuzzy
msgid ""
"We already saw this in the [Safe FFI Wrapper\n"
"exercise](../../exercises/day-3/safe-ffi-wrapper.md)."
msgstr ""
"Widzielimy to ju偶 w [Safe FFI Wrapper\n"
"wiczenie](../../wiczenia/dzie-3/safe-ffi-wrapper.md)."

#: src/android/interoperability/with-c.md:23
#, fuzzy
msgid ""
"> This assumes full knowledge of the target platform. Not recommended for\n"
"> production."
msgstr ""
"> Zakada to pen znajomo platformy docelowej. Nie zalecane dla\n"
"> produkcja."

#: src/android/interoperability/with-c.md:26
#, fuzzy
msgid "We will look at better options next."
msgstr "W nastpnej kolejnoci przyjrzymy si lepszym opcjom."

#: src/android/interoperability/with-c/bindgen.md:1
#, fuzzy
msgid "# Using Bindgen"
msgstr "Korzystanie z Cargo"

#: src/android/interoperability/with-c/bindgen.md:3
#, fuzzy
msgid ""
"The [bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html) "
"tool\n"
"can auto-generate bindings from a C header file."
msgstr ""
"Narzdzie "
"[bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html)\n"
"mo偶e automatycznie generowa powizania z pliku nag贸wkowego C."

#: src/android/interoperability/with-c/bindgen.md:6
#, fuzzy
msgid "First create a small C library:"
msgstr "Najpierw utw贸rz ma bibliotek C:"

#: src/android/interoperability/with-c/bindgen.md:8
#, fuzzy
msgid "_interoperability/bindgen/libbirthday.h_:"
msgstr "_interoperability/bindgen/libbirthday.h_:"

#: src/android/interoperability/with-c/bindgen.md:10
msgid ""
"```c\n"
"typedef struct card {\n"
"  const char* name;\n"
"  int years;\n"
"} card;"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:16
msgid "void print_card(const card* card);\n```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:19
#, fuzzy
msgid "_interoperability/bindgen/libbirthday.c_:"
msgstr "_interoperability/bindgen/libbirthday.c_:"

#: src/android/interoperability/with-c/bindgen.md:21
msgid ""
"```c\n"
"#include <stdio.h>\n"
"#include \"libbirthday.h\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:25
msgid ""
"void print_card(const card* card) {\n"
"  printf(\"+--------------\\n"
"\");\n"
"  printf(\"| Happy Birthday %s!\\n"
"\", card->name);\n"
"  printf(\"| Congratulations with the %i years!\\n"
"\", card->years);\n"
"  printf(\"+--------------\\n"
"\");\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:33
#, fuzzy
msgid "Add this to your `Android.bp` file:"
msgstr "Dodaj to do swojego pliku `Android.bp`:"

#: src/android/interoperability/with-c/bindgen.md:35
#: src/android/interoperability/with-c/bindgen.md:55
#: src/android/interoperability/with-c/bindgen.md:69
#: src/android/interoperability/with-c/bindgen.md:108
#, fuzzy
msgid "_interoperability/bindgen/Android.bp_:"
msgstr "_interoperacyjno/bindgen/Android.bp_:"

#: src/android/interoperability/with-c/bindgen.md:37
msgid ""
"```javascript\n"
"cc_library {\n"
"    name: \"libbirthday\",\n"
"    srcs: [\"libbirthday.c\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:44
#, fuzzy
msgid ""
"Create a wrapper header file for the library (not strictly needed in this\n"
"example):"
msgstr ""
"Utw贸rz plik nag贸wkowy opakowania dla biblioteki (nie jest to bezwzgldnie "
"potrzebne w tym przypadku\n"
"przykad):"

#: src/android/interoperability/with-c/bindgen.md:47
#, fuzzy
msgid "_interoperability/bindgen/libbirthday_wrapper.h_:"
msgstr "_interoperability/bindgen/libbirthday_wrapper.h_:"

#: src/android/interoperability/with-c/bindgen.md:49
msgid ""
"```c\n"
"#include \"libbirthday.h\"\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:53
#, fuzzy
msgid "You can now auto-generate the bindings:"
msgstr "Mo偶esz teraz automatycznie generowa powizania:"

#: src/android/interoperability/with-c/bindgen.md:57
msgid ""
"```javascript\n"
"rust_bindgen {\n"
"    name: \"libbirthday_bindgen\",\n"
"    crate_name: \"birthday_bindgen\",\n"
"    wrapper_src: \"libbirthday_wrapper.h\",\n"
"    source_stem: \"bindings\",\n"
"    static_libs: [\"libbirthday\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:67
#, fuzzy
msgid "Finally, we can use the bindings in our Rust program:"
msgstr "Na koniec mo偶emy u偶y powiza w naszym programie Rust:"

#: src/android/interoperability/with-c/bindgen.md:71
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"print_birthday_card\",\n"
"    srcs: [\"main.rs\"],\n"
"    rustlibs: [\"libbirthday_bindgen\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:79
#, fuzzy
msgid "_interoperability/bindgen/main.rs_:"
msgstr "_interoperacyjno/bindgen/main.rs_:"

#: src/android/interoperability/with-c/bindgen.md:81
msgid "```rust,compile_fail\n//! Bindgen demo."
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:84
msgid "use birthday_bindgen::{card, print_card};"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:86
msgid ""
"fn main() {\n"
"    let name = std::ffi::CString::new(\"Peter\").unwrap();\n"
"    let card = card {\n"
"        name: name.as_ptr(),\n"
"        years: 42,\n"
"    };\n"
"    unsafe {\n"
"        print_card(&card as *const card);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:100
msgid ""
"```shell\n"
"$ m print_birthday_card\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/print_birthday_card "
"/data/local/tmp\n"
"$ adb shell /data/local/tmp/print_birthday_card\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:106
#, fuzzy
msgid "Finally, we can run auto-generated tests to ensure the bindings work:"
msgstr ""
"Na koniec mo偶emy uruchomi automatycznie generowane testy, aby upewni si, "
"偶e powizania dziaaj:"

#: src/android/interoperability/with-c/bindgen.md:110
msgid ""
"```javascript\n"
"rust_test {\n"
"    name: \"libbirthday_bindgen_test\",\n"
"    srcs: [\":libbirthday_bindgen\"],\n"
"    crate_name: \"libbirthday_bindgen_test\",\n"
"    test_suites: [\"general-tests\"],\n"
"    auto_gen_config: true,\n"
"    clippy_lints: \"none\", // Generated file, skip linting\n"
"    lints: \"none\",\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:122
msgid ""
"```shell\n"
"$ atest libbirthday_bindgen_test\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:1
#, fuzzy
msgid "# Calling Rust"
msgstr "Ekosystem Rust"

#: src/android/interoperability/with-c/rust.md:3
#, fuzzy
msgid "Exporting Rust functions and types to C is easy:"
msgstr "Eksportowanie funkcji i typ贸w Rust do C jest atwe:"

#: src/android/interoperability/with-c/rust.md:5
#, fuzzy
msgid "_interoperability/rust/libanalyze/analyze.rs_"
msgstr "_interoperability/rust/libanalyze/analyze.rs_"

#: src/android/interoperability/with-c/rust.md:7
msgid ""
"```rust,editable\n"
"//! Rust FFI demo.\n"
"#![deny(improper_ctypes_definitions)]"
msgstr ""

#: src/android/interoperability/with-c/rust.md:11
msgid "use std::os::raw::c_int;"
msgstr ""

#: src/android/interoperability/with-c/rust.md:13
msgid ""
"/// Analyze the numbers.\n"
"#[no_mangle]\n"
"pub extern \"C\" fn analyze_numbers(x: c_int, y: c_int) {\n"
"    if x < y {\n"
"        println!(\"x ({x}) is smallest!\");\n"
"    } else {\n"
"        println!(\"y ({y}) is probably larger than x ({x})\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:24
#, fuzzy
msgid "_interoperability/rust/libanalyze/analyze.h_"
msgstr "_interoperability/rust/libanalyze/analyze.h_"

#: src/android/interoperability/with-c/rust.md:26
msgid ""
"```c\n"
"#ifndef ANALYSE_H\n"
"#define ANALYSE_H"
msgstr ""

#: src/android/interoperability/with-c/rust.md:30
msgid ""
"extern \"C\" {\n"
"void analyze_numbers(int x, int y);\n"
"}"
msgstr ""

#: src/android/interoperability/with-c/rust.md:34
msgid "#endif\n```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:37
#, fuzzy
msgid "_interoperability/rust/libanalyze/Android.bp_"
msgstr "_interoperacyjno/rust/libanalyze/Android.bp_"

#: src/android/interoperability/with-c/rust.md:39
msgid ""
"```javascript\n"
"rust_ffi {\n"
"    name: \"libanalyze_ffi\",\n"
"    crate_name: \"analyze_ffi\",\n"
"    srcs: [\"analyze.rs\"],\n"
"    include_dirs: [\".\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:48
#, fuzzy
msgid "We can now call this from a C binary:"
msgstr "Mo偶emy teraz wywoa to z pliku binarnego C:"

#: src/android/interoperability/with-c/rust.md:50
#, fuzzy
msgid "_interoperability/rust/analyze/main.c_"
msgstr "_interoperacyjno/rust/analiza/main.c_"

#: src/android/interoperability/with-c/rust.md:52
msgid "```c\n#include \"analyze.h\""
msgstr ""

#: src/android/interoperability/with-c/rust.md:55
msgid ""
"int main() {\n"
"  analyze_numbers(10, 20);\n"
"  analyze_numbers(123, 123);\n"
"  return 0;\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:62
#, fuzzy
msgid "_interoperability/rust/analyze/Android.bp_"
msgstr "_interoperacyjno/rust/analyze/Android.bp_"

#: src/android/interoperability/with-c/rust.md:64
msgid ""
"```javascript\n"
"cc_binary {\n"
"    name: \"analyze_numbers\",\n"
"    srcs: [\"main.c\"],\n"
"    static_libs: [\"libanalyze_ffi\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:75
msgid ""
"```shell\n"
"$ m analyze_numbers\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/analyze_numbers /data/local/tmp\n"
"$ adb shell /data/local/tmp/analyze_numbers\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:83
#, fuzzy
msgid ""
"`#[no_mangle]` disables Rust's usual name mangling, so the exported symbol "
"will just be the name of\n"
"the function. You can also use `#[export_name = \"some_name\"]` to specify "
"whatever name you want."
msgstr ""
"`#[no_mangle]` wycza zwyke znieksztacanie nazw Rusta, wic eksportowany "
"symbol bdzie po prostu nazw\n"
"funkcja. Mo偶esz tak偶e u偶y `#[nazwa_eksportu = \"jaka_nazwa\"]`, aby "
"okreli dowoln nazw."

#: src/android/interoperability/cpp.md:1
#, fuzzy
msgid "# With C++"
msgstr "# Z C++"

#: src/android/interoperability/cpp.md:3
#, fuzzy
msgid ""
"The [CXX crate][1] makes it possible to do safe interoperability between "
"Rust\n"
"and C++."
msgstr ""
"[Skrzynia CXX][1] umo偶liwia bezpieczn interoperacyjno midzy Rust\n"
"i C++."

#: src/android/interoperability/cpp.md:6
#, fuzzy
msgid "The overall approach looks like this:"
msgstr "Og贸lne podejcie wyglda nastpujco:"

#: src/android/interoperability/cpp.md:8
#, fuzzy
msgid "<img src=\"cpp/overview.svg\">"
msgstr "<img src=\"cpp/overview.svg\">"

#: src/android/interoperability/cpp.md:10
#, fuzzy
msgid "See the [CXX tutorial][2] for an full example of using this."
msgstr ""
"Zobacz [samouczek CXX][2], aby zapozna si z penym przykadem u偶ycia tego."

#: src/android/interoperability/cpp.md:12
#, fuzzy
msgid "[1]: https://cxx.rs/\n[2]: https://cxx.rs/tutorial.html"
msgstr "[1]: https://cxx.rs/\n[2]: https://cxx.rs/tutorial.html"

#: src/android/interoperability/java.md:1
#, fuzzy
msgid "# Interoperability with Java"
msgstr "# Wsp贸praca z Jav"

#: src/android/interoperability/java.md:3
#, fuzzy
msgid ""
"Java can load shared objects via [Java Native Interface\n"
"(JNI)](https://en.wikipedia.org/wiki/Java_Native_Interface). The [`jni`\n"
"crate](https://docs.rs/jni/) allows you to create a compatible library."
msgstr ""
"Java mo偶e adowa udostpnione obiekty za porednictwem [Java Native "
"Interface\n"
"(JNI)](https://en.wikipedia.org/wiki/Java_Native_Interface). [`jni`\n"
"crate](https://docs.rs/jni/) umo偶liwia utworzenie kompatybilnej biblioteki."

#: src/android/interoperability/java.md:7
#, fuzzy
msgid "First, we create a Rust function to export to Java:"
msgstr "Najpierw tworzymy funkcj Rust do eksportu do Javy:"

#: src/android/interoperability/java.md:9
#, fuzzy
msgid "_interoperability/java/src/lib.rs_:"
msgstr "_interoperacyjno/java/src/lib.rs_:"

#: src/android/interoperability/java.md:11
msgid "```rust,compile_fail\n//! Rust <-> Java FFI demo."
msgstr ""

#: src/android/interoperability/java.md:14
msgid ""
"use jni::objects::{JClass, JString};\n"
"use jni::sys::jstring;\n"
"use jni::JNIEnv;"
msgstr ""

#: src/android/interoperability/java.md:18
msgid ""
"/// HelloWorld::hello method implementation.\n"
"#[no_mangle]\n"
"pub extern \"system\" fn Java_HelloWorld_hello(\n"
"    env: JNIEnv,\n"
"    _class: JClass,\n"
"    name: JString,\n"
") -> jstring {\n"
"    let input: String = env.get_string(name).unwrap().into();\n"
"    let greeting = format!(\"Hello, {input}!\");\n"
"    let output = env.new_string(greeting).unwrap();\n"
"    output.into_inner()\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:32 src/android/interoperability/java.md:62
#, fuzzy
msgid "_interoperability/java/Android.bp_:"
msgstr "_interoperacyjno/java/Android.bp_:"

#: src/android/interoperability/java.md:34
msgid ""
"```javascript\n"
"rust_ffi_shared {\n"
"    name: \"libhello_jni\",\n"
"    crate_name: \"hello_jni\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    rustlibs: [\"libjni\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:43
#, fuzzy
msgid "Finally, we can call this function from Java:"
msgstr "Na koniec mo偶emy wywoa t funkcj z Javy:"

#: src/android/interoperability/java.md:45
#, fuzzy
msgid "_interoperability/java/HelloWorld.java_:"
msgstr "_interoperacyjno/java/HelloWorld.java_:"

#: src/android/interoperability/java.md:47
msgid ""
"```java\n"
"class HelloWorld {\n"
"    private static native String hello(String name);"
msgstr ""

#: src/android/interoperability/java.md:51
msgid ""
"    static {\n"
"        System.loadLibrary(\"hello_jni\");\n"
"    }"
msgstr ""

#: src/android/interoperability/java.md:55
msgid ""
"    public static void main(String[] args) {\n"
"        String output = HelloWorld.hello(\"Alice\");\n"
"        System.out.println(output);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:64
msgid ""
"```javascript\n"
"java_binary {\n"
"    name: \"helloworld_jni\",\n"
"    srcs: [\"HelloWorld.java\"],\n"
"    main_class: \"HelloWorld\",\n"
"    required: [\"libhello_jni\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:73
#, fuzzy
msgid "Finally, you can build, sync, and run the binary:"
msgstr "Na koniec mo偶esz zbudowa, zsynchronizowa i uruchomi plik binarny:"

#: src/android/interoperability/java.md:75
msgid ""
"```shell\n"
"$ m helloworld_jni\n"
"$ adb sync  # requires adb root && adb remount\n"
"$ adb shell /system/bin/helloworld_jni\n"
"```"
msgstr ""

#: src/exercises/day-4/afternoon.md:3
#, fuzzy
msgid ""
"For the last exercise, we will look at one of the projects you work with. "
"Let us\n"
"group up and do this together. Some suggestions:"
msgstr ""
"W ostatnim wiczeniu przyjrzymy si jednemu z projekt贸w, nad kt贸rymi "
"pracujesz. Pozw贸l nam\n"
"zbierzcie si i zr贸bcie to razem. Jakie sugestie:"

#: src/exercises/day-4/afternoon.md:6
#, fuzzy
msgid "* Call your AIDL service with a client written in Rust."
msgstr "* Zadzwo do swojego serwisu AIDL z klientem napisanym w Rust."

#: src/exercises/day-4/afternoon.md:8
#, fuzzy
msgid "* Move a function from your project to Rust and call it."
msgstr "* Przenie funkcj z projektu do Rusta i wywoaj j."

#: src/exercises/day-4/afternoon.md:12
#, fuzzy
msgid ""
"No solution is provided here since this is open-ended: it relies on someone "
"in\n"
"the class having a piece of code which you can turn in to Rust on the fly."
msgstr ""
"Nie podano tutaj 偶adnego rozwizania, poniewa偶 jest ono otwarte: polega na "
"kim w\n"
"klasa posiadajca fragment kodu, kt贸ry mo偶na przekaza Rustowi w locie."

#: src/thanks.md:1
#, fuzzy
msgid "# Thanks!"
msgstr "# Dziki!"

#: src/thanks.md:3
#, fuzzy
msgid ""
"_Thank you for taking Comprehensive Rust !_ We hope you enjoyed it and that "
"it\n"
"was useful."
msgstr ""
"_Dzikujemy za skorzystanie z Comprehensive Rust !_ Mamy nadziej, 偶e Ci "
"si podobao i 偶e tak\n"
"byo przydatne."

#: src/thanks.md:6
#, fuzzy
msgid ""
"We've had a lot of fun putting the course together. The course is not "
"perfect,\n"
"so if you spotted any mistakes or have ideas for improvements, please get "
"in\n"
"[contact with us on\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). We would "
"love\n"
"to hear from you."
msgstr ""
"wietnie si bawilimy przygotowujc kurs. Kurs nie jest doskonay,\n"
"wic jeli zauwa偶ye jakie bdy lub masz pomysy na ulepszenia, wejd藕\n"
"[kontakt z nami na\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). "
"Kochalibymy si\n"
"usysze od ciebie."

#: src/other-resources.md:1
msgid "# Other Rust Resources"
msgstr "# Inne 藕r贸da o Rucie"

#: src/other-resources.md:3
#, fuzzy
msgid ""
"The Rust community has created a wealth of high-quality and free resources\n"
"online."
msgstr ""
"Spoeczno Rust stworzya bogactwo wysokiej jakoci i bezpatnych zasob贸w\n"
"online."

#: src/other-resources.md:6
#, fuzzy
msgid "## Official Documentation"
msgstr "## Oficjalna dokumentacja"

#: src/other-resources.md:8
#, fuzzy
msgid "The Rust project hosts many resources. These cover Rust in general:"
msgstr "Projekt Rust zawiera wiele zasob贸w. Obejmuj one og贸lnie Rusta:"

#: src/other-resources.md:10
#, fuzzy
msgid ""
"* [The Rust Programming Language](https://doc.rust-lang.org/book/): the\n"
"  canonical free book about Rust. Covers the language in detail and includes "
"a\n"
"  few projects for people to build.\n"
"* [Rust By Example](https://doc.rust-lang.org/rust-by-example/): covers the "
"Rust\n"
"  syntax via a series of examples which showcase different constructs. "
"Sometimes\n"
"  includes small exercises where you are asked to expand on the code in the\n"
"  examples.\n"
"* [Rust Standard Library](https://doc.rust-lang.org/std/): full "
"documentation of\n"
"  the standard library for Rust.\n"
"* [The Rust Reference](https://doc.rust-lang.org/reference/): an incomplete "
"book\n"
"  which describes the Rust grammar and memory model."
msgstr ""
"* [Jzyk programowania Rust](https://doc.rust-lang.org/book/): the\n"
"  kanoniczna darmowa ksi偶ka o Rust. Szczeg贸owo omawia jzyk i zawiera "
"m.in\n"
"  kilka projekt贸w dla ludzi do zbudowania.\n"
"* [Rust By Example](https://doc.rust-lang.org/rust-by-example/): obejmuje "
"Rust\n"
"  skadni za pomoc serii przykad贸w prezentujcych r贸偶ne konstrukcje. "
"Czasami\n"
"  zawiera mae wiczenia, w kt贸rych jeste proszony o rozwinicie kodu w\n"
"  przykady.\n"
"* [Biblioteka standardowa Rust](https://doc.rust-lang.org/std/): pena "
"dokumentacja\n"
"  standardowa biblioteka dla Rusta.\n"
"* [The Rust Reference](https://doc.rust-lang.org/reference/): niekompletna "
"ksi偶ka\n"
"  kt贸ry opisuje gramatyk i model pamici Rusta."

#: src/other-resources.md:22
#, fuzzy
msgid "More specialized guides hosted on the official Rust site:"
msgstr ""
"Bardziej wyspecjalizowane przewodniki dostpne na oficjalnej stronie Rusta:"

#: src/other-resources.md:24
#, fuzzy
msgid ""
"* [The Rustonomicon](https://doc.rust-lang.org/nomicon/): covers unsafe "
"Rust,\n"
"  including working with raw pointers and interfacing with other languages\n"
"  (FFI).\n"
"* [Asynchronous Programming in "
"Rust](https://rust-lang.github.io/async-book/):\n"
"  covers the new asynchronous programming model which was introduced after "
"the\n"
"  Rust Book was written.\n"
"* [The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): "
"an\n"
"  introduction to using Rust on embedded devices without an operating system."
msgstr ""
"* [The Rustonomicon](https://doc.rust-lang.org/nomicon/): obejmuje "
"niebezpieczn Rust,\n"
"  w tym praca z surowymi wska藕nikami i czenie z innymi jzykami\n"
"  (FFI).\n"
"* [Programowanie asynchroniczne w "
"Rust](https://rust-lang.github.io/async-book/):\n"
"  obejmuje nowy model programowania asynchronicznego, kt贸ry zosta "
"wprowadzony po\n"
"  Ksiga rdzy zostaa napisana.\n"
"* [The Embedded Rust "
"Book](https://doc.rust-lang.org/stable/embedded-book/):\n"
"  wprowadzenie do u偶ywania Rusta na urzdzeniach wbudowanych bez systemu "
"operacyjnego."

#: src/other-resources.md:33
#, fuzzy
msgid "## Unofficial Learning Material"
msgstr "## Nieoficjalny materia do nauki"

#: src/other-resources.md:35
#, fuzzy
msgid "A small selection of other guides and tutorial for Rust:"
msgstr "Niewielki wyb贸r innych przewodnik贸w i samouczk贸w dotyczcych Rusta:"

#: src/other-resources.md:37
#, fuzzy
msgid ""
"* [Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): covers "
"Rust\n"
"  from the perspective of low-level C programmers.\n"
"* [Rust for Embedded C\n"
"  Programmers](https://docs.opentitan.org/doc/ug/rust_for_c/): covers Rust "
"from\n"
"  the perspective of developers who write firmware in C.\n"
"* [Rust for professionals](https://overexact.com/rust-for-professionals/):\n"
"  covers the syntax of Rust using side-by-side comparisons with other "
"languages\n"
"  such as C, C++, Java, JavaScript, and Python.\n"
"* [Rust on Exercism](https://exercism.org/tracks/rust): 100+ exercises to "
"help\n"
"  you learn Rust.\n"
"* [Ferrous Teaching\n"
"  Material](https://ferrous-systems.github.io/teaching-material/index.html): "
"a\n"
"  series of small presentations covering both basic and advanced part of "
"the\n"
"  Rust language. Other topics such as WebAssembly, and async/await are also\n"
"  covered.\n"
"* [Beginner's Series to\n"
"  Rust](https://docs.microsoft.com/en-us/shows/beginners-series-to-rust/) "
"and\n"
"  [Take your first steps with\n"
"  Rust](https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/): "
"two\n"
"  Rust guides aimed at new developers. The first is a set of 35 videos and "
"the\n"
"  second is a set of 11 modules which covers Rust syntax and basic "
"constructs.\n"
"* [Learn Rust With Entirely Too Many Linked\n"
"  Lists](https://rust-unofficial.github.io/too-many-lists/): in-depth\n"
"  exploration of Rust's memory management rules, through implementing a few\n"
"  different types of list structures."
msgstr ""
"* [Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): obejmuje "
"Rust\n"
"  z perspektywy niskopoziomowych programist贸w C.\n"
"* [Rdza dla wbudowanego C\n"
"  Programici](https://docs.opentitan.org/doc/ug/rust_for_c/): obejmuje "
"Rusta z\n"
"  perspektywa programist贸w, kt贸rzy pisz firmware w C.\n"
"* [Rdza dla "
"profesjonalist贸w](https://overexact.com/rust-for-professionals/):\n"
"  obejmuje skadni jzyka Rust przy u偶yciu por贸wna side-by-side z innymi "
"jzykami\n"
"  takich jak C, C++, Java, JavaScript i Python.\n"
"* [Rust on Exercism](https://exercism.org/tracks/rust): ponad 100 wicze, "
"kt贸re pomog\n"
"  uczysz si Rusta.\n"
"* [呕elazne nauczanie\n"
"  Materia](https://ferrous-systems.github.io/teaching-material/index.html): "
"a\n"
"  seria maych prezentacji obejmujcych zar贸wno podstawow, jak i "
"zaawansowan cz\n"
"  Jzyk rdzy. Inne tematy, takie jak WebAssembly i "
"asynchronizacja/oczekiwanie, r贸wnie偶 s\n"
"  pokryty.\n"
"* [Seria dla pocztkujcych do\n"
"  Rust](https://docs.microsoft.com/en-us/shows/beginners-series-to-rust/) i\n"
"  [Zr贸b swoje pierwsze kroki z\n"
"  Rust](https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/): "
"dwa\n"
"  Przewodniki Rust skierowane do nowych programist贸w. Pierwszy to zestaw 35 "
"film贸w i\n"
"  drugi to zestaw 11 modu贸w, kt贸ry obejmuje skadni i podstawowe "
"konstrukcje Rusta.\n"
"* [Naucz si Rust z cakowicie zbyt wieloma linkami\n"
"  Listy](https://rust-unofficial.github.io/too-many-lists/): szczeg贸owe\n"
"  eksploracja regu zarzdzania pamici Rust, poprzez implementacj kilku\n"
"  r贸偶ne rodzaje struktur list."

#: src/other-resources.md:63
#, fuzzy
msgid ""
"Please see the [Little Book of Rust Books](https://lborb.github.io/book/) "
"for\n"
"even more Rust books."
msgstr ""
"Prosz zapozna si z [Little Book of Rust "
"Books](https://lborb.github.io/book/)\n"
"jeszcze wicej ksi偶ek Rust."

#: src/credits.md:1
#, fuzzy
msgid "# Credits"
msgstr "# Kredyty"

#: src/credits.md:3
#, fuzzy
msgid ""
"The material here builds on top of the many great sources of Rust "
"documentation.\n"
"See the page on [other resources](other-resources.md) for a full list of "
"useful\n"
"resources."
msgstr ""
"Materia tutaj opiera si na wielu wspaniaych 藕r贸dach dokumentacji Rusta.\n"
"Zobacz stron [inne zasoby](other-resources.md), aby uzyska pen list "
"przydatnych\n"
"zasoby."

#: src/credits.md:7
#, fuzzy
msgid ""
"The material of Comprehensive Rust is licensed under the terms of the Apache "
"2.0\n"
"license, please see [`LICENSE`](../LICENSE) for details."
msgstr ""
"Materia Comprehensive Rust jest objty licencj na warunkach Apache 2.0\n"
"licencji, zobacz [`LICENCJA`](../LICENCJA), aby uzyska szczeg贸owe "
"informacje."

#: src/credits.md:10
#, fuzzy
msgid "## Rust by Example"
msgstr "## Rust by Example"

#: src/credits.md:12
#, fuzzy
msgid ""
"Some examples and exercises have been copied and adapted from [Rust by\n"
"Example](https://doc.rust-lang.org/rust-by-example/). Please see the\n"
"`third_party/rust-by-example/` directory for details, including the license\n"
"terms."
msgstr ""
"Niekt贸re przykady i wiczenia zostay skopiowane i zaadaptowane z [Rust by\n"
"Przykad](https://doc.rust-lang.org/rust-by-example/). Prosz zobaczy\n"
"Katalog `third_party/rust-by-example/` zawiera szczeg贸owe informacje, w tym "
"licencj\n"
"warunki."

#: src/credits.md:17
#, fuzzy
msgid "## Rust on Exercism"
msgstr "## Rust on Exercism"

#: src/credits.md:19
#, fuzzy
msgid ""
"Some exercises have been copied and adapted from [Rust on\n"
"Exercism](https://exercism.org/tracks/rust). Please see the\n"
"`third_party/rust-on-exercism/` directory for details, including the "
"license\n"
"terms."
msgstr ""
"Niekt贸re wiczenia zostay skopiowane i zaadaptowane z [Rust on\n"
"wiczenia](https://exercism.org/tracks/rust). Prosz zobaczy\n"
"`third_party/rust-on-exercism/`, aby uzyska szczeg贸owe informacje, w tym "
"licencj\n"
"warunki."

#: src/credits.md:24
#, fuzzy
msgid "## CXX"
msgstr "## CXX"

#: src/credits.md:26
#, fuzzy
msgid ""
"The [Interoperability with C++](android/interoperability/cpp.md) section "
"uses an\n"
"image from [CXX](https://cxx.rs/). Please see the `third_party/cxx/` "
"directory\n"
"for details, including the license terms."
msgstr ""
"Sekcja [Interoperability with C++](android/interoperability/cpp.md) "
"wykorzystuje plik\n"
"obraz z [CXX](https://cxx.rs/). Zapoznaj si z katalogiem "
"`third_party/cxx/`\n"
"aby uzyska szczeg贸owe informacje, w tym warunki licencji."

#: src/exercises/solutions.md:1
#, fuzzy
msgid "# Solutions"
msgstr "# Rozwizania"

#: src/exercises/solutions.md:3
#, fuzzy
msgid "You will find solutions to the exercises on the following pages."
msgstr "Na kolejnych stronach znajdziesz rozwizania wicze."

#: src/exercises/solutions.md:5
#, fuzzy
msgid ""
"Feel free to ask questions about the solutions [on\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). Let us "
"know\n"
"if you have a different or better solution than what is presented here."
msgstr ""
"Zachcamy do zadawania pyta dotyczcych rozwiza [on\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). Daj nam "
"zna\n"
"jeli masz inne lub lepsze rozwizanie ni偶 przedstawione tutaj."

#: src/exercises/solutions.md:10
#, fuzzy
msgid ""
"> **Note:** Please ignore the `// ANCHOR: label` and `// ANCHOR_END: label`\n"
"> comments you see in the solutions. They are there to make it possible to\n"
"> re-use parts of the solutions as the exercises."
msgstr ""
"> **Uwaga:** prosz zignorowa `// ANCHOR: etykieta` i `// ANCHOR_END: "
"etykieta`\n"
"> komentarze, kt贸re widzisz w rozwizaniach. S po to, aby to umo偶liwi\n"
"> ponownie wykorzystaj czci rozwiza jako wiczenia."

#: src/exercises/day-1/solutions-morning.md:1
#, fuzzy
msgid "# Day 1 Morning Exercises"
msgstr "# Dzie 1 wiczenia poranne"

#: src/exercises/day-1/solutions-morning.md:3
#, fuzzy
msgid "## Arrays and `for` Loops"
msgstr "## Tablice i ptle `for`"

#: src/exercises/day-1/solutions-morning.md:5
msgid "([back to exercise](for-loops.md))"
msgstr "([powr贸t do wiczenia](for-loops.md))"

#: src/exercises/day-1/solutions-morning.md:7 src/exercises/day-1/solutions-afternoon.md:7
#: src/exercises/day-2/solutions-morning.md:7 src/exercises/day-2/solutions-afternoon.md:7
#: src/exercises/day-2/solutions-afternoon.md:102 src/exercises/day-3/solutions-morning.md:7
#: src/exercises/day-3/solutions-afternoon.md:7 src/exercises/day-4/solutions-morning.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License."
msgstr ""

#: src/exercises/day-1/solutions-morning.md:22
msgid ""
"// ANCHOR: transpose\n"
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    // ANCHOR_END: transpose\n"
"    let mut result = [[0; 3]; 3];\n"
"    for i in 0..3 {\n"
"        for j in 0..3 {\n"
"            result[j][i] = matrix[i][j];\n"
"        }\n"
"    }\n"
"    return result;\n"
"}"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:34
msgid ""
"// ANCHOR: pretty_print\n"
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    // ANCHOR_END: pretty_print\n"
"    for row in matrix {\n"
"        println!(\"{row:?}\");\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:42
msgid ""
"// ANCHOR: tests\n"
"#[test]\n"
"fn test_transpose() {\n"
"    let matrix = [\n"
"        [101, 102, 103], //\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"    let transposed = transpose(matrix);\n"
"    assert_eq!(\n"
"        transposed,\n"
"        [\n"
"            [101, 201, 301], //\n"
"            [102, 202, 302],\n"
"            [103, 203, 303],\n"
"        ]\n"
"    );\n"
"}\n"
"// ANCHOR_END: tests"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:62
msgid ""
"// ANCHOR: main\n"
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:73
msgid ""
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```\n"
"### Bonus question"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:80
#, fuzzy
msgid ""
"It requires more advanced concepts. It might seem that we could use a "
"slice-of-slices (`&[&[i32]]`) as the input type to transpose and thus make "
"our function handle any size of matrix. However, this quickly breaks down: "
"the return type cannot be `&[&[i32]]` since it needs to own the data you "
"return."
msgstr ""
"Wymaga bardziej zaawansowanych koncepcji. Mogoby si wydawa, 偶e moglibymy "
"u偶y wycinka plasterk贸w (`&[&[i32]]`) jako typu wejciowego do transpozycji, "
"a tym samym sprawi, by nasza funkcja obsugiwaa dowolny rozmiar macierzy. "
"Jednak to szybko si psuje: zwracany typ nie mo偶e by `&[&[i32]]`, poniewa偶 "
"musi by wacicielem zwracanych danych."

#: src/exercises/day-1/solutions-morning.md:82
#, fuzzy
msgid ""
"You can attempt to use something like `Vec<Vec<i32>>`, but this doesn't work "
"out-of-the-box either: it's hard to convert from `Vec<Vec<i32>>` to "
"`&[&[i32]]` so now you cannot easily use `pretty_print` either."
msgstr ""
"Mo偶esz spr贸bowa u偶y czego takiego jak `Vec<Vec<i32>>`, ale to te偶 nie "
"dziaa od razu po wyjciu z pudeka: trudno jest przekonwertowa z "
"`Vec<Vec<i32>>` na `&[ &[i32]]`, wic teraz nie mo偶esz te偶 atwo u偶ywa "
"`pretty_print`."

#: src/exercises/day-1/solutions-morning.md:84
#, fuzzy
msgid ""
"Once we get to traits and generics, we'll be able to use the "
"[`std::convert::AsRef`][1] trait to abstract over anything that can be "
"referenced as a slice."
msgstr ""
"Gdy przejdziemy do cech i typ贸w og贸lnych, bdziemy mogli u偶y cechy "
"[`std::convert::AsRef`][1] do abstrakcji na wszystkim, co mo偶na nazwa "
"plasterkiem."

#: src/exercises/day-1/solutions-morning.md:86
msgid ""
"```rust\n"
"use std::convert::AsRef;\n"
"use std::fmt::Debug;"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:90
msgid ""
"fn pretty_print<T, Line, Matrix>(matrix: Matrix)\n"
"where\n"
"    T: Debug,\n"
"    // A line references a slice of items\n"
"    Line: AsRef<[T]>,\n"
"    // A matrix references a slice of lines\n"
"    Matrix: AsRef<[Line]>\n"
"{\n"
"    for row in matrix.as_ref() {\n"
"        println!(\"{:?}\", row.as_ref());\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:103
msgid ""
"fn main() {\n"
"    // &[&[i32]]\n"
"    pretty_print(&[&[1, 2, 3], &[4, 5, 6], &[7, 8, 9]]);\n"
"    // [[&str; 2]; 2]\n"
"    pretty_print([[\"a\", \"b\"], [\"c\", \"d\"]]);\n"
"    // Vec<Vec<i32>>\n"
"    pretty_print(vec![vec![1, 2], vec![3, 4]]);\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:113
#, fuzzy
msgid ""
"In addition, the type itself would not enforce that the child slices are of "
"the same length, so such variable could contain an invalid matrix."
msgstr ""
"Ponadto sam typ nie wymuszaby, aby wycinki potomne byy tej samej dugoci, "
"wic taka zmienna mogaby zawiera nieprawidow macierz."

#: src/exercises/day-1/solutions-morning.md:115
#, fuzzy
msgid "[1]: https://doc.rust-lang.org/std/convert/trait.AsRef.html"
msgstr "[1]: https://doc.rust-lang.org/std/convert/trait.AsRef.html"

#: src/exercises/day-1/solutions-afternoon.md:1
#, fuzzy
msgid "# Day 1 Afternoon Exercises"
msgstr "# Dzie 1 wiczenia popoudniowe"

#: src/exercises/day-1/solutions-afternoon.md:3
#, fuzzy
msgid "## Designing a Library"
msgstr "## Projektowanie biblioteki"

#: src/exercises/day-1/solutions-afternoon.md:5
msgid "([back to exercise](book-library.md))"
msgstr "([powr贸t do wiczenia](book-library.md))"

#: src/exercises/day-1/solutions-afternoon.md:22
msgid ""
"// ANCHOR: setup\n"
"struct Library {\n"
"    books: Vec<Book>,\n"
"}"
msgstr ""
"// ANCHOR: setup\n"
"struct Library {\n"
"    books: Vec<Book>,\n"
"}"

#: src/exercises/day-1/solutions-afternoon.md:42
msgid ""
"// This makes it possible to print Book values with {}.\n"
"impl std::fmt::Display for Book {\n"
"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n"
"        write!(f, \"{} ({})\", self.title, self.year)\n"
"    }\n"
"}\n"
"// ANCHOR_END: setup"
msgstr ""
"// Umo偶liwia to drukowanie wartoci Book za pomoc {}.\n"
"impl std::fmt::Display for Book {\n"
"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n"
"        write!(f, \"{} ({})\", self.title, self.year)\n"
"    }\n"
"}\n"
"// ANCHOR_END: setup"

#: src/exercises/day-1/solutions-afternoon.md:50
msgid ""
"// ANCHOR: Library_new\n"
"impl Library {\n"
"    fn new() -> Library {\n"
"        // ANCHOR_END: Library_new\n"
"        Library { books: Vec::new() }\n"
"    }"
msgstr ""
"// ANCHOR: Library_new\n"
"impl Library {\n"
"    fn new() -> Library {\n"
"        // ANCHOR_END: Library_new\n"
"        Library { books: Vec::new() }\n"
"    }"

#: src/exercises/day-1/solutions-afternoon.md:57
msgid ""
"    // ANCHOR: Library_len\n"
"    //fn len(self) -> usize {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_len\n"
"    fn len(&self) -> usize {\n"
"        self.books.len()\n"
"    }"
msgstr ""
"    // ANCHOR: Library_len\n"
"    //fn len(self) -> usize {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_len\n"
"    fn len(&self) -> usize {\n"
"        self.books.len()\n"
"    }"

#: src/exercises/day-1/solutions-afternoon.md:66
msgid ""
"    // ANCHOR: Library_is_empty\n"
"    //fn is_empty(self) -> bool {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_is_empty\n"
"    fn is_empty(&self) -> bool {\n"
"        self.books.is_empty()\n"
"    }"
msgstr ""
"    // ANCHOR: Library_is_empty\n"
"    //fn is_empty(self) -> bool {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_is_empty\n"
"    fn is_empty(&self) -> bool {\n"
"        self.books.is_empty()\n"
"    }"

#: src/exercises/day-1/solutions-afternoon.md:75
msgid ""
"    // ANCHOR: Library_add_book\n"
"    //fn add_book(self, book: Book) {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_add_book\n"
"    fn add_book(&mut self, book: Book) {\n"
"        self.books.push(book)\n"
"    }"
msgstr ""
"    // ANCHOR: Library_add_book\n"
"    //fn add_book(self, book: Book) {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_add_book\n"
"    fn add_book(&mut self, book: Book) {\n"
"        self.books.push(book)\n"
"    }"

#: src/exercises/day-1/solutions-afternoon.md:84
msgid ""
"    // ANCHOR: Library_print_books\n"
"    //fn print_books(self) {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_print_books\n"
"    fn print_books(&self) {\n"
"        for book in &self.books {\n"
"            println!(\"{}\", book);\n"
"        }\n"
"    }"
msgstr ""
"    // ANCHOR: Library_print_books\n"
"    //fn print_books(self) {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_print_books\n"
"    fn print_books(&self) {\n"
"        for book in &self.books {\n"
"            println!(\"{}\", book);\n"
"        }\n"
"    }"

#: src/exercises/day-1/solutions-afternoon.md:95
msgid ""
"    // ANCHOR: Library_oldest_book\n"
"    //fn oldest_book(self) -> Option<&Book> {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_oldest_book\n"
"    fn oldest_book(&self) -> Option<&Book> {\n"
"        self.books.iter().min_by_key(|book| book.year)\n"
"    }\n"
"}"
msgstr ""
"    // ANCHOR: Library_oldest_book\n"
"    //fn oldest_book(self) -> Option<&Book> {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_oldest_book\n"
"    fn oldest_book(&self) -> Option<&Book> {\n"
"        self.books.iter().min_by_key(|book| book.year)\n"
"    }\n"
"}"

#: src/exercises/day-1/solutions-afternoon.md:105
msgid ""
"// ANCHOR: main\n"
"// This shows the desired behavior. Uncomment the code below and\n"
"// implement the missing methods. You will need to update the\n"
"// method signatures, including the \"self\" parameter! You may\n"
"// also need to update the variable bindings within main.\n"
"fn main() {\n"
"    let library = Library::new();"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:113
msgid ""
"    //println!(\"Our library is empty: {}\", library.is_empty());\n"
"    //\n"
"    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    //\n"
"    //library.print_books();\n"
"    //\n"
"    //match library.oldest_book() {\n"
"    //    Some(book) => println!(\"My oldest book is {book}\"),\n"
"    //    None => println!(\"My library is empty!\"),\n"
"    //}\n"
"    //\n"
"    //println!(\"Our library has {} books\", library.len());\n"
"}\n"
"// ANCHOR_END: main"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:129
msgid ""
"#[test]\n"
"fn test_library_len() {\n"
"    let mut library = Library::new();\n"
"    assert_eq!(library.len(), 0);\n"
"    assert!(library.is_empty());"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:135
msgid ""
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    assert_eq!(library.len(), 2);\n"
"    assert!(!library.is_empty());\n"
"}"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:141
msgid ""
"#[test]\n"
"fn test_library_is_empty() {\n"
"    let mut library = Library::new();\n"
"    assert!(library.is_empty());"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:146
msgid ""
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    assert!(!library.is_empty());\n"
"}"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:150
msgid ""
"#[test]\n"
"fn test_library_print_books() {\n"
"    let mut library = Library::new();\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    // We could try and capture stdout, but let us just call the\n"
"    // method to start with.\n"
"    library.print_books();\n"
"}"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:160
msgid ""
"#[test]\n"
"fn test_library_oldest_book() {\n"
"    let mut library = Library::new();\n"
"    assert!(library.oldest_book().is_none());"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:165
msgid ""
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    assert_eq!(\n"
"        library.oldest_book().map(|b| b.title.as_str()),\n"
"        Some(\"Lord of the Rings\")\n"
"    );"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:171
msgid ""
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    assert_eq!(\n"
"        library.oldest_book().map(|b| b.title.as_str()),\n"
"        Some(\"Alice's Adventures in Wonderland\")\n"
"    );\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:1
#, fuzzy
msgid "# Day 2 Morning Exercises"
msgstr "# Dzie 2 wiczenia poranne"

#: src/exercises/day-2/solutions-morning.md:3
#, fuzzy
msgid "## Points and Polygons"
msgstr "## Punkty i wielokty"

#: src/exercises/day-2/solutions-morning.md:5
msgid "([back to exercise](points-polygons.md))"
msgstr "([powr贸t do wiczenia](points-polygons.md))"

#: src/exercises/day-2/solutions-morning.md:22
msgid ""
"#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n"
"// ANCHOR: Point\n"
"pub struct Point {\n"
"    // ANCHOR_END: Point\n"
"    x: i32,\n"
"    y: i32,\n"
"}"
msgstr ""
"#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n"
"// ANCHOR: Point\n"
"pub struct Point {\n"
"    // ANCHOR_END: Point\n"
"    x: i32,\n"
"    y: i32,\n"
"}"

#: src/exercises/day-2/solutions-morning.md:30
msgid ""
"// ANCHOR: Point-impl\n"
"impl Point {\n"
"    // ANCHOR_END: Point-impl\n"
"    pub fn new(x: i32, y: i32) -> Point {\n"
"        Point { x, y }\n"
"    }"
msgstr ""
"// ANCHOR: Point-impl\n"
"impl Point {\n"
"    // ANCHOR_END: Point-impl\n"
"    pub fn new(x: i32, y: i32) -> Point {\n"
"        Point { x, y }\n"
"    }"

#: src/exercises/day-2/solutions-morning.md:37
msgid ""
"    pub fn magnitude(self) -> f64 {\n"
"        f64::from(self.x.pow(2) + self.y.pow(2)).sqrt()\n"
"    }"
msgstr ""
"    pub fn magnitude(self) -> f64 {\n"
"        f64::from(self.x.pow(2) + self.y.pow(2)).sqrt()\n"
"    }"

#: src/exercises/day-2/solutions-morning.md:41
msgid ""
"    pub fn dist(self, other: Point) -> f64 {\n"
"        (self - other).magnitude()\n"
"    }\n"
"}"
msgstr ""
"    pub fn dist(self, other: Point) -> f64 {\n"
"        (self - other).magnitude()\n"
"    }\n"
"}"

#: src/exercises/day-2/solutions-morning.md:49
msgid ""
"    fn add(self, other: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x + other.x,\n"
"            y: self.y + other.y,\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"    fn add(self, other: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x + other.x,\n"
"            y: self.y + other.y,\n"
"        }\n"
"    }\n"
"}"

#: src/exercises/day-2/solutions-morning.md:57
msgid "impl std::ops::Sub for Point {\n    type Output = Self;"
msgstr "impl std::ops::Sub for Point {\n    type Output = Self;"

#: src/exercises/day-2/solutions-morning.md:60
msgid ""
"    fn sub(self, other: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x - other.x,\n"
"            y: self.y - other.y,\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"    fn sub(self, other: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x - other.x,\n"
"            y: self.y - other.y,\n"
"        }\n"
"    }\n"
"}"

#: src/exercises/day-2/solutions-morning.md:68
msgid ""
"// ANCHOR: Polygon\n"
"pub struct Polygon {\n"
"    // ANCHOR_END: Polygon\n"
"    points: Vec<Point>,\n"
"}"
msgstr ""
"// ANCHOR: Polygon\n"
"pub struct Polygon {\n"
"    // ANCHOR_END: Polygon\n"
"    points: Vec<Point>,\n"
"}"

#: src/exercises/day-2/solutions-morning.md:74
msgid ""
"// ANCHOR: Polygon-impl\n"
"impl Polygon {\n"
"    // ANCHOR_END: Polygon-impl\n"
"    pub fn new() -> Polygon {\n"
"        Polygon { points: Vec::new() }\n"
"    }"
msgstr ""
"// ANCHOR: Polygon-impl\n"
"impl Polygon {\n"
"    // ANCHOR_END: Polygon-impl\n"
"    pub fn new() -> Polygon {\n"
"        Polygon { points: Vec::new() }\n"
"    }"

#: src/exercises/day-2/solutions-morning.md:81
msgid ""
"    pub fn add_point(&mut self, point: Point) {\n"
"        self.points.push(point);\n"
"    }"
msgstr ""
"    pub fn add_point(&mut self, point: Point) {\n"
"        self.points.push(point);\n"
"    }"

#: src/exercises/day-2/solutions-morning.md:85
msgid ""
"    pub fn left_most_point(&self) -> Option<Point> {\n"
"        self.points.iter().min_by_key(|p| p.x).copied()\n"
"    }"
msgstr ""
"    pub fn left_most_point(&self) -> Option<Point> {\n"
"        self.points.iter().min_by_key(|p| p.x).copied()\n"
"    }"

#: src/exercises/day-2/solutions-morning.md:89
msgid ""
"    pub fn iter(&self) -> impl Iterator<Item = &Point> {\n"
"        self.points.iter()\n"
"    }"
msgstr ""
"    pub fn iter(&self) -> impl Iterator<Item = &Point> {\n"
"        self.points.iter()\n"
"    }"

#: src/exercises/day-2/solutions-morning.md:93
msgid ""
"    pub fn length(&self) -> f64 {\n"
"        if self.points.is_empty() {\n"
"            return 0.0;\n"
"        }"
msgstr ""
"    pub fn length(&self) -> f64 {\n"
"        if self.points.is_empty() {\n"
"            return 0.0;\n"
"        }"

#: src/exercises/day-2/solutions-morning.md:98
msgid ""
"        let mut result = 0.0;\n"
"        let mut last_point = self.points[0];\n"
"        for point in &self.points[1..] {\n"
"            result += last_point.dist(*point);\n"
"            last_point = *point;\n"
"        }\n"
"        result += last_point.dist(self.points[0]);\n"
"        result\n"
"    }\n"
"}"
msgstr ""
"        let mut result = 0.0;\n"
"        let mut last_point = self.points[0];\n"
"        for point in &self.points[1..] {\n"
"            result += last_point.dist(*point);\n"
"            last_point = *point;\n"
"        }\n"
"        result += last_point.dist(self.points[0]);\n"
"        result\n"
"    }\n"
"}"

#: src/exercises/day-2/solutions-morning.md:109
msgid ""
"// ANCHOR: Circle\n"
"pub struct Circle {\n"
"    // ANCHOR_END: Circle\n"
"    center: Point,\n"
"    radius: i32,\n"
"}"
msgstr ""
"// ANCHOR: Circle\n"
"pub struct Circle {\n"
"    // ANCHOR_END: Circle\n"
"    center: Point,\n"
"    radius: i32,\n"
"}"

#: src/exercises/day-2/solutions-morning.md:116
msgid ""
"// ANCHOR: Circle-impl\n"
"impl Circle {\n"
"    // ANCHOR_END: Circle-impl\n"
"    pub fn new(center: Point, radius: i32) -> Circle {\n"
"        Circle { center, radius }\n"
"    }"
msgstr ""
"// ANCHOR: Circle-impl\n"
"impl Circle {\n"
"    // ANCHOR_END: Circle-impl\n"
"    pub fn new(center: Point, radius: i32) -> Circle {\n"
"        Circle { center, radius }\n"
"    }"

#: src/exercises/day-2/solutions-morning.md:123
msgid ""
"    pub fn circumference(&self) -> f64 {\n"
"        2.0 * std::f64::consts::PI * f64::from(self.radius)\n"
"    }"
msgstr ""
"    pub fn circumference(&self) -> f64 {\n"
"        2.0 * std::f64::consts::PI * f64::from(self.radius)\n"
"    }"

#: src/exercises/day-2/solutions-morning.md:127
msgid ""
"    pub fn dist(&self, other: &Self) -> f64 {\n"
"        self.center.dist(other.center)\n"
"    }\n"
"}"
msgstr ""
"    pub fn dist(&self, other: &Self) -> f64 {\n"
"        self.center.dist(other.center)\n"
"    }\n"
"}"

#: src/exercises/day-2/solutions-morning.md:132
msgid ""
"// ANCHOR: Shape\n"
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}\n"
"// ANCHOR_END: Shape"
msgstr ""
"// ANCHOR: Shape\n"
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}\n"
"// ANCHOR_END: Shape"

#: src/exercises/day-2/solutions-morning.md:139
msgid ""
"impl From<Polygon> for Shape {\n"
"    fn from(poly: Polygon) -> Self {\n"
"        Shape::Polygon(poly)\n"
"    }\n"
"}"
msgstr ""
"impl From<Polygon> for Shape {\n"
"    fn from(poly: Polygon) -> Self {\n"
"        Shape::Polygon(poly)\n"
"    }\n"
"}"

#: src/exercises/day-2/solutions-morning.md:145
msgid ""
"impl From<Circle> for Shape {\n"
"    fn from(circle: Circle) -> Self {\n"
"        Shape::Circle(circle)\n"
"    }\n"
"}"
msgstr ""
"impl From<Circle> for Shape {\n"
"    fn from(circle: Circle) -> Self {\n"
"        Shape::Circle(circle)\n"
"    }\n"
"}"

#: src/exercises/day-2/solutions-morning.md:151
msgid ""
"impl Shape {\n"
"    pub fn perimeter(&self) -> f64 {\n"
"        match self {\n"
"            Shape::Polygon(poly) => poly.length(),\n"
"            Shape::Circle(circle) => circle.circumference(),\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"impl Shape {\n"
"    pub fn perimeter(&self) -> f64 {\n"
"        match self {\n"
"            Shape::Polygon(poly) => poly.length(),\n"
"            Shape::Circle(circle) => circle.circumference(),\n"
"        }\n"
"    }\n"
"}"

#: src/exercises/day-2/solutions-morning.md:160
msgid ""
"// ANCHOR: unit-tests\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;"
msgstr ""
"// ANCHOR: unit-tests\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;"

#: src/exercises/day-2/solutions-morning.md:213
msgid ""
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimeter)\n"
"            .map(round_two_digits)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}\n"
"// ANCHOR_END: unit-tests"
msgstr ""
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimeter)\n"
"            .map(round_two_digits)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}\n"
"// ANCHOR_END: unit-tests"

#: src/exercises/day-2/solutions-morning.md:233 src/exercises/day-2/solutions-afternoon.md:174
msgid "fn main() {}\n```"
msgstr "fn main() {}\n```"

#: src/exercises/day-2/solutions-afternoon.md:1
#, fuzzy
msgid "# Day 2 Afternoon Exercises"
msgstr "# Dzie 2 wiczenia popoudniowe"

#: src/exercises/day-2/solutions-afternoon.md:3
#, fuzzy
msgid "## Luhn Algorithm"
msgstr "## Algorytm Luhna"

#: src/exercises/day-2/solutions-afternoon.md:5
msgid "([back to exercise](luhn.md))"
msgstr "([powr贸t do wiczenia](luhn.md))"

#: src/exercises/day-2/solutions-afternoon.md:22
msgid ""
"// ANCHOR: luhn\n"
"pub fn luhn(cc_number: &str) -> bool {\n"
"    // ANCHOR_END: luhn\n"
"    let mut digits_seen = 0;\n"
"    let mut sum = 0;\n"
"    for (i, ch) in cc_number.chars().rev().filter(|&ch| ch != ' "
"').enumerate() {\n"
"        match ch.to_digit(10) {\n"
"            Some(d) => {\n"
"                sum += if i % 2 == 1 {\n"
"                    let dd = d * 2;\n"
"                    dd / 10 + dd % 10\n"
"                } else {\n"
"                    d\n"
"                };\n"
"                digits_seen += 1;\n"
"            }\n"
"            None => return false,\n"
"        }\n"
"    }"
msgstr ""
"// ANCHOR: luhn\n"
"pub fn luhn(cc_number: &str) -> bool {\n"
"    // ANCHOR_END: luhn\n"
"    let mut digits_seen = 0;\n"
"    let mut sum = 0;\n"
"    for (i, ch) in cc_number.chars().rev().filter(|&ch| ch != ' "
"').enumerate() {\n"
"        match ch.to_digit(10) {\n"
"            Some(d) => {\n"
"                sum += if i % 2 == 1 {\n"
"                    let dd = d * 2;\n"
"                    dd / 10 + dd % 10\n"
"                } else {\n"
"                    d\n"
"                };\n"
"                digits_seen += 1;\n"
"            }\n"
"            None => return false,\n"
"        }\n"
"    }"

#: src/exercises/day-2/solutions-afternoon.md:42
msgid ""
"    if digits_seen < 2 {\n"
"        return false;\n"
"    }"
msgstr ""
"    if digits_seen < 2 {\n"
"        return false;\n"
"    }"

#: src/exercises/day-2/solutions-afternoon.md:46
msgid "    sum % 10 == 0\n}"
msgstr "    sum % 10 == 0\n}"

#: src/exercises/day-2/solutions-afternoon.md:49
msgid ""
"fn main() {\n"
"    let cc_number = \"1234 5678 1234 5670\";\n"
"    println!(\n"
"        \"Is {} a valid credit card number? {}\",\n"
"        cc_number,\n"
"        if luhn(cc_number) { \"yes\" } else { \"no\" }\n"
"    );\n"
"}"
msgstr ""
"fn main() {\n"
"    let cc_number = \"1234 5678 1234 5670\";\n"
"    println!(\n"
"        \"Czy {} to prawidowy numer karty kredytowej? {}\",\n"
"        cc_number,\n"
"        if luhn(cc_number) { \"tak\" } else { \"nie\" }\n"
"    );\n"
"}"

#: src/exercises/day-2/solutions-afternoon.md:58
msgid ""
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\"));\n"
"}"
msgstr ""
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\"));\n"
"}"

#: src/exercises/day-2/solutions-afternoon.md:89
msgid ""
"#[test]\n"
"fn test_invalid_cc_number() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}\n"
"// ANCHOR_END: unit-tests\n"
"```"
msgstr ""
"#[test]\n"
"fn test_invalid_cc_number() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}\n"
"// ANCHOR_END: unit-tests\n"
"```"

#: src/exercises/day-2/solutions-afternoon.md:98
#, fuzzy
msgid "## Strings and Iterators"
msgstr "## acuchy i iteratory"

#: src/exercises/day-2/solutions-afternoon.md:100
msgid "([back to exercise](strings-iterators.md))"
msgstr "([powr贸t do wiczenia](strings-iterators.md))"

#: src/exercises/day-2/solutions-afternoon.md:117
msgid ""
"// ANCHOR: prefix_matches\n"
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    // ANCHOR_END: prefix_matches\n"
"    let prefixes = prefix.split('/');\n"
"    let request_paths = request_path\n"
"        .split('/')\n"
"        .map(|p| Some(p))\n"
"        .chain(std::iter::once(None));"
msgstr ""
"// ANCHOR: prefix_matches\n"
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    // ANCHOR_END: prefix_matches\n"
"    let prefixes = prefix.split('/');\n"
"    let request_paths = request_path\n"
"        .split('/')\n"
"        .map(|p| Some(p))\n"
"        .chain(std::iter::once(None));"

#: src/exercises/day-2/solutions-afternoon.md:126
msgid ""
"    for (prefix, request_path) in prefixes.zip(request_paths) {\n"
"        match request_path {\n"
"            Some(request_path) => {\n"
"                if (prefix != \"*\") && (prefix != request_path) {\n"
"                    return false;\n"
"                }\n"
"            }\n"
"            None => return false,\n"
"        }\n"
"    }\n"
"    true\n"
"}"
msgstr ""
"    for (prefix, request_path) in prefixes.zip(request_paths) {\n"
"        match request_path {\n"
"            Some(request_path) => {\n"
"                if (prefix != \"*\") && (prefix != request_path) {\n"
"                    return false;\n"
"                }\n"
"            }\n"
"            None => return false,\n"
"        }\n"
"    }\n"
"    true\n"
"}"

#: src/exercises/day-2/solutions-afternoon.md:139
msgid ""
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", "
"\"/v1/publishers/abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", "
"\"/v1/publishers/abc/books\"));"
msgstr ""
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", "
"\"/v1/publishers/abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", "
"\"/v1/publishers/abc/books\"));"

#: src/exercises/day-2/solutions-afternoon.md:166
msgid ""
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", "
"\"/v1/publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"// ANCHOR_END: unit-tests"
msgstr ""
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", "
"\"/v1/publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"// ANCHOR_END: unit-tests"

#: src/exercises/day-3/solutions-morning.md:1
#, fuzzy
msgid "# Day 3 Morning Exercise"
msgstr "# Dzie 3 Poranna gimnastyka"

#: src/exercises/day-3/solutions-morning.md:3
msgid "## A Simple GUI Library"
msgstr "## Prosta biblioteka GUI"

#: src/exercises/day-3/solutions-morning.md:5
msgid "([back to exercise](simple-gui.md))"
msgstr "([powr贸t do wiczenia](simple-gui.md))"

#: src/exercises/day-3/solutions-morning.md:22
msgid ""
"// ANCHOR: setup\n"
"pub trait Widget {\n"
"    /// Natural width of `self`.\n"
"    fn width(&self) -> usize;"
msgstr ""
"// ANCHOR: setup\n"
"pub trait Widget {\n"
"    /// Naturalna szeroko `self`.\n"
"    fn width(&self) -> usize;"

#: src/exercises/day-3/solutions-morning.md:82
msgid "// ANCHOR_END: setup"
msgstr "// ANCHOR_END: setup"

#: src/exercises/day-3/solutions-morning.md:84
msgid ""
"// ANCHOR: Window-width\n"
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Window-width\n"
"        std::cmp::max(\n"
"            self.title.chars().count(),\n"
"            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
"        )\n"
"    }"
msgstr ""
"// ANCHOR: Window-width\n"
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Window-width\n"
"        std::cmp::max(\n"
"            self.title.chars().count(),\n"
"            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
"        )\n"
"    }"

#: src/exercises/day-3/solutions-morning.md:94
msgid ""
"    // ANCHOR: Window-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Window-draw_into\n"
"        let mut inner = String::new();\n"
"        for widget in &self.widgets {\n"
"            widget.draw_into(&mut inner);\n"
"        }"
msgstr ""
"    // ANCHOR: Window-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Window-draw_into\n"
"        let mut inner = String::new();\n"
"        for widget in &self.widgets {\n"
"            widget.draw_into(&mut inner);\n"
"        }"

#: src/exercises/day-3/solutions-morning.md:102
msgid "        let window_width = self.width();"
msgstr "        let window_width = self.width();"

#: src/exercises/day-3/solutions-morning.md:104
msgid ""
"        // TODO: after learning about error handling, you can change\n"
"        // draw_into to return Result<(), std::fmt::Error>. Then use\n"
"        // the ?-operator here instead of .unwrap().\n"
"        writeln!(buffer, \"+-{:-<window_width$}-+\", \"\").unwrap();\n"
"        writeln!(buffer, \"| {:^window_width$} |\", &self.title).unwrap();\n"
"        writeln!(buffer, \"+={:=<window_width$}=+\", \"\").unwrap();\n"
"        for line in inner.lines() {\n"
"            writeln!(buffer, \"| {:window_width$} |\", line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+-{:-<window_width$}-+\", \"\").unwrap();\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:117
msgid ""
"// ANCHOR: Button-width\n"
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Button-width\n"
"        self.label.width() + 8 // add a bit of padding\n"
"    }"
msgstr ""
"// ANCHOR: Button-width\n"
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Button-width\n"
"        self.label.width() + 8 // dodaj troch wypenienia\n"
"    }"

#: src/exercises/day-3/solutions-morning.md:124
msgid ""
"    // ANCHOR: Button-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Button-draw_into\n"
"        let width = self.width();\n"
"        let mut label = String::new();\n"
"        self.label.draw_into(&mut label);"
msgstr ""
"    // ANCHOR: Button-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Button-draw_into\n"
"        let width = self.width();\n"
"        let mut label = String::new();\n"
"        self.label.draw_into(&mut label);"

#: src/exercises/day-3/solutions-morning.md:131
msgid ""
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"        for line in label.lines() {\n"
"            writeln!(buffer, \"|{:^width$}|\", &line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"    }\n"
"}"
msgstr ""
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"        for line in label.lines() {\n"
"            writeln!(buffer, \"|{:^width$}|\", &line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"    }\n"
"}"

#: src/exercises/day-3/solutions-morning.md:139
msgid ""
"// ANCHOR: Label-width\n"
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Label-width\n"
"        self.label\n"
"            .lines()\n"
"            .map(|line| line.chars().count())\n"
"            .max()\n"
"            .unwrap_or(0)\n"
"    }"
msgstr ""
"// ANCHOR: Label-width\n"
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Label-width\n"
"        self.label\n"
"            .lines()\n"
"            .map(|line| line.chars().count())\n"
"            .max()\n"
"            .unwrap_or(0)\n"
"    }"

#: src/exercises/day-3/solutions-morning.md:150
msgid ""
"    // ANCHOR: Label-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Label-draw_into\n"
"        writeln!(buffer, \"{}\", &self.label).unwrap();\n"
"    }\n"
"}"
msgstr ""
"    // ANCHOR: Label-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Label-draw_into\n"
"        writeln!(buffer, \"{}\", &self.label).unwrap();\n"
"    }\n"
"}"

#: src/exercises/day-3/solutions-morning.md:157
msgid ""
"// ANCHOR: main\n"
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"This is a small text GUI "
"demo.\")));\n"
"    window.add_widget(Box::new(Button::new(\n"
"        \"Click me!\",\n"
"        Box::new(|| println!(\"You clicked the button!\")),\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"// ANCHOR_END: main\n"
"```"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:1
#, fuzzy
msgid "# Day 3 Afternoon Exercises"
msgstr "# Dzie 3 wiczenia popoudniowe"

#: src/exercises/day-3/solutions-afternoon.md:3
#, fuzzy
msgid "## Safe FFI Wrapper"
msgstr "## Bezpieczne opakowanie FFI"

#: src/exercises/day-3/solutions-afternoon.md:5
msgid "([back to exercise](safe-ffi-wrapper.md))"
msgstr "([powr贸t do wiczenia](safe-ffi-wrapper.md))"

#: src/exercises/day-3/solutions-afternoon.md:22
msgid ""
"// ANCHOR: ffi\n"
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int, c_long, c_ulong, c_ushort};"
msgstr ""
"// ANCHOR: ffi\n"
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int, c_long, c_ulong, c_ushort};"

#: src/exercises/day-3/solutions-afternoon.md:53
msgid ""
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}\n"
"// ANCHOR_END: ffi"
msgstr ""
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}\n"
"// ANCHOR_END: ffi"

#: src/exercises/day-3/solutions-afternoon.md:60
msgid ""
"// ANCHOR: DirectoryIterator\n"
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
"        // ANCHOR_END: DirectoryIterator\n"
"        let path = CString::new(path).map_err(|err| format!(\"Invalid path: "
"{err}\"))?;\n"
"        // SAFETY: path.as_ptr() cannot be NULL.\n"
"        let dir = unsafe { ffi::opendir(path.as_ptr()) };\n"
"        if dir.is_null() {\n"
"            Err(format!(\"Could not open {:?}\", path))\n"
"        } else {\n"
"            Ok(DirectoryIterator { path, dir })\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:77
msgid ""
"// ANCHOR: Iterator\n"
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Keep calling readdir until we get a NULL pointer back.\n"
"        // ANCHOR_END: Iterator\n"
"        // SAFETY: self.dir is never NULL.\n"
"        let dirent = unsafe { ffi::readdir(self.dir) };\n"
"        if dirent.is_null() {\n"
"            // We have reached the end of the directory.\n"
"            return None;\n"
"        }\n"
"        // SAFETY: dirent is not NULL and dirent.d_name is NUL\n"
"        // terminated.\n"
"        let d_name = unsafe { CStr::from_ptr((*dirent).d_name.as_ptr()) };\n"
"        let os_str = OsStr::from_bytes(d_name.to_bytes());\n"
"        Some(os_str.to_owned())\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:97
msgid ""
"// ANCHOR: Drop\n"
"impl Drop for DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Call closedir as needed.\n"
"        // ANCHOR_END: Drop\n"
"        if !self.dir.is_null() {\n"
"            // SAFETY: self.dir is not NULL.\n"
"            if unsafe { ffi::closedir(self.dir) } != 0 {\n"
"                panic!(\"Could not close {:?}\", self.path);\n"
"            }\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:111
msgid ""
"// ANCHOR: main\n"
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"// ANCHOR_END: main\n"
"```"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:1
#, fuzzy
msgid "# Day 4 Morning Exercise"
msgstr "# Dzie 4 Poranna gimnastyka"

#: src/exercises/day-4/solutions-morning.md:3
msgid "## Dining Philosophers"
msgstr "## Ucztujcy filozofowie"

#: src/exercises/day-4/solutions-morning.md:5
msgid "([back to exercise](dining-philosophers.md))"
msgstr "([powr贸t do wiczenia](dining-philosophers.md))"

#: src/exercises/day-4/solutions-morning.md:22
msgid ""
"// ANCHOR: Philosopher\n"
"use std::sync::mpsc;\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:30
#, fuzzy
msgid ""
"struct Philosopher {\n"
"    name: String,\n"
"    // ANCHOR_END: Philosopher\n"
"    left_fork: Arc<Mutex<Fork>>,\n"
"    right_fork: Arc<Mutex<Fork>>,\n"
"    thoughts: mpsc::SyncSender<String>,\n"
"}"
msgstr ""
"struktura Filozof {\n"
"    imi: Cig,\n"
"    // ANCHOR_END: Filozof\n"
"    left_fork: Arc<Mutex<Fork>>,\n"
"    right_fork: Arc<Mutex<Fork>>,\n"
"    myli: mpsc::SyncSender<String>,\n"
"}"

#: src/exercises/day-4/solutions-morning.md:38
msgid ""
"// ANCHOR: Philosopher-think\n"
"impl Philosopher {\n"
"    fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))\n"
"            .unwrap();\n"
"    }\n"
"    // ANCHOR_END: Philosopher-think"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:47
msgid ""
"    // ANCHOR: Philosopher-eat\n"
"    fn eat(&self) {\n"
"        // ANCHOR_END: Philosopher-eat\n"
"        println!(\"{} is trying to eat\", &self.name);\n"
"        let left = self.left_fork.lock().unwrap();\n"
"        let right = self.right_fork.lock().unwrap();"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:54
msgid ""
"        // ANCHOR: Philosopher-eat-end\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:63
msgid ""
"fn main() {\n"
"    // ANCHOR_END: Philosopher-eat-end\n"
"    let (tx, rx) = mpsc::sync_channel(10);"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:67
msgid ""
"    let forks = (0..PHILOSOPHERS.len())\n"
"        .map(|_| Arc::new(Mutex::new(Fork)))\n"
"        .collect::<Vec<_>>();"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:71
msgid ""
"    for i in 0..forks.len() {\n"
"        let tx = tx.clone();\n"
"        let mut left_fork = forks[i].clone();\n"
"        let mut right_fork = forks[(i + 1) % forks.len()].clone();"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:76
msgid ""
"        // To avoid a deadlock, we have to break the symmetry\n"
"        // somewhere. This will swap the forks without deinitializing\n"
"        // either of them.\n"
"        if i == forks.len() - 1 {\n"
"            std::mem::swap(&mut left_fork, &mut right_fork);\n"
"        }"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:83
msgid ""
"        let philosopher = Philosopher {\n"
"            name: PHILOSOPHERS[i].to_string(),\n"
"            thoughts: tx,\n"
"            left_fork,\n"
"            right_fork,\n"
"        };"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:90
msgid ""
"        thread::spawn(move || {\n"
"            for _ in 0..100 {\n"
"                philosopher.eat();\n"
"                philosopher.think();\n"
"            }\n"
"        });\n"
"    }"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:98
msgid ""
"    drop(tx);\n"
"    for thought in rx {\n"
"        println!(\"{thought}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
