msgid ""
msgstr ""
"Project-Id-Version: Comprehensive Rust \n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2023-03-10 17:32+0100\n"
"Last-Translator: Kuba Jaroszewski <jakub.jaroszewski@gmail.com>\n"
"Language-Team: Polish <translation-team-pl@lists.sourceforge.net>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pl\n"
"Plural-Forms: nplurals=3; plural=(n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 "
"|| n%100>=20) ? 1 : 2);\n"

#: src/SUMMARY.md:3 src/welcome.md:1
msgid "Welcome to Comprehensive Rust "
msgstr "Witamy w Comprehensive Rust "

#: src/SUMMARY.md:4 src/running-the-course.md:1
msgid "Running the Course"
msgstr "Prowadzenie kursu"

#: src/SUMMARY.md:5 src/running-the-course/course-structure.md:1
msgid "Course Structure"
msgstr "Struktura kursu"

#: src/SUMMARY.md:6 src/running-the-course/keyboard-shortcuts.md:1
msgid "Keyboard Shortcuts"
msgstr "Skr贸ty klawiszowe"

#: src/SUMMARY.md:7 src/running-the-course/translations.md:1
msgid "Translations"
msgstr "Tumaczenia"

#: src/SUMMARY.md:8 src/cargo.md:1
msgid "Using Cargo"
msgstr "Korzystanie z Cargo"

#: src/SUMMARY.md:9
msgid "Rust Ecosystem"
msgstr "Ekosystem Rust"

#: src/SUMMARY.md:10
msgid "Code Samples"
msgstr "Pr贸bki kodu"

#: src/SUMMARY.md:11
msgid "Running Cargo Locally"
msgstr "Lokalne uruchamianie Cargo"

#: src/SUMMARY.md:14
msgid "Day 1: Morning"
msgstr "Dzie 1: Rano"

#: src/SUMMARY.md:18 src/SUMMARY.md:74 src/SUMMARY.md:127 src/SUMMARY.md:183
msgid "Welcome"
msgstr "Witamy"

#: src/SUMMARY.md:19 src/welcome-day-1/what-is-rust.md:1
msgid "What is Rust?"
msgstr "Co to jest Rust?"

#: src/SUMMARY.md:20 src/hello-world.md:1
msgid "Hello World!"
msgstr "Witaj wiecie!"

#: src/SUMMARY.md:21 src/hello-world/small-example.md:1
msgid "Small Example"
msgstr "May przykad"

#: src/SUMMARY.md:22 src/why-rust.md:1
msgid "Why Rust?"
msgstr "Dlaczego Rust?"

#: src/SUMMARY.md:23 src/why-rust/compile-time.md:1
msgid "Compile Time Guarantees"
msgstr "Gwarancje w czasie kompilacji"

#: src/SUMMARY.md:24 src/why-rust/runtime.md:1
msgid "Runtime Guarantees"
msgstr "Gwarancje podczas dziaania"

#: src/SUMMARY.md:25 src/why-rust/modern.md:1
msgid "Modern Features"
msgstr "Nowoczesne funkcjonalnoci"

#: src/SUMMARY.md:26 src/basic-syntax.md:1
msgid "Basic Syntax"
msgstr "Podstawowa skadnia"

#: src/SUMMARY.md:27 src/basic-syntax/scalar-types.md:1
msgid "Scalar Types"
msgstr "Typy skalarne"

#: src/SUMMARY.md:28 src/basic-syntax/compound-types.md:1
msgid "Compound Types"
msgstr "Typy zo偶one"

#: src/SUMMARY.md:29 src/basic-syntax/references.md:1
msgid "References"
msgstr "Referencje"

#: src/SUMMARY.md:30 src/basic-syntax/references-dangling.md:1
msgid "Dangling References"
msgstr "Wiszce referencje"

#: src/SUMMARY.md:31 src/basic-syntax/slices.md:1
msgid "Slices"
msgstr "Wycinki"

#: src/SUMMARY.md:32
msgid "String vs str"
msgstr "String a str"

#: src/SUMMARY.md:33 src/basic-syntax/functions.md:1
msgid "Functions"
msgstr "Funkcje"

#: src/SUMMARY.md:34 src/SUMMARY.md:81 src/basic-syntax/methods.md:1
#: src/methods.md:1
msgid "Methods"
msgstr "Metody"

#: src/SUMMARY.md:35
msgid "Overloading"
msgstr "Przeci偶enie"

#: src/SUMMARY.md:36 src/SUMMARY.md:65 src/SUMMARY.md:89 src/SUMMARY.md:118
#: src/SUMMARY.md:147 src/SUMMARY.md:175 src/SUMMARY.md:198 src/SUMMARY.md:225
#: src/exercises/day-4/morning.md:1 src/exercises/day-4/afternoon.md:1
msgid "Exercises"
msgstr "wiczenia"

#: src/SUMMARY.md:37 src/exercises/day-1/implicit-conversions.md:1
msgid "Implicit Conversions"
msgstr "Niejawne konwersje"

#: src/SUMMARY.md:38
msgid "Arrays and for Loops"
msgstr "Tablice i ptle for"

#: src/SUMMARY.md:40
msgid "Day 1: Afternoon"
msgstr "Dzie 1: Popoudnie"

#: src/SUMMARY.md:42 src/basic-syntax/variables.md:1
msgid "Variables"
msgstr "Zmienne"

#: src/SUMMARY.md:43 src/basic-syntax/type-inference.md:1
msgid "Type Inference"
msgstr "Wnioskowanie typ贸w"

#: src/SUMMARY.md:44
msgid "static & const"
msgstr "static i const"

#: src/SUMMARY.md:45 src/basic-syntax/scopes-shadowing.md:1
msgid "Scopes and Shadowing"
msgstr "Zakresy i przesanianie"

#: src/SUMMARY.md:46 src/memory-management.md:1
msgid "Memory Management"
msgstr "Zarzdzanie pamici"

#: src/SUMMARY.md:47
msgid "Stack vs Heap"
msgstr "Stos a sterta"

#: src/SUMMARY.md:48 src/memory-management/stack.md:1
msgid "Stack Memory"
msgstr "Pami stosu"

#: src/SUMMARY.md:49 src/memory-management/manual.md:1
msgid "Manual Memory Management"
msgstr "Rczne zarzdzanie pamici"

#: src/SUMMARY.md:50 src/memory-management/scope-based.md:1
msgid "Scope-Based Memory Management"
msgstr "Zarzdzanie pamici w oparciu o zakres"

#: src/SUMMARY.md:51
msgid "Garbage Collection"
msgstr "Odmiecanie pamici"

#: src/SUMMARY.md:52
msgid "Rust Memory Management"
msgstr "Zarzdzanie pamici w Rucie"

#: src/SUMMARY.md:53 src/memory-management/comparison.md:1
msgid "Comparison"
msgstr "Por贸wnanie"

#: src/SUMMARY.md:54 src/ownership.md:1
msgid "Ownership"
msgstr "Wasno"

#: src/SUMMARY.md:55 src/ownership/move-semantics.md:1
msgid "Move Semantics"
msgstr "Semantyka przenoszenia"

#: src/SUMMARY.md:56 src/ownership/moved-strings-rust.md:1
msgid "Moved Strings in Rust"
msgstr "Przenoszenie String w Rucie"

#: src/SUMMARY.md:57 src/ownership/double-free-modern-cpp.md:1
msgid "Double Frees in Modern C++"
msgstr "Podw贸jne zwalnianie pamici w nowoczesnym C++"

#: src/SUMMARY.md:58 src/ownership/moves-function-calls.md:1
msgid "Moves in Function Calls"
msgstr "Przenoszenie w wywoaniach funkcji"

#: src/SUMMARY.md:59 src/ownership/copy-clone.md:1
msgid "Copying and Cloning"
msgstr "Kopiowanie i klonowanie"

#: src/SUMMARY.md:60 src/ownership/borrowing.md:1
msgid "Borrowing"
msgstr "Po偶yczanie"

#: src/SUMMARY.md:61 src/ownership/shared-unique-borrows.md:1
msgid "Shared and Unique Borrows"
msgstr "Wsp贸lne i unikalne po偶yczenia"

#: src/SUMMARY.md:62 src/ownership/lifetimes.md:1
msgid "Lifetimes"
msgstr "Czas 偶ycia"

#: src/SUMMARY.md:63 src/ownership/lifetimes-function-calls.md:1
#, fuzzy
msgid "Lifetimes in Function Calls"
msgstr "Czas 偶ycia w wywoaniach funkcji"

#: src/SUMMARY.md:64 src/ownership/lifetimes-data-structures.md:1
#, fuzzy
msgid "Lifetimes in Data Structures"
msgstr "Czasy 偶ycia w strukturach danych"

#: src/SUMMARY.md:66 src/exercises/day-1/book-library.md:1
#: src/exercises/day-1/solutions-afternoon.md:3
msgid "Designing a Library"
msgstr "Projektowanie biblioteki"

#: src/SUMMARY.md:67 src/exercises/day-1/iterators-and-ownership.md:1
msgid "Iterators and Ownership"
msgstr "Iteratory a wasno"

#: src/SUMMARY.md:70
msgid "Day 2: Morning"
msgstr "Dzie 2: Rano"

#: src/SUMMARY.md:75 src/structs.md:1
msgid "Structs"
msgstr "Struktury"

#: src/SUMMARY.md:76 src/structs/tuple-structs.md:1
msgid "Tuple Structs"
msgstr "Struktury krotkowe"

#: src/SUMMARY.md:77 src/structs/field-shorthand.md:1
msgid "Field Shorthand Syntax"
msgstr "Skr贸cona skadnia pola"

#: src/SUMMARY.md:78 src/enums.md:1
msgid "Enums"
msgstr "Wyliczenia"

#: src/SUMMARY.md:79 src/enums/variant-payloads.md:1
msgid "Variant Payloads"
msgstr "Dane w wariantach"

#: src/SUMMARY.md:80 src/enums/sizes.md:1
msgid "Enum Sizes"
msgstr "Rozmiary wylicze"

#: src/SUMMARY.md:82 src/methods/receiver.md:1
msgid "Method Receiver"
msgstr "Skadnia metody"

#: src/SUMMARY.md:83 src/SUMMARY.md:158 src/SUMMARY.md:193
#: src/methods/example.md:1 src/concurrency/shared_state/example.md:1
msgid "Example"
msgstr "Przykad"

#: src/SUMMARY.md:84 src/pattern-matching.md:1
msgid "Pattern Matching"
msgstr "Dopasowywanie wzorc贸w"

#: src/SUMMARY.md:85 src/pattern-matching/destructuring-enums.md:1
msgid "Destructuring Enums"
msgstr "Destrukturyzacja wylicze"

#: src/SUMMARY.md:86 src/pattern-matching/destructuring-structs.md:1
msgid "Destructuring Structs"
msgstr "Destrukturyzacja struktur"

#: src/SUMMARY.md:87 src/pattern-matching/destructuring-arrays.md:1
msgid "Destructuring Arrays"
msgstr "Destrukturyzacja tablic"

#: src/SUMMARY.md:88 src/pattern-matching/match-guards.md:1
msgid "Match Guards"
msgstr "Stra偶nicy w dopasowywaniu wzorc贸w"

#: src/SUMMARY.md:90 src/exercises/day-2/health-statistics.md:1
msgid "Health Statistics"
msgstr "Statystyki zdrowia"

#: src/SUMMARY.md:91 src/exercises/day-2/solutions-morning.md:3
msgid "Points and Polygons"
msgstr "Punkty i wielokty"

#: src/SUMMARY.md:93
msgid "Day 2: Afternoon"
msgstr "Dzie 2: Popoudnie"

#: src/SUMMARY.md:95 src/control-flow.md:1
msgid "Control Flow"
msgstr "Kontrola przepywu"

#: src/SUMMARY.md:96 src/control-flow/blocks.md:1
msgid "Blocks"
msgstr "Bloki"

#: src/SUMMARY.md:97
msgid "if expressions"
msgstr "Wyra偶enia if"

#: src/SUMMARY.md:98
msgid "if let expressions"
msgstr "Wyra偶enia if let"

#: src/SUMMARY.md:99
msgid "while expressions"
msgstr "Wyra偶enia while"

#: src/SUMMARY.md:100
msgid "while let expressions"
msgstr "Wyra偶enia while let"

#: src/SUMMARY.md:101
msgid "for expressions"
msgstr "Wyra偶enia for"

#: src/SUMMARY.md:102
msgid "loop expressions"
msgstr "Wyra偶enia loop"

#: src/SUMMARY.md:103
msgid "match expressions"
msgstr "Wyra偶enia match"

#: src/SUMMARY.md:104
msgid "break & continue"
msgstr "break i continue"

#: src/SUMMARY.md:105 src/std.md:1
msgid "Standard Library"
msgstr "Biblioteka standardowa"

#: src/SUMMARY.md:106
msgid "Option and Result"
msgstr "Option i Result"

#: src/SUMMARY.md:107 src/std/string.md:1
msgid "String"
msgstr "String"

#: src/SUMMARY.md:108
msgid "Vec"
msgstr "Vec"

#: src/SUMMARY.md:109
msgid "HashMap"
msgstr "HashMap"

#: src/SUMMARY.md:110
msgid "Box"
msgstr "Box"

#: src/SUMMARY.md:111
msgid "Recursive Data Types"
msgstr "Rekurencyjne typy danych"

#: src/SUMMARY.md:112 src/std/box-niche.md:1
msgid "Niche Optimization"
msgstr "Niszowa optymalizacja"

#: src/SUMMARY.md:113
msgid "Rc"
msgstr "Rc"

#: src/SUMMARY.md:114 src/modules.md:1
msgid "Modules"
msgstr "Moduy"

#: src/SUMMARY.md:115 src/modules/visibility.md:1
msgid "Visibility"
msgstr "Widoczno"

#: src/SUMMARY.md:116 src/modules/paths.md:1
msgid "Paths"
msgstr "cie偶ki"

#: src/SUMMARY.md:117 src/modules/filesystem.md:1
msgid "Filesystem Hierarchy"
msgstr "Hierarchia systemu plik贸w"

#: src/SUMMARY.md:119 src/exercises/day-2/luhn.md:1
#: src/exercises/day-2/solutions-afternoon.md:3
msgid "Luhn Algorithm"
msgstr "Algorytm Luhna"

#: src/SUMMARY.md:120 src/exercises/day-2/strings-iterators.md:1
#: src/exercises/day-2/solutions-afternoon.md:98
msgid "Strings and Iterators"
msgstr "acuchy i iteratory"

#: src/SUMMARY.md:123
msgid "Day 3: Morning"
msgstr "Dzie 3: Rano"

#: src/SUMMARY.md:128 src/traits.md:1
msgid "Traits"
msgstr "Cechy"

#: src/SUMMARY.md:129 src/traits/deriving-traits.md:1
msgid "Deriving Traits"
msgstr "Wyprowadzanie cech"

#: src/SUMMARY.md:130 src/traits/default-methods.md:1
msgid "Default Methods"
msgstr "Metody domylne"

#: src/SUMMARY.md:131 src/traits/important-traits.md:1
msgid "Important Traits"
msgstr "Wa偶ne cechy"

#: src/SUMMARY.md:132
msgid "Iterator"
msgstr "Iterator"

#: src/SUMMARY.md:133 src/traits/from-iterator.md:1
msgid "FromIterator"
msgstr "FromIterator"

#: src/SUMMARY.md:134
msgid "From and Into"
msgstr "From i Into"

#: src/SUMMARY.md:135
msgid "Read and Write"
msgstr "Read i Write"

#: src/SUMMARY.md:136
msgid "Add, Mul, ..."
msgstr "Add, Mul, ..."

#: src/SUMMARY.md:137
msgid "Drop"
msgstr "Drop"

#: src/SUMMARY.md:138
msgid "Default"
msgstr "Default"

#: src/SUMMARY.md:139 src/generics.md:1
msgid "Generics"
msgstr "Generyki"

#: src/SUMMARY.md:140 src/generics/data-types.md:1
msgid "Generic Data Types"
msgstr "Generyczne typy danych"

#: src/SUMMARY.md:141 src/generics/methods.md:1
msgid "Generic Methods"
msgstr "Metody generyczne"

#: src/SUMMARY.md:142 src/generics/trait-bounds.md:1
#, fuzzy
msgid "Trait Bounds"
msgstr "Granice cech"

#: src/SUMMARY.md:143
msgid "impl Trait"
msgstr "Skadnia impl Cecha"

#: src/SUMMARY.md:144 src/generics/closures.md:1
msgid "Closures"
msgstr "Domknicia"

#: src/SUMMARY.md:145 src/generics/monomorphization.md:1
msgid "Monomorphization"
msgstr "Monomorfizacja"

#: src/SUMMARY.md:146 src/generics/trait-objects.md:1
#, fuzzy
msgid "Trait Objects"
msgstr "Obiekty cech"

#: src/SUMMARY.md:148 src/exercises/day-3/simple-gui.md:1
#: src/exercises/day-3/solutions-morning.md:3
msgid "A Simple GUI Library"
msgstr "Prosta biblioteka GUI"

#: src/SUMMARY.md:150
msgid "Day 3: Afternoon"
msgstr "Dzie 3: Popoudnie"

#: src/SUMMARY.md:152 src/error-handling.md:1
msgid "Error Handling"
msgstr "Obsuga bd贸w"

#: src/SUMMARY.md:153 src/error-handling/panics.md:1
msgid "Panics"
msgstr "Panikowanie"

#: src/SUMMARY.md:154
msgid "Catching Stack Unwinding"
msgstr "apanie rozwinicia stosu"

#: src/SUMMARY.md:155
msgid "Structured Error Handling"
msgstr "Strukturalna obsuga bd贸w"

#: src/SUMMARY.md:156
msgid "Propagating Errors with ?"
msgstr "Propagowanie bd贸w za pomoc ?"

#: src/SUMMARY.md:157 src/error-handling/converting-error-types.md:1
#: src/error-handling/converting-error-types-example.md:1
msgid "Converting Error Types"
msgstr "Konwersja typ贸w bd贸w"

#: src/SUMMARY.md:159 src/error-handling/deriving-error-enums.md:1
#, fuzzy
msgid "Deriving Error Enums"
msgstr "Wyprowadzanie wylicze bd贸w"

#: src/SUMMARY.md:160 src/error-handling/dynamic-errors.md:1
msgid "Dynamic Error Types"
msgstr "Dynamiczne typy bd贸w"

#: src/SUMMARY.md:161 src/error-handling/error-contexts.md:1
msgid "Adding Context to Errors"
msgstr "Dodawanie kontekstu do bd贸w"

#: src/SUMMARY.md:162 src/testing.md:1
msgid "Testing"
msgstr "Testowanie"

#: src/SUMMARY.md:163 src/testing/unit-tests.md:1
msgid "Unit Tests"
msgstr "Testy jednostkowe"

#: src/SUMMARY.md:164 src/testing/test-modules.md:1
msgid "Test Modules"
msgstr "Moduy testowe"

#: src/SUMMARY.md:165 src/testing/doc-tests.md:1
msgid "Documentation Tests"
msgstr "Testy dokumentacyjne"

#: src/SUMMARY.md:166 src/testing/integration-tests.md:1
msgid "Integration Tests"
msgstr "Testy integracyjne"

#: src/SUMMARY.md:167 src/unsafe.md:1
msgid "Unsafe Rust"
msgstr "Niebezpieczny Rust"

#: src/SUMMARY.md:168 src/unsafe/raw-pointers.md:1
#, fuzzy
msgid "Dereferencing Raw Pointers"
msgstr "Dereferencja surowych wska藕nik贸w"

#: src/SUMMARY.md:169 src/unsafe/mutable-static-variables.md:1
msgid "Mutable Static Variables"
msgstr "Mutowalne zmienne statyczne"

#: src/SUMMARY.md:170 src/unsafe/unions.md:1
msgid "Unions"
msgstr "Unie"

#: src/SUMMARY.md:171 src/unsafe/calling-unsafe-functions.md:1
msgid "Calling Unsafe Functions"
msgstr "Wywoywanie niebezpiecznych funkcji"

#: src/SUMMARY.md:172 src/unsafe/writing-unsafe-functions.md:1
msgid "Writing Unsafe Functions"
msgstr "Pisanie niebezpiecznych funkcji"

#: src/SUMMARY.md:173
msgid "Extern Functions"
msgstr "Funkcje zewntrzne"

#: src/SUMMARY.md:174 src/unsafe/unsafe-traits.md:1
#, fuzzy
msgid "Implementing Unsafe Traits"
msgstr "Wdra偶anie niebezpiecznych cech"

#: src/SUMMARY.md:176 src/exercises/day-3/safe-ffi-wrapper.md:1
#: src/exercises/day-3/solutions-afternoon.md:3
msgid "Safe FFI Wrapper"
msgstr "Bezpieczne opakowanie FFI"

#: src/SUMMARY.md:179
msgid "Day 4: Morning"
msgstr "Dzie 4: Rano"

#: src/SUMMARY.md:184
msgid "Concurrency"
msgstr "Wsp贸bie偶no"

#: src/SUMMARY.md:185 src/concurrency/threads.md:1
msgid "Threads"
msgstr "Wtki"

#: src/SUMMARY.md:186 src/concurrency/scoped-threads.md:1
msgid "Scoped Threads"
msgstr "Wtki z zakresem"

#: src/SUMMARY.md:187 src/concurrency/channels.md:1
msgid "Channels"
msgstr "Kanay"

#: src/SUMMARY.md:188 src/concurrency/channels/unbounded.md:1
msgid "Unbounded Channels"
msgstr "Nieograniczone kanay"

#: src/SUMMARY.md:189 src/concurrency/channels/bounded.md:1
msgid "Bounded Channels"
msgstr "Ograniczone kanay"

#: src/SUMMARY.md:190 src/concurrency/shared_state.md:1
msgid "Shared State"
msgstr "Wsp贸dzielony stan"

#: src/SUMMARY.md:191
msgid "Arc"
msgstr "Arc"

#: src/SUMMARY.md:192
msgid "Mutex"
msgstr "Mutex"

#: src/SUMMARY.md:194
msgid "Send and Sync"
msgstr "Send i Sync"

#: src/SUMMARY.md:194
msgid "Send"
msgstr "Send"

#: src/SUMMARY.md:194
msgid "Sync"
msgstr "Sync"

#: src/SUMMARY.md:197 src/concurrency/send-sync/examples.md:1
msgid "Examples"
msgstr "Przykady"

#: src/SUMMARY.md:199 src/exercises/day-4/dining-philosophers.md:1
#: src/exercises/day-4/solutions-morning.md:3
msgid "Dining Philosophers"
msgstr "Ucztujcy filozofowie"

#: src/SUMMARY.md:200 src/exercises/day-4/link-checker.md:1
msgid "Multi-threaded Link Checker"
msgstr "Wielowtkowe narzdzie do sprawdzania link贸w"

#: src/SUMMARY.md:202
msgid "Day 4: Afternoon"
msgstr "Dzie 4: Popoudnie"

#: src/SUMMARY.md:206 src/android.md:1
msgid "Android"
msgstr "Android"

#: src/SUMMARY.md:207 src/android/setup.md:1
msgid "Setup"
msgstr "Przygotowanie"

#: src/SUMMARY.md:208 src/android/build-rules.md:1
msgid "Build Rules"
msgstr "Reguy budowania"

#: src/SUMMARY.md:209
msgid "Binary"
msgstr "Pliki binarne"

#: src/SUMMARY.md:210
msgid "Library"
msgstr "Biblioteka"

#: src/SUMMARY.md:211 src/android/aidl.md:1
msgid "AIDL"
msgstr "AIDL"

#: src/SUMMARY.md:212
msgid "Interface"
msgstr "Interfejs"

#: src/SUMMARY.md:213
msgid "Implementation"
msgstr "Implementacja"

#: src/SUMMARY.md:214
msgid "Server"
msgstr "Serwer"

#: src/SUMMARY.md:215 src/android/aidl/deploy.md:1
msgid "Deploy"
msgstr "Wdra偶anie"

#: src/SUMMARY.md:216
msgid "Client"
msgstr "Klient"

#: src/SUMMARY.md:217 src/android/aidl/changing.md:1
msgid "Changing API"
msgstr "Zmiana API"

#: src/SUMMARY.md:218 src/android/logging.md:1
msgid "Logging"
msgstr "Logowanie"

#: src/SUMMARY.md:219 src/android/interoperability.md:1
msgid "Interoperability"
msgstr "Interoperacyjno"

#: src/SUMMARY.md:220
msgid "With C"
msgstr "Z jzykiem C"

#: src/SUMMARY.md:221
msgid "Calling C with Bindgen"
msgstr "Wywoanie C z Bindgenem"

#: src/SUMMARY.md:222
msgid "Calling Rust from C"
msgstr "Wywoanie Rusta z C"

#: src/SUMMARY.md:223 src/android/interoperability/cpp.md:1
msgid "With C++"
msgstr "Z jzykiem C++"

#: src/SUMMARY.md:224
msgid "With Java"
msgstr "Z Jav"

#: src/SUMMARY.md:227
msgid "Final Words"
msgstr "Ostatnie sowa"

#: src/SUMMARY.md:229 src/thanks.md:1
msgid "Thanks!"
msgstr "Dziki!"

#: src/SUMMARY.md:230
msgid "Other Resources"
msgstr "Inne zasoby"

#: src/SUMMARY.md:231 src/credits.md:1
msgid "Credits"
msgstr "Uznania"

#: src/SUMMARY.md:235 src/exercises/solutions.md:1
msgid "Solutions"
msgstr "Rozwizania"

#: src/SUMMARY.md:240
msgid "Day 1 Morning"
msgstr "Dzie 1 Rano"

#: src/SUMMARY.md:241
msgid "Day 1 Afternoon"
msgstr "Dzie 1 Popoudnie"

#: src/SUMMARY.md:242
msgid "Day 2 Morning"
msgstr "Dzie 2 Rano"

#: src/SUMMARY.md:243
msgid "Day 2 Afternoon"
msgstr "Dzie 2 Popoudnie"

#: src/SUMMARY.md:244
msgid "Day 3 Morning"
msgstr "Dzie 3 Rano"

#: src/SUMMARY.md:245
msgid "Day 3 Afternoon"
msgstr "Dzie 3 Popoudnie"

#: src/SUMMARY.md:246
msgid "Day 4 Morning"
msgstr "Dzie 4 Rano"

#: src/welcome.md:3
msgid ""
"This is a four day Rust course developed by the Android team. The course "
"covers the full spectrum of Rust, from basic syntax to advanced topics like "
"generics and error handling. It also includes Android-specific content on "
"the last day."
msgstr ""
"To jest czterodniowy kurs Rust opracowany przez zesp贸 Androida. Kurs "
"obejmuje pene spektrum Rusta, od podstawowej skadni po zaawansowane "
"tematy, takie jak programowanie uog贸lnione i obsug bd贸w. Ostatni dzie "
"obejmuje r贸wnie偶 treci specyficzne dla Androida."

#: src/welcome.md:7
msgid ""
"The goal of the course is to teach you Rust. We assume you don't know "
"anything about Rust and hope to:"
msgstr ""
"Celem kursu jest nauczenie Ci jzyka Rust. Zakadamy, 偶e nic nie wiesz o "
"Rucie i mamy nadziej, 偶e:"

#: src/welcome.md:10
msgid "Give you a comprehensive understanding of the Rust syntax and language."
msgstr "Damy Ci kompleksowe zrozumienie skadni i jzyka Rust."

#: src/welcome.md:11
msgid "Enable you to modify existing programs and write new programs in Rust."
msgstr ""
"Umo偶liwimy modyfikowanie istniejcych program贸w i pisanie nowych program贸w w "
"Rucie."

#: src/welcome.md:12
msgid "Show you common Rust idioms."
msgstr "Poka偶emy powszechne idiomy Rusta."

#: src/welcome.md:14
msgid "On Day 4, we will cover Android-specific things such as:"
msgstr "W dniu 4 om贸wimy kwestie specyficzne dla Androida, takie jak:"

#: src/welcome.md:16
msgid "Building Android components in Rust."
msgstr "Budowanie komponent贸w Androida w Rucie."

#: src/welcome.md:17
msgid "AIDL servers and clients."
msgstr "Serwery i klienty AIDL."

#: src/welcome.md:18
msgid "Interoperability with C, C++, and Java."
msgstr "Interoperacyjno z C, C++ i Jav."

#: src/welcome.md:20
msgid ""
"It is important to note that this course does not cover Android "
"**application**  development in Rust, and that the Android-specific parts "
"are specifically about writing code for Android itself, the operating "
"system. "
msgstr ""
"Nale偶y zauwa偶y, 偶e ten kurs nie obejmuje rozwoju **aplikacji** na Androida "
"w Rucie i 偶e czci specyficzne dla Androida s o pisaniu kodu dla samego "
"Androida, systemu operacyjnego. "

#: src/welcome.md:24
msgid "Non-Goals"
msgstr "Poza zakresem"

#: src/welcome.md:26
msgid ""
"Rust is a large language and we won't be able to cover all of it in a few "
"days. Some non-goals of this course are:"
msgstr ""
"Rust to du偶y jzyk i nie bdziemy w stanie om贸wi go w caoci w cigu kilku "
"dni. Niekt贸re cele bdce poza zakresem tego kursu to:"

#: src/welcome.md:29
msgid ""
"Learn how to use async Rust --- we'll only mention async Rust when covering "
"traditional concurrency primitives. Please see [Asynchronous Programming in "
"Rust](https://rust-lang.github.io/async-book/) instead for details on this "
"topic."
msgstr ""
"U偶ywanie asynchronicznego Rusta --- wspomnimy o asynchronicznym Rucie tylko "
"wtedy, gdy obejmujce tradycyjne prymitywy wsp贸bie偶noci. Po wicej "
"szczeg贸贸w w tym temacie zobacz [Asynchronous Programming in Rust](https://"
"rust-lang.github.io/async-book/)."

#: src/welcome.md:33
msgid ""
"Learn how to develop macros, please see [Chapter 19.5 in the Rust Book]"
"(https://doc.rust-lang.org/book/ch19-06-macros.html) and [Rust by Example]"
"(https://doc.rust-lang.org/rust-by-example/macros.html) instead."
msgstr ""
"Tworzenie makr, zamiast tego zobacz [Rozdzia 19.5 w Jzyk Programowanie "
"Rust](http://rust.w8.pl/book/ch19-06-macros.html) i [Rust by Example]"
"(https://doc.rust-lang.org/rust-by-example/macros.html)."

#: src/welcome.md:37
msgid "Assumptions"
msgstr "Zao偶enia"

#: src/welcome.md:39
msgid ""
"The course assumes that you already know how to program. Rust is a "
"statically typed language and we will sometimes make comparisons with C and "
"C++ to better explain or contrast the Rust approach."
msgstr ""
"Kurs zakada, 偶e wiesz ju偶, jak programowa. Rust to statycznie typowany "
"jzyk i aby byo lepiej wyjani lub przeciwstawi podejcie Rusta czasami "
"bdziemy dokonywa por贸wna z C i C++."

#: src/welcome.md:43
msgid ""
"If you know how to program in a dynamically typed language such as Python or "
"JavaScript, then you will be able to follow along just fine too."
msgstr ""
"Jeli wiesz, jak programowa w jzyku o dynamicznym typowaniu, takim jak "
"Python lub JavaScript, to te偶 dasz sobie rad."

#: src/welcome.md:48
msgid ""
"This is an example of a _speaker note_. We will use these to add additional "
"information to the slides. This could be key points which the instructor "
"should cover as well as answers to typical questions which come up in class."
msgstr ""
"To jest przykad _notatki dla prowadzcego_. U偶yjemy ich, aby doda "
"dodatkowe informacje do slajd贸w. Mog to by kluczowe punkty, kt贸re "
"prowadzcy powinien om贸wi, a tak偶e odpowiedzi na typowe pytania, kt贸re "
"pojawiaj si na zajciach."

#: src/running-the-course.md:3 src/running-the-course/course-structure.md:3
msgid "This page is for the course instructor."
msgstr "Ta strona jest dla prowadzcego kurs."

#: src/running-the-course.md:5
msgid ""
"Here is a bit of background information about how we've been running the "
"course internally at Google."
msgstr ""
"Oto troch podstawowych informacji o tym, jak prowadzilimy ten kurs "
"wewntrznie w Google."

#: src/running-the-course.md:8
msgid "To run the course, you need to:"
msgstr "Aby prowadzi kurs nale偶y:"

#: src/running-the-course.md:10
msgid ""
"Make yourself familiar with the course material. We've included speaker "
"notes on some of the pages to help highlight the key points (please help us "
"by contributing more speaker notes!). You should make sure to open the "
"speaker notes in a popup (click the link with a little arrow next to "
"\"Speaker Notes\"). This way you have a clean screen to present to the class."
msgstr ""
"Zapoznaj si z materiaem kursu. Doczylimy notatki prowadzcego na "
"niekt贸rych stronach, aby podkreli kluczowe punkty (pom贸偶 nam dodajc "
"wicej notatek dla prowadzcego!). Powiniene upewni si, 偶e notatki s "
"otwarte w wyskakujcym okienku (kliknij cze z ma strzak obok Notatki "
"Prowadzcego\"). W ten spos贸b masz czysty ekran do zaprezentowania klasie."

#: src/running-the-course.md:16
msgid ""
"Decide on the dates. Since the course is large, we recommend that you "
"schedule the four days over two weeks. Course participants have said that "
"they find it helpful to have a gap in the course since it helps them process "
"all the information we give them."
msgstr ""
"Zdecyduj o datach. Poniewa偶 kurs jest du偶y, zalecamy zaplanowanie czterech "
"dni w przecigu dw贸ch tygodni. Uczestnicy kursu uwa偶aj, 偶e luka w kursie "
"jest pomocna, poniewa偶 pomaga im przetworzy wszystkie informacje, kt贸re im "
"przekazujemy."

#: src/running-the-course.md:21
msgid ""
"Find a room large enough for your in-person participants. We recommend a "
"class size of 15-20 people. That's small enough that people are comfortable "
"asking questions --- it's also small enough that one instructor will have "
"time to answer the questions."
msgstr ""
"Znajd藕 pok贸j wystarczajco du偶y dla uczestnik贸w. Polecamy grupy w wielkoci "
"15-20 os贸b. To na tyle mao, 偶e ludzie czuj si komfortowo w zadawaniu "
"pyta --- jest r贸wnie偶 na tyle mao, 偶e jeden prowadzcy bdzie mia czas na "
"odpowiedzenie na pytania."

#: src/running-the-course.md:26
msgid ""
"On the day of your course, show up to the room a little early to set things "
"up. We recommend presenting directly using `mdbook serve` running on your "
"laptop (see the [installation instructions](https://github.com/google/"
"comprehensive-rust#building)). This ensures optimal performance with no lag "
"as you change pages. Using your laptop will also allow you to fix typos as "
"you or the course participants spot them."
msgstr ""
"W dniu kursu przyjd藕 na sal nieco wczeniej, aby wszystko ustawi. Zalecamy "
"prezentacj bezporednio przy u偶yciu `mdbook serve` uruchomionego na twoim "
"laptopie (zobacz [instrukcja instalacji](https://github.com/google/"
"comprehensive-rust#building)). Zapewnia to optymaln wydajno bez op贸藕nie "
"podczas zmiany stron. Korzystanie z laptopa pozwoli Ci r贸wnie偶 poprawia "
"liter贸wki jak ty lub uczestnicy kursu je dostrzeg."

#: src/running-the-course.md:32
msgid ""
"Let people solve the exercises by themselves or in small groups. Make sure "
"to ask people if they're stuck or if there is anything you can help with. "
"When you see that several people have the same problem, call it out to the "
"class and offer a solution, e.g., by showing people where to find the "
"relevant information in the standard library."
msgstr ""
"Pozw贸l uczestnikom rozwizywa wiczenia samodzielnie lub w maych grupach. "
"Upewnij si, 偶e pytasz uczestnik贸w, czy utknli lub czy jest co, w czym "
"mo偶esz pom贸c. Gdy widzisz, 偶e kilka os贸b ma ten sam problem, powiedz o tym "
"klasie i zaoferuj rozwizanie, np. pokazujc gdzie znale藕 odpowiednie "
"informacje w bibliotece standardowej."

#: src/running-the-course.md:38
msgid ""
"If you don't skip the Android specific parts on Day 4, you will need an "
"[AOSP checkout](https://source.android.com/docs/setup/download/downloading). "
"Make a checkout of the [course repository](https://github.com/google/"
"comprehensive-rust) on the same machine and move the `src/android/` "
"directory into the root of your AOSP checkout. This will ensure that the "
"Android build system sees the `Android.bp` files in `src/android/`."
msgstr ""
"Jeli nie pomijasz czci zwizanych z Androidem w dniu 4, bdziesz "
"potrzebowa [AOSP](https://source.android.com/docs/setup/download/"
"downloading). cignij [repozytorium kursu](https://github.com/google/"
"comprehensive-rust) na tym samym komputerze i przenie katalog `src/android/"
"` do katalogu g贸wnego AOSP. Zapewni to, 偶e system kompilacji Androida "
"zobaczy pliki `Android.bp` w `src/android/`."

#: src/running-the-course.md:44
msgid ""
"Ensure that `adb sync` works with your emulator or real device and pre-build "
"all Android examples using `src/android/build_all.sh`. Read the script to "
"see the commands it runs and make sure they work when you run them by hand."
msgstr ""
"Upewnij si, 偶e `adb sync` dziaa z twoim emulatorem lub prawdziwym "
"urzdzeniem i prekompiluj wszystkie przykady Androida u偶ywajc `src/android/"
"build_all.sh`. Przeczytaj skrypt, 偶eby zobaczy polecenia, kt贸re uruchamia, "
"i upewnij si, 偶e dziaaj, gdy uruchamiasz je rcznie."

#: src/running-the-course.md:48
msgid ""
"That is all, good luck running the course! We hope it will be as much fun "
"for you as it has been for us!"
msgstr ""
"To wszystko, powodzenia w prowadzeniu kursu! Mamy nadziej, 偶e bdzie to dla "
"Ciebie r贸wnie zabawne jak dla nas!"

#: src/running-the-course.md:51
msgid ""
"Please [provide feedback](https://github.com/google/comprehensive-rust/"
"discussions/86) afterwards so that we can keep improving the course. We "
"would love to hear what worked well for you and what can be made better. "
"Your students are also very welcome to [send us feedback](https://github.com/"
"google/comprehensive-rust/discussions/100)!"
msgstr ""
"Prosimy o p贸藕niejsze [przekazanie opinii](https://github.com/google/"
"comprehensive-rust/discussions/86), abymy mogli dalej ulepsza kurs. "
"Chtnie dowiemy si, co sprawdzio si u Ciebie, a co mo偶na ulepszy. "
"Uczestnik贸w r贸wnie偶 zachcamy do [przesania nam swoich opinii](https://"
"github.com/google/comprehensive-rust/discussions/100)!"

#: src/running-the-course/course-structure.md:5
msgid "The course is fast paced and covers a lot of ground:"
msgstr "Kurs jest prowadzony w szybkim tempie i obejmuje du偶o materiau:"

#: src/running-the-course/course-structure.md:7
msgid "Day 1: Basic Rust, ownership and the borrow checker."
msgstr "Dzie 1: Podstawowy Rust, wasno i nadzorca po偶yczania."

#: src/running-the-course/course-structure.md:8
msgid "Day 2: Compound data types,  pattern matching, the standard library."
msgstr ""
"Dzie 2: Typy danych zo偶onych, dopasowywanie wzorc贸w, biblioteka "
"standardowa."

#: src/running-the-course/course-structure.md:9
msgid "Day 3: Traits and generics, error handling, testing, unsafe Rust."
msgstr ""
"Dzie 3: Cechy i uog贸lnienia, obsuga bd贸w, testowanie, niebezpieczny Rust."

#: src/running-the-course/course-structure.md:10
msgid "Day 4: Concurrency in Rust and interoperability with other languages"
msgstr "Dzie 4: Wsp贸bie偶no w Rucie i interoperacyjno z innymi jzykami"

#: src/running-the-course/course-structure.md:12
msgid ""
"**Exercise for Day 4:** Do you interface with some C/C++ code in your "
"project which we could attempt to move to Rust? The fewer dependencies the "
"better. Parsing code would be ideal."
msgstr ""
"**wiczenie na dzie 4:** Czy korzystasz z kodu C/C++ w swoim projekcie, "
"kt贸ry moglibymy spr贸bowa przenie do Rusta? Im mniej zale偶noci, tym "
"lepiej. Kod parsujcy byby idealny."

#: src/running-the-course/course-structure.md:16
msgid "Format"
msgstr "Format"

#: src/running-the-course/course-structure.md:18
msgid ""
"The course is meant to be very interactive and we recommend letting the "
"questions drive the exploration of Rust!"
msgstr ""
"Kurs ma by bardzo interaktywny i zalecamy pozwalanie 偶eby pytania napdzay "
"eksploracj Rusta!"

#: src/running-the-course/keyboard-shortcuts.md:3
msgid "There are several useful keyboard shortcuts in mdBook:"
msgstr "Istnieje kilka przydatnych skr贸t贸w klawiaturowych w mdBook:"

#: src/running-the-course/keyboard-shortcuts.md:5
msgid "Arrow-Left"
msgstr "Strzaka w lewo"

#: src/running-the-course/keyboard-shortcuts.md:5
msgid ": Navigate to the previous page."
msgstr ": Przejd藕 do poprzedniej strony."

#: src/running-the-course/keyboard-shortcuts.md:6
msgid "Arrow-Right"
msgstr "Strzaka w prawo"

#: src/running-the-course/keyboard-shortcuts.md:6
msgid ": Navigate to the next page."
msgstr ": Przejd藕 do nastpnej strony."

#: src/running-the-course/keyboard-shortcuts.md:7 src/cargo/code-samples.md:19
msgid "Ctrl + Enter"
msgstr "Ctrl + Enter"

#: src/running-the-course/keyboard-shortcuts.md:7
msgid ": Execute the code sample that has focus."
msgstr ": Wykonaj przykadowy kod, kt贸ry ma fokus."

#: src/running-the-course/keyboard-shortcuts.md:8
msgid "s"
msgstr "s"

#: src/running-the-course/keyboard-shortcuts.md:8
msgid ": Activate the search bar."
msgstr ": Aktywuj pasek wyszukiwania."

#: src/running-the-course/translations.md:3
msgid ""
"The course has been translated into other languages by a set of wonderful "
"volunteers:"
msgstr ""
"Kurs zosta przetumaczony na inne jzyki przez zesp贸 cudownych "
"wolontariuszy:"

#: src/running-the-course/translations.md:6
msgid ""
"[Brazilian Portuguese](https://google.github.io/comprehensive-rust/pt-BR/) "
"by [@rastringer](https://github.com/rastringer) and [@hugojacob](https://"
"github.com/hugojacob)."
msgstr ""
"[brazylijski portugalski](https://google.github.io/comprehensive-rust/pt-"
"BR/) autorstwa [@rastringer](https://github.com/rastringer) i [@hugojacob]"
"(https://github.com/hugojacob)."

#: src/running-the-course/translations.md:7
msgid ""
"[Korean](https://google.github.io/comprehensive-rust/ko/) by [@keispace]"
"(https://github.com/keispace), [@jiyongp](https://github.com/jiyongp) and "
"[@jooyunghan](https://github.com/jooyunghan)."
msgstr ""
"[koreaski](https://google.github.io/comprehensive-rust/ko/) autorstwa "
"[@keispace](https://github.com/keispace), [@jiyongp](https://github.com/"
"jiyongp) i [@jooyunghan](https://github.com/jooyunghan)."

#: src/running-the-course/translations.md:9
msgid ""
"Use the language picker in the top-right corner to switch between languages."
msgstr ""
"U偶yj selektora jzyka w prawym g贸rnym rogu, aby przecza si midzy "
"jzykami."

#: src/running-the-course/translations.md:11
msgid ""
"If you want to help with this effort, please see [our instructions](https://"
"github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md) for how to "
"get going. Translations are coordinated on the [issue tracker](https://"
"github.com/google/comprehensive-rust/issues/282)."
msgstr ""
"Jeli chcesz w tym pom贸c, zapoznaj si z [naszymi instrukcjami](https://"
"github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md) aby "
"dowiedzie si, jak to zacz. Tumaczenia s koordynowane w [narzdziu do "
"ledzenia problem贸w](https://github.com/google/comprehensive-rust/"
"issues/282)."

#: src/cargo.md:3
msgid ""
"When you start reading about Rust, you will soon meet [Cargo](https://doc."
"rust-lang.org/cargo/), the standard tool used in the Rust ecosystem to build "
"and run Rust applications. Here we want to give a brief overview of what "
"Cargo is and how it fits into the wider ecosystem and how it fits into this "
"training."
msgstr ""
"Kiedy zaczniesz czyta o Rucie, wkr贸tce poznasz [Cargo](https://doc.rust-"
"lang.org/cargo/), jest to standardowe narzdzie u偶ywany w ekosystemie Rusta "
"do tworzenia i uruchamiania aplikacji Rusta. Tutaj chcemy kr贸tko opisa, "
"czym jest Cargo i jak pasuje do szerszego ekosystemu i do tego szkolenia."

#: src/cargo.md:8
msgid "Installation"
msgstr "Instalacja"

#: src/cargo.md:10
msgid "Rustup (Recommended)"
msgstr "Rustup (zalecane)"

#: src/cargo.md:12
msgid ""
"You can follow the instructions to install cargo and rust compiler, among "
"other standard ecosystem tools with the [rustup](https://rustup.rs/) tool, "
"which is maintained by the Rust Foundation."
msgstr ""
"Mo偶esz postpowa zgodnie z instrukcjami narzdzia [rustup](https://rustup."
"rs/), aby zainstalowa Cargo, kompilator Rusta oraz inne standardowe "
"narzdzia ekosystemu Rusta. Narzdzie [rustup](https://rustup.rs/) jest "
"utrzymywane przez Fundacj Rust."

#: src/cargo.md:14
msgid ""
"Along with cargo and rustc, Rustup will install itself as a command line "
"utility that you can use to install/switch toolchains, setup cross "
"compilation, etc."
msgstr ""
"Wraz z cargo i rustc, Rustup zainstaluje si jako narzdzie wiersza polece, "
"kt贸rego mo偶na u偶y do instalacji/przeczenia acuch贸w narzdzi, "
"konfiguracji skronej kompilacji itp."

#: src/cargo.md:16
msgid "Package Managers"
msgstr "Mened偶erowie pakiet贸w"

#: src/cargo.md:18
msgid "Debian"
msgstr "Debian"

#: src/cargo.md:20
msgid ""
"On Debian/Ubuntu, you can install Cargo, the Rust source and the [Rust "
"formatter](https://github.com/rust-lang/rustfmt) with"
msgstr ""
"Na Debianie/Ubuntu mo偶esz zainstalowa Cargo, 藕r贸do Rusta i [narzdzie do "
"formatowania Rusta](https://github.com/rust-lang/rustfmt) za pomoc"

#: src/cargo.md:22
msgid ""
"```shell\n"
"$ sudo apt install cargo rust-src rustfmt\n"
"```"
msgstr ""
"```shell\n"
"$ sudo apt install cargo rust-src rustfmt\n"
"```"

#: src/cargo.md:26
msgid ""
"This will allow [rust-analyzer](https://rust-analyzer.github.io/) to jump to "
"the definitions. We suggest using [VS Code](https://code.visualstudio.com/) "
"to edit the code (but any LSP compatible editor works)."
msgstr ""
"Umo偶liwi to narzdziu [rust-analyzer](https://rust-analyzer.github.io/) "
"przechodzenie do definicji. Sugerujemy u偶ycie [VS Code](https://code."
"visualstudio.com/), aby edytowa kod (ale dziaa ka偶dy edytor kompatybilny z "
"LSP)."

#: src/cargo.md:29
msgid ""
"Some folks also like to use the [JetBrains](https://www.jetbrains.com/"
"clion/) family of IDEs, which do their own analysis but have their own "
"tradeoffs. If you prefer them, you can install the [Rust Plugin](https://www."
"jetbrains.com/rust/). Please take note that as of January 2023 debugging "
"only works on the CLion version of the JetBrains IDEA suite."
msgstr ""
"Niekt贸rzy ludzie lubi r贸wnie偶 korzysta z rodziny IDE [JetBrains](https://"
"www.jetbrains.com/clion/), kt贸re wykonuj wasne analizy, ale maj wasne "
"kompromisy. Jeli wolisz je, mo偶esz zainstalowa [wtyczk Rusta](https://www."
"jetbrains.com/rust/). Nale偶y pamita, 偶e od stycznia 2023 r. debugowanie "
"dziaa tylko w wersji CLion pakietu JetBrains IDEA."

#: src/cargo/rust-ecosystem.md:1
msgid "The Rust Ecosystem"
msgstr "Ekosystem Rusta"

#: src/cargo/rust-ecosystem.md:3
msgid ""
"The Rust ecosystem consists of a number of tools, of which the main ones are:"
msgstr "Ekosystem Rusta skada si z wielu narzdzi, z kt贸rych g贸wne to:"

#: src/cargo/rust-ecosystem.md:5
msgid ""
"`rustc`: the Rust compiler which turns `.rs` files into binaries and other "
"intermediate formats."
msgstr ""
"`rustc`: kompilator Rusta, kt贸ry zmienia pliki `.rs` na pliki binarne i inne "
"formaty porednie."

#: src/cargo/rust-ecosystem.md:8
msgid ""
"`cargo`: the Rust dependency manager and build tool. Cargo knows how to "
"download dependencies hosted on <https://crates.io> and it will pass them to "
"`rustc` when building your project. Cargo also comes with a built-in test "
"runner which is used to execute unit tests."
msgstr ""
"`cargo`: mened偶er zale偶noci Rusta i narzdzie do budowania. Cargo wie, jak "
"pobra zale偶noci hostowane na <https://crates.io> i przekaza je do `rustc` "
"podczas budowania projektu. Cargo ma r贸wnie偶 wbudowane narzdzie do "
"uruchamiania test贸w, kt贸re jest u偶ywane do wykonywania test贸w jednostkowych."

#: src/cargo/rust-ecosystem.md:13
msgid ""
"`rustup`: the Rust toolchain installer and updater. This tool is used to "
"install and update `rustc` and `cargo` when new versions of Rust is "
"released. In addition, `rustup` can also download documentation for the "
"standard library. You can have multiple versions of Rust installed at once "
"and `rustup` will let you switch between them as needed."
msgstr ""
"`rustup`: instalator i aktualizator pakietu narzdzi Rusta. To narzdzie "
"su偶y do instalowania i aktualizacji `rustc` i `cargo`, gdy zostan wydane "
"nowe wersje Rusta. Ponadto `rustup` mo偶e r贸wnie偶 pobra dokumentacj "
"biblioteki standardowej. Mo偶esz mie jednoczenie zainstalowanych wiele "
"wersji Rusta i `rustup` pozwoli ci przecza si midzy nimi w razie "
"potrzeby."

#: src/cargo/rust-ecosystem.md:21 src/hello-world.md:25
#: src/hello-world/small-example.md:27 src/why-rust/runtime.md:10
#: src/why-rust/modern.md:21 src/basic-syntax/compound-types.md:30
#: src/error-handling/try-operator.md:50
#: src/error-handling/converting-error-types-example.md:50
#: src/concurrency/threads.md:30 src/pattern-matching/destructuring-enums.md:35
msgid "Key points:"
msgstr "Kluczowe punkty:"

#: src/cargo/rust-ecosystem.md:23
msgid ""
"Rust has a rapid release schedule with a new release coming out every six "
"weeks. New releases maintain backwards compatibility with old releases --- "
"plus they enable new functionality."
msgstr ""
"Rust ma szybki harmonogram wyda z now wersj co sze tygodni. Nowe wersje "
"zachowuj kompatybilno wsteczn z starymi wersjami --- plus umo偶liwiaj "
"nowe funkcjonalnoci."

#: src/cargo/rust-ecosystem.md:27
msgid ""
"There are three release channels: \"stable\", \"beta\", and \"nightly\"."
msgstr ""
"Istniej trzy kanay wydania: \"stable\" (\"stabilny\"), \"beta\" i "
"\"nightly\" (\"nocny\")."

#: src/cargo/rust-ecosystem.md:29
msgid ""
"New features are being tested on \"nightly\", \"beta\" is what becomes "
"\"stable\" every six weeks."
msgstr ""
"Nowe funkcje s testowane na \"nightly\", \"beta\" jest tym, co staje si "
"\"stable\" co sze tygodni."

#: src/cargo/rust-ecosystem.md:32
msgid ""
"Rust also has [editions](https://doc.rust-lang.org/edition-guide/): the "
"current edition is Rust 2021. Previous editions were Rust 2015 and Rust 2018."
msgstr ""
"Rust ma r贸wnie偶 [edycje](https://doc.rust-lang.org/edition-guide/): obecna "
"edycja to Rust 2021. Poprzednie edycje to Rust 2015 i Rust 2018."

#: src/cargo/rust-ecosystem.md:35
msgid ""
"The editions are allowed to make backwards incompatible changes to the "
"language."
msgstr "Edycje mog wprowadza do jzyka zmiany niekompatybilne wstecznie."

#: src/cargo/rust-ecosystem.md:38
msgid ""
"To prevent breaking code, editions are opt-in: you select the edition for "
"your crate via the `Cargo.toml` file."
msgstr ""
"Aby zapobiec niekompatybilnoci kodu, edycje s opcjonalne: wybierasz edycj "
"swojej skrzyni za pomoc pliku `Cargo.toml`."

#: src/cargo/rust-ecosystem.md:41
msgid ""
"To avoid splitting the ecosystem, Rust compilers can mix code written for "
"different editions."
msgstr ""
"Aby unikn podziau ekosystemu, kompilatory Rusta mog miesza kod napisany "
"dla r贸偶nych edycji."

#: src/cargo/rust-ecosystem.md:44
msgid ""
"Mention that it is quite rare to ever use the compiler directly not through "
"`cargo` (most users never do)."
msgstr ""
"Wspomnij, 偶e do rzadko u偶ywa si kompilatora bezporednio, a nie przez "
"`cargo` (wikszo u偶ytkownik贸w nigdy tego nie robi)."

#: src/cargo/rust-ecosystem.md:46
msgid ""
"It might be worth alluding that Cargo itself is an extremely powerful and "
"comprehensive tool.  It is capable of many advanced features including but "
"not limited to: "
msgstr ""
"Warto wspomnie, 偶e samo Cargo jest niezwykle pot偶nym i wszechstronnym "
"narzdziem. Jest zdolne do wielu zaawansowanych funkcji, w tym midzy innymi:"

#: src/cargo/rust-ecosystem.md:47
msgid "Project/package structure"
msgstr "Struktura projektu/pakietu"

#: src/cargo/rust-ecosystem.md:48
msgid "[workspaces](https://doc.rust-lang.org/cargo/reference/workspaces.html)"
msgstr ""
"[obszary robocze](https://doc.rust-lang.org/cargo/reference/workspaces.html)"

#: src/cargo/rust-ecosystem.md:49
msgid "Dev Dependencies and Runtime Dependency management/caching"
msgstr "Zarzdzanie/buforowanie zale偶noci"

#: src/cargo/rust-ecosystem.md:50
msgid ""
"[build scripting](https://doc.rust-lang.org/cargo/reference/build-scripts."
"html)"
msgstr ""
"[tworzenie skrypt贸w](https://doc.rust-lang.org/cargo/reference/build-scripts."
"html)"

#: src/cargo/rust-ecosystem.md:51
msgid ""
"[global installation](https://doc.rust-lang.org/cargo/commands/cargo-install."
"html)"
msgstr ""
"[instalacja globalna](https://doc.rust-lang.org/cargo/commands/cargo-install."
"html)"

#: src/cargo/rust-ecosystem.md:52
msgid ""
"It is also extensible with sub command plugins as well (such as [cargo "
"clippy](https://github.com/rust-lang/rust-clippy))."
msgstr ""
"Jest r贸wnie偶 rozszerzalne za pomoc wtyczek polece podrzdnych (takich jak "
"[cargo clippy](https://github.com/rust-lang/rust-clippy))."

#: src/cargo/rust-ecosystem.md:53
msgid ""
"Read more from the [official Cargo Book](https://doc.rust-lang.org/cargo/)"
msgstr ""
"Przeczytaj wicej w [oficjalnej ksidze Cargo](https://doc.rust-lang.org/"
"cargo/)"

#: src/cargo/code-samples.md:1
msgid "Code Samples in This Training"
msgstr "Pr贸bki kodu"

#: src/cargo/code-samples.md:3
msgid ""
"For this training, we will mostly explore the Rust language through examples "
"which can be executed through your browser. This makes the setup much easier "
"and ensures a consistent experience for everyone."
msgstr ""
"Na tym szkoleniu bdziemy g贸wnie poznawa jzyk Rust poprzez przykady "
"kt贸re mo偶na wykona za porednictwem przegldarki. To znacznie uatwia "
"konfiguracj i zapewnia sp贸jne wra偶enia dla wszystkich."

#: src/cargo/code-samples.md:7
msgid ""
"Installing Cargo is still encouraged: it will make it easier for you to do "
"the exercises. On the last day, we will do a larger exercise which shows you "
"how to work with dependencies and for that you need Cargo."
msgstr ""
"Nadal zachcamy do instalowania Cargo: uatwi ci to wykonanie wicze. "
"Ostatniego dnia wykonamy wiksze wiczenie, kt贸re poka偶e ci, jak pracowa z "
"zale偶nociami i do tego potrzebujesz Cargo."

#: src/cargo/code-samples.md:11
msgid "The code blocks in this course are fully interactive:"
msgstr "Bloki kodu w tym kursie s w peni interaktywne:"

#: src/cargo/code-samples.md:13
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"Edit me!\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"Zmie mnie!\");\n"
"}\n"
"```"

#: src/cargo/code-samples.md:19
msgid "You can use "
msgstr "Mo偶esz u偶y "

#: src/cargo/code-samples.md:19
msgid " to execute the code when focus is in the text box."
msgstr ", aby wykona kod, gdy fokus znajduje si w polu tekstowym."

#: src/cargo/code-samples.md:24
msgid ""
"Most code samples are editable like shown above. A few code samples are not "
"editable for various reasons:"
msgstr ""
"Wikszo przykad贸w kodu mo偶na edytowa, jak pokazano powy偶ej. Kilku pr贸bek "
"kodu nie mo偶na edytowa z r贸偶nych powod贸w:"

#: src/cargo/code-samples.md:27
msgid ""
"The embedded playgrounds cannot execute unit tests. Copy-paste the code and "
"open it in the real Playground to demonstrate unit tests."
msgstr ""
"Wbudowane playground nie mog wykonywa test贸w jednostkowych. Kopiuj-wklej "
"kod i otw贸rz go na prawdziwym Playground, aby zademonstrowa testy "
"jednostkowe."

#: src/cargo/code-samples.md:30
msgid ""
"The embedded playgrounds lose their state the moment you navigate away from "
"the page! This is the reason that the students should solve the exercises "
"using a local Rust installation or via the Playground."
msgstr ""
"Wbudowane playground trac sw贸j stan w momencie nawigacji z dala od strony! "
"To jest pow贸d, dla kt贸rego uczniowie powinni rozwizywa wiczenia "
"korzystajc z lokalnej instalacji Rusta lub za porednictwem prawdziwego "
"Playground."

#: src/cargo/running-locally.md:1
msgid "Running Code Locally with Cargo"
msgstr "Uruchamianie kodu lokalnie z Cargo"

#: src/cargo/running-locally.md:3
msgid ""
"If you want to experiment with the code on your own system, then you will "
"need to first install Rust. Do this by following the [instructions in the "
"Rust Book](https://doc.rust-lang.org/book/ch01-01-installation.html). This "
"should give you a working `rustc` and `cargo`. At the time of writing, the "
"latest stable Rust release has these version numbers:"
msgstr ""
"Jeli chcesz eksperymentowa z kodem we wasnym systemie, bdziesz musie "
"najpierw zainstalowa Rusta. Zr贸b to, postpujc zgodnie z [instrukcjami w "
"ksi偶ce Jzyk Programowania Rust](http://rust.w8.pl/book/ch01-01-"
"installation.html). To powinno da dziaajce `rustc` i `cargo`. Aktualnie "
"najnowsza stabilna wersja Rusta ma nastpujce numery wersji:"

#: src/cargo/running-locally.md:8
msgid ""
"```shell\n"
"% rustc --version\n"
"rustc 1.61.0 (fe5b13d68 2022-05-18)\n"
"% cargo --version\n"
"cargo 1.61.0 (a028ae4 2022-04-29)\n"
"```"
msgstr ""
"```shell\n"
"% rustc --version\n"
"rustc 1.61.0 (fe5b13d68 2022-05-18)\n"
"% cargo --version\n"
"cargo 1.61.0 (a028ae4 2022-04-29)\n"
"```"

#: src/cargo/running-locally.md:15
msgid ""
"With this is in place, then follow these steps to build a Rust binary from "
"one of the examples in this training:"
msgstr ""
"Nastpnie wykonaj nastpujce kroki, aby zbudowa plik binarny Rusta z "
"jednego z przykad贸w w tym szkoleniu:"

#: src/cargo/running-locally.md:18
msgid "Click the \"Copy to clipboard\" button on the example you want to copy."
msgstr ""
"Kliknij przycisk Kopiuj do schowka na przykadzie, kt贸ry chcesz skopiowa."

#: src/cargo/running-locally.md:20
msgid ""
"Use `cargo new exercise` to create a new `exercise/` directory for your code:"
msgstr ""
"U偶yj polecenia `cargo new exercise`, aby utworzy nowy katalog `exercise/` "
"dla swojego kodu:"

#: src/cargo/running-locally.md:22
msgid ""
"```\n"
"```shell\n"
"$ cargo new exercise\n"
"     Created binary (application) `exercise` package\n"
"```\n"
"```"
msgstr ""
"```\n"
"```shell\n"
"$ cargo new exercise\n"
"     Created binary (application) `exercise` package\n"
"```\n"
"```"

#: src/cargo/running-locally.md:27
msgid ""
"Navigate into `exercise/` and use `cargo run` to build and run your binary:"
msgstr ""
"Przejd藕 do `exercise/` i u偶yj `cargo run`, aby zbudowa i uruchomi plik "
"binarny:"

#: src/cargo/running-locally.md:29
msgid ""
"```\n"
"```shell\n"
"$ cd exercise\n"
"$ cargo run\n"
"   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.75s\n"
"     Running `target/debug/exercise`\n"
"Hello, world!\n"
"```\n"
"```"
msgstr ""
"```\n"
"```shell\n"
"$ cd exercise\n"
"$ cargo run\n"
"   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.75s\n"
"     Running `target/debug/exercise`\n"
"Hello, world!\n"
"```\n"
"```"

#: src/cargo/running-locally.md:38
msgid ""
"Replace the boiler-plate code in `src/main.rs` with your own code. For "
"example, using the example on the previous page, make `src/main.rs` look like"
msgstr ""
"Zastp kod w `src/main.rs` wasnym kodem. Na przykad, korzystajc z "
"przykadu na poprzedniej stronie, spraw, aby `src/main.rs` wyglda tak"

#: src/cargo/running-locally.md:41
msgid ""
"```\n"
"```rust\n"
"fn main() {\n"
"    println!(\"Edit me!\");\n"
"}\n"
"```\n"
"```"
msgstr ""
"```\n"
"```rust\n"
"fn main() {\n"
"    println!(\"Zmie mnie!\");\n"
"}\n"
"```\n"
"```"

#: src/cargo/running-locally.md:47
msgid "Use `cargo run` to build and run your updated binary:"
msgstr ""
"U偶yj polecenia `cargo run`, aby zbudowa i uruchomi zaktualizowany plik "
"binarny:"

#: src/cargo/running-locally.md:49
msgid ""
"```\n"
"```shell\n"
"$ cargo run\n"
"   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.24s\n"
"     Running `target/debug/exercise`\n"
"Edit me!\n"
"```\n"
"```"
msgstr ""
"```\n"
"```shell\n"
"$ cargo run\n"
"   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.24s\n"
"     Running `target/debug/exercise`\n"
"Zmie mnie!\n"
"```\n"
"```"

#: src/cargo/running-locally.md:57
msgid ""
"Use `cargo check` to quickly check your project for errors, use `cargo "
"build` to compile it without running it. You will find the output in `target/"
"debug/` for a normal debug build. Use `cargo build --release` to produce an "
"optimized release build in `target/release/`."
msgstr ""
"U偶yj `cargo check`, aby szybko sprawdzi sw贸j projekt pod ktem bd贸w, u偶yj "
"`cargo build` aby skompilowa go bez uruchamiania. Dane wyjciowe znajdziesz "
"w `target/debug/` dla normalnej kompilacji do debugowania. U偶yj polecenia "
"`cargo build --release`, aby utworzy zoptymalizowany plik do wydania w "
"`target/release/`."

#: src/cargo/running-locally.md:62
msgid ""
"You can add dependencies for your project by editing `Cargo.toml`. When you "
"run `cargo` commands, it will automatically download and compile missing "
"dependencies for you."
msgstr ""
"Mo偶esz doda zale偶noci dla swojego projektu, edytujc `Cargo.toml`. Kiedy "
"uruchamiasz polecenia `cargo`, Cargo automatycznie pobierze i skompiluje "
"brakujce zale偶noci dla Ciebie."

#: src/cargo/running-locally.md:70
msgid ""
"Try to encourage the class participants to install Cargo and use a local "
"editor. It will make their life easier since they will have a normal "
"development environment."
msgstr ""
"Spr贸buj zachci uczestnik贸w zaj do zainstalowania Cargo i korzystania z "
"edytora tekstu. Uatwi im to 偶ycie, poniewa偶 bd mieli normalne rodowisko "
"programistyczne."

#: src/welcome-day-1.md:1
msgid "Welcome to Day 1"
msgstr "Witamy w dniu 1"

#: src/welcome-day-1.md:3
msgid ""
"This is the first day of Comprehensive Rust. We will cover a lot of ground "
"today:"
msgstr "To pierwszy dzie Comprehensive Rust. Przerobimy dzi du偶o materiau:"

#: src/welcome-day-1.md:6
msgid ""
"Basic Rust syntax: variables, scalar and compound types, enums, structs, "
"references, functions, and methods."
msgstr ""
"Podstawowa skadnia Rusta: zmienne, typy skalarne i zo偶one, wyliczenia, "
"struktury, referencje, funkcje i metody."

#: src/welcome-day-1.md:9
msgid ""
"Memory management: stack vs heap, manual memory management, scope-based "
"memory management, and garbage collection."
msgstr ""
"Zarzdzanie pamici: stos a sterta, rczne zarzdzanie pamici, "
"zarzdzanie pamici oparte na zakresie i odmiecanie pamici."

#: src/welcome-day-1.md:12
msgid ""
"Ownership: move semantics, copying and cloning, borrowing, and lifetimes."
msgstr ""
"Wasno: semantyka przenoszenia, kopiowanie i klonowanie, po偶yczanie i "
"czasy 偶ycia."

#: src/welcome-day-1.md:16
msgid "Please remind the students that:"
msgstr "Prosz przypomnie uczniom, 偶e:"

#: src/welcome-day-1.md:18
msgid ""
"They should ask questions when they get them, don't save them to the end."
msgstr ""
"Powinni zadawa pytania, kiedy je dostan, nich ich nie zachowuj do koca."

#: src/welcome-day-1.md:19
msgid ""
"The class is meant to be interactive and discussions are very much "
"encouraged!"
msgstr "Klasa ma by interaktywna, a dyskusje s bardzo mile widziane!"

#: src/welcome-day-1.md:20
msgid ""
"As an instructor, you should try to keep the discussions relevant, i.e., "
"keep the related to how Rust does things vs some other language. It can be "
"hard to find the right balance, but err on the side of allowing discussions "
"since they engage people much more than one-way communication."
msgstr ""
"Jako prowadzcy powiniene stara si, aby dyskusje byy istotne, tj. "
"zachowaj zwizek z tym, jak Rust robi rzeczy w por贸wnaniu z innym jzykiem. "
"Mo偶e by ci偶ko znale藕 waciw r贸wnowag, ale skaniaj si do zezwalania "
"na dyskusje poniewa偶 anga偶uj ludzi znacznie bardziej ni偶 jednokierunkowa "
"komunikacja."

#: src/welcome-day-1.md:24
msgid ""
"The questions will likely mean that we talk about things ahead of the slides."
msgstr ""
"Pytania prawdopodobnie oznaczaj, 偶e rozmawiamy o rzeczach przed slajdami."

#: src/welcome-day-1.md:25
msgid ""
"This is perfectly okay! Repetition is an important part of learning. "
"Remember that the slides are just a support and you are free to skip them as "
"you like."
msgstr ""
"To jest cakowicie w porzdku! Powtarzanie jest wa偶n czci uczenia si. "
"Pamitaj, 偶e slajdy s tylko wsparciem i je偶eli chcesz to mo偶esz je pomin."

#: src/welcome-day-1.md:29
msgid ""
"The idea for the first day is to show _just enough_ of Rust to be able to "
"speak about the famous borrow checker. The way Rust handles memory is a "
"major feature and we should show students this right away."
msgstr ""
"Ide pierwszego dnia jest pokazanie _tylko tyle_ Rusta, 偶eby m贸c m贸wi o "
"synnym nadzorcu po偶yczania. Spos贸b, w jaki Rust obsuguje pami, jest jego "
"g贸wn cech i powinnimy od razu pokaza to uczniom."

#: src/welcome-day-1.md:33
msgid ""
"If you're teaching this in a classroom, this is a good place to go over the "
"schedule. We suggest splitting the day into two parts (following the slides):"
msgstr ""
"Jeli uczysz tego w klasie, jest to dobre miejsce do przejrzenia "
"harmonogramu. Proponujemy podzieli dzie na dwie czci (wedug slajd贸w):"

#: src/welcome-day-1.md:36
msgid "Morning: 9:00 to 12:00,"
msgstr "Rano: od 9:00 do 12:00,"

#: src/welcome-day-1.md:37
msgid "Afternoon: 13:00 to 16:00."
msgstr "Po poudniu: od 13:00 do 16:00."

#: src/welcome-day-1.md:39
msgid ""
"You can of course adjust this as necessary. Please make sure to include "
"breaks, we recommend a break every hour!"
msgstr ""
"Mo偶na to oczywicie dostosowa w razie potrzeby. Prosz uwzgldni przerwy, "
"zalecamy przerw co godzin!"

#: src/welcome-day-1/what-is-rust.md:3
msgid ""
"Rust is a new programming language which had its [1.0 release in 2015]"
"(https://blog.rust-lang.org/2015/05/15/Rust-1.0.html):"
msgstr ""
"Rust to nowy jzyk programowania, kt贸ry mia swoje [wydanie 1.0 w 2015 roku]"
"(https://blog.rust-lang.org/2015/05/15/Rust-1.0.html):"

#: src/welcome-day-1/what-is-rust.md:5
msgid "Rust is a statically compiled language in a similar role as C++"
msgstr "Rust to jzyk kompilowany statycznie, penicy podobn rol jak C++"

#: src/welcome-day-1/what-is-rust.md:6
msgid "`rustc` uses LLVM as its backend."
msgstr "`rustc` u偶ywa LLVM jako backendu."

#: src/welcome-day-1/what-is-rust.md:7
msgid ""
"Rust supports many [platforms and architectures](https://doc.rust-lang.org/"
"nightly/rustc/platform-support.html):"
msgstr ""
"Rust obsuguje wiele [platform i architektur](https://doc.rust-lang.org/"
"nightly/rustc/platform-support.html):"

#: src/welcome-day-1/what-is-rust.md:9
msgid "x86, ARM, WebAssembly, ..."
msgstr "x86, ARM, WebAssembly, ..."

#: src/welcome-day-1/what-is-rust.md:10
msgid "Linux, Mac, Windows, ..."
msgstr "Linux, Mac, Windows,..."

#: src/welcome-day-1/what-is-rust.md:11
msgid "Rust is used for a wide range of devices:"
msgstr "Rust jest u偶ywany w szerokiej gamie urzdze:"

#: src/welcome-day-1/what-is-rust.md:12
msgid "firmware and boot loaders,"
msgstr "firmware i bootloadery,"

#: src/welcome-day-1/what-is-rust.md:13
msgid "smart displays,"
msgstr "inteligentne wywietlacze,"

#: src/welcome-day-1/what-is-rust.md:14
msgid "mobile phones,"
msgstr "telefony kom贸rkowe,"

#: src/welcome-day-1/what-is-rust.md:15
msgid "desktops,"
msgstr "komputery stacjonarne,"

#: src/welcome-day-1/what-is-rust.md:16
msgid "servers."
msgstr "serwery."

#: src/welcome-day-1/what-is-rust.md:21
msgid "Rust fits in the same area as C++:"
msgstr "Rust pasuje do tego samego obszaru co C++:"

#: src/welcome-day-1/what-is-rust.md:23
msgid "High flexibility."
msgstr "Wysoka elastyczno."

#: src/welcome-day-1/what-is-rust.md:24
msgid "High level of control."
msgstr "Wysoki poziom kontroli."

#: src/welcome-day-1/what-is-rust.md:25
msgid "Can be scaled down to very constrained devices like mobile phones."
msgstr ""
"Mo偶na skalowa do bardzo ograniczonych urzdze, takich jak telefony "
"kom贸rkowe."

#: src/welcome-day-1/what-is-rust.md:26
msgid "Has no runtime or garbage collection."
msgstr "Nie ma biblioteki uruchomieniowej ani odmiecania pamici."

#: src/welcome-day-1/what-is-rust.md:27
msgid "Focuses on reliability and safety without sacrificing performance."
msgstr ""
"Koncentruje si na niezawodnoci i bezpieczestwie bez powicania "
"wydajnoci."

#: src/hello-world.md:3
msgid ""
"Let us jump into the simplest possible Rust program, a classic Hello World "
"program:"
msgstr ""
"Przejd藕my do najprostszego mo偶liwego programu Rust, klasycznego Hello World "
"program:"

#: src/hello-world.md:6
msgid ""
"```rust\n"
"fn main() {\n"
"    println!(\"Hello !\");\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    println!(\"Witaj !\");\n"
"}\n"
"```"

#: src/hello-world.md:12
msgid "What you see:"
msgstr "Co wida:"

#: src/hello-world.md:14
msgid "Functions are introduced with `fn`."
msgstr "Funkcje s wprowadzane za pomoc `fn`."

#: src/hello-world.md:15
msgid "Blocks are delimited by curly braces like in C and C++."
msgstr "Bloki s oddzielone nawiasami klamrowymi, jak w C i C++."

#: src/hello-world.md:16
msgid "The `main` function is the entry point of the program."
msgstr "Funkcja `main` jest punktem wejcia programu."

#: src/hello-world.md:17
msgid "Rust has hygienic macros, `println!` is an example of this."
msgstr "Rust ma higieniczne makra, `println!` jest tego przykadem."

#: src/hello-world.md:18
msgid "Rust strings are UTF-8 encoded and can contain any Unicode character."
msgstr ""
"acuchy znak贸w w Rucie s zakodowane w UTF-8 i mog zawiera dowolne znaki "
"Unicode."

#: src/hello-world.md:22
msgid ""
"This slide tries to make the students comfortable with Rust code. They will "
"see a ton of it over the next four days so we start small with something "
"familiar."
msgstr ""
"Ten slajd ma na celu zapoznanie uczni贸w z kodem Rusta. Zobacz tego du偶o w "
"cigu nastpnych czterech dni, wic zaczniemy od czego znajomego."

#: src/hello-world.md:27
msgid ""
"Rust is very much like other languages in the C/C++/Java tradition. It is "
"imperative (not functional) and it doesn't try to reinvent things unless "
"absolutely necessary."
msgstr ""
"Rust jest bardzo podobny do innych jzyk贸w w tradycji C/C++/Java. Jest "
"imperatywny (nie funkcjonalny) i nie pr贸buje wymyla rzeczy na nowo jeli "
"nie ma takiej potrzeby."

#: src/hello-world.md:31
msgid "Rust is modern with full support for things like Unicode."
msgstr "Rust jest nowoczesny, ma pene wsparcie dla rzeczy takich jak Unicode."

#: src/hello-world.md:33
msgid ""
"Rust uses macros for situations where you want to have a variable number of "
"arguments (no function [overloading](basic-syntax/functions-interlude.md))."
msgstr ""
"Rust u偶ywa makr w sytuacjach, w kt贸rych chcesz mie zmienn liczb argumenty "
"(brak [przeci偶ania funkcji](basic-syntax/functions-interlude.md))."

#: src/hello-world/small-example.md:3
msgid "Here is a small example program in Rust:"
msgstr "Oto may przykadowy program w Rucie:"

#: src/hello-world/small-example.md:5
msgid ""
"```rust,editable\n"
"fn main() {              // Program entry point\n"
"    let mut x: i32 = 6;  // Mutable variable binding\n"
"    print!(\"{x}\");       // Macro for printing, like printf\n"
"    while x != 1 {       // No parenthesis around expression\n"
"        if x % 2 == 0 {  // Math like in other languages\n"
"            x = x / 2;\n"
"        } else {\n"
"            x = 3 * x + 1;\n"
"        }\n"
"        print!(\" -> {x}\");\n"
"    }\n"
"    println!();\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {              // Punkt wejcia do programu\n"
"    let mut x: i32 = 6;  // Zmienna mutowalna\n"
"    print!(\"{x}\");       // Makro do wypisywania tekstu, jak printf\n"
"    while x != 1 {       // Wyra偶enie bez nawias贸w\n"
"        if x % 2 == 0 {  // Obliczenia jak w innych jzykach\n"
"            x = x / 2;\n"
"        } else {\n"
"            x = 3 * x + 1;\n"
"        }\n"
"        print!(\" -> {x}\");\n"
"    }\n"
"    println!();\n"
"}\n"
"```"

#: src/hello-world/small-example.md:23
msgid ""
"The code implements the Collatz conjecture: it is believed that the loop "
"will always end, but this is not yet proved. Edit the code and play with "
"different inputs."
msgstr ""
"Kod implementuje hipotez Collatza: uwa偶a si, 偶e ptla zawsze si koczy, "
"ale nie zostao to jeszcze udowodnione. Edytuj kod i baw si r贸偶nymi danymi "
"wejciowymi."

#: src/hello-world/small-example.md:29
msgid ""
"Explain that all variables are statically typed. Try removing `i32` to "
"trigger type inference. Try with `i8` instead and trigger a runtime integer "
"overflow."
msgstr ""
"Wyjanij, 偶e wszystkie zmienne s typowane statycznie. Spr贸buj usun `i32`, "
"aby uruchomi wnioskowanie typu. Zamiast tego spr贸buj z `i8` i wywoaj "
"przepenienie liczby cakowitej w czasie wykonywania."

#: src/hello-world/small-example.md:32
msgid "Change `let mut x` to `let x`, discuss the compiler error."
msgstr "Zmie `let mut x` na `let x`, om贸w bd kompilatora."

#: src/hello-world/small-example.md:34
msgid ""
"Show how `print!` gives a compilation error if the arguments don't match the "
"format string."
msgstr ""
"Poka偶, jak `print!` daje bd kompilacji, jeli argumenty nie pasuj do "
"acucha formatujcego."

#: src/hello-world/small-example.md:37
msgid ""
"Show how you need to use `{}` as a placeholder if you want to print an "
"expression which is more complex than just a single variable."
msgstr ""
"Poka偶, 偶e  musisz u偶y `{}` jako symbolu zastpczego, jeli chcesz wypisa "
"wyra偶enie, kt贸re jest bardziej zo偶one ni偶 tylko pojedyncza zmienna."

#: src/hello-world/small-example.md:40
msgid ""
"Show the students the standard library, show them how to search for `std::"
"fmt` which has the rules of the formatting mini-language. It's important "
"that the students become familiar with searching in the standard library."
msgstr ""
"Poka偶 uczniom standardow bibliotek, poka偶 im, jak szuka `std::fmt` kt贸ry "
"ma zasady mini-jzyka formatowania. Wa偶ne jest, aby studenci zapoznaj si z "
"wyszukiwaniem w bibliotece standardowej."

#: src/why-rust.md:3
msgid "Some unique selling points of Rust:"
msgstr "Niekt贸re unikalne zalety Rusta:"

#: src/why-rust.md:5
msgid "Compile time memory safety."
msgstr "Bezpieczestwo pamici w czasie kompilacji."

#: src/why-rust.md:6
msgid "Lack of undefined runtime behavior."
msgstr "Brak niezdefiniowanego zachowania w czasie wykonywania."

#: src/why-rust.md:7
msgid "Modern language features."
msgstr "Nowoczesne funkcje jzykowe."

#: src/why-rust.md:11
msgid ""
"Make sure to ask the class which languages they have experience with. "
"Depending on the answer you can highlight different features of Rust:"
msgstr ""
"Pamitaj, aby zapyta klas, z jakimi jzykami maj dowiadczenie. W "
"zale偶noci od odpowiedzi mo偶esz wyr贸偶ni r贸偶ne funkcje Rusta:"

#: src/why-rust.md:14
msgid ""
"Experience with C or C++: Rust eliminates a whole class of _runtime errors_ "
"via the borrow checker. You get performance like in C and C++, but you don't "
"have the memory unsafety issues. In addition, you get a modern language with "
"constructs like pattern matching and built-in dependency management."
msgstr ""
"Dowiadczenie z C lub C++: Rust eliminuje ca klas bd贸w _w czasie "
"dziaania_ za porednictwem nadzorcy po偶yczania. Otrzymujesz wydajno jak w "
"C i C++, ale bez problem贸w z bezpieczestwem pamici. Ponadto otrzymujesz "
"nowoczesny jzyk z konstrukcjami, jak dopasowywanie wzorc贸w i wbudowane "
"zarzdzanie zale偶nociami."

#: src/why-rust.md:19
msgid ""
"Experience with Java, Go, Python, JavaScript...: You get the same memory "
"safety as in those languages, plus a similar high-level language feeling. In "
"addition you get fast and predictable performance like C and C++ (no garbage "
"collector) as well as access to low-level hardware (should you need it)"
msgstr ""
"Dowiadczenie z Jav, Go, Pythonem, JavaScript...: Otrzymujesz takie samo "
"bezpieczestwo pamici jak w tych jzykach, plus podobne uczucie jzyka "
"wysokiego poziomu. Ponadto otrzymujesz szybk i przewidywaln wydajno jak "
"w C i C++ (bez Garbage Collectora) a tak偶e dostp do sprztu na niskim "
"poziomie (jeli go potrzebujesz)"

#: src/why-rust/compile-time.md:3
msgid "Static memory management at compile time:"
msgstr "Statyczne zarzdzanie pamici w czasie kompilacji:"

#: src/why-rust/compile-time.md:5
msgid "No uninitialized variables."
msgstr "Brak niezainicjowanych zmiennych."

#: src/why-rust/compile-time.md:6
msgid "No memory leaks (_mostly_, see notes)."
msgstr "Brak wyciek贸w pamici (_g贸wnie_, patrz uwagi)."

#: src/why-rust/compile-time.md:7
msgid "No double-frees."
msgstr "Brak podw贸jnych zwolnie pamici."

#: src/why-rust/compile-time.md:8
msgid "No use-after-free."
msgstr "Brak u偶ycia po zwolnieniu."

#: src/why-rust/compile-time.md:9
msgid "No `NULL` pointers."
msgstr "Brak wska藕nik贸w `NULL`."

#: src/why-rust/compile-time.md:10
msgid "No forgotten locked mutexes."
msgstr "呕adnych zapomnianych zablokowanych muteks贸w."

#: src/why-rust/compile-time.md:11
msgid "No data races between threads."
msgstr "Brak wycig贸w danych midzy wtkami."

#: src/why-rust/compile-time.md:12
msgid "No iterator invalidation."
msgstr "Brak uniewa偶niania iteratora."

#: src/why-rust/compile-time.md:16
msgid ""
"It is possible to produce memory leaks in (safe) Rust. Some examples are:"
msgstr ""
"Mo偶liwe jest generowanie wyciek贸w pamici w (bezpiecznym) Rucie. Kilka "
"przykad贸w:"

#: src/why-rust/compile-time.md:19
msgid ""
"You can for use [`Box::leak`](https://doc.rust-lang.org/std/boxed/struct.Box."
"html#method.leak) to leak a pointer. A use of this could be to get runtime-"
"initialized and runtime-sized static variables"
msgstr ""
"Mo偶esz u偶y [`Box::leak`](https://doc.rust-lang.org/std/boxed/struct.Box."
"html#method.leak) do wycieku wska藕nika. Mo偶na to wykorzysta, aby uzyska "
"zmienne statyczne inicjowane w czasie wykonywania i o rozmiarze czasu "
"wykonywania"

#: src/why-rust/compile-time.md:21
msgid ""
"You can use [`std::mem::forget`](https://doc.rust-lang.org/std/mem/fn.forget."
"html) to make the compiler \"forget\" about a value (meaning the destructor "
"is never run)."
msgstr ""
"Mo偶esz u偶y [`std::mem::forget`](https://doc.rust-lang.org/std/mem/fn.forget."
"html), aby kompilator zapomnia o wartoci (co oznacza, 偶e destruktor "
"nigdy nie jest uruchamiany)."

#: src/why-rust/compile-time.md:23
msgid ""
"You can also accidentally create a [reference cycle](https://doc.rust-lang."
"org/book/ch15-06-reference-cycles.html) with `Rc` or `Arc`."
msgstr ""
"Mo偶esz tak偶e przypadkowo utworzy [cykl referencyjny](http://rust.w8.pl/book/"
"ch15-06-reference-cycles.html) za pomoc `Rc` lub `Arc`."

#: src/why-rust/compile-time.md:25
msgid ""
"In fact, some will consider infinitely populating a collection a memory leak "
"and Rust does not protect from those."
msgstr ""
"W rzeczywistoci niekt贸rzy uznaj zapenianie kolekcji w nieskoczono za "
"wyciek pamici, a Rust nie chroni przed nimi."

#: src/why-rust/compile-time.md:28
msgid ""
"For the purpose of this course, \"No memory leaks\" should be understood as "
"\"Pretty much no _accidental_ memory leaks\"."
msgstr ""
"Na potrzeby tego kursu nale偶y rozumie Brak wyciek贸w pamici. jako Prawie "
"nie ma _przypadkowych_ wyciek贸w pamici."

#: src/why-rust/runtime.md:3
msgid "No undefined behavior at runtime:"
msgstr "Brak niezdefiniowanego zachowania w czasie wykonywania:"

#: src/why-rust/runtime.md:5
msgid "Array access is bounds checked."
msgstr "Zakres dostpu do tablicy jest sprawdzany."

#: src/why-rust/runtime.md:6
msgid "Integer overflow is defined."
msgstr "Zdefiniowano przepenienie cakowitoliczbowe."

#: src/why-rust/runtime.md:12
msgid ""
"Integer overflow is defined via a compile-time flag. The options are either "
"a panic (a controlled crash of the program) or wrap-around semantics. By "
"default, you get panics in debug mode (`cargo build`) and wrap-around in "
"release mode (`cargo build --release`)."
msgstr ""
"Przepenienie liczb cakowitych jest definiowane za pomoc flagi czasu "
"kompilacji. Opcje to panika (kontrolowana awaria programu) lub zawijanie. "
"Domylnie to panika w trybie debugowania (`cargo build`) i zawijanie w "
"trybie produkcyjnym (`cargo build --release`)."

#: src/why-rust/runtime.md:17
msgid ""
"Bounds checking cannot be disabled with a compiler flag. It can also not be "
"disabled directly with the `unsafe` keyword. However, `unsafe` allows you to "
"call functions such as `slice::get_unchecked` which does not do bounds "
"checking."
msgstr ""
"Sprawdzania granic nie mo偶na wyczy za pomoc flagi kompilatora. Nie mo偶e "
"te偶 wyczy go bezporednio za pomoc sowa kluczowego `unsafe`. Jednak偶e, "
"`unsafe` pozwala na wywoanie funkcji takich jak `slice::get_unchecked`, "
"kt贸re nie sprawdzaj granic."

#: src/why-rust/modern.md:3
msgid "Rust is built with all the experience gained in the last 40 years."
msgstr ""
"Rust jest zbudowany z caym dowiadczeniem zdobytym w cigu ostatnich 40 lat."

#: src/why-rust/modern.md:5
msgid "Language Features"
msgstr "Funkcje jzyka"

#: src/why-rust/modern.md:7
msgid "Enums and pattern matching."
msgstr "Wyliczenia i dopasowywanie wzorc贸w."

#: src/why-rust/modern.md:8
msgid "Generics."
msgstr "Generyczne typy i funkcje."

#: src/why-rust/modern.md:9
msgid "No overhead FFI."
msgstr "Brak narzutu przy FFI."

#: src/why-rust/modern.md:10
msgid "Zero-cost abstractions."
msgstr "Abstrakcje o zerowych kosztach."

#: src/why-rust/modern.md:12
msgid "Tooling"
msgstr "Narzdzia"

#: src/why-rust/modern.md:14
msgid "Great compiler errors."
msgstr "wietne bdy kompilatora."

#: src/why-rust/modern.md:15
msgid "Built-in dependency manager."
msgstr "Wbudowany mened偶er zale偶noci."

#: src/why-rust/modern.md:16
msgid "Built-in support for testing."
msgstr "Wbudowana obsuga test贸w."

#: src/why-rust/modern.md:17
msgid "Excellent Language Server Protocol support."
msgstr "Doskonaa obsuga protokou serwera jzykowego."

#: src/why-rust/modern.md:23
msgid ""
"Zero-cost abstractions, similar to C++, means that you don't have to 'pay' "
"for higher-level programming constructs with memory or CPU. For example, "
"writing a loop using `for` should result in roughly the same low level "
"instructions as using the `.iter().fold()` construct."
msgstr ""
"Abstrakcje o zerowych kosztach, podobne do C++, oznaczaj, 偶e nie musisz "
"paci za konstrukcje programistyczne wy偶szego poziomu pamici lub "
"procesorem. Na przykad, pisanie ptli przy u偶yciu `for` powinno da w "
"przybli偶eniu te same instrukcje niskiego poziomu jak przy u偶yciu konstrukcji "
"`.iter().fold()`."

#: src/why-rust/modern.md:28
msgid ""
"It may be worth mentioning that Rust enums are 'Algebraic Data Types', also "
"known as 'sum types', which allow the type system to express things like "
"`Option<T>` and `Result<T, E>`."
msgstr ""
"Warto wspomnie, 偶e wyliczenia w Rust r贸wnie偶 s algebraicznymi typami "
"danych, kt贸re pozwalaj systemowi typ贸w wyra偶a takie rzeczy jak "
"`Option<T>` i `Result<T, E>`."

#: src/why-rust/modern.md:32
msgid ""
"Remind people to read the errors --- many developers have gotten used to "
"ignore lengthy compiler output. The Rust compiler is significantly more "
"talkative than other compilers. It will often provide you with _actionable_ "
"feedback, ready to copy-paste into your code."
msgstr ""
"Przypomnij ludziom, aby przeczytali bdy --- wielu programist贸w "
"przyzwyczaio si do ignorowanie dugich danych wyjciowych kompilatora. "
"Kompilator Rusta jest znacznie bardziej rozmowny ni偶 inne kompilatory. "
"Czsto da ci _u偶yteczne_ podpowiedzi, gotowe do skopiowania i wklejenia do "
"kodu."

#: src/why-rust/modern.md:37
msgid ""
"The Rust standard library is small compared to languages like Java, Python, "
"and Go. Rust does not come with several things you might consider standard "
"and essential:"
msgstr ""
"Standardowa biblioteka Rusta jest niewielka w por贸wnaniu z jzykami takimi "
"jak Java, Python, i Go. Rust nie zawiera kilku rzeczy, kt贸re mo偶na by uzna "
"za standardowe i niezbdne:"

#: src/why-rust/modern.md:41
msgid "a random number generator, but see [rand](https://docs.rs/rand/)."
msgstr "generator liczb losowych, ale patrz [rand](https://docs.rs/rand/)."

#: src/why-rust/modern.md:42
msgid "support for SSL or TLS, but see [rusttls](https://docs.rs/rustls/)."
msgstr ""
"wsparcie dla SSL lub TLS, ale zobacz [rusttls](https://docs.rs/rustls/)."

#: src/why-rust/modern.md:43
msgid "support for JSON, but see [serde_json](https://docs.rs/serde_json/)."
msgstr ""
"wsparcie dla JSON, ale zobacz [serde_json](https://docs.rs/serde_json/)."

#: src/why-rust/modern.md:45
msgid ""
"The reasoning behind this is that functionality in the standard library "
"cannot go away, so it has to be very stable. For the examples above, the "
"Rust community is still working on finding the best solution --- and perhaps "
"there isn't a single \"best solution\" for some of these things."
msgstr ""
"Powodem tego jest to, 偶e funkcjonalno w bibliotece standardowej nie mo偶e "
"odej, wic musi by bardzo stabilna. Dla powy偶szych przykad贸w spoeczno "
"Rusta wci偶 pracuje nad znalezieniem najlepszego rozwizania --- i by mo偶e "
"nie ma jednego najlepszego rozwizania dla niekt贸rych z tych rzeczy."

#: src/why-rust/modern.md:50
msgid ""
"Rust comes with a built-in package manager in the form of Cargo and this "
"makes it trivial to download and compile third-party crates. A consequence "
"of this is that the standard library can be smaller."
msgstr ""
"Rust ma wbudowanego mened偶era pakiet贸w w postaci Cargo i to sprawia, 偶e "
"pobieranie i kompilowanie zewntrznych pakiet贸w jest trywialne. Konsekwencj "
"tego jest to, 偶e standardowa biblioteka mo偶e by mniejsza."

#: src/why-rust/modern.md:54
msgid ""
"Discovering good third-party crates can be a problem. Sites like <https://"
"lib.rs/> help with this by letting you compare health metrics for crates to "
"find a good and trusted one."
msgstr ""
"Odkrywanie dobrych skrzynek mo偶e by problemem. Witryny takie jak <https://"
"lib.rs/> w tym pomagaj, umo偶liwiajc por贸wnanie wska藕nik贸w kondycji "
"skrzynki, aby znale藕 te dobre i zaufane."

#: src/why-rust/modern.md:58
msgid ""
"[rust-analyzer](https://rust-analyzer.github.io/) is a well supported LSP "
"implementation used in major IDEs and text editors."
msgstr ""
"[rust-analyzer](https://rust-analyzer.github.io/) to dobrze obsugiwana "
"implementacja LSP u偶ywana w g贸wnych IDE i edytorach tekstu."

#: src/basic-syntax.md:3
msgid "Much of the Rust syntax will be familiar to you from C, C++ or Java:"
msgstr "Wikszo skadni Rusta bdzie Ci znana z C, C++ lub Javy:"

#: src/basic-syntax.md:5
msgid "Blocks and scopes are delimited by curly braces."
msgstr "Bloki i zakresy s oddzielone nawiasami klamrowymi."

#: src/basic-syntax.md:6
msgid ""
"Line comments are started with `//`, block comments are delimited by `/* ... "
"*/`."
msgstr ""
"Komentarze wierszowe rozpoczynaj si od `//`, komentarze blokowe s "
"rozdzielane przez `/*... */`."

#: src/basic-syntax.md:8
msgid "Keywords like `if` and `while` work the same."
msgstr "Sowa kluczowe, takie jak `if` i `while`, dziaaj tak samo."

#: src/basic-syntax.md:9
msgid "Variable assignment is done with `=`, comparison is done with `==`."
msgstr ""
"Przypisanie zmiennej odbywa si za pomoc `=`, por贸wnanie za pomoc `==`."

#: src/basic-syntax/scalar-types.md:3 src/basic-syntax/compound-types.md:3
msgid "Types"
msgstr "Typy"

#: src/basic-syntax/scalar-types.md:3 src/basic-syntax/compound-types.md:3
msgid "Literals"
msgstr "Literay"

#: src/basic-syntax/scalar-types.md:5
msgid "Signed integers"
msgstr "Liczby cakowite ze znakiem"

#: src/basic-syntax/scalar-types.md:5
msgid "`i8`, `i16`, `i32`, `i64`, `i128`, `isize`"
msgstr "`i8`, `i16`, `i32`, `i64`, `i128`, `isize`"

#: src/basic-syntax/scalar-types.md:5
msgid "`-10`, `0`, `1_000`, `123i64`"
msgstr "`-10`, `0`, `1_000`, `123i64`"

#: src/basic-syntax/scalar-types.md:6
msgid "Unsigned integers"
msgstr "Liczby cakowite bez znaku"

#: src/basic-syntax/scalar-types.md:6
msgid "`u8`, `u16`, `u32`, `u64`, `u128`, `usize`"
msgstr "`u8`, `u16`, `u32`, `u64`, `u128`, `usize`"

#: src/basic-syntax/scalar-types.md:6
msgid "`0`, `123`, `10u16`"
msgstr "`0`, `123`, `10u16`"

#: src/basic-syntax/scalar-types.md:7
msgid "Floating point numbers"
msgstr "Liczby zmiennoprzecinkowe"

#: src/basic-syntax/scalar-types.md:7
msgid "`f32`, `f64`"
msgstr "`f32`, `f64`"

#: src/basic-syntax/scalar-types.md:7
msgid "`3.14`, `-10.0e20`, `2f32`"
msgstr "`3.14`, `-10.0e20`, `2f32`"

#: src/basic-syntax/scalar-types.md:8
msgid "Strings"
msgstr "acuchy znak贸w"

#: src/basic-syntax/scalar-types.md:8
msgid "`&str`"
msgstr "`&str`"

#: src/basic-syntax/scalar-types.md:8
msgid "`\"foo\"`, `r#\"\\\\\"#`"
msgstr "`\"foo\"`, `r#\"\\\\\"#`"

#: src/basic-syntax/scalar-types.md:9
msgid "Unicode scalar values"
msgstr "Wartoci skalarne Unicode"

#: src/basic-syntax/scalar-types.md:9
msgid "`char`"
msgstr "`char`"

#: src/basic-syntax/scalar-types.md:9
msgid "`'a'`, `'伪'`, `''`"
msgstr "`'a'`, `'伪'`, `''`"

#: src/basic-syntax/scalar-types.md:10
msgid "Byte strings"
msgstr "Cigi bajt贸w"

#: src/basic-syntax/scalar-types.md:10
msgid "`&[u8]`"
msgstr "`&[u8]`"

#: src/basic-syntax/scalar-types.md:10
msgid "`b\"abc\"`, `br#\" \" \"#`"
msgstr "`b\"abc\"`, `br#\" \"\"#`"

#: src/basic-syntax/scalar-types.md:11
msgid "Booleans"
msgstr "Logiczne"

#: src/basic-syntax/scalar-types.md:11
msgid "`bool`"
msgstr "`bool`"

#: src/basic-syntax/scalar-types.md:11
msgid "`true`, `false`"
msgstr "`true`, `false`"

#: src/basic-syntax/scalar-types.md:13
msgid "The types have widths as follows:"
msgstr "Typy maj nastpujce rozmiary:"

#: src/basic-syntax/scalar-types.md:15
msgid "`iN`, `uN`, and `fN` are _N_ bits wide,"
msgstr "`iN`, `uN` i `fN` maj wielko _N_ bit贸w,"

#: src/basic-syntax/scalar-types.md:16
msgid "`isize` and `usize` are the width of a pointer,"
msgstr "`isize` i `usize` maj wielko wska藕nika,"

#: src/basic-syntax/scalar-types.md:17
msgid "`char` is 32 bit wide,"
msgstr "`char` ma 32 bit贸w,"

#: src/basic-syntax/scalar-types.md:18
msgid "`bool` is 8 bit wide."
msgstr "`bool` ma 8 bit贸w."

#: src/basic-syntax/compound-types.md:5
msgid "Arrays"
msgstr "Tablice"

#: src/basic-syntax/compound-types.md:5
msgid "`[T; N]`"
msgstr "`[T; N]`"

#: src/basic-syntax/compound-types.md:5
msgid "`[20, 30, 40]`, `[0; 3]`"
msgstr "`[20, 30, 40]`, `[0; 3]`"

#: src/basic-syntax/compound-types.md:6
msgid "Tuples"
msgstr "Krotki"

#: src/basic-syntax/compound-types.md:6
msgid "`()`, `(T,)`, `(T1, T2)`, ..."
msgstr "`()`, `(T,)`, `(T1, T2)`, ..."

#: src/basic-syntax/compound-types.md:6
msgid "`()`, `('x',)`, `('x', 1.2)`, ..."
msgstr "`()`, `('x',)`, `('x', 1.2)`, ..."

#: src/basic-syntax/compound-types.md:8
msgid "Array assignment and access:"
msgstr "Przypisanie i dostp do tablicy:"

#: src/basic-syntax/compound-types.md:10
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut a: [i8; 10] = [42; 10];\n"
"    a[5] = 0;\n"
"    println!(\"a: {:?}\", a);\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let mut a: [i8; 10] = [42; 10];\n"
"    a[5] = 0;\n"
"    println!(\"a: {:?}\", a);\n"
"}\n"
"```"

#: src/basic-syntax/compound-types.md:18
msgid "Tuple assignment and access:"
msgstr "Przypisanie i dostp do krotki:"

#: src/basic-syntax/compound-types.md:20
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let t: (i8, bool) = (7, true);\n"
"    println!(\"1st index: {}\", t.0);\n"
"    println!(\"2nd index: {}\", t.1);\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let t: (i8, bool) = (7, true);\n"
"    println!(\"Pierwszy element: {}\", t.0);\n"
"    println!(\"Drugi element: {}\", t.1);\n"
"}\n"
"```"

#: src/basic-syntax/compound-types.md:32
msgid "Arrays:"
msgstr "Tablice:"

#: src/basic-syntax/compound-types.md:34
msgid ""
"Arrays have elements of the same type, `T`, and length, `N`, which is a "
"compile-time constant. Note that the length of the array is _part of its "
"type_, which means that `[u8; 3]` and `[u8; 4]` are considered two different "
"types."
msgstr ""
"Tablice maj elementy tego samego typu, `T`, i dugo, `N`, kt贸ra jest "
"sta czasu kompilacji. Zauwa偶, 偶e dugo tablicy to _cz jej typu_, to "
"znaczy, 偶e `[u8; 3]` i `[u8; 4]` to dwa r贸偶ne typy."

#: src/basic-syntax/compound-types.md:38
msgid "We can use literals to assign values to arrays."
msgstr "Mo偶emy u偶y litera贸w do przypisania wartoci do tablic."

#: src/basic-syntax/compound-types.md:40
msgid ""
"In the main function, the print statement asks for the debug implementation "
"with the `?` format parameter: `{}` gives the default output, `{:?}` gives "
"the debug output. We could also have used `{a}` and `{a:?}` without "
"specifying the value after the format string."
msgstr ""
"W funkcji main instrukcja print pyta o implementacj do debugowania za "
"pomoc parametru formatowania `?`: `{}` daje domylne wyjcie, `{:?}` daje "
"wyjcie do debugowania. Moglimy r贸wnie偶 u偶y `{a}` i `{a:?}` bez okrelania "
"wartoci po acuchu formatujcym."

#: src/basic-syntax/compound-types.md:45
msgid ""
"Adding `#`, eg `{a:#?}`, invokes a \"pretty printing\" format, which can be "
"easier to read."
msgstr ""
"Dodanie `#`, np. `{a:#?}`, wywouje format \"adnego druku\", kt贸ry mo偶e by "
"atwiejszy do odczytania."

#: src/basic-syntax/compound-types.md:47
msgid "Tuples:"
msgstr "Krotki:"

#: src/basic-syntax/compound-types.md:49
msgid "Like arrays, tuples have a fixed length."
msgstr "Podobnie jak tablice, krotki maj sta dugo."

#: src/basic-syntax/compound-types.md:51
msgid "Tuples group together values of different types into a compound type."
msgstr "Krotki grupuj wartoci r贸偶nych typ贸w w typ zo偶ony."

#: src/basic-syntax/compound-types.md:53
msgid ""
"Fields of a tuple can be accessed by the period and the index of the value, "
"e.g. `t.0`, `t.1`."
msgstr ""
"Dostp do p贸l krotki mo偶na uzyska po kropce i indeksie wartoci, np. `t.0`, "
"`t.1`."

#: src/basic-syntax/compound-types.md:55
msgid ""
"The empty tuple `()` is also known as the \"unit type\". It is both a type, "
"and the only valid value of that type - that is to say both the type and its "
"value are expressed as `()`. It is used to indicate, for example, that a "
"function or expression has no return value, as we'll see in a future slide. "
msgstr ""
"Pusta krotka `()` jest r贸wnie偶 znana jako \"typ jednostkowy\". Jest to "
"zar贸wno typ, jak i jedyna poprawna warto tego typu  to znaczy zar贸wno "
"typ, jak i jego warto s wyra偶one jako `()`. Su偶y do wskazania, na "
"przykad, 偶e funkcja lub wyra偶enie nie zwraca 偶adnej wartoci, co zobaczymy "
"na kolejnym slajdzie."

#: src/basic-syntax/compound-types.md:59
msgid ""
"You can think of it as `void` that can be familiar to you from other  "
"programming languages."
msgstr ""
"Mo偶esz myle o tym jako o pustce (ang. `void`), kt贸ra mo偶e by ci znana z "
"innych jzyk贸w programowania."

#: src/basic-syntax/references.md:3
msgid "Like C++, Rust has references:"
msgstr "Podobnie jak C++, Rust ma referencje:"

#: src/basic-syntax/references.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x: i32 = 10;\n"
"    let ref_x: &mut i32 = &mut x;\n"
"    *ref_x = 20;\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x: i32 = 10;\n"
"    let ref_x: &mut i32 = &mut x;\n"
"    *ref_x = 20;\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"

#: src/basic-syntax/references.md:14
msgid "Some notes:"
msgstr "Niekt贸re uwagi:"

#: src/basic-syntax/references.md:16
msgid ""
"We must dereference `ref_x` when assigning to it, similar to C and C++ "
"pointers."
msgstr ""
"Podczas przypisywania musimy wyuska referencj `ref_x`, podobnie jak w "
"przypadku wska藕nik贸w C i C++."

#: src/basic-syntax/references.md:17
msgid ""
"Rust will auto-dereference in some cases, in particular when invoking "
"methods (try `ref_x.count_ones()`)."
msgstr ""
"W niekt贸rych przypadkach Rust dokona automatycznej dereferencji, w "
"szczeg贸lnoci podczas wywoywania metod (spr贸buj `ref_x.count_ones()`)."

#: src/basic-syntax/references.md:19
msgid ""
"References that are declared as `mut` can be bound to different values over "
"their lifetime."
msgstr ""
"Referencje zadeklarowane jako `mut` mog by powizane z r贸偶nymi wartociami "
"w czasie ich istnienia."

#: src/basic-syntax/references.md:24
msgid ""
"Be sure to note the difference between `let mut ref_x: &i32` and `let ref_x: "
"&mut i32`. The first one represents a mutable reference which can be bound "
"to different values, while the second represents a reference to a mutable "
"value."
msgstr ""
"Pamitaj o r贸偶nicy midzy `let mut ref_x: &i32` i `let ref_x: &mut i32`. "
"Pierwsza reprezentuje zmienn referencj, z kt贸r mo偶na powiza r贸偶ne "
"wartoci, podczas gdy druga reprezentuje odwoanie do zmiennej wartoci."

#: src/basic-syntax/references-dangling.md:3
msgid "Rust will statically forbid dangling references:"
msgstr "Rust bdzie statycznie zabrania wiszcych referencji:"

#: src/basic-syntax/references-dangling.md:5
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let ref_x: &i32;\n"
"    {\n"
"        let x: i32 = 10;\n"
"        ref_x = &x;\n"
"    }\n"
"    println!(\"ref_x: {ref_x}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let ref_x: &i32;\n"
"    {\n"
"        let x: i32 = 10;\n"
"        ref_x = &x;\n"
"    }\n"
"    println!(\"ref_x: {ref_x}\");\n"
"}\n"
"```"

#: src/basic-syntax/references-dangling.md:16
msgid "A reference is said to \"borrow\" the value it refers to."
msgstr "M贸wi si, 偶e referencja po偶ycza warto, do kt贸rej si odnosi."

#: src/basic-syntax/references-dangling.md:17
msgid ""
"Rust is tracking the lifetimes of all references to ensure they live long "
"enough."
msgstr ""
"Rust ledzi czas 偶ycia wszystkich referencji, aby zapewni, 偶e maj "
"wystarczajco dugi czas 偶ycia."

#: src/basic-syntax/references-dangling.md:19
msgid "We will talk more about borrowing when we get to ownership."
msgstr "Porozmawiamy wicej o po偶yczaniu, kiedy przejdziemy do wasnoci."

#: src/basic-syntax/slices.md:3
msgid "A slice gives you a view into a larger collection:"
msgstr "Wycinek daje wgld w wiksz kolekcj:"

#: src/basic-syntax/slices.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a: [i32; 6] = [10, 20, 30, 40, 50, 60];\n"
"    println!(\"a: {a:?}\");\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let a: [i32; 6] = [10, 20, 30, 40, 50, 60];\n"
"    println!(\"a: {a:?}\");\n"
"```"

#: src/basic-syntax/slices.md:10
msgid ""
"```\n"
"let s: &[i32] = &a[2..4];\n"
"println!(\"s: {s:?}\");\n"
"```"
msgstr ""
"```\n"
"let s: &[i32] = &a[2..4];\n"
"println!(\"s: {s:?}\");\n"
"```"

#: src/basic-syntax/slices.md:12 src/basic-syntax/string-slices.md:17
#: src/basic-syntax/methods.md:20
#: src/exercises/day-1/implicit-conversions.md:16
#: src/exercises/day-1/for-loops.md:35 src/exercises/day-1/for-loops.md:77
#: src/basic-syntax/type-inference.md:21 src/basic-syntax/type-inference.md:43
#: src/basic-syntax/scopes-shadowing.md:20
#: src/ownership/shared-unique-borrows.md:20 src/std/rc.md:15
#: src/exercises/day-1/book-library.md:74
#: src/exercises/day-1/book-library.md:96
#: src/exercises/day-1/iterators-and-ownership.md:31
#: src/exercises/day-1/iterators-and-ownership.md:43
#: src/exercises/day-1/iterators-and-ownership.md:80
#: src/exercises/day-1/iterators-and-ownership.md:59
#: src/exercises/day-1/iterators-and-ownership.md:100 src/structs.md:26
#: src/enums/variant-payloads.md:30 src/enums/sizes.md:84
#: src/enums/sizes.md:133 src/methods/example.md:30 src/pattern-matching.md:18
#: src/exercises/day-2/health-statistics.md:47
#: src/exercises/day-2/points-polygons.md:109
#: src/control-flow/while-let-expressions.md:14
#: src/control-flow/for-expressions.md:17 src/std/option-result.md:13
#: src/std/string.md:19 src/std/vec.md:26 src/std/hashmap.md:33
#: src/std/rc.md:63 src/modules/visibility.md:30
#: src/exercises/day-2/strings-iterators.md:29
#: src/exercises/day-2/solutions-afternoon.md:149
#: src/exercises/day-2/strings-iterators.md:51 src/traits/iterator.md:20
#: src/traits/read-write.md:20 src/traits/operators.md:15
#: src/traits/default.md:34 src/generics/methods.md:15
#: src/generics/trait-bounds.md:30 src/generics/closures.md:20
#: src/exercises/day-3/simple-gui.md:35
#: src/exercises/day-3/solutions-morning.md:36
#: src/exercises/day-3/simple-gui.md:79
#: src/exercises/day-3/solutions-morning.md:80
#: src/exercises/day-3/simple-gui.md:90 src/exercises/day-3/simple-gui.md:100
#: src/exercises/day-3/simple-gui.md:110 src/error-handling/try-operator.md:39
#: src/testing/test-modules.md:23 src/unsafe/raw-pointers.md:21
#: src/unsafe/mutable-static-variables.md:27
#: src/unsafe/calling-unsafe-functions.md:23
#: src/unsafe/writing-unsafe-functions.md:28
#: src/exercises/day-3/safe-ffi-wrapper.md:54
#: src/exercises/day-3/solutions-afternoon.md:48 src/concurrency/threads.md:21
#: src/concurrency/scoped-threads.md:14 src/concurrency/scoped-threads.md:30
#: src/concurrency/channels.md:22 src/concurrency/channels/unbounded.md:26
#: src/concurrency/channels/bounded.md:26
#: src/concurrency/shared_state/arc.md:22
#: src/concurrency/shared_state/mutex.md:19
#: src/concurrency/shared_state/example.md:18
#: src/concurrency/shared_state/example.md:49
#: src/exercises/day-4/dining-philosophers.md:44
#: src/exercises/day-4/dining-philosophers.md:57
#: src/exercises/day-4/link-checker.md:78 src/android/aidl/client.md:34
#: src/android/interoperability/java.md:59
#: src/exercises/day-1/solutions-morning.md:76
#: src/exercises/day-1/solutions-afternoon.md:103
#: src/exercises/day-1/solutions-afternoon.md:139
#: src/exercises/day-1/solutions-afternoon.md:148
#: src/exercises/day-1/solutions-afternoon.md:176
#: src/exercises/day-2/solutions-morning.md:44
#: src/exercises/day-2/solutions-morning.md:55
#: src/exercises/day-2/solutions-morning.md:66
#: src/exercises/day-2/solutions-morning.md:107
#: src/exercises/day-2/solutions-morning.md:130
#: src/exercises/day-2/solutions-afternoon.md:47
#: src/exercises/day-2/solutions-afternoon.md:137
#: src/exercises/day-3/solutions-morning.md:115
#: src/exercises/day-3/solutions-morning.md:137
#: src/exercises/day-3/solutions-morning.md:155
#: src/exercises/day-4/solutions-morning.md:58
#: src/exercises/day-4/solutions-morning.md:102
msgid "}"
msgstr "}"

#: src/basic-syntax/slices.md:13 src/basic-syntax/string-slices.md:18
#: src/basic-syntax/functions.md:31 src/basic-syntax/methods.md:28
#: src/basic-syntax/functions-interlude.md:23
#: src/exercises/day-1/implicit-conversions.md:17
#: src/exercises/day-1/for-loops.md:36 src/exercises/day-1/for-loops.md:78
#: src/basic-syntax/type-inference.md:22 src/basic-syntax/type-inference.md:44
#: src/basic-syntax/static-and-const.md:25
#: src/basic-syntax/static-and-const.md:39
#: src/basic-syntax/scopes-shadowing.md:21 src/ownership.md:16
#: src/ownership/moves-function-calls.md:16 src/ownership/copy-clone.md:28
#: src/ownership/borrowing.md:20 src/ownership/shared-unique-borrows.md:21
#: src/std/rc.md:16 src/ownership/lifetimes-function-calls.md:19
#: src/exercises/day-1/book-library.md:97
#: src/exercises/day-1/iterators-and-ownership.md:32
#: src/exercises/day-1/iterators-and-ownership.md:44
#: src/exercises/day-1/iterators-and-ownership.md:81
#: src/exercises/day-1/iterators-and-ownership.md:60
#: src/exercises/day-1/iterators-and-ownership.md:101 src/structs.md:27
#: src/structs/tuple-structs.md:12 src/structs/tuple-structs.md:33
#: src/traits/default.md:36 src/generics/trait-objects.md:86
#: src/structs/field-shorthand.md:23 src/enums.md:29
#: src/enums/variant-payloads.md:31 src/enums/sizes.md:35 src/enums/sizes.md:85
#: src/enums/sizes.md:134 src/methods.md:26 src/methods/example.md:42
#: src/pattern-matching.md:19 src/pattern-matching/destructuring-enums.md:27
#: src/exercises/day-2/points-polygons.md:113 src/exercises/day-2/luhn.md:70
#: src/control-flow/blocks.md:36 src/control-flow/while-let-expressions.md:15
#: src/control-flow/for-expressions.md:18 src/std/option-result.md:14
#: src/std/string.md:20 src/std/vec.md:27 src/std/hashmap.md:34
#: src/std/box-recursive.md:16 src/std/box-niche.md:14 src/std/rc.md:64
#: src/modules.md:24 src/modules/visibility.md:35
#: src/exercises/day-2/strings-iterators.md:52 src/traits.md:37
#: src/traits/deriving-traits.md:19 src/traits/default-methods.md:28
#: src/traits/iterator.md:28 src/traits/read-write.md:21
#: src/traits/read-write.md:40 src/traits/operators.md:22 src/traits/drop.md:30
#: src/generics/data-types.md:17 src/generics/methods.md:21
#: src/generics/trait-bounds.md:31 src/generics/impl-trait.md:17
#: src/generics/closures.md:21 src/generics/monomorphization.md:29
#: src/generics/trait-objects.md:16 src/generics/trait-objects.md:37
#: src/exercises/day-3/simple-gui.md:121 src/exercises/day-3/simple-gui.md:133
#: src/error-handling/panic-unwind.md:17 src/error-handling/result.md:23
#: src/error-handling/try-operator.md:46
#: src/error-handling/converting-error-types-example.md:46
#: src/error-handling/deriving-error-enums.md:35
#: src/error-handling/dynamic-errors.md:32
#: src/error-handling/error-contexts.md:31 src/testing/test-modules.md:24
#: src/unsafe/raw-pointers.md:22 src/unsafe/mutable-static-variables.md:11
#: src/unsafe/mutable-static-variables.md:28 src/unsafe/unions.md:17
#: src/unsafe/calling-unsafe-functions.md:28
#: src/unsafe/writing-unsafe-functions.md:29 src/unsafe/extern-functions.md:17
#: src/unsafe/unsafe-traits.md:26 src/exercises/day-3/safe-ffi-wrapper.md:93
#: src/concurrency/threads.md:22 src/concurrency/scoped-threads.md:15
#: src/concurrency/scoped-threads.md:31 src/concurrency/channels.md:23
#: src/concurrency/channels/unbounded.md:27
#: src/concurrency/channels/bounded.md:27
#: src/concurrency/shared_state/arc.md:23
#: src/concurrency/shared_state/mutex.md:20
#: src/concurrency/shared_state/example.md:19
#: src/exercises/day-4/dining-philosophers.md:58
#: src/exercises/day-4/link-checker.md:88 src/android/build-rules/binary.md:25
#: src/android/build-rules/library.md:46 src/android/build-rules/library.md:57
#: src/android/aidl/interface.md:15 src/android/aidl/implementation.md:24
#: src/android/aidl/server.md:26 src/android/aidl/client.md:35
#: src/android/aidl/changing.md:14 src/android/logging.md:40
#: src/android/interoperability/with-c.md:18
#: src/android/interoperability/with-c/bindgen.md:17
#: src/android/interoperability/with-c/bindgen.md:31
#: src/android/interoperability/with-c/bindgen.md:96
#: src/android/interoperability/with-c/rust.md:35
#: src/android/interoperability/with-c/rust.md:60
#: src/android/interoperability/java.md:60
#: src/exercises/day-1/solutions-afternoon.md:177
#: src/exercises/day-2/solutions-morning.md:234
#: src/exercises/day-2/solutions-afternoon.md:175
#: src/exercises/day-3/solutions-morning.md:168
#: src/exercises/day-3/solutions-afternoon.md:118
#: src/exercises/day-4/solutions-morning.md:103
msgid ""
"```\n"
"```"
msgstr ""
"```\n"
"```"

#: src/basic-syntax/slices.md:15
msgid "Slices borrow data from the sliced type."
msgstr "Wycinki po偶yczaj dane od citego typu."

#: src/basic-syntax/slices.md:16
msgid "Question: What happens if you modify `a[3]`?"
msgstr "Pytanie: Co si stanie, jeli zmodyfikujesz `a[3]`?"

#: src/basic-syntax/slices.md:20
msgid ""
"We create a slice by borrowing `a` and specifying the starting and ending "
"indexes in brackets."
msgstr ""
"Tworzymy wycinek, po偶yczajc `a` i okrelajc indeksy pocztkowe i kocowe w "
"nawiasach."

#: src/basic-syntax/slices.md:22
msgid ""
"If the slice starts at index 0, Rusts range syntax allows us to drop the "
"starting index, meaning that `&a[0..a.len()]` and `&a[..a.len()]` are "
"identical."
msgstr ""
"Jeli wycinek zaczyna si od indeksu 0, skadnia zakresu Rusta pozwala nam "
"pomin indeks pocztkowy, co oznacza, 偶e `&a[0..a.len()]` i `&a[..a.len()]` "
"s identyczne ."

#: src/basic-syntax/slices.md:24
msgid ""
"The same is true for the last index, so `&a[2..a.len()]` and `&a[2..]` are "
"identical."
msgstr ""
"To samo dotyczy ostatniego indeksu, wic `&a[2..a.len()]` i `&a[2..]` s "
"identyczne."

#: src/basic-syntax/slices.md:26
msgid ""
"To easily create a slice of the full array, we can therefore use `&a[..]`."
msgstr "Aby atwo utworzy wycinek penej tablicy, mo偶emy zatem u偶y `&a[..]`."

#: src/basic-syntax/slices.md:28
msgid ""
"`s` is a reference to a slice of `i32`s. Notice that the type of `s` "
"(`&[i32]`) no longer mentions the array length. This allows us to perform "
"computation on slices of different sizes."
msgstr ""
"`s` jest referencj do wycinka element贸w `i32`. Zauwa偶, 偶e typ `s` "
"(`&[i32]`) nie wspomina ju偶 o dugoci tablicy. To pozwala nam wykonywa "
"obliczenia na wycinkach o r贸偶nych rozmiarach."

#: src/basic-syntax/slices.md:30
msgid ""
"Slices always borrow from another object. In this example, `a` has to remain "
"'alive' (in scope) for at least as long as our slice. "
msgstr ""
"Wycinki zawsze po偶yczaj od innego obiektu. W tym przykadzie `a` musi "
"pozosta '偶ywe' (w zakresie) przynajmniej tak dugo, jak nasz wycinek."

#: src/basic-syntax/slices.md:32
msgid ""
"The question about modifying `a[3]` can spark an interesting discussion, but "
"the answer is that for memory safety reasons you cannot do it through `a` "
"after you created a slice, but you can read the data from both `a` and `s` "
"safely.  More details will be explained in the borrow checker section."
msgstr ""
"Pytanie o modyfikacj `a[3]` mo偶e wywoa interesujc dyskusj, ale "
"odpowied藕 jest taka, 偶e ze wzgld贸w bezpieczestwa pamici nie mo偶esz tego "
"zrobi przez `a` po utworzeniu wycinka, ale mo偶esz bezpiecznie odczyta dane "
"zar贸wno z `a` jak i `s`. Wicej szczeg贸贸w zostanie wyjanionych w sekcji o "
"nadzorcy po偶yczania."

#: src/basic-syntax/string-slices.md:1
msgid "`String` vs `str`"
msgstr "`String` i `str`"

#: src/basic-syntax/string-slices.md:3
msgid "We can now understand the two string types in Rust:"
msgstr "Mo偶emy teraz zrozumie dwa typy acuch贸w w Rust:"

#: src/basic-syntax/string-slices.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: &str = \"World\";\n"
"    println!(\"s1: {s1}\");\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: &str = \"wiecie\";\n"
"    println!(\"s1: {s1}\");\n"
"```"

#: src/basic-syntax/string-slices.md:10
msgid ""
"```\n"
"let mut s2: String = String::from(\"Hello \");\n"
"println!(\"s2: {s2}\");\n"
"s2.push_str(s1);\n"
"println!(\"s2: {s2}\");\n"
"\n"
"let s3: &str = &s2[6..];\n"
"println!(\"s3: {s3}\");\n"
"```"
msgstr ""
"```\n"
"let mut s2: String = String::from(\"Witaj \");\n"
"println!(\"s2: {s2}\");\n"
"s2.push_str(s1);\n"
"println!(\"s2: {s2}\");\n"
"\n"
"let s3: &str = &s2[6..];\n"
"println!(\"s3: {s3}\");\n"
"```"

#: src/basic-syntax/string-slices.md:20
msgid "Rust terminology:"
msgstr "Terminologia Rusta:"

#: src/basic-syntax/string-slices.md:22
msgid "`&str` an immutable reference to a string slice."
msgstr "`&str` to niezmienna referencja do wycinka acucha."

#: src/basic-syntax/string-slices.md:23
msgid "`String` a mutable string buffer."
msgstr "`String` to zmienny bufor acucha znak贸w."

#: src/basic-syntax/string-slices.md:27
msgid ""
"`&str` introduces a string slice, which is an immutable reference to UTF-8 "
"encoded string data  stored in a block of memory. String literals "
"(`Hello`), are stored in the programs binary."
msgstr ""
"`&str` wprowadza fragment acucha, kt贸ry jest niezmiennym odniesieniem do "
"danych acuchowych zakodowanych w UTF-8 przechowywanych w bloku pamici. "
"Literay acuchowe (`\"Witaj\"`) s przechowywane w pliku binarnym programu."

#: src/basic-syntax/string-slices.md:30
msgid ""
"Rusts `String` type is a wrapper around a vector of bytes. As with a "
"`Vec<T>`, it is owned."
msgstr ""
"Typ `String` to opakowanie dla wektora bajt贸w. Tak jak `Vec<T>`, ma dane na "
"wasno."

#: src/basic-syntax/string-slices.md:32
msgid ""
"As with many other types `String::from()` creates a string from a string "
"literal; `String::new()`  creates a new empty string, to which string data "
"can be added using the `push()` and `push_str()` methods."
msgstr ""
"Tak jak z wieloma innymi typami `String::from()` tworzy acuch z literau "
"znak贸w; `String::new()`  tworzy pusty acuch, do kt贸rego mo偶na doda dane "
"za pomoc metod `push()` i `push_str()`."

#: src/basic-syntax/string-slices.md:35
msgid ""
"The `format!()` macro is a convenient way to generate an owned string from "
"dynamic values. It  accepts the same format specification as `println!()`."
msgstr ""
"Makro `format!()` jest wygodnym sposobem generowania posiadanego acucha z "
"wartoci dynamicznych. Akceptuje t sam specyfikacj formatu co `println!"
"()`."

#: src/basic-syntax/string-slices.md:38
msgid ""
"You can borrow `&str` slices from `String` via `&` and optionally range "
"selection."
msgstr ""
"Mo偶esz po偶yczy wycinki `&str` ze `String` za pomoc `&` i opcjonalnego "
"wyboru zakresu."

#: src/basic-syntax/string-slices.md:40
msgid ""
"For C++ programmers: think of `&str` as `const char*` from C++, but the one "
"that always points  to a valid string in memory. Rust `String` is a rough "
"equivalent of `std::string` from C++  (main difference: it can only contain "
"UTF-8 encoded bytes and will never use a small-string optimization)."
msgstr ""
"Dla programist贸w C++: myl o `&str` jako o `const char*` z C++, ale tym, "
"kt贸re zawsze wskazuje do prawidowego cigu w pamici. Rust `String` jest "
"przybli偶onym odpowiednikiem `std::string` z C++ (g贸wna r贸偶nica: mo偶e "
"zawiera tylko bajty zakodowane w UTF-8 i nigdy nie u偶yje optymalizacji "
"maych cig贸w)."

#: src/basic-syntax/functions.md:3
msgid ""
"A Rust version of the famous [FizzBuzz](https://en.wikipedia.org/wiki/"
"Fizz_buzz) interview question:"
msgstr ""
"Rustowa wersja synnego pytania z rozm贸w o prac [FizzBuzz](https://en."
"wikipedia.org/wiki/Fizz_buzz):"

#: src/basic-syntax/functions.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    fizzbuzz_to(20);   // Defined below, no forward declaration needed\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    fizzbuzz_to(20);   // Zdefiniowany poni偶ej, nie ma potrzeby na "
"deklarowanie z g贸ry\n"
"}\n"
"```"

#: src/basic-syntax/functions.md:10
msgid ""
"fn is_divisible_by(lhs: u32, rhs: u32) -> bool { if rhs == 0 { return "
"false;  // Corner case, early return } lhs % rhs == 0     // The last "
"expression in a block is the return value }"
msgstr ""
"fn is_divisible_by(lhs: u32, rhs: u32) -> bool { if rhs == 0 { return "
"false;  // Szczeg贸lny przypadek, wczesne wyjcie } lhs % rhs == 0     // "
"Ostatnie wyra偶enie w bloku to zwracana warto }"

#: src/basic-syntax/functions.md:17
msgid ""
"fn fizzbuzz(n: u32) -> () {  // No return value means returning the unit "
"type `()` match (is_divisible_by(n, 3), is_divisible_by(n, 5)) { (true,  "
"true)  => println!(\"fizzbuzz\"), (true,  false) => println!(\"fizz\"), "
"(false, true)  => println!(\"buzz\"), (false, false) => println!"
"(\"{n}\"), } }"
msgstr ""
"fn fizzbuzz(n: u32) -> () { // Brak wartoci zwracanej oznacza zwr贸cenie "
"typu jednostkowego `()` match (is_divisible_by(n, 3), is_divisible_by(n, 5)) "
"{ (true, true) => println!(\"fizzbuzz\"), (true, false) => println!"
"(\"fizz\"), (false, true) => println!(\"buzz\"), (false, false) => println!"
"(\"{n}\"), } }"

#: src/basic-syntax/functions.md:26
msgid ""
"fn fizzbuzz_to(n: u32) {  // `-> ()` is normally omitted for i in 1..=n "
"{ fizzbuzz(i); } }"
msgstr ""
"fn fizzbuzz_to(n: u32) {  // `-> ()` jest zwykle pomijany for i in 1..=n "
"{ fizzbuzz(i); } }"

#: src/basic-syntax/functions.md:35
msgid ""
"We refer in `main` to a function written below. Neither forward declarations "
"nor headers are necessary. "
msgstr ""
"W `main` odnosimy si do funkcji napisanej poni偶ej. Nie ma potrzeby na "
"deklaracje z gory lub na nag贸wki. "

#: src/basic-syntax/functions.md:36
msgid ""
"Declaration parameters are followed by a type (the reverse of some "
"programming languages), then a return type."
msgstr ""
"Deklarowane parametry s poprzedzaj typ (na odwr贸t w por贸wnaniu do "
"niekt贸rych jzyk贸w programowania), potem zwracany typ."

#: src/basic-syntax/functions.md:37
msgid ""
"The last expression in a function body (or any block) becomes the return "
"value. Simply omit the `;` at the end of the expression."
msgstr ""
"Ostatnie wyra偶enie w ciele funkcji (lub bloku) staje si zwracan wartoci. "
"Wystarczy pomin `;` na kocu wyra偶enia."

#: src/basic-syntax/functions.md:38
msgid ""
"Some functions have no return value, and return the 'unit type', `()`. The "
"compiler will infer this if the `-> ()` return type is omitted."
msgstr ""
"Niekt贸re funkcje nie zwracaj wartoci, ich zwracany typ to 'typ "
"jednostkowy', `()`. Kompilator to wywnioskuje je偶eli `-> ()` jest pominite."

#: src/basic-syntax/functions.md:39
msgid ""
"The range expression in the `for` loop in `fizzbuzz_to()` contains `=n`, "
"which causes it to include the upper bound."
msgstr ""
"Wyra偶enie zakresu w ptli `for` w `fizzbuzz_to()` zawiera `=n`, powoduje to "
"zawarcie g贸rnego zakresu."

#: src/basic-syntax/functions.md:40
msgid ""
"The `match` expression in `fizzbuzz()` is doing a lot of work. It is "
"expanded below to show what is happening."
msgstr ""
"Wyra偶enie `match` w `fizzbuzz()` wykonuje wiele pracy. Jest rozwinite "
"poni偶ej 偶eby pokaza co si dzieje."

#: src/basic-syntax/functions.md:42
msgid "(Type annotations added for clarity, but they can be elided.)"
msgstr "(Adnotacje typ贸w dodane dla przejrzystoci, ale mo偶na je pomin.)"

#: src/basic-syntax/functions.md:44
msgid ""
"```rust,ignore\n"
"let by_3: bool = is_divisible_by(n, 3);\n"
"let by_5: bool = is_divisible_by(n, 5);\n"
"let by_35: (bool, bool) = (by_3, by_5);\n"
"match by_35 {\n"
"  // ...\n"
"```"
msgstr ""
"```rust,ignore\n"
"let by_3: bool = is_divisible_by(n, 3);\n"
"let by_5: bool = is_divisible_by(n, 5);\n"
"let by_35: (bool, bool) = (by_3, by_5);\n"
"match by_35 {\n"
"  // ...\n"
"```"

#: src/basic-syntax/methods.md:3
msgid ""
"Rust has methods, they are simply functions that are associated with a "
"particular type. The first argument of a method is an instance of the type "
"it is associated with:"
msgstr ""
"Rust ma metody, s to po prostu funkcje powizane z okrelonym typem. "
"Pierwszy argument metody jest instancj typu, z kt贸rym jest powizana:"

#: src/basic-syntax/methods.md:6
msgid ""
"```rust,editable\n"
"struct Rectangle {\n"
"    width: u32,\n"
"    height: u32,\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"struct Rectangle {\n"
"    width: u32,\n"
"    height: u32,\n"
"}\n"
"```"

#: src/basic-syntax/methods.md:12
msgid "impl Rectangle { fn area(&self) -> u32 { self.width * self.height }"
msgstr "impl Rectangle { fn area(&self) -> u32 { self.width * self.height }"

#: src/basic-syntax/methods.md:17
msgid ""
"```\n"
"fn inc_width(&mut self, delta: u32) {\n"
"    self.width += delta;\n"
"}\n"
"```"
msgstr ""
"```\n"
"fn inc_width(&mut self, delta: u32) {\n"
"    self.width += delta;\n"
"}\n"
"```"

#: src/basic-syntax/methods.md:22
msgid ""
"fn main() { let mut rect = Rectangle { width: 10, height: 5 }; println!"
"(\"old area: {}\", rect.area()); rect.inc_width(5); println!(\"new area: "
"{}\", rect.area()); }"
msgstr ""
"fn main() { let mut rect = Rectangle { width: 10, height: 5 }; println!"
"(\"stare pole: {}\", rect.area()); rect.inc_width(5); println!(\"nowe pole: "
"{}\", rect.area()); }"

#: src/basic-syntax/methods.md:30
msgid ""
"We will look much more at methods in today's exercise and in tomorrow's "
"class."
msgstr ""
"W dzisiejszym wiczeniu i na jutrzejszych zajciach przyjrzymy si metodom "
"znacznie dokadniej."

#: src/basic-syntax/functions-interlude.md:1
msgid "Function Overloading"
msgstr "Przeci偶anie funkcji"

#: src/basic-syntax/functions-interlude.md:3
msgid "Overloading is not supported:"
msgstr "Przeci偶anie nie jest obsugiwane:"

#: src/basic-syntax/functions-interlude.md:5
msgid "Each function has a single implementation:"
msgstr "Ka偶da funkcja ma jedn implementacj:"

#: src/basic-syntax/functions-interlude.md:6
msgid "Always takes a fixed number of parameters."
msgstr "Zawsze przyjmuje sta liczb parametr贸w."

#: src/basic-syntax/functions-interlude.md:7
msgid "Always takes a single set of parameter types."
msgstr "Zawsze przyjmuje jeden zestaw typ贸w parametr贸w."

#: src/basic-syntax/functions-interlude.md:8
msgid "Default values are not supported:"
msgstr "Wartoci domylne nie s obsugiwane:"

#: src/basic-syntax/functions-interlude.md:9
msgid "All call sites have the same number of arguments."
msgstr "Wszystkie wywoania maj tak sam liczb argument贸w."

#: src/basic-syntax/functions-interlude.md:10
msgid "Macros are sometimes used as an alternative."
msgstr "Makra s czasami u偶ywane jako alternatywa."

#: src/basic-syntax/functions-interlude.md:12
msgid "However, function parameters can be generic:"
msgstr "Jednak parametry funkcji mog by generyczne:"

#: src/basic-syntax/functions-interlude.md:14
msgid ""
"```rust,editable\n"
"fn pick_one<T>(a: T, b: T) -> T {\n"
"    if std::process::id() % 2 == 0 { a } else { b }\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn pick_one<T>(a: T, b: T) -> T {\n"
"    if std::process::id() % 2 == 0 { a } else { b }\n"
"}\n"
"```"

#: src/basic-syntax/functions-interlude.md:19
msgid ""
"fn main() { println!(\"coin toss: {}\", pick_one(\"heads\", \"tails\")); "
"println!(\"cash prize: {}\", pick_one(500, 1000)); }"
msgstr ""
"fn main() { println!(\"rzut monet: {}\", pick_one(\"orze\", \"reszka\")); "
"println!(\"nagroda: {}\", pick_one(500, 1000)); }"

#: src/basic-syntax/functions-interlude.md:27
msgid ""
"When using generics, the standard library's `Into<T>` can provide a kind of "
"limited polymorphism on argument types. We will see more details in a later "
"section."
msgstr ""
"Podczas korzystania z typ贸w generycznych, `Into<T>` z biblioteki "
"standardowej mo偶e zapewni pewnego rodzaju ograniczony polimorfizm typ贸w "
"argument贸w. Wicej szczeg贸贸w zobaczymy w dalszej czci."

#: src/exercises/day-1/morning.md:1
msgid "Day 1: Morning Exercises"
msgstr "Dzie 1: wiczenia poranne"

#: src/exercises/day-1/morning.md:3
msgid "In these exercises, we will explore two parts of Rust:"
msgstr "W tych wiczeniach przyjrzymy si dw贸m czciom Rusta:"

#: src/exercises/day-1/morning.md:5
msgid "Implicit conversions between types."
msgstr "Niejawne konwersje midzy typami."

#: src/exercises/day-1/morning.md:7
msgid "Arrays and `for` loops."
msgstr "Tablice i ptle `for`."

#: src/exercises/day-1/morning.md:11
msgid "A few things to consider while solving the exercises:"
msgstr ""
"Kilka rzeczy, kt贸re nale偶y wzi pod uwag podczas rozwizywania wicze:"

#: src/exercises/day-1/morning.md:13
msgid ""
"Use a local Rust installation, if possible. This way you can get auto-"
"completion in your editor. See the page about [Using Cargo](../../cargo.md) "
"for details on installing Rust."
msgstr ""
"Jeli to mo偶liwe, u偶yj lokalnej instalacji Rusta. W ten spos贸b mo偶esz dosta "
"autouzupenianie w twoim edytorze. Wicej informacji o instalowaniu Rusta "
"znajdziesz na stronie o [Korzystaniu z Cargo](../../cargo.md)."

#: src/exercises/day-1/morning.md:17
msgid "Alternatively, use the Rust Playground."
msgstr "Ewentualnie skorzystaj z Rust Playground."

#: src/exercises/day-1/morning.md:19
msgid ""
"The code snippets are not editable on purpose: the inline code snippets lose "
"their state if you navigate away from the page."
msgstr ""
"Fragment贸w kodu celowo nie mo偶na edytowa: wbudowane fragmenty kodu trac "
"stan, jeli opucisz stron."

#: src/exercises/day-1/morning.md:22 src/exercises/day-1/afternoon.md:11
#: src/exercises/day-2/morning.md:11 src/exercises/day-2/afternoon.md:7
#: src/exercises/day-3/morning.md:7 src/exercises/day-4/morning.md:12
msgid ""
"After looking at the exercises, you can look at the \\[solutions\\] provided."
msgstr ""
"Po obejrzeniu wicze mo偶esz spojrze na dostarczone \\[rozwizania\\]."

#: src/exercises/day-1/implicit-conversions.md:3
msgid ""
"Rust will not automatically apply _implicit conversions_ between types "
"([unlike C++](https://en.cppreference.com/w/cpp/language/"
"implicit_conversion)). You can see this in a program like this:"
msgstr ""
"Rust nie zastosuje automatycznie _niejawnych konwersji_ midzy typami ([w "
"przeciwiestwie do C++](https://en.cppreference.com/w/cpp/language/"
"implicit_conversion)). Mo偶esz to zobaczy w takim programie:"

#: src/exercises/day-1/implicit-conversions.md:6
msgid ""
"```rust,editable,compile_fail\n"
"fn multiply(x: i16, y: i16) -> i16 {\n"
"    x * y\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"fn multiply(x: i16, y: i16) -> i16 {\n"
"    x * y\n"
"}\n"
"```"

#: src/exercises/day-1/implicit-conversions.md:11
msgid "fn main() { let x: i8 = 15; let y: i16 = 1000;"
msgstr "fn main() { let x: i8 = 15; let y: i16 = 1000;"

#: src/exercises/day-1/implicit-conversions.md:15
msgid ""
"```\n"
"println!(\"{x} * {y} = {}\", multiply(x, y));\n"
"```"
msgstr ""
"```\n"
"println!(\"{x} * {y} = {}\", multiply(x, y));\n"
"```"

#: src/exercises/day-1/implicit-conversions.md:19
msgid ""
"The Rust integer types all implement the [`From<T>`](https://doc.rust-lang."
"org/std/convert/trait.From.html) and [`Into<T>`](https://doc.rust-lang.org/"
"std/convert/trait.Into.html) traits to let us convert between them. The "
"`From<T>` trait has a single `from()` method and similarly, the `Into<T>` "
"trait has a single `into()` method. Implementing these traits is how a type "
"expresses that it can be converted into another type."
msgstr ""
"Wszystkie typy cakowite w Rucie implementuj cechy [`From<T>`](https://doc."
"rust-lang.org/std/convert/trait.From.html) i [`Into<T>`](https://doc.rust-"
"lang.org/std/convert/trait.Into.html) aby umo偶liwi nam konwersj midzy "
"nimi. Cecha `From<T>` ma jedn metod `from()` i podobnie cecha `Into<T>` ma "
"jedn metod `into()`. Implementacja tych cech to wyra偶enie, w jaki spos贸b "
"mo偶na przeksztaci dany typ w inny typ."

#: src/exercises/day-1/implicit-conversions.md:25
msgid ""
"The standard library has an implementation of `From<i8> for i16`, which "
"means that we can convert a variable `x` of type `i8` to an `i16` by "
"calling  `i16::from(x)`. Or, simpler, with `x.into()`, because `From<i8> for "
"i16` implementation automatically create an implementation of `Into<i16> for "
"i8`."
msgstr ""
"Standardowa biblioteka ma implementacj `From<i8>` dla `i16`, co oznacza 偶e "
"mo偶emy zamieni zmienn `x` typu `i8` na `i16` przez wywoanie `i16::"
"from(x)`. Lub, prociej, za pomoc `x.into()`, poniewa偶 implementacja "
"`From<i8>` dla `i16` automatycznie tworzy implementacj `Into<i16>` dla `i8`."

#: src/exercises/day-1/implicit-conversions.md:30
msgid ""
"The same applies for your own `From` implementations for your own types, so "
"it is sufficient to only implement `From` to get a respective `Into` "
"implementation automatically."
msgstr ""
"To samo dotyczy twoich wasnych implementacji `From` dla twoich wasnych "
"typ贸w, wic wystarczy zaimplementowa tylko `From`, aby automatycznie "
"uzyska odpowiedni implementacj `Into`."

#: src/exercises/day-1/implicit-conversions.md:33
msgid "Execute the above program and look at the compiler error."
msgstr "Uruchom powy偶szy program i sp贸jrz na bd kompilatora."

#: src/exercises/day-1/implicit-conversions.md:35
msgid "Update the code above to use `into()` to do the conversion."
msgstr ""
"Zaktualizuj powy偶szy kod, aby u偶y funkcji `into()` do przeprowadzenia "
"konwersji."

#: src/exercises/day-1/implicit-conversions.md:37
msgid ""
"Change the types of `x` and `y` to other things (such as `f32`, `bool`, "
"`i128`) to see which types you can convert to which other types. Try "
"converting small types to big types and the other way around. Check the "
"[standard library documentation](https://doc.rust-lang.org/std/convert/trait."
"From.html) to see if `From<T>` is implemented for the pairs you check."
msgstr ""
"Zmie typy `x` i `y` na inne (takie jak `f32`, `bool`, `i128`), aby "
"zobaczy, kt贸re typy mo偶na przekonwertowa na inne typy. Spr贸buj konwertowa "
"mae typy na du偶e i na odwr贸t. Sprawd藕 [dokumentacj biblioteki standardowej]"
"(https://doc.rust-lang.org/std/convert/trait.From.html), aby zobaczy, czy "
"`From<T>` jest zaimplementowane dla pary typ贸w, kt贸re sprawdzasz."

#: src/exercises/day-1/for-loops.md:1
#: src/exercises/day-1/solutions-morning.md:3
msgid "Arrays and `for` Loops"
msgstr "Tablice i ptle `for`"

#: src/exercises/day-1/for-loops.md:3
msgid "We saw that an array can be declared like this:"
msgstr "Widzielimy, 偶e tablic mo偶na zadeklarowa w nastpujcy spos贸b:"

#: src/exercises/day-1/for-loops.md:5
msgid ""
"```rust\n"
"let array = [10, 20, 30];\n"
"```"
msgstr ""
"```rust\n"
"let array = [10, 20, 30];\n"
"```"

#: src/exercises/day-1/for-loops.md:9
msgid ""
"You can print such an array by asking for its debug representation with `{:?}"
"`:"
msgstr ""
"Mo偶esz wydrukowa tak tablic, proszc o jej reprezentacj debugowania za "
"pomoc `{:?}`:"

#: src/exercises/day-1/for-loops.md:11
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    println!(\"array: {array:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    println!(\"array: {array:?}\");\n"
"}\n"
"```"

#: src/exercises/day-1/for-loops.md:18
msgid ""
"Rust lets you iterate over things like arrays and ranges using the `for` "
"keyword:"
msgstr ""
"Rust pozwala iterowa po takich rzeczach, jak tablice i zakresy, u偶ywajc "
"sowa kluczowego `for`:"

#: src/exercises/day-1/for-loops.md:21
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    print!(\"Iterating over array:\");\n"
"    for n in array {\n"
"        print!(\" {n}\");\n"
"    }\n"
"    println!();\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    print!(\"Iterowanie po tablicy:\");\n"
"    for n in array {\n"
"        print!(\" {n}\");\n"
"    }\n"
"    println!();\n"
"```"

#: src/exercises/day-1/for-loops.md:30
msgid ""
"```\n"
"print!(\"Iterating over range:\");\n"
"for i in 0..3 {\n"
"    print!(\" {}\", array[i]);\n"
"}\n"
"println!();\n"
"```"
msgstr ""
"```\n"
"print!(\"Iterowanie po zakresie:\");\n"
"for i in 0..3 {\n"
"    print!(\" {}\", array[i]);\n"
"}\n"
"println!();\n"
"```"

#: src/exercises/day-1/for-loops.md:38
msgid ""
"Use the above to write a function `pretty_print` which pretty-print a matrix "
"and a function `transpose` which will transpose a matrix (turn rows into "
"columns):"
msgstr ""
"U偶yj powy偶szego, aby napisa funkcj `pretty_print`, kt贸ra adnie drukuje "
"macierz i funkcj `transpose`, kt贸ra transponuje macierz (zamienia wiersze "
"na kolumny):"

#: src/exercises/day-1/for-loops.md:41
msgid ""
"```bob\n"
"           1 2 3も      1 4 7\n"
"\"transpose\"4 5 6モ  \"==\"2 5 8\n"
"           7 8 9      3 6 9\n"
"```"
msgstr ""
"```bob\n"
"           1 2 3も      1 4 7\n"
"\"transpose\"4 5 6モ  \"==\"2 5 8\n"
"           7 8 9      3 6 9\n"
"```"

#: src/exercises/day-1/for-loops.md:47
msgid "Hard-code both functions to operate on 3  3 matrices."
msgstr "Zakoduj na stae obie funkcje, aby dziaay na macierzach 3  3."

#: src/exercises/day-1/for-loops.md:49
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and implement the "
"functions:"
msgstr ""
"Skopiuj poni偶szy kod do <https://play.rust-lang.org/> i zaimplementuj "
"funkcje:"

#: src/exercises/day-1/for-loops.md:52 src/exercises/day-1/book-library.md:20
#: src/exercises/day-2/health-statistics.md:13
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"```"
msgstr ""
"```rust,should_panic\n"
"// TODO: usu to jak skoczysz implementacj.\n"
"#![allow(unused_variables, dead_code)]\n"
"```"

#: src/exercises/day-1/for-loops.md:56
msgid ""
"fn transpose(matrix: \\[\\[i32; 3\\]; 3\\]) -> \\[\\[i32; 3\\]; 3\\] "
"{ unimplemented!() }"
msgstr ""
"fn transpose(matrix: \\[\\[i32; 3\\]; 3\\]) -> \\[\\[i32; 3\\]; 3\\] "
"{ unimplemented!() }"

#: src/exercises/day-1/for-loops.md:60
msgid "fn pretty_print(matrix: &\\[\\[i32; 3\\]; 3\\]) { unimplemented!() }"
msgstr "fn pretty_print(matrix: &\\[\\[i32; 3\\]; 3\\]) { unimplemented!() }"

#: src/exercises/day-1/for-loops.md:64
msgid ""
"fn main() { let matrix = \\[ \\[101, 102, 103\\], // \\<\\-- the comment "
"makes rustfmt add a newline \\[201, 202, 203\\], \\[301, 302, 303\\], \\];"
msgstr ""
"fn main() { let matrix = \\[ \\[101, 102, 103\\], // \\<\\-- ten komentarz "
"powoduje, 偶e rustfmt dodaje now lini \\[201, 202, 203\\], \\[301, 302, "
"303\\], \\];"

#: src/exercises/day-1/for-loops.md:71
#: src/exercises/day-1/solutions-morning.md:70
msgid ""
"```\n"
"println!(\"matrix:\");\n"
"pretty_print(&matrix);\n"
"```"
msgstr ""
"```\n"
"println!(\"matrix:\");\n"
"pretty_print(&matrix);\n"
"```"

#: src/exercises/day-1/for-loops.md:74
#: src/exercises/day-1/solutions-morning.md:73
msgid ""
"```\n"
"let transposed = transpose(matrix);\n"
"println!(\"transposed:\");\n"
"pretty_print(&transposed);\n"
"```"
msgstr ""
"```\n"
"let transposed = transpose(matrix);\n"
"println!(\"transposed:\");\n"
"pretty_print(&transposed);\n"
"```"

#: src/exercises/day-1/for-loops.md:80
msgid "Bonus Question"
msgstr "Dodatkowe pytanie"

#: src/exercises/day-1/for-loops.md:82
msgid ""
"Could you use `&[i32]` slices instead of hard-coded 3  3 matrices for your "
"argument and return types? Something like `&[&[i32]]` for a two-dimensional "
"slice-of-slices. Why or why not?"
msgstr ""
"Czy m贸gby u偶y wycink贸w `&[i32]` zamiast zakodowanych na stae macierzy 3 "
" 3 dla typ贸w argument贸w i typ贸w zwracanych? Co w stylu `&[&[i32]]` dla "
"dwuwymiarowych wycink贸w-wycink贸w. Dlaczego tak lub dlaczego nie?"

#: src/exercises/day-1/for-loops.md:87
msgid ""
"See the [`ndarray` crate](https://docs.rs/ndarray/) for a production quality "
"implementation."
msgstr ""
"Zobacz [skrzyni `ndarray`](https://docs.rs/ndarray/) dla implementacji "
"produkcyjnej jakoci."

#: src/exercises/day-1/for-loops.md:92
msgid ""
"The solution and the answer to the bonus section are available in the  "
"[Solution](solutions-morning.md#arrays-and-for-loops) section."
msgstr ""
"Rozwizanie i odpowied藕 do sekcji bonusowej s dostpne w sekcji "
"[Rozwizanie](solutions-morning.md#arrays-and-for-loops)."

#: src/basic-syntax/variables.md:3
msgid ""
"Rust provides type safety via static typing. Variable bindings are immutable "
"by default:"
msgstr ""
"Rust zapewnia bezpieczestwo typ贸w dziki statycznemu typowaniu. Wizania "
"zmiennych s domylnie niezmienne:"

#: src/basic-syntax/variables.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x: i32 = 10;\n"
"    println!(\"x: {x}\");\n"
"    // x = 20;\n"
"    // println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let x: i32 = 10;\n"
"    println!(\"x: {x}\");\n"
"    // x = 20;\n"
"    // println!(\"x: {x}\");\n"
"}\n"
"```"

#: src/basic-syntax/variables.md:17
msgid ""
"Due to type inference the `i32` is optional. We will gradually show the "
"types less and less as the course progresses."
msgstr ""
"Ze wzgldu na wnioskowanie o typie `i32` jest opcjonalne. Stopniowo bdziemy "
"pokazywa mniej typ贸w w miar postp贸w w kursie."

#: src/basic-syntax/variables.md:18
msgid ""
"Note that since `println!` is a macro, `x` is not moved, even using the "
"function like syntax of `println!(\"x: {}\", x)`"
msgstr ""
"Zauwa偶, 偶e poniewa偶 `println!` jest makrem, `x` nie jest przenoszone, nawet "
"przy u偶yciu skadni podobnej do funkcji `println!(\"x: {}\", x)`"

#: src/basic-syntax/type-inference.md:3
msgid "Rust will look at how the variable is _used_ to determine the type:"
msgstr ""
"Rust sprawdzi, w jaki spos贸b zmienna jest _u偶ywana_ do okrelenia typu:"

#: src/basic-syntax/type-inference.md:5
msgid ""
"```rust,editable\n"
"fn takes_u32(x: u32) {\n"
"    println!(\"u32: {x}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn takes_u32(x: u32) {\n"
"    println!(\"u32: {x}\");\n"
"}\n"
"```"

#: src/basic-syntax/type-inference.md:10
msgid "fn takes_i8(y: i8) { println!(\"i8: {y}\"); }"
msgstr "fn takes_i8(y: i8) { println!(\"i8: {y}\"); }"

#: src/basic-syntax/type-inference.md:14
msgid "fn main() { let x = 10; let y = 20;"
msgstr "fn main() { let x = 10; let y = 20;"

#: src/basic-syntax/type-inference.md:18
msgid ""
"```\n"
"takes_u32(x);\n"
"takes_i8(y);\n"
"// takes_u32(y);\n"
"```"
msgstr ""
"```\n"
"takes_u32(x);\n"
"takes_i8(y);\n"
"// takes_u32(y);\n"
"```"

#: src/basic-syntax/type-inference.md:26
msgid ""
"This slide demonstrates how the Rust compiler infers types based on "
"constraints given by variable declarations and usages."
msgstr ""
"Ten slajd pokazuje, w jaki spos贸b kompilator Rusta wnioskuje o typach na "
"podstawie ogranicze nao偶onych przez deklaracje i zastosowania zmiennych."

#: src/basic-syntax/type-inference.md:28
msgid ""
"It is very important to emphasize that variables declared like this are not "
"of some sort of dynamic \"any type\" that can hold any data. The machine "
"code generated by such declaration is identical to the explicit declaration "
"of a type. The compiler does the job for us and helps us write more concise "
"code."
msgstr ""
"Bardzo wa偶ne jest podkrelenie, 偶e zmienne zadeklarowane w ten spos贸b nie s "
"jakim dynamicznym dowolnym typem, kt贸ry mo偶e przechowywa dowolne dane. "
"Kod maszynowy generowany przez tak deklaracj jest identyczny z jawn "
"deklaracj typu. Kompilator wykonuje to za nas i pomaga nam pisa bardziej "
"zwizy kod."

#: src/basic-syntax/type-inference.md:32
msgid ""
"The following code tells the compiler to copy into a certain generic "
"container without the code ever explicitly specifying the contained type, "
"using `_` as a placeholder:"
msgstr ""
"Poni偶szy kod m贸wi kompilatorowi, aby skopiowa do pewnego og贸lnego kontenera "
"bez jawnego okrelania typu zawartego w kodzie, u偶ywajc `_` jako symbolu "
"zastpczego:"

#: src/basic-syntax/type-inference.md:34
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v = Vec::new();\n"
"    v.push((10, false));\n"
"    v.push((20, true));\n"
"    println!(\"v: {v:?}\");\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v = Vec::new();\n"
"    v.push((10, false));\n"
"    v.push((20, true));\n"
"    println!(\"v: {v:?}\");\n"
"```"

#: src/basic-syntax/type-inference.md:41
msgid ""
"```\n"
"let vv = v.iter().collect::<std::collections::HashSet<_>>();\n"
"println!(\"vv: {vv:?}\");\n"
"```"
msgstr ""
"```\n"
"let vv = v.iter().collect::<std::collections::HashSet<_>>();\n"
"println!(\"vv: {vv:?}\");\n"
"```"

#: src/basic-syntax/type-inference.md:46
msgid ""
"[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator."
"html#method.collect) relies on `FromIterator`, which [`HashSet`](https://doc."
"rust-lang.org/std/iter/trait.FromIterator.html) implements."
msgstr ""
"[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator."
"html#method.collect) polega na `FromIterator`, kt贸ry \\[`HashSet`\\]"
"(https:/ /doc.rust-lang.org/std/iter/trait.FromIterator.html) implementuje."

#: src/basic-syntax/static-and-const.md:1
msgid "Static and Constant Variables"
msgstr "Zmienne statyczne i stae"

#: src/basic-syntax/static-and-const.md:3
msgid "Global state is managed with static and constant variables."
msgstr ""
"Stan globalny jest zarzdzany za pomoc zmiennych statycznych i staych."

#: src/basic-syntax/static-and-const.md:5
msgid "`const`"
msgstr "`const`"

#: src/basic-syntax/static-and-const.md:7
msgid "You can declare compile-time constants:"
msgstr "Mo偶esz zadeklarowa stae czasu kompilacji:"

#: src/basic-syntax/static-and-const.md:9
msgid ""
"```rust,editable\n"
"const DIGEST_SIZE: usize = 3;\n"
"const ZERO: Option<u8> = Some(42);\n"
"```"
msgstr ""
"```rust,editable\n"
"const DIGEST_SIZE: usize = 3;\n"
"const ZERO: Option<u8> = Some(42);\n"
"```"

#: src/basic-syntax/static-and-const.md:13
msgid ""
"fn compute_digest(text: &str) -> \\[u8; DIGEST_SIZE\\] { let mut digest = "
"\\[ZERO.unwrap_or(0); DIGEST_SIZE\\]; for (idx, &b) in text.as_bytes()."
"iter().enumerate() { digest\\[idx % DIGEST_SIZE\\] = digest\\[idx % "
"DIGEST_SIZE\\].wrapping_add(b); } digest }"
msgstr ""
"fn compute_digest(text: &str) -> \\[u8; DIGEST_SIZE\\] { let mut digest = "
"\\[ZERO.unwrap_or(0); DIGEST_SIZE\\]; for (idx, &b) in text.as_bytes()."
"iter().enumerate() { digest\\[idx % DIGEST_SIZE\\] = digest\\[idx % "
"DIGEST_SIZE\\].wrapping_add(b); } digest }"

#: src/basic-syntax/static-and-const.md:21
msgid ""
"fn main() { let digest = compute_digest(\"Hello\"); println!(\"Digest: "
"{digest:?}\"); }"
msgstr ""
"fn main() { let digest = compute_digest(\"Hello\"); println!(\"Digest: "
"{digest:?}\"); }"

#: src/basic-syntax/static-and-const.md:27
msgid ""
"According the the [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-"
"const-vs-static.html) these are inlined upon use."
msgstr ""
"Zgodnie z [ksi偶k Rust RFC](https://rust-lang.github.io/rfcs/0246-const-vs-"
"static.html) s one wstawiane podczas u偶ycia."

#: src/basic-syntax/static-and-const.md:29
msgid "`static`"
msgstr "`static`"

#: src/basic-syntax/static-and-const.md:31
msgid "You can also declare static variables:"
msgstr "Mo偶esz tak偶e zadeklarowa zmienne statyczne:"

#: src/basic-syntax/static-and-const.md:33
msgid ""
"```rust,editable\n"
"static BANNER: &str = \"Welcome to RustOS 3.14\";\n"
"```"
msgstr ""
"```rust,editable\n"
"static BANNER: &str = \"Witamy w RustOS 3.14\";\n"
"```"

#: src/basic-syntax/static-and-const.md:36
msgid "fn main() { println!(\"{BANNER}\"); }"
msgstr "fn main() { println!(\"{BANNER}\"); }"

#: src/basic-syntax/static-and-const.md:41
msgid ""
"As noted in the [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-"
"vs-static.html), these are not inlined upon use and have an actual "
"associated memory location.  This is useful for unsafe and embedded code, "
"and the variable lives through the entirety of the program execution."
msgstr ""
"Jak zauwa偶ono w [ksi偶ce Rust RFC](https://rust-lang.github.io/rfcs/0246-"
"const-vs-static.html), nie s one wstawiane podczas u偶ycia i maj "
"rzeczywist powizan lokalizacj pamici. Jest to przydatne w przypadku "
"niebezpiecznego i osadzonego kodu, a zmienna 偶yje przez cae wykonanie "
"programu."

#: src/basic-syntax/static-and-const.md:44
msgid ""
"We will look at mutating static data in the [chapter on Unsafe Rust](../"
"unsafe.md)."
msgstr ""
"Przyjrzymy si zmienianiu danych statycznych w [rozdziale dotyczcym "
"niebezpiecznego Rusta](../unsafe.md)."

#: src/basic-syntax/static-and-const.md:48
msgid "Mention that `const` behaves semantically similar to C++'s `constexpr`."
msgstr ""
"Wspomnij, 偶e `const` zachowuje si semantycznie podobnie do `constexpr` C++."

#: src/basic-syntax/static-and-const.md:49
msgid ""
"`static`, on the other hand, is much more similar to a `const` or mutable "
"global variable in C++."
msgstr ""
"Z drugiej strony `static` jest znacznie bardziej podobny do `const` lub "
"mutowalnej zmiennej globalnej w C++."

#: src/basic-syntax/static-and-const.md:50
msgid ""
"It isn't super common that one would need a runtime evaluated constant, but "
"it is helpful and safer than using a static."
msgstr ""
"Nie jest bardzo powszechne, 偶e kto potrzebowaby staej wyliczanej w czasie "
"wykonywania, ale jest to pomocne i bezpieczniejsze ni偶 u偶ywanie zmiennej "
"statycznej."

#: src/basic-syntax/scopes-shadowing.md:3
msgid ""
"You can shadow variables, both those from outer scopes and variables from "
"the same scope:"
msgstr ""
"Mo偶esz przesania zmienne, zar贸wno te z zakres贸w zewntrznych, jak i "
"zmienne z tego samego zakresu:"

#: src/basic-syntax/scopes-shadowing.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 10;\n"
"    println!(\"before: {a}\");\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 10;\n"
"    println!(\"przedtem: {a}\");\n"
"```"

#: src/basic-syntax/scopes-shadowing.md:11
msgid ""
"```\n"
"{\n"
"    let a = \"hello\";\n"
"    println!(\"inner scope: {a}\");\n"
"```"
msgstr ""
"```\n"
"{\n"
"    let a = \"cze\";\n"
"    println!(\"wewntrzny zakres: {a}\");\n"
"```"

#: src/basic-syntax/scopes-shadowing.md:15
msgid ""
"```\n"
"    let a = true;\n"
"    println!(\"shadowed in inner scope: {a}\");\n"
"}\n"
"```"
msgstr ""
"```\n"
"    let a = true;\n"
"    println!(\"przesonita w wewntrznym zakresie: {a}\");\n"
"}\n"
"```"

#: src/basic-syntax/scopes-shadowing.md:19
msgid ""
"```\n"
"println!(\"after: {a}\");\n"
"```"
msgstr ""
"```\n"
"println!(\"potem: {a}\");\n"
"```"

#: src/basic-syntax/scopes-shadowing.md:25
msgid ""
"Definition: Shadowing is different from mutation, because after shadowing "
"both variable's memory locations exist at the same time. Both are available "
"under the same name, depending where you use it in the code. "
msgstr ""
"Definicja: Przesanianie r贸偶ni si od mutacji, poniewa偶 po przesanianiu "
"obie lokalizacje pamici istniej w tym samym czasie. Obie s dostpne pod "
"t sam nazw, w zale偶noci od tego, gdzie u偶ywasz ich w kodzie."

#: src/basic-syntax/scopes-shadowing.md:26
msgid "A shadowing variable can have a different type. "
msgstr "Zmienna przesaniajca mo偶e mie inny typ."

#: src/basic-syntax/scopes-shadowing.md:27
msgid ""
"Shadowing looks obscure at first, but is convenient for holding on to values "
"after `.unwrap()`."
msgstr ""
"Przesanianie na pierwszy rzut oka wyglda niejasno, ale jest wygodne do "
"trzymania wartoci po `.unwrap()`."

#: src/basic-syntax/scopes-shadowing.md:28
msgid ""
"The following code demonstrates why the compiler can't simply reuse memory "
"locations when shadowing an immutable variable in a scope, even if the type "
"does not change."
msgstr ""
"Poni偶szy kod ilustruje, dlaczego kompilator nie mo偶e po prostu ponownie u偶y "
"lokalizacji pamici podczas przesaniania niemutowalnej zmiennej w zakresie, "
"nawet jeli typ si nie zmienia."

#: src/basic-syntax/scopes-shadowing.md:30
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 1;\n"
"    let b = &a;\n"
"    let a = a + 1;\n"
"    println!(\"{a} {b}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 1;\n"
"    let b = &a;\n"
"    let a = a + 1;\n"
"    println!(\"{a} {b}\");\n"
"}\n"
"```"

#: src/memory-management.md:3
msgid "Traditionally, languages have fallen into two broad categories:"
msgstr "Tradycyjnie jzyki dzieliy si na dwie szerokie kategorie:"

#: src/memory-management.md:5
msgid "Full control via manual memory management: C, C++, Pascal, ..."
msgstr ""
"Pena kontrola poprzez rczne zarzdzanie pamici: C, C++, Pascal, ..."

#: src/memory-management.md:6
msgid ""
"Full safety via automatic memory management at runtime: Java, Python, Go, "
"Haskell, ..."
msgstr ""
"Pene bezpieczestwo dziki automatycznemu zarzdzaniu pamici w czasie "
"wykonywania: Java, Python, Go, Haskell, ..."

#: src/memory-management.md:8
msgid "Rust offers a new mix:"
msgstr "Rust oferuje now mieszank:"

#: src/memory-management.md:10
msgid ""
"Full control _and_ safety via compile time enforcement of correct memory "
"management."
msgstr ""
"Pena kontrola _i_ bezpieczestwo poprzez egzekwowanie poprawnego "
"zarzdzania pamici w czasie kompilacji."

#: src/memory-management.md:13
msgid "It does this with an explicit ownership concept."
msgstr "Czyni to z wyra藕n koncepcj wasnoci."

#: src/memory-management.md:15
msgid "First, let's refresh how memory management works."
msgstr "Najpierw odwie偶my, jak dziaa zarzdzanie pamici."

#: src/memory-management/stack-vs-heap.md:1
msgid "The Stack vs The Heap"
msgstr "Stos a sterta"

#: src/memory-management/stack-vs-heap.md:3
msgid "Stack: Continuous area of memory for local variables."
msgstr "Stos: cigy obszar pamici dla zmiennych lokalnych."

#: src/memory-management/stack-vs-heap.md:4
msgid "Values have fixed sizes known at compile time."
msgstr "Wartoci maj stae rozmiary znane w czasie kompilacji."

#: src/memory-management/stack-vs-heap.md:5
msgid "Extremely fast: just move a stack pointer."
msgstr "Niezwykle szybki: wystarczy przesun wska藕nik stosu."

#: src/memory-management/stack-vs-heap.md:6
msgid "Easy to manage: follows function calls."
msgstr "atwy w zarzdzaniu: pod偶a za wywoaniami funkcji."

#: src/memory-management/stack-vs-heap.md:7
msgid "Great memory locality."
msgstr "wietna lokalno pamici."

#: src/memory-management/stack-vs-heap.md:9
msgid "Heap: Storage of values outside of function calls."
msgstr "Sterta: Przechowywanie wartoci poza wywoaniami funkcji."

#: src/memory-management/stack-vs-heap.md:10
msgid "Values have dynamic sizes determined at runtime."
msgstr "Wartoci maj dynamiczne rozmiary okrelone w czasie wykonywania."

#: src/memory-management/stack-vs-heap.md:11
msgid "Slightly slower than the stack: some book-keeping needed."
msgstr "Nieco wolniejsza ni偶 stos: potrzebne troch ksigowoci."

#: src/memory-management/stack-vs-heap.md:12
msgid "No guarantee of memory locality."
msgstr "Brak gwarancji lokalnoci pamici."

#: src/memory-management/stack.md:3
msgid ""
"Creating a `String` puts fixed-sized data on the stack and dynamically sized "
"data on the heap:"
msgstr ""
"Utworzenie `String` powoduje umieszczenie danych o staym rozmiarze na "
"stosie i danych o dynamicznym rozmiarze na stercie:"

#: src/memory-management/stack.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1 = String::from(\"Hello\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let s1 = String::from(\"Hello\");\n"
"}\n"
"```"

#: src/memory-management/stack.md:12
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - -.\n"
":                           :     :                               :\n"
":    s1                     :     :                               :\n"
":   +-----------+-------+   :     :   +----+----+----+----+----+  :\n"
":   | ptr       |   o---+---+-----+-->| H  | e  | l  | l  | o  |  :\n"
":   | len       |     5 |   :     :   +----+----+----+----+----+  :\n"
":   | capacity  |     5 |   :     :                               :\n"
":   +-----------+-------+   :     :                               :\n"
":                           :     `- - - - - - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stos                             Sterta\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - -.\n"
":                           :     :                               :\n"
":    s1                     :     :                               :\n"
":   +-----------+-------+   :     :   +----+----+----+----+----+  :\n"
":   | ptr       |   o---+---+-----+-->| H  | e  | l  | l  | o  |  :\n"
":   | len       |     5 |   :     :   +----+----+----+----+----+  :\n"
":   | capacity  |     5 |   :     :                               :\n"
":   +-----------+-------+   :     :                               :\n"
":                           :     `- - - - - - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/memory-management/stack.md:28
msgid ""
"Mention that a `String` is backed by a `Vec`, so it has a capacity and "
"length and can grow if mutable via reallocation on the heap."
msgstr ""
"Wspomnij, 偶e `String` jest oparty o `Vec`, wic ma pojemno i dugo, i "
"je偶eli jest mutowalny to mo偶e rosn poprzez realokacj na stercie."

#: src/memory-management/stack.md:30
msgid ""
"If students ask about it, you can mention that the underlying memory is heap "
"allocated using the [System Allocator](https://doc.rust-lang.org/std/alloc/"
"struct.System.html) and custom allocators can be implemented using the "
"[Allocator API](https://doc.rust-lang.org/std/alloc/index.html)"
msgstr ""
"Je偶eli uczniowie o to zapytaj to mo偶esz wspomnie, 偶e pami na stercie "
"jest alokowana za pomoc [alokatora systemowego](https://doc.rust-lang.org/"
"std/alloc/struct.System.html) I wasny alokator mo偶e by zaimplementowany "
"u偶ywajc [API alokatora](https://doc.rust-lang.org/std/alloc/index.html)"

#: src/memory-management/stack.md:32
msgid ""
"We can inspect the memory layout with `unsafe` code. However, you should "
"point out that this is rightfully unsafe!"
msgstr ""
"Mo偶emy zrobi inspekcj rozo偶enia pamici w niebezpiecznym (`unsafe`) "
"kodzie. Jednak nale偶y zauwa偶y, 偶e jest to niebezpieczne!"

#: src/memory-management/stack.md:34
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::from(\"Hello\");\n"
"    s1.push(' ');\n"
"    s1.push_str(\"world\");\n"
"    // DON'T DO THIS AT HOME! For educational purposes only.\n"
"    // String provides no guarantees about its layout, so this could lead "
"to\n"
"    // undefined behavior.\n"
"    unsafe {\n"
"        let (capacity, ptr, len): (usize, usize, usize) = std::mem::"
"transmute(s1);\n"
"        println!(\"ptr = {ptr:#x}, len = {len}, capacity = {capacity}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::from(\"Hello\");\n"
"    s1.push(' ');\n"
"    s1.push_str(\"world\");\n"
"    // NIE PRBUJCIE TEGO W DOMU! Tylko dla cel贸w edukacyjnych.\n"
"    // String nie gwarantuje rozo偶enia pamici wic to mo偶e prowadzi do\n"
"    // niezdefiniowanego zachowania.\n"
"    unsafe {\n"
"        let (capacity, ptr, len): (usize, usize, usize) = std::mem::"
"transmute(s1);\n"
"        println!(\"ptr = {ptr:#x}, len = {len}, capacity = {capacity}\");\n"
"    }\n"
"}\n"
"```"

#: src/memory-management/manual.md:3
msgid "You allocate and deallocate heap memory yourself."
msgstr "Mo偶esz wasnorcznie alokowa i zwalnia pami sterty."

#: src/memory-management/manual.md:5
msgid ""
"If not done with care, this can lead to crashes, bugs, security "
"vulnerabilities, and memory leaks."
msgstr ""
"Je偶eli nie jest to zrobione z uwag to mo偶e prowadzi do zaamania "
"(\"crash\"), bd贸w, problem贸w bezpieczestwa i wyciek贸w pamici."

#: src/memory-management/manual.md:7
msgid "C Example"
msgstr "Przykad C"

#: src/memory-management/manual.md:9
msgid "You must call `free` on every pointer you allocate with `malloc`:"
msgstr ""
"Musisz wywoa `free` na ka偶dym wska藕niku, kt贸ry alokujesz za pomoc "
"`malloc`:"

#: src/memory-management/manual.md:11
msgid ""
"```c\n"
"void foo(size_t n) {\n"
"    int* int_array = (int*)malloc(n * sizeof(int));\n"
"    //\n"
"    // ... lots of code\n"
"    //\n"
"    free(int_array);\n"
"}\n"
"```"
msgstr ""
"```c\n"
"void foo(size_t n) {\n"
"    int* int_array = (int*)malloc(n * sizeof(int));\n"
"    //\n"
"    // ... du偶o kodu\n"
"    //\n"
"    free(int_array);\n"
"}\n"
"```"

#: src/memory-management/manual.md:21
msgid ""
"Memory is leaked if the function returns early between `malloc` and `free`: "
"the pointer is lost and we cannot deallocate the memory."
msgstr ""
"Pami wycieka je偶eli funkcja zwr贸ci pomidzy `malloc` i `free`: wska藕nik "
"jest stracony i nie mo偶emy zwolni pamici."

#: src/memory-management/scope-based.md:3
msgid ""
"Constructors and destructors let you hook into the lifetime of an object."
msgstr "Konstruktory i destruktory pozwalaj wpi si do czasu 偶ycia obiektu."

#: src/memory-management/scope-based.md:5
msgid ""
"By wrapping a pointer in an object, you can free memory when the object is "
"destroyed. The compiler guarantees that this happens, even if an exception "
"is raised."
msgstr ""
"Przez opakowania wska藕nika w obiekt, mo偶esz zwolni pami je偶eli obiekt "
"jest zniszczony. Kompilator to gwarantuje, nawet je偶eli rzucony jest wyjtek."

#: src/memory-management/scope-based.md:9
msgid ""
"This is often called _resource acquisition is initialization_ (RAII) and "
"gives you smart pointers."
msgstr ""
"Czsto jest to nazywane inicjowaniem przy pozyskaniu zasobu (ang. _resource "
"acquisition is initialization_ (RAII)) i pozwala nam na inteligentne "
"wska藕niki."

#: src/memory-management/scope-based.md:12
msgid "C++ Example"
msgstr "Przykad C++"

#: src/memory-management/scope-based.md:14
msgid ""
"```c++\n"
"void say_hello(std::unique_ptr<Person> person) {\n"
"  std::cout << \"Hello \" << person->name << std::endl;\n"
"}\n"
"```"
msgstr ""
"```c++\n"
"void say_hello(std::unique_ptr<Person> person) {\n"
"  std::cout << \"Hello \" << person->name << std::endl;\n"
"}\n"
"```"

#: src/memory-management/scope-based.md:20
msgid ""
"The `std::unique_ptr` object is allocated on the stack, and points to memory "
"allocated on the heap."
msgstr ""
"Obiekt `std::unique_ptr` jest alokowany na stosie i wskazuje na pami "
"zaalokowan na stercie."

#: src/memory-management/scope-based.md:22
msgid "At the end of `say_hello`, the `std::unique_ptr` destructor will run."
msgstr "Na kocu `say_hello` jest wywoywany destruktor `std::unique_ptr`."

#: src/memory-management/scope-based.md:23
msgid "The destructor frees the `Person` object it points to."
msgstr "Destruktor zwalnia pami obiektu `Person` na kt贸ry wskazuje."

#: src/memory-management/scope-based.md:25
msgid ""
"Special move constructors are used when passing ownership to a function:"
msgstr ""
"Specjalne konstruktory przenoszenia s u偶ywane kiedy wasno jest "
"przekazywana do funkcji:"

#: src/memory-management/scope-based.md:27
msgid ""
"```c++\n"
"std::unique_ptr<Person> person = find_person(\"Carla\");\n"
"say_hello(std::move(person));\n"
"```"
msgstr ""
"```c++\n"
"std::unique_ptr<Person> person = find_person(\"Carla\");\n"
"say_hello(std::move(person));\n"
"```"

#: src/memory-management/garbage-collection.md:1
msgid "Automatic Memory Management"
msgstr "Automatyczne zarzdzanie pamici"

#: src/memory-management/garbage-collection.md:3
msgid ""
"An alternative to manual and scope-based memory management is automatic "
"memory management:"
msgstr ""
"Alternatyw do rcznego zarzdzania pamici i zarzdzania opartego o zasig "
"jest automatyczne zarzdzanie pamici:"

#: src/memory-management/garbage-collection.md:6
msgid "The programmer never allocates or deallocates memory explicitly."
msgstr "Programista nigdy wyra藕nie nie alokuje i nie zwalnia pamici."

#: src/memory-management/garbage-collection.md:7
msgid ""
"A garbage collector finds unused memory and deallocates it for the "
"programmer."
msgstr ""
"Odmiecacz pamici znajduje nieu偶ywan pami i zwalnia j dla programisty."

#: src/memory-management/garbage-collection.md:9
msgid "Java Example"
msgstr "Przykad Javy"

#: src/memory-management/garbage-collection.md:11
msgid "The `person` object is not deallocated after `sayHello` returns:"
msgstr "Obiekt `person` nie jest zwalniany po zwr贸ceniu z `sayHello`:"

#: src/memory-management/garbage-collection.md:13
msgid ""
"```java\n"
"void sayHello(Person person) {\n"
"  System.out.println(\"Hello \" + person.getName());\n"
"}\n"
"```"
msgstr ""
"```java\n"
"void sayHello(Person person) {\n"
"  System.out.println(\"Hello \" + person.getName());\n"
"}\n"
"```"

#: src/memory-management/rust.md:1
msgid "Memory Management in Rust"
msgstr "Zarzdzanie pamici w Rucie"

#: src/memory-management/rust.md:3
msgid "Memory management in Rust is a mix:"
msgstr "Zarzdzanie pamici w Rucie to mieszanka:"

#: src/memory-management/rust.md:5
msgid "Safe and correct like Java, but without a garbage collector."
msgstr "Bezpieczne i prawidowe jak w Javie, ale bez odmiecania pamici."

#: src/memory-management/rust.md:6
msgid ""
"Depending on which abstraction (or combination of abstractions) you choose, "
"can be a single unique pointer, reference counted, or atomically reference "
"counted."
msgstr ""
"W zale偶noci kt贸r abstrakcj (lub kombinacj abstrakcji) wybierzesz to mo偶e "
"by pojedynczy unikalny wska偶nik, zliczanie referencji lub atomiczne "
"zliczanie referencji."

#: src/memory-management/rust.md:7
msgid "Scope-based like C++, but the compiler enforces full adherence."
msgstr ""
"Oparte o zakres jak w C++, ale kompilator egzekwuje pene przestrzeganie."

#: src/memory-management/rust.md:8
msgid ""
"A Rust user can choose the right abstraction for the situation, some even "
"have no cost at runtime like C."
msgstr ""
"U偶ytkownika Rusta wybiera waciw abstrakcj w zale偶noci od sytuacji, "
"niekt贸re nie maj nawet kosztu w czasie uruchomienia jak w C."

#: src/memory-management/rust.md:10
msgid "It achieves this by modeling _ownership_ explicitly."
msgstr "Osiga to przez wyra藕ne modelowanie _wasnoci_."

#: src/memory-management/rust.md:14
msgid ""
"If asked how at this point, you can mention that in Rust this is usually "
"handled by RAII wrapper types such as [Box](https://doc.rust-lang.org/std/"
"boxed/struct.Box.html), [Vec](https://doc.rust-lang.org/std/vec/struct.Vec."
"html), [Rc](https://doc.rust-lang.org/std/rc/struct.Rc.html), or [Arc]"
"(https://doc.rust-lang.org/std/sync/struct.Arc.html). These encapsulate "
"ownership and memory allocation via various means, and prevent the potential "
"errors in C."
msgstr ""
"Je偶eli uczniowie zapytaj w tym momencie jak, to wspomnij, 偶e w Rucie to "
"przewa偶nie jest zrobione za pomoc opakowa takich jak [Box](https://doc."
"rust-lang.org/std/boxed/struct.Box.html), [Vec](https://doc.rust-lang.org/"
"std/vec/struct.Vec.html), [Rc](https://doc.rust-lang.org/std/rc/struct.Rc."
"html), czy [Arc](https://doc.rust-lang.org/std/sync/struct.Arc.html). Typy "
"te zapewniaj wasno i alokacj pamici r贸偶nymi metodami i zapobiegaj "
"potencjalnym problemom w C."

#: src/memory-management/rust.md:16
msgid ""
"You may be asked about destructors here, the [Drop](https://doc.rust-lang."
"org/std/ops/trait.Drop.html) trait is the Rust equivalent."
msgstr ""
"Mo偶esz dosta pytanie o destruktory, cecha [Drop](https://doc.rust-lang.org/"
"std/ops/trait.Drop.html) to Rustowy odpowiednik."

#: src/memory-management/comparison.md:3
msgid "Here is a rough comparison of the memory management techniques."
msgstr "Tutaj z grubsza por贸wnujemy techniki zarzdzania pamici."

#: src/memory-management/comparison.md:5
msgid "Pros of Different Memory Management Techniques"
msgstr "Zalety r贸偶nych technik zarzdzania pamici"

#: src/memory-management/comparison.md:7 src/memory-management/comparison.md:22
msgid "Manual like C:"
msgstr "Rczne jak w C:"

#: src/memory-management/comparison.md:8 src/memory-management/comparison.md:14
#: src/memory-management/comparison.md:17
msgid "No runtime overhead."
msgstr "Brak kosztu w czasie dziaania."

#: src/memory-management/comparison.md:9 src/memory-management/comparison.md:26
msgid "Automatic like Java:"
msgstr "Automatyczne jak w Javie:"

#: src/memory-management/comparison.md:10
msgid "Fully automatic."
msgstr "W penie automatyczne."

#: src/memory-management/comparison.md:11
#: src/memory-management/comparison.md:18
msgid "Safe and correct."
msgstr "Bezpieczne i prawidowe."

#: src/memory-management/comparison.md:12
#: src/memory-management/comparison.md:29
msgid "Scope-based like C++:"
msgstr "Oparte o zakres jak w C++:"

#: src/memory-management/comparison.md:13
msgid "Partially automatic."
msgstr "Czciowo automatyczne."

#: src/memory-management/comparison.md:15
msgid "Compiler-enforced scope-based like Rust:"
msgstr "Egzekwowane przez kompilator oparte o zakres jak w Rucie:"

#: src/memory-management/comparison.md:16
msgid "Enforced by compiler."
msgstr "Egzekwowane przez kompilator."

#: src/memory-management/comparison.md:20
msgid "Cons of Different Memory Management Techniques"
msgstr "Wady r贸偶nych technik zarzdzania pamici"

#: src/memory-management/comparison.md:23
msgid "Use-after-free."
msgstr "U偶ycie po zwolnieniu."

#: src/memory-management/comparison.md:24
msgid "Double-frees."
msgstr "Podw贸jne zwolnienie."

#: src/memory-management/comparison.md:25
msgid "Memory leaks."
msgstr "Wycieki pamici."

#: src/memory-management/comparison.md:27
msgid "Garbage collection pauses."
msgstr "Pauzy na odmiecanie pamici."

#: src/memory-management/comparison.md:28
msgid "Destructor delays."
msgstr "Op贸藕nienie destruktor贸w."

#: src/memory-management/comparison.md:30
msgid "Complex, opt-in by programmer."
msgstr "Skomplikowane, dobrowolnie u偶ywane przez programist."

#: src/memory-management/comparison.md:31
msgid "Potential for use-after-free."
msgstr "Potencjalne u偶ycie po zwolnieniu."

#: src/memory-management/comparison.md:32
msgid "Compiler-enforced and scope-based like Rust:"
msgstr "Egzekwowane przez kompilator oparte o zakres jak w Rucie:"

#: src/memory-management/comparison.md:33
msgid "Some upfront complexity."
msgstr "Pewna zo偶ono z g贸ry."

#: src/memory-management/comparison.md:34
msgid "Can reject valid programs."
msgstr "Mo偶e odrzuci prawidowe programy."

#: src/ownership.md:3
msgid ""
"All variable bindings have a _scope_ where they are valid and it is an error "
"to use a variable outside its scope:"
msgstr ""
"Wszystkie przywizania zmiennych maj _zakres_, w kt贸rym s prawidowe. "
"U偶ycie zmiennej poza jej zakresem jest bdem:"

#: src/ownership.md:6
msgid ""
"```rust,editable,compile_fail\n"
"struct Point(i32, i32);\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"struct Point(i32, i32);\n"
"```"

#: src/ownership.md:9
msgid ""
"fn main() { { let p = Point(3, 4); println!(\"x: {}\", p.0); } println!(\"y: "
"{}\", p.1); }"
msgstr ""
"fn main() { { let p = Point(3, 4); println!(\"x: {}\", p.0); } println!(\"y: "
"{}\", p.1); }"

#: src/ownership.md:18
msgid ""
"At the end of the scope, the variable is _dropped_ and the data is freed."
msgstr "Na kocu zakresu, zmienna jest _upuszczana_ i dane s zwalniane."

#: src/ownership.md:19
msgid "A destructor can run here to free up resources."
msgstr "Destruktor mo偶e by uruchomiony 偶eby zwolni zasoby."

#: src/ownership.md:20
msgid "We say that the variable _owns_ the value."
msgstr "M贸wi si, 偶e zmienna _posiada_ warto."

#: src/ownership/move-semantics.md:3
msgid "An assignment will transfer ownership between variables:"
msgstr "Przypisanie przeniesie wasno pomidzy zmiennymi:"

#: src/ownership/move-semantics.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Hello!\");\n"
"    let s2: String = s1;\n"
"    println!(\"s2: {s2}\");\n"
"    // println!(\"s1: {s1}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Cze!\");\n"
"    let s2: String = s1;\n"
"    println!(\"s2: {s2}\");\n"
"    // println!(\"s1: {s1}\");\n"
"}\n"
"```"

#: src/ownership/move-semantics.md:14
msgid "The assignment of `s1` to `s2` transfers ownership."
msgstr "Przypisanie `s1` do `s2` przenosi wasno."

#: src/ownership/move-semantics.md:15
msgid "The data was _moved_ from `s1` and `s1` is no longer accessible."
msgstr "Dane s _przeniesione_ z `s1` i zmienna `s1` nie jest ju偶 dostpna."

#: src/ownership/move-semantics.md:16
msgid "When `s1` goes out of scope, nothing happens: it has no ownership."
msgstr ""
"Kiedy zmienna `s1` wychodzi poza zakres, nic si nie dzieje: nie ma "
"wasnoci."

#: src/ownership/move-semantics.md:17
msgid "When `s2` goes out of scope, the string data is freed."
msgstr ""
"Kiedy zmienna `s2` wychodzi poza zakres, dane acucha znak贸w s zwalniane."

#: src/ownership/move-semantics.md:18
msgid "There is always _exactly_ one variable binding which owns a value."
msgstr ""
"Zawsze jest _dokadnie_ jedno przypisanie do zmiennej, kt贸re ma dane na "
"wasno."

#: src/ownership/move-semantics.md:22
msgid ""
"Mention that this is the opposite of the defaults in C++, which copies by "
"value unless you use `std::move` (and the move constructor is defined!)."
msgstr ""
"Wspomnij, 偶e jest to na odwr贸t ni偶 w C++, kt贸ry domylnie kopiuje wartoci "
"chyba, 偶e jest u偶yte `std::move` (i zdefiniowany konstruktor przenoszenia!)."

#: src/ownership/move-semantics.md:24
msgid "In Rust, clones are explicit (by using `clone`)."
msgstr "W Rucie, klonowanie jest jawne (za pomoc `clone`)."

#: src/ownership/moved-strings-rust.md:3
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Rust\");\n"
"    let s2: String = s1;\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Rust\");\n"
"    let s2: String = s1;\n"
"}\n"
"```"

#: src/ownership/moved-strings-rust.md:10
msgid "The heap data from `s1` is reused for `s2`."
msgstr "Dane sterty z `s1` s u偶yte ponownie dla `s2`."

#: src/ownership/moved-strings-rust.md:11
msgid "When `s1` goes out of scope, nothing happens (it has been moved from)."
msgstr ""
"Kiedy `s1` wychodzi poza zakres, nic si nie dzieje (dane zostay z niej "
"przeniesione)."

#: src/ownership/moved-strings-rust.md:13
msgid "Before move to `s2`:"
msgstr "Przed przeniesieniem do `s2`:"

#: src/ownership/moved-strings-rust.md:15
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1                     :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+-----+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :     :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :     :                           :\n"
":   +-----------+-------+   :     :                           :\n"
":                           :     `- - - - - - - - - - - - - -'\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stos                              Sterta\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1                     :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+-----+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :     :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :     :                           :\n"
":   +-----------+-------+   :     :                           :\n"
":                           :     `- - - - - - - - - - - - - -'\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/ownership/moved-strings-rust.md:30
msgid "After move to `s2`:"
msgstr "Po przeniesieniu do `s2`:"

#: src/ownership/moved-strings-rust.md:32
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"(inaccessible)\"    :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :  |  :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :  |  :                           :\n"
":   +-----------+-------+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     4 |   :\n"
":   | capacity  |     4 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stos                              Sterta\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"(inaccessible)\"    :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :  |  :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :  |  :                           :\n"
":   +-----------+-------+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     4 |   :\n"
":   | capacity  |     4 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/ownership/double-free-modern-cpp.md:3
msgid "Modern C++ solves this differently:"
msgstr "Nowoczesny C++ rozwizuje to inaczej:"

#: src/ownership/double-free-modern-cpp.md:5
msgid ""
"```c++\n"
"std::string s1 = \"Cpp\";\n"
"std::string s2 = s1;  // Duplicate the data in s1.\n"
"```"
msgstr ""
"```c++\n"
"std::string s1 = \"Cpp\";\n"
"std::string s2 = s1;  // Duplikowanie danych z s1.\n"
"```"

#: src/ownership/double-free-modern-cpp.md:10
msgid ""
"The heap data from `s1` is duplicated and `s2` gets its own independent copy."
msgstr ""
"Dane sterty z `s1` s zduplikowane i `s2` dostaje swoj niezale偶n kopi."

#: src/ownership/double-free-modern-cpp.md:11
msgid "When `s1` and `s2` go out of scope, they each free their own memory."
msgstr ""
"Kiedy `s1` i `s2` wychodz poza zakres, obydwie zmienne zwalniaj swoj "
"pami."

#: src/ownership/double-free-modern-cpp.md:13
msgid "Before copy-assignment:"
msgstr "Przed przypisywaniem kopiujcym:"

#: src/ownership/double-free-modern-cpp.md:16
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stos                              Sterta\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/ownership/double-free-modern-cpp.md:30
msgid "After copy-assignment:"
msgstr "Po przypisaniu kopiujcym:"

#: src/ownership/double-free-modern-cpp.md:32
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     :                       :\n"
":    s2                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+-----+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stos                              Sterta\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     :                       :\n"
":    s2                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+-----+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/ownership/moves-function-calls.md:3
msgid ""
"When you pass a value to a function, the value is assigned to the function "
"parameter. This transfers ownership:"
msgstr ""
"Kiedy przekazujesz warto do funkcji, warto jest przypisywana do "
"parametru funkcji. To przenosi wasno:"

#: src/ownership/moves-function-calls.md:6
msgid ""
"```rust,editable\n"
"fn say_hello(name: String) {\n"
"    println!(\"Hello {name}\")\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn say_hello(name: String) {\n"
"    println!(\"Cze {name}\")\n"
"}\n"
"```"

#: src/ownership/moves-function-calls.md:11
msgid ""
"fn main() { let name = String::from(\"Alice\"); say_hello(name); // "
"say_hello(name); }"
msgstr ""
"fn main() { let name = String::from(\"Alice\"); say_hello(name); // "
"say_hello(name); }"

#: src/ownership/moves-function-calls.md:20
msgid ""
"With the first call to `say_hello`, `main` gives up ownership of `name`. "
"Afterwards, `name` cannot be used anymore within `main`."
msgstr ""
"Przy pierwszym wywoaniu `say_hello`, `main` oddaje wasno `name`. Potem "
"`name` nie mo偶e by ju偶 u偶yte wewntrz `main`."

#: src/ownership/moves-function-calls.md:21
msgid ""
"The heap memory allocated for `name` will be freed at the end of the "
"`say_hello` function."
msgstr ""
"Dane zaalokowane na stercie dla `name` bd zwolnione na kocu wywoania "
"funkcji `say_hello`."

#: src/ownership/moves-function-calls.md:22
msgid ""
"`main` can retain ownership if it passes `name` as a reference (`&name`) and "
"if `say_hello` accepts a reference as a parameter."
msgstr ""
"`main` mo偶e zachowa wasno je偶eli przeka偶e `name` jako referencj "
"(`&name`) i je偶eli `say_hello` akceptuje referencj jako parameter."

#: src/ownership/moves-function-calls.md:23
msgid ""
"Alternatively, `main` can pass a clone of `name` in the first call (`name."
"clone()`)."
msgstr ""
"Alternatywnie, `main` mo偶e przekaza klona `name` w pierwszym wywoaniu "
"(`name.clone()`)."

#: src/ownership/moves-function-calls.md:24
msgid ""
"Rust makes it harder than C++ to inadvertently create copies by making move "
"semantics the default, and by forcing programmers to make clones explicit."
msgstr ""
"Przez u偶ywanie semantyki przenoszenia domylnie i przez zmuszanie "
"programist贸w do jawnego tworzenia klon贸w, Rust powoduje, 偶e przypadkowe "
"tworzenie kopii jest trudniejsze ni偶 w C++."

#: src/ownership/copy-clone.md:3
msgid ""
"While move semantics are the default, certain types are copied by default:"
msgstr ""
"Semantyka przenoszenia jest domylna, ale niekt贸re typy s domylnie "
"kopiowane:"

#: src/ownership/copy-clone.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x = 42;\n"
"    let y = x;\n"
"    println!(\"x: {x}\");\n"
"    println!(\"y: {y}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let x = 42;\n"
"    let y = x;\n"
"    println!(\"x: {x}\");\n"
"    println!(\"y: {y}\");\n"
"}\n"
"```"

#: src/ownership/copy-clone.md:14
msgid "These types implement the `Copy` trait."
msgstr "Te typy implementuj cech `Copy`."

#: src/ownership/copy-clone.md:16
msgid "You can opt-in your own types to use copy semantics:"
msgstr ""
"Mo偶esz spowodowa 偶eby semantyka kopiowania bya u偶ywana dla twoich wasnych "
"typ贸w:"

#: src/ownership/copy-clone.md:18
msgid ""
"```rust,editable\n"
"#[derive(Copy, Clone, Debug)]\n"
"struct Point(i32, i32);\n"
"```"
msgstr ""
"```rust,editable\n"
"#[derive(Copy, Clone, Debug)]\n"
"struct Point(i32, i32);\n"
"```"

#: src/ownership/copy-clone.md:22
msgid ""
"fn main() { let p1 = Point(3, 4); let p2 = p1; println!(\"p1: {p1:?}\"); "
"println!(\"p2: {p2:?}\"); }"
msgstr ""
"fn main() { let p1 = Point(3, 4); let p2 = p1; println!(\"p1: {p1:?}\"); "
"println!(\"p2: {p2:?}\"); }"

#: src/ownership/copy-clone.md:30
msgid "After the assignment, both `p1` and `p2` own their own data."
msgstr ""
"Po przypisaniu, obydwie zmienne `p1` i `p2` maj swoje dane na wasno."

#: src/ownership/copy-clone.md:31
msgid "We can also use `p1.clone()` to explicitly copy the data."
msgstr "Mo偶emy te偶 u偶y `p1.clone()` 偶eby jawnie skopiowa dane."

#: src/ownership/copy-clone.md:35
msgid "Copying and cloning are not the same thing:"
msgstr "Kopiowanie i klonowanie to nie to samo:"

#: src/ownership/copy-clone.md:37
msgid ""
"Copying refers to bitwise copies of memory regions and does not work on "
"arbitrary objects."
msgstr ""
"Kopiowanie odnosi si do bezporedniego kopiowania pamici i nie dziaa dla "
"wszystkich obiekt贸w."

#: src/ownership/copy-clone.md:38
msgid ""
"Copying does not allow for custom logic (unlike copy constructors in C++)."
msgstr ""
"Kopiowanie nie pozwala na wasn logik (jak konstruktory kopiowania w C++)."

#: src/ownership/copy-clone.md:39
msgid ""
"Cloning is a more general operation and also allows for custom behavior by "
"implementing the `Clone` trait."
msgstr ""
"Klonowanie jest og贸lniejsz operacj i pozwala na wasne zachowanie poprzez "
"implementacj cechy `Clone`."

#: src/ownership/copy-clone.md:40
msgid "Copying does not work on types that implement the `Drop` trait."
msgstr "Kopiowanie nie dziaa na typach, kt贸re implementuj cech `Drop`."

#: src/ownership/copy-clone.md:42 src/ownership/lifetimes-function-calls.md:29
msgid "In the above example, try the following:"
msgstr "W powy偶szym przykadzie spr贸buj nastpujcego:"

#: src/ownership/copy-clone.md:44
msgid ""
"Add a `String` field to `struct Point`. It will not compile because `String` "
"is not a `Copy` type."
msgstr ""
"Dodaj pole `String` do `struct Point`. Nie skompiluje si bo `String` nie "
"jest typem `Copy`."

#: src/ownership/copy-clone.md:45
msgid ""
"Remove `Copy` from the `derive` attribute. The compiler error is now in the "
"`println!` for  `p1`."
msgstr ""
"Usu `Copy` z atrybutu `derive`. Kompilator teraz zwr贸ci bd w `println!` "
"dla `p1`."

#: src/ownership/copy-clone.md:46
msgid "Show that it works if you clone `p1` instead."
msgstr "Poka偶, 偶e zadziaa je偶eli zamiast tego sklonujesz `p1`."

#: src/ownership/copy-clone.md:48
msgid ""
"If students ask about `derive`, it is sufficient to say that this is a way "
"to generate code in Rust at compile time. In this case the default "
"implementations of `Copy` and `Clone` traits are generated."
msgstr ""
"Je偶eli studenci zapytaj o `derive`, to wystarczy powiedzie, 偶e to spos贸b "
"na generowanie kodu Rusta w czasie kompilacji. W tym przypadku bd "
"wygenerowane domylne implementacje cech `Copy` i `Clone`."

#: src/ownership/borrowing.md:3
msgid ""
"Instead of transferring ownership when calling a function, you can let a "
"function _borrow_ the value:"
msgstr ""
"Zamiast przekazywania wasnoci w momencie wywoania funkcji, mo偶esz "
"_po偶yczy_ funkcji warto:"

#: src/ownership/borrowing.md:6 src/ownership/lifetimes-function-calls.md:5
#: src/ownership/borrowing.md:30
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point(i32, i32);\n"
"```"
msgstr ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point(i32, i32);\n"
"```"

#: src/ownership/borrowing.md:10
msgid ""
"fn add(p1: &Point, p2: &Point) -> Point { Point(p1.0 + p2.0, p1.1 + p2.1) }"
msgstr ""
"fn add(p1: &Point, p2: &Point) -> Point { Point(p1.0 + p2.0, p1.1 + p2.1) }"

#: src/ownership/borrowing.md:14
msgid ""
"fn main() { let p1 = Point(3, 4); let p2 = Point(10, 20); let p3 = add(&p1, "
"&p2); println!(\"{p1:?} + {p2:?} = {p3:?}\"); }"
msgstr ""
"fn main() { let p1 = Point(3, 4); let p2 = Point(10, 20); let p3 = add(&p1, "
"&p2); println!(\"{p1:?} + {p2:?} = {p3:?}\"); }"

#: src/ownership/borrowing.md:22
msgid "The `add` function _borrows_ two points and returns a new point."
msgstr "Funkcja `add` _po偶ycza_ dwa punkty i zwraca nowy punkt."

#: src/ownership/borrowing.md:23
msgid "The caller retains ownership of the inputs."
msgstr "Wywoujcy funkcj zachowuje wasno."

#: src/ownership/borrowing.md:27
msgid "Notes on stack returns:"
msgstr "Kilka notatek na temat zwracania przez stos:"

#: src/ownership/borrowing.md:28
msgid ""
"Demonstrate that the return from `add` is cheap because the compiler can "
"eliminate the copy operation. Change the above code to print stack addresses "
"and run it on the [Playground](https://play.rust-lang.org/). In the "
"\"DEBUG\" optimization level, the addresses should change, while the stay "
"the same when changing to the \"RELEASE\" setting:"
msgstr ""
"Poka偶, 偶e zwracanie z `add` jest tanie bo kompilator eliminuje kopiowanie. "
"Zmie powy偶szy kod 偶eby pokaza adresy na stosie i uruchom w [Playground]"
"(https://play.rust-lang.org/). W optymalizacji \"DEBUG\" adresy powinny si "
"zmieni, ale przy u偶yciu ustawienia \"RELEASE\" powinny pozosta te same:"

#: src/ownership/borrowing.md:34
msgid ""
"fn add(p1: &Point, p2: &Point) -> Point { let p = Point(p1.0 + p2.0, p1.1 + "
"p2.1); println!(\"&p.0: {:p}\", &p.0); p }"
msgstr ""
"fn add(p1: &Point, p2: &Point) -> Point { let p = Point(p1.0 + p2.0, p1.1 + "
"p2.1); println!(\"&p.0: {:p}\", &p.0); p }"

#: src/ownership/borrowing.md:40
msgid ""
"fn main() { let p1 = Point(3, 4); let p2 = Point(10, 20); let p3 = add(&p1, "
"&p2); println!(\"&p3.0: {:p}\", &p3.0); println!(\"{p1:?} + {p2:?} = "
"{p3:?}\"); }"
msgstr ""
"fn main() { let p1 = Point(3, 4); let p2 = Point(10, 20); let p3 = add(&p1, "
"&p2); println!(\"&p3.0: {:p}\", &p3.0); println!(\"{p1:?} + {p2:?} = "
"{p3:?}\"); }"

#: src/ownership/borrowing.md:47
msgid ""
"```\n"
"* The Rust compiler can do return value optimization (RVO).\n"
"* In C++, copy elision has to be defined in the language specification "
"because constructors can have side effects. In Rust, this is not an issue at "
"all. If RVO did not happen, Rust will always performs a simple and efficient "
"`memcpy` copy.\n"
"```"
msgstr ""
"```\n"
"* Kompilator Rusta mo偶e zoptymalizowa zwracanie przez warto (ang. _return "
"value optimization_ (RVO)).\n"
"* W C++, usuwanie kopii musi by zdefiniowane w specyfikacji jzyka bo "
"konstruktory mog mie skutki uboczne. W Rucie nie stanowi to problemu. "
"Je偶eli RVO nie byo zastosowane, to Rust u偶yje prostej i wydajnej kopii "
"`memcpy`.\n"
"```"

#: src/ownership/shared-unique-borrows.md:3
msgid "Rust puts constraints on the ways you can borrow values:"
msgstr "Rust narzuca ograniczenia na spos贸b w jaki mo偶na po偶ycza wartoci:"

#: src/ownership/shared-unique-borrows.md:5
msgid "You can have one or more `&T` values at any given time, _or_"
msgstr ""
"Mo偶esz mie jedno lub wicej po偶ycze wartoci `&T` w tym samym czasie, "
"_albo_"

#: src/ownership/shared-unique-borrows.md:6
msgid "You can have exactly one `&mut T` value."
msgstr "Mo偶esz mie dokadnie jedno po偶yczenie wartoci `&mut T`."

#: src/ownership/shared-unique-borrows.md:8
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let mut a: i32 = 10;\n"
"    let b: &i32 = &a;\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let mut a: i32 = 10;\n"
"    let b: &i32 = &a;\n"
"```"

#: src/ownership/shared-unique-borrows.md:13
msgid ""
"```\n"
"{\n"
"    let c: &mut i32 = &mut a;\n"
"    *c = 20;\n"
"}\n"
"```"
msgstr ""
"```\n"
"{\n"
"    let c: &mut i32 = &mut a;\n"
"    *c = 20;\n"
"}\n"
"```"

#: src/ownership/shared-unique-borrows.md:18 src/std/rc.md:13
msgid ""
"```\n"
"println!(\"a: {a}\");\n"
"println!(\"b: {b}\");\n"
"```"
msgstr ""
"```\n"
"println!(\"a: {a}\");\n"
"println!(\"b: {b}\");\n"
"```"

#: src/ownership/shared-unique-borrows.md:25
msgid ""
"The above code does not compile because `a` is borrowed as mutable (through "
"`c`) and as immutable (through `b`) at the same time."
msgstr ""
"Powy偶szy kod si nie kompiluje poniewa偶 `a` jest po偶yczone jako mutowalne "
"(przez `c`) i jako niemutowalne (przez `b`) w tym samym czasie."

#: src/ownership/shared-unique-borrows.md:26
msgid ""
"Move the `println!` statement for `b` before the scope that introduces `c` "
"to make the code compile."
msgstr ""
"Przenie instrukcj `println!` dla `b` przed zakres, kt贸ry wprowadza `c`, "
"偶eby kod si kompilowa."

#: src/ownership/shared-unique-borrows.md:27
msgid ""
"After that change, the compiler realizes that `b` is only ever used before "
"the new mutable borrow of `a` through `c`. This is a feature of the borrow "
"checker called \"non-lexical lifetimes\"."
msgstr ""
"Po zmianie, kompilator uwiadomi sobie, 偶e `b` jest tylko u偶ywane przed "
"mutowalnym po偶yczeniem `a` przez `c`. Ta funkcja nadzorcy po偶yczania nazywa "
"si \"nieleksykalne czasy 偶ycia\" (ang. _non-lexical lifetimes_)."

#: src/ownership/lifetimes.md:3
msgid "A borrowed value has a _lifetime_:"
msgstr "Po偶yczona warto ma _czas 偶ycia_:"

#: src/ownership/lifetimes.md:5
msgid "The lifetime can be elided: `add(p1: &Point, p2: &Point) -> Point`."
msgstr "Czas 偶ycia mo偶e by pominity: `add(p1: &Point, p2: &Point) -> Point`."

#: src/ownership/lifetimes.md:6
msgid "Lifetimes can also be explicit: `&'a Point`, `&'document str`."
msgstr "Czasy 偶ycia mog te偶 by jawne: `&'a Point`, `&'document str`."

#: src/ownership/lifetimes.md:7 src/ownership/lifetimes-function-calls.md:23
msgid ""
"Read `&'a Point` as \"a borrowed `Point` which is valid for at least the "
"lifetime `a`\"."
msgstr ""
"Czytaj `&'a Point` jako \"po偶yczony `Point` kt贸ry jest wa偶ny co najmniej w "
"czasie 偶ycia `a`\"."

#: src/ownership/lifetimes.md:9
msgid ""
"Lifetimes are always inferred by the compiler: you cannot assign a lifetime "
"yourself."
msgstr ""
"Czasy 偶ycia zawsze s wyliczane przez kompilator: nie mo偶na samemu przypisa "
"czasu 偶ycia."

#: src/ownership/lifetimes.md:11
msgid ""
"Lifetime annotations create constraints; the compiler verifies that there is "
"a valid solution."
msgstr ""
"Adnotacje czasu 偶ycia tworz ograniczenia; kompilator weryfikuje, 偶e "
"istnieje prawidowe rozwizanie."

#: src/ownership/lifetimes-function-calls.md:3
msgid ""
"In addition to borrowing its arguments, a function can return a borrowed "
"value:"
msgstr ""
"W dodatku do po偶yczania swoich argument贸w, funkcja mo偶e zwr贸ci po偶yczon "
"warto:"

#: src/ownership/lifetimes-function-calls.md:9
#: src/ownership/lifetimes-function-calls.md:36
msgid ""
"fn left_most\\<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point { if p1.0 \\< "
"p2.0 { p1 } else { p2 } }"
msgstr ""
"fn left_most\\<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point { if p1.0 \\< "
"p2.0 { p1 } else { p2 } }"

#: src/ownership/lifetimes-function-calls.md:13
msgid ""
"fn main() { let p1: Point = Point(10, 10); let p2: Point = Point(20, 20); "
"let p3: &Point = left_most(&p1, &p2); println!(\"left-most point: {:?}\", "
"p3); }"
msgstr ""
"fn main() { let p1: Point = Point(10, 10); let p2: Point = Point(20, 20); "
"let p3: &Point = left_most(&p1, &p2); println!(\"left-most point: {:?}\", "
"p3); }"

#: src/ownership/lifetimes-function-calls.md:21
msgid "`'a` is a generic parameter, it is inferred by the compiler."
msgstr "`'a` to parameter generyczny, jest wyliczany przez kompilator."

#: src/ownership/lifetimes-function-calls.md:22
msgid "Lifetimes start with `'` and `'a` is a typical default name."
msgstr "Czas 偶ycia zaczyna si `'` i `'a` to typowa domylna nazwa."

#: src/ownership/lifetimes-function-calls.md:25
msgid ""
"The _at least_ part is important when parameters are in different scopes."
msgstr "To _co najmniej_ jest wa偶ne je偶eli parametry s w r贸偶nych zakresach."

#: src/ownership/lifetimes-function-calls.md:31
msgid ""
"Move the declaration of `p2` and `p3` into a a new scope (`{ ... }`), "
"resulting in the following code:"
msgstr ""
"Przenie deklaracj `p2` i `p3` do nowego zakresu (`{ ... }`), powiniene "
"otrzyma poni偶szy kod:"

#: src/ownership/lifetimes-function-calls.md:32
msgid ""
"```rust,ignore\n"
"#[derive(Debug)]\n"
"struct Point(i32, i32);\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Debug)]\n"
"struct Point(i32, i32);\n"
"```"

#: src/ownership/lifetimes-function-calls.md:40
msgid ""
"fn main() { let p1: Point = Point(10, 10); let p3: &Point; { let p2: Point = "
"Point(20, 20); p3 = left_most(&p1, &p2); } println!(\"left-most point: "
"{:?}\", p3); }"
msgstr ""
"fn main() { let p1: Point = Point(10, 10); let p3: &Point; { let p2: Point = "
"Point(20, 20); p3 = left_most(&p1, &p2); } println!(\"left-most point: "
"{:?}\", p3); }"

#: src/ownership/lifetimes-function-calls.md:49
msgid ""
"```\n"
"Note how this does not compile since `p3` outlives `p2`.\n"
"```"
msgstr ""
"```\n"
"Zauwa偶, 偶e teraz kod si nie kompiluje bo `p3` prze偶ywa `p2`.\n"
"```"

#: src/ownership/lifetimes-function-calls.md:52
msgid ""
"Reset the workspace and change the function signature to `fn left_most<'a, "
"'b>(p1: &'a Point, p2: &'a Point) -> &'b Point`. This will not compile "
"because the relationship between the lifetimes `'a` and `'b` is unclear."
msgstr ""
"Zresetuj edytor i zmie sygnatur funkcji na `fn left_most<'a, 'b>(p1: &'a "
"Point, p2: &'a Point) -> &'b Point`. To si nie skompiluje bo zale偶no "
"pomidzy czasami 偶ycia `'a` i `'b` jest niejasna."

#: src/ownership/lifetimes-function-calls.md:53
msgid "Another way to explain it:"
msgstr "Inny spos贸b 偶eby to wytumaczy:"

#: src/ownership/lifetimes-function-calls.md:54
msgid ""
"Two references to two values are borrowed by a function and the function "
"returns another reference."
msgstr ""
"Dwie referencje do dw贸ch wartoci s po偶yczone przez funkcj i funkcja musi "
"zwr贸ci inn referencj."

#: src/ownership/lifetimes-function-calls.md:56
msgid ""
"It must have come from one of those two inputs (or from a global variable)."
msgstr ""
"Ta referencja musi pochodzi z jednego z dw贸ch wej(lub ze zmiennej "
"globalnej)."

#: src/ownership/lifetimes-function-calls.md:57
msgid ""
"Which one is it? The compiler needs to to know, so at the call site the "
"returned reference is not used for longer than a variable from where the "
"reference came from."
msgstr ""
"Kt贸ra to? Kompilator musi wiedzie, 偶eby w czasie wywoania zwracana "
"referencja nie jest u偶ywana du偶ej ni偶 zmienna z kt贸rej pochodzi ta "
"referencja."

#: src/ownership/lifetimes-data-structures.md:3
msgid ""
"If a data type stores borrowed data, it must be annotated with a lifetime:"
msgstr ""
"Je偶eli typ danych przechowuje po偶yczone dane, to musz one mie adnotcj "
"czasu 偶ycia:"

#: src/ownership/lifetimes-data-structures.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Highlight<'doc>(&'doc str);\n"
"```"
msgstr ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Highlight<'doc>(&'doc str);\n"
"```"

#: src/ownership/lifetimes-data-structures.md:9
msgid "fn erase(text: String) { println!(\"Bye {text}!\"); }"
msgstr "fn erase(text: String) { println!(\"Bye {text}!\"); }"

#: src/ownership/lifetimes-data-structures.md:13
msgid ""
"fn main() { let text = String::from(\"The quick brown fox jumps over the "
"lazy dog.\"); let fox = Highlight(&text\\[4..19\\]); let dog = "
"Highlight(&text\\[35..43\\]); // erase(text); println!(\"{fox:?}\"); println!"
"(\"{dog:?}\"); }"
msgstr ""
"fn main() { let text = String::from(\"The quick brown fox jumps over the "
"lazy dog.\"); let fox = Highlight(&text\\[4..19\\]); let dog = "
"Highlight(&text\\[35..43\\]); // erase(text); println!(\"{fox:?}\"); println!"
"(\"{dog:?}\"); }"

#: src/ownership/lifetimes-data-structures.md:21
msgid ""
"```\n"
"\n"
"# Lifetimes in Data Structures\n"
"\n"
"If a data type stores borrowed data, it must be annotated with a lifetime:\n"
"\n"
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Highlight<'doc>(&'doc str);\n"
"\n"
"fn erase(text: String) {\n"
"    println!(\"Bye {text}!\");\n"
"}\n"
"\n"
"<details>\n"
"\n"
"* In the above example, the annotation on `Highlight` enforces that the data "
"underlying the contained `&str` lives at least as long as any instance of "
"`Highlight` that uses that data.\n"
"* If `text` is consumed before the end of the lifetime of `fox` (or `dog`), "
"the borrow checker throws an error.\n"
"* Types with borrowed data force users to hold on to the original data. This "
"can be useful for creating lightweight views, but it generally makes them "
"somewhat harder to use.\n"
"* When possible, make data structures own their data directly.\n"
"* Some structs with multiple references inside can have more than one "
"lifetime annotation. This can be necessary if there is a need to describe "
"lifetime relationships between the references themselves, in addition to the "
"lifetime of the struct itself. Those are very advanced use cases.\n"
"</details>\n"
"\n"
"# Lifetimes in Data Structures\n"
"\n"
"If a data type stores borrowed data, it must be annotated with a lifetime:\n"
"\n"
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Highlight<'doc>(&'doc str);\n"
"\n"
"fn erase(text: String) {\n"
"    println!(\"Bye {text}!\");\n"
"}\n"
"\n"
"fn main() {\n"
"    let text = String::from(\"The quick brown fox jumps over the lazy dog."
"\");\n"
"    let fox = Highlight(&text[4..19]);\n"
"    let dog = Highlight(&text[35..43]);\n"
"    // erase(text);\n"
"    println!(\"{fox:?}\");\n"
"    println!(\"{dog:?}\");\n"
"}\n"
"```"
msgstr ""
"```\n"
"\n"
"# Czasy 偶ycia w strukturach danych\n"
"\n"
"Je偶eli typ danych przechowuje po偶yczone dane, to musz one mie adnotcj "
"czasu 偶ycia:\n"
"\n"
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Highlight<'doc>(&'doc str);\n"
"\n"
"fn erase(text: String) {\n"
"    println!(\"Bye {text}!\");\n"
"}\n"
"\n"
"<details>\n"
"\n"
"* W powy偶szym przykadzie, adnotacja na `Highlight` wymaga 偶eby dane w "
"zawartym `&str` 偶yy co najmniej tak dugo jak instancja `Highlight`, kt贸ra "
"u偶ywa tych danych.\n"
"* Je偶eli `text` jest skonsumowany przed kocem 偶ycia `fox` (lub `dog`), to "
"nadzorca po偶yczania poka偶e bd.\n"
"* Typy z po偶yczonymi danymi wymagaj od u偶ytkownik贸w utrzymywania "
"oryginalnych danych. Jest to przydatne przy tworzeniu lekkich widok贸w, ale "
"generalnie powoduje, 偶e s trudniejsze w u偶yciu.\n"
"* Je偶eli mo偶liwe tw贸rz struktury danych, kt贸re bezporednio s wacicielami "
"swoich danych.\n"
"* Niekt贸re struktury z wieloma referencjami mog mie wicej ni偶 jedn "
"adnotacj cyklu 偶ycia. To mo偶e by potrzebne je偶eli potrzebujesz opisa "
"relacj cyklu 偶ycia pomidzy referencjami w dodatku do cyklu 偶ycia samej "
"struktury. S to bardzo zaawansowane przypadki u偶ycia.\n"
"</details>\n"
"\n"
"# Lifetimes in Data Structures\n"
"\n"
"If a data type stores borrowed data, it must be annotated with a lifetime:\n"
"\n"
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Highlight<'doc>(&'doc str);\n"
"\n"
"fn erase(text: String) {\n"
"    println!(\"Bye {text}!\");\n"
"}\n"
"\n"
"fn main() {\n"
"    let text = String::from(\"The quick brown fox jumps over the lazy dog."
"\");\n"
"    let fox = Highlight(&text[4..19]);\n"
"    let dog = Highlight(&text[35..43]);\n"
"    // erase(text);\n"
"    println!(\"{fox:?}\");\n"
"    println!(\"{dog:?}\");\n"
"}\n"
"```"

#: src/ownership/lifetimes-data-structures.md:25
msgid ""
"In the above example, the annotation on `Highlight` enforces that the data "
"underlying the contained `&str` lives at least as long as any instance of "
"`Highlight` that uses that data."
msgstr ""
"W powy偶szym przykadzie, adnotacja na `Highlight` wymaga 偶eby dane w "
"zawartym `&str` 偶yy co najmniej tak dugo jak instancja `Highlight`, kt贸ra "
"u偶ywa tych danych."

#: src/ownership/lifetimes-data-structures.md:26
msgid ""
"If `text` is consumed before the end of the lifetime of `fox` (or `dog`), "
"the borrow checker throws an error."
msgstr ""
"Je偶eli `text` jest skonsumowany przed kocem 偶ycia `fox` (lub `dog`), to "
"nadzorca po偶yczania poka偶e bd."

#: src/ownership/lifetimes-data-structures.md:27
msgid ""
"Types with borrowed data force users to hold on to the original data. This "
"can be useful for creating lightweight views, but it generally makes them "
"somewhat harder to use."
msgstr ""
"Typy z po偶yczonymi danymi wymagaj od u偶ytkownik贸w utrzymywania oryginalnych "
"danych. Jest to przydatne przy tworzeniu lekkich widok贸w, ale generalnie "
"powoduje, 偶e s trudniejsze w u偶yciu."

#: src/ownership/lifetimes-data-structures.md:28
msgid "When possible, make data structures own their data directly."
msgstr ""
"Je偶eli mo偶liwe tw贸rz struktury danych, kt贸re bezporednio s wacicielami "
"swoich danych."

#: src/ownership/lifetimes-data-structures.md:29
msgid ""
"Some structs with multiple references inside can have more than one lifetime "
"annotation. This can be necessary if there is a need to describe lifetime "
"relationships between the references themselves, in addition to the lifetime "
"of the struct itself. Those are very advanced use cases."
msgstr ""
"Niekt贸re struktury z wieloma referencjami mog mie wicej ni偶 jedn "
"adnotacj cyklu 偶ycia. To mo偶e by potrzebne je偶eli potrzebujesz opisa "
"relacj cyklu 偶ycia pomidzy referencjami w dodatku do cyklu 偶ycia samej "
"struktury. S to bardzo zaawansowane przypadki u偶ycia."

#: src/exercises/day-1/afternoon.md:1
#, fuzzy
msgid "Day 1: Afternoon Exercises"
msgstr "Dzie 1: wiczenia popoudniowe"

#: src/exercises/day-1/afternoon.md:3
#, fuzzy
msgid "We will look at two things:"
msgstr "Przyjrzymy si dw贸m rzeczom:"

#: src/exercises/day-1/afternoon.md:5
#, fuzzy
msgid "A small book library,"
msgstr "Maa biblioteczka,"

#: src/exercises/day-1/afternoon.md:7
#, fuzzy
msgid "Iterators and ownership (hard)."
msgstr "Iteratory i wasno (trudne)."

#: src/exercises/day-1/book-library.md:3
#, fuzzy
msgid ""
"We will learn much more about structs and the `Vec<T>` type tomorrow. For "
"now, you just need to know part of its API:"
msgstr ""
"Jutro dowiemy si znacznie wicej o strukturach i typie `Vec<T>`. Na razie, "
"wystarczy zna cz jego API:"

#: src/exercises/day-1/book-library.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut vec = vec![10, 20];\n"
"    vec.push(30);\n"
"    println!(\"middle value: {}\", vec[vec.len() / 2]);\n"
"    for item in vec.iter() {\n"
"        println!(\"item: {item}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let mut vec = vec![10, 20];\n"
"    vec.push(30);\n"
"    println!(\"middle value: {}\", vec[vec.len() / 2]);\n"
"    for item in vec.iter() {\n"
"        println!(\"item: {item}\");\n"
"    }\n"
"}\n"
"```"

#: src/exercises/day-1/book-library.md:17
#, fuzzy
msgid ""
"Use this to create a library application. Copy the code below to <https://"
"play.rust-lang.org/> and update the types to make it compile:"
msgstr ""
"U偶yj tego, aby utworzy aplikacj biblioteczn. Skopiuj poni偶szy kod do "
"<https://play.rust-lang.org/> i zaktualizuj typy, aby skompilowa:"

#: src/exercises/day-1/book-library.md:24
msgid "struct Library { books: Vec"
msgstr "struct Library { books: Vec"

#: src/exercises/day-1/book-library.md:25
#: src/exercises/day-1/solutions-afternoon.md:24
#: src/exercises/day-2/solutions-morning.md:71
#: src/exercises/day-4/solutions-morning.md:35
msgid ", }"
msgstr ", }"

#: src/exercises/day-1/book-library.md:28
#: src/exercises/day-1/solutions-afternoon.md:27
msgid "struct Book { title: String, year: u16, }"
msgstr "struct Book { title: String, year: u16, }"

#: src/exercises/day-1/book-library.md:33
#: src/exercises/day-1/solutions-afternoon.md:32
msgid ""
"impl Book { // This is a constructor, used below. fn new(title: &str, year: "
"u16) -> Book { Book { title: String::from(title), year, } } }"
msgstr ""
"impl Book { // To jest konstruktor u偶ywany poni偶ej. fn new(title: &str, "
"year: u16) -> Book { Book { title: String::from(title), year, } } }"

#: src/exercises/day-1/book-library.md:43
msgid ""
"// This makes it possible to print Book values with {}. impl std::fmt::"
"Display for Book { fn fmt(&self, f: &mut std::fmt::Formatter\\<'\\_\\>) -> "
"std::fmt::Result { write!(f, \"{} ({})\", self.title, self.year) } }"
msgstr ""
"// Umo偶liwia to drukowanie wartoci Book za pomoc {}. impl std::fmt::"
"Display for Book { fn fmt(&self, f: &mut std::fmt::Formatter\\<'\\_\\>) -> "
"std::fmt::Result { write!(f, \"{} ({})\", self.title, self.year) } }"

#: src/exercises/day-1/book-library.md:50
msgid "impl Library { fn new() -> Library { unimplemented!() }"
msgstr "impl Library { fn new() -> Library { unimplemented!() }"

#: src/exercises/day-1/book-library.md:55
msgid ""
"```\n"
"//fn len(self) -> usize {\n"
"//    unimplemented!()\n"
"//}\n"
"```"
msgstr ""
"```\n"
"//fn len(self) -> usize {\n"
"//    unimplemented!()\n"
"//}\n"
"```"

#: src/exercises/day-1/book-library.md:59
msgid ""
"```\n"
"//fn is_empty(self) -> bool {\n"
"//    unimplemented!()\n"
"//}\n"
"```"
msgstr ""
"```\n"
"//fn is_empty(self) -> bool {\n"
"//    unimplemented!()\n"
"//}\n"
"```"

#: src/exercises/day-1/book-library.md:63
msgid ""
"```\n"
"//fn add_book(self, book: Book) {\n"
"//    unimplemented!()\n"
"//}\n"
"```"
msgstr ""
"```\n"
"//fn add_book(self, book: Book) {\n"
"//    unimplemented!()\n"
"//}\n"
"```"

#: src/exercises/day-1/book-library.md:67
msgid ""
"```\n"
"//fn print_books(self) {\n"
"//    unimplemented!()\n"
"//}\n"
"```"
msgstr ""
"```\n"
"//fn print_books(self) {\n"
"//    unimplemented!()\n"
"//}\n"
"```"

#: src/exercises/day-1/book-library.md:71
msgid ""
"```\n"
"//fn oldest_book(self) -> Option<&Book> {\n"
"//    unimplemented!()\n"
"//}\n"
"```"
msgstr ""
"```\n"
"//fn oldest_book(self) -> Option<&Book> {\n"
"//    unimplemented!()\n"
"//}\n"
"```"

#: src/exercises/day-1/book-library.md:76
msgid ""
"// This shows the desired behavior. Uncomment the code below and // "
"implement the missing methods. You will need to update the // method "
"signatures, including the \"self\" parameter! You may // also need to update "
"the variable bindings within main. fn main() { let library = Library::new();"
msgstr ""

#: src/exercises/day-1/book-library.md:83
#: src/exercises/day-1/solutions-afternoon.md:113
msgid ""
"```\n"
"//println!(\"Our library is empty: {}\", library.is_empty());\n"
"//\n"
"//library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"//library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"//\n"
"//library.print_books();\n"
"//\n"
"//match library.oldest_book() {\n"
"//    Some(book) => println!(\"My oldest book is {book}\"),\n"
"//    None => println!(\"My library is empty!\"),\n"
"//}\n"
"//\n"
"//println!(\"Our library has {} books\", library.len());\n"
"```"
msgstr ""

#: src/exercises/day-1/book-library.md:101
msgid "[Solution](solutions-afternoon.md#designing-a-library)"
msgstr "[Rozwizanie](solutions-afternoon.md#designing-a-library)"

#: src/exercises/day-1/iterators-and-ownership.md:3
#, fuzzy
msgid ""
"The ownership model of Rust affects many APIs. An example of this is the "
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) and "
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html) "
"traits."
msgstr ""
"Model wasnoci Rust wpywa na wiele interfejs贸w API. Przykadem tego jest "
"tzw [`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) i "
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html) "
"cechy."

#: src/exercises/day-1/iterators-and-ownership.md:8
msgid "`Iterator`"
msgstr "`Iterator`"

#: src/exercises/day-1/iterators-and-ownership.md:10
#, fuzzy
msgid ""
"Traits are like interfaces: they describe behavior (methods) for a type. The "
"`Iterator` trait simply says that you can call `next` until you get `None` "
"back:"
msgstr ""
"Cechy s jak interfejsy: opisuj zachowanie (metody) dla typu. The Cecha "
"`Iterator` m贸wi po prostu, 偶e mo偶esz wywoywa `next`, dop贸ki nie otrzymasz "
"z powrotem `None`:"

#: src/exercises/day-1/iterators-and-ownership.md:13
msgid ""
"```rust\n"
"pub trait Iterator {\n"
"    type Item;\n"
"    fn next(&mut self) -> Option<Self::Item>;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"pub trait Iterator {\n"
"    type Item;\n"
"    fn next(&mut self) -> Option<Self::Item>;\n"
"}\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:20
#, fuzzy
msgid "You use this trait like this:"
msgstr "U偶ywasz tej cechy w ten spos贸b:"

#: src/exercises/day-1/iterators-and-ownership.md:22
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:27
msgid ""
"```\n"
"println!(\"v[0]: {:?}\", iter.next());\n"
"println!(\"v[1]: {:?}\", iter.next());\n"
"println!(\"v[2]: {:?}\", iter.next());\n"
"println!(\"No more items: {:?}\", iter.next());\n"
"```"
msgstr ""
"```\n"
"println!(\"v[0]: {:?}\", iter.next());\n"
"println!(\"v[1]: {:?}\", iter.next());\n"
"println!(\"v[2]: {:?}\", iter.next());\n"
"println!(\"Nie ma wicej element贸w: {:?}\", iter.next());\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:34
#, fuzzy
msgid "What is the type returned by the iterator? Test your answer here:"
msgstr "Jaki typ zwraca iterator? Sprawd藕 swoj odpowied藕 tutaj:"

#: src/exercises/day-1/iterators-and-ownership.md:36
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:41
#: src/exercises/day-1/iterators-and-ownership.md:78
msgid ""
"```\n"
"let v0: Option<..> = iter.next();\n"
"println!(\"v0: {v0:?}\");\n"
"```"
msgstr ""
"```\n"
"let v0: Option<..> = iter.next();\n"
"println!(\"v0: {v0:?}\");\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:46
#, fuzzy
msgid "Why is this type used?"
msgstr "Dlaczego ten typ jest u偶ywany?"

#: src/exercises/day-1/iterators-and-ownership.md:48
msgid "`IntoIterator`"
msgstr "`IntoIterator`"

#: src/exercises/day-1/iterators-and-ownership.md:50
#, fuzzy
msgid ""
"The `Iterator` trait tells you how to _iterate_ once you have created an "
"iterator. The related trait `IntoIterator` tells you how to create the "
"iterator:"
msgstr ""
"Cecha `Iterator` m贸wi ci, jak _iterowa_ po utworzeniu iterator. Powizana "
"cecha `IntoIterator` m贸wi ci, jak stworzy iterator:"

#: src/exercises/day-1/iterators-and-ownership.md:53
msgid ""
"```rust\n"
"pub trait IntoIterator {\n"
"    type Item;\n"
"    type IntoIter: Iterator<Item = Self::Item>;\n"
"```"
msgstr ""
"```rust\n"
"pub trait IntoIterator {\n"
"    type Item;\n"
"    type IntoIter: Iterator<Item = Self::Item>;\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:58
msgid ""
"```\n"
"fn into_iter(self) -> Self::IntoIter;\n"
"```"
msgstr ""
"```\n"
"fn into_iter(self) -> Self::IntoIter;\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:62
#, fuzzy
msgid ""
"The syntax here means that every implementation of `IntoIterator` must "
"declare two types:"
msgstr ""
"Skadnia tutaj oznacza, 偶e ka偶da implementacja `IntoIterator` musi "
"zadeklarowa dwa typy:"

#: src/exercises/day-1/iterators-and-ownership.md:65
#, fuzzy
msgid "`Item`: the type we iterate over, such as `i8`,"
msgstr "`Item`: typ, kt贸ry iterujemy, na przykad `i8`,"

#: src/exercises/day-1/iterators-and-ownership.md:66
#, fuzzy
msgid "`IntoIter`: the `Iterator` type returned by the `into_iter` method."
msgstr "`IntoIter`: typ `Iterator` zwracany przez metod `into_iter`."

#: src/exercises/day-1/iterators-and-ownership.md:68
#, fuzzy
msgid ""
"Note that `IntoIter` and `Item` are linked: the iterator must have the same "
"`Item` type, which means that it returns `Option<Item>`"
msgstr ""
"Zauwa偶, 偶e `IntoIter` i `Item` s poczone: iterator musi mie to samo Typ "
"`Item`, co oznacza, 偶e zwraca `Option<Item>`"

#: src/exercises/day-1/iterators-and-ownership.md:71
#, fuzzy
msgid "Like before, what  is the type returned by the iterator?"
msgstr "Tak jak poprzednio, jaki typ jest zwracany przez iterator?"

#: src/exercises/day-1/iterators-and-ownership.md:73
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::"
"from(\"bar\")];\n"
"    let mut iter = v.into_iter();\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::"
"from(\"bar\")];\n"
"    let mut iter = v.into_iter();\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:83
msgid "`for` Loops"
msgstr "Ptle `for`"

#: src/exercises/day-1/iterators-and-ownership.md:85
#, fuzzy
msgid ""
"Now that we know both `Iterator` and `IntoIterator`, we can build `for` "
"loops. They call `into_iter()` on an expression and iterates over the "
"resulting iterator:"
msgstr ""
"Teraz, gdy znamy zar贸wno `Iterator`, jak i `IntoIterator`, mo偶emy budowa "
"ptle `for`. Wywouj `into_iter()` na wyra偶eniu i iteruj wynik iterator:"

#: src/exercises/day-1/iterators-and-ownership.md:89
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::"
"from(\"bar\")];\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::"
"from(\"bar\")];\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:93
msgid ""
"```\n"
"for word in &v {\n"
"    println!(\"word: {word}\");\n"
"}\n"
"```"
msgstr ""
"```\n"
"for word in &v {\n"
"    println!(\"word: {word}\");\n"
"}\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:97
msgid ""
"```\n"
"for word in v {\n"
"    println!(\"word: {word}\");\n"
"}\n"
"```"
msgstr ""
"```\n"
"for word in v {\n"
"    println!(\"word: {word}\");\n"
"}\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:103
#, fuzzy
msgid "What is the type of `word` in each loop?"
msgstr "Jaki jest typ sowa w ka偶dej ptli?"

#: src/exercises/day-1/iterators-and-ownership.md:105
#, fuzzy
msgid ""
"Experiment with the code above and then consult the documentation for [`impl "
"IntoIterator for &Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec."
"html#impl-IntoIterator-for-%26%27a%20Vec%3CT%2C%20A%3E) and [`impl "
"IntoIterator for Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec."
"html#impl-IntoIterator-for-Vec%3CT%2C%20A%3E) to check your answers."
msgstr ""
"Eksperymentuj z powy偶szym kodem, a nastpnie zapoznaj si z dokumentacj dla "
"[`impl IntoIterator dla &Vec<T>`](https://doc.rust-lang.org/std/vec/struct."
"Vec.html#impl-IntoIterator-for-%26%27a%20Vec%3CT%2C%20A%3E) i [`impl "
"IntoIterator dla Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec."
"html#impl-IntoIterator-for-Vec%3CT%2C%20A%3E) aby sprawdzi swoje odpowiedzi."

#: src/welcome-day-2.md:1
msgid "Welcome to Day 2"
msgstr "Witamy w dniu 2"

#: src/welcome-day-2.md:3
#, fuzzy
msgid "Now that we have seen a fair amount of Rust, we will continue with:"
msgstr "Teraz, gdy widzielimy ju偶 sporo Rust, bdziemy kontynuowa:"

#: src/welcome-day-2.md:5
#, fuzzy
msgid "Structs, enums, methods."
msgstr "Struktury, wyliczenia, metody."

#: src/welcome-day-2.md:7
#, fuzzy
msgid "Pattern matching: destructuring enums, structs, and arrays."
msgstr "Dopasowywanie wzorc贸w: destrukturyzacja wylicze, struktur i tablic."

#: src/welcome-day-2.md:9
#, fuzzy
msgid ""
"Control flow constructs: `if`, `if let`, `while`, `while let`, `break`, and "
"`continue`."
msgstr ""
"Konstrukcje przepywu sterowania: `if`, `if let`, `while`, `while let`, "
"`break` i `kontynuuj`."

#: src/welcome-day-2.md:12
#, fuzzy
msgid ""
"The Standard Library: `String`, `Option` and `Result`, `Vec`, `HashMap`, "
"`Rc` and `Arc`."
msgstr ""
"Biblioteka standardowa: `String`, `Option` i `Result`, `Vec`, `HashMap`, "
"`Rc` i `uk`."

#: src/welcome-day-2.md:15
#, fuzzy
msgid "Modules: visibility, paths, and filesystem hierarchy."
msgstr "Moduy: widoczno, cie偶ki i hierarchia system贸w plik贸w."

#: src/structs.md:3
#, fuzzy
msgid "Like C and C++, Rust has support for custom structs:"
msgstr "Podobnie jak C i C++, Rust obsuguje niestandardowe struktury:"

#: src/structs.md:5
msgid ""
"```rust,editable\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"```"

#: src/structs.md:11
msgid ""
"fn main() { let mut peter = Person { name: String::from(\"Peter\"), age: "
"27, }; println!(\"{} is {} years old\", peter.name, peter.age);"
msgstr ""
"fn main() { let mut peter = Person { name: String::from(\"Peter\"), age: "
"27, }; println!(\"{} ma {} lat\", peter.name, peter.age);"

#: src/structs.md:18
msgid ""
"```\n"
"peter.age = 28;\n"
"println!(\"{} is {} years old\", peter.name, peter.age);\n"
"\n"
"let jackie = Person {\n"
"    name: String::from(\"Jackie\"),\n"
"    ..peter\n"
"};\n"
"println!(\"{} is {} years old\", jackie.name, jackie.age);\n"
"```"
msgstr ""
"```\n"
"peter.age = 28;\n"
"println!(\"{} ma {} lat\", peter.name, peter.age);\n"
"\n"
"let jackie = Person {\n"
"    name: String::from(\"Jackie\"),\n"
"    ..peter\n"
"};\n"
"println!(\"{} ma {} lat\", jackie.name, jackie.age);\n"
"```"

#: src/structs.md:32
msgid "Structs work like in C or C++."
msgstr ""

#: src/structs.md:33
msgid "Like in C++, and unlike in C, no typedef is needed to define a type."
msgstr ""

#: src/structs.md:34
msgid "Unlike in C++, there is no inheritance between structs."
msgstr ""

#: src/structs.md:35
msgid ""
"Methods are defined in an `impl` block, which we will see in following "
"slides."
msgstr ""

#: src/structs.md:36
msgid ""
"This may be a good time to let people know there are different types of "
"structs. "
msgstr ""

#: src/structs.md:37
msgid ""
"Zero-sized structs `e.g., struct Foo;` might be used when implementing a "
"trait on some type but dont have any data that you want to store in the "
"value itself. "
msgstr ""

#: src/structs.md:38
msgid ""
"The next slide will introduce Tuple structs, used when the field names are "
"not important."
msgstr ""

#: src/structs.md:39
msgid ""
"The syntax `..peter` allows us to copy the majority of the fields from the "
"old struct without having to explicitly type it all out. It must always be "
"the last element."
msgstr ""

#: src/structs/tuple-structs.md:3
#, fuzzy
msgid "If the field names are unimportant, you can use a tuple struct:"
msgstr "Jeli nazwy p贸l s nieistotne, mo偶esz u偶y struktury krotki:"

#: src/structs/tuple-structs.md:5
msgid ""
"```rust,editable\n"
"struct Point(i32, i32);\n"
"```"
msgstr ""
"```rust,editable\n"
"struct Point(i32, i32);\n"
"```"

#: src/structs/tuple-structs.md:8
msgid "fn main() { let p = Point(17, 23); println!(\"({}, {})\", p.0, p.1); }"
msgstr "fn main() { let p = Point(17, 23); println!(\"({}, {})\", p.0, p.1); }"

#: src/structs/tuple-structs.md:14
#, fuzzy
msgid "This is often used for single-field wrappers (called newtypes):"
msgstr ""
"Jest to czsto u偶ywane w przypadku opakowa z jednym polem (zwanych "
"newtypes):"

#: src/structs/tuple-structs.md:16
msgid ""
"```rust,editable,compile_fail\n"
"struct PoundOfForce(f64);\n"
"struct Newtons(f64);\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"struct PoundOfForce(f64);\n"
"struct Newtons(f64);\n"
"```"

#: src/structs/tuple-structs.md:20
msgid ""
"fn compute_thruster_force() -> PoundOfForce { todo!(\"Ask a rocket scientist "
"at NASA\") }"
msgstr ""
"fn compute_thruster_force() -> PoundOfForce { todo!(\"Zapytaj naukowca "
"rakietowego z NASA\") }"

#: src/structs/tuple-structs.md:24
msgid "fn set_thruster_force(force: Newtons) { // ... }"
msgstr "fn set_thruster_force(force: Newtons) { // ... }"

#: src/structs/tuple-structs.md:28
msgid ""
"fn main() { let force = compute_thruster_force(); "
"set_thruster_force(force); }"
msgstr ""
"fn main() { let force = compute_thruster_force(); "
"set_thruster_force(force); }"

#: src/structs/tuple-structs.md:37
#, fuzzy
msgid ""
"Newtypes are a great way to encode additional information about the value in "
"a primitive type, for example:"
msgstr ""
"Nowe typy to wietny spos贸b na zakodowanie dodatkowych informacji o wartoci "
"w typie pierwotnym, na przykad:"

#: src/structs/tuple-structs.md:38
#, fuzzy
msgid "The number is measured in some units: `Newtons` in the example above."
msgstr ""
"Liczba jest mierzona w niekt贸rych jednostkach: Newtons w powy偶szym "
"przykadzie."

#: src/structs/tuple-structs.md:39
#, fuzzy
msgid ""
"The value passed some validation when it was created, so you no longer have "
"to validate it again at every use: 'PhoneNumber(String)`or`OddNumber(u32)\\`."
msgstr ""
"Warto przesza walidacj podczas tworzenia, wic nie musisz ju偶 "
"weryfikowa jej ponownie przy ka偶dym u偶yciu: PhoneNumber(String) lub "
"OddNumber(u32)."

#: src/structs/tuple-structs.md:40
#, fuzzy
msgid ""
"Demonstrate how to add a `f64` value to a `Newtons` type by accessing the "
"single field in the newtype."
msgstr ""
"Zademonstruj, jak doda warto `f64` do typu `Newtons`, uzyskujc dostp do "
"pojedynczego pola w newtype."

#: src/structs/tuple-structs.md:41
#, fuzzy
msgid ""
"Rust generally doesnt like inexplicit things, like automatic unwrapping or "
"for instance using booleans as integers."
msgstr ""
"Rust generalnie nie lubi niejasnych rzeczy, takich jak automatyczne "
"rozpakowywanie lub na przykad u偶ywanie wartoci boolowskich jako liczb "
"cakowitych."

#: src/structs/tuple-structs.md:42
#, fuzzy
msgid "Operator overloading is discussed on Day 3 (generics). "
msgstr "Przeci偶enie operatora jest om贸wione w dniu 3 (leki generyczne)."

#: src/structs/field-shorthand.md:3
#, fuzzy
msgid ""
"If you already have variables with the right names, then you can create the "
"struct using a shorthand:"
msgstr ""
"Jeli masz ju偶 zmienne o odpowiednich nazwach, mo偶esz je utworzy struct za "
"pomoc skr贸tu:"

#: src/structs/field-shorthand.md:6 src/methods.md:6
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"```"

#: src/structs/field-shorthand.md:13
msgid ""
"impl Person { fn new(name: String, age: u8) -> Person { Person { name, "
"age } } }"
msgstr ""
"impl Person { fn new(name: String, age: u8) -> Person { Person { name, "
"age } } }"

#: src/structs/field-shorthand.md:19
msgid ""
"fn main() { let peter = Person::new(String::from(\"Peter\"), 27); println!"
"(\"{peter:?}\"); }"
msgstr ""
"fn main() { let peter = Person::new(String::from(\"Peter\"), 27); println!"
"(\"{peter:?}\"); }"

#: src/structs/field-shorthand.md:27
#, fuzzy
msgid ""
"The `new` function could be written using `Self` as a type, as it is "
"interchangeable with the struct type name"
msgstr ""
"Funkcja `new` mo偶e by napisana przy u偶yciu `Self` jako typu, poniewa偶 jest "
"wymienna z nazw typu struct"

#: src/structs/field-shorthand.md:29
msgid ""
"```rust,ignore\n"
"impl Person {\n"
"    fn new(name: String, age: u8) -> Self {\n"
"        Self { name, age }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"impl Person {\n"
"    fn new(name: String, age: u8) -> Self {\n"
"        Self { name, age }\n"
"    }\n"
"}\n"
"```"

#: src/structs/field-shorthand.md:37
#, fuzzy
msgid "Methods are defined in the `impl` block."
msgstr "Metody s zdefiniowane w bloku `impl`."

#: src/structs/field-shorthand.md:38
#, fuzzy
msgid ""
"Use struct update syntax to define a new structure using `peter`. Note that "
"the variable `peter` will no longer be accessible afterwards."
msgstr ""
"U偶yj skadni aktualizacji struktury, aby zdefiniowa now struktur za "
"pomoc `peter`. Zauwa偶, 偶e p贸藕niej zmienna `peter` nie bdzie ju偶 dostpna."

#: src/structs/field-shorthand.md:39
#, fuzzy
msgid ""
"Use `{:#?}` when printing structs to request the `Debug` representation."
msgstr ""
"U偶yj `{:#?}` podczas drukowania struktur, aby za偶da reprezentacji `Debug`."

#: src/enums.md:3
#, fuzzy
msgid ""
"The `enum` keyword allows the creation of a type which has a few different "
"variants:"
msgstr ""
"Sowo kluczowe `enum` pozwala na utworzenie typu, kt贸ry ma kilka r贸偶ne "
"warianty:"

#: src/enums.md:6
msgid ""
"```rust,editable\n"
"fn generate_random_number() -> i32 {\n"
"    4  // Chosen by fair dice roll. Guaranteed to be random.\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn generate_random_number() -> i32 {\n"
"    4  // Wyznaczone rzutem koci. Gwarantowana losowo.\n"
"}\n"
"```"

#: src/enums.md:11
msgid "\\#\\[derive(Debug)\\] enum CoinFlip { Heads, Tails, }"
msgstr "\\#\\[derive(Debug)\\] enum CoinFlip { Heads, Tails, }"

#: src/enums.md:17
msgid ""
"fn flip_coin() -> CoinFlip { let random_number = generate_random_number(); "
"if random_number % 2 == 0 { return CoinFlip::Heads; } else { return "
"CoinFlip::Tails; } }"
msgstr ""
"fn flip_coin() -> CoinFlip { let random_number = generate_random_number(); "
"if random_number % 2 == 0 { return CoinFlip::Heads; } else { return "
"CoinFlip::Tails; } }"

#: src/enums.md:26
msgid "fn main() { println!(\"You got: {:?}\", flip_coin()); }"
msgstr "fn main() { println!(\"Wynik: {:?}\", flip_coin()); }"

#: src/enums.md:33 src/methods.md:30 src/methods/example.md:46
#: src/pattern-matching.md:25 src/pattern-matching/match-guards.md:22
#: src/control-flow/blocks.md:42
#, fuzzy
msgid "Key Points:"
msgstr "Kluczowe punkty:"

#: src/enums.md:35
#, fuzzy
msgid "Enumerations allow you to collect a set of values under one type"
msgstr "Wyliczenia umo偶liwiaj zebranie zestawu wartoci w ramach jednego typu"

#: src/enums.md:36
#, fuzzy
msgid ""
"This page offers an enum type `CoinFlip` with two variants `Heads` and "
"`Tail`. You might note the namespace when using variants."
msgstr ""
"Ta strona oferuje typ wyliczeniowy `CoinFlip` z dwoma wariantami `Heads` i "
"`Tail`. Podczas u偶ywania wariant贸w mo偶esz zwr贸ci uwag na przestrze nazw."

#: src/enums.md:37
#, fuzzy
msgid "This might be a good time to compare Structs and Enums:"
msgstr "To mo偶e by dobry moment na por贸wnanie Structs i Enums:"

#: src/enums.md:38
#, fuzzy
msgid ""
"In both, you can have a simple version without fields (unit struct) or one "
"with different types of fields (variant payloads). "
msgstr ""
"W obu przypadkach mo偶esz mie prost wersj bez p贸l (struktura jednostek) "
"lub wersj z r贸偶nymi typami p贸l (wariantowe adunki)."

#: src/enums.md:39
#, fuzzy
msgid "In both, associated functions are defined within an `impl` block."
msgstr "W obu przypadkach powizane funkcje s zdefiniowane w bloku `impl`."

#: src/enums.md:40
#, fuzzy
msgid ""
"You could even implement the different variants of an enum with separate "
"structs but then they wouldnt be the same type as they would if they were "
"all defined in an enum. "
msgstr ""
"Mo偶na nawet zaimplementowa r贸偶ne warianty wyliczenia z osobnymi "
"strukturami, ale wtedy nie byyby one tego samego typu, co gdyby wszystkie "
"byy zdefiniowane w wyliczeniu."

#: src/enums/variant-payloads.md:3
#, fuzzy
msgid ""
"You can define richer enums where the variants carry data. You can then use "
"the `match` statement to extract the data from each variant:"
msgstr ""
"Mo偶esz zdefiniowa bogatsze wyliczenia, w kt贸rych warianty zawieraj dane. "
"Mo偶esz wtedy u偶y tzw Instrukcja `match` w celu wyodrbnienia danych z "
"ka偶dego wariantu:"

#: src/enums/variant-payloads.md:6
msgid ""
"```rust,editable\n"
"enum WebEvent {\n"
"    PageLoad,                 // Variant without payload\n"
"    KeyPress(char),           // Tuple struct variant\n"
"    Click { x: i64, y: i64 }, // Full struct variant\n"
"}\n"
"```"
msgstr ""

#: src/enums/variant-payloads.md:13
msgid ""
"\\#\\[rustfmt::skip\\] fn inspect(event: WebEvent) { match event { WebEvent::"
"PageLoad       => println!(\"page loaded\"), WebEvent::KeyPress(c)    => "
"println!(\"pressed '{c}'\"), WebEvent::Click { x, y } => println!(\"clicked "
"at x={x}, y={y}\"), } }"
msgstr ""
"\\#\\[rustfmt::skip\\] fn inspect(event: WebEvent) { match event { WebEvent::"
"PageLoad       => println!(\"strona zaadowana\"), WebEvent::KeyPress(c)    "
"=> println!(\"przycinito '{c}'\"), WebEvent::Click { x, y } => println!"
"(\"kliknito w x={x}, y={y}\"), } }"

#: src/enums/variant-payloads.md:22
msgid ""
"fn main() { let load = WebEvent::PageLoad; let press = WebEvent::"
"KeyPress('x'); let click = WebEvent::Click { x: 20, y: 80 };"
msgstr ""
"fn main() { let load = WebEvent::PageLoad; let press = WebEvent::"
"KeyPress('x'); let click = WebEvent::Click { x: 20, y: 80 };"

#: src/enums/variant-payloads.md:27
msgid ""
"```\n"
"inspect(load);\n"
"inspect(press);\n"
"inspect(click);\n"
"```"
msgstr ""
"```\n"
"inspect(load);\n"
"inspect(press);\n"
"inspect(click);\n"
"```"

#: src/enums/variant-payloads.md:35
#, fuzzy
msgid ""
"The values in the enum variants can only be accessed after being pattern "
"matched. The pattern binds references to the fields in the \"match arm\" "
"after the `=>`."
msgstr ""
"Dostp do wartoci w wariantach enum mo偶na uzyska dopiero po dopasowaniu do "
"wzorca. Wzorzec wi偶e odniesienia do p贸l w rami dopasowania po `=>`."

#: src/enums/variant-payloads.md:36
#, fuzzy
msgid ""
"The expressions is matched against the patterns from top to bottom. There is "
"no fall-through like in C or C++."
msgstr ""
"Wyra偶enia s dopasowywane do wzorc贸w od g贸ry do dou. Nie ma spadku, jak w C "
"lub C++."

#: src/enums/variant-payloads.md:37
#, fuzzy
msgid ""
"The match expression has a value. The value is the last expression in the "
"match arm which was executed."
msgstr ""
"Wyra偶enie dopasowania ma warto. Warto to ostatnie wyra偶enie w ramieniu "
"dopasowania, kt贸re zostao wykonane."

#: src/enums/variant-payloads.md:38
#, fuzzy
msgid ""
"Starting from the top we look for what pattern matches the value then run "
"the code following the arrow. Once we find a match, we stop. "
msgstr ""
"Zaczynajc od g贸ry, szukamy wzoru pasujcego do wartoci, a nastpnie "
"uruchamiamy kod pod偶ajcy za strzak. Gdy znajdziemy dopasowanie, "
"zatrzymujemy si."

#: src/enums/variant-payloads.md:39
#, fuzzy
msgid ""
"Demonstrate what happens when the search is inexhaustive. Note the advantage "
"the Rust compiler provides by confirming when all cases are handled. "
msgstr ""
"Zademonstruj, co si dzieje, gdy wyszukiwanie jest niewyczerpujce. Zwr贸 "
"uwag na zalety kompilatora Rusta, kt贸ry potwierdza, kiedy wszystkie "
"przypadki s obsugiwane."

#: src/enums/variant-payloads.md:40
#, fuzzy
msgid "`match` inspects a hidden discriminant field in the `enum`."
msgstr "`match` sprawdza ukryte pole dyskryminujce w `enum`."

#: src/enums/variant-payloads.md:41
#, fuzzy
msgid ""
"It is possible to retrieve the discriminant by calling `std::mem::"
"discriminant()`"
msgstr ""
"Mo偶liwe jest odzyskanie wyr贸偶nika przez wywoanie `std::mem::discriminant()`"

#: src/enums/variant-payloads.md:42
#, fuzzy
msgid ""
"This is useful, for example, if implementing `PartialEq` for structs where "
"comparing field values doesn't affect equality."
msgstr ""
"Jest to przydatne na przykad przy implementacji `PartialEq` dla struktur, w "
"kt贸rych por贸wnywanie wartoci p贸l nie wpywa na r贸wno."

#: src/enums/variant-payloads.md:43
#, fuzzy
msgid ""
"`WebEvent::Click { ... }` is not exactly the same as `WebEvent::"
"Click(Click)` with a top level `struct Click { ... }`. The inlined version "
"cannot implement traits, for example."
msgstr ""
"`WebEvent::Click { ... }` nie jest dokadnie tym samym co `WebEvent::"
"Click(Click)` z najwy偶szym poziomem `struct Click { ... }`. Wbudowana wersja "
"nie mo偶e na przykad implementowa cech."

#: src/enums/sizes.md:3
#, fuzzy
msgid ""
"Rust enums are packed tightly, taking constraints due to alignment into "
"account:"
msgstr ""
"Wyliczenia Rust s ciasno upakowane, biorc pod uwag ograniczenia "
"wynikajce z wyr贸wnania:"

#: src/enums/sizes.md:5
msgid ""
"```rust,editable\n"
"use std::mem::{align_of, size_of};\n"
"```"
msgstr ""
"```rust,editable\n"
"use std::mem::{align_of, size_of};\n"
"```"

#: src/enums/sizes.md:8
msgid ""
"macro_rules! dbg_size { ($t:ty) => { println!(\"{}: size {} bytes, align: {} "
"bytes\", stringify!($t), size_of::\\<$t>(), align_of::\\<$t>()); }; }"
msgstr ""
"macro_rules! dbg_size { ($t:ty) => { println!(\"{}: rozmiar {} bajt贸w, "
"wyr贸wnanie: {} bytes\", stringify!($t), size_of::\\<$t>(), align_of::"
"\\<$t>()); }; }"

#: src/enums/sizes.md:15
msgid "enum Foo { A, B, }"
msgstr "enum Foo { A, B, }"

#: src/enums/sizes.md:20
msgid "\\#\\[repr(u32)\\] enum Bar { A,  // 0 B = 10000, C,  // 10001 }"
msgstr "\\#\\[repr(u32)\\] enum Bar { A,  // 0 B = 10000, C,  // 10001 }"

#: src/enums/sizes.md:27
msgid ""
"fn main() { dbg_size!(Foo); dbg_size!(Bar); dbg_size!(bool); dbg_size!(Option"
msgstr ""
"fn main() { dbg_size!(Foo); dbg_size!(Bar); dbg_size!(bool); dbg_size!(Option"

#: src/enums/sizes.md:31
msgid "); dbg_size!(&i32); dbg_size!(Option\\<&i32>); }"
msgstr "); dbg_size!(&i32); dbg_size!(Option\\<&i32>); }"

#: src/enums/sizes.md:37
#, fuzzy
msgid ""
"See the [Rust Reference](https://doc.rust-lang.org/reference/type-layout."
"html)."
msgstr ""
"Zobacz [Odniesienie do Rust](https://doc.rust-lang.org/reference/type-layout."
"html)."

#: src/enums/sizes.md:41
#, fuzzy
msgid "Key Points: "
msgstr "Kluczowe punkty:"

#: src/enums/sizes.md:42
#, fuzzy
msgid ""
"Internally Rust is using a field (discriminant) to keep track of the enum "
"variant."
msgstr ""
"Wewntrznie Rust u偶ywa pola (dyskryminacyjnego) do ledzenia wariantu enum."

#: src/enums/sizes.md:43
#, fuzzy
msgid ""
"`Bar` enum demonstrates that there is a way to control the discriminant "
"value and type. If `repr` is removed, the discriminant type takes 2 bytes, "
"becuase 10001 fits 2 bytes."
msgstr ""
"Wyliczenie `Bar` pokazuje, 偶e istnieje spos贸b kontrolowania wartoci i typu "
"wyr贸偶nika. Jeli usunie si `repr`, typ dyskryminacyjny zajmuje 2 bajty, "
"poniewa偶 10001 mieci 2 bajty."

#: src/enums/sizes.md:44
#, fuzzy
msgid ""
"As a niche optimization an enum discriminant is merged with the pointer so "
"that `Option<&Foo>` is the same size as `&Foo`."
msgstr ""
"Jako optymalizacja niszowa dyskryminator wyliczeniowy jest czony ze "
"wska藕nikiem, dziki czemu `Option<&Foo>` ma taki sam rozmiar jak `&Foo`."

#: src/enums/sizes.md:45
#, fuzzy
msgid "`Option<bool>` is another example of tight packing."
msgstr "`Option<bool>` to kolejny przykad ciasnego upakowania."

#: src/enums/sizes.md:46
#, fuzzy
msgid ""
"For [some types](https://doc.rust-lang.org/std/option/#representation), Rust "
"guarantees that `size_of::<T>()` equals `size_of::<Option<T>>()`."
msgstr ""
"Dla [niekt贸rych typ贸w](https://doc.rust-lang.org/std/option/"
"#representation), Rust gwarantuje, 偶e `size_of::<T>()` r贸wna si `size_of::"
"<Option<T> >()`."

#: src/enums/sizes.md:47
#, fuzzy
msgid ""
"Zero-sized types allow for efficient implementation of `HashSet` using "
"`HashMap` with `()` as the value."
msgstr ""
"Typy o zerowym rozmiarze pozwalaj na wydajn implementacj `HashSet` przy "
"u偶yciu `HashMap` z `()` jako wartoci."

#: src/enums/sizes.md:49
#, fuzzy
msgid ""
"Example code if you want to show how the bitwise representation _may_ look "
"like in practice. It's important to note that the compiler provides no "
"guarantees regarding this representation, therefore this is totally unsafe."
msgstr ""
"Przykadowy kod, jeli chcesz pokaza, jak reprezentacja bitowa _mo偶e_ "
"wyglda w praktyce. Nale偶y zauwa偶y, 偶e kompilator nie zapewnia 偶adnych "
"gwarancji dotyczcych tej reprezentacji, dlatego jest to cakowicie "
"niebezpieczne."

#: src/enums/sizes.md:52
msgid ""
"```rust,editable\n"
"use std::mem::transmute;\n"
"```"
msgstr ""
"```rust,editable\n"
"use std::mem::transmute;\n"
"```"

#: src/enums/sizes.md:55 src/enums/sizes.md:94
msgid ""
"macro_rules! dbg_bits { ($e:expr, $bit_type:ty) => { println!(\"- {}: {:"
"#x}\", stringify!($e), transmute::\\<\\_, $bit_type>($e)); }; }"
msgstr ""
"macro_rules! dbg_bits { ($e:expr, $bit_type:ty) => { println!(\"- {}: {:"
"#x}\", stringify!($e), transmute::\\<\\_, $bit_type>($e)); }; }"

#: src/enums/sizes.md:61
msgid ""
"fn main() { // TOTALLY UNSAFE. Rust provides no guarantees about the "
"bitwise // representation of types. unsafe { println!(\"Bitwise "
"representation of bool\"); dbg_bits!(false, u8); dbg_bits!(true, u8);"
msgstr ""
"fn main() { // NIEBEZPIECZNE. Rust nie daje gwarancji jak dany typ jest "
"przedstawiony w pamici. unsafe { println!(\"Bitowa reprezentacja typu "
"bool\"); dbg_bits!(false, u8); dbg_bits!(true, u8);"

#: src/enums/sizes.md:69
msgid ""
"```\n"
"    println!(\"Bitwise representation of Option<bool>\");\n"
"    dbg_bits!(None::<bool>, u8);\n"
"    dbg_bits!(Some(false), u8);\n"
"    dbg_bits!(Some(true), u8);\n"
"```"
msgstr ""
"```\n"
"    println!(\"Bitowa reprezentacja Option<bool>\");\n"
"    dbg_bits!(None::<bool>, u8);\n"
"    dbg_bits!(Some(false), u8);\n"
"    dbg_bits!(Some(true), u8);\n"
"```"

#: src/enums/sizes.md:74
msgid ""
"```\n"
"    println!(\"Bitwise representation of Option<Option<bool>>\");\n"
"    dbg_bits!(Some(Some(false)), u8);\n"
"    dbg_bits!(Some(Some(true)), u8);\n"
"    dbg_bits!(Some(None::<bool>), u8);\n"
"    dbg_bits!(None::<Option<bool>>, u8);\n"
"```"
msgstr ""
"```\n"
"    println!(\"Bitowa reprezentacja Option<Option<bool>>\");\n"
"    dbg_bits!(Some(Some(false)), u8);\n"
"    dbg_bits!(Some(Some(true)), u8);\n"
"    dbg_bits!(Some(None::<bool>), u8);\n"
"    dbg_bits!(None::<Option<bool>>, u8);\n"
"```"

#: src/enums/sizes.md:80
msgid ""
"```\n"
"    println!(\"Bitwise representation of Option<&i32>\");\n"
"    dbg_bits!(None::<&i32>, usize);\n"
"    dbg_bits!(Some(&0i32), usize);\n"
"}\n"
"```"
msgstr ""
"```\n"
"    println!(\"Bitowa reprezentacja Option<&i32>\");\n"
"    dbg_bits!(None::<&i32>, usize);\n"
"    dbg_bits!(Some(&0i32), usize);\n"
"}\n"
"```"

#: src/enums/sizes.md:87
#, fuzzy
msgid ""
"More complex example if you want to discuss what happens when we chain more "
"than 256 `Option`s together."
msgstr ""
"Bardziej zo偶ony przykad, jeli chcesz om贸wi, co si stanie, gdy poczymy "
"razem wicej ni偶 256 opcji."

#: src/enums/sizes.md:89
msgid ""
"```rust,editable\n"
"#![recursion_limit = \"1000\"]\n"
"```"
msgstr ""
"```rust,editable\n"
"#![recursion_limit = \"1000\"]\n"
"```"

#: src/enums/sizes.md:92
msgid "use std::mem::transmute;"
msgstr "use std::mem::transmute;"

#: src/enums/sizes.md:100
msgid ""
"// Macro to wrap a value in 2^n Some() where n is the number of \"@\" "
"signs. // Increasing the recursion limit is required to evaluate this macro. "
"macro_rules! many_options { ($value:expr) => { Some($value) }; ($value:expr, "
"@) => { Some(Some($value)) }; ($value:expr, @ $($more:tt)+) => "
"{ many_options!(many_options!($value, $($more)+), $($more)+) }; }"
msgstr ""
"// Makro pakujce warto w 2^n Some() gdzie n to liczba znak贸w \"@\". // "
"Zwiksznie limitu rekurencji jest wymagane 偶eby wywoa to makro. "
"macro_rules! many_options { ($value:expr) => { Some($value) }; ($value:expr, "
"@) => { Some(Some($value)) }; ($value:expr, @ $($more:tt)+) => "
"{ many_options!(many_options!($value, $($more)+), $($more)+) }; }"

#: src/enums/sizes.md:112
msgid ""
"fn main() { // TOTALLY UNSAFE. Rust provides no guarantees about the "
"bitwise // representation of types. unsafe { assert_eq!(many_options!"
"(false), Some(false)); assert_eq!(many_options!(false, @), "
"Some(Some(false))); assert_eq!(many_options!(false, @@), "
"Some(Some(Some(Some(false)))));"
msgstr ""
"fn main() { // NIEBEZPIECZNE. Rust nie daje gwarancji jak dany typ jest "
"przedstawiony w pamici. unsafe { assert_eq!(many_options!(false), "
"Some(false)); assert_eq!(many_options!(false, @), Some(Some(false))); "
"assert_eq!(many_options!(false, @@), Some(Some(Some(Some(false)))));"

#: src/enums/sizes.md:120
msgid ""
"```\n"
"    println!(\"Bitwise representation of a chain of 128 Option's.\");\n"
"    dbg_bits!(many_options!(false, @@@@@@@), u8);\n"
"    dbg_bits!(many_options!(true, @@@@@@@), u8);\n"
"```"
msgstr ""
"```\n"
"    println!(\"Bitowa reprezentacja acucha 128 Option.\");\n"
"    dbg_bits!(many_options!(false, @@@@@@@), u8);\n"
"    dbg_bits!(many_options!(true, @@@@@@@), u8);\n"
"```"

#: src/enums/sizes.md:124
msgid ""
"```\n"
"    println!(\"Bitwise representation of a chain of 256 Option's.\");\n"
"    dbg_bits!(many_options!(false, @@@@@@@@), u16);\n"
"    dbg_bits!(many_options!(true, @@@@@@@@), u16);\n"
"```"
msgstr ""
"```\n"
"    println!(\"Bitowa reprezentacja acucha 256 Option.\");\n"
"    dbg_bits!(many_options!(false, @@@@@@@@), u16);\n"
"    dbg_bits!(many_options!(true, @@@@@@@@), u16);\n"
"```"

#: src/enums/sizes.md:128
msgid ""
"```\n"
"    println!(\"Bitwise representation of a chain of 257 Option's.\");\n"
"    dbg_bits!(many_options!(Some(false), @@@@@@@@), u16);\n"
"    dbg_bits!(many_options!(Some(true), @@@@@@@@), u16);\n"
"    dbg_bits!(many_options!(None::<bool>, @@@@@@@@), u16);\n"
"}\n"
"```"
msgstr ""
"```\n"
"    println!(\"Bitowa reprezentacja acucha 257 Option.\");\n"
"    dbg_bits!(many_options!(Some(false), @@@@@@@@), u16);\n"
"    dbg_bits!(many_options!(Some(true), @@@@@@@@), u16);\n"
"    dbg_bits!(many_options!(None::<bool>, @@@@@@@@), u16);\n"
"}\n"
"```"

#: src/methods.md:3
#, fuzzy
msgid ""
"Rust allows you to associate functions with your new types. You do this with "
"an `impl` block:"
msgstr ""
"Rust umo偶liwia powizanie funkcji z nowymi typami. Robisz to z blok `impl`:"

#: src/methods.md:13
msgid ""
"impl Person { fn say_hello(&self) { println!(\"Hello, my name is {}\", self."
"name); } }"
msgstr ""
"impl Person { fn say_hello(&self) { println!(\"Cze, mam na imi {}\", self."
"name); } }"

#: src/methods.md:19
msgid ""
"fn main() { let peter = Person { name: String::from(\"Peter\"), age: 27, }; "
"peter.say_hello(); }"
msgstr ""
"fn main() { let peter = Person { name: String::from(\"Peter\"), age: 27, }; "
"peter.say_hello(); }"

#: src/methods.md:31
#, fuzzy
msgid "It can be helpful to introduce methods by comparing them to functions."
msgstr ""
"Pomocne mo偶e by wprowadzenie metod poprzez por贸wnanie ich z funkcjami."

#: src/methods.md:32
#, fuzzy
msgid ""
"Methods are called on an instance of a type (such as a struct or enum), the "
"first parameter represents the instance as `self`."
msgstr ""
"Metody s wywoywane na instancji typu (takiej jak struct lub enum), "
"pierwszy parametr reprezentuje instancj jako `self`."

#: src/methods.md:33
#, fuzzy
msgid ""
"Developers may choose to use methods to take advantage of method receiver "
"syntax and to help keep them more organized. By using methods we can keep "
"all the implementation code in one predictable place."
msgstr ""
"Deweloperzy mog zdecydowa si na u偶ycie metod, aby skorzysta ze skadni "
"odbiornika metod i pom贸c w ich lepszej organizacji. Dziki metodom mo偶emy "
"przechowywa cay kod implementacji w jednym przewidywalnym miejscu."

#: src/methods.md:34
#, fuzzy
msgid "Point out the use of the keyword `self`, a method receiver. "
msgstr "Zwr贸 uwag na u偶ycie sowa kluczowego `self`, odbiornika metody."

#: src/methods.md:35
#, fuzzy
msgid ""
"Show that it is an abbreviated term for `self:&Self` and perhaps show how "
"the struct name could also be used. "
msgstr ""
"Poka偶, 偶e jest to skr贸cony termin dla `self:&Self` i by mo偶e poka偶, jak "
"mo偶na r贸wnie偶 u偶y nazwy struktury."

#: src/methods.md:36
#, fuzzy
msgid ""
"Explain that `Self` is a type alias for the type the `impl` block is in and "
"can be used elsewhere in the block."
msgstr ""
"Wyjanij, 偶e `Self` jest aliasem typu dla typu, w kt贸rym znajduje si blok "
"`impl` i mo偶e by u偶yty w innym miejscu bloku."

#: src/methods.md:37
#, fuzzy
msgid ""
"Note how `self` is used like other structs and dot notation can be used to "
"refer to individual fields."
msgstr ""
"Zwr贸 uwag, jak `self` jest u偶ywane jak inne struktury, a notacja kropkowa "
"mo偶e by u偶ywana do odwoywania si do poszczeg贸lnych p贸l."

#: src/methods.md:38
#, fuzzy
msgid ""
"This might be a good time to demonstrate how the `&self` differs from `self` "
"by modifying the code and trying to run say_hello twice."
msgstr ""
"To mo偶e by dobry moment, aby zademonstrowa, czym `&self` r贸偶ni si od "
"`self` poprzez modyfikacj kodu i pr贸b dwukrotnego uruchomienia say_hello."

#: src/methods.md:39
#, fuzzy
msgid "We describe the distinction between method receivers next."
msgstr "Nastpnie opiszemy rozr贸偶nienie midzy odbiornikami metod."

#: src/methods/receiver.md:3
#, fuzzy
msgid ""
"The `&self` above indicates that the method borrows the object immutably. "
"There are other possible receivers for a method:"
msgstr ""
"&self powy偶ej wskazuje, 偶e metoda niezmiennie po偶ycza obiekt. Tam s "
"innymi mo偶liwymi odbiorcami metody:"

#: src/methods/receiver.md:6
#, fuzzy
msgid ""
"`&self`: borrows the object from the caller using a shared and immutable "
"reference. The object can be used again afterwards."
msgstr ""
"`&self`: po偶ycza obiekt od dzwonicego za pomoc wsp贸dzielonego i "
"niezmiennego odniesienie. Obiekt mo偶e by p贸藕niej ponownie u偶yty."

#: src/methods/receiver.md:8
#, fuzzy
msgid ""
"`&mut self`: borrows the object from the caller using a unique and mutable "
"reference. The object can be used again afterwards."
msgstr ""
"`&mut self`: po偶ycza obiekt od wywoujcego u偶ywajc unikalnego i zmiennego "
"odniesienie. Obiekt mo偶e by p贸藕niej ponownie u偶yty."

#: src/methods/receiver.md:10
#, fuzzy
msgid ""
"`self`: takes ownership of the object and moves it away from the caller. The "
"method becomes the owner of the object. The object will be dropped "
"(deallocated) when the method returns, unless its ownership is explicitly "
"transmitted."
msgstr ""
"`self`: przejmuje obiekt na wasno i oddala go od dzwonicego. The metoda "
"staje si wacicielem obiektu. Obiekt zostanie usunity (cofnity "
"przydzia) gdy metoda zwraca, chyba 偶e jej wasno jest wyra藕nie okrelona "
"przekazywane."

#: src/methods/receiver.md:14
#, fuzzy
msgid ""
"`mut self`: same as above, but while the method owns the object, it can "
"mutate it too. Complete ownership does not automatically mean mutability."
msgstr ""
"`mut self`: to samo co powy偶ej, ale gdy metoda jest wacicielem obiektu, "
"mo偶e te偶 mutuj. Pena wasno nie oznacza automatycznie zmiennoci."

#: src/methods/receiver.md:16
#, fuzzy
msgid ""
"No receiver: this becomes a static method on the struct. Typically used to "
"create constructors which are called `new` by convention."
msgstr ""
"Brak odbiornika: staje si to metod statyczn w strukturze. Zwykle "
"przyzwyczajony tworzy konstruktory, kt贸re zgodnie z konwencj nazywane s "
"nowymi."

#: src/methods/receiver.md:19
#, fuzzy
msgid ""
"Beyond variants on `self`, there are also [special wrapper types](https://"
"doc.rust-lang.org/reference/special-types-and-traits.html) allowed to be "
"receiver types, such as `Box<Self>`."
msgstr ""
"Opr贸cz wariant贸w na ja, istniej r贸wnie偶 [specjalne typy opakowa](https://"
"doc.rust-lang.org/reference/special-types-and-traits.html) mog by typami "
"odbiornik贸w, takimi jak `Box<Self>`."

#: src/methods/receiver.md:25
#, fuzzy
msgid ""
"Consider emphasizing \"shared and immutable\" and \"unique and mutable\". "
"These constraints always come together in Rust due to borrow checker rules, "
"and `self` is no exception. It isn't possible to reference a struct from "
"multiple locations and call a mutating (`&mut self`) method on it."
msgstr ""
"Rozwa偶 podkrelenie s贸w wsp贸lny i niezmienny oraz unikatowy i zmienny. "
"Te ograniczenia pojawiaj si zawsze razem w Rust ze wzgldu na zasady "
"po偶yczania sprawdzania, a `self` nie jest wyjtkiem. Nie mo偶na odwoa si "
"do struktury z wielu lokalizacji i wywoa na niej metod mutacji (`&mut "
"self`)."

#: src/methods/example.md:3
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Race {\n"
"    name: String,\n"
"    laps: Vec<i32>,\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Race {\n"
"    name: String,\n"
"    laps: Vec<i32>,\n"
"}\n"
"```"

#: src/methods/example.md:10
#, fuzzy
msgid ""
"impl Race { fn new(name: &str) -> Race {  // No receiver, a static method "
"Race { name: String::from(name), laps: Vec::new() } }"
msgstr ""
"impl Wycig { fn new(name: &str) -> Race { // Brak odbiornika, metoda "
"statyczna Wycig { nazwa: String::from(name), okr偶enia: Vec::new() } }"

#: src/methods/example.md:15
msgid ""
"```\n"
"fn add_lap(&mut self, lap: i32) {  // Exclusive borrowed read-write access "
"to self\n"
"    self.laps.push(lap);\n"
"}\n"
"```"
msgstr ""

#: src/methods/example.md:19
msgid ""
"```\n"
"fn print_laps(&self) {  // Shared and read-only borrowed access to self\n"
"    println!(\"Recorded {} laps for {}:\", self.laps.len(), self.name);\n"
"    for (idx, lap) in self.laps.iter().enumerate() {\n"
"        println!(\"Lap {idx}: {lap} sec\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/methods/example.md:26
msgid ""
"```\n"
"fn finish(self) {  // Exclusive ownership of self\n"
"    let total = self.laps.iter().sum::<i32>();\n"
"    println!(\"Race {} is finished, total lap time: {}\", self.name, "
"total);\n"
"}\n"
"```"
msgstr ""

#: src/methods/example.md:32
msgid ""
"fn main() { let mut race = Race::new(\"Monaco Grand Prix\"); race."
"add_lap(70); race.add_lap(68); race.print_laps(); race.add_lap(71); race."
"print_laps(); race.finish(); // race.add_lap(42); }"
msgstr ""
"fn main() { let mut race = Race::new(\"Monaco Grand Prix\"); race."
"add_lap(70); race.add_lap(68); race.print_laps(); race.add_lap(71); race."
"print_laps(); race.finish(); // race.add_lap(42); }"

#: src/methods/example.md:47
#, fuzzy
msgid "All four methods here use a different method receiver."
msgstr "Wszystkie cztery metody tutaj wykorzystuj inny odbiornik metody."

#: src/methods/example.md:48
#, fuzzy
msgid ""
"You can point out how that changes what the function can do with the "
"variable values and if/how it can be used again in `main`."
msgstr ""
"Mo偶esz wskaza, jak to zmienia to, co funkcja mo偶e zrobi z wartociami "
"zmiennych i czy/jak mo偶na jej ponownie u偶y w `main`."

#: src/methods/example.md:49
#, fuzzy
msgid ""
"You can showcase the error that appears when trying to call `finish` twice."
msgstr ""
"Mo偶esz pokaza bd, kt贸ry pojawia si podczas pr贸by dwukrotnego wywoania "
"`finish`."

#: src/methods/example.md:50
#, fuzzy
msgid ""
"Note that although the method receivers are different, the non-static "
"functions are called the same way in the main body. Rust enables automatic "
"referencing and dereferencing when calling methods. Rust automatically adds "
"in the `&`, `*`, `muts` so that that object matches the method signature."
msgstr ""
"Nale偶y zauwa偶y, 偶e chocia偶 odbiorniki metod s r贸偶ne, funkcje niestatyczne "
"s wywoywane w ten sam spos贸b w g贸wnej czci. Rust umo偶liwia automatyczne "
"odwoywanie si i usuwanie odwoa podczas wywoywania metod. Rust "
"automatycznie dodaje `&`, `*`, `muts`, aby ten obiekt pasowa do sygnatury "
"metody."

#: src/methods/example.md:51
#, fuzzy
msgid ""
"You might point out that `print_laps` is using a vector that is iterated "
"over. We describe vectors in more detail in the afternoon. "
msgstr ""
"Mo偶esz zauwa偶y, 偶e `print_laps` u偶ywa wektora, kt贸ry jest iterowany. "
"Wektory opiszemy bardziej szczeg贸owo po poudniu."

#: src/pattern-matching.md:3
#, fuzzy
msgid ""
"The `match` keyword let you match a value against one or more _patterns_. "
"The comparisons are done from top to bottom and the first match wins."
msgstr ""
"Sowo kluczowe `match` pozwala dopasowa warto do jednego lub wicej "
"_wzorc贸w_. The por贸wnania s wykonywane od g贸ry do dou, a pierwszy mecz "
"wygrywa."

#: src/pattern-matching.md:6
#, fuzzy
msgid "The patterns can be simple values, similarly to `switch` in C and C++:"
msgstr "Wzorce mog by prostymi wartociami, podobnie jak `switch` w C i C++:"

#: src/pattern-matching.md:8
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let input = 'x';\n"
"```"
msgstr ""

#: src/pattern-matching.md:12
msgid ""
"```\n"
"match input {\n"
"    'q'                   => println!(\"Quitting\"),\n"
"    'a' | 's' | 'w' | 'd' => println!(\"Moving around\"),\n"
"    '0'..='9'             => println!(\"Number input\"),\n"
"    _                     => println!(\"Something else\"),\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching.md:21
#, fuzzy
msgid "The `_` pattern is a wildcard pattern which matches any value."
msgstr ""
"Wzorzec `_` jest wzorcem wieloznacznym, kt贸ry pasuje do dowolnej wartoci."

#: src/pattern-matching.md:26
#, fuzzy
msgid ""
"You might point out how some specific characters are being used when in a "
"pattern"
msgstr ""
"Mo偶esz wskaza, w jaki spos贸b niekt贸re okrelone znaki s u偶ywane we wzorcu"

#: src/pattern-matching.md:27
#, fuzzy
msgid "`|` as an `or`"
msgstr "`|` jako `lub`"

#: src/pattern-matching.md:28
#, fuzzy
msgid "`..` can expand as much as it needs to be"
msgstr "`..` mo偶e rozwin si tak bardzo, jak to konieczne"

#: src/pattern-matching.md:29
#, fuzzy
msgid "`1..=5` represents an inclusive range"
msgstr "`1..=5` reprezentuje zakres wcznie"

#: src/pattern-matching.md:30
#, fuzzy
msgid "`_` is a wild card"
msgstr "`_` to symbol wieloznaczny"

#: src/pattern-matching.md:31
#, fuzzy
msgid ""
"It can be useful to show how binding works, by for instance replacing a "
"wildcard character with a variable, or removing the quotes around `q`."
msgstr ""
"Przydatne mo偶e by pokazanie, jak dziaa wizanie, na przykad zastpujc "
"symbol wieloznaczny zmienn lub usuwajc cudzysowy wok贸 `q`."

#: src/pattern-matching.md:32
#, fuzzy
msgid "You can demonstrate matching on a reference."
msgstr "Mo偶esz zademonstrowa dopasowanie na podstawie referencji."

#: src/pattern-matching.md:33
#, fuzzy
msgid ""
"This might be a good time to bring up the concept of irrefutable patterns, "
"as the term can show up in error messages."
msgstr ""
"To mo偶e by dobry moment, aby przywoa koncepcj niepodwa偶alnych wzorc贸w, "
"poniewa偶 termin ten mo偶e pojawia si w komunikatach o bdach."

#: src/pattern-matching/destructuring-enums.md:3
#, fuzzy
msgid ""
"Patterns can also be used to bind variables to parts of your values. This is "
"how you inspect the structure of your types. Let us start with a simple "
"`enum` type:"
msgstr ""
"Wzorc贸w mo偶na r贸wnie偶 u偶ywa do wizania zmiennych z czciami wartoci. Oto "
"jak sprawdzasz struktur swoich typ贸w. Zacznijmy od prostego typu `enum`:"

#: src/pattern-matching/destructuring-enums.md:6
msgid ""
"```rust,editable\n"
"enum Result {\n"
"    Ok(i32),\n"
"    Err(String),\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/destructuring-enums.md:12
#, fuzzy
msgid ""
"fn divide_in_two(n: i32) -> Result { if n % 2 == 0 { Result::Ok(n / 2) } "
"else { Result::Err(format!(\"cannot divide {n} into two equal parts\")) } }"
msgstr ""
"fn dzielenie_na_dwa(n: i32) -> Wynik { jeli n % 2 == 0 { Wynik::OK(n / 2) } "
"w przeciwnym razie { Result::Err(format!(\"nie mo偶na podzieli {n} na dwie "
"r贸wne czci\")) } }"

#: src/pattern-matching/destructuring-enums.md:20
msgid ""
"fn main() { let n = 100; match divide_in_two(n) { Result::Ok(half) => "
"println!(\"{n} divided in two is {half}\"), Result::Err(msg) => println!"
"(\"sorry, an error happened: {msg}\"), } }"
msgstr ""

#: src/pattern-matching/destructuring-enums.md:29
#, fuzzy
msgid ""
"Here we have used the arms to _destructure_ the `Result` value. In the first "
"arm, `half` is bound to the value inside the `Ok` variant. In the second "
"arm, `msg` is bound to the error message."
msgstr ""
"Tutaj u偶ylimy ramion do _destrukturyzacji_ wartoci `Result`. Na pocztku "
"arm, `half` jest powizany z wartoci wewntrz wariantu `Ok`. W drugim "
"ramieniu `msg` jest powizany z komunikatem o bdzie."

#: src/pattern-matching/destructuring-enums.md:36
#, fuzzy
msgid ""
"The `if`/`else` expression is returning an enum that is later unpacked with "
"a `match`."
msgstr ""
"Wyra偶enie `if`/`else` zwraca wyliczenie, kt贸re jest p贸藕niej rozpakowywane z "
"`match`."

#: src/pattern-matching/destructuring-enums.md:37
#, fuzzy
msgid ""
"You can try adding a third variant to the enum definition and displaying the "
"errors when running the code. Point out the places where your code is now "
"inexhaustive and how the compiler tries to give you hints."
msgstr ""
"Mo偶esz spr贸bowa doda trzeci wariant do definicji enum i wywietli bdy "
"podczas uruchamiania kodu. Wska偶 miejsca, w kt贸rych Tw贸j kod jest teraz "
"niewyczerpany i jak kompilator pr贸buje udzieli Ci wskaz贸wek."

#: src/pattern-matching/destructuring-structs.md:3
#, fuzzy
msgid "You can also destructure `structs`:"
msgstr "Mo偶esz tak偶e zniszczy `struktury`:"

#: src/pattern-matching/destructuring-structs.md:5
msgid ""
"```rust,editable\n"
"struct Foo {\n"
"    x: (u32, u32),\n"
"    y: u32,\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/destructuring-structs.md:11
msgid ""
"\\#\\[rustfmt::skip\\] fn main() { let foo = Foo { x: (1, 2), y: 3 }; match "
"foo { Foo { x: (1, b), y } => println!(\"x.0 = 1, b = {b}, y = {y}\"), Foo "
"{ y: 2, x: i }   => println!(\"y = 2, x = {i:?}\"), Foo { y, .. }        => "
"println!(\"y = {y}, other fields were ignored\"), } }"
msgstr ""

#: src/pattern-matching/destructuring-structs.md:20
msgid ""
"```\n"
"<details>\n"
"\n"
"# Destructuring Structs\n"
"\n"
"You can also destructure `structs`:\n"
"\n"
"```rust,editable\n"
"struct Foo {\n"
"    x: (u32, u32),\n"
"    y: u32,\n"
"}\n"
"\n"
"* Change the literal values in `foo` to match with the other patterns.\n"
"* Add a new field to `Foo` and make changes to the pattern as needed.\n"
"</details>\n"
"\n"
"# Destructuring Structs\n"
"\n"
"You can also destructure `structs`:\n"
"\n"
"```rust,editable\n"
"{{#include ../../third_party/rust-by-example/destructuring-structs.rs}}\n"
"```"
msgstr ""

#: src/pattern-matching/destructuring-structs.md:23
#, fuzzy
msgid "Change the literal values in `foo` to match with the other patterns."
msgstr "Zmie wartoci literalne w `foo`, aby dopasowa je do innych wzorc贸w."

#: src/pattern-matching/destructuring-structs.md:24
#, fuzzy
msgid "Add a new field to `Foo` and make changes to the pattern as needed."
msgstr "Dodaj nowe pole do `Foo` i w razie potrzeby wprowad藕 zmiany we wzorcu."

#: src/pattern-matching/destructuring-arrays.md:3
#, fuzzy
msgid ""
"You can destructure arrays, tuples, and slices by matching on their elements:"
msgstr "Mo偶esz niszczy tablice, krotki i plasterki, dopasowujc ich elementy:"

#: src/pattern-matching/destructuring-arrays.md:5
msgid ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let triple = [0, -2, 3];\n"
"    println!(\"Tell me about {triple:?}\");\n"
"    match triple {\n"
"        [0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"        [1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
"        _         => println!(\"All elements were ignored\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/destructuring-arrays.md:21
#, fuzzy
msgid ""
"Destructuring of slices of unknown length also works with patterns of fixed "
"length."
msgstr ""
"Destrukturyzacja plasterk贸w o nieznanej dugoci dziaa r贸wnie偶 z wzorami o "
"staej dugoci."

#: src/pattern-matching/destructuring-arrays.md:24
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    inspect(&[0, -2, 3]);\n"
"    inspect(&[0, -2, 3, 4]);\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/destructuring-arrays.md:30
msgid ""
"\\#\\[rustfmt::skip\\] fn inspect(slice: &\\[i32\\]) { println!(\"Tell me "
"about {slice:?}\"); match slice { &\\[0, y, z\\] => println!(\"First is 0, y "
"= {y}, and z = {z}\"), &\\[1, ..\\]   => println!(\"First is 1 and the rest "
"were ignored\"), \\_          => println!(\"All elements were ignored\"), } }"
msgstr ""

#: src/pattern-matching/destructuring-arrays.md:39
msgid ""
"```\n"
"  \n"
"* Create a new pattern using `_` to represent an element. \n"
"* Add more values to the array.\n"
"* Point out that how `..` will expand to account for different number of "
"elements.\n"
"* Show matching against the tail with patterns `[.., b]` and `[a@..,b]`\n"
"\n"
"# Destructuring Arrays\n"
"\n"
"You can destructure arrays, tuples, and slices by matching on their "
"elements:\n"
"\n"
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let triple = [0, -2, 3];\n"
"    println!(\"Tell me about {triple:?}\");\n"
"    match triple {\n"
"        [0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"        [1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
"        _         => println!(\"All elements were ignored\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/match-guards.md:3
#, fuzzy
msgid ""
"When matching, you can add a _guard_ to a pattern. This is an arbitrary "
"Boolean expression which will be executed if the pattern matches:"
msgstr ""
"Podczas dopasowywania mo偶esz doda _guard_ do wzoru. To jest dowolna warto "
"logiczna wyra偶enie, kt贸re zostanie wykonane, jeli wzorzec pasuje:"

#: src/pattern-matching/match-guards.md:6
msgid ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let pair = (2, -2);\n"
"    println!(\"Tell me about {pair:?}\");\n"
"    match pair {\n"
"        (x, y) if x == y     => println!(\"These are twins\"),\n"
"        (x, y) if x + y == 0 => println!(\"Antimatter, kaboom!\"),\n"
"        (x, _) if x % 2 == 1 => println!(\"The first one is odd\"),\n"
"        _                    => println!(\"No correlation...\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/match-guards.md:23
#, fuzzy
msgid ""
"Match guards as a separate syntax feature are important and necessary when "
"we wish to concisely express more complex ideas than patterns alone would "
"allow."
msgstr ""
"Osony dopasowujce jako oddzielna funkcja skadni s wa偶ne i konieczne, gdy "
"chcemy zwi藕le wyrazi bardziej zo偶one idee, ni偶 pozwalaj na to same "
"wzorce."

#: src/pattern-matching/match-guards.md:24
#, fuzzy
msgid ""
"They are not the same as separate `if` expression inside of the match arm. "
"An `if` expression inside of the branch block (after `=>`) happens after the "
"match arm is selected. Failing the `if` condition inside of that block won't "
"result in other arms of the original `match` expression being considered."
msgstr ""
"Nie s tym samym, co osobne wyra偶enie `if` wewntrz ramienia dopasowania. "
"Wyra偶enie `if` wewntrz bloku rozgazienia (po `=>`) nastpuje po wybraniu "
"ramienia dopasowania. Niepowodzenie warunku `if` wewntrz tego bloku nie "
"spowoduje powstania innych ramion oryginalnego wyra偶enia dopasuj, kt贸re "
"jest brane pod uwag."

#: src/pattern-matching/match-guards.md:26
#, fuzzy
msgid "You can use the variables defined in the pattern in your if expression."
msgstr "Mo偶esz u偶y zmiennych zdefiniowanych we wzorcu w swoim wyra偶eniu if."

#: src/pattern-matching/match-guards.md:27
#, fuzzy
msgid ""
"The condition defined in the guard applies to every expression in a pattern "
"with an `|`."
msgstr ""
"Warunek zdefiniowany w stra偶niku dotyczy ka偶dego wyra偶enia we wzorcu ze "
"znakiem `|`."

#: src/exercises/day-2/morning.md:1
#, fuzzy
msgid "Day 2: Morning Exercises"
msgstr "Dzie 2: wiczenia poranne"

#: src/exercises/day-2/morning.md:3
#, fuzzy
msgid "We will look at implementing methods in two contexts:"
msgstr "Przyjrzymy si metodom implementacji w dw贸ch kontekstach:"

#: src/exercises/day-2/morning.md:5
#, fuzzy
msgid "Simple struct which tracks health statistics."
msgstr "Prosta struktura, kt贸ra ledzi statystyki zdrowotne."

#: src/exercises/day-2/morning.md:7
#, fuzzy
msgid "Multiple structs and enums for a drawing library."
msgstr "Wiele struktur i wylicze dla biblioteki rysunk贸w."

#: src/exercises/day-2/health-statistics.md:3
#, fuzzy
msgid ""
"You're working on implementing a health-monitoring system. As part of that, "
"you need to keep track of users' health statistics."
msgstr ""
"Pracujesz nad wdro偶eniem systemu monitorowania stanu. W ramach tego ty musz "
"ledzi statystyki dotyczce zdrowia u偶ytkownik贸w."

#: src/exercises/day-2/health-statistics.md:6
#, fuzzy
msgid ""
"You'll start with some stubbed functions in an `impl` block as well as a "
"`User` struct definition. Your goal is to implement the stubbed out methods "
"on the `User` `struct` defined in the `impl` block."
msgstr ""
"Zaczniesz od niekt贸rych funkcji skr贸towych w bloku `impl`, jak r贸wnie偶 "
"`U偶ytkownika` definicja struktury. Twoim celem jest zaimplementowanie "
"wygaszonych metod na `User` `struct` zdefiniowana w bloku `impl`."

#: src/exercises/day-2/health-statistics.md:10
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing "
"methods:"
msgstr ""
"Skopiuj poni偶szy kod na <https://play.rust-lang.org/> i uzupenij brakujce "
"metody:"

#: src/exercises/day-2/health-statistics.md:17
msgid "struct User { name: String, age: u32, weight: f32, }"
msgstr "struct User { name: String, age: u32, weight: f32, }"

#: src/exercises/day-2/health-statistics.md:23
msgid ""
"impl User { pub fn new(name: String, age: u32, weight: f32) -> Self "
"{ unimplemented!() }"
msgstr ""
"impl User { pub fn new(name: String, age: u32, weight: f32) -> Self "
"{ unimplemented!() }"

#: src/exercises/day-2/health-statistics.md:28
msgid ""
"```\n"
"pub fn name(&self) -> &str {\n"
"    unimplemented!()\n"
"}\n"
"```"
msgstr ""
"```\n"
"pub fn name(&self) -> &str {\n"
"    unimplemented!()\n"
"}\n"
"```"

#: src/exercises/day-2/health-statistics.md:32
msgid ""
"```\n"
"pub fn age(&self) -> u32 {\n"
"    unimplemented!()\n"
"}\n"
"```"
msgstr ""
"```\n"
"pub fn age(&self) -> u32 {\n"
"    unimplemented!()\n"
"}\n"
"```"

#: src/exercises/day-2/health-statistics.md:36
msgid ""
"```\n"
"pub fn weight(&self) -> f32 {\n"
"    unimplemented!()\n"
"}\n"
"```"
msgstr ""
"```\n"
"pub fn weight(&self) -> f32 {\n"
"    unimplemented!()\n"
"}\n"
"```"

#: src/exercises/day-2/health-statistics.md:40
msgid ""
"```\n"
"pub fn set_age(&mut self, new_age: u32) {\n"
"    unimplemented!()\n"
"}\n"
"```"
msgstr ""
"```\n"
"pub fn set_age(&mut self, new_age: u32) {\n"
"    unimplemented!()\n"
"}\n"
"```"

#: src/exercises/day-2/health-statistics.md:44
msgid ""
"```\n"
"pub fn set_weight(&mut self, new_weight: f32) {\n"
"    unimplemented!()\n"
"}\n"
"```"
msgstr ""
"```\n"
"pub fn set_weight(&mut self, new_weight: f32) {\n"
"    unimplemented!()\n"
"}\n"
"```"

#: src/exercises/day-2/health-statistics.md:49
msgid ""
"fn main() { let bob = User::new(String::from(\"Bob\"), 32, 155.2); println!"
"(\"I'm {} and my age is {}\", bob.name(), bob.age()); }"
msgstr ""
"fn main() { let bob = User::new(String::from(\"Bob\"), 32, 155.2); println!"
"(\"Jestem {} i mam {} lat\", bob.name(), bob.age()); }"

#: src/exercises/day-2/health-statistics.md:54
msgid ""
"\\#\\[test\\] fn test_weight() { let bob = User::new(String::from(\"Bob\"), "
"32, 155.2); assert_eq!(bob.weight(), 155.2); }"
msgstr ""
"\\#\\[test\\] fn test_weight() { let bob = User::new(String::from(\"Bob\"), "
"32, 155.2); assert_eq!(bob.weight(), 155.2); }"

#: src/exercises/day-2/health-statistics.md:60
msgid ""
"\\#\\[test\\] fn test_set_age() { let mut bob = User::new(String::"
"from(\"Bob\"), 32, 155.2); assert_eq!(bob.age(), 32); bob.set_age(33); "
"assert_eq!(bob.age(), 33); }"
msgstr ""
"\\#\\[test\\] fn test_set_age() { let mut bob = User::new(String::"
"from(\"Bob\"), 32, 155.2); assert_eq!(bob.age(), 32); bob.set_age(33); "
"assert_eq!(bob.age(), 33); }"

#: src/exercises/day-2/health-statistics.md:67
msgid ""
"```\n"
"\n"
"# Health Statistics\n"
"\n"
"You're working on implementing a health-monitoring system. As part of that, "
"you\n"
"need to keep track of users' health statistics.\n"
"\n"
"You'll start with some stubbed functions in an `impl` block as well as a "
"`User`\n"
"struct definition. Your goal is to implement the stubbed out methods on the\n"
"`User` `struct` defined in the `impl` block.\n"
"\n"
"Copy the code below to <https://play.rust-lang.org/> and fill in the "
"missing\n"
"methods:\n"
"\n"
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"struct User {\n"
"    name: String,\n"
"    age: u32,\n"
"    weight: f32,\n"
"}\n"
"\n"
"impl User {\n"
"    pub fn new(name: String, age: u32, weight: f32) -> Self {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn name(&self) -> &str {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn age(&self) -> u32 {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn weight(&self) -> f32 {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn set_age(&mut self, new_age: u32) {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn set_weight(&mut self, new_weight: f32) {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    println!(\"I'm {} and my age is {}\", bob.name(), bob.age());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_weight() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.weight(), 155.2);\n"
"}\n"
"\n"
"# Health Statistics\n"
"\n"
"{{#include ../../../third_party/rust-on-exercism/health-statistics.md}}\n"
"\n"
"Copy the code below to <https://play.rust-lang.org/> and fill in the "
"missing\n"
"methods:\n"
"\n"
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"{{#include ../../../third_party/rust-on-exercism/health-statistics.rs}}\n"
"\n"
"fn main() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    println!(\"I'm {} and my age is {}\", bob.name(), bob.age());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_height() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.height(), 155.2);\n"
"}\n"
"\n"
"#[test]\n"
"fn test_set_age() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.age(), 32);\n"
"    bob.set_age(33);\n"
"    assert_eq!(bob.age(), 33);\n"
"}\n"
"\n"
"#[test]\n"
"fn test_visit() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.doctor_visits(), 0);\n"
"    let report = bob.visit_doctor(Measurements {\n"
"        height: 156.1,\n"
"        blood_pressure: (120, 80),\n"
"    });\n"
"    assert_eq!(report.patient_name, \"Bob\");\n"
"    assert_eq!(report.visit_count, 1);\n"
"    assert_eq!(report.blood_pressure_change, None);\n"
"\n"
"    let report = bob.visit_doctor(Measurements {\n"
"        height: 156.1,\n"
"        blood_pressure: (115, 76),\n"
"    });\n"
"\n"
"    assert_eq!(report.visit_count, 2);\n"
"    assert_eq!(report.blood_pressure_change, Some((-5, -4)));\n"
"}\n"
"```"
msgstr ""
"```\n"
"\n"
"# Statystyki zdrowia\n"
"\n"
"Pracujesz nad wdro偶eniem systemu monitorowania stanu. W ramach tego ty\n"
"musz ledzi statystyki dotyczce zdrowia u偶ytkownik贸w.\n"
"\n"
"Zaczniesz od niekt贸rych funkcji skr贸towych w bloku `impl`, jak r贸wnie偶 "
"`U偶ytkownika`\n"
"definicja struktury. Twoim celem jest zaimplementowanie wygaszonych metod "
"na\n"
"`User` `struct` zdefiniowana w bloku `impl`.\n"
"\n"
"Skopiuj poni偶szy kod na <https://play.rust-lang.org/> i uzupenij brakujce\n"
"metody:\n"
"\n"
"```rust,should_panic\n"
"// TODO: usu to jak skoczysz implementacj.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"struct User {\n"
"    name: String,\n"
"    age: u32,\n"
"    weight: f32,\n"
"}\n"
"\n"
"impl User {\n"
"    pub fn new(name: String, age: u32, weight: f32) -> Self {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn name(&self) -> &str {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn age(&self) -> u32 {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn weight(&self) -> f32 {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn set_age(&mut self, new_age: u32) {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn set_weight(&mut self, new_weight: f32) {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    println!(\"Jestem {} i mam {} lat\", bob.name(), bob.age());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_weight() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.weight(), 155.2);\n"
"}\n"
"\n"
"# Health Statistics\n"
"\n"
"{{#include ../../../third_party/rust-on-exercism/health-statistics.md}}\n"
"\n"
"Copy the code below to <https://play.rust-lang.org/> and fill in the "
"missing\n"
"methods:\n"
"\n"
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"{{#include ../../../third_party/rust-on-exercism/health-statistics.rs}}\n"
"\n"
"fn main() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    println!(\"I'm {} and my age is {}\", bob.name(), bob.age());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_height() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.height(), 155.2);\n"
"}\n"
"\n"
"#[test]\n"
"fn test_set_age() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.age(), 32);\n"
"    bob.set_age(33);\n"
"    assert_eq!(bob.age(), 33);\n"
"}\n"
"\n"
"#[test]\n"
"fn test_visit() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.doctor_visits(), 0);\n"
"    let report = bob.visit_doctor(Measurements {\n"
"        height: 156.1,\n"
"        blood_pressure: (120, 80),\n"
"    });\n"
"    assert_eq!(report.patient_name, \"Bob\");\n"
"    assert_eq!(report.visit_count, 1);\n"
"    assert_eq!(report.blood_pressure_change, None);\n"
"\n"
"    let report = bob.visit_doctor(Measurements {\n"
"        height: 156.1,\n"
"        blood_pressure: (115, 76),\n"
"    });\n"
"\n"
"    assert_eq!(report.visit_count, 2);\n"
"    assert_eq!(report.blood_pressure_change, Some((-5, -4)));\n"
"}\n"
"```"

#: src/exercises/day-2/points-polygons.md:1
#, fuzzy
msgid "Polygon Struct"
msgstr "Struktura wielokta"

#: src/exercises/day-2/points-polygons.md:3
#, fuzzy
msgid ""
"We will create a `Polygon` struct which contain some points. Copy the code "
"below to <https://play.rust-lang.org/> and fill in the missing methods to "
"make the tests pass:"
msgstr ""
"Stworzymy struktur `Polygon` zawierajc kilka punkt贸w. Skopiuj poni偶szy "
"kod na <https://play.rust-lang.org/> i uzupenij brakujce metody, aby "
"utworzy plik testy przechodz:"

#: src/exercises/day-2/points-polygons.md:7 src/exercises/day-2/luhn.md:23
#: src/exercises/day-2/strings-iterators.md:12
msgid ""
"```rust\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"```"
msgstr ""
"```rust\n"
"// TODO: usu to jak skoczysz implementacj.\n"
"#![allow(unused_variables, dead_code)]\n"
"```"

#: src/exercises/day-2/points-polygons.md:11
msgid "pub struct Point { // add fields }"
msgstr "pub struct Point { // dodaj pola }"

#: src/exercises/day-2/points-polygons.md:15
msgid "impl Point { // add methods }"
msgstr "impl Point { // dodaj metody }"

#: src/exercises/day-2/points-polygons.md:19
msgid "pub struct Polygon { // add fields }"
msgstr "pub struct Polygon { // dodaj pola }"

#: src/exercises/day-2/points-polygons.md:23
msgid "impl Polygon { // add methods }"
msgstr "impl Polygon { // dodaj metody }"

#: src/exercises/day-2/points-polygons.md:27
msgid "pub struct Circle { // add fields }"
msgstr "pub struct Circle { // dodaj pola }"

#: src/exercises/day-2/points-polygons.md:31
msgid "impl Circle { // add methods }"
msgstr "impl Circle { // dodaj metody }"

#: src/exercises/day-2/points-polygons.md:35
msgid "pub enum Shape { Polygon(Polygon), Circle(Circle), }"
msgstr "pub enum Shape { Polygon(Polygon), Circle(Circle), }"

#: src/exercises/day-2/points-polygons.md:40 src/testing/test-modules.md:15
msgid "\\#\\[cfg(test)\\] mod tests { use super::\\*;"
msgstr "\\#\\[cfg(test)\\] mod tests { use super::\\*;"

#: src/exercises/day-2/points-polygons.md:44
#: src/exercises/day-2/solutions-morning.md:165
msgid ""
"```\n"
"fn round_two_digits(x: f64) -> f64 {\n"
"    (x * 100.0).round() / 100.0\n"
"}\n"
"```"
msgstr ""
"```\n"
"fn round_two_digits(x: f64) -> f64 {\n"
"    (x * 100.0).round() / 100.0\n"
"}\n"
"```"

#: src/exercises/day-2/points-polygons.md:48
#: src/exercises/day-2/solutions-morning.md:169
msgid ""
"```\n"
"#[test]\n"
"fn test_point_magnitude() {\n"
"    let p1 = Point::new(12, 13);\n"
"    assert_eq!(round_two_digits(p1.magnitude()), 17.69);\n"
"}\n"
"```"
msgstr ""
"```\n"
"#[test]\n"
"fn test_point_magnitude() {\n"
"    let p1 = Point::new(12, 13);\n"
"    assert_eq!(round_two_digits(p1.magnitude()), 17.69);\n"
"}\n"
"```"

#: src/exercises/day-2/points-polygons.md:54
#: src/exercises/day-2/solutions-morning.md:175
msgid ""
"```\n"
"#[test]\n"
"fn test_point_dist() {\n"
"    let p1 = Point::new(10, 10);\n"
"    let p2 = Point::new(14, 13);\n"
"    assert_eq!(round_two_digits(p1.dist(p2)), 5.00);\n"
"}\n"
"```"
msgstr ""
"```\n"
"#[test]\n"
"fn test_point_dist() {\n"
"    let p1 = Point::new(10, 10);\n"
"    let p2 = Point::new(14, 13);\n"
"    assert_eq!(round_two_digits(p1.dist(p2)), 5.00);\n"
"}\n"
"```"

#: src/exercises/day-2/points-polygons.md:61
#: src/exercises/day-2/solutions-morning.md:182
msgid ""
"```\n"
"#[test]\n"
"fn test_point_add() {\n"
"    let p1 = Point::new(16, 16);\n"
"    let p2 = p1 + Point::new(-4, 3);\n"
"    assert_eq!(p2, Point::new(12, 19));\n"
"}\n"
"```"
msgstr ""
"```\n"
"#[test]\n"
"fn test_point_add() {\n"
"    let p1 = Point::new(16, 16);\n"
"    let p2 = p1 + Point::new(-4, 3);\n"
"    assert_eq!(p2, Point::new(12, 19));\n"
"}\n"
"```"

#: src/exercises/day-2/points-polygons.md:68
#: src/exercises/day-2/solutions-morning.md:189
msgid ""
"```\n"
"#[test]\n"
"fn test_polygon_left_most_point() {\n"
"    let p1 = Point::new(12, 13);\n"
"    let p2 = Point::new(16, 16);\n"
"```"
msgstr ""
"```\n"
"#[test]\n"
"fn test_polygon_left_most_point() {\n"
"    let p1 = Point::new(12, 13);\n"
"    let p2 = Point::new(16, 16);\n"
"```"

#: src/exercises/day-2/points-polygons.md:73
#: src/exercises/day-2/solutions-morning.md:194
msgid ""
"```\n"
"    let mut poly = Polygon::new();\n"
"    poly.add_point(p1);\n"
"    poly.add_point(p2);\n"
"    assert_eq!(poly.left_most_point(), Some(p1));\n"
"}\n"
"```"
msgstr ""
"```\n"
"    let mut poly = Polygon::new();\n"
"    poly.add_point(p1);\n"
"    poly.add_point(p2);\n"
"    assert_eq!(poly.left_most_point(), Some(p1));\n"
"}\n"
"```"

#: src/exercises/day-2/points-polygons.md:79
#: src/exercises/day-2/solutions-morning.md:200
msgid ""
"```\n"
"#[test]\n"
"fn test_polygon_iter() {\n"
"    let p1 = Point::new(12, 13);\n"
"    let p2 = Point::new(16, 16);\n"
"```"
msgstr ""
"```\n"
"#[test]\n"
"fn test_polygon_iter() {\n"
"    let p1 = Point::new(12, 13);\n"
"    let p2 = Point::new(16, 16);\n"
"```"

#: src/exercises/day-2/points-polygons.md:84
#: src/exercises/day-2/solutions-morning.md:205
msgid ""
"```\n"
"    let mut poly = Polygon::new();\n"
"    poly.add_point(p1);\n"
"    poly.add_point(p2);\n"
"```"
msgstr ""
"```\n"
"    let mut poly = Polygon::new();\n"
"    poly.add_point(p1);\n"
"    poly.add_point(p2);\n"
"```"

#: src/exercises/day-2/points-polygons.md:88
#: src/exercises/day-2/solutions-morning.md:209
msgid ""
"```\n"
"    let points = poly.iter().cloned().collect::<Vec<_>>();\n"
"    assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);\n"
"}\n"
"```"
msgstr ""
"```\n"
"    let points = poly.iter().cloned().collect::<Vec<_>>();\n"
"    assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);\n"
"}\n"
"```"

#: src/exercises/day-2/points-polygons.md:92
#: src/exercises/day-2/solutions-morning.md:213
msgid ""
"```\n"
"#[test]\n"
"fn test_shape_perimeters() {\n"
"    let mut poly = Polygon::new();\n"
"    poly.add_point(Point::new(12, 13));\n"
"    poly.add_point(Point::new(17, 11));\n"
"    poly.add_point(Point::new(16, 16));\n"
"    let shapes = vec![\n"
"        Shape::from(poly),\n"
"        Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"    ];\n"
"    let perimeters = shapes\n"
"        .iter()\n"
"        .map(Shape::perimeter)\n"
"        .map(round_two_digits)\n"
"        .collect::<Vec<_>>();\n"
"    assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"}\n"
"```"
msgstr ""
"```\n"
"#[test]\n"
"fn test_shape_perimeters() {\n"
"    let mut poly = Polygon::new();\n"
"    poly.add_point(Point::new(12, 13));\n"
"    poly.add_point(Point::new(17, 11));\n"
"    poly.add_point(Point::new(16, 16));\n"
"    let shapes = vec![\n"
"        Shape::from(poly),\n"
"        Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"    ];\n"
"    let perimeters = shapes\n"
"        .iter()\n"
"        .map(Shape::perimeter)\n"
"        .map(round_two_digits)\n"
"        .collect::<Vec<_>>();\n"
"    assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"}\n"
"```"

#: src/exercises/day-2/points-polygons.md:111 src/exercises/day-2/luhn.md:68
msgid "\\#\\[allow(dead_code)\\] fn main() {}"
msgstr "\\#\\[allow(dead_code)\\] fn main() {}"

#: src/exercises/day-2/points-polygons.md:117
#, fuzzy
msgid ""
"Since the method signatures are missing from the problem statements, the key "
"part of the exercise is to specify those correctly. You don't have to modify "
"the tests."
msgstr ""
"Poniewa偶 w opisach problem贸w brakuje sygnatur metod, kluczowa cz "
"wiczenia polega na ich prawidowym okreleniu. Nie musisz modyfikowa "
"test贸w."

#: src/exercises/day-2/points-polygons.md:120
#, fuzzy
msgid "Other interesting parts of the exercise:"
msgstr "Inne ciekawe czci wiczenia:"

#: src/exercises/day-2/points-polygons.md:122
#, fuzzy
msgid ""
"Derive a `Copy` trait for some structs, as in tests the methods sometimes "
"don't borrow their arguments."
msgstr ""
"Wyprowad藕 cech `Kopiuj` dla niekt贸rych struktur, poniewa偶 w testach metody "
"czasami nie po偶yczaj swoich argument贸w."

#: src/exercises/day-2/points-polygons.md:123
#, fuzzy
msgid ""
"Discover that `Add` trait must be implemented for two objects to be addable "
"via \"+\". Note that we do not discuss generics until Day 3."
msgstr ""
"Odkryj, 偶e cecha `Dodaj` musi zosta zaimplementowana, aby dwa obiekty mo偶na "
"byo dodawa za pomoc +. Pamitaj, 偶e nie omawiamy lek贸w generycznych a偶 "
"do dnia 3."

#: src/control-flow.md:3
#, fuzzy
msgid ""
"As we have seen, `if` is an expression in Rust. It is used to conditionally "
"evaluate one of two blocks, but the blocks can have a value which then "
"becomes the value of the `if` expression. Other control flow expressions "
"work similarly in Rust."
msgstr ""
"Jak widzielimy, `if` jest wyra偶eniem w Rust. Su偶y do warunkowego oceni "
"jeden z dw贸ch blok贸w, ale bloki mog mie warto, kt贸ra nastpnie staje si "
"warto wyra偶enia `if`. Inne wyra偶enia przepywu sterowania dziaaj "
"podobnie w Rucie."

#: src/control-flow/blocks.md:3
#, fuzzy
msgid ""
"A block in Rust has a value and a type: the value is the last expression of "
"the block:"
msgstr "Blok w Rust ma warto i typ: warto jest ostatnim wyra偶eniem blok:"

#: src/control-flow/blocks.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x = {\n"
"        let y = 10;\n"
"        println!(\"y: {y}\");\n"
"        let z = {\n"
"            let w = {\n"
"                3 + 4\n"
"            };\n"
"            println!(\"w: {w}\");\n"
"            y * w\n"
"        };\n"
"        println!(\"z: {z}\");\n"
"        z - y\n"
"    };\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/blocks.md:25
#, fuzzy
msgid ""
"The same rule is used for functions: the value of the function body is the "
"return value:"
msgstr ""
"Ta sama regua jest u偶ywana dla funkcji: wartoci ciaa funkcji jest "
"zwracana warto:"

#: src/control-flow/blocks.md:28
msgid ""
"```rust,editable\n"
"fn double(x: i32) -> i32 {\n"
"    x + x\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/blocks.md:33
msgid "fn main() { println!(\"doubled: {}\", double(7)); }"
msgstr ""

#: src/control-flow/blocks.md:38
msgid ""
"However if the last expression ends with `;`, then the resulting value and "
"type is `()`."
msgstr ""

#: src/control-flow/blocks.md:43
#, fuzzy
msgid ""
"The point of this slide is to show that blocks have a type and value in "
"Rust. "
msgstr "Celem tego slajdu jest pokazanie, 偶e bloki maj typ i warto w Rust."

#: src/control-flow/blocks.md:44
#, fuzzy
msgid ""
"You can show how the value of the block changes by changing the last line in "
"the block. For instance, adding/removing a semicolon or using a `return`."
msgstr ""
"Mo偶esz pokaza, jak zmienia si warto bloku, zmieniajc ostatni lini w "
"bloku. Na przykad dodanie/usunicie rednika lub u偶ycie zwrotu."

#: src/control-flow/if-expressions.md:1
#, fuzzy
msgid "`if` expressions"
msgstr "wyra偶enia `jeli`"

#: src/control-flow/if-expressions.md:3
#, fuzzy
msgid "You use `if` very similarly to how you would in other languages:"
msgstr "U偶ywasz `if` bardzo podobnie jak w innych jzykach:"

#: src/control-flow/if-expressions.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    if x % 2 == 0 {\n"
"        x = x / 2;\n"
"    } else {\n"
"        x = 3 * x + 1;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/if-expressions.md:16
#, fuzzy
msgid ""
"In addition, you can use it as an expression. This does the same as above:"
msgstr "Ponadto mo偶esz u偶y go jako wyra偶enia. Robi to samo, co powy偶ej:"

#: src/control-flow/if-expressions.md:18
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    x = if x % 2 == 0 {\n"
"        x / 2\n"
"    } else {\n"
"        3 * x + 1\n"
"    };\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/if-expressions.md:31
msgid ""
"Because `if` is an expression and must have a particular type, both of its "
"branch blocks must have the same type. Consider showing what happens if you "
"add `;` after `x / 2` in the second example."
msgstr ""

#: src/control-flow/if-let-expressions.md:1
#, fuzzy
msgid "`if let` expressions"
msgstr "wyra偶enia `if let`"

#: src/control-flow/if-let-expressions.md:3
#, fuzzy
msgid "If you want to match a value against a pattern, you can use `if let`:"
msgstr "Jeli chcesz dopasowa warto do wzorca, mo偶esz u偶y `if let`:"

#: src/control-flow/if-let-expressions.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let arg = std::env::args().next();\n"
"    if let Some(value) = arg {\n"
"        println!(\"Program name: {value}\");\n"
"    } else {\n"
"        println!(\"Missing name?\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/if-let-expressions.md:16
#: src/control-flow/while-let-expressions.md:21
#: src/control-flow/match-expressions.md:22
#, fuzzy
msgid ""
"See [pattern matching](../pattern-matching.md) for more details on patterns "
"in Rust."
msgstr ""
"Zobacz [dopasowywanie wzorc贸w](../pattern-matching.md), aby uzyska wicej "
"informacji na temat wzorc贸w w Rdza."

#: src/control-flow/if-let-expressions.md:21
#, fuzzy
msgid ""
"`if let` can be more concise than `match`, e.g., when only one case is "
"interesting. In contrast, `match` requires all branches to be covered."
msgstr ""
"`if let` mo偶e by bardziej zwize ni偶 `dopasuj`, np. gdy interesujcy jest "
"tylko jeden przypadek. Natomiast dopasowanie wymaga pokrycia wszystkich "
"gazi."

#: src/control-flow/if-let-expressions.md:22
#, fuzzy
msgid ""
"For the similar use case consider demonstrating a newly stabilized [`let "
"else`](https://github.com/rust-lang/rust/pull/93628) feature."
msgstr ""
"W przypadku podobnego przypadku rozwa偶 zademonstrowanie nowo ustabilizowanej "
"funkcji [`let else`](https://github.com/rust-lang/rust/pull/93628)."

#: src/control-flow/if-let-expressions.md:23
#, fuzzy
msgid "A common usage is handling `Some` values when working with `Option`."
msgstr ""
"Typowym zastosowaniem jest obsuga wartoci `Some` podczas pracy z `Option`."

#: src/control-flow/if-let-expressions.md:24
#, fuzzy
msgid ""
"Unlike `match`, `if let` does not support guard clauses for pattern matching."
msgstr ""
"W przeciwiestwie do `match`, `if let` nie obsuguje klauzul ochronnych dla "
"dopasowywania wzorc贸w."

#: src/control-flow/while-expressions.md:1
#, fuzzy
msgid "`while` expressions"
msgstr "Wyra偶enia `while`"

#: src/control-flow/while-expressions.md:3
#, fuzzy
msgid "The `while` keyword works very similar to other languages:"
msgstr "Sowo kluczowe `while` dziaa bardzo podobnie do innych jzyk贸w:"

#: src/control-flow/while-expressions.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    while x != 1 {\n"
"        x = if x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"    }\n"
"    println!(\"Final x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/while-let-expressions.md:1
#, fuzzy
msgid "`while let` expressions"
msgstr "wyra偶enia `while let`"

#: src/control-flow/while-let-expressions.md:3
#, fuzzy
msgid ""
"Like with `if`, there is a `while let` variant which repeatedly tests a "
"value against a pattern:"
msgstr ""
"Podobnie jak w przypadku `if`, istnieje wariant `while let`, kt贸ry "
"wielokrotnie sprawdza warto wbrew wzorowi:"

#: src/control-flow/while-let-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();\n"
"```"
msgstr ""

#: src/control-flow/while-let-expressions.md:11
msgid ""
"```\n"
"while let Some(x) = iter.next() {\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/while-let-expressions.md:17
#, fuzzy
msgid ""
"Here the iterator returned by `v.iter()` will return a `Option<i32>` on "
"every call to `next()`. It returns `Some(x)` until it is done, after which "
"it will return `None`. The `while let` lets us keep iterating through all "
"items."
msgstr ""
"Tutaj iterator zwr贸cony przez `v.iter()` zwr贸ci `Option<i32>` przy ka偶dym "
"wywoanie funkcji nastpny(). Zwraca `Some(x)` dop贸ki nie skoczy, po czym "
"to zrobi zwr贸 Brak. Polecenie while let pozwala nam przeglda "
"wszystkie elementy."

#: src/control-flow/while-let-expressions.md:27
#, fuzzy
msgid ""
"Point out that the `while let` loop will keep going as long as the value "
"matches the pattern."
msgstr ""
"Zwr贸 uwag, 偶e ptla while let bdzie dziaa tak dugo, jak dugo "
"warto bdzie pasowa do wzorca."

#: src/control-flow/while-let-expressions.md:28
#, fuzzy
msgid ""
"You could rewrite the `while let` loop as an infinite loop with an if "
"statement that breaks when there is no value to unwrap for `iter.next()`. "
"The `while let` provides syntactic sugar for the above scenario."
msgstr ""
"Mo偶esz przepisa ptl `while let` jako ptl nieskoczon z instrukcj if, "
"kt贸ra przerywa dziaanie, gdy nie ma wartoci do rozpakowania dla `iter."
"next()`. Opcja `while let` zapewnia cukier skadniowy dla powy偶szego "
"scenariusza."

#: src/control-flow/for-expressions.md:1
#, fuzzy
msgid "`for` expressions"
msgstr "wyra偶enia `for`"

#: src/control-flow/for-expressions.md:3
#, fuzzy
msgid ""
"The `for` expression is closely related to the `while let` expression. It "
"will automatically call `into_iter()` on the expression and then iterate "
"over it:"
msgstr ""
"Wyra偶enie `for` jest blisko spokrewnione z wyra偶eniem `while let`. To bdzie "
"automatycznie wywoaj `into_iter()` na wyra偶eniu, a nastpnie wykonaj "
"iteracj:"

#: src/control-flow/for-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"```"
msgstr ""

#: src/control-flow/for-expressions.md:10
msgid ""
"```\n"
"for x in v {\n"
"    println!(\"x: {x}\");\n"
"}\n"
"\n"
"for i in (0..10).step_by(2) {\n"
"    println!(\"i: {i}\");\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/for-expressions.md:20
#, fuzzy
msgid "You can use `break` and `continue` here as usual."
msgstr "Mo偶esz u偶y `break` i `continue` tutaj jak zwykle."

#: src/control-flow/for-expressions.md:24
#, fuzzy
msgid "Index iteration is not a special syntax in Rust for just that case."
msgstr ""
"Iteracja indeksu nie jest specjaln skadni w Rust tylko w tym przypadku."

#: src/control-flow/for-expressions.md:25
#, fuzzy
msgid "`(0..10)` is a range that implements an `Iterator` trait. "
msgstr "`(0..10)` to zakres implementujcy cech `Iterator`."

#: src/control-flow/for-expressions.md:26
#, fuzzy
msgid ""
"`step_by` is a method that returns another `Iterator` that skips every other "
"element. "
msgstr ""
"`step_by` to metoda, kt贸ra zwraca kolejny `Iterator`, kt贸ry pomija ka偶dy "
"inny element."

#: src/control-flow/for-expressions.md:27
#, fuzzy
msgid ""
"Modify the elements in the vector and explain the compiler errors. Change "
"vector `v` to be mutable and the for loop to `for x in v.iter_mut()`."
msgstr ""
"Zmodyfikuj elementy wektora i wyjanij bdy kompilatora. Zmie wektor `v` "
"na zmienny, a ptl for na `for x w v.iter_mut()`."

#: src/control-flow/loop-expressions.md:1
#, fuzzy
msgid "`loop` expressions"
msgstr "wyra偶enia `ptli`"

#: src/control-flow/loop-expressions.md:3
#, fuzzy
msgid ""
"Finally, there is a `loop` keyword which creates an endless loop. Here you "
"must either `break` or `return` to stop the loop:"
msgstr ""
"Wreszcie istnieje sowo kluczowe `loop`, kt贸re tworzy nieskoczon ptl. "
"Tutaj musisz albo `break` albo `return`, aby zatrzyma ptl:"

#: src/control-flow/loop-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    loop {\n"
"        x = if x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"        if x == 1 {\n"
"            break;\n"
"        }\n"
"    }\n"
"    println!(\"Final x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/loop-expressions.md:25
#, fuzzy
msgid "Break the `loop` with a value (e.g. `break 8`) and print it out."
msgstr "Przerwij `ptl` wartoci (np. `break 8`) i wypisz j."

#: src/control-flow/match-expressions.md:1
#, fuzzy
msgid "`match` expressions"
msgstr "`dopasuj` wyra偶enia"

#: src/control-flow/match-expressions.md:3
#, fuzzy
msgid ""
"The `match` keyword is used to match a value against one or more patterns. "
"In that sense, it works like a series of `if let` expressions:"
msgstr ""
"Sowo kluczowe `match` su偶y do dopasowania wartoci do jednego lub wicej "
"wzorc贸w. W w tym sensie dziaa jak seria wyra偶e if let:"

#: src/control-flow/match-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    match std::env::args().next().as_deref() {\n"
"        Some(\"cat\") => println!(\"Will do cat things\"),\n"
"        Some(\"ls\")  => println!(\"Will ls some files\"),\n"
"        Some(\"mv\")  => println!(\"Let's move some files\"),\n"
"        Some(\"rm\")  => println!(\"Uh, dangerous!\"),\n"
"        None        => println!(\"Hmm, no program name?\"),\n"
"        _           => println!(\"Unknown program name!\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/match-expressions.md:19
#, fuzzy
msgid ""
"Like `if let`, each match arm must have the same type. The type is the last "
"expression of the block, if any. In the example above, the type is `()`."
msgstr ""
"Podobnie jak `if let`, ka偶de rami dopasowania musi by tego samego typu. "
"Typ jest ostatni wyra偶enie bloku, jeli istnieje. W powy偶szym przykadzie "
"typem jest `()`."

#: src/control-flow/match-expressions.md:27
#, fuzzy
msgid "Save the match expression to a variable and print it out."
msgstr "Zapisz wyra偶enie dopasowania do zmiennej i wydrukuj je."

#: src/control-flow/match-expressions.md:28
#, fuzzy
msgid "Remove `.as_deref()` and explain the error."
msgstr "Usu `.as_deref()` i wyjanij bd."

#: src/control-flow/match-expressions.md:29
#, fuzzy
msgid ""
"`std::env::args().next()` returns an `Option<String>`, but we cannot match "
"against `String`."
msgstr ""
"`std::env::args().next()` zwraca `Option<String>`, ale nie mo偶emy dopasowa "
"do `String`."

#: src/control-flow/match-expressions.md:30
#, fuzzy
msgid ""
"`as_deref()` transforms an `Option<T>` to `Option<&T::Target>`. In our case, "
"this turns `Option<String>` into `Option<&str>`."
msgstr ""
"`as_deref()` przeksztaca `Option<T>` w `Option<&T::Target>`. W naszym "
"przypadku zmienia to `Option<String>` w `Option<&str>`."

#: src/control-flow/match-expressions.md:31
#, fuzzy
msgid ""
"We can now use pattern matching to match against the `&str` inside `Option`."
msgstr ""
"Mo偶emy teraz u偶y dopasowywania wzorc贸w, aby dopasowa si do `&str` "
"wewntrz `Option`."

#: src/control-flow/break-continue.md:1
#, fuzzy
msgid "`break` and `continue`"
msgstr "`przerwij` i `kontynuuj`"

#: src/control-flow/break-continue.md:3
#, fuzzy
msgid ""
"If you want to exit a loop early, use `break`, if you want to immediately "
"start the next iteration use `continue`. Both `continue` and `break` can "
"optionally take a label argument which is used to break out of nested loops:"
msgstr ""
"Jeli chcesz wyj z ptli wczeniej, u偶yj `break`, jeli chcesz natychmiast "
"rozpocz w nastpnej iteracji u偶yj polecenia kontynuuj. Zar贸wno "
"`continue`, jak i `break` mog opcjonalnie we藕 argument etykiety, kt贸ry "
"su偶y do wyrwania si z zagnie偶d偶onych ptli:"

#: src/control-flow/break-continue.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();\n"
"    'outer: while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"        let mut i = 0;\n"
"        while i < x {\n"
"            println!(\"x: {x}, i: {i}\");\n"
"            i += 1;\n"
"            if i == 3 {\n"
"                break 'outer;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/break-continue.md:25
#, fuzzy
msgid ""
"In this case we break the outer loop after 3 iterations of the inner loop."
msgstr ""
"W tym przypadku przerywamy zewntrzn ptl po 3 iteracjach wewntrznej "
"ptli."

#: src/std.md:3
#, fuzzy
msgid ""
"Rust comes with a standard library which helps establish a set of common "
"types used by Rust library and programs. This way, two libraries can work "
"together smoothly because they both use the same `String` type."
msgstr ""
"Rust jest dostarczany ze standardow bibliotek, kt贸ra pomaga ustali zestaw "
"typowych typ贸w u偶ywany przez bibliotek i programy Rusta. W ten spos贸b dwie "
"biblioteki mog ze sob wsp贸pracowa pynnie, poniewa偶 oba u偶ywaj tego "
"samego typu `String`."

#: src/std.md:7
#, fuzzy
msgid "The common vocabulary types include:"
msgstr "Typowe typy sownictwa obejmuj:"

#: src/std.md:9
msgid ""
"[`Option` and `Result`](std/option-result.md) types: used for optional "
"values and [error handling](error-handling.md)."
msgstr ""
"Typy [`Option` i `Result`](std/option-result.md): u偶ywane dla wartoci "
"opcjonalnych i [obsugi bd贸w](error-handling.md)."

#: src/std.md:12
#, fuzzy
msgid "[`String`](std/string.md): the default string type used for owned data."
msgstr ""
"[`String`](std/string.md): domylny typ cigu u偶ywany dla posiadanych danych."

#: src/std.md:14
#, fuzzy
msgid "[`Vec`](std/vec.md): a standard extensible vector."
msgstr "[`Vec`](std/vec.md): standardowy rozszerzalny wektor."

#: src/std.md:16
#, fuzzy
msgid ""
"[`HashMap`](std/hashmap.md): a hash map type with a configurable hashing "
"algorithm."
msgstr ""
"[`HashMap`](std/hashmap.md): typ mapy mieszajcej z konfigurowalnym "
"haszowaniem algorytm."

#: src/std.md:19
#, fuzzy
msgid "[`Box`](std/box.md): an owned pointer for heap-allocated data."
msgstr ""
"[`Box`](std/box.md): wasny wska藕nik dla danych przydzielonych na stercie."

#: src/std.md:21
#, fuzzy
msgid ""
"[`Rc`](std/rc.md): a shared reference-counted pointer for heap-allocated "
"data."
msgstr ""
"[`Rc`](std/rc.md): wsp贸dzielony wska藕nik zliczania odwoa dla danych "
"alokowanych na stercie."

#: src/std.md:25
#, fuzzy
msgid ""
"In fact, Rust contains several layers of the Standard Library: `core`, "
"`alloc` and `std`. "
msgstr ""
"W rzeczywistoci Rust zawiera kilka warstw Biblioteki Standardowej: `core`, "
"`alloc` i `std`."

#: src/std.md:26
#, fuzzy
msgid ""
"`core` includes the most basic types and functions that don't depend on "
"`libc`, allocator or even the presence of an operating system. "
msgstr ""
"`core` zawiera najbardziej podstawowe typy i funkcje, kt贸re nie zale偶 od "
"`libc`, alokatora lub nawet obecno systemu operacyjnego."

#: src/std.md:28
#, fuzzy
msgid ""
"`alloc` includes types which require a global heap allocator, such as `Vec`, "
"`Box` and `Arc`."
msgstr ""
"`alloc` obejmuje typy, kt贸re wymagaj globalnego alokatora sterty, takie jak "
"`Vec`, `Box` i `Arc`."

#: src/std.md:29
#, fuzzy
msgid ""
"Embedded Rust applications often only use `core`, and sometimes `alloc`."
msgstr ""
"Aplikacje Embedded Rust czsto u偶ywaj tylko `core`, a czasami `alloc`."

#: src/std/option-result.md:1
msgid "`Option` and `Result`"
msgstr "`Option` i `Result`"

#: src/std/option-result.md:3
#, fuzzy
msgid "The types represent optional data:"
msgstr "Typy reprezentuj dane opcjonalne:"

#: src/std/option-result.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let numbers = vec![10, 20, 30];\n"
"    let first: Option<&i8> = numbers.first();\n"
"    println!(\"first: {first:?}\");\n"
"```"
msgstr ""

#: src/std/option-result.md:11
msgid ""
"```\n"
"let idx: Result<usize, usize> = numbers.binary_search(&10);\n"
"println!(\"idx: {idx:?}\");\n"
"```"
msgstr ""

#: src/std/option-result.md:18
#, fuzzy
msgid "`Option` and `Result` are widely used not just in the standard library."
msgstr ""
"`Opcja` i `Wynik` s szeroko stosowane nie tylko w standardowej bibliotece."

#: src/std/option-result.md:19
#, fuzzy
msgid "`Option<&T>` has zero space overhead compared to `&T`."
msgstr "`Option<&T>` ma zerowy narzut przestrzeni w por贸wnaniu z `&T`."

#: src/std/option-result.md:20
#, fuzzy
msgid ""
"`Result` is the standard type to implement error handling as we will see on "
"Day 3."
msgstr ""
"`Result` to standardowy typ implementacji obsugi bd贸w, jak zobaczymy w "
"dniu 3."

#: src/std/option-result.md:21
#, fuzzy
msgid "`binary_search` returns `Result<usize, usize>`."
msgstr "`binary_search` zwraca `Result<usize, use>`."

#: src/std/option-result.md:22
#, fuzzy
msgid "If found, `Result::Ok` holds the index where the element is found."
msgstr ""
"Jeli zostanie znaleziony, `Result::Ok` zawiera indeks, w kt贸rym element "
"zosta znaleziony."

#: src/std/option-result.md:23
#, fuzzy
msgid ""
"Otherwise, `Result::Err` contains the index where such an element should be "
"inserted."
msgstr ""
"W przeciwnym razie `Result::Err` zawiera indeks, w kt贸rym taki element "
"powinien zosta wstawiony."

#: src/std/string.md:3
#, fuzzy
msgid ""
"[`String`](https://doc.rust-lang.org/std/string/struct.String.html) is the "
"standard heap-allocated growable UTF-8 string buffer:"
msgstr ""
"[`String`](https://doc.rust-lang.org/std/string/struct.String.html) to "
"standardowy bufor cig贸w znak贸w UTF-8 przydzielony na stercie:"

#: src/std/string.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::new();\n"
"    s1.push_str(\"Hello\");\n"
"    println!(\"s1: len = {}, capacity = {}\", s1.len(), s1.capacity());\n"
"```"
msgstr ""

#: src/std/string.md:11
msgid ""
"```\n"
"let mut s2 = String::with_capacity(s1.len() + 1);\n"
"s2.push_str(&s1);\n"
"s2.push('!');\n"
"println!(\"s2: len = {}, capacity = {}\", s2.len(), s2.capacity());\n"
"```"
msgstr ""

#: src/std/string.md:16
msgid ""
"```\n"
"let s3 = String::from(\"\");\n"
"println!(\"s3: len = {}, number of chars = {}\", s3.len(),\n"
"         s3.chars().count());\n"
"```"
msgstr ""

#: src/std/string.md:22
#, fuzzy
msgid ""
"`String` implements [`Deref<Target = str>`](https://doc.rust-lang.org/std/"
"string/struct.String.html#deref-methods-str), which means that you can call "
"all `str` methods on a `String`."
msgstr ""
"`String` implementuje [`Deref<Target = str>`](https://doc.rust-lang.org/std/"
"string/struct.String.html#deref-methods-str), co oznacza, 偶e mo偶esz wywoa "
"wszystkie Metody `str` na `Stringu`."

#: src/std/string.md:30
msgid ""
"`String::new` returns a new empty string, use `String::with capacity` when "
"you know how much data you want to push to the string."
msgstr ""

#: src/std/string.md:31
msgid ""
"`String::len` returns the size of the `String` in bytes (which can be "
"different from its length in characters)."
msgstr ""

#: src/std/string.md:32
msgid ""
"`String::chars` returns an iterator over the actual characters. Note that a "
"`char` can be different from what a human will consider a \"character\" due "
"to [grapheme clusters](https://docs.rs/unicode-segmentation/latest/"
"unicode_segmentation/struct.Graphemes.html)."
msgstr ""

#: src/std/string.md:33
msgid ""
"When people refer to strings they could either be talking about `&str` or "
"`String`."
msgstr ""

#: src/std/string.md:34
msgid ""
"When a type implements `Deref<Target = T>`, the compiler will let you "
"transparently call methods from `T`."
msgstr ""

#: src/std/string.md:35
msgid ""
"`String` implements `Deref<Target = str>` which transparently gives it "
"access to `str`'s methods."
msgstr ""

#: src/std/string.md:36
msgid "Write and compare `let s3 = s1.deref();` and  `let s3 = &*s1`;."
msgstr ""

#: src/std/string.md:37
msgid ""
"`String` is implemented as a wrapper around a vector of bytes, many of the "
"operations you see supported on vectors are also supported on `String`, but "
"with some extra guarantees."
msgstr ""

#: src/std/string.md:38
msgid ""
"Compare the different ways to inde a Strings by using `s3[i]` and `s3.chars."
"nth(i).unwrap()` where `i` is in-bound, out-of-bounds, and \"on\" the flag "
"unicode character."
msgstr ""

#: src/std/vec.md:1
#, fuzzy
msgid "`Vec`"
msgstr "`Vec`"

#: src/std/vec.md:3
#, fuzzy
msgid ""
"[`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html) is the standard "
"resizable heap-allocated buffer:"
msgstr ""
"[`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html) to standardowy "
"bufor alokowany na stercie o zmiennym rozmiarze:"

#: src/std/vec.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v1 = Vec::new();\n"
"    v1.push(42);\n"
"    println!(\"v1: len = {}, capacity = {}\", v1.len(), v1.capacity());\n"
"```"
msgstr ""

#: src/std/vec.md:11
msgid ""
"```\n"
"let mut v2 = Vec::with_capacity(v1.len() + 1);\n"
"v2.extend(v1.iter());\n"
"v2.push(9999);\n"
"println!(\"v2: len = {}, capacity = {}\", v2.len(), v2.capacity());\n"
"```"
msgstr ""

#: src/std/vec.md:16
msgid ""
"```\n"
"// Canonical macro to initialize a vector with elements.\n"
"let mut v3 = vec![0, 0, 1, 2, 3, 4];\n"
"```"
msgstr ""

#: src/std/vec.md:19
msgid ""
"```\n"
"// Retain only the even elements.\n"
"v3.retain(|x| x % 2 == 0);\n"
"println!(\"{v3:?}\");\n"
"```"
msgstr ""

#: src/std/vec.md:23
msgid ""
"```\n"
"// Remove consecutive duplicates.\n"
"v3.dedup();\n"
"println!(\"{v3:?}\");\n"
"```"
msgstr ""

#: src/std/vec.md:29
#, fuzzy
msgid ""
"`Vec` implements [`Deref<Target = [T]>`](https://doc.rust-lang.org/std/vec/"
"struct.Vec.html#deref-methods-[T]), which means that you can call slice "
"methods on a `Vec`."
msgstr ""
"`Vec` implementuje [`Deref<Target = [T]>`](https://doc.rust-lang.org/std/vec/"
"struct.Vec.html#deref-methods-[T]), co oznacza, 偶e mo偶esz wywoa slice "
"metody na `Vec`."

#: src/std/vec.md:37
msgid ""
"`Vec` is a type of collection, along with `String` and `HashMap`. The data "
"it contains is stored on the heap. This means the amount of data doesn't "
"need to be  known at compile time. It can grow or shrink at runtime."
msgstr ""

#: src/std/vec.md:40
msgid ""
"Notice how `Vec<T>` is a generic type too, but you don't have to specify `T` "
"explicitly. As always with Rust type inference, the `T` was established "
"during the first `push` call."
msgstr ""

#: src/std/vec.md:42
msgid ""
"`vec![...]` is a canonical macro to use instead of `Vec::new()` and it "
"supports adding initial elements to the vector."
msgstr ""

#: src/std/vec.md:44
msgid ""
"To index the vector you use `[` `]`, but they will panic if out of bounds. "
"Alternatively, using `get` will return an `Option`. The `pop` function will "
"remove the last element."
msgstr ""

#: src/std/vec.md:46
msgid ""
"Show iterating over a vector and mutating the value: `for e in &mut v { *e "
"+= 50; }`"
msgstr ""

#: src/std/hashmap.md:1
#, fuzzy
msgid "`HashMap`"
msgstr "`HashMap`"

#: src/std/hashmap.md:3
#, fuzzy
msgid "Standard hash map with protection against HashDoS attacks:"
msgstr "Standardowa mapa haszujca z ochron przed atakami HashDoS:"

#: src/std/hashmap.md:5
msgid ""
"```rust,editable\n"
"use std::collections::HashMap;\n"
"```"
msgstr ""

#: src/std/hashmap.md:8
msgid ""
"fn main() { let mut page_counts = HashMap::new(); page_counts."
"insert(\"Adventures of Huckleberry Finn\".to_string(), 207); page_counts."
"insert(\"Grimms' Fairy Tales\".to_string(), 751); page_counts.insert(\"Pride "
"and Prejudice\".to_string(), 303);"
msgstr ""

#: src/std/hashmap.md:14
msgid ""
"```\n"
"if !page_counts.contains_key(\"Les Mis茅rables\") {\n"
"    println!(\"We know about {} books, but not Les Mis茅rables.\",\n"
"             page_counts.len());\n"
"}\n"
"```"
msgstr ""

#: src/std/hashmap.md:19
#, fuzzy
msgid ""
"```\n"
"for book in [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"] "
"{\n"
"    match page_counts.get(book) {\n"
"        Some(count) => println!(\"{book}: {count} pages\"),\n"
"        None => println!(\"{book} is unknown.\")\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```\n"
"za ksi偶k w [\"Duma i uprzedzenie\", \"Alicja w Krainie Czar贸w\"] {\n"
"    dopasuj page_counts.get(book) {\n"
"        Some(count) => println!(\"{ksi偶ka}: {count} stron\"),\n"
"        Brak => println!(\"{ksi偶ka} jest nieznana.\")\n"
"    }\n"
"}\n"
"```"

#: src/std/hashmap.md:26
msgid ""
"```\n"
"// Use the .entry() method to insert a value if nothing is found.\n"
"for book in [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"] "
"{\n"
"    let page_count: &mut i32 = page_counts.entry(book.to_string())."
"or_insert(0);\n"
"    *page_count += 1;\n"
"}\n"
"```"
msgstr ""

#: src/std/hashmap.md:32
msgid ""
"```\n"
"println!(\"{page_counts:#?}\");\n"
"```"
msgstr ""

#: src/std/hashmap.md:38
#, fuzzy
msgid ""
"`HashMap` is not defined in the prelude and needs to be brought into scope."
msgstr ""
"`HashMap` nie jest zdefiniowany we wstpie i musi zosta uwzgldniony w "
"zakresie."

#: src/std/hashmap.md:39
#, fuzzy
msgid ""
"Try the following lines of code. The first line will see if a book is in the "
"hashmap and if not return an alternative value. The second line will insert "
"the alternative value in the hashmap if the book is not found."
msgstr ""
"Wypr贸buj nastpujce wiersze kodu. Pierwsza linia poka偶e, czy ksi偶ka "
"znajduje si w mapie skr贸t贸w, a jeli nie, zwr贸ci warto alternatywn. "
"Drugi wiersz wstawi alternatywn warto do mapy skr贸t贸w, jeli ksi偶ka nie "
"zostanie znaleziona."

#: src/std/hashmap.md:41
msgid ""
"```rust,ignore\n"
"let pc1 = page_counts\n"
"    .get(\"Harry Potter and the Sorcerer's Stone \")\n"
"    .unwrap_or(&336);\n"
"let pc2 = page_counts\n"
"    .entry(\"The Hunger Games\".to_string())\n"
"    .or_insert(374);\n"
"```"
msgstr ""

#: src/std/hashmap.md:49
msgid "Unlike `vec!`, there is unfortunately no standard `hashmap!` macro."
msgstr ""

#: src/std/hashmap.md:50
msgid ""
"Although, since Rust 1.56, HashMap implements [`From<[(K, V); N]>`](https://"
"doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#impl-"
"From%3C%5B(K%2C%20V)%3B%20N%5D%3E-for-"
"HashMap%3CK%2C%20V%2C%20RandomState%3E), which allows us to easily "
"initialize a hash map from a literal array:"
msgstr ""

#: src/std/hashmap.md:52
msgid ""
"```rust,ignore\n"
"let page_counts = HashMap::from([\n"
"  (\"Harry Potter and the Sorcerer's Stone\".to_string(), 336),\n"
"  (\"The Hunger Games\".to_string(), 374),\n"
"]);\n"
"```"
msgstr ""

#: src/std/hashmap.md:59
#, fuzzy
msgid ""
"Alternatively HashMap can be built from any `Iterator` which yields key-"
"value tuples."
msgstr ""
"Alternatywnie HashMap mo偶na zbudowa z dowolnego `Iteratora`, kt贸ry daje "
"krotki klucz-warto."

#: src/std/hashmap.md:60
#, fuzzy
msgid ""
"We are showing `HashMap<String, i32>`, and avoid using `&str` as key to make "
"examples easier. Using references in collections can, of course, be done, "
"but it can lead into complications with the borrow checker."
msgstr ""
"Pokazujemy `HashMap<String, i32>` i unikamy u偶ywania `&str` jako klucza, aby "
"uatwi przykady. Korzystanie z referencji w kolekcjach jest oczywicie "
"mo偶liwe, ale mo偶e to prowadzi do komplikacji z sprawdzaniem po偶yczek."

#: src/std/hashmap.md:62
#, fuzzy
msgid ""
"Try removing `to_string()` from the example above and see if it still "
"compiles. Where do you think we might run into issues?"
msgstr ""
"Spr贸buj usun `to_string()` z powy偶szego przykadu i sprawd藕, czy nadal si "
"kompiluje. Jak mylisz, gdzie mo偶emy napotka problemy?"

#: src/std/box.md:1
#, fuzzy
msgid "`Box`"
msgstr "`Pudeko`"

#: src/std/box.md:3
#, fuzzy
msgid ""
"[`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) is an owned "
"pointer to data on the heap:"
msgstr ""
"[`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) jest posiadanym "
"wska藕nikiem do danych na stercie:"

#: src/std/box.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let five = Box::new(5);\n"
"    println!(\"five: {}\", *five);\n"
"}\n"
"```"
msgstr ""

#: src/std/box.md:13
msgid ""
"```bob\n"
" Stack                     Heap\n"
".- - - - - - -.     .- - - - - - -.\n"
":             :     :             :\n"
":    five     :     :             :\n"
":   +-----+   :     :   +-----+   :\n"
":   | o---|---+-----+-->|  5  |   :\n"
":   +-----+   :     :   +-----+   :\n"
":             :     :             :\n"
":             :     :             :\n"
"`- - - - - - -'     `- - - - - - -'\n"
"```"
msgstr ""

#: src/std/box.md:26
#, fuzzy
msgid ""
"`Box<T>` implements `Deref<Target = T>`, which means that you can [call "
"methods from `T` directly on a `Box<T>`](https://doc.rust-lang.org/std/ops/"
"trait.Deref.html#more-on-deref-coercion)."
msgstr ""
"`Box<T>` implementuje `Deref<Target = T>`, co oznacza, 偶e mo偶esz [wywoywa "
"metody z `T` bezporednio na `Box<T>`](https://doc.rust-lang.org/std/ops/"
"trait.Deref.html#more-on-deref-coercion)."

#: src/std/box.md:34
#, fuzzy
msgid ""
"`Box` is like `std::unique_ptr` in C++, except that it's guaranteed to be "
"not null. "
msgstr ""
"`Box` jest jak `std::unique_ptr` w C++, z t r贸偶nic, 偶e nie jest puste."

#: src/std/box.md:35
#, fuzzy
msgid ""
"In the above example, you can even leave out the `*` in the `println!` "
"statement thanks to `Deref`. "
msgstr ""
"W powy偶szym przykadzie mo偶esz nawet pomin `*` w instrukcji `println!` "
"dziki `Deref`."

#: src/std/box.md:36
#, fuzzy
msgid "A `Box` can be useful when you:"
msgstr "Pudeko mo偶e by przydatne, gdy:"

#: src/std/box.md:37
#, fuzzy
msgid ""
"have a type whose size that can't be known at compile time, but the Rust "
"compiler wants to know an exact size."
msgstr ""
"mie typ, kt贸rego rozmiar nie mo偶e by znany w czasie kompilacji, ale "
"kompilator Rust chce zna dokadny rozmiar."

#: src/std/box.md:38
#, fuzzy
msgid ""
"want to transfer ownership of a large amount of data. To avoid copying large "
"amounts of data on the stack, instead store the data on the heap in a `Box` "
"so only the pointer is moved."
msgstr ""
"chcesz przenie wasno du偶ej iloci danych. Aby unikn kopiowania du偶ych "
"iloci danych na stosie, zamiast tego przechowuj dane na stercie w `Box`, "
"tak aby przesuwany by tylko wska藕nik."

#: src/std/box-recursive.md:1
#, fuzzy
msgid "Box with Recursive Data Structures"
msgstr "Pudeko z rekurencyjnymi strukturami danych"

#: src/std/box-recursive.md:3
#, fuzzy
msgid ""
"Recursive data types or data types with dynamic sizes need to use a `Box`:"
msgstr ""
"Rekurencyjne typy danych lub typy danych o dynamicznych rozmiarach musz "
"u偶ywa `Box`:"

#: src/std/box-recursive.md:5 src/std/box-niche.md:3
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"enum List<T> {\n"
"    Cons(T, Box<List<T>>),\n"
"    Nil,\n"
"}\n"
"```"
msgstr ""

#: src/std/box-recursive.md:12 src/std/box-niche.md:10
msgid "fn main() { let list: List"
msgstr ""

#: src/std/box-recursive.md:13 src/std/box-niche.md:11
msgid ""
" = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil)))); println!"
"(\"{list:?}\"); }"
msgstr ""

#: src/std/box-recursive.md:18
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                         :     :                                               :\n"
":    "
"list                 :     :                                               :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----"
"+   :\n"
":   | Cons | 1  | o--+----+-----+--->| Cons | 2  | o--+--->| Nil  | // | // "
"|   :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----"
"+   :\n"
":                         :     :                                               :\n"
":                         :     :                                               :\n"
"'- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"
msgstr ""

#: src/std/box-recursive.md:33
#, fuzzy
msgid ""
"If the `Box` was not used here and we attempted to embed a `List` directly "
"into the `List`, the compiler would not compute a fixed size of the struct "
"in memory, it would look infinite."
msgstr ""
"Jeli `Box` nie zosta tutaj u偶yty i pr贸bowalimy osadzi `List` "
"bezporednio w `List`, kompilator nie obliczyby staego rozmiaru struktury "
"w pamici, wygldaby na nieskoczony."

#: src/std/box-recursive.md:36
#, fuzzy
msgid ""
"`Box` solves this problem as it has the same size as a regular pointer and "
"just points at the next element of the `List` in the heap."
msgstr ""
"`Box` rozwizuje ten problem, poniewa偶 ma taki sam rozmiar jak zwyky "
"wska藕nik i po prostu wskazuje nastpny element Listy w stercie."

#: src/std/box-recursive.md:39
#, fuzzy
msgid ""
"Remove the `Box` in the List definition and show the compiler error. "
"\"Recursive with indirection\" is a hint you might want to use a Box or "
"reference of some kind, instead of storing a value directly."
msgstr ""
"Usu `Box` w definicji listy i poka偶 bd kompilatora. Rekurencyjne z "
"kierunkiem to wskaz贸wka, 偶e mo偶esz chcie u偶y pewnego rodzaju pudeka lub "
"odniesienia, zamiast bezporednio przechowywa warto."

#: src/std/box-niche.md:16
#, fuzzy
msgid ""
"A `Box` cannot be empty, so the pointer is always valid and non-`null`. This "
"allows the compiler to optimize the memory layout:"
msgstr ""
"`Box` nie mo偶e by pusty, wic wska藕nik jest zawsze wa偶ny i nie ma wartoci "
"`null`. Ten pozwala kompilatorowi zoptymalizowa ukad pamici:"

#: src/std/box-niche.md:19
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - "
"-.\n"
":                         :     :                                             :\n"
":    "
"list                 :     :                                             :\n"
":   +----+----+           :     :    +----+----+    +----+------"
"+             :\n"
":   | 1  | o--+-----------+-----+--->| 2  | o--+--->| // | null "
"|             :\n"
":   +----+----+           :     :    +----+----+    +----+------"
"+             :\n"
":                         :     :                                             :\n"
":                         :     :                                             :\n"
"`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - "
"-'\n"
"```"
msgstr ""

#: src/std/rc.md:1
#, fuzzy
msgid "`Rc`"
msgstr "`Rc`"

#: src/std/rc.md:3
#, fuzzy
msgid ""
"[`Rc`](https://doc.rust-lang.org/std/rc/struct.Rc.html) is a reference-"
"counted shared pointer. Use this when you need to refer to the same data "
"from multiple places:"
msgstr ""
"[`Rc`](https://doc.rust-lang.org/std/rc/struct.Rc.html) jest wsp贸dzielonym "
"wska藕nikiem zliczanym przez referencje. U偶yj tego, gdy potrzebujesz si "
"odnie do tych samych danych z wielu miejsc:"

#: src/std/rc.md:6
msgid ""
"```rust,editable\n"
"use std::rc::Rc;\n"
"```"
msgstr ""

#: src/std/rc.md:9
msgid "fn main() { let mut a = Rc::new(10); let mut b = a.clone();"
msgstr ""

#: src/std/rc.md:18
#, fuzzy
msgid ""
"If you need to mutate the data inside an `Rc`, you will need to wrap the "
"data in a type such as [`Cell` or `RefCell`](https://doc.rust-lang.org/std/"
"cell/index.html)."
msgstr ""
"Jeli musisz zmutowa dane wewntrz `Rc`, bdziesz musia zawin dane typu "
"takiego jak [`Cell` lub `RefCell`](../concurrency/shared_state/arc.md)."

#: src/std/rc.md:20
#, fuzzy
msgid ""
"See [`Arc`](../concurrency/shared_state/arc.md) if you are in a multi-"
"threaded context."
msgstr ""
"Zobacz [`Arc`](https://doc.rust-lang.org/std/sync/struct.Mutex.html), jeli "
"pracujesz w kontekcie wielowtkowym."

#: src/std/rc.md:21
#, fuzzy
msgid ""
"You can _downgrade_ a shared pointer into a [`Weak`](https://doc.rust-lang."
"org/std/rc/struct.Weak.html) pointer to create cycles that will get dropped."
msgstr ""
"Mo偶esz _zmniejszy_ wsp贸dzielony wska藕nik do wska藕nika [`Weak`](https://doc."
"rust-lang.org/std/rc/struct.Weak.html), aby tworzy cykle 偶e zostanie "
"upuszczony."

#: src/std/rc.md:31
#, fuzzy
msgid "Like C++'s `std::shared_ptr`."
msgstr "Podobnie jak `std::shared_ptr` C++."

#: src/std/rc.md:32
#, fuzzy
msgid ""
"`clone` is cheap: creates a pointer to the same allocation and increases the "
"reference count."
msgstr ""
"`clone` jest tanie: tworzy wska藕nik do tej samej alokacji i zwiksza liczb "
"odwoa."

#: src/std/rc.md:33
#, fuzzy
msgid ""
"`make_mut` actually clones the inner value if necessary (\"clone-on-write\") "
"and returns a mutable reference."
msgstr ""
"`make_mut` faktycznie klonuje wewntrzn warto, jeli to konieczne (clone-"
"on-write) i zwraca mutowaln referencj."

#: src/std/rc.md:34
#, fuzzy
msgid ""
"You can `downgrade()` a `Rc` into a _weakly reference-counted_ object to "
"create cycles that will be dropped properly (likely in combination with "
"`RefCell`)."
msgstr ""
"Mo偶esz `downgrade()` `Rc` do obiektu _sabo zliczanego_, aby tworzy cykle, "
"kt贸re zostan poprawnie upuszczone (prawdopodobnie w poczeniu z `Kom贸rka "
"Ref`)."

#: src/std/rc.md:38
msgid ""
"```rust,editable\n"
"use std::rc::{Rc, Weak};\n"
"use std::cell::RefCell;\n"
"```"
msgstr ""

#: src/std/rc.md:42
msgid ""
"\\#\\[derive(Debug)\\] struct Node { value: i64, parent: "
"Option\\<Weak\\<RefCell"
msgstr ""
"\\#\\[derive(Debug)\\] struct Node { value: i64, parent: "
"Option\\<Weak\\<RefCell"

#: src/std/rc.md:45
msgid "\\>>, children: Vec\\<Rc\\<RefCell"
msgstr "\\>>, children: Vec\\<Rc\\<RefCell"

#: src/std/rc.md:46
msgid "\\>>, }"
msgstr "\\>>, }"

#: src/std/rc.md:49
msgid ""
"fn main() { let mut root = Rc::new(RefCell::new(Node { value: 42, parent: "
"None, children: vec![\\], })); let child = Rc::new(RefCell::new(Node "
"{ value: 43, children: vec![\\], parent: Some(Rc::downgrade(&root)) })); "
"root.borrow_mut().children.push(child);"
msgstr ""

#: src/std/rc.md:62
msgid ""
"```\n"
"println!(\"graph: {root:#?}\");\n"
"```"
msgstr ""

#: src/modules.md:3
#, fuzzy
msgid "We have seen how `impl` blocks let us namespace functions to a type."
msgstr ""
"Widzielimy, jak bloki `impl` pozwalaj nam funkcjonowa w przestrzeni nazw "
"dla typu."

#: src/modules.md:5
#, fuzzy
msgid "Similarly, `mod` lets us namespace types and functions:"
msgstr "Podobnie `mod` pozwala nam na typy i funkcje przestrzeni nazw:"

#: src/modules.md:7
msgid ""
"```rust,editable\n"
"mod foo {\n"
"    pub fn do_something() {\n"
"        println!(\"In the foo module\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/modules.md:14
msgid "mod bar { pub fn do_something() { println!(\"In the bar module\"); } }"
msgstr ""

#: src/modules.md:20
msgid "fn main() { foo::do_something(); bar::do_something(); }"
msgstr ""

#: src/modules.md:28
#, fuzzy
msgid ""
"Packages provide functionality and include a `Cargo.toml` file that "
"describes how to build a bundle of 1+ crates."
msgstr ""
"Pakiety zapewniaj funkcjonalno i zawieraj plik `Cargo.toml`, kt贸ry "
"opisuje, jak zbudowa pakiet 1+ skrzynek."

#: src/modules.md:29
#, fuzzy
msgid ""
"Crates are a tree of modules, where a binary crate creates an executable and "
"a library crate compiles to a library."
msgstr ""
"Skrzynki to drzewo modu贸w, w kt贸rym binarna skrzynia tworzy plik "
"wykonywalny, a skrzynka biblioteczna kompiluje si do biblioteki."

#: src/modules.md:30
#, fuzzy
msgid "Modules define organization, scope, and are the focus of this section."
msgstr "Moduy okrelaj organizacj, zakres i s tematem tej sekcji."

#: src/modules/visibility.md:3
#, fuzzy
msgid "Modules are a privacy boundary:"
msgstr "Moduy stanowi granic prywatnoci:"

#: src/modules/visibility.md:5
#, fuzzy
msgid "Module items are private by default (hides implementation details)."
msgstr ""
"Elementy moduu s domylnie prywatne (ukrywa szczeg贸y implementacji)."

#: src/modules/visibility.md:6
#, fuzzy
msgid "Parent and sibling items are always visible."
msgstr "Elementy nadrzdne i rodzestwo s zawsze widoczne."

#: src/modules/visibility.md:7
#, fuzzy
msgid ""
"In other words, if an item is visible in module `foo`, it's visible in all "
"the descendants of `foo`."
msgstr ""
"Innymi sowy, jeli element jest widoczny w module `foo`, jest widoczny we "
"wszystkich moduach potomkowie `foo`."

#: src/modules/visibility.md:10
msgid ""
"```rust,editable\n"
"mod outer {\n"
"    fn private() {\n"
"        println!(\"outer::private\");\n"
"    }\n"
"```"
msgstr ""

#: src/modules/visibility.md:16
msgid ""
"```\n"
"pub fn public() {\n"
"    println!(\"outer::public\");\n"
"}\n"
"```"
msgstr ""

#: src/modules/visibility.md:20
msgid ""
"```\n"
"mod inner {\n"
"    fn private() {\n"
"        println!(\"outer::inner::private\");\n"
"    }\n"
"```"
msgstr ""

#: src/modules/visibility.md:25
msgid ""
"```\n"
"    pub fn public() {\n"
"        println!(\"outer::inner::public\");\n"
"        super::private();\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/modules/visibility.md:32
msgid "fn main() { outer::public(); }"
msgstr ""

#: src/modules/visibility.md:39
#, fuzzy
msgid "Use the `pub` keyword to make modules public."
msgstr "U偶yj sowa kluczowego `pub`, aby upubliczni moduy."

#: src/modules/visibility.md:41
#, fuzzy
msgid ""
"Additionally, there are advanced `pub(...)` specifiers to restrict the scope "
"of public visibility."
msgstr ""
"Dodatkowo istniej zaawansowane specyfikatory `pub(...)` ograniczajce "
"zakres publicznej widocznoci."

#: src/modules/visibility.md:43
#, fuzzy
msgid ""
"See the [Rust Reference](https://doc.rust-lang.org/reference/visibility-and-"
"privacy.html#pubin-path-pubcrate-pubsuper-and-pubself))."
msgstr ""
"Zobacz [Odniesienie do Rust](https://doc.rust-lang.org/reference/visibility-"
"and-privacy.html#pubin-path-pubcrate-pubsuper-and-pubself))."

#: src/modules/visibility.md:44
#, fuzzy
msgid "Configuring `pub(crate)` visibility is a common pattern."
msgstr "Konfigurowanie widocznoci `pub(crate)` jest powszechnym wzorcem."

#: src/modules/visibility.md:45
#, fuzzy
msgid "Less commonly, you can give visibility to a specific path."
msgstr "Rzadziej mo偶na zapewni widoczno okrelonej cie偶ce."

#: src/modules/visibility.md:46
#, fuzzy
msgid ""
"In any case, visibility must be granted to an ancestor module (and all of "
"its descendants)."
msgstr ""
"W ka偶dym przypadku widoczno musi by przyznana moduowi przodka (i "
"wszystkim jego potomkom)."

#: src/modules/paths.md:3
#, fuzzy
msgid "Paths are resolved as follows:"
msgstr "cie偶ki s rozstrzygane w nastpujcy spos贸b:"

#: src/modules/paths.md:5
#, fuzzy
msgid "As a relative path:"
msgstr "Jako cie偶ka wzgldna:"

#: src/modules/paths.md:6
#, fuzzy
msgid "`foo` or `self::foo` refers to `foo` in the current module,"
msgstr "`foo` lub `self::foo` odnosi si do `foo` w bie偶cym module,"

#: src/modules/paths.md:7
#, fuzzy
msgid "`super::foo` refers to `foo` in the parent module."
msgstr "`super::foo` odnosi si do `foo` w module nadrzdnym."

#: src/modules/paths.md:9
#, fuzzy
msgid "As an absolute path:"
msgstr "Jako cie偶ka bezwzgldna:"

#: src/modules/paths.md:10
#, fuzzy
msgid "`crate::foo` refers to `foo` in the root of the current crate,"
msgstr "`crate::foo` odnosi si do `foo` w katalogu g贸wnym bie偶cej skrzynki,"

#: src/modules/paths.md:11
#, fuzzy
msgid "`bar::foo` refers to `foo` in the `bar` crate."
msgstr "`bar::foo` odnosi si do `foo` w skrzynce `bar`."

#: src/modules/filesystem.md:3
#, fuzzy
msgid "The module content can be omitted:"
msgstr "Tre moduu mo偶na pomin:"

#: src/modules/filesystem.md:5
msgid ""
"```rust,editable,compile_fail\n"
"mod garden;\n"
"```"
msgstr ""

#: src/modules/filesystem.md:9
#, fuzzy
msgid "The `garden` module content is found at:"
msgstr "Zawarto moduu `garden` znajduje si pod adresem:"

#: src/modules/filesystem.md:11
#, fuzzy
msgid "`src/garden.rs` (modern Rust 2018 style)"
msgstr "`src/garden.rs` (nowoczesny styl Rust 2018)"

#: src/modules/filesystem.md:12
#, fuzzy
msgid "`src/garden/mod.rs` (older Rust 2015 style)"
msgstr "`src/garden/mod.rs` (starszy styl Rust 2015)"

#: src/modules/filesystem.md:14
#, fuzzy
msgid "Similarly, a `garden::vegetables` module can be found at:"
msgstr "Podobnie modu `garden::vegetables` mo偶na znale藕 pod adresem:"

#: src/modules/filesystem.md:16
#, fuzzy
msgid "`src/garden/vegetables.rs` (modern Rust 2018 style)"
msgstr "`src/garden/vegetables.rs` (nowoczesny styl Rust 2018)"

#: src/modules/filesystem.md:17
#, fuzzy
msgid "`src/garden/vegetables/mod.rs` (older Rust 2015 style)"
msgstr "`src/garden/vegetables/mod.rs` (starszy styl Rust 2015)"

#: src/modules/filesystem.md:19
#, fuzzy
msgid "The `crate` root is in:"
msgstr "Korze `crate` znajduje si w:"

#: src/modules/filesystem.md:21
#, fuzzy
msgid "`src/lib.rs` (for a library crate)"
msgstr "`src/lib.rs` (dla skrzynki bibliotecznej)"

#: src/modules/filesystem.md:22
#, fuzzy
msgid "`src/main.rs` (for a binary crate)"
msgstr "`src/main.rs` (dla skrzynki binarnej)"

#: src/modules/filesystem.md:26
#, fuzzy
msgid ""
"The change from `module/mod.rs` to `module.rs` doesn't preclude the use of "
"submodules in Rust 2018. (It was mandatory in Rust 2015.)"
msgstr ""
"Zmiana z `module/mod.rs` na `module.rs` nie wyklucza u偶ycia submodu贸w w "
"Rust 2018. (Byo to obowizkowe w Rust 2015.)"

#: src/modules/filesystem.md:29
#, fuzzy
msgid "The following is valid:"
msgstr "Poni偶sze jest wa偶ne:"

#: src/modules/filesystem.md:31
msgid ""
"```ignore\n"
"src/\n"
" main.rs\n"
" top_module.rs\n"
" top_module/\n"
"     sub_module.rs\n"
"```"
msgstr ""

#: src/modules/filesystem.md:39
#, fuzzy
msgid ""
"The main reason for the change is to prevent many files named `mod.rs`, "
"which can be hard to distinguish in IDEs."
msgstr ""
"G贸wnym powodem zmiany jest uniemo偶liwienie wielu plik贸w o nazwie `mod.rs`, "
"co mo偶e by trudne rozr贸偶nia w IDE."

#: src/modules/filesystem.md:42
#, fuzzy
msgid ""
"Rust will look for modules in `modulename/mod.rs` and `modulename.rs`, but "
"this can be changed with a compiler directive:"
msgstr ""
"Rust bdzie szuka modu贸w w `modulename/mod.rs` i `modulename.rs`, ale "
"mo偶na to zmieni z dyrektyw kompilatora:"

#: src/modules/filesystem.md:45
msgid ""
"```rust,ignore\n"
"#[path = \"some/path.rs\"]\n"
"mod some_module { }\n"
"```"
msgstr ""

#: src/modules/filesystem.md:50
#, fuzzy
msgid ""
"This is useful, for example, if you would like to place tests for a module "
"in a file named `some_module_test.rs`, similar to the convention in Go."
msgstr ""
"Jest to przydatne na przykad, jeli chcesz umieci testy moduu w pliku o "
"nazwie `some_module_test.rs`, podobnie do konwencji w Go."

#: src/exercises/day-2/afternoon.md:1
#, fuzzy
msgid "Day 2: Afternoon Exercises"
msgstr "Dzie 2: wiczenia popoudniowe"

#: src/exercises/day-2/afternoon.md:3
#, fuzzy
msgid "The exercises for this afternoon will focus on strings and iterators."
msgstr "wiczenia na to popoudnie skupi si na cigach znak贸w i iteratorach."

#: src/exercises/day-2/luhn.md:3
#, fuzzy
msgid ""
"The [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm) is used "
"to validate credit card numbers. The algorithm takes a string as input and "
"does the following to validate the credit card number:"
msgstr ""
"[Algorytm Luhna](https://en.wikipedia.org/wiki/Luhn_algorithm) su偶y do "
"zweryfikowa numery kart kredytowych. Algorytm pobiera cig jako dane "
"wejciowe i wykonuje aby zweryfikowa numer karty kredytowej:"

#: src/exercises/day-2/luhn.md:7
#, fuzzy
msgid "Ignore all spaces. Reject number with less than two digits."
msgstr ""
"Zignoruj wszystkie spacje. Odrzu numer zawierajcy mniej ni偶 dwie cyfry."

#: src/exercises/day-2/luhn.md:9
#, fuzzy
msgid ""
"Moving from right to left, double every second digit: for the number `1234`, "
"we double `3` and `1`."
msgstr ""
"Przechodzc od prawej do lewej, podwajaj co drug cyfr: dla liczby `1234`, "
"podwajamy 3 i 1."

#: src/exercises/day-2/luhn.md:12
#, fuzzy
msgid ""
"After doubling a digit, sum the digits. So doubling `7` becomes `14` which "
"becomes `5`."
msgstr ""
"Po podwojeniu cyfry zsumuj cyfry. Wic podwojenie 7 daje 14, co staje "
"si 5."

#: src/exercises/day-2/luhn.md:15
#, fuzzy
msgid "Sum all the undoubled and doubled digits."
msgstr "Zsumuj wszystkie niepodwojone i podwojone cyfry."

#: src/exercises/day-2/luhn.md:17
#, fuzzy
msgid "The credit card number is valid if the sum ends with `0`."
msgstr "Numer karty kredytowej jest wa偶ny, jeli suma koczy si na `0`."

#: src/exercises/day-2/luhn.md:19
#, fuzzy
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and implement the "
"function:"
msgstr ""
"Skopiuj poni偶szy kod do <https://play.rust-lang.org/> i zaimplementuj "
"funkcjonowa:"

#: src/exercises/day-2/luhn.md:27
msgid "pub fn luhn(cc_number: &str) -> bool { unimplemented!() }"
msgstr "pub fn luhn(cc_number: &str) -> bool { unimplemented!() }"

#: src/exercises/day-2/luhn.md:31
msgid ""
"\\#\\[test\\] fn test_non_digit_cc_number() { assert!(!luhn(\"foo\")); }"
msgstr ""

#: src/exercises/day-2/luhn.md:36 src/exercises/day-2/solutions-afternoon.md:64
msgid ""
"\\#\\[test\\] fn test_empty_cc_number() { assert!(!luhn(\"\")); assert!(!"
"luhn(\" \")); assert!(!luhn(\"  \")); assert!(!luhn(\"    \")); }"
msgstr ""

#: src/exercises/day-2/luhn.md:44 src/exercises/day-2/solutions-afternoon.md:72
msgid ""
"\\#\\[test\\] fn test_single_digit_cc_number() { assert!(!luhn(\"0\")); }"
msgstr ""

#: src/exercises/day-2/luhn.md:49 src/exercises/day-2/solutions-afternoon.md:77
msgid ""
"\\#\\[test\\] fn test_two_digit_cc_number() { assert!(luhn(\" 0 0 \")); }"
msgstr ""

#: src/exercises/day-2/luhn.md:54 src/exercises/day-2/solutions-afternoon.md:82
msgid ""
"\\#\\[test\\] fn test_valid_cc_number() { assert!(luhn(\"4263 9826 4026 "
"9299\")); assert!(luhn(\"4539 3195 0343 6467\")); assert!(luhn(\"7992 7398 "
"713\")); }"
msgstr ""

#: src/exercises/day-2/luhn.md:61
msgid ""
"\\#\\[test\\] fn test_invalid_cc_number() { assert!(!luhn(\"4223 9826 4026 "
"9299\")); assert!(!luhn(\"4539 3195 0343 6476\")); assert!(!luhn(\"8273 1232 "
"7352 0569\")); }"
msgstr ""

#: src/exercises/day-2/strings-iterators.md:3
#, fuzzy
msgid ""
"In this exercise, you are implementing a routing component of a web server. "
"The server is configured with a number of _path prefixes_ which are matched "
"against _request paths_. The path prefixes can contain a wildcard character "
"which matches a full segment. See the unit tests below."
msgstr ""
"W tym wiczeniu implementujesz komponent routingu serwera WWW. The serwer "
"jest skonfigurowany z liczb _prefiks贸w cie偶ki_, z kt贸rymi s dopasowywane "
"_za偶daj cie偶ek_. Prefiksy cie偶ki mog zawiera symbol wieloznaczny, kt贸ry "
"pasuje do penego segmentu. Zobacz testy jednostkowe poni偶ej."

#: src/exercises/day-2/strings-iterators.md:8
#, fuzzy
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and make the tests "
"pass. Try avoiding allocating a `Vec` for your intermediate results:"
msgstr ""
"Skopiuj poni偶szy kod do <https://play.rust-lang.org/> i wykonaj testy "
"przechodzi. Staraj si unika przydzielania `Vec` dla wynik贸w porednich:"

#: src/exercises/day-2/strings-iterators.md:16
msgid ""
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool "
"{ unimplemented!() }"
msgstr ""
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool "
"{ unimplemented!() }"

#: src/exercises/day-2/strings-iterators.md:20
msgid ""
"\\#\\[test\\] fn test_matches_without_wildcard() { assert!(prefix_matches(\"/"
"v1/publishers\", \"/v1/publishers\")); assert!(prefix_matches(\"/v1/"
"publishers\", \"/v1/publishers/abc-123\")); assert!(prefix_matches(\"/v1/"
"publishers\", \"/v1/publishers/abc/books\"));"
msgstr ""
"\\#\\[test\\] fn test_matches_without_wildcard() { assert!(prefix_matches(\"/"
"v1/publishers\", \"/v1/publishers\")); assert!(prefix_matches(\"/v1/"
"publishers\", \"/v1/publishers/abc-123\")); assert!(prefix_matches(\"/v1/"
"publishers\", \"/v1/publishers/abc/books\"));"

#: src/exercises/day-2/strings-iterators.md:26
#: src/exercises/day-2/solutions-afternoon.md:146
msgid ""
"```\n"
"assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
"assert!(!prefix_matches(\"/v1/publishers\", \"/v1/publishersBooks\"));\n"
"assert!(!prefix_matches(\"/v1/publishers\", \"/v1/parent/publishers\"));\n"
"```"
msgstr ""
"```\n"
"assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
"assert!(!prefix_matches(\"/v1/publishers\", \"/v1/publishersBooks\"));\n"
"assert!(!prefix_matches(\"/v1/publishers\", \"/v1/parent/publishers\"));\n"
"```"

#: src/exercises/day-2/strings-iterators.md:31
#: src/exercises/day-2/solutions-afternoon.md:151
msgid ""
"\\#\\[test\\] fn test_matches_with_wildcard() { assert!(prefix_matches( \"/"
"v1/publishers/_/books\", \"/v1/publishers/foo/books\" )); assert!"
"(prefix_matches( \"/v1/publishers/_/books\", \"/v1/publishers/bar/"
"books\" )); assert!(prefix_matches( \"/v1/publishers/\\*/books\", \"/v1/"
"publishers/foo/books/book1\" ));"
msgstr ""
"\\#\\[test\\] fn test_matches_with_wildcard() { assert!(prefix_matches( \"/"
"v1/publishers/_/books\", \"/v1/publishers/foo/books\" )); assert!"
"(prefix_matches( \"/v1/publishers/_/books\", \"/v1/publishers/bar/"
"books\" )); assert!(prefix_matches( \"/v1/publishers/\\*/books\", \"/v1/"
"publishers/foo/books/book1\" ));"

#: src/exercises/day-2/strings-iterators.md:46
#: src/exercises/day-2/solutions-afternoon.md:166
msgid ""
"```\n"
"assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/publishers\"));\n"
"assert!(!prefix_matches(\n"
"    \"/v1/publishers/*/books\",\n"
"    \"/v1/publishers/foo/booksByAuthor\"\n"
"));\n"
"```"
msgstr ""
"```\n"
"assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/publishers\"));\n"
"assert!(!prefix_matches(\n"
"    \"/v1/publishers/*/books\",\n"
"    \"/v1/publishers/foo/booksByAuthor\"\n"
"));\n"
"```"

#: src/welcome-day-3.md:1
msgid "Welcome to Day 3"
msgstr "Witamy w dniu 3"

#: src/welcome-day-3.md:3
#, fuzzy
msgid "Today, we will cover some more advanced topics of Rust:"
msgstr ""
"Dzisiaj om贸wimy kilka bardziej zaawansowanych zagadnie zwizanych z Rust:"

#: src/welcome-day-3.md:5
#, fuzzy
msgid ""
"Traits: deriving traits, default methods, and important standard library "
"traits."
msgstr ""
"Cechy: wyprowadzanie cech, metody domylne i wa偶na biblioteka standardowa "
"cechy."

#: src/welcome-day-3.md:8
#, fuzzy
msgid ""
"Generics: generic data types, generic methods, monomorphization, and trait "
"objects."
msgstr ""
"Rodzaje: og贸lne typy danych, metody og贸lne, monomorfizacja i cecha obiekty."

#: src/welcome-day-3.md:11
#, fuzzy
msgid "Error handling: panics, `Result`, and the try operator `?`."
msgstr "Obsuga bd贸w: paniki, `Result` i operator try `?`."

#: src/welcome-day-3.md:13
#, fuzzy
msgid "Testing: unit tests, documentation tests, and integration tests."
msgstr ""
"Testowanie: testy jednostkowe, testy dokumentacji i testy integracyjne."

#: src/welcome-day-3.md:15
#, fuzzy
msgid ""
"Unsafe Rust: raw pointers, static variables, unsafe functions, and extern "
"functions."
msgstr ""
"Niebezpieczny Rust: surowe wska藕niki, zmienne statyczne, niebezpieczne "
"funkcje i extern Funkcje."

#: src/traits.md:3
#, fuzzy
msgid ""
"Rust lets you abstract over types with traits. They're similar to interfaces:"
msgstr ""
"Rust pozwala na abstrakcj nad typami z cechami. S podobne do interfejs贸w:"

#: src/traits.md:5
msgid ""
"```rust,editable\n"
"trait Greet {\n"
"    fn say_hello(&self);\n"
"}\n"
"```"
msgstr ""

#: src/traits.md:10
#, fuzzy
msgid "struct Dog { name: String, }"
msgstr "pies konstrukcyjny { imi: Cig, }"

#: src/traits.md:14
msgid "struct Cat;  // No name, cats won't respond to it anyway."
msgstr ""

#: src/traits.md:16
msgid ""
"impl Greet for Dog { fn say_hello(&self) { println!(\"Wuf, my name is {}!\", "
"self.name); } }"
msgstr ""

#: src/traits.md:22
msgid "impl Greet for Cat { fn say_hello(&self) { println!(\"Miau!\"); } }"
msgstr ""

#: src/traits.md:28
msgid "fn main() { let pets: Vec\\<Box"
msgstr ""

#: src/traits.md:29
msgid ""
"\\> = vec![ Box::new(Dog { name: String::from(\"Fido\") }), Box::new(Cat), "
"\\]; for pet in pets { pet.say_hello(); } }"
msgstr ""

#: src/traits.md:41
#, fuzzy
msgid ""
"Traits may specify pre-implemented (default) methods and methods that users "
"are required to implement themselves. Methods with default implementations "
"can rely on required methods."
msgstr ""
"Cechy mog okrela wstpnie zaimplementowane (domylne) metody i metody, "
"kt贸re u偶ytkownicy musz sami zaimplementowa. Metody z domylnymi "
"implementacjami mog polega na metodach wymaganych."

#: src/traits.md:42
#, fuzzy
msgid ""
"Types that implement a given trait may be of different sizes. This makes it "
"impossible to have things like `Vec<Greet>` in the example above."
msgstr ""
"Typy realizujce dan cech mog mie r贸偶ne rozmiary. To sprawia, 偶e "
"niemo偶liwe jest posiadanie rzeczy takich jak `Vec<Greet>` w powy偶szym "
"przykadzie."

#: src/traits.md:43
#, fuzzy
msgid ""
"`dyn Greet` is a way to tell the compiler about a dynamically sized type "
"that implements `Greet`."
msgstr ""
"`dyn Greet` to spos贸b poinformowania kompilatora o typie o dynamicznym "
"rozmiarze, kt贸ry implementuje `Greet`."

#: src/traits.md:44
#, fuzzy
msgid ""
"In the example, `pets` holds Fat Pointers to objects that implement `Greet`. "
"The Fat Pointer consists of two components, a pointer to the actual object "
"and a pointer to the virtual method table for the `Greet` implementation of "
"that particular object."
msgstr ""
"W przykadzie `pets` przechowuje Fat Pointers do obiekt贸w, kt贸re "
"implementuj `Greet`. Fat Pointer skada si z dw贸ch komponent贸w, wska藕nika "
"do rzeczywistego obiektu i wska藕nika do wirtualnej tabeli metod dla "
"implementacji `Greet` tego konkretnego obiektu."

#: src/traits.md:46
msgid "Compare these outputs in the above example:"
msgstr ""

#: src/traits.md:47
msgid ""
"```rust,ignore\n"
"    println!(\"{} {}\", std::mem::size_of::<Dog>(), std::mem::size_of::"
"<Cat>());\n"
"    println!(\"{} {}\", std::mem::size_of::<&Dog>(), std::mem::size_of::"
"<&Cat>());\n"
"    println!(\"{}\", std::mem::size_of::<&dyn Greet>());\n"
"    println!(\"{}\", std::mem::size_of::<Box<dyn Greet>>());\n"
"```"
msgstr ""

#: src/traits/deriving-traits.md:3
#, fuzzy
msgid "You can let the compiler derive a number of traits:"
msgstr "Mo偶esz pozwoli kompilatorowi uzyska szereg cech:"

#: src/traits/deriving-traits.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Clone, PartialEq, Eq, Default)]\n"
"struct Player {\n"
"    name: String,\n"
"    strength: u8,\n"
"    hit_points: u8,\n"
"}\n"
"```"
msgstr ""

#: src/traits/deriving-traits.md:13
msgid ""
"fn main() { let p1 = Player::default(); let p2 = p1.clone(); println!(\"Is "
"{:?}\\nequal to {:?}?\\nThe answer is {}!\", &p1, &p2, if p1 == p2 "
"{ \"yes\" } else { \"no\" }); }"
msgstr ""

#: src/traits/default-methods.md:3
#, fuzzy
msgid "Traits can implement behavior in terms of other trait methods:"
msgstr "Cechy mog implementowa zachowanie w kategoriach innych metod cech:"

#: src/traits/default-methods.md:5
msgid ""
"```rust,editable\n"
"trait Equals {\n"
"    fn equal(&self, other: &Self) -> bool;\n"
"    fn not_equal(&self, other: &Self) -> bool {\n"
"        !self.equal(other)\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/traits/default-methods.md:13
msgid "\\#\\[derive(Debug)\\] struct Centimeter(i16);"
msgstr ""

#: src/traits/default-methods.md:16
#, fuzzy
msgid ""
"impl Equals for Centimeter { fn equal(&self, other: &Centimeter) -> bool "
"{ self.0 == other.0 } }"
msgstr ""
"impl R贸wna si dla centymetra { fn r贸wny(&ja; inny: &Centymetr) -> bool "
"{ sam.0 == inny.0 } }"

#: src/traits/default-methods.md:22
msgid ""
"fn main() { let a = Centimeter(10); let b = Centimeter(20); println!(\"{a:?} "
"equals {b:?}: {}\", a.equal(&b)); println!(\"{a:?} not_equals {b:?}: {}\", a."
"not_equal(&b)); }"
msgstr ""

#: src/traits/important-traits.md:3
#, fuzzy
msgid ""
"We will now look at some of the most common traits of the Rust standard "
"library:"
msgstr ""
"Przyjrzymy si teraz niekt贸rym z najczstszych cech standardowej biblioteki "
"Rust:"

#: src/traits/important-traits.md:5
#, fuzzy
msgid ""
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) and "
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html) "
"used in `for` loops,"
msgstr ""
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) i "
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html) "
"u偶ywane w ptlach `for`,"

#: src/traits/important-traits.md:6
#, fuzzy
msgid ""
"[`From`](https://doc.rust-lang.org/std/convert/trait.From.html) and [`Into`]"
"(https://doc.rust-lang.org/std/convert/trait.Into.html) used to convert "
"values,"
msgstr ""
"[`From`](https://doc.rust-lang.org/std/convert/trait.From.html) i [`Into`]"
"(https://doc.rust-lang.org/std/convert/trait.Into.html) u偶ywane do konwersji "
"wartoci,"

#: src/traits/important-traits.md:7
#, fuzzy
msgid ""
"[`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) and [`Write`]"
"(https://doc.rust-lang.org/std/io/trait.Write.html) used for IO,"
msgstr ""
"[`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) i [`Write`]"
"(https://doc.rust-lang.org/std/io/trait.Write.html) u偶ywane do IO,"

#: src/traits/important-traits.md:8
#, fuzzy
msgid ""
"[`Add`](https://doc.rust-lang.org/std/ops/trait.Add.html), [`Mul`](https://"
"doc.rust-lang.org/std/ops/trait.Mul.html), ... used for operator "
"overloading, and"
msgstr ""
"[`Add`](https://doc.rust-lang.org/std/ops/trait.Add.html), [`Mul`](https://"
"doc.rust-lang.org/std/ops/trait.Mul.html), ... u偶ywane do przeci偶ania "
"operatora i"

#: src/traits/important-traits.md:9
#, fuzzy
msgid ""
"[`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) used for "
"defining destructors."
msgstr ""
"[`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) u偶ywane do "
"definiowania destruktor贸w."

#: src/traits/important-traits.md:10
#, fuzzy
msgid ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) used "
"to construct a default instance of a type."
msgstr ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) "
"u偶ywane do konstruowania domylnej instancji typu."

#: src/traits/iterator.md:1
#, fuzzy
msgid "Iterators"
msgstr "Iteratory"

#: src/traits/iterator.md:3
#, fuzzy
msgid ""
"You can implement the [`Iterator`](https://doc.rust-lang.org/std/iter/trait."
"Iterator.html) trait on your own types:"
msgstr ""
"Mo偶esz zaimplementowa cech [`Iterator`](https://doc.rust-lang.org/std/iter/"
"trait.Iterator.html) na swoich wasnych typach:"

#: src/traits/iterator.md:5
msgid ""
"```rust,editable\n"
"struct Fibonacci {\n"
"    curr: u32,\n"
"    next: u32,\n"
"}\n"
"```"
msgstr ""

#: src/traits/iterator.md:11
msgid "impl Iterator for Fibonacci { type Item = u32;"
msgstr ""

#: src/traits/iterator.md:14
msgid ""
"```\n"
"fn next(&mut self) -> Option<Self::Item> {\n"
"    let new_next = self.curr + self.next;\n"
"    self.curr = self.next;\n"
"    self.next = new_next;\n"
"    Some(self.curr)\n"
"}\n"
"```"
msgstr ""

#: src/traits/iterator.md:22
msgid ""
"fn main() { let fib = Fibonacci { curr: 0, next: 1 }; for (i, n) in fib."
"enumerate().take(5) { println!(\"fib({i}): {n}\"); } }"
msgstr ""

#: src/traits/iterator.md:32
#, fuzzy
msgid ""
"`IntoIterator` is the trait that makes for loops work. It is implemented by "
"collection types such as `Vec<T>` and references to them such as `&Vec<T>` "
"and `&[T]`. Ranges also implement it."
msgstr ""
"`IntoIterator` to cecha, kt贸ra sprawia, 偶e ptle for dziaaj. Jest "
"implementowany przez typy kolekcji, takie jak `Vec<T>` i odniesienia do "
"nich, takie jak `&Vec<T>` i `&[T]`. Realizuj to r贸wnie偶 zakresy."

#: src/traits/iterator.md:34
#, fuzzy
msgid ""
"The `Iterator` trait implements many common functional programming "
"operations over collections  (e.g. `map`, `filter`, `reduce`, etc). This is "
"the trait where you can find all the documentation about them. In Rust these "
"functions should produce the code as efficient as equivalent imperative "
"implementations."
msgstr ""
"Cecha `Iterator` implementuje wiele typowych operacji programowania "
"funkcyjnego na kolekcjach (np. `mapa`, `filtr`, `zmniejsz` itp.). Jest to "
"cecha, w kt贸rej mo偶na znale藕 ca dokumentacj o nich. W Rust te funkcje "
"powinny generowa kod tak wydajny, jak r贸wnowa偶ny imperatyw wdro偶enia."

#: src/traits/from-iterator.md:3
#, fuzzy
msgid ""
"[`FromIterator`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html) "
"lets you build a collection from an [`Iterator`](https://doc.rust-lang.org/"
"std/iter/trait.Iterator.html)."
msgstr ""
"[`FromIterator`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html) "
"pozwala zbudowa kolekcj z [`Iterator`](https://doc.rust-lang.org/std/iter/"
"trait.Iterator.html)."

#: src/traits/from-iterator.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let primes = vec![2, 3, 5, 7];\n"
"    let prime_squares = primes\n"
"        .into_iter()\n"
"        .map(|prime| prime * prime)\n"
"        .collect::<Vec<_>>();\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-iterator.md:17
#, fuzzy
msgid ""
"`Iterator` implements `fn collect<B>(self) -> B where B: FromIterator<Self::"
"Item>, Self: Sized`"
msgstr ""
"Implementy `Iteratora` `fn zbieraj<B>(ja) -> B Gdzie B: FromIterator<Self::"
"Item>, Wasny: Wielkoci`"

#: src/traits/from-iterator.md:23
#, fuzzy
msgid ""
"There are also implementations which let you do cool things like convert an "
"`Iterator<Item = Result<V, E>>` into a `Result<Vec<V>, E>`."
msgstr ""
"Istniej r贸wnie偶 implementacje, kt贸re pozwalaj robi fajne rzeczy, takie "
"jak konwersja pliku `Iterator<Pozycja = Wynik<V, E>>` w `Wynik<Vec<V>, E>`."

#: src/traits/from-into.md:1
#, fuzzy
msgid "`From` and `Into`"
msgstr "`Od` i `do`"

#: src/traits/from-into.md:3
#, fuzzy
msgid ""
"Types implement [`From`](https://doc.rust-lang.org/std/convert/trait.From."
"html) and [`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) to "
"facilitate type conversions:"
msgstr ""
"Typy implementuj [`From`](https://doc.rust-lang.org/std/convert/trait.From."
"html) i [`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) w "
"celu uatwienia konwersji typ贸w:"

#: src/traits/from-into.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s = String::from(\"hello\");\n"
"    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);\n"
"    let one = i16::from(true);\n"
"    let bigger = i32::from(123i16);\n"
"    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-into.md:15
#, fuzzy
msgid ""
"[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) is "
"automatically implemented when [`From`](https://doc.rust-lang.org/std/"
"convert/trait.From.html) is implemented:"
msgstr ""
"[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) jest "
"automatycznie implementowane po zaimplementowaniu [`From`](https://doc.rust-"
"lang.org/std/convert/trait.From.html):"

#: src/traits/from-into.md:17
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s: String = \"hello\".into();\n"
"    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();\n"
"    let one: i16 = true.into();\n"
"    let bigger: i32 = 123i16.into();\n"
"    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-into.md:29
#, fuzzy
msgid ""
"That's why it is common to only implement `From`, as your type will get "
"`Into` implementation too."
msgstr ""
"Dlatego czsto implementuje si tylko `From`, poniewa偶 tw贸j typ r贸wnie偶 "
"otrzyma implementacj `Into`."

#: src/traits/from-into.md:30
#, fuzzy
msgid ""
"When declaring a function argument input type like \"anything that can be "
"converted into a `String`\", the rule is opposite, you should use `Into`. "
"Your function will accept types that implement `From` and those that _only_ "
"implement `Into`."
msgstr ""
"Deklarujc typ wejciowy argumentu funkcji, taki jak wszystko, co mo偶na "
"przekonwertowa na `String`, zasada jest odwrotna, nale偶y u偶y `Into`. "
"Twoja funkcja akceptuje typy, kt贸re implementuj `From` i te, kt贸re _tylko_ "
"implementuj `Into`."

#: src/traits/read-write.md:1
#, fuzzy
msgid "`Read` and `Write`"
msgstr "`Odczyt` i `Zapis`"

#: src/traits/read-write.md:3
#, fuzzy
msgid ""
"Using [`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) and "
"[`BufRead`](https://doc.rust-lang.org/std/io/trait.BufRead.html), you can "
"abstract over `u8` sources:"
msgstr ""
"U偶ywajc [`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) i "
"[`BufRead`](https://doc.rust-lang.org/std/io/trait.BufRead.html), mo偶esz "
"wyodrbni 藕r贸da `u8`:"

#: src/traits/read-write.md:5
msgid ""
"```rust,editable\n"
"use std::io::{BufRead, BufReader, Read, Result};\n"
"```"
msgstr ""

#: src/traits/read-write.md:8
msgid ""
"fn count_lines\\<R: Read>(reader: R) -> usize { let buf_reader = BufReader::"
"new(reader); buf_reader.lines().count() }"
msgstr ""

#: src/traits/read-write.md:13
msgid ""
"fn main() -> Result\\<()> { let slice: &\\[u8\\] = b\"foo\\nbar\\nbaz\\n\"; "
"println!(\"lines in slice: {}\", count_lines(slice));"
msgstr ""

#: src/traits/read-write.md:17
msgid ""
"```\n"
"let file = std::fs::File::open(std::env::current_exe()?)?;\n"
"println!(\"lines in file: {}\", count_lines(file));\n"
"Ok(())\n"
"```"
msgstr ""

#: src/traits/read-write.md:23
#, fuzzy
msgid ""
"Similarly, [`Write`](https://doc.rust-lang.org/std/io/trait.Write.html) lets "
"you abstract over `u8` sinks:"
msgstr ""
"Podobnie, [`Write`](https://doc.rust-lang.org/std/io/trait.Write.html) "
"pozwala na abstrakcj nad ujciami `u8`:"

#: src/traits/read-write.md:25
msgid ""
"```rust,editable\n"
"use std::io::{Result, Write};\n"
"```"
msgstr ""

#: src/traits/read-write.md:28
msgid ""
"fn log\\<W: Write>(writer: &mut W, msg: &str) -> Result\\<()> { writer."
"write_all(msg.as_bytes())?; writer.write_all(\"\\n\".as_bytes()) }"
msgstr ""

#: src/traits/read-write.md:33
msgid ""
"fn main() -> Result\\<()> { let mut buffer = Vec::new(); log(&mut buffer, "
"\"Hello\")?; log(&mut buffer, \"World\")?; println!(\"Logged: {:?}\", "
"buffer); Ok(()) }"
msgstr ""

#: src/traits/operators.md:1
#, fuzzy
msgid "`Add`, `Mul`, ..."
msgstr "`Dodaj`, `Mul`, ..."

#: src/traits/operators.md:3
#, fuzzy
msgid ""
"Operator overloading is implemented via traits in [`std::ops`](https://doc."
"rust-lang.org/std/ops/index.html):"
msgstr ""
"Przeci偶anie operatora jest realizowane poprzez cechy w [`std::ops`](https://"
"doc.rust-lang.org/std/ops/index.html):"

#: src/traits/operators.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Copy, Clone)]\n"
"struct Point { x: i32, y: i32 }\n"
"```"
msgstr ""

#: src/traits/operators.md:9 src/exercises/day-2/solutions-morning.md:46
msgid "impl std::ops::Add for Point { type Output = Self;"
msgstr ""

#: src/traits/operators.md:12
#, fuzzy
msgid ""
"```\n"
"fn add(self, other: Self) -> Self {\n"
"    Self {x: self.x + other.x, y: self.y + other.y}\n"
"}\n"
"```"
msgstr ""
"```\n"
"fn add(sam, inny: Wasny) -> Wasny {\n"
"    Ja {x: ja.x + inny.x, y: ja.y + inny.y}\n"
"}\n"
"```"

#: src/traits/operators.md:17
msgid ""
"fn main() { let p1 = Point { x: 10, y: 20 }; let p2 = Point { x: 100, y: "
"200 }; println!(\"{:?} + {:?} = {:?}\", p1, p2, p1 + p2); }"
msgstr ""

#: src/traits/operators.md:26 src/traits/drop.md:34
#, fuzzy
msgid "Discussion points:"
msgstr "Punkty dyskusji:"

#: src/traits/operators.md:28
#, fuzzy
msgid ""
"You could implement `Add` for `&Point`. In which situations is that useful? "
msgstr ""
"Mo偶esz zaimplementowa `Add` dla `&Point`. W jakich sytuacjach jest to "
"przydatne?"

#: src/traits/operators.md:29
#, fuzzy
msgid ""
"Answer: `Add:add` consumes `self`. If type `T` for which you are overloading "
"the operator is not `Copy`, you should consider overloading the operator for "
"`&T` as well. This avoids unnecessary cloning on the call site."
msgstr ""
"Odpowied藕: `Add:add` zu偶ywa `self`. Jeli wpisz `T` za kt贸rym jeste "
"przeci偶anie operatora nie jest `Kopiuj`, powiniene rozwa偶y przeci偶anie "
"operator dla `&T` r贸wnie偶. Pozwala to unikn niepotrzebnego klonowania w "
"pliku Zadzwo do serwisu."

#: src/traits/operators.md:33
#, fuzzy
msgid "Why is `Output` an associated type? Could it be made a type parameter?"
msgstr ""
"Dlaczego `Output` jest powizanym typem? Czy mo偶na go ustawi jako parametr "
"typu?"

#: src/traits/operators.md:34
#, fuzzy
msgid ""
"Short answer: Type parameters are controlled by the caller, but associated "
"types (like `Output`) are controlled by the implementor of a trait."
msgstr ""
"Kr贸tka odpowied藕: Parametry typu s kontrolowane przez dzwonicego, ale "
"powizane typy (takie jak `Output`) s kontrolowane przez implementatora a "
"cecha."

#: src/traits/drop.md:1
#, fuzzy
msgid "The `Drop` Trait"
msgstr "Cecha Upu."

#: src/traits/drop.md:3
#, fuzzy
msgid ""
"Values which implement [`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop."
"html) can specify code to run when they go out of scope:"
msgstr ""
"Wartoci, kt贸re implementuj [`Drop`](https://doc.rust-lang.org/std/ops/"
"trait.Drop.html), mog okrela kod do wykonania, gdy wykraczaj poza zakres:"

#: src/traits/drop.md:5
msgid ""
"```rust,editable\n"
"struct Droppable {\n"
"    name: &'static str,\n"
"}\n"
"```"
msgstr ""

#: src/traits/drop.md:10
msgid ""
"impl Drop for Droppable { fn drop(&mut self) { println!(\"Dropping {}\", "
"self.name); } }"
msgstr ""

#: src/traits/drop.md:16
msgid ""
"fn main() { let a = Droppable { name: \"a\" }; { let b = Droppable { name: "
"\"b\" }; { let c = Droppable { name: \"c\" }; let d = Droppable { name: "
"\"d\" }; println!(\"Exiting block B\"); } println!(\"Exiting block A\"); } "
"drop(a); println!(\"Exiting main\"); }"
msgstr ""

#: src/traits/drop.md:36
#, fuzzy
msgid "Why does not `Drop::drop` take `self`?"
msgstr "Dlaczego `Drop::drop` nie przyjmuje `self`?"

#: src/traits/drop.md:37
#, fuzzy
msgid ""
"Short-answer: If it did, `std::mem::drop` would be called at the end of the "
"block, resulting in another call to `Drop::drop`, and a stack overflow!"
msgstr ""
"Kr贸tka odpowied藕: gdyby tak byo, `std::mem::drop` zostaoby wywoane na "
"kocu blok, co skutkuje kolejnym wywoaniem `Drop::drop` i stosem przelewowy!"

#: src/traits/drop.md:40
#, fuzzy
msgid "Try replacing `drop(a)` with `a.drop()`."
msgstr "Spr贸buj zamieni `drop(a)` na `a.drop()`."

#: src/traits/default.md:1
#, fuzzy
msgid "The `Default` Trait"
msgstr "Cecha Domylna."

#: src/traits/default.md:3
#, fuzzy
msgid ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) trait "
"provides a default implementation of a trait."
msgstr ""
"Cecha [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) "
"zapewnia domyln implementacj cechy."

#: src/traits/default.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Default)]\n"
"struct Derived {\n"
"    x: u32,\n"
"    y: String,\n"
"    z: Implemented,\n"
"}\n"
"```"
msgstr ""

#: src/traits/default.md:13
msgid "\\#\\[derive(Debug)\\] struct Implemented(String);"
msgstr ""

#: src/traits/default.md:16
#, fuzzy
msgid ""
"impl Default for Implemented { fn default() -> Self { Self(\"John Smith\"."
"into()) } }"
msgstr ""
"impl Domylnie dla zaimplementowanych { fn default() -> Wasny { Self(\"Jan "
"Kowalski\".do()) } }"

#: src/traits/default.md:22
msgid ""
"fn main() { let default_struct: Derived = Default::default(); println!"
"(\"{default_struct:#?}\");"
msgstr ""

#: src/traits/default.md:26
msgid ""
"```\n"
"let almost_default_struct = Derived {\n"
"    y: \"Y is set!\".into(),\n"
"    ..Default::default()\n"
"};\n"
"println!(\"{almost_default_struct:#?}\");\n"
"```"
msgstr ""

#: src/traits/default.md:32
msgid ""
"```\n"
"let nothing: Option<Derived> = None;\n"
"println!(\"{:#?}\", nothing.unwrap_or_default());\n"
"```"
msgstr ""

#: src/traits/default.md:40
#, fuzzy
msgid ""
"It can be implemented directly or it can be derived via `#[derive(Default)]`."
msgstr ""
"Mo偶e by zaimplementowany bezporednio lub wyprowadzony przez "
"`#[derive(Default)]`."

#: src/traits/default.md:41
#, fuzzy
msgid ""
"Derived implementation will produce an instance where all fields are set to "
"their default values."
msgstr ""
"Implementacja pochodna utworzy instancj, w kt贸rej wszystkie pola zostan "
"ustawione na wartoci domylne."

#: src/traits/default.md:42
#, fuzzy
msgid "This means all types in the struct must implement `Default` too."
msgstr ""
"Oznacza to, 偶e wszystkie typy w strukturze musz r贸wnie偶 implementowa "
"`Default`."

#: src/traits/default.md:43
#, fuzzy
msgid ""
"Standard Rust types often implement `Default` with reasonable values (e.g. "
"`0`, `\"\"`, etc)."
msgstr ""
"Standardowe typy Rust czsto implementuj `Default` z rozsdnymi wartociami "
"(np. `0`, `\"\"` itp.)."

#: src/traits/default.md:44
#, fuzzy
msgid "The partial struct copy works nicely with default."
msgstr "Czciowa kopia struktury dobrze dziaa z ustawieniami domylnymi."

#: src/traits/default.md:45
#, fuzzy
msgid ""
"Rust standard library is aware that types can implement `Default` and "
"provides convenience methods that use it."
msgstr ""
"Standardowa biblioteka Rust jest wiadoma, 偶e typy mog implementowa "
"`Default` i zapewnia wygodne metody, kt贸re z niej korzystaj."

#: src/generics.md:3
#, fuzzy
msgid ""
"Rust support generics, which lets you abstract an algorithm (such as "
"sorting) over the types used in the algorithm."
msgstr ""
"Rust obsuguje typy og贸lne, kt贸re pozwalaj wyodrbni algorytm (taki jak "
"sortowanie) nad typami u偶ywanymi w algorytmie."

#: src/generics/data-types.md:3
#, fuzzy
msgid "You can use generics to abstract over the concrete field type:"
msgstr "Mo偶esz u偶y generycznych do abstrakcji nad konkretnym typem pola:"

#: src/generics/data-types.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point<T> {\n"
"    x: T,\n"
"    y: T,\n"
"}\n"
"```"
msgstr ""

#: src/generics/data-types.md:12
msgid ""
"fn main() { let integer = Point { x: 5, y: 10 }; let float = Point { x: 1.0, "
"y: 4.0 }; println!(\"{integer:?} and {float:?}\"); }"
msgstr ""

#: src/generics/methods.md:3
#, fuzzy
msgid "You can declare a generic type on your `impl` block:"
msgstr "Mo偶esz zadeklarowa typ og贸lny w swoim bloku `impl`:"

#: src/generics/methods.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point<T>(T, T);\n"
"```"
msgstr ""

#: src/generics/methods.md:9
#, fuzzy
msgid "impl"
msgstr "impl"

#: src/generics/methods.md:9
#, fuzzy
msgid " Point"
msgstr " Punkt"

#: src/generics/methods.md:9
#, fuzzy
msgid " { fn x(&self) -> &T { &self.0  // + 10 }"
msgstr " { fn x(&ja) -> &T { &sobie.0 // + 10 }"

#: src/generics/methods.md:14
#, fuzzy
msgid ""
"```\n"
"// fn set_x(&mut self, x: T)\n"
"```"
msgstr ""
"```\n"
"// fn set_x(&mut self, x: T)\n"
"```"

#: src/generics/methods.md:17
msgid "fn main() { let p = Point(5, 10); println!(\"p.x = {}\", p.x()); }"
msgstr ""

#: src/generics/methods.md:25
#, fuzzy
msgid ""
"_Q:_ Why `T` is specified twice in `impl<T> Point<T> {}`? Isn't that "
"redundant?"
msgstr ""
"_P:_ Dlaczego `T` jest okrelone dwukrotnie w `impl<T> Point<T> {}`? Czy to "
"nie jest zbdne?"

#: src/generics/methods.md:26
#, fuzzy
msgid ""
"This is because it is a generic implementation section for generic type. "
"They are independently generic."
msgstr ""
"Dzieje si tak, poniewa偶 jest to og贸lna sekcja implementacji dla typu "
"og贸lnego. S niezale偶nie og贸lne."

#: src/generics/methods.md:27
#, fuzzy
msgid "It means these methods are defined for any `T`."
msgstr "Oznacza to, 偶e te metody s zdefiniowane dla dowolnego `T`."

#: src/generics/methods.md:28
#, fuzzy
msgid "It is possible to write `impl Point<u32> { .. }`. "
msgstr "Mo偶na napisa `impl Point<u32> { .. }`."

#: src/generics/methods.md:29
#, fuzzy
msgid ""
"`Point` is still generic and you can use `Point<f64>`, but methods in this "
"block will only be available for `Point<u32>`."
msgstr ""
"`Point` jest nadal og贸lny i mo偶esz u偶y `Point<f64>`, ale metody w tym bloku "
"bd dostpne tylko dla `Point<u32>`."

#: src/generics/trait-bounds.md:3
#, fuzzy
msgid ""
"When working with generics, you often want to require the types to implement "
"some trait, so that you can call this trait's methods."
msgstr ""
"Podczas pracy z typami og贸lnymi czsto chcesz wymaga implementacji typ贸w "
"jak cech, aby mo偶na byo wywoa metody tej cechy."

#: src/generics/trait-bounds.md:6
#, fuzzy
msgid "You can do this with `T: Trait` or `impl Trait`:"
msgstr "Mo偶esz to zrobi za pomoc `T: Cecha` lub `impl Cecha`:"

#: src/generics/trait-bounds.md:8
msgid ""
"```rust,editable\n"
"fn duplicate<T: Clone>(a: T) -> (T, T) {\n"
"    (a.clone(), a.clone())\n"
"}\n"
"```"
msgstr ""

#: src/generics/trait-bounds.md:13
#, fuzzy
msgid "// Syntactic sugar for: //   fn add_42_millions\\<T: Into"
msgstr "// Cukier syntaktyczny do: // fn add_42_millions\\<T: Into"

#: src/generics/trait-bounds.md:14
#, fuzzy
msgid "\\>(x: T) -> i32 { fn add_42_millions(x: impl Into"
msgstr "\\>(x: T) -> i32 { fn add_42_milions(x: impl Into"

#: src/generics/trait-bounds.md:15
#, fuzzy
msgid ") -> i32 { x.into() + 42_000_000 }"
msgstr ") -> i32 { x.do() + 42_000_000 }"

#: src/generics/trait-bounds.md:19
msgid "// struct NotClonable;"
msgstr ""

#: src/generics/trait-bounds.md:21
msgid ""
"fn main() { let foo = String::from(\"foo\"); let pair = duplicate(foo); "
"println!(\"{pair:?}\");"
msgstr ""

#: src/generics/trait-bounds.md:26
msgid ""
"```\n"
"let many = add_42_millions(42_i8);\n"
"println!(\"{many}\");\n"
"let many_more = add_42_millions(10_000_000);\n"
"println!(\"{many_more}\");\n"
"```"
msgstr ""

#: src/generics/trait-bounds.md:35
msgid "Show a `where` clause, students will encounter it when reading code."
msgstr ""

#: src/generics/trait-bounds.md:37
msgid ""
"```rust,ignore\n"
"fn duplicate<T>(a: T) -> (T, T)\n"
"where\n"
"    T: Clone,\n"
"{\n"
"    (a.clone(), a.clone())\n"
"}\n"
"```"
msgstr ""

#: src/generics/trait-bounds.md:46
#, fuzzy
msgid "It declutters the function signature if you have many parameters."
msgstr "Odczytuje sygnatur funkcji, jeli masz wiele parametr贸w."

#: src/generics/trait-bounds.md:47
#, fuzzy
msgid "It has additional features making it more powerful."
msgstr "Posiada dodatkowe funkcje, dziki kt贸rym jest pot偶niejszy."

#: src/generics/trait-bounds.md:48
#, fuzzy
msgid ""
"If someone asks, the extra feature is that the type on the left of \":\" can "
"be arbitrary, like `Option<T>`."
msgstr ""
"Jeli kto zapyta, dodatkow cech jest to, 偶e typ po lewej stronie : mo偶e "
"by dowolny, na przykad `Option<T>`."

#: src/generics/impl-trait.md:1
#, fuzzy
msgid "`impl Trait`"
msgstr "`impl Cecha`"

#: src/generics/impl-trait.md:3
#, fuzzy
msgid ""
"Similar to trait bounds, an `impl Trait` syntax can be used in function "
"arguments and return values:"
msgstr ""
"Podobnie jak w przypadku granic cech, skadnia `impl Trait` mo偶e by u偶ywana "
"w funkcji argumenty i zwracane wartoci:"

#: src/generics/impl-trait.md:6 src/generics/trait-objects.md:5
#: src/generics/trait-objects.md:28
msgid ""
"```rust,editable\n"
"use std::fmt::Display;\n"
"```"
msgstr ""

#: src/generics/impl-trait.md:9
#, fuzzy
msgid ""
"fn get_x(name: impl Display) -> impl Display { format!(\"Hello {name}\") }"
msgstr ""
"fn get_x(nazwa: impl Wywietl) -> impl Wywietl { format!(\"Witaj {imi}\") }"

#: src/generics/impl-trait.md:13
msgid "fn main() { let x = get_x(\"foo\"); println!(\"{x}\"); }"
msgstr ""

#: src/generics/impl-trait.md:19
#, fuzzy
msgid "`impl Trait` cannot be used with the `::<>` turbo fish syntax."
msgstr "`impl Trait` nie mo偶e by u偶ywany ze skadni `::<>` turbofish."

#: src/generics/impl-trait.md:20
#, fuzzy
msgid "`impl Trait` allows you to work with types which you cannot name."
msgstr "`impl Trait` umo偶liwia prac z typami, kt贸rych nie mo偶na nazwa."

#: src/generics/impl-trait.md:24
#, fuzzy
msgid ""
"The meaning of `impl Trait` is a bit different in the different positions."
msgstr "Znaczenie impl Cecha jest nieco inne w r贸偶nych pozycjach."

#: src/generics/impl-trait.md:26
#, fuzzy
msgid ""
"For a parameter, `impl Trait` is like an anonymous generic parameter with a "
"trait bound."
msgstr ""
"W przypadku parametru impl Trait jest jak anonimowy parametr og贸lny z "
"powizaniem z cech."

#: src/generics/impl-trait.md:27
#, fuzzy
msgid ""
"For a return type, it means that the return type is some concrete type that "
"implements the trait, without naming the type. This can be useful when you "
"don't want to expose the concrete type in a public API."
msgstr ""
"W przypadku typu zwracanego oznacza to, 偶e typ zwracany jest jakim "
"konkretnym typem, kt贸ry implementuje cech, bez okrelania rodzaju. Mo偶e to "
"by przydatne, gdy nie chcesz ujawnia konkretnego typu w pliku publiczne "
"API."

#: src/generics/impl-trait.md:31
#, fuzzy
msgid ""
"This example is great, because it uses `impl Display` twice. It helps to "
"explain that nothing here enforces that it is _the same_ `impl Display` "
"type. If we used a single  `T: Display`, it would enforce the constraint "
"that input `T` and return `T` type are the same type. It would not work for "
"this particular function, as the type we expect as input is likely not what "
"`format!` returns. If we wanted to do the same via `: Display` syntax, we'd "
"need two independent generic parameters."
msgstr ""
"Ten przykad jest wietny, poniewa偶 dwukrotnie u偶ywa `impl Display`. Pomaga "
"to wyjani nic tutaj nie wymusza, 偶e jest to _ten sam_ typ `impl Display`. "
"Gdybymy u偶yli jednego `T: Display`, wymuszaoby ograniczenie, 偶e wejcie "
"`T` i zwracany typ `T` s tego samego typu. Nie zadziaaoby to dla tej "
"konkretnej funkcji, poniewa偶 typ, kt贸rego oczekujemy jako dane wejciowe, "
"prawdopodobnie nie co zwraca `format!`. Gdybymy chcieli zrobi to samo za "
"pomoc skadni `: Display`, potrzebowalibymy dw贸ch niezale偶ne parametry "
"og贸lne."

#: src/generics/closures.md:3
#, fuzzy
msgid ""
"Closures or lambda expressions have types which cannot be named. However, "
"they implement special [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn."
"html), [`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), and "
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) traits:"
msgstr ""
"Domknicia lub wyra偶enia lambda maj typy, kt贸rych nie mo偶na nazwa. Jednak "
"oni zaimplementowa specjalne [`Fn`](https://doc.rust-lang.org/std/ops/trait."
"Fn.html), [`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html) oraz "
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) cechy:"

#: src/generics/closures.md:8
msgid ""
"```rust,editable\n"
"fn apply_with_log(func: impl FnOnce(i32) -> i32, input: i32) -> i32 {\n"
"    println!(\"Calling function on {input}\");\n"
"    func(input)\n"
"}\n"
"```"
msgstr ""

#: src/generics/closures.md:14
msgid "fn main() { let add_3 = |x| x + 3; let mul_5 = |x| x * 5;"
msgstr ""

#: src/generics/closures.md:18
msgid ""
"```\n"
"println!(\"add_3: {}\", apply_with_log(add_3, 10));\n"
"println!(\"mul_5: {}\", apply_with_log(mul_5, 20));\n"
"```"
msgstr ""

#: src/generics/closures.md:25
#, fuzzy
msgid ""
"If you have an `FnOnce`, you may only call it once. It might consume "
"captured values."
msgstr ""
"Jeli masz `FnOnce`, mo偶esz wywoa go tylko raz. Mo偶e zu偶ywa przechwycone "
"wartoci."

#: src/generics/closures.md:27
#, fuzzy
msgid ""
"An `FnMut` might mutate captured values, so you can call it multiple times "
"but not concurrently."
msgstr ""
"`FnMut` mo偶e zmutowa przechwycone wartoci, wic mo偶esz go wywoywa wiele "
"razy, ale nie jednoczenie."

#: src/generics/closures.md:29
#, fuzzy
msgid ""
"An `Fn` neither consumes nor mutates captured values, or perhaps captures "
"nothing at all, so it can be called multiple times concurrently."
msgstr ""
"`Fn` ani nie konsumuje, ani nie mutuje przechwyconych wartoci, a by mo偶e w "
"og贸le nie przechwytuje niczego, wic mo偶e by wywoywane wiele razy "
"jednoczenie."

#: src/generics/closures.md:32
#, fuzzy
msgid ""
"`FnMut` is a subtype of `FnOnce`. `Fn` is a subtype of `FnMut` and `FnOnce`. "
"I.e. you can use an `FnMut` wherever an `FnOnce` is called for, and you can "
"use an `Fn` wherever an `FnMut` or `FnOnce` is called for."
msgstr ""
"`FnMut` jest podtypem `FnOnce`. `Fn` jest podtypem `FnMut` i `FnOnce`. Tj. "
"mo偶esz u偶y `FnMut` wszdzie tam, gdzie wymagane jest `FnOnce`, a `Fn` mo偶na "
"u偶y wszdzie tam, gdzie `FnMut` lub `FnOnce` jest wezwany."

#: src/generics/closures.md:36
#, fuzzy
msgid "`move` closures only implement `FnOnce`."
msgstr "Zamknicia `move` implementuj tylko `FnOnce`."

#: src/generics/monomorphization.md:3
#, fuzzy
msgid "Generic code is turned into non-generic code based on the call sites:"
msgstr ""
"Kod og贸lny jest przeksztacany w kod nierodzajowy na podstawie witryn "
"wywoujcych:"

#: src/generics/monomorphization.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let integer = Some(5);\n"
"    let float = Some(5.0);\n"
"}\n"
"```"
msgstr ""

#: src/generics/monomorphization.md:12
#, fuzzy
msgid "behaves as if you wrote"
msgstr "zachowuje si tak, jakby napisa"

#: src/generics/monomorphization.md:14
msgid ""
"```rust,editable\n"
"enum Option_i32 {\n"
"    Some(i32),\n"
"    None,\n"
"}\n"
"```"
msgstr ""

#: src/generics/monomorphization.md:20
#, fuzzy
msgid "enum Option_f64 { Some(f64), None, }"
msgstr "wyliczenie Option_f64 { Niekt贸re (f64), Nic, }"

#: src/generics/monomorphization.md:25
msgid ""
"fn main() { let integer = Option_i32::Some(5); let float = Option_f64::"
"Some(5.0); }"
msgstr ""

#: src/generics/monomorphization.md:31
#, fuzzy
msgid ""
"This is a zero-cost abstraction: you get exactly the same result as if you "
"had hand-coded the data structures without the abstraction."
msgstr ""
"Jest to abstrakcja o zerowych kosztach: otrzymujesz dokadnie taki sam "
"wynik, jakby mia rcznie zakodowa struktury danych bez abstrakcji."

#: src/generics/trait-objects.md:3
#, fuzzy
msgid "We've seen how a function can take arguments which implement a trait:"
msgstr ""
"Widzielimy, jak funkcja mo偶e przyjmowa argumenty, kt贸re implementuj cech:"

#: src/generics/trait-objects.md:8
msgid "fn print\\<T: Display>(x: T) { println!(\"Your value: {x}\"); }"
msgstr ""

#: src/generics/trait-objects.md:12
msgid "fn main() { print(123); print(\"Hello\"); }"
msgstr ""

#: src/generics/trait-objects.md:18
#, fuzzy
msgid ""
"However, how can we store a collection of mixed types which implement "
"`Display`?"
msgstr ""
"Jak jednak mo偶emy przechowywa kolekcj typ贸w mieszanych, kt贸re implementuj "
"`Display`?"

#: src/generics/trait-objects.md:20
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let xs = vec![123, \"Hello\"];\n"
"}\n"
"```"
msgstr ""

#: src/generics/trait-objects.md:26
#, fuzzy
msgid "For this, we need _trait objects_:"
msgstr "W tym celu potrzebujemy _obiekt贸w cech_:"

#: src/generics/trait-objects.md:31
msgid "fn main() { let xs: Vec\\<Box"
msgstr ""

#: src/generics/trait-objects.md:32
msgid ""
"\\> = vec![Box::new(123), Box::new(\"Hello\")\\]; for x in xs { println!"
"(\"x: {x}\"); } }"
msgstr ""

#: src/generics/trait-objects.md:39
#, fuzzy
msgid "Memory layout after allocating `xs`:"
msgstr "Ukad pamici po przydzieleniu `xs`:"

#: src/generics/trait-objects.md:41
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - "
"- - -.\n"
":                           :     :                                               :\n"
":    "
"xs                     :     :                                               :\n"
":   +-----------+-------+   :     :   +-----+-----"
"+                               :\n"
":   | ptr       |   o---+---+-----+-->| o o | o o "
"|                               :\n"
":   | len       |     2 |   :     :   +-|-|-+-|-|-"
"+                               :\n"
":   | capacity  |     2 |   :     :     | |   | |   +----+----+----+----+----"
"+    :\n"
":   +-----------+-------+   :     :     | |   | '-->| H  | e  | l  | l  | o  "
"|    :\n"
":                           :     :     | |   |     +----+----+----+----+----"
"+    :\n"
"`- - - - - - - - - - - - - -'     :     | |   "
"|                                   :\n"
"                                  :     | |   |     "
"+-------------------------+   :\n"
"                                  :     | |   '---->| \"<str as Display>::"
"fmt\" |   :\n"
"                                  :     | |         "
"+-------------------------+   :\n"
"                                  :     | "
"|                                       :\n"
"                                  :     | |   +----+----+----+----"
"+               :\n"
"                                  :     | '-->| 7b | 00 | 00 | 00 "
"|               :\n"
"                                  :     |     +----+----+----+----"
"+               :\n"
"                                  :     "
"|                                         :\n"
"                                  :     |     +-------------------------"
"+         :\n"
"                                  :     '---->| \"<i32 as Display>::fmt\" "
"|         :\n"
"                                  :           +-------------------------"
"+         :\n"
"                                  :                                               :\n"
"                                  :                                               :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - "
"- - -'\n"
"```"
msgstr ""

#: src/generics/trait-objects.md:69
#, fuzzy
msgid ""
"Similarly, you need a trait object if you want to return different types "
"implementing a trait:"
msgstr ""
"Podobnie potrzebujesz obiektu cechy, jeli chcesz zwr贸ci r贸偶ne typy "
"wdro偶enie cechy:"

#: src/generics/trait-objects.md:72
msgid ""
"```rust,editable\n"
"fn numbers(n: i32) -> Box<dyn Iterator<Item=i32>> {\n"
"    if n > 0 {\n"
"        Box::new(0..n)\n"
"    } else {\n"
"        Box::new((n..0).rev())\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/generics/trait-objects.md:81
msgid ""
"fn main() { println!(\"{:?}\", numbers(-5).collect::\\<Vec\\<_\\>>()); "
"println!(\"{:?}\", numbers(5).collect::\\<Vec\\<_\\>>()); }"
msgstr ""

#: src/exercises/day-3/morning.md:1
#, fuzzy
msgid "Day 3: Morning Exercises"
msgstr "Dzie 3: wiczenia poranne"

#: src/exercises/day-3/morning.md:3
#, fuzzy
msgid "We will design a classical GUI library traits and trait objects."
msgstr "Zaprojektujemy klasyczn bibliotek GUI cech i obiekt贸w cech."

#: src/exercises/day-3/simple-gui.md:3
#, fuzzy
msgid ""
"Let us design a classical GUI library using our new knowledge of traits and "
"trait objects."
msgstr ""
"Zaprojektujmy klasyczn bibliotek GUI, korzystajc z naszej nowej wiedzy na "
"temat cech i obiekty cech."

#: src/exercises/day-3/simple-gui.md:6
#, fuzzy
msgid "We will have a number of widgets in our library:"
msgstr "W naszej bibliotece bdziemy mie kilka wid偶et贸w:"

#: src/exercises/day-3/simple-gui.md:8
#, fuzzy
msgid "`Window`: has a `title` and contains other widgets."
msgstr "`Okno`: ma `tytu` i zawiera inne wid偶ety."

#: src/exercises/day-3/simple-gui.md:9
#, fuzzy
msgid ""
"`Button`: has a `label` and a callback function which is invoked when the "
"button is pressed."
msgstr ""
"`Button`: ma `etykiet` i funkcj wywoania zwrotnego, kt贸ra jest "
"wywoywana, gdy przycisk jest wcinity."

#: src/exercises/day-3/simple-gui.md:11
#, fuzzy
msgid "`Label`: has a `label`."
msgstr "`Etykieta`: ma `etykiet`."

#: src/exercises/day-3/simple-gui.md:13
#, fuzzy
msgid "The widgets will implement a `Widget` trait, see below."
msgstr "Wid偶ety zaimplementuj cech `Widget`, patrz poni偶ej."

#: src/exercises/day-3/simple-gui.md:15
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/>, fill in the missing "
"`draw_into` methods so that you implement the `Widget` trait:"
msgstr ""
"Skopiuj poni偶szy kod na <https://play.rust-lang.org/>, uzupenij brakujce "
"metody `draw_into`, aby zaimplementowa cech `Widget`:"

#: src/exercises/day-3/simple-gui.md:18
#: src/exercises/day-3/safe-ffi-wrapper.md:25
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_imports, unused_variables, dead_code)]\n"
"```"
msgstr ""
"```rust,should_panic\n"
"// TODO: usu to jak skoczysz implementacj.\n"
"#![allow(unused_imports, unused_variables, dead_code)]\n"
"```"

#: src/exercises/day-3/simple-gui.md:22
msgid ""
"pub trait Widget { /// Natural width of `self`. fn width(&self) -> usize;"
msgstr ""
"pub trait Widget { /// Naturalna szeroko `self`. fn width(&self) -> usize;"

#: src/exercises/day-3/simple-gui.md:26
#: src/exercises/day-3/solutions-morning.md:27
msgid ""
"```\n"
"/// Draw the widget into a buffer.\n"
"fn draw_into(&self, buffer: &mut dyn std::fmt::Write);\n"
"```"
msgstr ""
"```\n"
"/// Narysuj widget w buforze.\n"
"fn draw_into(&self, buffer: &mut dyn std::fmt::Write);\n"
"```"

#: src/exercises/day-3/simple-gui.md:29
#: src/exercises/day-3/solutions-morning.md:30
msgid ""
"```\n"
"/// Draw the widget on standard output.\n"
"fn draw(&self) {\n"
"    let mut buffer = String::new();\n"
"    self.draw_into(&mut buffer);\n"
"    println!(\"{buffer}\");\n"
"}\n"
"```"
msgstr ""
"```\n"
"/// Narysuj widget na standardowym wyjciu.\n"
"fn draw(&self) {\n"
"    let mut buffer = String::new();\n"
"    self.draw_into(&mut buffer);\n"
"    println!(\"{buffer}\");\n"
"}\n"
"```"

#: src/exercises/day-3/simple-gui.md:37
#: src/exercises/day-3/solutions-morning.md:38
msgid "pub struct Label { label: String, }"
msgstr "pub struct Label { label: String, }"

#: src/exercises/day-3/simple-gui.md:41
#: src/exercises/day-3/solutions-morning.md:42
msgid ""
"impl Label { fn new(label: &str) -> Label { Label { label: label."
"to_owned(), } } }"
msgstr ""
"impl Label { fn new(label: &str) -> Label { Label { label: label."
"to_owned(), } } }"

#: src/exercises/day-3/simple-gui.md:49
#: src/exercises/day-3/solutions-morning.md:50
msgid "pub struct Button { label: Label, callback: Box\\<dyn FnMut()>, }"
msgstr "pub struct Button { label: Label, callback: Box\\<dyn FnMut()>, }"

#: src/exercises/day-3/simple-gui.md:54
#: src/exercises/day-3/solutions-morning.md:55
msgid ""
"impl Button { fn new(label: &str, callback: Box\\<dyn FnMut()>) -> Button "
"{ Button { label: Label::new(label), callback, } } }"
msgstr ""
"impl Button { fn new(label: &str, callback: Box\\<dyn FnMut()>) -> Button "
"{ Button { label: Label::new(label), callback, } } }"

#: src/exercises/day-3/simple-gui.md:63
#: src/exercises/day-3/solutions-morning.md:64
msgid "pub struct Window { title: String, widgets: Vec\\<Box"
msgstr "pub struct Window { title: String, widgets: Vec\\<Box"

#: src/exercises/day-3/simple-gui.md:65
#: src/exercises/day-3/solutions-morning.md:66
msgid "\\>, }"
msgstr "\\>, }"

#: src/exercises/day-3/simple-gui.md:68
#: src/exercises/day-3/solutions-morning.md:69
msgid ""
"impl Window { fn new(title: &str) -> Window { Window { title: title."
"to_owned(), widgets: Vec::new(), } }"
msgstr ""
"impl Window { fn new(title: &str) -> Window { Window { title: title."
"to_owned(), widgets: Vec::new(), } }"

#: src/exercises/day-3/simple-gui.md:76
#: src/exercises/day-3/solutions-morning.md:77
msgid ""
"```\n"
"fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
"    self.widgets.push(widget);\n"
"}\n"
"```"
msgstr ""
"```\n"
"fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
"    self.widgets.push(widget);\n"
"}\n"
"```"

#: src/exercises/day-3/simple-gui.md:82
msgid "impl Widget for Label { fn width(&self) -> usize { unimplemented!() }"
msgstr "impl Widget for Label { fn width(&self) -> usize { unimplemented!() }"

#: src/exercises/day-3/simple-gui.md:87 src/exercises/day-3/simple-gui.md:97
#: src/exercises/day-3/simple-gui.md:107
msgid ""
"```\n"
"fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"    unimplemented!()\n"
"}\n"
"```"
msgstr ""
"```\n"
"fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"    unimplemented!()\n"
"}\n"
"```"

#: src/exercises/day-3/simple-gui.md:92
msgid "impl Widget for Button { fn width(&self) -> usize { unimplemented!() }"
msgstr "impl Widget for Button { fn width(&self) -> usize { unimplemented!() }"

#: src/exercises/day-3/simple-gui.md:102
msgid "impl Widget for Window { fn width(&self) -> usize { unimplemented!() }"
msgstr "impl Widget for Window { fn width(&self) -> usize { unimplemented!() }"

#: src/exercises/day-3/simple-gui.md:112
msgid ""
"fn main() { let mut window = Window::new(\"Rust GUI Demo 1.23\"); window."
"add_widget(Box::new(Label::new(\"This is a small text GUI demo.\"))); window."
"add_widget(Box::new(Button::new( \"Click me!\", Box::new(|| println!(\"You "
"clicked the button!\")), ))); window.draw(); }"
msgstr ""

#: src/exercises/day-3/simple-gui.md:123
#, fuzzy
msgid "The output of the above program can be something simple like this:"
msgstr "Wyjcie powy偶szego programu mo偶e by czym prostym, takim jak to:"

#: src/exercises/day-3/simple-gui.md:125
msgid ""
"```text\n"
"========\n"
"Rust GUI Demo 1.23\n"
"========\n"
"```"
msgstr ""

#: src/exercises/day-3/simple-gui.md:130
#, fuzzy
msgid "This is a small text GUI demo."
msgstr "To jest maa tekstowa demonstracja GUI."

#: src/exercises/day-3/simple-gui.md:132
msgid "\\| Click me! |"
msgstr ""

#: src/exercises/day-3/simple-gui.md:135
#, fuzzy
msgid ""
"If you want to draw aligned text, you can use the [fill/alignment](https://"
"doc.rust-lang.org/std/fmt/index.html#fillalignment) formatting operators. In "
"particular, notice how you can pad with different characters (here a `'/'`) "
"and how you can control alignment:"
msgstr ""
"Jeli chcesz narysowa wyr贸wnany tekst, mo偶esz u偶y [wypenienie/wyr贸wnanie]"
"(https://doc.rust-lang.org/std/fmt/index.html#wyr贸wnanie) operatory "
"formatowania. W szczeg贸lnoci zwr贸 uwag, jak mo偶esz wypeni r贸偶ne znaki "
"(tutaj `'/'`) i jak mo偶esz kontrolowa wyr贸wnanie:"

#: src/exercises/day-3/simple-gui.md:140
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let width = 10;\n"
"    println!(\"left aligned:  |{:/<width$}|\", \"foo\");\n"
"    println!(\"centered:      |{:/^width$}|\", \"foo\");\n"
"    println!(\"right aligned: |{:/>width$}|\", \"foo\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-3/simple-gui.md:149
#, fuzzy
msgid ""
"Using such alignment tricks, you can for example produce output like this:"
msgstr ""
"Korzystajc z takich sztuczek zwizanych z wyr贸wnaniem, mo偶esz na przykad "
"uzyska takie dane wyjciowe:"

#: src/exercises/day-3/simple-gui.md:151
msgid ""
"```text\n"
"+--------------------------------+\n"
"|       Rust GUI Demo 1.23       |\n"
"+================================+\n"
"| This is a small text GUI demo. |\n"
"| +-----------+                  |\n"
"| | Click me! |                  |\n"
"| +-----------+                  |\n"
"+--------------------------------+\n"
"```"
msgstr ""

#: src/error-handling.md:3
#, fuzzy
msgid "Error handling in Rust is done using explicit control flow:"
msgstr ""
"Obsuga bd贸w w Rust odbywa si za pomoc jawnego przepywu sterowania:"

#: src/error-handling.md:5
#, fuzzy
msgid "Functions that can have errors list this in their return type,"
msgstr "Funkcje, kt贸re mog mie bdy, wymieniaj to w zwracanym typie,"

#: src/error-handling.md:6
#, fuzzy
msgid "There are no exceptions."
msgstr "Nie ma wyjtk贸w."

#: src/error-handling/panics.md:3
#, fuzzy
msgid "Rust will trigger a panic if a fatal error happens at runtime:"
msgstr "Rust wywoa panik, jeli w czasie wykonywania wystpi bd krytyczny:"

#: src/error-handling/panics.md:5
msgid ""
"```rust,editable,should_panic\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    println!(\"v[100]: {}\", v[100]);\n"
"}\n"
"```"
msgstr ""
"```rust,editable,should_panic\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    println!(\"v[100]: {}\", v[100]);\n"
"}\n"
"```"

#: src/error-handling/panics.md:12
#, fuzzy
msgid "Panics are for unrecoverable and unexpected errors."
msgstr "Paniki dotycz nieodwracalnych i nieoczekiwanych bd贸w."

#: src/error-handling/panics.md:13
#, fuzzy
msgid "Panics are symptoms of bugs in the program."
msgstr "Paniki to objawy bd贸w w programie."

#: src/error-handling/panics.md:14
#, fuzzy
msgid ""
"Use non-panicking APIs (such as `Vec::get`) if crashing is not acceptable."
msgstr ""
"U偶ywaj niepanikujcych interfejs贸w API (takich jak `Vec::get`), jeli awaria "
"jest nie do zaakceptowania."

#: src/error-handling/panic-unwind.md:1
#, fuzzy
msgid "Catching the Stack Unwinding"
msgstr "apanie rozwijajcego si stosu"

#: src/error-handling/panic-unwind.md:3
#, fuzzy
msgid ""
"By default, a panic will cause the stack to unwind. The unwinding can be "
"caught:"
msgstr "Domylnie panika spowoduje wycofanie stosu. Odwijanie mo偶na zapa:"

#: src/error-handling/panic-unwind.md:5
msgid ""
"```rust\n"
"use std::panic;\n"
"```"
msgstr ""

#: src/error-handling/panic-unwind.md:8
msgid ""
"let result = panic::catch_unwind(|| { println!(\"hello!\"); }); assert!"
"(result.is_ok());"
msgstr ""
"let result = panic::catch_unwind(|| { println!(\"cze!\"); }); assert!"
"(result.is_ok());"

#: src/error-handling/panic-unwind.md:13
msgid ""
"let result = panic::catch_unwind(|| { panic!(\"oh no!\"); }); assert!(result."
"is_err());"
msgstr ""
"let result = panic::catch_unwind(|| { panic!(\"o nie!\"); }); assert!(result."
"is_err());"

#: src/error-handling/panic-unwind.md:19
#, fuzzy
msgid ""
"This can be useful in servers which should keep running even if a single "
"request crashes."
msgstr ""
"Mo偶e to by przydatne na serwerach, kt贸re powinny dziaa, nawet jeli s "
"pojedyncze 偶dania awarii."

#: src/error-handling/panic-unwind.md:21
#, fuzzy
msgid "This does not work if `panic = 'abort'` is set in your `Cargo.toml`."
msgstr "To nie dziaa, jeli w twoim `Cargo.toml` ustawiono `panic = 'abort'`."

#: src/error-handling/result.md:1
#, fuzzy
msgid "Structured Error Handling with `Result`"
msgstr "Strukturalna obsuga bd贸w za pomoc `Result`"

#: src/error-handling/result.md:3
#, fuzzy
msgid ""
"We have already seen the `Result` enum. This is used pervasively when errors "
"are expected as part of normal operation:"
msgstr ""
"Widzielimy ju偶 enum `Result`. Jest to powszechnie stosowane, gdy wystpuj "
"bdy spodziewane w ramach normalnej eksploatacji:"

#: src/error-handling/result.md:6
msgid ""
"```rust\n"
"use std::fs::File;\n"
"use std::io::Read;\n"
"```"
msgstr ""
"```rust\n"
"use std::fs::File;\n"
"use std::io::Read;\n"
"```"

#: src/error-handling/result.md:10
msgid ""
"fn main() { let file = File::open(\"diary.txt\"); match file { Ok(mut file) "
"=> { let mut contents = String::new(); file.read_to_string(&mut contents); "
"println!(\"Dear diary: {contents}\"); }, Err(err) => { println!(\"The diary "
"could not be opened: {err}\"); } } }"
msgstr ""

#: src/error-handling/result.md:27
#, fuzzy
msgid ""
"As with `Option`, the successful value sits inside of `Result`, forcing the "
"developer to explicitly extract it. This encourages error checking. In the "
"case where an error should never happen, `unwrap()` or `expect()` can be "
"called, and this is a signal of the developer intent too."
msgstr ""
"Podobnie jak w przypadku `Opcji`, pomylna warto znajduje si wewntrz "
"`Result`, zmuszajc programist do tego wyra藕nie go wyodrbni. To zachca "
"do sprawdzania bd贸w. W przypadku, gdy bd nigdy nie powinien si "
"wydarzy, Mo偶na wywoa `unwrap()` lub `expect()`, co r贸wnie偶 jest sygnaem "
"intencji programisty."

#: src/error-handling/result.md:30
#, fuzzy
msgid ""
"`Result` documentation is a recommended read. Not during the course, but it "
"is worth mentioning.  It contains a lot of convenience methods and functions "
"that help functional-style programming. "
msgstr ""
"Dokumentacja `Result` jest zalecan lektur. Nie w trakcie kursu, ale warto "
"o tym wspomnie. Zawiera wiele wygodnych metod i funkcji, kt贸re pomagaj "
"programowa w stylu funkcjonalnym."

#: src/error-handling/try-operator.md:1
#, fuzzy
msgid "Propagating Errors with `?`"
msgstr "Propagowanie bd贸w za pomoc `?`"

#: src/error-handling/try-operator.md:3
#, fuzzy
msgid ""
"The try-operator `?` is used to return errors to the caller. It lets you "
"turn the common"
msgstr ""
"Operator try `?` su偶y do zwracania bd贸w do obiektu wywoujcego. Pozwala "
"si obr贸ci wsp贸lne"

#: src/error-handling/try-operator.md:6
msgid ""
"```rust,ignore\n"
"match some_expression {\n"
"    Ok(value) => value,\n"
"    Err(err) => return Err(err),\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"match some_expression {\n"
"    Ok(value) => value,\n"
"    Err(err) => return Err(err),\n"
"}\n"
"```"

#: src/error-handling/try-operator.md:13
#, fuzzy
msgid "into the much simpler"
msgstr "w du偶o prostsze"

#: src/error-handling/try-operator.md:15
msgid ""
"```rust,ignore\n"
"some_expression?\n"
"```"
msgstr ""
"```rust,ignore\n"
"jakie_wyra偶enie?\n"
"```"

#: src/error-handling/try-operator.md:19
#, fuzzy
msgid "We can use this to simplify our error handing code:"
msgstr "Mo偶emy u偶y tego, aby uproci nasz kod przekazywania bd贸w:"

#: src/error-handling/try-operator.md:21
msgid ""
"```rust,editable\n"
"use std::fs;\n"
"use std::io::{self, Read};\n"
"```"
msgstr ""
"```rust,editable\n"
"use std::fs;\n"
"use std::io::{self, Read};\n"
"```"

#: src/error-handling/try-operator.md:25
msgid ""
"fn read_username(path: &str) -> Result\\<String, io::Error> { let "
"username_file_result = fs::File::open(path);"
msgstr ""
"fn read_username(path: &str) -> Result\\<String, io::Error> { let "
"username_file_result = fs::File::open(path);"

#: src/error-handling/try-operator.md:28
msgid ""
"```\n"
"let mut username_file = match username_file_result {\n"
"    Ok(file) => file,\n"
"    Err(e) => return Err(e),\n"
"};\n"
"```"
msgstr ""
"```\n"
"let mut username_file = match username_file_result {\n"
"    Ok(file) => file,\n"
"    Err(e) => return Err(e),\n"
"};\n"
"```"

#: src/error-handling/try-operator.md:33
msgid ""
"```\n"
"let mut username = String::new();\n"
"```"
msgstr ""
"```\n"
"let mut username = String::new();\n"
"```"

#: src/error-handling/try-operator.md:35
msgid ""
"```\n"
"match username_file.read_to_string(&mut username) {\n"
"    Ok(_) => Ok(username),\n"
"    Err(e) => Err(e),\n"
"}\n"
"```"
msgstr ""
"```\n"
"match username_file.read_to_string(&mut username) {\n"
"    Ok(_) => Ok(username),\n"
"    Err(e) => Err(e),\n"
"}\n"
"```"

#: src/error-handling/try-operator.md:41
msgid ""
"fn main() { //fs::write(\"config.dat\", \"alice\").unwrap(); let username = "
"read_username(\"config.dat\"); println!(\"username or error: "
"{username:?}\"); }"
msgstr ""
"fn main() { //fs::write(\"config.dat\", \"alice\").unwrap(); let username = "
"read_username(\"config.dat\"); println!(\"nazwa u偶ytkownika lub bd: "
"{username:?}\"); }"

#: src/error-handling/try-operator.md:52
#: src/error-handling/converting-error-types-example.md:52
#, fuzzy
msgid "The `username` variable can be either `Ok(string)` or `Err(error)`."
msgstr "Zmienna `username` mo偶e mie posta `Ok(string)` lub `Err(error)`."

#: src/error-handling/try-operator.md:53
#: src/error-handling/converting-error-types-example.md:53
#, fuzzy
msgid ""
"Use the `fs::write` call to test out the different scenarios: no file, empty "
"file, file with username."
msgstr ""
"U偶yj wywoania `fs::write`, aby przetestowa r贸偶ne scenariusze: brak pliku, "
"pusty plik, plik z nazw u偶ytkownika."

#: src/error-handling/converting-error-types.md:3
#, fuzzy
msgid ""
"The effective expansion of `?` is a little more complicated than previously "
"indicated:"
msgstr ""
"Efektywna interpretacja znaku `?` jest nieco bardziej skomplikowana ni偶 "
"wskazano wczeniej:"

#: src/error-handling/converting-error-types.md:5
msgid ""
"```rust,ignore\n"
"expression?\n"
"```"
msgstr ""
"```rust,ignore\n"
"wyra偶enie?\n"
"```"

#: src/error-handling/converting-error-types.md:9
#, fuzzy
msgid "works the same as"
msgstr "dziaa tak samo jak"

#: src/error-handling/converting-error-types.md:11
msgid ""
"```rust,ignore\n"
"match expression {\n"
"    Ok(value) => value,\n"
"    Err(err)  => return Err(From::from(err)),\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"match wyra偶enie {\n"
"    Ok(value) => value,\n"
"    Err(err)  => return Err(From::from(err)),\n"
"}\n"
"```"

#: src/error-handling/converting-error-types.md:18
#, fuzzy
msgid ""
"The `From::from` call here means we attempt to convert the error type to the "
"type returned by the function:"
msgstr ""
"Wywoanie `From::from` oznacza, 偶e pr贸bujemy przekonwertowa typ bdu na "
"typ zwracany przez funkcj:"

#: src/error-handling/converting-error-types-example.md:3
msgid ""
"```rust,editable\n"
"use std::error::Error;\n"
"use std::fmt::{self, Display, Formatter};\n"
"use std::fs::{self, File};\n"
"use std::io::{self, Read};\n"
"```"
msgstr ""
"```rust,editable\n"
"use std::error::Error;\n"
"use std::fmt::{self, Display, Formatter};\n"
"use std::fs::{self, File};\n"
"use std::io::{self, Read};\n"
"```"

#: src/error-handling/converting-error-types-example.md:9
msgid ""
"\\#\\[derive(Debug)\\] enum ReadUsernameError { IoError(io::Error), "
"EmptyUsername(String), }"
msgstr ""
"\\#\\[derive(Debug)\\] enum ReadUsernameError { IoError(io::Error), "
"EmptyUsername(String), }"

#: src/error-handling/converting-error-types-example.md:15
msgid "impl Error for ReadUsernameError {}"
msgstr "impl Error for ReadUsernameError {}"

#: src/error-handling/converting-error-types-example.md:17
msgid ""
"impl Display for ReadUsernameError { fn fmt(&self, f: &mut Formatter) -> "
"fmt::Result { match self { Self::IoError(e) => write!(f, \"IO error: {}\", "
"e), Self::EmptyUsername(filename) => write!(f, \"Found no username in {}\", "
"filename), } } }"
msgstr ""
"impl Display for ReadUsernameError { fn fmt(&self, f: &mut Formatter) -> "
"fmt::Result { match self { Self::IoError(e) => write!(f, \"Bd wejcia/"
"wyjcia: {}\", e), Self::EmptyUsername(filename) => write!(f, \"Nie "
"znaleziono nazwy u偶ytkownika w {}\", filename), } } }"

#: src/error-handling/converting-error-types-example.md:26
msgid ""
"impl From<io::Error> for ReadUsernameError { fn from(err: io::Error) -> "
"ReadUsernameError { ReadUsernameError::IoError(err) } }"
msgstr ""
"impl From<io::Error> for ReadUsernameError { fn from(err: io::Error) -> "
"ReadUsernameError { ReadUsernameError::IoError(err) } }"

#: src/error-handling/converting-error-types-example.md:32
msgid ""
"fn read_username(path: &str) -> Result\\<String, ReadUsernameError> { let "
"mut username = String::with_capacity(100); File::open(path)?."
"read_to_string(&mut username)?; if username.is_empty() { return "
"Err(ReadUsernameError::EmptyUsername(String::from(path))); } Ok(username) }"
msgstr ""
"fn read_username(path: &str) -> Result\\<String, ReadUsernameError> { let "
"mut username = String::with_capacity(100); File::open(path)?."
"read_to_string(&mut username)?; if username.is_empty() { return "
"Err(ReadUsernameError::EmptyUsername(String::from(path))); } Ok(username) }"

#: src/error-handling/converting-error-types-example.md:41
msgid ""
"fn main() { //fs::write(\"config.dat\", \"\").unwrap(); let username = "
"read_username(\"config.dat\"); println!(\"username or error: "
"{username:?}\"); }"
msgstr ""
"fn main() { //fs::write(\"config.dat\", \"\").unwrap(); let username = "
"read_username(\"config.dat\"); println!(\"nazwa u偶ytkownika lub bd: "
"{username:?}\"); }"

#: src/error-handling/converting-error-types-example.md:55
#, fuzzy
msgid ""
"It is good practice for all error types to implement `std::error::Error`, "
"which requires `Debug` and `Display`. It's generally helpful for them to "
"implement `Clone` and `Eq` too where possible, to make life easier for tests "
"and consumers of your library. In this case we can't easily do so, because "
"`io::Error` doesn't implement them."
msgstr ""
"Dobr praktyk dla wszystkich typ贸w bd贸w jest implementacja `std::error::"
"Error`, kt贸ra wymaga `Debugowania` i `Wywietlanie`. Generalnie pomocne jest "
"dla nich zaimplementowanie `Clone` i `Eq` tam, gdzie to mo偶liwe uatwi 偶ycie "
"testerom i konsumentom Twojej biblioteki. W tym przypadku nie mo偶emy tego "
"atwo zrobi, poniewa偶 `io::Error` nie implementuje ich."

#: src/error-handling/deriving-error-enums.md:3
#, fuzzy
msgid ""
"The [thiserror](https://docs.rs/thiserror/) crate is a popular way to create "
"an error enum like we did on the previous page:"
msgstr ""
"Skrzynka [thiserror](https://docs.rs/thiserror/) to popularny spos贸b "
"tworzenia enum bdu, tak jak zrobilimy to na poprzedniej stronie:"

#: src/error-handling/deriving-error-enums.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use thiserror::Error;\n"
"```"
msgstr ""

#: src/error-handling/deriving-error-enums.md:11
msgid ""
"\\#\\[derive(Debug, Error)\\] enum ReadUsernameError { \\#\\[error(\"Could "
"not read: {0}\")\\] IoError(#\\[from\\] io::Error), \\#\\[error(\"Found no "
"username in {0}\")\\] EmptyUsername(String), }"
msgstr ""
"\\#\\[derive(Debug, Error)\\] enum ReadUsernameError { \\#\\[error(\"Nie "
"mo偶na odczyta: {0}\")\\] IoError(#\\[from\\] io::Error), \\#\\[error(\"Nie "
"znaleziono nazwy u偶ytkownika w {0}\")\\] EmptyUsername(String), }"

#: src/error-handling/deriving-error-enums.md:19
msgid ""
"fn read_username(path: &str) -> Result\\<String, ReadUsernameError> { let "
"mut username = String::with_capacity(100); fs::File::open(path)?."
"read_to_string(&mut username)?; if username.is_empty() { return "
"Err(ReadUsernameError::EmptyUsername(String::from(path))); } Ok(username) }"
msgstr ""

#: src/error-handling/deriving-error-enums.md:28
#: src/error-handling/dynamic-errors.md:25
msgid ""
"fn main() { //fs::write(\"config.dat\", \"\").unwrap(); match "
"read_username(\"config.dat\") { Ok(username) => println!(\"Username: "
"{username}\"), Err(err)     => println!(\"Error: {err}\"), } }"
msgstr ""

#: src/error-handling/deriving-error-enums.md:39
#, fuzzy
msgid ""
"`thiserror`'s derive macro automatically implements `std::error::Error`, and "
"optionally `Display` (if the `#[error(...)]` attributes are provided) and "
"`From` (if the `#[from]` attribute is added). It also works for structs."
msgstr ""
"Makro pochodne `thiserror` automatycznie implementuje `std::error::Error` i "
"opcjonalnie `Display` (jeli podano atrybuty `#[error(...)]`) i `From` "
"(jeli dodano atrybut `#[from]`). Dziaa r贸wnie偶 dla struktur."

#: src/error-handling/deriving-error-enums.md:43
#, fuzzy
msgid "It doesn't affect your public API, which makes it good for libraries."
msgstr ""
"Nie wpywa na tw贸j publiczny interfejs API, co czyni go dobrym dla bibliotek."

#: src/error-handling/dynamic-errors.md:3
#, fuzzy
msgid ""
"Sometimes we want to allow any type of error to be returned without writing "
"our own enum covering all the different possibilities. `std::error::Error` "
"makes this easy."
msgstr ""
"Czasami chcemy zezwoli na zwr贸cenie dowolnego rodzaju bdu bez pisania "
"wasnego pokrycia wyliczeniowego wszystkie r贸偶ne mo偶liwoci. `std::error::"
"Error` uatwia to zadanie."

#: src/error-handling/dynamic-errors.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use std::fs::{self, File};\n"
"use std::io::Read;\n"
"use thiserror::Error;\n"
"use std::error::Error;\n"
"```"
msgstr ""

#: src/error-handling/dynamic-errors.md:12
msgid ""
"\\#\\[derive(Clone, Debug, Eq, Error, PartialEq)\\] \\#\\[error(\"Found no "
"username in {0}\")\\] struct EmptyUsernameError(String);"
msgstr ""

#: src/error-handling/dynamic-errors.md:16
msgid "fn read_username(path: &str) -> Result\\<String, Box"
msgstr ""

#: src/error-handling/dynamic-errors.md:16
msgid ""
"\\> { let mut username = String::with_capacity(100); File::open(path)?."
"read_to_string(&mut username)?; if username.is_empty() { return "
"Err(EmptyUsernameError(String::from(path)).into()); } Ok(username) }"
msgstr ""

#: src/error-handling/dynamic-errors.md:36
#, fuzzy
msgid ""
"This saves on code, but gives up the ability to cleanly handle different "
"error cases differently in the program. As such it's generally not a good "
"idea to use `Box<dyn Error>` in the public API of a library, but it can be a "
"good option in a program where you just want to display the error message "
"somewhere."
msgstr ""
"Oszczdza to kod, ale rezygnuje z mo偶liwoci czystego radzenia sobie z "
"r贸偶nymi przypadkami bd贸w w inny spos贸b program. W zwizku z tym generalnie "
"nie jest dobrym pomysem u偶ywanie `Box<dyn Error>` w publicznym API "
"aplikacji a Library, ale mo偶e to by dobra opcja w programie, w kt贸rym "
"chcesz tylko wywietli komunikat o bdzie gdzie."

#: src/error-handling/error-contexts.md:3
#, fuzzy
msgid ""
"The widely used [anyhow](https://docs.rs/anyhow/) crate can help you add "
"contextual information to your errors and allows you to have fewer custom "
"error types:"
msgstr ""
"Powszechnie u偶ywana [mimo wszystko](https://docs.rs/anyhow/) skrzynka mo偶e "
"pom贸c w dodaniu informacje kontekstowe do twoich bd贸w i pozwala mie ich "
"mniej niestandardowe typy bd贸w:"

#: src/error-handling/error-contexts.md:7
msgid ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use anyhow::{Context, Result, bail};\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use anyhow::{Context, Result, bail};\n"
"```"

#: src/error-handling/error-contexts.md:12
msgid "fn read_username(path: &str) -> Result"
msgstr ""

#: src/error-handling/error-contexts.md:12
msgid ""
" { let mut username = String::with_capacity(100); fs::File::open(path) ."
"context(format!(\"Failed to open {path}\"))? .read_to_string(&mut username) ."
"context(\"Failed to read\")?; if username.is_empty() { bail!(\"Found no "
"username in {path}\"); } Ok(username) }"
msgstr ""

#: src/error-handling/error-contexts.md:24
msgid ""
"fn main() { //fs::write(\"config.dat\", \"\").unwrap(); match "
"read_username(\"config.dat\") { Ok(username) => println!(\"Username: "
"{username}\"), Err(err)     => println!(\"Error: {err:?}\"), } }"
msgstr ""

#: src/error-handling/error-contexts.md:35
#, fuzzy
msgid "`anyhow::Result<V>` is a type alias for `Result<V, anyhow::Error>`."
msgstr "`anyhow::Result<V>` jest aliasem typu dla `Result<V, anyhow::Error>`."

#: src/error-handling/error-contexts.md:36
#, fuzzy
msgid ""
"`anyhow::Error` is essentially a wrapper around `Box<dyn Error>`. As such "
"it's again generally not a good choice for the public API of a library, but "
"is widely used in applications."
msgstr ""
"`w ka偶dym razie::Bd` jest zasadniczo opakowaniem wok贸 `Box<dyn Error>`. "
"Jako taki to znowu generalnie nie dobry wyb贸r dla publicznego interfejsu API "
"biblioteki, ale jest szeroko stosowany w aplikacjach."

#: src/error-handling/error-contexts.md:38
#, fuzzy
msgid ""
"Actual error type inside of it can be extracted for examination if necessary."
msgstr ""
"Rzeczywisty typ bdu w nim mo偶na wyodrbni w celu zbadania, jeli to "
"konieczne."

#: src/error-handling/error-contexts.md:39
#, fuzzy
msgid ""
"Functionality provided by `anyhow::Result<T>` may be familiar to Go "
"developers, as it provides similar usage patterns and ergonomics to `(T, "
"error)` from Go."
msgstr ""
"Funkcjonalno zapewniana przez `anyhow::Result<T>` mo偶e by znana "
"programistom Go, poniewa偶 zapewnia podobne wzorce u偶ytkowania i ergonomia do "
"`(T, error)` z Go."

#: src/testing.md:3
#, fuzzy
msgid "Rust and Cargo come with a simple unit test framework:"
msgstr ""
"Rust i Cargo s dostarczane z prostym frameworkiem do test贸w jednostkowych:"

#: src/testing.md:5
#, fuzzy
msgid "Unit tests are supported throughout your code."
msgstr "Testy jednostkowe s obsugiwane w caym kodzie."

#: src/testing.md:7
#, fuzzy
msgid "Integration tests are supported via the `tests/` directory."
msgstr "Testy integracyjne s obsugiwane przez katalog `tests/`."

#: src/testing/unit-tests.md:3
#, fuzzy
msgid "Mark unit tests with `#[test]`:"
msgstr "Oznacz testy jednostkowe za pomoc `#[test]`:"

#: src/testing/unit-tests.md:5
msgid ""
"```rust,editable\n"
"fn first_word(text: &str) -> &str {\n"
"    match text.find(' ') {\n"
"        Some(idx) => &text[..idx],\n"
"        None => &text,\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/testing/unit-tests.md:13
msgid "\\#\\[test\\] fn test_empty() { assert_eq!(first_word(\"\"), \"\"); }"
msgstr ""

#: src/testing/unit-tests.md:18
msgid ""
"\\#\\[test\\] fn test_single_word() { assert_eq!(first_word(\"Hello\"), "
"\"Hello\"); }"
msgstr ""

#: src/testing/unit-tests.md:23
msgid ""
"\\#\\[test\\] fn test_multiple_words() { assert_eq!(first_word(\"Hello "
"World\"), \"Hello\"); }"
msgstr ""

#: src/testing/unit-tests.md:27
msgid ""
"```\n"
"\n"
"# Unit Tests\n"
"\n"
"Mark unit tests with `#[test]`:\n"
"\n"
"```rust,editable\n"
"fn first_word(text: &str) -> &str {\n"
"    match text.find(' ') {\n"
"        Some(idx) => &text[..idx],\n"
"        None => &text,\n"
"    }\n"
"}\n"
"\n"
"#[test]\n"
"fn test_empty() {\n"
"    assert_eq!(first_word(\"\"), \"\");\n"
"}\n"
"\n"
"#[test]\n"
"fn test_single_word() {\n"
"    assert_eq!(first_word(\"Hello\"), \"Hello\");\n"
"}\n"
"\n"
"Use `cargo test` to find and run the unit tests.\n"
"\n"
"# Unit Tests\n"
"\n"
"Mark unit tests with `#[test]`:\n"
"\n"
"```rust,editable,ignore\n"
"fn first_word(text: &str) -> &str {\n"
"    match text.find(' ') {\n"
"        Some(idx) => &text[..idx],\n"
"        None => &text,\n"
"    }\n"
"}\n"
"\n"
"#[test]\n"
"fn test_empty() {\n"
"    assert_eq!(first_word(\"\"), \"\");\n"
"}\n"
"\n"
"#[test]\n"
"fn test_single_word() {\n"
"    assert_eq!(first_word(\"Hello\"), \"Hello\");\n"
"}\n"
"\n"
"#[test]\n"
"fn test_multiple_words() {\n"
"    assert_eq!(first_word(\"Hello World\"), \"Hello\");\n"
"}\n"
"```"
msgstr ""

#: src/testing/unit-tests.md:29
#, fuzzy
msgid "Use `cargo test` to find and run the unit tests."
msgstr "U偶yj testu adunku, aby znale藕 i uruchomi testy jednostkowe."

#: src/testing/test-modules.md:3
#, fuzzy
msgid ""
"Unit tests are often put in a nested module (run tests on the [Playground]"
"(https://play.rust-lang.org/)):"
msgstr ""
"Testy jednostkowe s czsto umieszczane w zagnie偶d偶onym module (uruchamiaj "
"testy na [Plac zabaw](https://play.rust-lang.org/)):"

#: src/testing/test-modules.md:6
msgid ""
"```rust,editable\n"
"fn helper(a: &str, b: &str) -> String {\n"
"    format!(\"{a} {b}\")\n"
"}\n"
"```"
msgstr ""

#: src/testing/test-modules.md:11
msgid "pub fn main() { println!(\"{}\", helper(\"Hello\", \"World\")); }"
msgstr ""

#: src/testing/test-modules.md:19
msgid ""
"```\n"
"#[test]\n"
"fn test_helper() {\n"
"    assert_eq!(helper(\"foo\", \"bar\"), \"foo bar\");\n"
"}\n"
"```"
msgstr ""

#: src/testing/test-modules.md:26
#, fuzzy
msgid "This lets you unit test private helpers."
msgstr "To pozwala testowa prywatnych pomocnik贸w jednostkowych."

#: src/testing/test-modules.md:27
#, fuzzy
msgid "The `#[cfg(test)]` attribute is only active when you run `cargo test`."
msgstr ""
"Atrybut `#[cfg(test)]` jest aktywny tylko po uruchomieniu `cargo test`."

#: src/testing/doc-tests.md:3
#, fuzzy
msgid "Rust has built-in support for documentation tests:"
msgstr "Rust ma wbudowan obsug test贸w dokumentacji:"

#: src/testing/doc-tests.md:5
msgid ""
"```rust\n"
"/// Shortens a string to the given length.\n"
"///\n"
"/// ```\n"
"/// use playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"
"pub fn shorten_string(s: &str, length: usize) -> &str {\n"
"    &s[..std::cmp::min(length, s.len())]\n"
"}\n"
"```"
msgstr ""

#: src/testing/doc-tests.md:18
#, fuzzy
msgid "Code blocks in `///` comments are automatically seen as Rust code."
msgstr ""
"Bloki kodu w komentarzach `///` s automatycznie postrzegane jako kod Rusta."

#: src/testing/doc-tests.md:19
#, fuzzy
msgid "The code will be compiled and executed as part of `cargo test`."
msgstr "Kod zostanie skompilowany i wykonany w ramach testu adunku."

#: src/testing/doc-tests.md:20
#, fuzzy
msgid ""
"Test the above code on the [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."
msgstr ""
"Przetestuj powy偶szy kod na [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."

#: src/testing/integration-tests.md:3
#, fuzzy
msgid "If you want to test your library as a client, use an integration test."
msgstr ""
"Jeli chcesz przetestowa swoj bibliotek jako klient, u偶yj testu "
"integracji."

#: src/testing/integration-tests.md:5
#, fuzzy
msgid "Create a `.rs` file under `tests/`:"
msgstr "Utw贸rz plik `.rs` w `tests/`:"

#: src/testing/integration-tests.md:7
msgid ""
"```rust,ignore\n"
"use my_library::init;\n"
"```"
msgstr ""

#: src/testing/integration-tests.md:10
msgid "\\#\\[test\\] fn test_init() { assert!(init().is_ok()); }"
msgstr ""

#: src/testing/integration-tests.md:14
msgid ""
"```\n"
"\n"
"# Integration Tests\n"
"\n"
"If you want to test your library as a client, use an integration test.\n"
"\n"
"Create a `.rs` file under `tests/`:\n"
"\n"
"```rust,ignore\n"
"use my_library::init;\n"
"\n"
"These tests only have access to the public API of your crate.\n"
"\n"
"# Integration Tests\n"
"\n"
"If you want to test your library as a client, use an integration test.\n"
"\n"
"Create a `.rs` file under `tests/`:\n"
"\n"
"```rust,ignore\n"
"use my_library::init;\n"
"\n"
"#[test]\n"
"fn test_init() {\n"
"    assert!(init().is_ok());\n"
"}\n"
"```"
msgstr ""

#: src/testing/integration-tests.md:16
#, fuzzy
msgid "These tests only have access to the public API of your crate."
msgstr "Te testy maj dostp tylko do publicznego API Twojej skrzynki."

#: src/unsafe.md:3
#, fuzzy
msgid "The Rust language has two parts:"
msgstr "Jzyk Rust skada si z dw贸ch czci:"

#: src/unsafe.md:5
#, fuzzy
msgid "**Safe Rust:** memory safe, no undefined behavior possible."
msgstr ""
"**Bezpieczna rdza:** bezpieczna pami, niemo偶liwe niezdefiniowane "
"zachowanie."

#: src/unsafe.md:6
#, fuzzy
msgid ""
"**Unsafe Rust:** can trigger undefined behavior if preconditions are "
"violated."
msgstr ""
"**Niebezpieczna rdza:** mo偶e wywoa niezdefiniowane zachowanie, jeli "
"zostan naruszone warunki wstpne."

#: src/unsafe.md:8
#, fuzzy
msgid ""
"We will be seeing mostly safe Rust in this course, but it's important to "
"know what Unsafe Rust is."
msgstr ""
"W tym kursie zobaczymy g贸wnie bezpieczn Rust, ale wa偶ne jest, aby wiedzie "
"czym jest niebezpieczna rdza."

#: src/unsafe.md:11
#, fuzzy
msgid ""
"Unsafe code is usually small and isolated, and its correctness should be "
"carefully documented. It is usually wrapped in a safe abstraction layer."
msgstr ""
"Niebezpieczny kod jest zwykle may i izolowany, a jego poprawno powinna "
"by ostro偶na udokumentowane. Zwykle jest opakowany w bezpieczn warstw "
"abstrakcji."

#: src/unsafe.md:14
#, fuzzy
msgid "Unsafe Rust gives you access to five new capabilities:"
msgstr "Unsafe Rust zapewnia dostp do piciu nowych mo偶liwoci:"

#: src/unsafe.md:16
#, fuzzy
msgid "Dereference raw pointers."
msgstr "Wyuskaj surowe wska藕niki."

#: src/unsafe.md:17
#, fuzzy
msgid "Access or modify mutable static variables."
msgstr "Uzyskaj dostp lub modyfikuj zmienne zmienne statyczne."

#: src/unsafe.md:18
#, fuzzy
msgid "Access `union` fields."
msgstr "Dostp do p贸l unii."

#: src/unsafe.md:19
#, fuzzy
msgid "Call `unsafe` functions, including `extern` functions."
msgstr "Wywoaj funkcje `niebezpieczne`, w tym funkcje `extern`."

#: src/unsafe.md:20
#, fuzzy
msgid "Implement `unsafe` traits."
msgstr "Implementuj niebezpieczne cechy."

#: src/unsafe.md:22
#, fuzzy
msgid ""
"We will briefly cover unsafe capabilities next. For full details, please see "
"[Chapter 19.1 in the Rust Book](https://doc.rust-lang.org/book/ch19-01-"
"unsafe-rust.html) and the [Rustonomicon](https://doc.rust-lang.org/nomicon/)."
msgstr ""
"W dalszej czci kr贸tko om贸wimy niebezpieczne mo偶liwoci. Aby uzyska "
"szczeg贸owe informacje, zobacz [Rozdzia 19.1 w Ksidze Rusta](https://doc."
"rust-lang.org/book/ch19-01-unsafe-rust.html) oraz [Rustonomicon](https://doc."
"rust-lang.org/nomicon/)."

#: src/unsafe.md:28
#, fuzzy
msgid ""
"Unsafe Rust does not mean the code is incorrect. It means that developers "
"have turned off the compiler safety features and have to write correct code "
"by themselves. It means the compiler no longer enforces Rust's memory-safety "
"rules."
msgstr ""
"Niebezpieczny Rust nie oznacza, 偶e kod jest nieprawidowy. Oznacza to, 偶e "
"deweloperzy maj wyczy funkcje bezpieczestwa kompilatora i musia "
"napisa poprawny kod wg sobie. Oznacza to, 偶e kompilator nie egzekwuje ju偶 "
"zasad bezpieczestwa pamici Rusta."

#: src/unsafe/raw-pointers.md:3
#, fuzzy
msgid "Creating pointers is safe, but dereferencing them requires `unsafe`:"
msgstr ""
"Tworzenie wska藕nik贸w jest bezpieczne, ale dereferencja wymaga "
"niebezpiecznego:"

#: src/unsafe/raw-pointers.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut num = 5;\n"
"```"
msgstr ""

#: src/unsafe/raw-pointers.md:9
msgid ""
"```\n"
"let r1 = &mut num as *mut i32;\n"
"let r2 = &num as *const i32;\n"
"```"
msgstr ""

#: src/unsafe/raw-pointers.md:12
msgid ""
"```\n"
"// Safe because r1 and r2 were obtained from references and so are "
"guaranteed to be non-null and\n"
"// properly aligned, the objects underlying the references from which they "
"were obtained are\n"
"// live throughout the whole unsafe block, and they are not accessed either "
"through the\n"
"// references or concurrently through any other pointers.\n"
"unsafe {\n"
"    println!(\"r1 is: {}\", *r1);\n"
"    *r1 = 10;\n"
"    println!(\"r2 is: {}\", *r2);\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/raw-pointers.md:26
#, fuzzy
msgid ""
"It is good practice (and required by the Android Rust style guide) to write "
"a comment for each `unsafe` block explaining how the code inside it "
"satisfies the safety requirements of the unsafe operations it is doing."
msgstr ""
"Dobr praktyk (i wymagan przez przewodnik stylistyczny Android Rust) jest "
"napisanie komentarza dla ka偶dego Blok `niebezpieczny` wyjaniajcy, w jaki "
"spos贸b znajdujcy si w nim kod spenia wymagania bezpieczestwa "
"niebezpiecznego operacje, kt贸re wykonuje."

#: src/unsafe/raw-pointers.md:30
#, fuzzy
msgid ""
"In the case of pointer dereferences, this means that the pointers must be "
"[_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), i.e.:"
msgstr ""
"W przypadku dereferencji wska藕nik贸w oznacza to, 偶e wska藕niki musz by "
"[_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), czyli:"

#: src/unsafe/raw-pointers.md:33
#, fuzzy
msgid "The pointer must be non-null."
msgstr "Wska藕nik musi by inny ni偶 null."

#: src/unsafe/raw-pointers.md:34
#, fuzzy
msgid ""
"The pointer must be _dereferenceable_ (within the bounds of a single "
"allocated object)."
msgstr ""
"Wska藕nik musi by _dereferenceable_ (w granicach pojedynczego przydzielonego "
"obiektu)."

#: src/unsafe/raw-pointers.md:35
#, fuzzy
msgid "The object must not have been deallocated."
msgstr "Obiekt nie mo偶e by cofnity."

#: src/unsafe/raw-pointers.md:36
#, fuzzy
msgid "There must not be concurrent accesses to the same location."
msgstr "Nie mo偶e by jednoczesnych dostp贸w do tej samej lokalizacji."

#: src/unsafe/raw-pointers.md:37
#, fuzzy
msgid ""
"If the pointer was obtained by casting a reference, the underlying object "
"must be live and no reference may be used to access the memory."
msgstr ""
"Jeli wska藕nik zosta uzyskany przez rzutowanie odniesienia, obiekt le偶cy "
"pod spodem musi by 偶ywy i nie odwoanie mo偶e by u偶yte do uzyskania dostpu "
"do pamici."

#: src/unsafe/raw-pointers.md:40
#, fuzzy
msgid "In most cases the pointer must also be properly aligned."
msgstr ""
"W wikszoci przypadk贸w wska藕nik musi by r贸wnie偶 odpowiednio wyr贸wnany."

#: src/unsafe/mutable-static-variables.md:3
#, fuzzy
msgid "It is safe to read an immutable static variable:"
msgstr "Odczyt niezmiennej zmiennej statycznej jest bezpieczny:"

#: src/unsafe/mutable-static-variables.md:5
msgid ""
"```rust,editable\n"
"static HELLO_WORLD: &str = \"Hello, world!\";\n"
"```"
msgstr ""

#: src/unsafe/mutable-static-variables.md:8
msgid "fn main() { println!(\"HELLO_WORLD: {HELLO_WORLD}\"); }"
msgstr ""

#: src/unsafe/mutable-static-variables.md:13
#, fuzzy
msgid ""
"However, since data races can occur, it is unsafe to read and write mutable "
"static variables:"
msgstr ""
"Poniewa偶 jednak mog wystpi wycigi danych, odczytywanie i zapisywanie "
"zmiennych jest niebezpieczne zmienne statyczne:"

#: src/unsafe/mutable-static-variables.md:16
msgid ""
"```rust,editable\n"
"static mut COUNTER: u32 = 0;\n"
"```"
msgstr ""

#: src/unsafe/mutable-static-variables.md:19
msgid ""
"fn add_to_counter(inc: u32) { unsafe { COUNTER += inc; }  // Potential data "
"race! }"
msgstr ""

#: src/unsafe/mutable-static-variables.md:23
msgid "fn main() { add_to_counter(42);"
msgstr ""

#: src/unsafe/mutable-static-variables.md:26
msgid ""
"```\n"
"unsafe { println!(\"COUNTER: {COUNTER}\"); }  // Potential data race!\n"
"```"
msgstr ""

#: src/unsafe/mutable-static-variables.md:32
#, fuzzy
msgid ""
"Using a mutable static is generally a bad idea, but there are some cases "
"where it might make sense in low-level `no_std` code, such as implementing a "
"heap allocator or working with some C APIs."
msgstr ""
"U偶ywanie zmiennej statyki jest generalnie zym pomysem, ale s przypadki, w "
"kt贸rych mo偶e to mie sens w kodzie niskiego poziomu `no_std`, takim jak "
"implementacja alokatora sterty lub praca z niekt贸rymi interfejsami API C."

#: src/unsafe/unions.md:3
#, fuzzy
msgid "Unions are like enums, but you need to track the active field yourself:"
msgstr "Unie s jak wyliczenia, ale musisz samodzielnie ledzi aktywne pole:"

#: src/unsafe/unions.md:5
msgid ""
"```rust,editable\n"
"#[repr(C)]\n"
"union MyUnion {\n"
"    i: u8,\n"
"    b: bool,\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/unions.md:12
msgid ""
"fn main() { let u = MyUnion { i: 42 }; println!(\"int: {}\", unsafe { u."
"i }); println!(\"bool: {}\", unsafe { u.b });  // Undefined behavior! }"
msgstr ""

#: src/unsafe/unions.md:21
#, fuzzy
msgid ""
"Unions are very rarely needed in Rust as you can usually use an enum. They "
"are occasionally needed for interacting with C library APIs."
msgstr ""
"Unie s bardzo rzadko potrzebne w Rust, poniewa偶 zwykle mo偶na u偶y "
"wyliczenia. Czasami s potrzebne do interakcji z interfejsami API biblioteki "
"C."

#: src/unsafe/unions.md:24
#, fuzzy
msgid ""
"If you just want to reinterpret bytes as a different type, you probably want "
"[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn."
"transmute.html) or a safe wrapper such as the [`zerocopy`](https://crates.io/"
"crates/zerocopy) crate."
msgstr ""
"Jeli chcesz po prostu ponownie zinterpretowa bajty jako inny typ, "
"prawdopodobnie chcesz [`std::mem::transmute`](https://doc.rust-lang.org/"
"stable/std/mem/fn.transmute.html) lub sejf opakowanie, takie jak skrzynka "
"[`zerocopy`](https://crates.io/crates/zerocopy)."

#: src/unsafe/calling-unsafe-functions.md:3
#, fuzzy
msgid ""
"A function or method can be marked `unsafe` if it has extra preconditions "
"you must uphold to avoid undefined behaviour:"
msgstr ""
"Funkcja lub metoda mo偶e zosta oznaczona jako niebezpieczna, jeli ma "
"dodatkowe warunki wstpne kt贸rych nale偶y przestrzega, aby unikn "
"niezdefiniowanych zachowa:"

#: src/unsafe/calling-unsafe-functions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let emojis = \"烩\";\n"
"```"
msgstr ""

#: src/unsafe/calling-unsafe-functions.md:10
msgid ""
"```\n"
"// Safe because the indices are in the correct order, within the bounds of\n"
"// the string slice, and lie on UTF-8 sequence boundaries.\n"
"unsafe {\n"
"    println!(\"emoji: {}\", emojis.get_unchecked(0..4));\n"
"    println!(\"emoji: {}\", emojis.get_unchecked(4..7));\n"
"    println!(\"emoji: {}\", emojis.get_unchecked(7..11));\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/calling-unsafe-functions.md:18
msgid ""
"```\n"
"println!(\"char count: {}\", count_chars(unsafe { emojis."
"get_unchecked(0..7) }));\n"
"```"
msgstr ""

#: src/unsafe/calling-unsafe-functions.md:20
msgid ""
"```\n"
"// Not upholding the UTF-8 encoding requirement breaks memory safety!\n"
"// println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
"// println!(\"char count: {}\", count_chars(unsafe { emojis."
"get_unchecked(0..3) }));\n"
"```"
msgstr ""

#: src/unsafe/calling-unsafe-functions.md:25
msgid "fn count_chars(s: &str) -> usize { s.chars().map(|\\_\\| 1).sum() }"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:3
#, fuzzy
msgid ""
"You can mark your own functions as `unsafe` if they require particular "
"conditions to avoid undefined behaviour."
msgstr ""
"Mo偶esz oznaczy wasne funkcje jako niebezpieczne, jeli wymagaj "
"okrelonych warunk贸w, aby unikn niezdefiniowanych zachowanie."

#: src/unsafe/writing-unsafe-functions.md:6
msgid ""
"```rust,editable\n"
"/// Swaps the values pointed to by the given pointers.\n"
"///\n"
"/// # Safety\n"
"///\n"
"/// The pointers must be valid and properly aligned.\n"
"unsafe fn swap(a: *mut u8, b: *mut u8) {\n"
"    let temp = *a;\n"
"    *a = *b;\n"
"    *b = temp;\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:18
msgid "fn main() { let mut a = 42; let mut b = 66;"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:22
msgid ""
"```\n"
"// Safe because ...\n"
"unsafe {\n"
"    swap(&mut a, &mut b);\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:27
msgid ""
"```\n"
"println!(\"a = {}, b = {}\", a, b);\n"
"```"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:33
#, fuzzy
msgid ""
"We wouldn't actually use pointers for this because it can be done safely "
"with references."
msgstr ""
"W rzeczywistoci nie u偶ywalibymy do tego wska藕nik贸w, poniewa偶 mo偶na to "
"zrobi bezpiecznie za pomoc referencji."

#: src/unsafe/writing-unsafe-functions.md:35
#, fuzzy
msgid ""
"Note that unsafe code is allowed within an unsafe function without an "
"`unsafe` block. We can prohibit this with `#[deny(unsafe_op_in_unsafe_fn)]`. "
"Try adding it and see what happens."
msgstr ""
"Nale偶y zauwa偶y, 偶e niebezpieczny kod jest dozwolony w niebezpiecznej "
"funkcji bez bloku `unsafe`. Mo偶emy zabroni tego za pomoc "
"`#[deny(unsafe_op_in_unsafe_fn)]`. Spr贸buj go doda i zobacz, co si stanie."

#: src/unsafe/extern-functions.md:1
#, fuzzy
msgid "Calling External Code"
msgstr "Pr贸bki kodu"

#: src/unsafe/extern-functions.md:3
#, fuzzy
msgid ""
"Functions from other languages might violate the guarantees of Rust. Calling "
"them is thus unsafe:"
msgstr ""
"Funkcje z innych jzyk贸w mog narusza gwarancje Rusta. Powoanie s wic "
"niebezpieczne:"

#: src/unsafe/extern-functions.md:6
msgid ""
"```rust,editable\n"
"extern \"C\" {\n"
"    fn abs(input: i32) -> i32;\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/extern-functions.md:11
msgid ""
"fn main() { unsafe { // Undefined behavior if abs misbehaves. println!"
"(\"Absolute value of -3 according to C: {}\", abs(-3)); } }"
msgstr ""

#: src/unsafe/extern-functions.md:21
#, fuzzy
msgid ""
"This is usually only a problem for extern functions which do things with "
"pointers which might violate Rust's memory model, but in general any C "
"function might have undefined behaviour under any arbitrary circumstances."
msgstr ""
"Zwykle jest to problem tylko w przypadku funkcji extern, kt贸re robi rzeczy "
"ze wska藕nikami, kt贸re mog naruszaj model pamici Rusta, ale og贸lnie ka偶da "
"funkcja C mo偶e mie niezdefiniowane zachowanie pod dowolnym arbitralne "
"okolicznoci."

#: src/unsafe/extern-functions.md:25
msgid ""
"The `\"C\"` in this example is the ABI; [other ABIs are available too]"
"(https://doc.rust-lang.org/reference/items/external-blocks.html)."
msgstr ""

#: src/unsafe/unsafe-traits.md:3
#, fuzzy
msgid ""
"Like with functions, you can mark a trait as `unsafe` if the implementation "
"must guarantee particular conditions to avoid undefined behaviour."
msgstr ""
"Podobnie jak w przypadku funkcji, mo偶esz oznaczy cech jako "
"niebezpieczn, jeli implementacja musi gwarantowa szczeg贸lne warunki, "
"aby unikn nieokrelonego zachowania."

#: src/unsafe/unsafe-traits.md:6
#, fuzzy
msgid ""
"For example, the `zerocopy` crate has an unsafe trait that looks [something "
"like this](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html):"
msgstr ""
"Na przykad skrzynka zerocopy ma niebezpieczn cech, kt贸ra wyglda [co "
"takiego](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html):"

#: src/unsafe/unsafe-traits.md:9
msgid ""
"```rust,editable\n"
"use std::mem::size_of_val;\n"
"use std::slice;\n"
"```"
msgstr ""

#: src/unsafe/unsafe-traits.md:13
#, fuzzy
msgid ""
"/// ... /// # Safety /// The type must have a defined representation and no "
"padding. pub unsafe trait AsBytes { fn as_bytes(&self) -> &\\[u8\\] { unsafe "
"{ slice::from_raw_parts(self as \\*const Self as \\*const u8, "
"size_of_val(self)) } } }"
msgstr ""
"/// ... /// # Bezpieczestwo /// Typ musi mie zdefiniowan reprezentacj i "
"brak dopenienia. niebezpieczna cecha publikacji AsBytes { fn "
"as_bytes(&self) -> &\\[u8\\] { niebezpieczny { slice::from_raw_parts(self "
"jako \\*const Self as \\*const u8, size_of_val(self)) } } }"

#: src/unsafe/unsafe-traits.md:24
msgid ""
"// Safe because u32 has a defined representation and no padding. unsafe impl "
"AsBytes for u32 {}"
msgstr ""

#: src/unsafe/unsafe-traits.md:30
#, fuzzy
msgid ""
"There should be a `# Safety` section on the Rustdoc for the trait explaining "
"the requirements for the trait to be safely implemented."
msgstr ""
"Powinna istnie sekcja `# Safety` w Rustdoc dla cechy wyjaniajcej "
"wymagania dla cecha, kt贸r nale偶y bezpiecznie wdro偶y."

#: src/unsafe/unsafe-traits.md:33
#, fuzzy
msgid ""
"The actual safety section for `AsBytes` is rather longer and more "
"complicated."
msgstr ""
"Waciwa sekcja bezpieczestwa dla `AsBytes` jest raczej du偶sza i bardziej "
"skomplikowana."

#: src/unsafe/unsafe-traits.md:35
#, fuzzy
msgid "The built-in `Send` and `Sync` traits are unsafe."
msgstr "Wbudowane cechy Wylij i Synchronizacja s niebezpieczne."

#: src/exercises/day-3/afternoon.md:1
#, fuzzy
msgid "Day 3: Afternoon Exercises"
msgstr "Dzie 3: wiczenia popoudniowe"

#: src/exercises/day-3/afternoon.md:3
#, fuzzy
msgid "Let us build a safe wrapper for reading directory content!"
msgstr "Zbudujmy bezpieczne opakowanie do odczytu zawartoci katalogu!"

#: src/exercises/day-3/afternoon.md:7
#, fuzzy
msgid ""
"After looking at the exercise, you can look at the [solution](solutions-"
"afternoon.md) provided."
msgstr ""
"Po obejrzeniu wiczenia mo偶esz spojrze na podane [rozwizanie](solutions-"
"afternoon.md)."

#: src/exercises/day-3/safe-ffi-wrapper.md:3
#, fuzzy
msgid ""
"Rust has great support for calling functions through a _foreign function "
"interface_ (FFI). We will use this to build a safe wrapper for the `libc` "
"functions you would use from C to read the filenames of a directory."
msgstr ""
"Rust ma wietne wsparcie dla wywoywania funkcji poprzez funkcj _foreign "
"interfejs_ (FFI). U偶yjemy tego do zbudowania bezpiecznego opakowania dla "
"`libc` funkcje, kt贸rych u偶yby z C do odczytania nazw plik贸w z katalogu."

#: src/exercises/day-3/safe-ffi-wrapper.md:7
#, fuzzy
msgid "You will want to consult the manual pages:"
msgstr "Bdziesz chcia zapozna si ze stronami podrcznika:"

#: src/exercises/day-3/safe-ffi-wrapper.md:9
msgid "[`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)"
msgstr "[`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)"

#: src/exercises/day-3/safe-ffi-wrapper.md:10
msgid "[`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)"
msgstr "[`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)"

#: src/exercises/day-3/safe-ffi-wrapper.md:11
msgid "[`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"
msgstr "[`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"

#: src/exercises/day-3/safe-ffi-wrapper.md:13
#, fuzzy
msgid ""
"You will also want to browse the [`std::ffi`](https://doc.rust-lang.org/std/"
"ffi/) module, particular for [`CStr`](https://doc.rust-lang.org/std/ffi/"
"struct.CStr.html) and [`CString`](https://doc.rust-lang.org/std/ffi/struct."
"CString.html) types which are used to hold NUL-terminated strings coming "
"from C. The [Nomicon](https://doc.rust-lang.org/nomicon/ffi.html) also has a "
"very useful chapter about FFI."
msgstr ""
"Bdziesz tak偶e chcia przejrze modu [`std::ffi`](https://doc.rust-lang.org/"
"std/ffi/), w szczeg贸lnoci dla [`CStr`](https://doc.rust-lang.org/std/ffi/"
"struct.CStr.html) i [`CString`](https://doc.rust-lang.org/std/ffi/struct."
"CString.html), kt贸re s u偶ywane do przechowywania cig贸w znak贸w zakoczonych "
"znakiem NUL pochodzcych z C. [Nomicon](https://doc.rust-lang.org/nomicon/"
"ffi.html) zawiera r贸wnie偶 bardzo przydatny rozdzia o FFI."

#: src/exercises/day-3/safe-ffi-wrapper.md:22
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing "
"functions and methods:"
msgstr ""
"Skopiuj poni偶szy kod na <https://play.rust-lang.org/> i uzupenij brakujce "
"funkcje i metody:"

#: src/exercises/day-3/safe-ffi-wrapper.md:29
msgid "mod ffi { use std::os::raw::{c_char, c_int, c_long, c_ulong, c_ushort};"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:32
#: src/exercises/day-3/solutions-afternoon.md:26
msgid ""
"```\n"
"// Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
"#[repr(C)]\n"
"pub struct DIR {\n"
"    _data: [u8; 0],\n"
"    _marker: core::marker::PhantomData<(*mut u8, core::marker::"
"PhantomPinned)>,\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:39
#: src/exercises/day-3/solutions-afternoon.md:33
msgid ""
"```\n"
"// Layout as per readdir(3) and definitions in /usr/include/x86_64-linux-"
"gnu.\n"
"#[repr(C)]\n"
"pub struct dirent {\n"
"    pub d_ino: c_long,\n"
"    pub d_off: c_ulong,\n"
"    pub d_reclen: c_ushort,\n"
"    pub d_type: c_char,\n"
"    pub d_name: [c_char; 256],\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:49
#: src/exercises/day-3/solutions-afternoon.md:43
msgid ""
"```\n"
"extern \"C\" {\n"
"    pub fn opendir(s: *const c_char) -> *mut DIR;\n"
"    pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"    pub fn closedir(s: *mut DIR) -> c_int;\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:56
#: src/exercises/day-3/solutions-afternoon.md:50
msgid ""
"use std::ffi::{CStr, CString, OsStr, OsString}; use std::os::unix::ffi::"
"OsStrExt;"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:59
msgid ""
"\\#\\[derive(Debug)\\] struct DirectoryIterator { path: CString, dir: \\*mut "
"ffi::DIR, }"
msgstr ""
"\\#\\[derive(Debug)\\] struct DirectoryIterator { path: CString, dir: \\*mut "
"ffi::DIR, }"

#: src/exercises/day-3/safe-ffi-wrapper.md:65
msgid ""
"impl DirectoryIterator { fn new(path: &str) -> Result\\<DirectoryIterator, "
"String> { // Call opendir and return a Ok value if that worked, // otherwise "
"return Err with a message. unimplemented!() } }"
msgstr ""
"impl DirectoryIterator { fn new(path: &str) -> Result\\<DirectoryIterator, "
"String> { // Call opendir and return a Ok value if that worked, // otherwise "
"return Err with a message. unimplemented!() } }"

#: src/exercises/day-3/safe-ffi-wrapper.md:73
msgid ""
"impl Iterator for DirectoryIterator { type Item = OsString; fn next(&mut "
"self) -> Option"
msgstr ""
"impl Iterator for DirectoryIterator { type Item = OsString; fn next(&mut "
"self) -> Option"

#: src/exercises/day-3/safe-ffi-wrapper.md:75
msgid ""
" { // Keep calling readdir until we get a NULL pointer back. unimplemented!"
"() } }"
msgstr ""
" { // Wywouj readdir do uzyskania wska藕nika NULL. unimplemented!() } }"

#: src/exercises/day-3/safe-ffi-wrapper.md:81
msgid ""
"impl Drop for DirectoryIterator { fn drop(&mut self) { // Call closedir as "
"needed. unimplemented!() } }"
msgstr ""
"impl Drop for DirectoryIterator { fn drop(&mut self) { // Wywoaj closedir. "
"unimplemented!() } }"

#: src/exercises/day-3/safe-ffi-wrapper.md:88
msgid ""
"fn main() -> Result\\<(), String> { let iter = DirectoryIterator::new(\"."
"\")?; println!(\"files: {:#?}\", iter.collect::\\<Vec\\<\\_\\>>()); Ok(()) }"
msgstr ""
"fn main() -> Result\\<(), String> { let iter = DirectoryIterator::new(\"."
"\")?; println!(\"pliki: {:#?}\", iter.collect::\\<Vec\\<\\_\\>>()); Ok(()) }"

#: src/welcome-day-4.md:1
msgid "Welcome to Day 4"
msgstr "Witamy w dniu 4"

#: src/welcome-day-4.md:3
#, fuzzy
msgid "Today we will look at two main topics:"
msgstr "Dzisiaj przyjrzymy si dw贸m g贸wnym tematom:"

#: src/welcome-day-4.md:5
#, fuzzy
msgid "Concurrency: threads, channels, shared state, `Send` and `Sync`."
msgstr ""
"Wsp贸bie偶no: wtki, kanay, wsp贸dzielony stan, `Wylij` i "
"`Synchronizacja`."

#: src/welcome-day-4.md:7
#, fuzzy
msgid ""
"Android: building binaries and libraries, using AIDL, logging, and "
"interoperability with C, C++, and Java."
msgstr ""
"Android: tworzenie plik贸w binarnych i bibliotek przy u偶yciu AIDL, logowanie "
"i wsp贸dziaanie z C, C++ i Jav."

#: src/welcome-day-4.md:10
#, fuzzy
msgid ""
"We will attempt to call Rust from one of your own projects today. So try to "
"find a little corner of your code base where we can move some lines of code "
"to Rust. The fewer dependencies and \"exotic\" types the better. Something "
"that parses some raw bytes would be ideal."
msgstr ""
"Spr贸bujemy dzisiaj wywoa Rusta z jednego z twoich wasnych projekt贸w. Wic "
"spr贸buj znajd藕 may zaktek swojej bazy kodu, do kt贸rego mo偶emy przenie "
"kilka linii kodu Rdza. Im mniej zale偶noci i typ贸w egzotycznych, tym "
"lepiej. Co takiego analizuje kilka nieprzetworzonych bajt贸w byoby idealnie."

#: src/concurrency.md:1
#, fuzzy
msgid "Fearless Concurrency"
msgstr "Nieustraszona wsp贸bie偶no"

#: src/concurrency.md:3
#, fuzzy
msgid ""
"Rust has full support for concurrency using OS threads with mutexes and "
"channels."
msgstr ""
"Rust ma pene wsparcie dla wsp贸bie偶noci przy u偶yciu wtk贸w systemu "
"operacyjnego z muteksami i kanay."

#: src/concurrency.md:6
#, fuzzy
msgid ""
"The Rust type system plays an important role in making many concurrency bugs "
"compile time bugs. This is often referred to as _fearless concurrency_ since "
"you can rely on the compiler to ensure correctness at runtime."
msgstr ""
"System typu Rust odgrywa wa偶n rol w tworzeniu wielu bd贸w wsp贸bie偶noci "
"skompilowa bdy czasowe. Od tego czasu jest to czsto okrelane jako "
"_nieustraszona wsp贸bie偶no_ mo偶e polega na kompilatorze, aby zapewni "
"poprawno w czasie wykonywania."

#: src/concurrency/threads.md:3
#, fuzzy
msgid "Rust threads work similarly to threads in other languages:"
msgstr "Wtki Rust dziaaj podobnie do wtk贸w w innych jzykach:"

#: src/concurrency/threads.md:5
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"```"
msgstr ""

#: src/concurrency/threads.md:9
msgid ""
"fn main() { thread::spawn(|| { for i in 1..10 { println!(\"Count in thread: "
"{i}!\"); thread::sleep(Duration::from_millis(5)); } });"
msgstr ""

#: src/concurrency/threads.md:17
msgid ""
"```\n"
"for i in 1..5 {\n"
"    println!(\"Main thread: {i}\");\n"
"    thread::sleep(Duration::from_millis(5));\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/threads.md:24
#, fuzzy
msgid "Threads are all daemon threads, the main thread does not wait for them."
msgstr "Wtki to wszystkie wtki demon贸w, g贸wny wtek na nie nie czeka."

#: src/concurrency/threads.md:25
#, fuzzy
msgid "Thread panics are independent of each other."
msgstr "Paniki wtk贸w s od siebie niezale偶ne."

#: src/concurrency/threads.md:26
#, fuzzy
msgid "Panics can carry a payload, which can be unpacked with `downcast_ref`."
msgstr ""
"Paniki mog przenosi adunek, kt贸ry mo偶na rozpakowa za pomoc "
"`downcast_ref`."

#: src/concurrency/threads.md:32
#, fuzzy
msgid ""
"Notice that the thread is stopped before it reaches 10  the main thread is "
"not waiting."
msgstr ""
"Zauwa偶, 偶e wtek jest zatrzymywany, zanim osignie 10  g贸wny wtek jest "
"nie czeka."

#: src/concurrency/threads.md:35
#, fuzzy
msgid ""
"Use `let handle = thread::spawn(...)` and later `handle.join()` to wait for "
"the thread to finish."
msgstr ""
"U偶yj `let handle = thread::spawn(...)` a p贸藕niej `handle.join()` aby czeka "
"wtek do koca."

#: src/concurrency/threads.md:38
#, fuzzy
msgid "Trigger a panic in the thread, notice how this doesn't affect `main`."
msgstr "Wywoaj panik w wtku, zauwa偶, 偶e nie wpywa to na `main`."

#: src/concurrency/threads.md:40
#, fuzzy
msgid ""
"Use the `Result` return value from `handle.join()` to get access to the "
"panic payload. This is a good time to talk about [`Any`](https://doc.rust-"
"lang.org/std/any/index.html)."
msgstr ""
"U偶yj wartoci zwracanej przez `Result` z `handle.join()`, aby uzyska dostp "
"do paniki adunek. To dobry moment, aby porozmawia o [`Dowolny`](https://"
"doc.rust-lang.org/std/any/index.html)."

#: src/concurrency/scoped-threads.md:3
#, fuzzy
msgid "Normal threads cannot borrow from their environment:"
msgstr "Normalne wtki nie mog po偶ycza ze swojego rodowiska:"

#: src/concurrency/scoped-threads.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use std::thread;\n"
"```"
msgstr ""

#: src/concurrency/scoped-threads.md:8 src/concurrency/scoped-threads.md:22
msgid "fn main() { let s = String::from(\"Hello\");"
msgstr ""

#: src/concurrency/scoped-threads.md:11
msgid ""
"```\n"
"thread::spawn(|| {\n"
"    println!(\"Length: {}\", s.len());\n"
"});\n"
"```"
msgstr ""

#: src/concurrency/scoped-threads.md:17
#, fuzzy
msgid ""
"However, you can use a [scoped thread](https://doc.rust-lang.org/std/thread/"
"fn.scope.html) for this:"
msgstr ""
"W tym celu mo偶esz jednak u偶y \\[wtku z zakresem\\] [1](https://doc.rust-"
"lang.org/std/thread/fn.scope.html):"

#: src/concurrency/scoped-threads.md:19
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"```"
msgstr ""

#: src/concurrency/scoped-threads.md:25
msgid ""
"```\n"
"thread::scope(|scope| {\n"
"    scope.spawn(|| {\n"
"        println!(\"Length: {}\", s.len());\n"
"    });\n"
"});\n"
"```"
msgstr ""

#: src/concurrency/scoped-threads.md:37
#, fuzzy
msgid ""
"The reason for that is that when the `thread::scope` function completes, all "
"the threads are guaranteed to be joined, so they can return borrowed data."
msgstr ""
"Powodem tego jest to, 偶e gdy funkcja `thread::scope` zakoczy dziaanie, "
"wszystkie wtki zostan poczone, wic bd mogy zwr贸ci po偶yczone dane."

#: src/concurrency/scoped-threads.md:38
#, fuzzy
msgid ""
"Normal Rust borrowing rules apply: you can either borrow mutably by one "
"thread, or immutably by any number of threads."
msgstr ""
"Obowizuj normalne zasady po偶yczania Rusta: mo偶esz po偶ycza zmiennie o "
"jeden wtek lub niezmiennie o dowoln liczb wtk贸w."

#: src/concurrency/channels.md:3
#, fuzzy
msgid ""
"Rust channels have two parts: a `Sender<T>` and a `Receiver<T>`. The two "
"parts are connected via the channel, but you only see the end-points."
msgstr ""
"Kanay Rusta maj dwie czci: `Sender<T>` i `Receiver<T>`. Dwie czci s "
"poczone kanaem, ale widzisz tylko punkty kocowe."

#: src/concurrency/channels.md:6
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"```"
msgstr ""

#: src/concurrency/channels.md:10 src/concurrency/channels/unbounded.md:10
msgid "fn main() { let (tx, rx) = mpsc::channel();"
msgstr ""

#: src/concurrency/channels.md:13
msgid ""
"```\n"
"tx.send(10).unwrap();\n"
"tx.send(20).unwrap();\n"
"```"
msgstr ""

#: src/concurrency/channels.md:16
msgid ""
"```\n"
"println!(\"Received: {:?}\", rx.recv());\n"
"println!(\"Received: {:?}\", rx.recv());\n"
"```"
msgstr ""

#: src/concurrency/channels.md:19
msgid ""
"```\n"
"let tx2 = tx.clone();\n"
"tx2.send(30).unwrap();\n"
"println!(\"Received: {:?}\", rx.recv());\n"
"```"
msgstr ""

#: src/concurrency/channels.md:27
#, fuzzy
msgid ""
"`mpsc` stands for Multi-Producer, Single-Consumer. `Sender` and `SyncSender` "
"implement `Clone` (so you can make multiple producers) but `Receiver` does "
"not."
msgstr ""
"`mpsc` oznacza Multi-Producer, Single-Consumer. `Sender` i `SyncSender` "
"implementuj `Clone` (tzw mo偶esz stworzy wielu producent贸w), ale `Receiver` "
"nie."

#: src/concurrency/channels.md:29
#, fuzzy
msgid ""
"`send()` and `recv()` return `Result`. If they return `Err`, it means the "
"counterpart `Sender` or `Receiver` is dropped and the channel is closed."
msgstr ""
"`send()` i `recv()` zwracaj `Result`. Jeli zwracaj `Bd`, oznacza to "
"odpowiednik `Nadawca` lub `Odbiornik` jest odrzucany i kana jest zamykany."

#: src/concurrency/channels/unbounded.md:3
#, fuzzy
msgid "You get an unbounded and asynchronous channel with `mpsc::channel()`:"
msgstr "Otrzymujesz nieograniczony i asynchroniczny kana z `mpsc::channel()`:"

#: src/concurrency/channels/unbounded.md:5
#: src/concurrency/channels/bounded.md:5
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"```"
msgstr ""

#: src/concurrency/channels/unbounded.md:13
#: src/concurrency/channels/bounded.md:13
msgid ""
"```\n"
"thread::spawn(move || {\n"
"    let thread_id = thread::current().id();\n"
"    for i in 1..10 {\n"
"        tx.send(format!(\"Message {i}\")).unwrap();\n"
"        println!(\"{thread_id:?}: sent Message {i}\");\n"
"    }\n"
"    println!(\"{thread_id:?}: done\");\n"
"});\n"
"thread::sleep(Duration::from_millis(100));\n"
"```"
msgstr ""

#: src/concurrency/channels/unbounded.md:23
msgid ""
"```\n"
"for msg in rx.iter() {\n"
"    println!(\"Main: got {}\", msg);\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/channels/bounded.md:3
#, fuzzy
msgid "Bounded and synchronous channels make `send` block the current thread:"
msgstr ""
"Ograniczone i synchroniczne kanay sprawiaj, 偶e `send` blokuje bie偶cy "
"wtek:"

#: src/concurrency/channels/bounded.md:10
msgid "fn main() { let (tx, rx) = mpsc::sync_channel(3);"
msgstr ""

#: src/concurrency/channels/bounded.md:23
msgid ""
"```\n"
"for msg in rx.iter() {\n"
"    println!(\"Main: got {msg}\");\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state.md:3
#, fuzzy
msgid ""
"Rust uses the type system to enforce synchronization of shared data. This is "
"primarily done via two types:"
msgstr ""
"Rust u偶ywa systemu typ贸w do wymuszania synchronizacji wsp贸dzielonych "
"danych. To jest odbywa si g贸wnie za pomoc dw贸ch typ贸w:"

#: src/concurrency/shared_state.md:6
#, fuzzy
msgid ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html), atomic "
"reference counted `T`: handles sharing between threads and takes care to "
"deallocate `T` when the last reference is dropped,"
msgstr ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html), referencja "
"atomowa liczona `T`: obsuguje udostpnianie midzy wtkami i dba o "
"zwolnienie `T`, gdy ostatnie odwoanie zostanie usunite,"

#: src/concurrency/shared_state.md:8
#, fuzzy
msgid ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html): ensures "
"mutually exclusive access to the `T` value."
msgstr ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html): zapewnia "
"wzajemnie wykluczajcy si dostp do wartoci `T`."

#: src/concurrency/shared_state/arc.md:1
#, fuzzy
msgid "`Arc`"
msgstr "`uk`"

#: src/concurrency/shared_state/arc.md:3
#, fuzzy
msgid ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html) allows shared "
"read-only access via its `clone` method:"
msgstr ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html) umo偶liwia "
"wsp贸dzielony dostp tylko do odczytu poprzez swoj metod `clone`:"

#: src/concurrency/shared_state/arc.md:5
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"use std::sync::Arc;\n"
"```"
msgstr ""

#: src/concurrency/shared_state/arc.md:9
msgid ""
"fn main() { let v = Arc::new(vec![10, 20, 30\\]); let mut handles = Vec::"
"new(); for _ in 1..5 { let v = v.clone(); handles.push(thread::spawn(move || "
"{ let thread_id = thread::current().id(); println!(\"{thread_id:?}: "
"{v:?}\"); })); }"
msgstr ""

#: src/concurrency/shared_state/arc.md:20
msgid ""
"```\n"
"handles.into_iter().for_each(|h| h.join().unwrap());\n"
"println!(\"v: {v:?}\");\n"
"```"
msgstr ""

#: src/concurrency/shared_state/arc.md:29
#, fuzzy
msgid ""
"`Arc` stands for \"Atomic Reference Counted\", a thread safe version of `Rc` "
"that uses atomic operations."
msgstr ""
"`Arc` oznacza \"Atomic Reference Counted\", bezpieczn dla wtk贸w wersj "
"`Rc`, kt贸ra wykorzystuje operacje."

#: src/concurrency/shared_state/arc.md:31
#, fuzzy
msgid ""
"`Arc<T>` implements `Clone` whether or not `T` does. It implements `Send` "
"and `Sync` iff `T` implements them both."
msgstr ""
"`Arc<T>` implementuje `Clone` niezale偶nie od tego, czy `T` to robi. "
"Implementuje `Wylij` i `Sync` iff `T` realizuje je obie."

#: src/concurrency/shared_state/arc.md:33
#, fuzzy
msgid ""
"`Arc::clone()` has the cost of atomic operations that get executed, but "
"after that the use of the `T` is free."
msgstr ""
"`Arc::clone()` ma koszt wykonania operacji atomowych, ale p贸藕niej u偶ycie `T` "
"jest darmowe."

#: src/concurrency/shared_state/arc.md:35
#, fuzzy
msgid ""
"Beware of reference cycles, `Arc` does not use a garbage collector to detect "
"them."
msgstr ""
"Uwa偶aj na cykle referencyjne, `Arc` nie u偶ywa moduu wyrzucania element贸w "
"bezu偶ytecznych do ich wykrywania."

#: src/concurrency/shared_state/arc.md:36
#, fuzzy
msgid "`std::sync::Weak` can help."
msgstr "`std::sync::Weak` mo偶e pom贸c."

#: src/concurrency/shared_state/mutex.md:1
#, fuzzy
msgid "`Mutex`"
msgstr "`Mutex`"

#: src/concurrency/shared_state/mutex.md:3
#, fuzzy
msgid ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html) ensures "
"mutual exclusion _and_ allows mutable access to `T` behind a read-only "
"interface:"
msgstr ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html) zapewnia "
"wzajemne wykluczanie _i_ umo偶liwia zmienny dostp do `T` za interfejsem "
"tylko do odczytu:"

#: src/concurrency/shared_state/mutex.md:6
msgid ""
"```rust,editable\n"
"use std::sync::Mutex;\n"
"```"
msgstr ""

#: src/concurrency/shared_state/mutex.md:9
msgid ""
"fn main() { let v = Mutex::new(vec![10, 20, 30\\]); println!(\"v: {:?}\", v."
"lock().unwrap());"
msgstr ""

#: src/concurrency/shared_state/mutex.md:13
msgid ""
"```\n"
"{\n"
"    let mut guard = v.lock().unwrap();\n"
"    guard.push(40);\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/mutex.md:18
msgid ""
"```\n"
"println!(\"v: {:?}\", v.lock().unwrap());\n"
"```"
msgstr ""

#: src/concurrency/shared_state/mutex.md:22
#, fuzzy
msgid ""
"Notice how we have a [`impl<T: Send> Sync for Mutex<T>`](https://doc.rust-"
"lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E) blanket "
"implementation."
msgstr ""
"Zauwa偶, 偶e mamy koc [`impl<T:Send> Sync for Mutex<T>`](https://doc.rust-lang."
"org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E). realizacja."

#: src/concurrency/shared_state/mutex.md:31
#, fuzzy
msgid ""
"`Mutex` in Rust looks like a collection with just one element - the "
"protected data."
msgstr ""
"`Mutex` w Rust wyglda jak kolekcja z tylko jednym elementem - chronionymi "
"danymi."

#: src/concurrency/shared_state/mutex.md:32
#, fuzzy
msgid ""
"It is not possible to forget to acquire the mutex before accessing the "
"protected data."
msgstr ""
"Nie mo偶na zapomnie o zdobyciu muteksu przed uzyskaniem dostpu do "
"chronionych danych."

#: src/concurrency/shared_state/mutex.md:33
#, fuzzy
msgid ""
"You can get an `&mut T` from an `&Mutex<T>` by taking the lock. The "
"`MutexGuard` ensures that the `&mut T` doesn't outlive the lock being held."
msgstr ""
"Mo偶esz uzyska `&mut T` z `&Mutex<T>`, biorc blokad. `MutexGuard` "
"zapewnia, 偶e `&mut T` nie przetrwa utrzymywanej blokady."

#: src/concurrency/shared_state/mutex.md:35
#, fuzzy
msgid "`Mutex<T>` implements both `Send` and `Sync` iff `T` implements `Send`."
msgstr ""
"`Mutex<T>` implementuje zar贸wno `Send`, jak i `Sync`, jeli `T` implementuje "
"`Send`."

#: src/concurrency/shared_state/mutex.md:36
#, fuzzy
msgid "A read-write lock counterpart - `RwLock`."
msgstr "Odpowiednik blokady odczytu i zapisu - `RwLock`."

#: src/concurrency/shared_state/mutex.md:37
#, fuzzy
msgid "Why does `lock()` return a `Result`? "
msgstr "Dlaczego `lock()` zwraca `Result`?"

#: src/concurrency/shared_state/mutex.md:38
#, fuzzy
msgid ""
"If the thread that held the `Mutex` panicked, the `Mutex` becomes "
"\"poisoned\" to signal that the data it protected might be in an "
"inconsistent state. Calling `lock()` on a poisoned mutex fails with a "
"[`PoisonError`](https://doc.rust-lang.org/std/sync/struct.PoisonError.html). "
"You can call `into_inner()` on the error to recover the data regardless."
msgstr ""
"Jeli wtek, kt贸ry zawiera `Mutex` wpad w panik, `Mutex` zostaje "
"zatruty, aby zasygnalizowa, 偶e chronione dane mog by w niesp贸jnym "
"stanie. Wywoanie `lock()` na zatrutym muteksie koczy si niepowodzeniem z "
"bdem [`PoisonError`](https://doc.rust-lang.org/std/sync/struct.PoisonError."
"html). Mo偶esz wywoa `into_inner()` w przypadku bdu, aby odzyska dane "
"mimo wszystko."

#: src/concurrency/shared_state/example.md:3
#, fuzzy
msgid "Let us see `Arc` and `Mutex` in action:"
msgstr "Zobaczmy `Arc` i `Mutex` w akcji:"

#: src/concurrency/shared_state/example.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use std::thread;\n"
"// use std::sync::{Arc, Mutex};\n"
"```"
msgstr ""

#: src/concurrency/shared_state/example.md:9
msgid ""
"fn main() { let mut v = vec![10, 20, 30\\]; let handle = thread::spawn(|| "
"{ v.push(10); }); v.push(1000);"
msgstr ""

#: src/concurrency/shared_state/example.md:16
msgid ""
"```\n"
"handle.join().unwrap();\n"
"println!(\"v: {v:?}\");\n"
"```"
msgstr ""

#: src/concurrency/shared_state/example.md:23
msgid "Possible solution:"
msgstr ""

#: src/concurrency/shared_state/example.md:25
msgid ""
"```rust,editable\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;\n"
"```"
msgstr ""

#: src/concurrency/shared_state/example.md:29
msgid "fn main() { let v = Arc::new(Mutex::new(vec![10, 20, 30\\]));"
msgstr ""

#: src/concurrency/shared_state/example.md:32
msgid ""
"```\n"
"let v2 = v.clone();\n"
"let handle = thread::spawn(move || {\n"
"    let mut v2 = v2.lock().unwrap();\n"
"    v2.push(10);\n"
"});\n"
"```"
msgstr ""

#: src/concurrency/shared_state/example.md:38
msgid ""
"```\n"
"{\n"
"    let mut v = v.lock().unwrap();\n"
"    v.push(1000);\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/example.md:43
msgid ""
"```\n"
"handle.join().unwrap();\n"
"```"
msgstr ""

#: src/concurrency/shared_state/example.md:45
msgid ""
"```\n"
"{\n"
"    let v = v.lock().unwrap();\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/example.md:50
msgid ""
"```\n"
"    \n"
"Notable parts:\n"
"```"
msgstr ""

#: src/concurrency/shared_state/example.md:54
#, fuzzy
msgid ""
"`v` is wrapped in both `Arc` and `Mutex`, because their concerns are "
"orthogonal."
msgstr ""
"`v` jest opakowane zar贸wno w `Arc`, jak i `Mutex`, poniewa偶 ich "
"zainteresowania s ortogonalne."

#: src/concurrency/shared_state/example.md:55
#, fuzzy
msgid ""
"Wrapping a `Mutex` in an `Arc` is a common pattern to share mutable state "
"between threads."
msgstr ""
"Zawijanie `Mutex` w `Arc` to powszechny wzorzec udostpniania zmiennego "
"stanu midzy wtkami."

#: src/concurrency/shared_state/example.md:56
#, fuzzy
msgid ""
"`v: Arc<_>` needs to be cloned as `v2` before it can be moved into another "
"thread. Note `move` was added to the lambda signature."
msgstr ""
"`v: Arc<_>` musi zosta sklonowany jako `v2` zanim bdzie mo偶na go przenie "
"do innego wtku. Uwaga: do sygnatury lambda dodano sowo move."

#: src/concurrency/shared_state/example.md:57
#, fuzzy
msgid ""
"Blocks are introduced to narrow the scope of the `LockGuard` as much as "
"possible."
msgstr ""
"Blokady s wprowadzane w celu maksymalnego zaw偶enia zakresu `LockGuard`."

#: src/concurrency/shared_state/example.md:58
#, fuzzy
msgid "We still need to acquire the `Mutex` to print our `Vec`."
msgstr "Nadal musimy zdoby `Mutex`, aby wydrukowa nasz `Vec`."

#: src/concurrency/send-sync.md:1
#, fuzzy
msgid "`Send` and `Sync`"
msgstr "`Wylij` i `Synchronizacja`"

#: src/concurrency/send-sync.md:3
#, fuzzy
msgid ""
"How does Rust know to forbid shared access across thread? The answer is in "
"two traits:"
msgstr ""
"Skd Rust wie, jak zabroni wsp贸dzielonego dostpu midzy wtkami? "
"Odpowied藕 tkwi w dw贸ch cechach:"

#: src/concurrency/send-sync.md:5
#, fuzzy
msgid ""
"[`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html): a type `T` "
"is `Send` if it is safe to move a `T` across a thread boundary."
msgstr ""
"[`Wylij`](https://doc.rust-lang.org/std/marker/trait.Send.html): typ `T` to "
"`Wylij`, jeli bezpieczne jest przeniesienie `T` w wtku granica."

#: src/concurrency/send-sync.md:7
#, fuzzy
msgid ""
"[`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html): a type `T` "
"is `Sync` if it is safe to move a `&T` across a thread boundary."
msgstr ""
"[`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html): typ `T` to "
"`Sync`, jeli bezpieczne jest przeniesienie `&T` w wtku granica."

#: src/concurrency/send-sync.md:10
#, fuzzy
msgid ""
"`Send` and `Sync` are [unsafe traits](../unsafe/unsafe-traits.md). The "
"compiler will automatically derive them for your types as long as they only "
"contain `Send` and `Sync` types. You can also implement them manually when "
"you know it is valid."
msgstr ""
"`Wylij` i `Synchronizacja` to [niebezpieczne cechy](../unsafe/unsafe-traits."
"md). Kompilator automatycznie wyprowadzi je dla twoich typ贸w o ile zawieraj "
"tylko typy `Send` i `Sync`. Mo偶esz tak偶e zaimplementowa je rcznie, gdy ty "
"wiedzie, 偶e jest wa偶ny."

#: src/concurrency/send-sync.md:20
#, fuzzy
msgid ""
"One can think of these traits as markers that the type has certain thread-"
"safety properties."
msgstr ""
"Mo偶na myle o tych cechach jako o znacznikach, 偶e typ ma pewne waciwoci "
"bezpieczestwa wtk贸w."

#: src/concurrency/send-sync.md:21
#, fuzzy
msgid "They can be used in the generic constraints as normal traits."
msgstr "Mog by u偶ywane w og贸lnych ograniczeniach jako normalne cechy."

#: src/concurrency/send-sync/send.md:1
#, fuzzy
msgid "`Send`"
msgstr "`Wylij`"

#: src/concurrency/send-sync/send.md:3
#, fuzzy
msgid ""
"A type `T` is [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html) "
"if it is safe to move a `T` value to another thread."
msgstr ""
"Typ `T` to [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html), "
"jeli przeniesienie wartoci `T` do innego wtku jest bezpieczne."

#: src/concurrency/send-sync/send.md:5
#, fuzzy
msgid ""
"The effect of moving ownership to another thread is that _destructors_ will "
"run in that thread. So the question is when you can allocate a value in one "
"thread and deallocate it in another."
msgstr ""
"Efektem przeniesienia wasnoci do innego wtku jest uruchomienie "
"_destruktor贸w_ w tym wtku. Pytanie brzmi, kiedy mo偶na przydzieli warto w "
"jednym wtku i zwolnij go w innym."

#: src/concurrency/send-sync/sync.md:1
#, fuzzy
msgid "`Sync`"
msgstr "`Synchronizacja`"

#: src/concurrency/send-sync/sync.md:3
#, fuzzy
msgid ""
"A type `T` is [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) "
"if it is safe to access a `T` value from multiple threads at the same time."
msgstr ""
"Typ `T` to [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html), "
"jeli dostp do wartoci `T` z wielu wtk贸w jednoczenie."

#: src/concurrency/send-sync/sync.md:6
#, fuzzy
msgid "More precisely, the definition is:"
msgstr "Dokadniej, definicja brzmi:"

#: src/concurrency/send-sync/sync.md:8
#, fuzzy
msgid "`T` is `Sync` if and only if `&T` is `Send`"
msgstr "`T` to `Sync` wtedy i tylko wtedy, gdy `&T` to `Wylij`"

#: src/concurrency/send-sync/sync.md:14
#, fuzzy
msgid ""
"This statement is essentially a shorthand way of saying that if a type is "
"thread-safe for shared use, it is also thread-safe to pass references of it "
"across threads."
msgstr ""
"To stwierdzenie jest zasadniczo skr贸towym sposobem stwierdzenia, 偶e jeli "
"typ jest bezpieczny dla wtk贸w do wsp贸lnego u偶ytku, bezpieczne jest r贸wnie偶 "
"przekazywanie odwoa do niego midzy wtkami."

#: src/concurrency/send-sync/sync.md:16
#, fuzzy
msgid ""
"This is because if a type is Sync it means that it can be shared across "
"multiple threads without the risk of data races or other synchronization "
"issues, so it is safe to move it to another thread. A reference to the type "
"is also safe to move to another thread, because the data it references can "
"be accessed from any thread safely."
msgstr ""
"Dzieje si tak, poniewa偶 jeli typem jest synchronizacja, oznacza to, 偶e "
"mo偶na go udostpnia w wielu wtkach bez ryzyka wycigu danych lub innych "
"problem贸w z synchronizacj, wic przeniesienie go do innego wtku jest "
"bezpieczne. Odwoanie do typu mo偶na r贸wnie偶 bezpiecznie przenie do innego "
"wtku, poniewa偶 do danych, do kt贸rych si odwouje, mo偶na bezpiecznie "
"uzyska dostp z dowolnego wtku."

#: src/concurrency/send-sync/examples.md:3
#, fuzzy
msgid "`Send + Sync`"
msgstr "`Wylij + synchronizuj`"

#: src/concurrency/send-sync/examples.md:5
#, fuzzy
msgid "Most types you come across are `Send + Sync`:"
msgstr "Wikszo spotykanych typ贸w to `Wylij + synchronizuj`:"

#: src/concurrency/send-sync/examples.md:7
msgid "`i8`, `f32`, `bool`, `char`, `&str`, ..."
msgstr ""

#: src/concurrency/send-sync/examples.md:8
msgid "`(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ..."
msgstr ""

#: src/concurrency/send-sync/examples.md:9
msgid "`String`, `Option<T>`, `Vec<T>`, `Box<T>`, ..."
msgstr ""

#: src/concurrency/send-sync/examples.md:10
msgid "`Arc<T>`: Explicitly thread-safe via atomic reference count."
msgstr ""

#: src/concurrency/send-sync/examples.md:11
msgid "`Mutex<T>`: Explicitly thread-safe via internal locking."
msgstr ""

#: src/concurrency/send-sync/examples.md:12
msgid "`AtomicBool`, `AtomicU8`, ...: Uses special atomic instructions."
msgstr ""

#: src/concurrency/send-sync/examples.md:14
#, fuzzy
msgid ""
"The generic types are typically `Send + Sync` when the type parameters are "
"`Send + Sync`."
msgstr ""
"Typy og贸lne to zazwyczaj `Wylij + synchronizacja`, gdy s to parametry typu "
"`Wylij + synchronizuj`."

#: src/concurrency/send-sync/examples.md:17
#, fuzzy
msgid "`Send + !Sync`"
msgstr "`Wylij +!Synchronizacja`"

#: src/concurrency/send-sync/examples.md:19
#, fuzzy
msgid ""
"These types can be moved to other threads, but they're not thread-safe. "
"Typically because of interior mutability:"
msgstr ""
"Te typy mo偶na przenosi do innych wtk贸w, ale nie s one bezpieczne dla "
"wtk贸w. Zazwyczaj z powodu wewntrznej zmiennoci:"

#: src/concurrency/send-sync/examples.md:22
#, fuzzy
msgid "`mpsc::Sender<T>`"
msgstr "`mpsc::Nadawca<T>`"

#: src/concurrency/send-sync/examples.md:23
#, fuzzy
msgid "`mpsc::Receiver<T>`"
msgstr "`mpsc::Odbiornik<T>`"

#: src/concurrency/send-sync/examples.md:24
#, fuzzy
msgid "`Cell<T>`"
msgstr "`Kom贸rka<T>`"

#: src/concurrency/send-sync/examples.md:25
#, fuzzy
msgid "`RefCell<T>`"
msgstr "`RefKom贸rka<T>`"

#: src/concurrency/send-sync/examples.md:27
#, fuzzy
msgid "`!Send + Sync`"
msgstr "`!Wylij + synchronizuj`"

#: src/concurrency/send-sync/examples.md:29
#, fuzzy
msgid ""
"These types are thread-safe, but they cannot be moved to another thread:"
msgstr ""
"Te typy s bezpieczne dla wtk贸w, ale nie mo偶na ich przenie do innego "
"wtku:"

#: src/concurrency/send-sync/examples.md:31
#, fuzzy
msgid ""
"`MutexGuard<T>`: Uses OS level primitives which must be deallocated on the "
"thread which created them."
msgstr ""
"`MutexGuard<T>`: U偶ywa prymityw贸w na poziomie systemu operacyjnego, kt贸re "
"musz zosta zwolnione na wtek, kt贸ry je stworzy."

#: src/concurrency/send-sync/examples.md:34
#, fuzzy
msgid "`!Send + !Sync`"
msgstr "`!Wylij + !Sync`"

#: src/concurrency/send-sync/examples.md:36
#, fuzzy
msgid "These types are not thread-safe and cannot be moved to other threads:"
msgstr ""
"Te typy nie s bezpieczne dla wtk贸w i nie mo偶na ich przenosi do innych "
"wtk贸w:"

#: src/concurrency/send-sync/examples.md:38
#, fuzzy
msgid ""
"`Rc<T>`: each `Rc<T>` has a reference to an `RcBox<T>`, which contains a non-"
"atomic reference count."
msgstr ""
"`Rc<T>`: ka偶dy `Rc<T>` ma odniesienie do `RcBox<T>`, kt贸ry zawiera "
"nieatomowa liczba referencji."

#: src/concurrency/send-sync/examples.md:40
#, fuzzy
msgid ""
"`*const T`, `*mut T`: Rust assumes raw pointers may have special concurrency "
"considerations."
msgstr ""
"`*const T`, `*mut T`: Rust zakada, 偶e surowe wska藕niki mog mie specjalne "
"wzgldy wsp贸bie偶noci."

#: src/exercises/day-4/morning.md:3
#, fuzzy
msgid "Let us practice our new concurrency skills with"
msgstr "Przewiczmy nasze nowe umiejtnoci wsp贸bie偶noci z"

#: src/exercises/day-4/morning.md:5
#, fuzzy
msgid "Dining philosophers: a classic problem in concurrency."
msgstr "Filozofowie jadalni: klasyczny problem wsp贸bie偶noci."

#: src/exercises/day-4/morning.md:7
#, fuzzy
msgid ""
"Multi-threaded link checker: a larger project where you'll use Cargo to "
"download dependencies and then check links in parallel."
msgstr ""
"Wielowtkowe narzdzie do sprawdzania link贸w: wikszy projekt, do kt贸rego "
"u偶yjesz Cargo pobierz zale偶noci, a nastpnie sprawd藕 linki r贸wnolegle."

#: src/exercises/day-4/dining-philosophers.md:3
#, fuzzy
msgid "The dining philosophers problem is a classic problem in concurrency:"
msgstr "Problem filozof贸w jadalni jest klasycznym problemem wsp贸bie偶noci:"

#: src/exercises/day-4/dining-philosophers.md:5
#, fuzzy
msgid ""
"Five philosophers dine together at the same table. Each philosopher has "
"their own place at the table. There is a fork between each plate. The dish "
"served is a kind of spaghetti which has to be eaten with two forks. Each "
"philosopher can only alternately think and eat. Moreover, a philosopher can "
"only eat their spaghetti when they have both a left and right fork. Thus two "
"forks will only be available when their two nearest neighbors are thinking, "
"not eating. After an individual philosopher finishes eating, they will put "
"down both forks."
msgstr ""
"Piciu filozof贸w je razem przy jednym stole. Ka偶dy filozof ma swoje wasne "
"miejsce przy stole. Pomidzy ka偶dym talerzem znajduje si widelec. Serwowane "
"danie to rodzaj spaghetti, kt贸re trzeba je dwoma widelcami. Ka偶dy filozof "
"mo偶e tylko na przemian myle i je. Co wicej, filozof mo偶e je tylko ich "
"spaghetti, gdy maj lewy i prawy widelec. Tak wic tylko dwa widelce by "
"dostpnym, gdy dwaj najbli偶si ssiedzi myl, a nie jedz. Po pojedynczy "
"filozof skoczy je, odo偶y oba widelce."

#: src/exercises/day-4/dining-philosophers.md:13
#, fuzzy
msgid ""
"You will need a local [Cargo installation](../../cargo/running-locally.md) "
"for this exercise. Copy the code below to `src/main.rs` file, fill out the "
"blanks, and test that `cargo run` does not deadlock:"
msgstr ""
"Bdziesz potrzebowa lokalnej [instalacji Cargo](../../cargo/running-locally."
"md) dla to wiczenie. Skopiuj poni偶szy kod do pliku `src/main.rs`, wypenij "
"puste pola, i sprawd藕, czy `cargo run` nie powoduje impasu:"

#: src/exercises/day-4/dining-philosophers.md:17
msgid ""
"```rust,compile_fail\n"
"use std::sync::mpsc;\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"```"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:23
#: src/exercises/day-4/solutions-morning.md:28
msgid "struct Fork;"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:25
#, fuzzy
msgid ""
"struct Philosopher { name: String, // left_fork: ... // right_fork: ... // "
"thoughts: ... }"
msgstr ""
"struktura Filozof { imi: Cig, // lewy_fork: ... // widelec_w prawo: ... // "
"myli: ... }"

#: src/exercises/day-4/dining-philosophers.md:32
msgid ""
"impl Philosopher { fn think(&self) { self.thoughts .send(format!(\"Eureka! "
"{} has a new idea!\", &self.name)) .unwrap(); }"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:39
msgid ""
"```\n"
"fn eat(&self) {\n"
"    // Pick up forks...\n"
"    println!(\"{} is eating...\", &self.name);\n"
"    thread::sleep(Duration::from_millis(10));\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:46
#: src/exercises/day-4/solutions-morning.md:60
msgid ""
"static PHILOSOPHERS: &\\[&str\\] = &\\[\"Socrates\", \"Plato\", "
"\"Aristotle\", \"Thales\", \"Pythagoras\"\\];"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:49
#, fuzzy
msgid "fn main() { // Create forks"
msgstr "fn main() { // Utw贸rz rozwidlenia"

#: src/exercises/day-4/dining-philosophers.md:52
#, fuzzy
msgid ""
"```\n"
"// Create philosophers\n"
"```"
msgstr ""
"```\n"
"// Tw贸rz filozof贸w\n"
"```"

#: src/exercises/day-4/dining-philosophers.md:54
#, fuzzy
msgid ""
"```\n"
"// Make them think and eat\n"
"```"
msgstr ""
"```\n"
"// Niech myl i jedz\n"
"```"

#: src/exercises/day-4/dining-philosophers.md:56
msgid ""
"```\n"
"// Output their thoughts\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:3
#, fuzzy
msgid ""
"Let us use our new knowledge to create a multi-threaded link checker. It "
"should start at a webpage and check that links on the page are valid. It "
"should recursively check other pages on the same domain and keep doing this "
"until all pages have been validated."
msgstr ""
"Wykorzystajmy nasz now wiedz do stworzenia wielowtkowego narzdzia do "
"sprawdzania link贸w. Powinno zacznij od strony internetowej i sprawd藕, czy "
"linki na stronie s prawidowe. Powinno rekurencyjnie sprawdzaj inne strony "
"w tej samej domenie i r贸b to, a偶 wszystkie strony zostay zweryfikowane."

#: src/exercises/day-4/link-checker.md:8
#, fuzzy
msgid ""
"For this, you will need an HTTP client such as [`reqwest`](https://docs.rs/"
"reqwest/). Create a new Cargo project and `reqwest` it as a dependency with:"
msgstr ""
"Do tego potrzebny bdzie klient HTTP, taki jak [`reqwest`](https://docs.rs/"
"reqwest/). Stw贸rz nowy Projekt Cargo i `reqwest` jako zale偶no z:"

#: src/exercises/day-4/link-checker.md:11
msgid ""
"```shell\n"
"$ cargo new link-checker\n"
"$ cd link-checker\n"
"$ cargo add --features blocking,rustls-tls reqwest\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:17
#, fuzzy
msgid ""
"If `cargo add` fails with `error: no such subcommand`, then please edit the "
"`Cargo.toml` file by hand. Add the dependencies listed below."
msgstr ""
"Jeli polecenie `cargo add` nie powiedzie si z komunikatem `error: no such "
"subcommand`, edytuj Plik `Cargo.toml` rcznie. Dodaj zale偶noci wymienione "
"poni偶ej."

#: src/exercises/day-4/link-checker.md:20
#, fuzzy
msgid ""
"You will also need a way to find links. We can use [`scraper`](https://docs."
"rs/scraper/) for that:"
msgstr ""
"Bdziesz tak偶e potrzebowa sposobu na znalezienie link贸w. Mo偶emy do tego "
"u偶y [`scraper`](https://docs.rs/scraper/):"

#: src/exercises/day-4/link-checker.md:22
msgid ""
"```shell\n"
"$ cargo add scraper\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:26
#, fuzzy
msgid ""
"Finally, we'll need some way of handling errors. We use [`thiserror`]"
"(https://docs.rs/thiserror/) for that:"
msgstr ""
"Na koniec bdziemy potrzebowa jakiego sposobu obsugi bd贸w. U偶ywamy "
"[`thiserror`](https://docs.rs/thiserror/) dla To:"

#: src/exercises/day-4/link-checker.md:29
msgid ""
"```shell\n"
"$ cargo add thiserror\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:33
#, fuzzy
msgid ""
"The `cargo add` calls will update the `Cargo.toml` file to look like this:"
msgstr ""
"Wywoania `cargo add` zaktualizuj plik `Cargo.toml` tak, aby wyglda "
"nastpujco:"

#: src/exercises/day-4/link-checker.md:35
msgid ""
"```toml\n"
"[dependencies]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-"
"tls\"] }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:42
#, fuzzy
msgid ""
"You can now download the start page. Try with a small site such as `https://"
"www.google.org/`."
msgstr ""
"Mo偶esz teraz pobra stron startow. Spr贸buj z ma witryn, tak jak "
"`https://www.google.org/`."

#: src/exercises/day-4/link-checker.md:45
#, fuzzy
msgid "Your `src/main.rs` file should look something like this:"
msgstr "Tw贸j plik `src/main.rs` powinien wyglda mniej wicej tak:"

#: src/exercises/day-4/link-checker.md:47
msgid ""
"```rust,compile_fail\n"
"use reqwest::blocking::{get, Response};\n"
"use reqwest::Url;\n"
"use scraper::{Html, Selector};\n"
"use thiserror::Error;\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:53
msgid ""
"\\#\\[derive(Error, Debug)\\] enum Error { \\#\\[error(\"request error: "
"{0}\")\\] ReqwestError(#\\[from\\] reqwest::Error), }"
msgstr ""
"\\#\\[derive(Error, Debug)\\] enum Error { \\#\\[error(\"bd zapytania: "
"{0}\")\\] ReqwestError(#\\[from\\] reqwest::Error), }"

#: src/exercises/day-4/link-checker.md:59
msgid "fn extract_links(response: Response) -> Result\\<Vec"
msgstr ""

#: src/exercises/day-4/link-checker.md:59
msgid ""
", Error> { let base_url = response.url().to_owned(); let document = response."
"text()?; let html = Html::parse_document(&document); let selector = "
"Selector::parse(\"a\").unwrap();"
msgstr ""

#: src/exercises/day-4/link-checker.md:65
msgid ""
"```\n"
"let mut valid_urls = Vec::new();\n"
"for element in html.select(&selector) {\n"
"    if let Some(href) = element.value().attr(\"href\") {\n"
"        match base_url.join(href) {\n"
"            Ok(url) => valid_urls.push(url),\n"
"            Err(err) => {\n"
"                println!(\"On {base_url}: could not parse {href:?}: {err} "
"(ignored)\",);\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:77
#, fuzzy
msgid ""
"```\n"
"Ok(valid_urls)\n"
"```"
msgstr ""
"```\n"
"OK (prawidowe_adresy URL)\n"
"```"

#: src/exercises/day-4/link-checker.md:80
msgid ""
"fn main() { let start_url = Url::parse(\"https://www.google.org\").unwrap(); "
"let response = get(start_url).unwrap(); match extract_links(response) "
"{ Ok(links) => println!(\"Links: {links:#?}\"), Err(err) => println!(\"Could "
"not extract links: {err:#}\"), } }"
msgstr ""

#: src/exercises/day-4/link-checker.md:90
#, fuzzy
msgid "Run the code in `src/main.rs` with"
msgstr "Uruchom kod w `src/main.rs` za pomoc"

#: src/exercises/day-4/link-checker.md:92
#, fuzzy
msgid ""
"```shell\n"
"$ cargo run\n"
"```"
msgstr "Korzystanie z Cargo"

#: src/exercises/day-4/link-checker.md:96
#, fuzzy
msgid "Tasks"
msgstr "Zadania"

#: src/exercises/day-4/link-checker.md:98
#, fuzzy
msgid ""
"Use threads to check the links in parallel: send the URLs to be checked to a "
"channel and let a few threads check the URLs in parallel."
msgstr ""
"U偶ywaj wtk贸w do r贸wnolegego sprawdzania link贸w: wylij adresy URL do "
"sprawdzenia do a channel i pozw贸l kilku wtkom r贸wnolegle sprawdza adresy "
"URL."

#: src/exercises/day-4/link-checker.md:100
#, fuzzy
msgid ""
"Extend this to recursively extract links from all pages on the `www.google."
"org` domain. Put an upper limit of 100 pages or so so that you don't end up "
"being blocked by the site."
msgstr ""
"Rozszerz to, aby rekurencyjnie wyodrbni linki ze wszystkich stron w "
"witrynie domena `www.google.org`. Ustaw g贸rny limit 100 stron lub tak, aby "
"m贸g nie zosta zablokowany przez witryn."

#: src/android.md:3
#, fuzzy
msgid ""
"Rust is supported for native platform development on Android. This means "
"that you can write new operating system services in Rust, as well as "
"extending existing services."
msgstr ""
"Rust jest obsugiwany w przypadku tworzenia natywnych platform na Androida. "
"To znaczy 偶e mo偶esz pisa nowe usugi systemu operacyjnego w Rust, a tak偶e "
"rozszerza istniejce usugi."

#: src/android/setup.md:3
#, fuzzy
msgid ""
"We will be using an Android Virtual Device to test our code. Make sure you "
"have access to one or create a new one with:"
msgstr ""
"Bdziemy u偶ywa urzdzenia wirtualnego z Androidem do testowania naszego "
"kodu. Upewnij si 偶e masz dostp do jednego lub utw贸rz nowy z:"

#: src/android/setup.md:6
msgid ""
"```shell\n"
"$ source build/envsetup.sh\n"
"$ lunch aosp_cf_x86_64_phone-userdebug\n"
"$ acloud create\n"
"```"
msgstr ""

#: src/android/setup.md:12
#, fuzzy
msgid ""
"Please see the [Android Developer Codelab](https://source.android.com/docs/"
"setup/start) for details."
msgstr ""
"Zobacz [Android Developer Codelab](https://source.android.com/docs/setup/"
"start), aby uzyska szczeg贸owe informacje."

#: src/android/build-rules.md:3
#, fuzzy
msgid "The Android build system (Soong) supports Rust via a number of modules:"
msgstr ""
"System kompilacji Androida (Soong) obsuguje Rusta za porednictwem wielu "
"modu贸w:"

#: src/android/build-rules.md:5
#, fuzzy
msgid "Module Type"
msgstr "Typ moduu"

#: src/android/build-rules.md:5
#, fuzzy
msgid "Description"
msgstr "Opis"

#: src/android/build-rules.md:7
#, fuzzy
msgid "`rust_binary`"
msgstr "`rust_binary`"

#: src/android/build-rules.md:7
#, fuzzy
msgid "Produces a Rust binary."
msgstr "Tworzy plik binarny Rust."

#: src/android/build-rules.md:8
#, fuzzy
msgid "`rust_library`"
msgstr "`rust_biblioteka`"

#: src/android/build-rules.md:8
#, fuzzy
msgid "Produces a Rust library, and provides both `rlib` and `dylib` variants."
msgstr ""
"Tworzy bibliotek Rust i udostpnia zar贸wno warianty `rlib`, jak i `dylib`."

#: src/android/build-rules.md:9
#, fuzzy
msgid "`rust_ffi`"
msgstr "`rust_ffi`"

#: src/android/build-rules.md:9
#, fuzzy
msgid ""
"Produces a Rust C library usable by `cc` modules, and provides both static "
"and shared variants."
msgstr ""
"Tworzy bibliotek Rust C u偶ywan przez moduy `cc` i zapewnia zar贸wno "
"statyczne, jak i wsp贸dzielone warianty."

#: src/android/build-rules.md:10
#, fuzzy
msgid "`rust_proc_macro`"
msgstr "`rust_proc_macro`"

#: src/android/build-rules.md:10
#, fuzzy
msgid ""
"Produces a `proc-macro` Rust library. These are analogous to compiler "
"plugins."
msgstr ""
"Tworzy bibliotek `proc-macro` Rusta. S one analogiczne do wtyczek "
"kompilatora."

#: src/android/build-rules.md:11
#, fuzzy
msgid "`rust_test`"
msgstr "`test_rdzy`"

#: src/android/build-rules.md:11
#, fuzzy
msgid "Produces a Rust test binary that uses the standard Rust test harness."
msgstr ""
"Tworzy plik binarny testu Rust, kt贸ry u偶ywa standardowej wizki testowej "
"Rust."

#: src/android/build-rules.md:12
#, fuzzy
msgid "`rust_fuzz`"
msgstr "`rust_fuzz`"

#: src/android/build-rules.md:12
#, fuzzy
msgid "Produces a Rust fuzz binary leveraging `libfuzzer`."
msgstr "Tworzy plik binarny Rust fuzz wykorzystujcy `libfuzzer`."

#: src/android/build-rules.md:13
#, fuzzy
msgid "`rust_protobuf`"
msgstr "`rust_protobuf`"

#: src/android/build-rules.md:13
#, fuzzy
msgid ""
"Generates source and produces a Rust library that provides an interface for "
"a particular protobuf."
msgstr ""
"Generuje 藕r贸do i tworzy bibliotek Rust, kt贸ra zapewnia interfejs dla "
"okrelonego protobuf."

#: src/android/build-rules.md:14
#, fuzzy
msgid "`rust_bindgen`"
msgstr "`rdza_powizanie`"

#: src/android/build-rules.md:14
#, fuzzy
msgid ""
"Generates source and produces a Rust library containing Rust bindings to C "
"libraries."
msgstr ""
"Generuje 藕r贸do i tworzy bibliotek Rust zawierajc powizania Rusta z "
"bibliotekami C."

#: src/android/build-rules.md:16
#, fuzzy
msgid "We will look at `rust_binary` and `rust_library` next."
msgstr "Nastpnie przyjrzymy si `rust_binary` i `rust_library`."

#: src/android/build-rules/binary.md:1
msgid "Rust Binaries"
msgstr "Binaria Rusta"

#: src/android/build-rules/binary.md:3
#, fuzzy
msgid ""
"Let us start with a simple application. At the root of an AOSP checkout, "
"create the following files:"
msgstr ""
"Zacznijmy od prostej aplikacji. W katalogu g贸wnym kasy AOSP utw贸rz "
"nastpujce pliki:"

#: src/android/build-rules/binary.md:6 src/android/build-rules/library.md:13
msgid "_hello_rust/Android.bp_:"
msgstr "_hello_rust/Android.bp_:"

#: src/android/build-rules/binary.md:8
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust\",\n"
"    crate_name: \"hello_rust\",\n"
"    srcs: [\"src/main.rs\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/binary.md:16 src/android/build-rules/library.md:34
#, fuzzy
msgid "_hello_rust/src/main.rs_:"
msgstr "_hello_rust/src/main.rs_:"

#: src/android/build-rules/binary.md:18
msgid ""
"```rust\n"
"//! Rust demo.\n"
"```"
msgstr ""
"```rust\n"
"//! Rust demo.\n"
"```"

#: src/android/build-rules/binary.md:21
msgid ""
"/// Prints a greeting to standard output. fn main() { println!(\"Hello from "
"Rust!\"); }"
msgstr ""

#: src/android/build-rules/binary.md:27
#, fuzzy
msgid "You can now build, push, and run the binary:"
msgstr "Mo偶esz teraz budowa, przesya i uruchamia plik binarny:"

#: src/android/build-rules/binary.md:29
msgid ""
"```shell\n"
"$ m hello_rust\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust\n"
"Hello from Rust!\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:1
msgid "Rust Libraries"
msgstr "Biblioteki Rusta"

#: src/android/build-rules/library.md:3
#, fuzzy
msgid "You use `rust_library` to create a new Rust library for Android."
msgstr ""
"U偶ywasz `rust_library` do tworzenia nowej biblioteki Rust dla Androida."

#: src/android/build-rules/library.md:5
#, fuzzy
msgid "Here we declare a dependency on two libraries:"
msgstr "Tutaj deklarujemy zale偶no od dw贸ch bibliotek:"

#: src/android/build-rules/library.md:7
#, fuzzy
msgid "`libgreeting`, which we define below,"
msgstr "`libgreeting`, kt贸re definiujemy poni偶ej,"

#: src/android/build-rules/library.md:8
#, fuzzy
msgid ""
"`libtextwrap`, which is a crate already vendored in [`external/rust/crates/`]"
"(https://cs.android.com/android/platform/superproject/+/master:external/rust/"
"crates/)."
msgstr ""
"`libtextwrap`, kt贸ra jest ju偶 sprzedawan skrzynk [`zewntrzne/rdza/"
"skrzynie/`](https://cs.android.com/android/platform/superproject/+/master:"
"external/rust/crates/)."

#: src/android/build-rules/library.md:15
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_with_dep\",\n"
"    crate_name: \"hello_rust_with_dep\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"libgreetings\",\n"
"        \"libtextwrap\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:27
msgid ""
"rust_library { name: \"libgreetings\", crate_name: \"greetings\", srcs: "
"\\[\"src/lib.rs\"\\], }"
msgstr ""

#: src/android/build-rules/library.md:32
msgid ""
"```\n"
"\n"
"# Rust Libraries\n"
"\n"
"You use `rust_library` to create a new Rust library for Android.\n"
"\n"
"Here we declare a dependency on two libraries:\n"
"\n"
"* `libgreeting`, which we define below,\n"
"* `libtextwrap`, which is a crate already vendored in\n"
"  [`external/rust/crates/`][crates].\n"
"\n"
"[crates]: https://cs.android.com/android/platform/superproject/+/master:"
"external/rust/crates/\n"
"\n"
"_hello_rust/Android.bp_:\n"
"\n"
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_with_dep\",\n"
"    crate_name: \"hello_rust_with_dep\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"libgreetings\",\n"
"        \"libtextwrap\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"\n"
"_hello_rust/src/main.rs_:\n"
"\n"
"```rust,ignore\n"
"//! Rust demo.\n"
"\n"
"use greetings::greeting;\n"
"use textwrap::fill;\n"
"\n"
"/// Prints a greeting to standard output.\n"
"fn main() {\n"
"    println!(\"{}\", fill(&greeting(\"Bob\"), 24));\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:36
msgid ""
"```rust,ignore\n"
"//! Rust demo.\n"
"```"
msgstr ""
"```rust,ignore\n"
"//! Rust demo.\n"
"```"

#: src/android/build-rules/library.md:39
msgid "use greetings::greeting; use textwrap::fill;"
msgstr ""

#: src/android/build-rules/library.md:42
msgid ""
"/// Prints a greeting to standard output. fn main() { println!(\"{}\", "
"fill(&greeting(\"Bob\"), 24)); }"
msgstr ""

#: src/android/build-rules/library.md:48
#, fuzzy
msgid "_hello_rust/src/lib.rs_:"
msgstr "_hello_rust/src/lib.rs_:"

#: src/android/build-rules/library.md:50
msgid ""
"```rust,ignore\n"
"//! Greeting library.\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:53
msgid ""
"/// Greet `name`. pub fn greeting(name: &str) -> String { format!(\"Hello "
"{name}, it is very nice to meet you!\") }"
msgstr ""

#: src/android/build-rules/library.md:59
#, fuzzy
msgid "You build, push, and run the binary like before:"
msgstr "Budujesz, wypychasz i uruchamiasz plik binarny tak jak poprzednio:"

#: src/android/build-rules/library.md:61
msgid ""
"```shell\n"
"$ m hello_rust_with_dep\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep /data/local/"
"tmp\n"
"$ adb shell /data/local/tmp/hello_rust_with_dep\n"
"Hello Bob, it is very\n"
"nice to meet you!\n"
"```"
msgstr ""

#: src/android/aidl.md:3
#, fuzzy
msgid ""
"The [Android Interface Definition Language (AIDL)](https://developer.android."
"com/guide/components/aidl) is supported in Rust:"
msgstr ""
"[Jzyk definicji interfejsu Androida (AIDL)](https://developer.android.com/"
"guide/components/aidl) jest obsugiwany w Rust:"

#: src/android/aidl.md:6
#, fuzzy
msgid "Rust code can call existing AIDL servers,"
msgstr "Kod Rusta mo偶e wywoywa istniejce serwery AIDL,"

#: src/android/aidl.md:7
#, fuzzy
msgid "You can create new AIDL servers in Rust."
msgstr "Mo偶esz tworzy nowe serwery AIDL w Rust."

#: src/android/aidl/interface.md:1
#, fuzzy
msgid "AIDL Interfaces"
msgstr "Interfejsy AIDL"

#: src/android/aidl/interface.md:3
#, fuzzy
msgid "You declare the API of your service using an AIDL interface:"
msgstr "Deklarujesz API swojej usugi za pomoc interfejsu AIDL:"

#: src/android/aidl/interface.md:5
#, fuzzy
msgid ""
"_birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl_:"
msgstr ""
"_urodziny_serwis/aidl/com/example/birthdayservice/IBirthdayService.aidl_:"

#: src/android/aidl/interface.md:7 src/android/aidl/changing.md:6
msgid ""
"```java\n"
"package com.example.birthdayservice;\n"
"```"
msgstr ""

#: src/android/aidl/interface.md:10
msgid ""
"/\\*\\* Birthday service interface. _/ interface IBirthdayService { /_\\* "
"Generate a Happy Birthday message. \\*/ String wishHappyBirthday(String "
"name, int years); }"
msgstr ""

#: src/android/aidl/interface.md:17
#, fuzzy
msgid "_birthday_service/aidl/Android.bp_:"
msgstr "_birthday_service/aidl/Android.bp_:"

#: src/android/aidl/interface.md:19
msgid ""
"```javascript\n"
"aidl_interface {\n"
"    name: \"com.example.birthdayservice\",\n"
"    srcs: [\"com/example/birthdayservice/*.aidl\"],\n"
"    unstable: true,\n"
"    backend: {\n"
"        rust: { // Rust is not enabled by default\n"
"            enabled: true,\n"
"        },\n"
"    },\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/interface.md:32
#, fuzzy
msgid ""
"Add `vendor_available: true` if your AIDL file is used by a binary in the "
"vendor partition."
msgstr ""
"Dodaj vendor_available: true, jeli plik AIDL jest u偶ywany przez plik "
"binarny dostawcy przegroda."

#: src/android/aidl/implementation.md:1
#, fuzzy
msgid "Service Implementation"
msgstr "Implementacja usugi"

#: src/android/aidl/implementation.md:3
#, fuzzy
msgid "We can now implement the AIDL service:"
msgstr "Mo偶emy teraz wdro偶y usug AIDL:"

#: src/android/aidl/implementation.md:5
#, fuzzy
msgid "_birthday_service/src/lib.rs_:"
msgstr "_birthday_service/src/lib.rs_:"

#: src/android/aidl/implementation.md:7
msgid ""
"```rust,ignore\n"
"//! Implementation of the `IBirthdayService` AIDL interface.\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::"
"IBirthdayService::IBirthdayService;\n"
"use com_example_birthdayservice::binder;\n"
"```"
msgstr ""

#: src/android/aidl/implementation.md:12
msgid "/// The `IBirthdayService` implementation. pub struct BirthdayService;"
msgstr ""

#: src/android/aidl/implementation.md:15
#, fuzzy
msgid "impl binder::Interface for BirthdayService {}"
msgstr "impl binder::Interfejs dla BirthdayService {}"

#: src/android/aidl/implementation.md:17
msgid ""
"impl IBirthdayService for BirthdayService { fn wishHappyBirthday(&self, "
"name: &str, years: i32) -> binder::Result"
msgstr ""

#: src/android/aidl/implementation.md:18
msgid ""
" { Ok(format!( \"Happy Birthday {name}, congratulations with the {years} "
"years!\" )) } }"
msgstr ""

#: src/android/aidl/implementation.md:26 src/android/aidl/server.md:28
#: src/android/aidl/client.md:37
#, fuzzy
msgid "_birthday_service/Android.bp_:"
msgstr "_birthday_service/Android.bp_:"

#: src/android/aidl/implementation.md:28
msgid ""
"```javascript\n"
"rust_library {\n"
"    name: \"libbirthdayservice\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    crate_name: \"birthdayservice\",\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/server.md:1
#, fuzzy
msgid "AIDL Server"
msgstr "Serwer AIDL"

#: src/android/aidl/server.md:3
#, fuzzy
msgid "Finally, we can create a server which exposes the service:"
msgstr "Na koniec mo偶emy stworzy serwer, kt贸ry eksponuje usug:"

#: src/android/aidl/server.md:5
#, fuzzy
msgid "_birthday_service/src/server.rs_:"
msgstr "_birthday_service/src/server.rs_:"

#: src/android/aidl/server.md:7
msgid ""
"```rust,ignore\n"
"//! Birthday service.\n"
"use birthdayservice::BirthdayService;\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::"
"IBirthdayService::BnBirthdayService;\n"
"use com_example_birthdayservice::binder;\n"
"```"
msgstr ""

#: src/android/aidl/server.md:13 src/android/aidl/client.md:12
msgid "const SERVICE_IDENTIFIER: &str = \"birthdayservice\";"
msgstr ""

#: src/android/aidl/server.md:15
msgid ""
"/// Entry point for birthday service. fn main() { let birthday_service = "
"BirthdayService; let birthday_service_binder = BnBirthdayService::"
"new_binder( birthday_service, binder::BinderFeatures::default(), ); binder::"
"add_service(SERVICE_IDENTIFIER, birthday_service_binder.as_binder()) ."
"expect(\"Failed to register service\"); binder::ProcessState::"
"join_thread_pool() }"
msgstr ""

#: src/android/aidl/server.md:30
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_server\",\n"
"    crate_name: \"birthday_server\",\n"
"    srcs: [\"src/server.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"        \"libbirthdayservice\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:3
#, fuzzy
msgid "We can now build, push, and start the service:"
msgstr "Mo偶emy teraz zbudowa, wypchn i uruchomi usug:"

#: src/android/aidl/deploy.md:5
msgid ""
"```shell\n"
"$ m birthday_server\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/tmp\n"
"$ adb shell /data/local/tmp/birthday_server\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:11
#, fuzzy
msgid "In another terminal, check that the service runs:"
msgstr "W innym terminalu sprawd藕, czy usuga dziaa:"

#: src/android/aidl/deploy.md:13
msgid ""
"```shell\n"
"$ adb shell service check birthdayservice\n"
"Service birthdayservice: found\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:18
#, fuzzy
msgid "You can also call the service with `service call`:"
msgstr "Mo偶esz r贸wnie偶 zadzwoni do serwisu za pomoc `wezwania serwisowego`:"

#: src/android/aidl/deploy.md:20
msgid ""
"```shell\n"
"$ $ adb shell service call birthdayservice 1 s16 Bob i32 24\n"
"Result: Parcel(\n"
"  0x00000000: 00000000 00000036 00610048 00700070 '....6...H.a.p.p.'\n"
"  0x00000010: 00200079 00690042 00740072 00640068 'y. .B.i.r.t.h.d.'\n"
"  0x00000020: 00790061 00420020 0062006f 0020002c 'a.y. .B.o.b.,. .'\n"
"  0x00000030: 006f0063 0067006e 00610072 00750074 'c.o.n.g.r.a.t.u.'\n"
"  0x00000040: 0061006c 00690074 006e006f 00200073 'l.a.t.i.o.n.s. .'\n"
"  0x00000050: 00690077 00680074 00740020 00650068 'w.i.t.h. .t.h.e.'\n"
"  0x00000060: 00320020 00200034 00650079 00720061 ' .2.4. .y.e.a.r.'\n"
"  0x00000070: 00210073 00000000                   's.!.....        ')\n"
"```"
msgstr ""

#: src/android/aidl/client.md:1
#, fuzzy
msgid "AIDL Client"
msgstr "Klient AIDL"

#: src/android/aidl/client.md:3
#, fuzzy
msgid "Finally, we can create a Rust client for our new service."
msgstr "Wreszcie mo偶emy stworzy klienta Rust dla naszej nowej usugi."

#: src/android/aidl/client.md:5
#, fuzzy
msgid "_birthday_service/src/client.rs_:"
msgstr "_birthday_service/src/client.rs_:"

#: src/android/aidl/client.md:7
msgid ""
"```rust,ignore\n"
"//! Birthday service.\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::"
"IBirthdayService::IBirthdayService;\n"
"use com_example_birthdayservice::binder;\n"
"```"
msgstr ""

#: src/android/aidl/client.md:14
#, fuzzy
msgid ""
"/// Connect to the BirthdayService. pub fn connect() -> Result\\<binder::"
"Strong"
msgstr ""
"/// Pocz si z usug BirthdayService. pub fn connect() -> Wynik\\<binder::"
"Strong"

#: src/android/aidl/client.md:15
#, fuzzy
msgid ", binder::StatusCode> { binder::get_interface(SERVICE_IDENTIFIER) }"
msgstr ", binder::StatusCode> { binder::get_interface(SERVICE_IDENTIFIER) }"

#: src/android/aidl/client.md:19
msgid ""
"/// Call the birthday service. fn main() -> Result\\<(), binder::Status> "
"{ let name = std::env::args() .nth(1) .unwrap_or_else(|| String::"
"from(\"Bob\")); let years = std::env::args() .nth(2) .and_then(|arg| arg."
"parse::"
msgstr ""

#: src/android/aidl/client.md:26
msgid "().ok()) .unwrap_or(42);"
msgstr ""

#: src/android/aidl/client.md:29
msgid ""
"```\n"
"binder::ProcessState::start_thread_pool();\n"
"let service = connect().expect(\"Failed to connect to BirthdayService\");\n"
"let msg = service.wishHappyBirthday(&name, years)?;\n"
"println!(\"{msg}\");\n"
"Ok(())\n"
"```"
msgstr ""

#: src/android/aidl/client.md:39
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_client\",\n"
"    crate_name: \"birthday_client\",\n"
"    srcs: [\"src/client.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/client.md:52
#, fuzzy
msgid "Notice that the client does not depend on `libbirthdayservice`."
msgstr "Zauwa偶, 偶e klient nie jest zale偶ny od `libbirthdayservice`."

#: src/android/aidl/client.md:54
#, fuzzy
msgid "Build, push, and run the client on your device:"
msgstr "Zbuduj, wypchnij i uruchom klienta na swoim urzdzeniu:"

#: src/android/aidl/client.md:56
msgid ""
"```shell\n"
"$ m birthday_client\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/birthday_client /data/local/tmp\n"
"$ adb shell /data/local/tmp/birthday_client Charlie 60\n"
"Happy Birthday Charlie, congratulations with the 60 years!\n"
"```"
msgstr ""

#: src/android/aidl/changing.md:3
#, fuzzy
msgid ""
"Let us extend the API with more functionality: we want to let clients "
"specify a list of lines for the birthday card:"
msgstr ""
"Rozszerzmy API o wicej funkcji: chcemy pozwoli klientom okreli lista "
"wierszy na kartk urodzinow:"

#: src/android/aidl/changing.md:9
msgid ""
"/\\*\\* Birthday service interface. _/ interface IBirthdayService { /_\\* "
"Generate a Happy Birthday message. \\*/ String wishHappyBirthday(String "
"name, int years, in String\\[\\] text); }"
msgstr ""

#: src/android/logging.md:3
#, fuzzy
msgid ""
"You should use the `log` crate to automatically log to `logcat` (on-device) "
"or `stdout` (on-host):"
msgstr ""
"Powiniene u偶y skrzynki `log`, aby automatycznie zalogowa si do `logcat` "
"(na urzdzeniu) lub `stdout` (na hocie):"

#: src/android/logging.md:6
#, fuzzy
msgid "_hello_rust_logs/Android.bp_:"
msgstr "_hello_rust_logs/Android.bp_:"

#: src/android/logging.md:8
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_logs\",\n"
"    crate_name: \"hello_rust_logs\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"liblog_rust\",\n"
"        \"liblogger\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"    host_supported: true,\n"
"}\n"
"```"
msgstr ""

#: src/android/logging.md:22
#, fuzzy
msgid "_hello_rust_logs/src/main.rs_:"
msgstr "_hello_rust_logs/src/main.rs_:"

#: src/android/logging.md:24
msgid ""
"```rust,ignore\n"
"//! Rust logging demo.\n"
"```"
msgstr ""

#: src/android/logging.md:27
msgid "use log::{debug, error, info};"
msgstr ""

#: src/android/logging.md:29
msgid ""
"/// Logs a greeting. fn main() { logger::init( logger::Config::default() ."
"with_tag_on_device(\"rust\") .with_min_level(log::Level::Trace), ); debug!"
"(\"Starting program.\"); info!(\"Things are going fine.\"); error!"
"(\"Something went wrong!\"); }"
msgstr ""

#: src/android/logging.md:42 src/android/interoperability/with-c/bindgen.md:98
#: src/android/interoperability/with-c/rust.md:73
#, fuzzy
msgid "Build, push, and run the binary on your device:"
msgstr "Zbuduj, wypchnij i uruchom plik binarny na swoim urzdzeniu:"

#: src/android/logging.md:44
msgid ""
"```shell\n"
"$ m hello_rust_logs\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust_logs\n"
"```"
msgstr ""

#: src/android/logging.md:50
#, fuzzy
msgid "The logs show up in `adb logcat`:"
msgstr "Dzienniki pojawiaj si w `adb logcat`:"

#: src/android/logging.md:52
msgid ""
"```shell\n"
"$ adb logcat -s rust\n"
"09-08 08:38:32.454  2420  2420 D rust: hello_rust_logs: Starting program.\n"
"09-08 08:38:32.454  2420  2420 I rust: hello_rust_logs: Things are going "
"fine.\n"
"09-08 08:38:32.454  2420  2420 E rust: hello_rust_logs: Something went "
"wrong!\n"
"```"
msgstr ""

#: src/android/interoperability.md:3
#, fuzzy
msgid ""
"Rust has excellent support for interoperability with other languages. This "
"means that you can:"
msgstr ""
"Rust ma doskonae wsparcie dla interoperacyjnoci z innymi jzykami. To "
"znaczy 偶e mo偶esz:"

#: src/android/interoperability.md:6
#, fuzzy
msgid "Call Rust functions from other languages."
msgstr "Wywoaj funkcje Rust z innych jzyk贸w."

#: src/android/interoperability.md:7
#, fuzzy
msgid "Call functions written in other languages from Rust."
msgstr "Funkcje wywoania napisane w innych jzykach z Rust."

#: src/android/interoperability.md:9
#, fuzzy
msgid ""
"When you call functions in a foreign language we say that you're using a "
"_foreign function interface_, also known as FFI."
msgstr ""
"Kiedy wywoujesz funkcje w jzyku obcym, m贸wimy, 偶e u偶ywasz a _interfejs "
"funkcji obcych_, znany r贸wnie偶 jako FFI."

#: src/android/interoperability/with-c.md:1
#, fuzzy
msgid "Interoperability with C"
msgstr "Interoperacyjno z C"

#: src/android/interoperability/with-c.md:3
#, fuzzy
msgid ""
"Rust has full support for linking object files with a C calling convention. "
"Similarly, you can export Rust functions and call them from C."
msgstr ""
"Rust ma pene wsparcie dla czenia plik贸w obiektowych z konwencj "
"wywoywania C. Podobnie mo偶esz eksportowa funkcje Rust i wywoywa je z C."

#: src/android/interoperability/with-c.md:6
#, fuzzy
msgid "You can do it by hand if you want:"
msgstr "Mo偶esz to zrobi rcznie, jeli chcesz:"

#: src/android/interoperability/with-c.md:8
msgid ""
"```rust\n"
"extern \"C\" {\n"
"    fn abs(x: i32) -> i32;\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c.md:13
msgid ""
"fn main() { let x = -42; let abs_x = unsafe { abs(x) }; println!(\"{x}, "
"{abs_x}\"); }"
msgstr ""

#: src/android/interoperability/with-c.md:20
#, fuzzy
msgid ""
"We already saw this in the [Safe FFI Wrapper exercise](../../exercises/day-3/"
"safe-ffi-wrapper.md)."
msgstr ""
"Widzielimy to ju偶 w [Safe FFI Wrapper wiczenie](../../wiczenia/dzie-3/"
"safe-ffi-wrapper.md)."

#: src/android/interoperability/with-c.md:23
#, fuzzy
msgid ""
"This assumes full knowledge of the target platform. Not recommended for "
"production."
msgstr ""
"Zakada to pen znajomo platformy docelowej. Nie zalecane dla produkcja."

#: src/android/interoperability/with-c.md:26
#, fuzzy
msgid "We will look at better options next."
msgstr "W nastpnej kolejnoci przyjrzymy si lepszym opcjom."

#: src/android/interoperability/with-c/bindgen.md:1
#, fuzzy
msgid "Using Bindgen"
msgstr "Korzystanie z Cargo"

#: src/android/interoperability/with-c/bindgen.md:3
#, fuzzy
msgid ""
"The [bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html) "
"tool can auto-generate bindings from a C header file."
msgstr ""
"Narzdzie [bindgen](https://rust-lang.github.io/rust-bindgen/introduction."
"html) mo偶e automatycznie generowa powizania z pliku nag贸wkowego C."

#: src/android/interoperability/with-c/bindgen.md:6
#, fuzzy
msgid "First create a small C library:"
msgstr "Najpierw utw贸rz ma bibliotek C:"

#: src/android/interoperability/with-c/bindgen.md:8
#, fuzzy
msgid "_interoperability/bindgen/libbirthday.h_:"
msgstr "_interoperability/bindgen/libbirthday.h_:"

#: src/android/interoperability/with-c/bindgen.md:10
msgid ""
"```c\n"
"typedef struct card {\n"
"  const char* name;\n"
"  int years;\n"
"} card;\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:16
msgid "void print_card(const card\\* card);"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:19
#, fuzzy
msgid "_interoperability/bindgen/libbirthday.c_:"
msgstr "_interoperability/bindgen/libbirthday.c_:"

#: src/android/interoperability/with-c/bindgen.md:21
msgid ""
"```c\n"
"#include <stdio.h>\n"
"#include \"libbirthday.h\"\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:25
msgid ""
"void print_card(const card\\* card) { printf(\"+--------------\\n\"); "
"printf(\"| Happy Birthday %s!\\n\", card->name); printf(\"| Congratulations "
"with the %i years!\\n\", card->years); printf(\"+--------------\\n\"); }"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:33
#, fuzzy
msgid "Add this to your `Android.bp` file:"
msgstr "Dodaj to do swojego pliku `Android.bp`:"

#: src/android/interoperability/with-c/bindgen.md:35
#: src/android/interoperability/with-c/bindgen.md:55
#: src/android/interoperability/with-c/bindgen.md:69
#: src/android/interoperability/with-c/bindgen.md:108
#, fuzzy
msgid "_interoperability/bindgen/Android.bp_:"
msgstr "_interoperacyjno/bindgen/Android.bp_:"

#: src/android/interoperability/with-c/bindgen.md:37
msgid ""
"```javascript\n"
"cc_library {\n"
"    name: \"libbirthday\",\n"
"    srcs: [\"libbirthday.c\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:44
#, fuzzy
msgid ""
"Create a wrapper header file for the library (not strictly needed in this "
"example):"
msgstr ""
"Utw贸rz plik nag贸wkowy opakowania dla biblioteki (nie jest to bezwzgldnie "
"potrzebne w tym przypadku przykad):"

#: src/android/interoperability/with-c/bindgen.md:47
#, fuzzy
msgid "_interoperability/bindgen/libbirthday_wrapper.h_:"
msgstr "_interoperability/bindgen/libbirthday_wrapper.h_:"

#: src/android/interoperability/with-c/bindgen.md:49
msgid ""
"```c\n"
"#include \"libbirthday.h\"\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:53
#, fuzzy
msgid "You can now auto-generate the bindings:"
msgstr "Mo偶esz teraz automatycznie generowa powizania:"

#: src/android/interoperability/with-c/bindgen.md:57
msgid ""
"```javascript\n"
"rust_bindgen {\n"
"    name: \"libbirthday_bindgen\",\n"
"    crate_name: \"birthday_bindgen\",\n"
"    wrapper_src: \"libbirthday_wrapper.h\",\n"
"    source_stem: \"bindings\",\n"
"    static_libs: [\"libbirthday\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:67
#, fuzzy
msgid "Finally, we can use the bindings in our Rust program:"
msgstr "Na koniec mo偶emy u偶y powiza w naszym programie Rust:"

#: src/android/interoperability/with-c/bindgen.md:71
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"print_birthday_card\",\n"
"    srcs: [\"main.rs\"],\n"
"    rustlibs: [\"libbirthday_bindgen\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:79
#, fuzzy
msgid "_interoperability/bindgen/main.rs_:"
msgstr "_interoperacyjno/bindgen/main.rs_:"

#: src/android/interoperability/with-c/bindgen.md:81
msgid ""
"```rust,compile_fail\n"
"//! Bindgen demo.\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:84
msgid "use birthday_bindgen::{card, print_card};"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:86
msgid ""
"fn main() { let name = std::ffi::CString::new(\"Peter\").unwrap(); let card "
"= card { name: name.as_ptr(), years: 42, }; unsafe { print_card(&card as "
"\\*const card); } }"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:100
msgid ""
"```shell\n"
"$ m print_birthday_card\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/print_birthday_card /data/local/"
"tmp\n"
"$ adb shell /data/local/tmp/print_birthday_card\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:106
#, fuzzy
msgid "Finally, we can run auto-generated tests to ensure the bindings work:"
msgstr ""
"Na koniec mo偶emy uruchomi automatycznie generowane testy, aby upewni si, "
"偶e powizania dziaaj:"

#: src/android/interoperability/with-c/bindgen.md:110
msgid ""
"```javascript\n"
"rust_test {\n"
"    name: \"libbirthday_bindgen_test\",\n"
"    srcs: [\":libbirthday_bindgen\"],\n"
"    crate_name: \"libbirthday_bindgen_test\",\n"
"    test_suites: [\"general-tests\"],\n"
"    auto_gen_config: true,\n"
"    clippy_lints: \"none\", // Generated file, skip linting\n"
"    lints: \"none\",\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:122
msgid ""
"```shell\n"
"$ atest libbirthday_bindgen_test\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:1
#, fuzzy
msgid "Calling Rust"
msgstr "Ekosystem Rust"

#: src/android/interoperability/with-c/rust.md:3
#, fuzzy
msgid "Exporting Rust functions and types to C is easy:"
msgstr "Eksportowanie funkcji i typ贸w Rust do C jest atwe:"

#: src/android/interoperability/with-c/rust.md:5
#, fuzzy
msgid "_interoperability/rust/libanalyze/analyze.rs_"
msgstr "_interoperability/rust/libanalyze/analyze.rs_"

#: src/android/interoperability/with-c/rust.md:7
msgid ""
"```rust,editable\n"
"//! Rust FFI demo.\n"
"#![deny(improper_ctypes_definitions)]\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:11
msgid "use std::os::raw::c_int;"
msgstr ""

#: src/android/interoperability/with-c/rust.md:13
msgid ""
"/// Analyze the numbers. \\#\\[no_mangle\\] pub extern \"C\" fn "
"analyze_numbers(x: c_int, y: c_int) { if x \\< y { println!(\"x ({x}) is "
"smallest!\"); } else { println!(\"y ({y}) is probably larger than x "
"({x})\"); } }"
msgstr ""

#: src/android/interoperability/with-c/rust.md:22
msgid ""
"```\n"
"\n"
"# Calling Rust\n"
"\n"
"Exporting Rust functions and types to C is easy:\n"
"\n"
"_interoperability/rust/libanalyze/analyze.rs_\n"
"\n"
"```rust,editable\n"
"//! Rust FFI demo.\n"
"#![deny(improper_ctypes_definitions)]\n"
"\n"
"use std::os::raw::c_int;\n"
"\n"
"_interoperability/rust/libanalyze/analyze.h_\n"
"\n"
"```c\n"
"#ifndef ANALYSE_H\n"
"#define ANALYSE_H\n"
"\n"
"extern \"C\" {\n"
"void analyze_numbers(int x, int y);\n"
"}\n"
"\n"
"#endif\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:24
#, fuzzy
msgid "_interoperability/rust/libanalyze/analyze.h_"
msgstr "_interoperability/rust/libanalyze/analyze.h_"

#: src/android/interoperability/with-c/rust.md:26
msgid ""
"```c\n"
"#ifndef ANALYSE_H\n"
"#define ANALYSE_H\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:30
msgid "extern \"C\" { void analyze_numbers(int x, int y); }"
msgstr ""

#: src/android/interoperability/with-c/rust.md:34
msgid "\\#endif"
msgstr ""

#: src/android/interoperability/with-c/rust.md:37
#, fuzzy
msgid "_interoperability/rust/libanalyze/Android.bp_"
msgstr "_interoperacyjno/rust/libanalyze/Android.bp_"

#: src/android/interoperability/with-c/rust.md:39
msgid ""
"```javascript\n"
"rust_ffi {\n"
"    name: \"libanalyze_ffi\",\n"
"    crate_name: \"analyze_ffi\",\n"
"    srcs: [\"analyze.rs\"],\n"
"    include_dirs: [\".\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:48
#, fuzzy
msgid "We can now call this from a C binary:"
msgstr "Mo偶emy teraz wywoa to z pliku binarnego C:"

#: src/android/interoperability/with-c/rust.md:50
#, fuzzy
msgid "_interoperability/rust/analyze/main.c_"
msgstr "_interoperacyjno/rust/analiza/main.c_"

#: src/android/interoperability/with-c/rust.md:52
msgid ""
"```c\n"
"#include \"analyze.h\"\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:55
msgid ""
"int main() { analyze_numbers(10, 20); analyze_numbers(123, 123); return 0; }"
msgstr ""

#: src/android/interoperability/with-c/rust.md:62
#, fuzzy
msgid "_interoperability/rust/analyze/Android.bp_"
msgstr "_interoperacyjno/rust/analyze/Android.bp_"

#: src/android/interoperability/with-c/rust.md:64
msgid ""
"```javascript\n"
"cc_binary {\n"
"    name: \"analyze_numbers\",\n"
"    srcs: [\"main.c\"],\n"
"    static_libs: [\"libanalyze_ffi\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:75
msgid ""
"```shell\n"
"$ m analyze_numbers\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/analyze_numbers /data/local/tmp\n"
"$ adb shell /data/local/tmp/analyze_numbers\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:83
#, fuzzy
msgid ""
"`#[no_mangle]` disables Rust's usual name mangling, so the exported symbol "
"will just be the name of the function. You can also use `#[export_name = "
"\"some_name\"]` to specify whatever name you want."
msgstr ""
"`#[no_mangle]` wycza zwyke znieksztacanie nazw Rusta, wic eksportowany "
"symbol bdzie po prostu nazw funkcja. Mo偶esz tak偶e u偶y `#[nazwa_eksportu = "
"\"jaka_nazwa\"]`, aby okreli dowoln nazw."

#: src/android/interoperability/cpp.md:3
#, fuzzy
msgid ""
"The [CXX crate](https://cxx.rs/) makes it possible to do safe "
"interoperability between Rust and C++."
msgstr ""
"[Skrzynia CXX](https://cxx.rs/) umo偶liwia bezpieczn interoperacyjno "
"midzy Rust i C++."

#: src/android/interoperability/cpp.md:6
#, fuzzy
msgid "The overall approach looks like this:"
msgstr "Og贸lne podejcie wyglda nastpujco:"

#: src/android/interoperability/cpp.md:10
#, fuzzy
msgid ""
"See the [CXX tutorial](https://cxx.rs/tutorial.html) for an full example of "
"using this."
msgstr ""
"Zobacz [samouczek CXX](https://cxx.rs/tutorial.html), aby zapozna si z "
"penym przykadem u偶ycia tego."

#: src/android/interoperability/java.md:1
#, fuzzy
msgid "Interoperability with Java"
msgstr "Wsp贸praca z Jav"

#: src/android/interoperability/java.md:3
#, fuzzy
msgid ""
"Java can load shared objects via [Java Native Interface (JNI)](https://en."
"wikipedia.org/wiki/Java_Native_Interface). The [`jni` crate](https://docs.rs/"
"jni/) allows you to create a compatible library."
msgstr ""
"Java mo偶e adowa udostpnione obiekty za porednictwem [Java Native "
"Interface (JNI)](https://en.wikipedia.org/wiki/Java_Native_Interface). "
"[`jni` crate](https://docs.rs/jni/) umo偶liwia utworzenie kompatybilnej "
"biblioteki."

#: src/android/interoperability/java.md:7
#, fuzzy
msgid "First, we create a Rust function to export to Java:"
msgstr "Najpierw tworzymy funkcj Rust do eksportu do Javy:"

#: src/android/interoperability/java.md:9
#, fuzzy
msgid "_interoperability/java/src/lib.rs_:"
msgstr "_interoperacyjno/java/src/lib.rs_:"

#: src/android/interoperability/java.md:11
msgid ""
"```rust,compile_fail\n"
"//! Rust <-> Java FFI demo.\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:14
msgid ""
"use jni::objects::{JClass, JString}; use jni::sys::jstring; use jni::JNIEnv;"
msgstr ""

#: src/android/interoperability/java.md:18
msgid ""
"/// HelloWorld::hello method implementation. \\#\\[no_mangle\\] pub extern "
"\"system\" fn Java_HelloWorld_hello( env: JNIEnv, \\_class: JClass, name: "
"JString, ) -> jstring { let input: String = env.get_string(name).unwrap()."
"into(); let greeting = format!(\"Hello, {input}!\"); let output = env."
"new_string(greeting).unwrap(); output.into_inner() }"
msgstr ""

#: src/android/interoperability/java.md:30
msgid ""
"```\n"
"\n"
"# Interoperability with Java\n"
"\n"
"Java can load shared objects via [Java Native Interface\n"
"(JNI)](https://en.wikipedia.org/wiki/Java_Native_Interface). The [`jni`\n"
"crate](https://docs.rs/jni/) allows you to create a compatible library.\n"
"\n"
"First, we create a Rust function to export to Java:\n"
"\n"
"_interoperability/java/src/lib.rs_:\n"
"\n"
"```rust,compile_fail\n"
"//! Rust <-> Java FFI demo.\n"
"\n"
"use jni::objects::{JClass, JString};\n"
"use jni::sys::jstring;\n"
"use jni::JNIEnv;\n"
"\n"
"_interoperability/java/Android.bp_:\n"
"\n"
"```javascript\n"
"rust_ffi_shared {\n"
"    name: \"libhello_jni\",\n"
"    crate_name: \"hello_jni\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    rustlibs: [\"libjni\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:32
#: src/android/interoperability/java.md:62
#, fuzzy
msgid "_interoperability/java/Android.bp_:"
msgstr "_interoperacyjno/java/Android.bp_:"

#: src/android/interoperability/java.md:34
msgid ""
"```javascript\n"
"rust_ffi_shared {\n"
"    name: \"libhello_jni\",\n"
"    crate_name: \"hello_jni\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    rustlibs: [\"libjni\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:43
#, fuzzy
msgid "Finally, we can call this function from Java:"
msgstr "Na koniec mo偶emy wywoa t funkcj z Javy:"

#: src/android/interoperability/java.md:45
#, fuzzy
msgid "_interoperability/java/HelloWorld.java_:"
msgstr "_interoperacyjno/java/HelloWorld.java_:"

#: src/android/interoperability/java.md:47
msgid ""
"```java\n"
"class HelloWorld {\n"
"    private static native String hello(String name);\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:51
msgid ""
"```\n"
"static {\n"
"    System.loadLibrary(\"hello_jni\");\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:55
msgid ""
"```\n"
"public static void main(String[] args) {\n"
"    String output = HelloWorld.hello(\"Alice\");\n"
"    System.out.println(output);\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:64
msgid ""
"```javascript\n"
"java_binary {\n"
"    name: \"helloworld_jni\",\n"
"    srcs: [\"HelloWorld.java\"],\n"
"    main_class: \"HelloWorld\",\n"
"    required: [\"libhello_jni\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:73
#, fuzzy
msgid "Finally, you can build, sync, and run the binary:"
msgstr "Na koniec mo偶esz zbudowa, zsynchronizowa i uruchomi plik binarny:"

#: src/android/interoperability/java.md:75
msgid ""
"```shell\n"
"$ m helloworld_jni\n"
"$ adb sync  # requires adb root && adb remount\n"
"$ adb shell /system/bin/helloworld_jni\n"
"```"
msgstr ""

#: src/exercises/day-4/afternoon.md:3
#, fuzzy
msgid ""
"For the last exercise, we will look at one of the projects you work with. "
"Let us group up and do this together. Some suggestions:"
msgstr ""
"W ostatnim wiczeniu przyjrzymy si jednemu z projekt贸w, nad kt贸rymi "
"pracujesz. Pozw贸l nam zbierzcie si i zr贸bcie to razem. Jakie sugestie:"

#: src/exercises/day-4/afternoon.md:6
#, fuzzy
msgid "Call your AIDL service with a client written in Rust."
msgstr "Zadzwo do swojego serwisu AIDL z klientem napisanym w Rust."

#: src/exercises/day-4/afternoon.md:8
#, fuzzy
msgid "Move a function from your project to Rust and call it."
msgstr "Przenie funkcj z projektu do Rusta i wywoaj j."

#: src/exercises/day-4/afternoon.md:12
#, fuzzy
msgid ""
"No solution is provided here since this is open-ended: it relies on someone "
"in the class having a piece of code which you can turn in to Rust on the fly."
msgstr ""
"Nie podano tutaj 偶adnego rozwizania, poniewa偶 jest ono otwarte: polega na "
"kim w klasa posiadajca fragment kodu, kt贸ry mo偶na przekaza Rustowi w "
"locie."

#: src/thanks.md:3
#, fuzzy
msgid ""
"_Thank you for taking Comprehensive Rust !_ We hope you enjoyed it and "
"that it was useful."
msgstr ""
"_Dzikujemy za skorzystanie z Comprehensive Rust !_ Mamy nadziej, 偶e Ci "
"si podobao i 偶e tak byo przydatne."

#: src/thanks.md:6
#, fuzzy
msgid ""
"We've had a lot of fun putting the course together. The course is not "
"perfect, so if you spotted any mistakes or have ideas for improvements, "
"please get in [contact with us on GitHub](https://github.com/google/"
"comprehensive-rust/discussions). We would love to hear from you."
msgstr ""
"wietnie si bawilimy przygotowujc kurs. Kurs nie jest doskonay, wic "
"jeli zauwa偶ye jakie bdy lub masz pomysy na ulepszenia, wejd藕 [kontakt "
"z nami na GitHub](https://github.com/google/comprehensive-rust/discussions). "
"Kochalibymy si usysze od ciebie."

#: src/other-resources.md:1
msgid "Other Rust Resources"
msgstr "Inne 藕r贸da o Rucie"

#: src/other-resources.md:3
#, fuzzy
msgid ""
"The Rust community has created a wealth of high-quality and free resources "
"online."
msgstr ""
"Spoeczno Rust stworzya bogactwo wysokiej jakoci i bezpatnych zasob贸w "
"online."

#: src/other-resources.md:6
#, fuzzy
msgid "Official Documentation"
msgstr "Oficjalna dokumentacja"

#: src/other-resources.md:8
#, fuzzy
msgid "The Rust project hosts many resources. These cover Rust in general:"
msgstr "Projekt Rust zawiera wiele zasob贸w. Obejmuj one og贸lnie Rusta:"

#: src/other-resources.md:10
#, fuzzy
msgid ""
"[The Rust Programming Language](https://doc.rust-lang.org/book/): the "
"canonical free book about Rust. Covers the language in detail and includes a "
"few projects for people to build."
msgstr ""
"[Jzyk programowania Rust](https://doc.rust-lang.org/book/): the kanoniczna "
"darmowa ksi偶ka o Rust. Szczeg贸owo omawia jzyk i zawiera m.in kilka "
"projekt贸w dla ludzi do zbudowania."

#: src/other-resources.md:13
#, fuzzy
msgid ""
"[Rust By Example](https://doc.rust-lang.org/rust-by-example/): covers the "
"Rust syntax via a series of examples which showcase different constructs. "
"Sometimes includes small exercises where you are asked to expand on the code "
"in the examples."
msgstr ""
"[Rust By Example](https://doc.rust-lang.org/rust-by-example/): obejmuje Rust "
"skadni za pomoc serii przykad贸w prezentujcych r贸偶ne konstrukcje. Czasami "
"zawiera mae wiczenia, w kt贸rych jeste proszony o rozwinicie kodu w "
"przykady."

#: src/other-resources.md:17
#, fuzzy
msgid ""
"[Rust Standard Library](https://doc.rust-lang.org/std/): full documentation "
"of the standard library for Rust."
msgstr ""
"[Biblioteka standardowa Rust](https://doc.rust-lang.org/std/): pena "
"dokumentacja standardowa biblioteka dla Rusta."

#: src/other-resources.md:19
#, fuzzy
msgid ""
"[The Rust Reference](https://doc.rust-lang.org/reference/): an incomplete "
"book which describes the Rust grammar and memory model."
msgstr ""
"[The Rust Reference](https://doc.rust-lang.org/reference/): niekompletna "
"ksi偶ka kt贸ry opisuje gramatyk i model pamici Rusta."

#: src/other-resources.md:22
#, fuzzy
msgid "More specialized guides hosted on the official Rust site:"
msgstr ""
"Bardziej wyspecjalizowane przewodniki dostpne na oficjalnej stronie Rusta:"

#: src/other-resources.md:24
#, fuzzy
msgid ""
"[The Rustonomicon](https://doc.rust-lang.org/nomicon/): covers unsafe Rust, "
"including working with raw pointers and interfacing with other languages "
"(FFI)."
msgstr ""
"[The Rustonomicon](https://doc.rust-lang.org/nomicon/): obejmuje "
"niebezpieczn Rust, w tym praca z surowymi wska藕nikami i czenie z innymi "
"jzykami (FFI)."

#: src/other-resources.md:27
#, fuzzy
msgid ""
"[Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/): "
"covers the new asynchronous programming model which was introduced after the "
"Rust Book was written."
msgstr ""
"[Programowanie asynchroniczne w Rust](https://rust-lang.github.io/async-"
"book/): obejmuje nowy model programowania asynchronicznego, kt贸ry zosta "
"wprowadzony po Ksiga rdzy zostaa napisana."

#: src/other-resources.md:30
#, fuzzy
msgid ""
"[The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): "
"an introduction to using Rust on embedded devices without an operating "
"system."
msgstr ""
"[The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): "
"wprowadzenie do u偶ywania Rusta na urzdzeniach wbudowanych bez systemu "
"operacyjnego."

#: src/other-resources.md:33
#, fuzzy
msgid "Unofficial Learning Material"
msgstr "Nieoficjalny materia do nauki"

#: src/other-resources.md:35
#, fuzzy
msgid "A small selection of other guides and tutorial for Rust:"
msgstr "Niewielki wyb贸r innych przewodnik贸w i samouczk贸w dotyczcych Rusta:"

#: src/other-resources.md:37
#, fuzzy
msgid ""
"[Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): covers Rust "
"from the perspective of low-level C programmers."
msgstr ""
"[Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): obejmuje "
"Rust z perspektywy niskopoziomowych programist贸w C."

#: src/other-resources.md:39
#, fuzzy
msgid ""
"[Rust for Embedded C Programmers](https://docs.opentitan.org/doc/ug/"
"rust_for_c/): covers Rust from the perspective of developers who write "
"firmware in C."
msgstr ""
"[Rdza dla wbudowanego C Programici](https://docs.opentitan.org/doc/ug/"
"rust_for_c/): obejmuje Rusta z perspektywa programist贸w, kt贸rzy pisz "
"firmware w C."

#: src/other-resources.md:42
#, fuzzy
msgid ""
"[Rust for professionals](https://overexact.com/rust-for-professionals/): "
"covers the syntax of Rust using side-by-side comparisons with other "
"languages such as C, C++, Java, JavaScript, and Python."
msgstr ""
"[Rdza dla profesjonalist贸w](https://overexact.com/rust-for-professionals/): "
"obejmuje skadni jzyka Rust przy u偶yciu por贸wna side-by-side z innymi "
"jzykami takich jak C, C++, Java, JavaScript i Python."

#: src/other-resources.md:45
#, fuzzy
msgid ""
"[Rust on Exercism](https://exercism.org/tracks/rust): 100+ exercises to help "
"you learn Rust."
msgstr ""
"[Rust on Exercism](https://exercism.org/tracks/rust): ponad 100 wicze, "
"kt贸re pomog uczysz si Rusta."

#: src/other-resources.md:47
#, fuzzy
msgid ""
"[Ferrous Teaching Material](https://ferrous-systems.github.io/teaching-"
"material/index.html): a series of small presentations covering both basic "
"and advanced part of the Rust language. Other topics such as WebAssembly, "
"and async/await are also covered."
msgstr ""
"[呕elazne nauczanie Materia](https://ferrous-systems.github.io/teaching-"
"material/index.html): a seria maych prezentacji obejmujcych zar贸wno "
"podstawow, jak i zaawansowan cz Jzyk rdzy. Inne tematy, takie jak "
"WebAssembly i asynchronizacja/oczekiwanie, r贸wnie偶 s pokryty."

#: src/other-resources.md:52
#, fuzzy
msgid ""
"[Beginner's Series to Rust](https://docs.microsoft.com/en-us/shows/beginners-"
"series-to-rust/) and [Take your first steps with Rust](https://docs."
"microsoft.com/en-us/learn/paths/rust-first-steps/): two Rust guides aimed at "
"new developers. The first is a set of 35 videos and the second is a set of "
"11 modules which covers Rust syntax and basic constructs."
msgstr ""
"[Seria dla pocztkujcych do Rust](https://docs.microsoft.com/en-us/shows/"
"beginners-series-to-rust/) i [Zr贸b swoje pierwsze kroki z Rust](https://docs."
"microsoft.com/en-us/learn/paths/rust-first-steps/): dwa Przewodniki Rust "
"skierowane do nowych programist贸w. Pierwszy to zestaw 35 film贸w i drugi to "
"zestaw 11 modu贸w, kt贸ry obejmuje skadni i podstawowe konstrukcje Rusta."

#: src/other-resources.md:58
#, fuzzy
msgid ""
"[Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial."
"github.io/too-many-lists/): in-depth exploration of Rust's memory management "
"rules, through implementing a few different types of list structures."
msgstr ""
"[Naucz si Rust z cakowicie zbyt wieloma linkami Listy](https://rust-"
"unofficial.github.io/too-many-lists/): szczeg贸owe eksploracja regu "
"zarzdzania pamici Rust, poprzez implementacj kilku r贸偶ne rodzaje "
"struktur list."

#: src/other-resources.md:63
#, fuzzy
msgid ""
"Please see the [Little Book of Rust Books](https://lborb.github.io/book/) "
"for even more Rust books."
msgstr ""
"Prosz zapozna si z [Little Book of Rust Books](https://lborb.github.io/"
"book/) jeszcze wicej ksi偶ek Rust."

#: src/credits.md:3
#, fuzzy
msgid ""
"The material here builds on top of the many great sources of Rust "
"documentation. See the page on [other resources](other-resources.md) for a "
"full list of useful resources."
msgstr ""
"Materia tutaj opiera si na wielu wspaniaych 藕r贸dach dokumentacji Rusta. "
"Zobacz stron [inne zasoby](other-resources.md), aby uzyska pen list "
"przydatnych zasoby."

#: src/credits.md:7
#, fuzzy
msgid ""
"The material of Comprehensive Rust is licensed under the terms of the Apache "
"2.0 license, please see [`LICENSE`](../LICENSE) for details."
msgstr ""
"Materia Comprehensive Rust jest objty licencj na warunkach Apache 2.0 "
"licencji, zobacz [`LICENCJA`](../LICENCJA), aby uzyska szczeg贸owe "
"informacje."

#: src/credits.md:10
#, fuzzy
msgid "Rust by Example"
msgstr "Rust by Example"

#: src/credits.md:12
#, fuzzy
msgid ""
"Some examples and exercises have been copied and adapted from [Rust by "
"Example](https://doc.rust-lang.org/rust-by-example/). Please see the "
"`third_party/rust-by-example/` directory for details, including the license "
"terms."
msgstr ""
"Niekt贸re przykady i wiczenia zostay skopiowane i zaadaptowane z [Rust by "
"Przykad](https://doc.rust-lang.org/rust-by-example/). Prosz zobaczy "
"Katalog `third_party/rust-by-example/` zawiera szczeg贸owe informacje, w tym "
"licencj warunki."

#: src/credits.md:17
#, fuzzy
msgid "Rust on Exercism"
msgstr "Rust on Exercism"

#: src/credits.md:19
#, fuzzy
msgid ""
"Some exercises have been copied and adapted from [Rust on Exercism](https://"
"exercism.org/tracks/rust). Please see the `third_party/rust-on-exercism/` "
"directory for details, including the license terms."
msgstr ""
"Niekt贸re wiczenia zostay skopiowane i zaadaptowane z [Rust on wiczenia]"
"(https://exercism.org/tracks/rust). Prosz zobaczy `third_party/rust-on-"
"exercism/`, aby uzyska szczeg贸owe informacje, w tym licencj warunki."

#: src/credits.md:24
#, fuzzy
msgid "CXX"
msgstr "CXX"

#: src/credits.md:26
#, fuzzy
msgid ""
"The [Interoperability with C++](android/interoperability/cpp.md) section "
"uses an image from [CXX](https://cxx.rs/). Please see the `third_party/cxx/` "
"directory for details, including the license terms."
msgstr ""
"Sekcja [Interoperability with C++](android/interoperability/cpp.md) "
"wykorzystuje plik obraz z [CXX](https://cxx.rs/). Zapoznaj si z katalogiem "
"`third_party/cxx/` aby uzyska szczeg贸owe informacje, w tym warunki "
"licencji."

#: src/exercises/solutions.md:3
#, fuzzy
msgid "You will find solutions to the exercises on the following pages."
msgstr "Na kolejnych stronach znajdziesz rozwizania wicze."

#: src/exercises/solutions.md:5
#, fuzzy
msgid ""
"Feel free to ask questions about the solutions [on GitHub](https://github."
"com/google/comprehensive-rust/discussions). Let us know if you have a "
"different or better solution than what is presented here."
msgstr ""
"Zachcamy do zadawania pyta dotyczcych rozwiza [on GitHub](https://"
"github.com/google/comprehensive-rust/discussions). Daj nam zna jeli masz "
"inne lub lepsze rozwizanie ni偶 przedstawione tutaj."

#: src/exercises/solutions.md:10
#, fuzzy
msgid ""
"**Note:** Please ignore the `// ANCHOR: label` and `// ANCHOR_END: label` "
"comments you see in the solutions. They are there to make it possible to re-"
"use parts of the solutions as the exercises."
msgstr ""
"**Uwaga:** prosz zignorowa `// ANCHOR: etykieta` i `// ANCHOR_END: "
"etykieta` komentarze, kt贸re widzisz w rozwizaniach. S po to, aby to "
"umo偶liwi ponownie wykorzystaj czci rozwiza jako wiczenia."

#: src/exercises/day-1/solutions-morning.md:1
#, fuzzy
msgid "Day 1 Morning Exercises"
msgstr "Dzie 1 wiczenia poranne"

#: src/exercises/day-1/solutions-morning.md:5
msgid "([back to exercise](for-loops.md))"
msgstr "([powr贸t do wiczenia](for-loops.md))"

#: src/exercises/day-1/solutions-morning.md:7
#: src/exercises/day-1/solutions-afternoon.md:7
#: src/exercises/day-2/solutions-morning.md:7
#: src/exercises/day-2/solutions-afternoon.md:7
#: src/exercises/day-2/solutions-afternoon.md:102
#: src/exercises/day-3/solutions-morning.md:7
#: src/exercises/day-3/solutions-afternoon.md:7
#: src/exercises/day-4/solutions-morning.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"```"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:22
msgid ""
"// ANCHOR: transpose fn transpose(matrix: \\[\\[i32; 3\\]; 3\\]) -> "
"\\[\\[i32; 3\\]; 3\\] { // ANCHOR_END: transpose let mut result = \\[\\[0; "
"3\\]; 3\\]; for i in 0..3 { for j in 0..3 { result\\[j\\]\\[i\\] = "
"matrix\\[i\\]\\[j\\]; } } return result; }"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:34
msgid ""
"// ANCHOR: pretty_print fn pretty_print(matrix: &\\[\\[i32; 3\\]; 3\\]) { // "
"ANCHOR_END: pretty_print for row in matrix { println!(\"{row:?}\"); } }"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:42
msgid ""
"// ANCHOR: tests \\#\\[test\\] fn test_transpose() { let matrix = "
"\\[ \\[101, 102, 103\\], // \\[201, 202, 203\\], \\[301, 302, 303\\], \\]; "
"let transposed = transpose(matrix); assert_eq!( transposed, \\[ \\[101, 201, "
"301\\], // \\[102, 202, 302\\], \\[103, 203, 303\\], \\] ); } // ANCHOR_END: "
"tests"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:62
msgid ""
"// ANCHOR: main fn main() { let matrix = \\[ \\[101, 102, 103\\], // \\<\\-- "
"the comment makes rustfmt add a newline \\[201, 202, 203\\], \\[301, 302, "
"303\\], \\];"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:77
msgid ""
"```\n"
"### Bonus question\n"
"```"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:80
#, fuzzy
msgid ""
"It requires more advanced concepts. It might seem that we could use a slice-"
"of-slices (`&[&[i32]]`) as the input type to transpose and thus make our "
"function handle any size of matrix. However, this quickly breaks down: the "
"return type cannot be `&[&[i32]]` since it needs to own the data you return."
msgstr ""
"Wymaga bardziej zaawansowanych koncepcji. Mogoby si wydawa, 偶e moglibymy "
"u偶y wycinka plasterk贸w (`&[&[i32]]`) jako typu wejciowego do transpozycji, "
"a tym samym sprawi, by nasza funkcja obsugiwaa dowolny rozmiar macierzy. "
"Jednak to szybko si psuje: zwracany typ nie mo偶e by `&[&[i32]]`, poniewa偶 "
"musi by wacicielem zwracanych danych."

#: src/exercises/day-1/solutions-morning.md:82
#, fuzzy
msgid ""
"You can attempt to use something like `Vec<Vec<i32>>`, but this doesn't work "
"out-of-the-box either: it's hard to convert from `Vec<Vec<i32>>` to "
"`&[&[i32]]` so now you cannot easily use `pretty_print` either."
msgstr ""
"Mo偶esz spr贸bowa u偶y czego takiego jak `Vec<Vec<i32>>`, ale to te偶 nie "
"dziaa od razu po wyjciu z pudeka: trudno jest przekonwertowa z "
"`Vec<Vec<i32>>` na `&[ &[i32]]`, wic teraz nie mo偶esz te偶 atwo u偶ywa "
"`pretty_print`."

#: src/exercises/day-1/solutions-morning.md:84
#, fuzzy
msgid ""
"Once we get to traits and generics, we'll be able to use the [`std::convert::"
"AsRef`](https://doc.rust-lang.org/std/convert/trait.AsRef.html) trait to "
"abstract over anything that can be referenced as a slice."
msgstr ""
"Gdy przejdziemy do cech i typ贸w og贸lnych, bdziemy mogli u偶y cechy [`std::"
"convert::AsRef`](https://doc.rust-lang.org/std/convert/trait.AsRef.html) do "
"abstrakcji na wszystkim, co mo偶na nazwa plasterkiem."

#: src/exercises/day-1/solutions-morning.md:86
msgid ""
"```rust\n"
"use std::convert::AsRef;\n"
"use std::fmt::Debug;\n"
"```"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:90
msgid ""
"fn pretty_print\\<T, Line, Matrix>(matrix: Matrix) where T: Debug, // A line "
"references a slice of items Line: AsRef\\<\\[T\\]\\>, // A matrix references "
"a slice of lines Matrix: AsRef\\<\\[Line\\]\\> { for row in matrix.as_ref() "
"{ println!(\"{:?}\", row.as_ref()); } }"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:103
msgid ""
"fn main() { // &\\[&\\[i32\\]\\] pretty_print(&\\[&\\[1, 2, 3\\], &\\[4, 5, "
"6\\], &\\[7, 8, 9\\]\\]); // \\[\\[&str; 2\\]; 2\\] "
"pretty_print(\\[\\[\"a\", \"b\"\\], \\[\"c\", \"d\"\\]\\]); // Vec\\<Vec"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:108
msgid "\\> pretty_print(vec![vec![1, 2\\], vec![3, 4\\]\\]); }"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:111
msgid ""
"```\n"
"\n"
"# Day 1 Morning Exercises\n"
"\n"
"## Arrays and `for` Loops\n"
"\n"
"([back to exercise](for-loops.md))\n"
"\n"
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: transpose\n"
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    // ANCHOR_END: transpose\n"
"    let mut result = [[0; 3]; 3];\n"
"    for i in 0..3 {\n"
"        for j in 0..3 {\n"
"            result[j][i] = matrix[i][j];\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n"
"// ANCHOR: pretty_print\n"
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    // ANCHOR_END: pretty_print\n"
"    for row in matrix {\n"
"        println!(\"{row:?}\");\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: tests\n"
"#[test]\n"
"fn test_transpose() {\n"
"    let matrix = [\n"
"        [101, 102, 103], //\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"    let transposed = transpose(matrix);\n"
"    assert_eq!(\n"
"        transposed,\n"
"        [\n"
"            [101, 201, 301], //\n"
"            [102, 202, 302],\n"
"            [103, 203, 303],\n"
"        ]\n"
"    );\n"
"}\n"
"// ANCHOR_END: tests\n"
"\n"
"// ANCHOR: main\n"
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"\n"
"    println!(\"matrix:\");\n"
"    pretty_print(&matrix);\n"
"\n"
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:113
#, fuzzy
msgid ""
"In addition, the type itself would not enforce that the child slices are of "
"the same length, so such variable could contain an invalid matrix."
msgstr ""
"Ponadto sam typ nie wymuszaby, aby wycinki potomne byy tej samej dugoci, "
"wic taka zmienna mogaby zawiera nieprawidow macierz."

#: src/exercises/day-1/solutions-afternoon.md:1
#, fuzzy
msgid "Day 1 Afternoon Exercises"
msgstr "Dzie 1 wiczenia popoudniowe"

#: src/exercises/day-1/solutions-afternoon.md:5
msgid "([back to exercise](book-library.md))"
msgstr "([powr贸t do wiczenia](book-library.md))"

#: src/exercises/day-1/solutions-afternoon.md:22
msgid "// ANCHOR: setup struct Library { books: Vec"
msgstr "// ANCHOR: setup struct Library { books: Vec"

#: src/exercises/day-1/solutions-afternoon.md:42
msgid ""
"// This makes it possible to print Book values with {}. impl std::fmt::"
"Display for Book { fn fmt(&self, f: &mut std::fmt::Formatter\\<'\\_\\>) -> "
"std::fmt::Result { write!(f, \"{} ({})\", self.title, self.year) } } // "
"ANCHOR_END: setup"
msgstr ""
"// Umo偶liwia to drukowanie wartoci Book za pomoc {}. impl std::fmt::"
"Display for Book { fn fmt(&self, f: &mut std::fmt::Formatter\\<'\\_\\>) -> "
"std::fmt::Result { write!(f, \"{} ({})\", self.title, self.year) } } // "
"ANCHOR_END: setup"

#: src/exercises/day-1/solutions-afternoon.md:50
msgid ""
"// ANCHOR: Library_new impl Library { fn new() -> Library { // ANCHOR_END: "
"Library_new Library { books: Vec::new() } }"
msgstr ""
"// ANCHOR: Library_new impl Library { fn new() -> Library { // ANCHOR_END: "
"Library_new Library { books: Vec::new() } }"

#: src/exercises/day-1/solutions-afternoon.md:57
msgid ""
"```\n"
"// ANCHOR: Library_len\n"
"//fn len(self) -> usize {\n"
"//    unimplemented!()\n"
"//}\n"
"// ANCHOR_END: Library_len\n"
"fn len(&self) -> usize {\n"
"    self.books.len()\n"
"}\n"
"```"
msgstr ""
"```\n"
"// ANCHOR: Library_len\n"
"//fn len(self) -> usize {\n"
"//    unimplemented!()\n"
"//}\n"
"// ANCHOR_END: Library_len\n"
"fn len(&self) -> usize {\n"
"    self.books.len()\n"
"}\n"
"```"

#: src/exercises/day-1/solutions-afternoon.md:66
msgid ""
"```\n"
"// ANCHOR: Library_is_empty\n"
"//fn is_empty(self) -> bool {\n"
"//    unimplemented!()\n"
"//}\n"
"// ANCHOR_END: Library_is_empty\n"
"fn is_empty(&self) -> bool {\n"
"    self.books.is_empty()\n"
"}\n"
"```"
msgstr ""
"```\n"
"// ANCHOR: Library_is_empty\n"
"//fn is_empty(self) -> bool {\n"
"//    unimplemented!()\n"
"//}\n"
"// ANCHOR_END: Library_is_empty\n"
"fn is_empty(&self) -> bool {\n"
"    self.books.is_empty()\n"
"}\n"
"```"

#: src/exercises/day-1/solutions-afternoon.md:75
msgid ""
"```\n"
"// ANCHOR: Library_add_book\n"
"//fn add_book(self, book: Book) {\n"
"//    unimplemented!()\n"
"//}\n"
"// ANCHOR_END: Library_add_book\n"
"fn add_book(&mut self, book: Book) {\n"
"    self.books.push(book)\n"
"}\n"
"```"
msgstr ""
"```\n"
"// ANCHOR: Library_add_book\n"
"//fn add_book(self, book: Book) {\n"
"//    unimplemented!()\n"
"//}\n"
"// ANCHOR_END: Library_add_book\n"
"fn add_book(&mut self, book: Book) {\n"
"    self.books.push(book)\n"
"}\n"
"```"

#: src/exercises/day-1/solutions-afternoon.md:84
msgid ""
"```\n"
"// ANCHOR: Library_print_books\n"
"//fn print_books(self) {\n"
"//    unimplemented!()\n"
"//}\n"
"// ANCHOR_END: Library_print_books\n"
"fn print_books(&self) {\n"
"    for book in &self.books {\n"
"        println!(\"{}\", book);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```\n"
"// ANCHOR: Library_print_books\n"
"//fn print_books(self) {\n"
"//    unimplemented!()\n"
"//}\n"
"// ANCHOR_END: Library_print_books\n"
"fn print_books(&self) {\n"
"    for book in &self.books {\n"
"        println!(\"{}\", book);\n"
"    }\n"
"}\n"
"```"

#: src/exercises/day-1/solutions-afternoon.md:95
msgid ""
"```\n"
"// ANCHOR: Library_oldest_book\n"
"//fn oldest_book(self) -> Option<&Book> {\n"
"//    unimplemented!()\n"
"//}\n"
"// ANCHOR_END: Library_oldest_book\n"
"fn oldest_book(&self) -> Option<&Book> {\n"
"    self.books.iter().min_by_key(|book| book.year)\n"
"}\n"
"```"
msgstr ""
"```\n"
"// ANCHOR: Library_oldest_book\n"
"//fn oldest_book(self) -> Option<&Book> {\n"
"//    unimplemented!()\n"
"//}\n"
"// ANCHOR_END: Library_oldest_book\n"
"fn oldest_book(&self) -> Option<&Book> {\n"
"    self.books.iter().min_by_key(|book| book.year)\n"
"}\n"
"```"

#: src/exercises/day-1/solutions-afternoon.md:105
msgid ""
"// ANCHOR: main // This shows the desired behavior. Uncomment the code below "
"and // implement the missing methods. You will need to update the // method "
"signatures, including the \"self\" parameter! You may // also need to update "
"the variable bindings within main. fn main() { let library = Library::new();"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:126
msgid "} // ANCHOR_END: main"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:129
msgid ""
"\\#\\[test\\] fn test_library_len() { let mut library = Library::new(); "
"assert_eq!(library.len(), 0); assert!(library.is_empty());"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:135
msgid ""
"```\n"
"library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"assert_eq!(library.len(), 2);\n"
"assert!(!library.is_empty());\n"
"```"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:141
msgid ""
"\\#\\[test\\] fn test_library_is_empty() { let mut library = Library::new(); "
"assert!(library.is_empty());"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:146
msgid ""
"```\n"
"library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"assert!(!library.is_empty());\n"
"```"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:150
msgid ""
"\\#\\[test\\] fn test_library_print_books() { let mut library = Library::"
"new(); library.add_book(Book::new(\"Lord of the Rings\", 1954)); library."
"add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865)); // We could "
"try and capture stdout, but let us just call the // method to start with. "
"library.print_books(); }"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:160
msgid ""
"\\#\\[test\\] fn test_library_oldest_book() { let mut library = Library::"
"new(); assert!(library.oldest_book().is_none());"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:165
msgid ""
"```\n"
"library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"assert_eq!(\n"
"    library.oldest_book().map(|b| b.title.as_str()),\n"
"    Some(\"Lord of the Rings\")\n"
");\n"
"```"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:171
msgid ""
"```\n"
"library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"assert_eq!(\n"
"    library.oldest_book().map(|b| b.title.as_str()),\n"
"    Some(\"Alice's Adventures in Wonderland\")\n"
");\n"
"```"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:1
#, fuzzy
msgid "Day 2 Morning Exercises"
msgstr "Dzie 2 wiczenia poranne"

#: src/exercises/day-2/solutions-morning.md:5
msgid "([back to exercise](points-polygons.md))"
msgstr "([powr贸t do wiczenia](points-polygons.md))"

#: src/exercises/day-2/solutions-morning.md:22
msgid ""
"\\#\\[derive(Debug, Copy, Clone, PartialEq, Eq)\\] // ANCHOR: Point pub "
"struct Point { // ANCHOR_END: Point x: i32, y: i32, }"
msgstr ""
"\\#\\[derive(Debug, Copy, Clone, PartialEq, Eq)\\] // ANCHOR: Point pub "
"struct Point { // ANCHOR_END: Point x: i32, y: i32, }"

#: src/exercises/day-2/solutions-morning.md:30
msgid ""
"// ANCHOR: Point-impl impl Point { // ANCHOR_END: Point-impl pub fn new(x: "
"i32, y: i32) -> Point { Point { x, y } }"
msgstr ""
"// ANCHOR: Point-impl impl Point { // ANCHOR_END: Point-impl pub fn new(x: "
"i32, y: i32) -> Point { Point { x, y } }"

#: src/exercises/day-2/solutions-morning.md:37
msgid ""
"```\n"
"pub fn magnitude(self) -> f64 {\n"
"    f64::from(self.x.pow(2) + self.y.pow(2)).sqrt()\n"
"}\n"
"```"
msgstr ""
"```\n"
"pub fn magnitude(self) -> f64 {\n"
"    f64::from(self.x.pow(2) + self.y.pow(2)).sqrt()\n"
"}\n"
"```"

#: src/exercises/day-2/solutions-morning.md:41
msgid ""
"```\n"
"pub fn dist(self, other: Point) -> f64 {\n"
"    (self - other).magnitude()\n"
"}\n"
"```"
msgstr ""
"```\n"
"pub fn dist(self, other: Point) -> f64 {\n"
"    (self - other).magnitude()\n"
"}\n"
"```"

#: src/exercises/day-2/solutions-morning.md:49
msgid ""
"```\n"
"fn add(self, other: Self) -> Self::Output {\n"
"    Self {\n"
"        x: self.x + other.x,\n"
"        y: self.y + other.y,\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```\n"
"fn add(self, other: Self) -> Self::Output {\n"
"    Self {\n"
"        x: self.x + other.x,\n"
"        y: self.y + other.y,\n"
"    }\n"
"}\n"
"```"

#: src/exercises/day-2/solutions-morning.md:57
msgid "impl std::ops::Sub for Point { type Output = Self;"
msgstr "impl std::ops::Sub for Point { type Output = Self;"

#: src/exercises/day-2/solutions-morning.md:60
msgid ""
"```\n"
"fn sub(self, other: Self) -> Self::Output {\n"
"    Self {\n"
"        x: self.x - other.x,\n"
"        y: self.y - other.y,\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```\n"
"fn sub(self, other: Self) -> Self::Output {\n"
"    Self {\n"
"        x: self.x - other.x,\n"
"        y: self.y - other.y,\n"
"    }\n"
"}\n"
"```"

#: src/exercises/day-2/solutions-morning.md:68
msgid ""
"// ANCHOR: Polygon pub struct Polygon { // ANCHOR_END: Polygon points: Vec"
msgstr ""
"// ANCHOR: Polygon pub struct Polygon { // ANCHOR_END: Polygon points: Vec"

#: src/exercises/day-2/solutions-morning.md:74
msgid ""
"// ANCHOR: Polygon-impl impl Polygon { // ANCHOR_END: Polygon-impl pub fn "
"new() -> Polygon { Polygon { points: Vec::new() } }"
msgstr ""
"// ANCHOR: Polygon-impl impl Polygon { // ANCHOR_END: Polygon-impl pub fn "
"new() -> Polygon { Polygon { points: Vec::new() } }"

#: src/exercises/day-2/solutions-morning.md:81
msgid ""
"```\n"
"pub fn add_point(&mut self, point: Point) {\n"
"    self.points.push(point);\n"
"}\n"
"```"
msgstr ""
"```\n"
"pub fn add_point(&mut self, point: Point) {\n"
"    self.points.push(point);\n"
"}\n"
"```"

#: src/exercises/day-2/solutions-morning.md:85
msgid ""
"```\n"
"pub fn left_most_point(&self) -> Option<Point> {\n"
"    self.points.iter().min_by_key(|p| p.x).copied()\n"
"}\n"
"```"
msgstr ""
"```\n"
"pub fn left_most_point(&self) -> Option<Point> {\n"
"    self.points.iter().min_by_key(|p| p.x).copied()\n"
"}\n"
"```"

#: src/exercises/day-2/solutions-morning.md:89
msgid ""
"```\n"
"pub fn iter(&self) -> impl Iterator<Item = &Point> {\n"
"    self.points.iter()\n"
"}\n"
"```"
msgstr ""
"```\n"
"pub fn iter(&self) -> impl Iterator<Item = &Point> {\n"
"    self.points.iter()\n"
"}\n"
"```"

#: src/exercises/day-2/solutions-morning.md:93
msgid ""
"```\n"
"pub fn length(&self) -> f64 {\n"
"    if self.points.is_empty() {\n"
"        return 0.0;\n"
"    }\n"
"```"
msgstr ""
"```\n"
"pub fn length(&self) -> f64 {\n"
"    if self.points.is_empty() {\n"
"        return 0.0;\n"
"    }\n"
"```"

#: src/exercises/day-2/solutions-morning.md:98
msgid ""
"```\n"
"    let mut result = 0.0;\n"
"    let mut last_point = self.points[0];\n"
"    for point in &self.points[1..] {\n"
"        result += last_point.dist(*point);\n"
"        last_point = *point;\n"
"    }\n"
"    result += last_point.dist(self.points[0]);\n"
"    result\n"
"}\n"
"```"
msgstr ""
"```\n"
"    let mut result = 0.0;\n"
"    let mut last_point = self.points[0];\n"
"    for point in &self.points[1..] {\n"
"        result += last_point.dist(*point);\n"
"        last_point = *point;\n"
"    }\n"
"    result += last_point.dist(self.points[0]);\n"
"    result\n"
"}\n"
"```"

#: src/exercises/day-2/solutions-morning.md:109
msgid ""
"// ANCHOR: Circle pub struct Circle { // ANCHOR_END: Circle center: Point, "
"radius: i32, }"
msgstr ""
"// ANCHOR: Circle pub struct Circle { // ANCHOR_END: Circle center: Point, "
"radius: i32, }"

#: src/exercises/day-2/solutions-morning.md:116
msgid ""
"// ANCHOR: Circle-impl impl Circle { // ANCHOR_END: Circle-impl pub fn "
"new(center: Point, radius: i32) -> Circle { Circle { center, radius } }"
msgstr ""
"// ANCHOR: Circle-impl impl Circle { // ANCHOR_END: Circle-impl pub fn "
"new(center: Point, radius: i32) -> Circle { Circle { center, radius } }"

#: src/exercises/day-2/solutions-morning.md:123
msgid ""
"```\n"
"pub fn circumference(&self) -> f64 {\n"
"    2.0 * std::f64::consts::PI * f64::from(self.radius)\n"
"}\n"
"```"
msgstr ""
"```\n"
"pub fn circumference(&self) -> f64 {\n"
"    2.0 * std::f64::consts::PI * f64::from(self.radius)\n"
"}\n"
"```"

#: src/exercises/day-2/solutions-morning.md:127
msgid ""
"```\n"
"pub fn dist(&self, other: &Self) -> f64 {\n"
"    self.center.dist(other.center)\n"
"}\n"
"```"
msgstr ""
"```\n"
"pub fn dist(&self, other: &Self) -> f64 {\n"
"    self.center.dist(other.center)\n"
"}\n"
"```"

#: src/exercises/day-2/solutions-morning.md:132
msgid ""
"// ANCHOR: Shape pub enum Shape { Polygon(Polygon), Circle(Circle), } // "
"ANCHOR_END: Shape"
msgstr ""
"// ANCHOR: Shape pub enum Shape { Polygon(Polygon), Circle(Circle), } // "
"ANCHOR_END: Shape"

#: src/exercises/day-2/solutions-morning.md:139
#: src/exercises/day-2/solutions-morning.md:145
msgid "impl From"
msgstr "impl From"

#: src/exercises/day-2/solutions-morning.md:139
msgid " for Shape { fn from(poly: Polygon) -> Self { Shape::Polygon(poly) } }"
msgstr " for Shape { fn from(poly: Polygon) -> Self { Shape::Polygon(poly) } }"

#: src/exercises/day-2/solutions-morning.md:145
msgid ""
" for Shape { fn from(circle: Circle) -> Self { Shape::Circle(circle) } }"
msgstr ""
" for Shape { fn from(circle: Circle) -> Self { Shape::Circle(circle) } }"

#: src/exercises/day-2/solutions-morning.md:151
msgid ""
"impl Shape { pub fn perimeter(&self) -> f64 { match self { Shape::"
"Polygon(poly) => poly.length(), Shape::Circle(circle) => circle."
"circumference(), } } }"
msgstr ""
"impl Shape { pub fn perimeter(&self) -> f64 { match self { Shape::"
"Polygon(poly) => poly.length(), Shape::Circle(circle) => circle."
"circumference(), } } }"

#: src/exercises/day-2/solutions-morning.md:160
msgid "// ANCHOR: unit-tests \\#\\[cfg(test)\\] mod tests { use super::\\*;"
msgstr "// ANCHOR: unit-tests \\#\\[cfg(test)\\] mod tests { use super::\\*;"

#: src/exercises/day-2/solutions-morning.md:230
#: src/exercises/day-2/solutions-afternoon.md:171
msgid "} // ANCHOR_END: unit-tests"
msgstr "} // ANCHOR_END: unit-tests"

#: src/exercises/day-2/solutions-morning.md:233
#: src/exercises/day-2/solutions-afternoon.md:174
msgid "fn main() {}"
msgstr "fn main() {}"

#: src/exercises/day-2/solutions-afternoon.md:1
#, fuzzy
msgid "Day 2 Afternoon Exercises"
msgstr "Dzie 2 wiczenia popoudniowe"

#: src/exercises/day-2/solutions-afternoon.md:5
msgid "([back to exercise](luhn.md))"
msgstr "([powr贸t do wiczenia](luhn.md))"

#: src/exercises/day-2/solutions-afternoon.md:22
msgid ""
"// ANCHOR: luhn pub fn luhn(cc_number: &str) -> bool { // ANCHOR_END: luhn "
"let mut digits_seen = 0; let mut sum = 0; for (i, ch) in cc_number.chars()."
"rev().filter(|&ch| ch != ' ').enumerate() { match ch.to_digit(10) { Some(d) "
"=> { sum += if i % 2 == 1 { let dd = d * 2; dd / 10 + dd % 10 } else { d }; "
"digits_seen += 1; } None => return false, } }"
msgstr ""
"// ANCHOR: luhn pub fn luhn(cc_number: &str) -> bool { // ANCHOR_END: luhn "
"let mut digits_seen = 0; let mut sum = 0; for (i, ch) in cc_number.chars()."
"rev().filter(|&ch| ch != ' ').enumerate() { match ch.to_digit(10) { Some(d) "
"=> { sum += if i % 2 == 1 { let dd = d * 2; dd / 10 + dd % 10 } else { d }; "
"digits_seen += 1; } None => return false, } }"

#: src/exercises/day-2/solutions-afternoon.md:42
msgid ""
"```\n"
"if digits_seen < 2 {\n"
"    return false;\n"
"}\n"
"```"
msgstr ""
"```\n"
"if digits_seen < 2 {\n"
"    return false;\n"
"}\n"
"```"

#: src/exercises/day-2/solutions-afternoon.md:46
msgid ""
"```\n"
"sum % 10 == 0\n"
"```"
msgstr ""
"```\n"
"sum % 10 == 0\n"
"```"

#: src/exercises/day-2/solutions-afternoon.md:49
msgid ""
"fn main() { let cc_number = \"1234 5678 1234 5670\"; println!( \"Is {} a "
"valid credit card number? {}\", cc_number, if luhn(cc_number) { \"yes\" } "
"else { \"no\" } ); }"
msgstr ""
"fn main() { let cc_number = \"1234 5678 1234 5670\"; println!( \"Czy {} to "
"prawidowy numer karty kredytowej? {}\", cc_number, if luhn(cc_number) "
"{ \"tak\" } else { \"nie\" } ); }"

#: src/exercises/day-2/solutions-afternoon.md:58
msgid ""
"// ANCHOR: unit-tests \\#\\[test\\] fn test_non_digit_cc_number() { assert!(!"
"luhn(\"foo\")); }"
msgstr ""
"// ANCHOR: unit-tests \\#\\[test\\] fn test_non_digit_cc_number() { assert!(!"
"luhn(\"foo\")); }"

#: src/exercises/day-2/solutions-afternoon.md:89
msgid ""
"\\#\\[test\\] fn test_invalid_cc_number() { assert!(!luhn(\"4223 9826 4026 "
"9299\")); assert!(!luhn(\"4539 3195 0343 6476\")); assert!(!luhn(\"8273 1232 "
"7352 0569\")); } // ANCHOR_END: unit-tests"
msgstr ""
"\\#\\[test\\] fn test_invalid_cc_number() { assert!(!luhn(\"4223 9826 4026 "
"9299\")); assert!(!luhn(\"4539 3195 0343 6476\")); assert!(!luhn(\"8273 1232 "
"7352 0569\")); } // ANCHOR_END: unit-tests"

#: src/exercises/day-2/solutions-afternoon.md:96
msgid ""
"```\n"
"\n"
"# Day 2 Afternoon Exercises\n"
"\n"
"## Luhn Algorithm\n"
"\n"
"([back to exercise](luhn.md))\n"
"\n"
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: luhn\n"
"pub fn luhn(cc_number: &str) -> bool {\n"
"    // ANCHOR_END: luhn\n"
"    let mut digits_seen = 0;\n"
"    let mut sum = 0;\n"
"    for (i, ch) in cc_number.chars().rev().filter(|&ch| ch != ' ')."
"enumerate() {\n"
"        match ch.to_digit(10) {\n"
"            Some(d) => {\n"
"                sum += if i % 2 == 1 {\n"
"                    let dd = d * 2;\n"
"                    dd / 10 + dd % 10\n"
"                } else {\n"
"                    d\n"
"                };\n"
"                digits_seen += 1;\n"
"            }\n"
"            None => return false,\n"
"        }\n"
"    }\n"
"\n"
"    if digits_seen < 2 {\n"
"        return false;\n"
"    }\n"
"\n"
"    sum % 10 == 0\n"
"}\n"
"\n"
"fn main() {\n"
"    let cc_number = \"1234 5678 1234 5670\";\n"
"    println!(\n"
"        \"Is {} a valid credit card number? {}\",\n"
"        cc_number,\n"
"        if luhn(cc_number) { \"yes\" } else { \"no\" }\n"
"    );\n"
"}\n"
"\n"
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_empty_cc_number() {\n"
"    assert!(!luhn(\"\"));\n"
"    assert!(!luhn(\" \"));\n"
"    assert!(!luhn(\"  \"));\n"
"    assert!(!luhn(\"    \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_single_digit_cc_number() {\n"
"    assert!(!luhn(\"0\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_two_digit_cc_number() {\n"
"    assert!(luhn(\" 0 0 \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_valid_cc_number() {\n"
"    assert!(luhn(\"4263 9826 4026 9299\"));\n"
"    assert!(luhn(\"4539 3195 0343 6467\"));\n"
"    assert!(luhn(\"7992 7398 713\"));\n"
"}\n"
"\n"
"## Strings and Iterators\n"
"\n"
"([back to exercise](strings-iterators.md))\n"
"\n"
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: prefix_matches\n"
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    // ANCHOR_END: prefix_matches\n"
"    let prefixes = prefix.split('/');\n"
"    let request_paths = request_path\n"
"        .split('/')\n"
"        .map(|p| Some(p))\n"
"        .chain(std::iter::once(None));\n"
"\n"
"    for (prefix, request_path) in prefixes.zip(request_paths) {\n"
"        match request_path {\n"
"            Some(request_path) => {\n"
"                if (prefix != \"*\") && (prefix != request_path) {\n"
"                    return false;\n"
"                }\n"
"            }\n"
"            None => return false,\n"
"        }\n"
"    }\n"
"    true\n"
"}\n"
"\n"
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/"
"abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/"
"books\"));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/publishersBooks\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/parent/"
"publishers\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_matches_with_wildcard() {\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/bar/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books/book1\"\n"
"    ));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/"
"publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"// ANCHOR_END: unit-tests\n"
"\n"
"fn main() {}\n"
"```"
msgstr ""
"```\n"
"\n"
"# Dzie 2 wiczenia popoudniowe\n"
"\n"
"## Algorytm Luhna\n"
"\n"
"([powr贸t do wiczenia](luhn.md))\n"
"\n"
"\n"
"\n"
"// ANCHOR: luhn\n"
"pub fn luhn(cc_number: &str) -> bool {\n"
"    // ANCHOR_END: luhn\n"
"    let mut digits_seen = 0;\n"
"    let mut sum = 0;\n"
"    for (i, ch) in cc_number.chars().rev().filter(|&ch| ch != ' ')."
"enumerate() {\n"
"        match ch.to_digit(10) {\n"
"            Some(d) => {\n"
"                sum += if i % 2 == 1 {\n"
"                    let dd = d * 2;\n"
"                    dd / 10 + dd % 10\n"
"                } else {\n"
"                    d\n"
"                };\n"
"                digits_seen += 1;\n"
"            }\n"
"            None => return false,\n"
"        }\n"
"    }\n"
"\n"
"    if digits_seen < 2 {\n"
"        return false;\n"
"    }\n"
"\n"
"    sum % 10 == 0\n"
"}\n"
"\n"
"fn main() {\n"
"    let cc_number = \"1234 5678 1234 5670\";\n"
"    println!(\n"
"        \"Czy {} to prawidowy numer karty kredytowej? {}\",\n"
"        cc_number,\n"
"        if luhn(cc_number) { \"tak\" } else { \"nie\" }\n"
"    );\n"
"}\n"
"\n"
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\"));\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"## acuchy i iteratory\n"
"\n"
"([powr贸t do wiczenia](strings-iterators.md))\n"
"\n"
"\n"
"\n"
"// ANCHOR: prefix_matches\n"
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    // ANCHOR_END: prefix_matches\n"
"    let prefixes = prefix.split('/');\n"
"    let request_paths = request_path\n"
"        .split('/')\n"
"        .map(|p| Some(p))\n"
"        .chain(std::iter::once(None));\n"
"\n"
"    for (prefix, request_path) in prefixes.zip(request_paths) {\n"
"        match request_path {\n"
"            Some(request_path) => {\n"
"                if (prefix != \"*\") && (prefix != request_path) {\n"
"                    return false;\n"
"                }\n"
"            }\n"
"            None => return false,\n"
"        }\n"
"    }\n"
"    true\n"
"}\n"
"\n"
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/"
"abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/"
"books\"));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/publishersBooks\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/parent/"
"publishers\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_matches_with_wildcard() {\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/bar/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books/book1\"\n"
"    ));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/"
"publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"// ANCHOR_END: unit-tests\n"
"\n"
"fn main() {}\n"
"```"

#: src/exercises/day-2/solutions-afternoon.md:100
msgid "([back to exercise](strings-iterators.md))"
msgstr "([powr贸t do wiczenia](strings-iterators.md))"

#: src/exercises/day-2/solutions-afternoon.md:117
msgid ""
"// ANCHOR: prefix_matches pub fn prefix_matches(prefix: &str, request_path: "
"&str) -> bool { // ANCHOR_END: prefix_matches let prefixes = prefix."
"split('/'); let request_paths = request_path .split('/') .map(|p| Some(p)) ."
"chain(std::iter::once(None));"
msgstr ""
"// ANCHOR: prefix_matches pub fn prefix_matches(prefix: &str, request_path: "
"&str) -> bool { // ANCHOR_END: prefix_matches let prefixes = prefix."
"split('/'); let request_paths = request_path .split('/') .map(|p| Some(p)) ."
"chain(std::iter::once(None));"

#: src/exercises/day-2/solutions-afternoon.md:126
msgid ""
"```\n"
"for (prefix, request_path) in prefixes.zip(request_paths) {\n"
"    match request_path {\n"
"        Some(request_path) => {\n"
"            if (prefix != \"*\") && (prefix != request_path) {\n"
"                return false;\n"
"            }\n"
"        }\n"
"        None => return false,\n"
"    }\n"
"}\n"
"true\n"
"```"
msgstr ""
"```\n"
"for (prefix, request_path) in prefixes.zip(request_paths) {\n"
"    match request_path {\n"
"        Some(request_path) => {\n"
"            if (prefix != \"*\") && (prefix != request_path) {\n"
"                return false;\n"
"            }\n"
"        }\n"
"        None => return false,\n"
"    }\n"
"}\n"
"true\n"
"```"

#: src/exercises/day-2/solutions-afternoon.md:139
msgid ""
"// ANCHOR: unit-tests \\#\\[test\\] fn test_matches_without_wildcard() "
"{ assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\")); assert!"
"(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc-123\")); assert!"
"(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/books\"));"
msgstr ""
"// ANCHOR: unit-tests \\#\\[test\\] fn test_matches_without_wildcard() "
"{ assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\")); assert!"
"(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc-123\")); assert!"
"(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/books\"));"

#: src/exercises/day-3/solutions-morning.md:1
#, fuzzy
msgid "Day 3 Morning Exercise"
msgstr "Dzie 3 Poranna gimnastyka"

#: src/exercises/day-3/solutions-morning.md:5
msgid "([back to exercise](simple-gui.md))"
msgstr "([powr贸t do wiczenia](simple-gui.md))"

#: src/exercises/day-3/solutions-morning.md:22
msgid ""
"// ANCHOR: setup pub trait Widget { /// Natural width of `self`. fn "
"width(&self) -> usize;"
msgstr ""
"// ANCHOR: setup pub trait Widget { /// Naturalna szeroko `self`. fn "
"width(&self) -> usize;"

#: src/exercises/day-3/solutions-morning.md:82
msgid "// ANCHOR_END: setup"
msgstr "// ANCHOR_END: setup"

#: src/exercises/day-3/solutions-morning.md:84
msgid ""
"// ANCHOR: Window-width impl Widget for Window { fn width(&self) -> usize "
"{ // ANCHOR_END: Window-width std::cmp::max( self.title.chars().count(), "
"self.widgets.iter().map(|w| w.width()).max().unwrap_or(0), ) }"
msgstr ""
"// ANCHOR: Window-width impl Widget for Window { fn width(&self) -> usize "
"{ // ANCHOR_END: Window-width std::cmp::max( self.title.chars().count(), "
"self.widgets.iter().map(|w| w.width()).max().unwrap_or(0), ) }"

#: src/exercises/day-3/solutions-morning.md:94
msgid ""
"```\n"
"// ANCHOR: Window-draw_into\n"
"fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"    // ANCHOR_END: Window-draw_into\n"
"    let mut inner = String::new();\n"
"    for widget in &self.widgets {\n"
"        widget.draw_into(&mut inner);\n"
"    }\n"
"```"
msgstr ""
"```\n"
"// ANCHOR: Window-draw_into\n"
"fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"    // ANCHOR_END: Window-draw_into\n"
"    let mut inner = String::new();\n"
"    for widget in &self.widgets {\n"
"        widget.draw_into(&mut inner);\n"
"    }\n"
"```"

#: src/exercises/day-3/solutions-morning.md:102
msgid ""
"```\n"
"    let window_width = self.width();\n"
"```"
msgstr ""
"```\n"
"    let window_width = self.width();\n"
"```"

#: src/exercises/day-3/solutions-morning.md:104
msgid ""
"```\n"
"    // TODO: after learning about error handling, you can change\n"
"    // draw_into to return Result<(), std::fmt::Error>. Then use\n"
"    // the ?-operator here instead of .unwrap().\n"
"    writeln!(buffer, \"+-{:-<window_width$}-+\", \"\").unwrap();\n"
"    writeln!(buffer, \"| {:^window_width$} |\", &self.title).unwrap();\n"
"    writeln!(buffer, \"+={:=<window_width$}=+\", \"\").unwrap();\n"
"    for line in inner.lines() {\n"
"        writeln!(buffer, \"| {:window_width$} |\", line).unwrap();\n"
"    }\n"
"    writeln!(buffer, \"+-{:-<window_width$}-+\", \"\").unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:117
msgid ""
"// ANCHOR: Button-width impl Widget for Button { fn width(&self) -> usize "
"{ // ANCHOR_END: Button-width self.label.width() + 8 // add a bit of "
"padding }"
msgstr ""
"// ANCHOR: Button-width impl Widget for Button { fn width(&self) -> usize "
"{ // ANCHOR_END: Button-width self.label.width() + 8 // dodaj troch "
"wypenienia }"

#: src/exercises/day-3/solutions-morning.md:124
msgid ""
"```\n"
"// ANCHOR: Button-draw_into\n"
"fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"    // ANCHOR_END: Button-draw_into\n"
"    let width = self.width();\n"
"    let mut label = String::new();\n"
"    self.label.draw_into(&mut label);\n"
"```"
msgstr ""
"```\n"
"// ANCHOR: Button-draw_into\n"
"fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"    // ANCHOR_END: Button-draw_into\n"
"    let width = self.width();\n"
"    let mut label = String::new();\n"
"    self.label.draw_into(&mut label);\n"
"```"

#: src/exercises/day-3/solutions-morning.md:131
msgid ""
"```\n"
"    writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"    for line in label.lines() {\n"
"        writeln!(buffer, \"|{:^width$}|\", &line).unwrap();\n"
"    }\n"
"    writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"}\n"
"```"
msgstr ""
"```\n"
"    writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"    for line in label.lines() {\n"
"        writeln!(buffer, \"|{:^width$}|\", &line).unwrap();\n"
"    }\n"
"    writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"}\n"
"```"

#: src/exercises/day-3/solutions-morning.md:139
msgid ""
"// ANCHOR: Label-width impl Widget for Label { fn width(&self) -> usize { // "
"ANCHOR_END: Label-width self.label .lines() .map(|line| line.chars()."
"count()) .max() .unwrap_or(0) }"
msgstr ""
"// ANCHOR: Label-width impl Widget for Label { fn width(&self) -> usize { // "
"ANCHOR_END: Label-width self.label .lines() .map(|line| line.chars()."
"count()) .max() .unwrap_or(0) }"

#: src/exercises/day-3/solutions-morning.md:150
msgid ""
"```\n"
"// ANCHOR: Label-draw_into\n"
"fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"    // ANCHOR_END: Label-draw_into\n"
"    writeln!(buffer, \"{}\", &self.label).unwrap();\n"
"}\n"
"```"
msgstr ""
"```\n"
"// ANCHOR: Label-draw_into\n"
"fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"    // ANCHOR_END: Label-draw_into\n"
"    writeln!(buffer, \"{}\", &self.label).unwrap();\n"
"}\n"
"```"

#: src/exercises/day-3/solutions-morning.md:157
msgid ""
"// ANCHOR: main fn main() { let mut window = Window::new(\"Rust GUI Demo "
"1.23\"); window.add_widget(Box::new(Label::new(\"This is a small text GUI "
"demo.\"))); window.add_widget(Box::new(Button::new( \"Click me!\", Box::"
"new(|| println!(\"You clicked the button!\")), ))); window.draw(); } // "
"ANCHOR_END: main"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:1
#, fuzzy
msgid "Day 3 Afternoon Exercises"
msgstr "Dzie 3 wiczenia popoudniowe"

#: src/exercises/day-3/solutions-afternoon.md:5
msgid "([back to exercise](safe-ffi-wrapper.md))"
msgstr "([powr贸t do wiczenia](safe-ffi-wrapper.md))"

#: src/exercises/day-3/solutions-afternoon.md:22
msgid ""
"// ANCHOR: ffi mod ffi { use std::os::raw::{c_char, c_int, c_long, c_ulong, "
"c_ushort};"
msgstr ""
"// ANCHOR: ffi mod ffi { use std::os::raw::{c_char, c_int, c_long, c_ulong, "
"c_ushort};"

#: src/exercises/day-3/solutions-afternoon.md:53
msgid ""
"\\#\\[derive(Debug)\\] struct DirectoryIterator { path: CString, dir: \\*mut "
"ffi::DIR, } // ANCHOR_END: ffi"
msgstr ""
"\\#\\[derive(Debug)\\] struct DirectoryIterator { path: CString, dir: \\*mut "
"ffi::DIR, } // ANCHOR_END: ffi"

#: src/exercises/day-3/solutions-afternoon.md:60
msgid ""
"// ANCHOR: DirectoryIterator impl DirectoryIterator { fn new(path: &str) -> "
"Result\\<DirectoryIterator, String> { // Call opendir and return a Ok value "
"if that worked, // otherwise return Err with a message. // ANCHOR_END: "
"DirectoryIterator let path = CString::new(path).map_err(|err| format!"
"(\"Invalid path: {err}\"))?; // SAFETY: path.as_ptr() cannot be NULL. let "
"dir = unsafe { ffi::opendir(path.as_ptr()) }; if dir.is_null() { Err(format!"
"(\"Could not open {:?}\", path)) } else { Ok(DirectoryIterator { path, "
"dir }) } } }"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:77
msgid ""
"// ANCHOR: Iterator impl Iterator for DirectoryIterator { type Item = "
"OsString; fn next(&mut self) -> Option"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:80
msgid ""
" { // Keep calling readdir until we get a NULL pointer back. // ANCHOR_END: "
"Iterator // SAFETY: self.dir is never NULL. let dirent = unsafe { ffi::"
"readdir(self.dir) }; if dirent.is_null() { // We have reached the end of the "
"directory. return None; } // SAFETY: dirent is not NULL and dirent.d_name is "
"NUL // terminated. let d_name = unsafe { CStr::from_ptr((\\*dirent).d_name."
"as_ptr()) }; let os_str = OsStr::from_bytes(d_name.to_bytes()); Some(os_str."
"to_owned()) } }"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:97
msgid ""
"// ANCHOR: Drop impl Drop for DirectoryIterator { fn drop(&mut self) { // "
"Call closedir as needed. // ANCHOR_END: Drop if !self.dir.is_null() { // "
"SAFETY: self.dir is not NULL. if unsafe { ffi::closedir(self.dir) } != 0 "
"{ panic!(\"Could not close {:?}\", self.path); } } } }"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:111
msgid ""
"// ANCHOR: main fn main() -> Result\\<(), String> { let iter = "
"DirectoryIterator::new(\".\")?; println!(\"files: {:#?}\", iter.collect::"
"\\<Vec\\<\\_\\>>()); Ok(()) } // ANCHOR_END: main"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:1
#, fuzzy
msgid "Day 4 Morning Exercise"
msgstr "Dzie 4 Poranna gimnastyka"

#: src/exercises/day-4/solutions-morning.md:5
msgid "([back to exercise](dining-philosophers.md))"
msgstr "([powr贸t do wiczenia](dining-philosophers.md))"

#: src/exercises/day-4/solutions-morning.md:22
msgid ""
"// ANCHOR: Philosopher use std::sync::mpsc; use std::sync::{Arc, Mutex}; use "
"std::thread; use std::time::Duration;"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:30
#, fuzzy
msgid ""
"struct Philosopher { name: String, // ANCHOR_END: Philosopher left_fork: "
"Arc\\<Mutex"
msgstr ""
"struktura Filozof { imi: Cig, // ANCHOR_END: Filozof left_fork: Arc\\<Mutex"

#: src/exercises/day-4/solutions-morning.md:33
#, fuzzy
msgid "\\>, right_fork: Arc\\<Mutex"
msgstr "\\>, right_fork: Arc\\<Mutex"

#: src/exercises/day-4/solutions-morning.md:34
#, fuzzy
msgid "\\>, thoughts: mpsc::SyncSender"
msgstr "\\>, myli: mpsc::SyncSender"

#: src/exercises/day-4/solutions-morning.md:38
msgid ""
"// ANCHOR: Philosopher-think impl Philosopher { fn think(&self) { self."
"thoughts .send(format!(\"Eureka! {} has a new idea!\", &self.name)) ."
"unwrap(); } // ANCHOR_END: Philosopher-think"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:47
msgid ""
"```\n"
"// ANCHOR: Philosopher-eat\n"
"fn eat(&self) {\n"
"    // ANCHOR_END: Philosopher-eat\n"
"    println!(\"{} is trying to eat\", &self.name);\n"
"    let left = self.left_fork.lock().unwrap();\n"
"    let right = self.right_fork.lock().unwrap();\n"
"```"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:54
msgid ""
"```\n"
"    // ANCHOR: Philosopher-eat-end\n"
"    println!(\"{} is eating...\", &self.name);\n"
"    thread::sleep(Duration::from_millis(10));\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:63
msgid ""
"fn main() { // ANCHOR_END: Philosopher-eat-end let (tx, rx) = mpsc::"
"sync_channel(10);"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:67
msgid ""
"```\n"
"let forks = (0..PHILOSOPHERS.len())\n"
"    .map(|_| Arc::new(Mutex::new(Fork)))\n"
"    .collect::<Vec<_>>();\n"
"```"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:71
msgid ""
"```\n"
"for i in 0..forks.len() {\n"
"    let tx = tx.clone();\n"
"    let mut left_fork = forks[i].clone();\n"
"    let mut right_fork = forks[(i + 1) % forks.len()].clone();\n"
"```"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:76
msgid ""
"```\n"
"    // To avoid a deadlock, we have to break the symmetry\n"
"    // somewhere. This will swap the forks without deinitializing\n"
"    // either of them.\n"
"    if i == forks.len() - 1 {\n"
"        std::mem::swap(&mut left_fork, &mut right_fork);\n"
"    }\n"
"```"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:83
msgid ""
"```\n"
"    let philosopher = Philosopher {\n"
"        name: PHILOSOPHERS[i].to_string(),\n"
"        thoughts: tx,\n"
"        left_fork,\n"
"        right_fork,\n"
"    };\n"
"```"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:90
msgid ""
"```\n"
"    thread::spawn(move || {\n"
"        for _ in 0..100 {\n"
"            philosopher.eat();\n"
"            philosopher.think();\n"
"        }\n"
"    });\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:98
msgid ""
"```\n"
"drop(tx);\n"
"for thought in rx {\n"
"    println!(\"{thought}\");\n"
"}\n"
"```"
msgstr ""
