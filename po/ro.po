msgid ""
msgstr ""
"Project-Id-Version: Comprehensive Rust 游\n"
"POT-Creation-Date: 2024-05-15T20:58:33+03:00\n"
"PO-Revision-Date: 2024-05-15 22:17+0300\n"
"Last-Translator: Razvan Stefanescu <rstefanescu@google.com>\n"
"Language-Team: Romanian <translation-team-ro@lists.sourceforge.net>\n"
"Language: ro\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=n==1 ? 0 : (n==0 || (n%100 > 0 && n%100 < "
"20)) ? 1 : 2;\n"
"X-Generator: Poedit 3.4.4\n"

#: src/SUMMARY.md src/index.md
msgid "Welcome to Comprehensive Rust 游"
msgstr "Bine a탵i venit la Comprehensive Rust 游 (ghidul complet pentu Rust)"

#: src/SUMMARY.md src/running-the-course.md
msgid "Running the Course"
msgstr "Rularea cursului"

#: src/SUMMARY.md src/running-the-course/course-structure.md
msgid "Course Structure"
msgstr "Structura cursului"

#: src/SUMMARY.md src/running-the-course/keyboard-shortcuts.md
msgid "Keyboard Shortcuts"
msgstr "Scurt캒turi de tastatur캒"

#: src/SUMMARY.md src/running-the-course/translations.md
msgid "Translations"
msgstr "Traduceri"

#: src/SUMMARY.md src/cargo.md
msgid "Using Cargo"
msgstr "Folosirea Cargo"

#: src/SUMMARY.md
msgid "Rust Ecosystem"
msgstr "Ecosistemul Rust"

#: src/SUMMARY.md
msgid "Code Samples"
msgstr "Mostre de cod"

#: src/SUMMARY.md
msgid "Running Cargo Locally"
msgstr "Rularea Cargo local"

#: src/SUMMARY.md
msgid "Day 1: Morning"
msgstr "Ziua 1: Diminea탵a"

#: src/SUMMARY.md src/concurrency/welcome-async.md
msgid "Welcome"
msgstr "Bine a탵i venit"

#: src/SUMMARY.md src/hello-world.md src/types-and-values/hello-world.md
msgid "Hello, World"
msgstr "Bun캒 lume"

#: src/SUMMARY.md src/hello-world/what-is-rust.md
msgid "What is Rust?"
msgstr "Ce este Rust?"

#: src/SUMMARY.md src/hello-world/benefits.md
msgid "Benefits of Rust"
msgstr "Avantajele Rust"

#: src/SUMMARY.md src/hello-world/playground.md
msgid "Playground"
msgstr "Ciorn캒"

#: src/SUMMARY.md src/types-and-values.md
msgid "Types and Values"
msgstr "Tipuri 탳i valori"

#: src/SUMMARY.md src/types-and-values/variables.md
msgid "Variables"
msgstr "Variabile"

#: src/SUMMARY.md src/types-and-values/values.md
msgid "Values"
msgstr "Valori"

#: src/SUMMARY.md src/types-and-values/arithmetic.md
msgid "Arithmetic"
msgstr "Aritmetic캒"

#: src/SUMMARY.md src/types-and-values/inference.md
msgid "Type Inference"
msgstr "Inferen탵a de tip"

#: src/SUMMARY.md src/types-and-values/exercise.md
msgid "Exercise: Fibonacci"
msgstr "Exerci탵iu: Fibonacci"

#: src/SUMMARY.md src/types-and-values/solution.md
#: src/control-flow-basics/solution.md src/tuples-and-arrays/solution.md
#: src/references/solution.md src/user-defined-types/solution.md
#: src/pattern-matching/solution.md src/methods-and-traits/solution.md
#: src/generics/solution.md src/std-types/solution.md
#: src/std-traits/solution.md src/memory-management/solution.md
#: src/smart-pointers/solution.md src/borrowing/solution.md
#: src/lifetimes/solution.md src/iterators/solution.md src/modules/solution.md
#: src/testing/solution.md src/error-handling/solution.md
#: src/unsafe-rust/solution.md
msgid "Solution"
msgstr "Solu탵ie"

#: src/SUMMARY.md src/control-flow-basics.md
msgid "Control Flow Basics"
msgstr "Bazele fluxului de control"

#: src/SUMMARY.md
msgid "`if` Expressions"
msgstr "Expresii 'if'"

#: src/SUMMARY.md src/control-flow-basics/loops.md
msgid "Loops"
msgstr "Bucle de execu탵ie"

#: src/SUMMARY.md src/control-flow-basics/loops/for.md
msgid "`for`"
msgstr "Bucle `for`"

#: src/SUMMARY.md src/control-flow-basics/loops/loop.md
msgid "`loop`"
msgstr "Bucle `loop`"

#: src/SUMMARY.md src/control-flow-basics/break-continue.md
msgid "`break` and `continue`"
msgstr "`break` 탳i `continue`"

#: src/SUMMARY.md src/control-flow-basics/break-continue/labels.md
msgid "Labels"
msgstr "Etichete"

#: src/SUMMARY.md src/control-flow-basics/blocks-and-scopes.md
msgid "Blocks and Scopes"
msgstr "Blocuri 탳i scopuri"

#: src/SUMMARY.md src/control-flow-basics/blocks-and-scopes/scopes.md
msgid "Scopes and Shadowing"
msgstr "Scopuri 탳i masc캒ri"

#: src/SUMMARY.md src/control-flow-basics/functions.md
msgid "Functions"
msgstr "Func탵ii"

#: src/SUMMARY.md src/control-flow-basics/macros.md
msgid "Macros"
msgstr "Macro-uri"

#: src/SUMMARY.md src/control-flow-basics/exercise.md
msgid "Exercise: Collatz Sequence"
msgstr "Exerci탵iu: secven탵a Collatz"

#: src/SUMMARY.md
msgid "Day 1: Afternoon"
msgstr "Ziua 1: Dup캒-amiaza"

#: src/SUMMARY.md src/tuples-and-arrays.md
msgid "Tuples and Arrays"
msgstr "Tupluri 탳i vectori"

#: src/SUMMARY.md src/tuples-and-arrays/arrays.md
msgid "Arrays"
msgstr "Array-uri"

#: src/SUMMARY.md src/tuples-and-arrays/tuples.md
msgid "Tuples"
msgstr "Tupluri"

#: src/SUMMARY.md src/tuples-and-arrays/iteration.md
msgid "Array Iteration"
msgstr "Itera탵ii pe vectori"

#: src/SUMMARY.md src/tuples-and-arrays/destructuring.md
msgid "Patterns and Destructuring"
msgstr "탲abloane 탳i destructur캒ri"

#: src/SUMMARY.md src/tuples-and-arrays/exercise.md
msgid "Exercise: Nested Arrays"
msgstr "Exerci탵iu: vectori 칥mbr캒ca탵i"

#: src/SUMMARY.md src/references.md
msgid "References"
msgstr "Referin콖e"

#: src/SUMMARY.md src/references/shared.md
msgid "Shared References"
msgstr "Referin콖e partajare"

#: src/SUMMARY.md src/references/exclusive.md
msgid "Exclusive References"
msgstr "Referin탵e exclusive"

#: src/SUMMARY.md
msgid "Slices: `&[T]`"
msgstr "Parti탵ii: `&[T]`"

#: src/SUMMARY.md src/references/strings.md
msgid "Strings"
msgstr "탲iruri de caractere"

#: src/SUMMARY.md src/references/exercise.md
msgid "Exercise: Geometry"
msgstr "Exerci탵iu: Geometrie"

#: src/SUMMARY.md src/user-defined-types.md
msgid "User-Defined Types"
msgstr "Tipuri definite de utilizator"

#: src/SUMMARY.md src/user-defined-types/named-structs.md
msgid "Named Structs"
msgstr "Structuri cu nume"

#: src/SUMMARY.md src/user-defined-types/tuple-structs.md
msgid "Tuple Structs"
msgstr "Structuri Tupluri"

#: src/SUMMARY.md src/user-defined-types/enums.md
#: src/pattern-matching/destructuring-enums.md
msgid "Enums"
msgstr "Enumer캒ri (enums)"

#: src/SUMMARY.md
msgid "Static"
msgstr "Static"

#: src/SUMMARY.md
msgid "Const"
msgstr "Const"

#: src/SUMMARY.md src/user-defined-types/aliases.md
msgid "Type Aliases"
msgstr "Aliasuri de tip"

#: src/SUMMARY.md src/user-defined-types/exercise.md
#, fuzzy
msgid "Exercise: Elevator Events"
msgstr "Exerci탵iu: Evaluarea expresiilor"

#: src/SUMMARY.md
msgid "Day 2: Morning"
msgstr "Ziua 2: Diminea탵a"

#: src/SUMMARY.md src/pattern-matching.md
msgid "Pattern Matching"
msgstr "Potrivire de 탳abloane"

#: src/SUMMARY.md src/pattern-matching/match.md
msgid "Matching Values"
msgstr "Potrivirea valorilor"

#: src/SUMMARY.md
#, fuzzy
msgid "Destructuring Structs"
msgstr "Destructur캒ri"

#: src/SUMMARY.md
msgid "Destructuring Enums"
msgstr "Destructurarea enumer캒rilor"

#: src/SUMMARY.md src/pattern-matching/let-control-flow.md
msgid "Let Control Flow"
msgstr "Fluxul de control"

#: src/SUMMARY.md src/pattern-matching/exercise.md
msgid "Exercise: Expression Evaluation"
msgstr "Exerci탵iu: Evaluarea expresiilor"

#: src/SUMMARY.md src/methods-and-traits.md
msgid "Methods and Traits"
msgstr "Metode 탳i tr캒s캒turi"

#: src/SUMMARY.md src/methods-and-traits/methods.md
msgid "Methods"
msgstr "Metode"

#: src/SUMMARY.md src/methods-and-traits/traits.md
msgid "Traits"
msgstr "Tr캒s캒turi"

#: src/SUMMARY.md src/methods-and-traits/traits/implementing.md
msgid "Implementing Traits"
msgstr "Implementarea tr캒s캒turilor"

#: src/SUMMARY.md src/methods-and-traits/traits/supertraits.md
msgid "Supertraits"
msgstr "Supertr캒s캒turi"

#: src/SUMMARY.md src/methods-and-traits/traits/associated-types.md
msgid "Associated Types"
msgstr "Tipuri asociate"

#: src/SUMMARY.md src/methods-and-traits/deriving.md
msgid "Deriving"
msgstr "Derivarea"

#: src/SUMMARY.md
#, fuzzy
msgid "Exercise: Generic Logger"
msgstr "Exerci탵iu: Logger generic"

#: src/SUMMARY.md
msgid "Day 2: Afternoon"
msgstr "Ziua 2: Dup캒-amiaza"

#: src/SUMMARY.md src/generics.md
msgid "Generics"
msgstr "Produse generice"

#: src/SUMMARY.md src/generics/generic-functions.md
msgid "Generic Functions"
msgstr "Func탵ii generice"

#: src/SUMMARY.md src/generics/generic-data.md
msgid "Generic Data Types"
msgstr "Tipuri de date generice"

#: src/SUMMARY.md src/generics/generic-traits.md
msgid "Generic Traits"
msgstr "Tr캒s캒turi generice"

#: src/SUMMARY.md src/generics/trait-bounds.md
msgid "Trait Bounds"
msgstr "Limite de tr캒s캒turi"

#: src/SUMMARY.md src/generics/impl-trait.md
msgid "`impl Trait`"
msgstr "`impl Trait`"

#: src/SUMMARY.md src/generics/exercise.md
msgid "Exercise: Generic `min`"
msgstr "Exerci탵iu: 'min' generic"

#: src/SUMMARY.md src/std-types.md
msgid "Standard Library Types"
msgstr "Biblioteca de tipuri standard"

#: src/SUMMARY.md src/std-types/std.md
msgid "Standard Library"
msgstr "Biblioteca standard"

#: src/SUMMARY.md src/std-types/docs.md
msgid "Documentation"
msgstr "Documenta탵ie"

#: src/SUMMARY.md
msgid "`Option`"
msgstr "'Option'"

#: src/SUMMARY.md
msgid "`Result`"
msgstr "`Result`"

#: src/SUMMARY.md src/android/aidl/types/primitives.md
#: src/android/interoperability/cpp/type-mapping.md
msgid "`String`"
msgstr "탲ir"

#: src/SUMMARY.md src/std-types/vec.md
msgid "`Vec`"
msgstr "`Vec`"

#: src/SUMMARY.md src/std-types/hashmap.md src/bare-metal/no_std.md
msgid "`HashMap`"
msgstr "`HashMap`"

#: src/SUMMARY.md src/std-types/exercise.md
msgid "Exercise: Counter"
msgstr "Exerci탵iu: num캒r캒tor"

#: src/SUMMARY.md src/std-traits.md
msgid "Standard Library Traits"
msgstr "Biblioteca standard de tr캒s캒turi"

#: src/SUMMARY.md src/std-traits/comparisons.md
#: src/concurrency/welcome-async.md
msgid "Comparisons"
msgstr "Compara탵ii"

#: src/SUMMARY.md src/std-traits/operators.md
msgid "Operators"
msgstr "Operatori"

#: src/SUMMARY.md src/std-traits/from-and-into.md
msgid "`From` and `Into`"
msgstr "`From` 탳i `Into`"

#: src/SUMMARY.md src/std-traits/casting.md
msgid "Casting"
msgstr "Transformarea"

#: src/SUMMARY.md src/std-traits/read-and-write.md
msgid "`Read` and `Write`"
msgstr "Citire 탳i scriere"

#: src/SUMMARY.md
msgid "`Default`, struct update syntax"
msgstr "'Default' (implicit), sintaxa de actualizare a structurilor"

#: src/SUMMARY.md src/std-traits/closures.md
msgid "Closures"
msgstr "칉nchideri"

#: src/SUMMARY.md src/std-traits/exercise.md
msgid "Exercise: ROT13"
msgstr "Exerci탵iu: ROT13"

#: src/SUMMARY.md
msgid "Day 3: Morning"
msgstr "Ziua 3: Diminea탵a"

#: src/SUMMARY.md src/memory-management.md
msgid "Memory Management"
msgstr "Gestionarea memoriei"

#: src/SUMMARY.md src/memory-management/review.md
msgid "Review of Program Memory"
msgstr "Utilizarea memoriei de c캒tre programe"

#: src/SUMMARY.md src/memory-management/approaches.md
msgid "Approaches to Memory Management"
msgstr "Abord캒ri ale administr캒rii memoriei"

#: src/SUMMARY.md src/memory-management/ownership.md
msgid "Ownership"
msgstr "Posesia"

#: src/SUMMARY.md src/memory-management/move.md
msgid "Move Semantics"
msgstr "Semantica mut캒rilor"

#: src/SUMMARY.md
msgid "`Clone`"
msgstr "'Clone'"

#: src/SUMMARY.md src/memory-management/copy-types.md
msgid "Copy Types"
msgstr "Tipuri copiate"

#: src/SUMMARY.md
msgid "`Drop`"
msgstr "'Drop'"

#: src/SUMMARY.md src/memory-management/exercise.md
msgid "Exercise: Builder Type"
msgstr "Exerci탵iu: Tipul constructor"

#: src/SUMMARY.md src/smart-pointers.md
msgid "Smart Pointers"
msgstr "Pointeri inteligen탵i"

#: src/SUMMARY.md src/smart-pointers/box.md
#: src/android/interoperability/cpp/type-mapping.md
msgid "`Box<T>`"
msgstr "`Box<T>`"

#: src/SUMMARY.md src/smart-pointers/rc.md
msgid "`Rc`"
msgstr "`Rc`"

#: src/SUMMARY.md src/smart-pointers/trait-objects.md
msgid "Trait Objects"
msgstr "Obiecte cu tr캒s캒turi"

#: src/SUMMARY.md src/smart-pointers/exercise.md
msgid "Exercise: Binary Tree"
msgstr "Exerci탵iu: arbore binar"

#: src/SUMMARY.md
msgid "Day 3: Afternoon"
msgstr "Ziua 3: Dup캒-amiaza"

#: src/SUMMARY.md src/borrowing.md
msgid "Borrowing"
msgstr "칉mprumut"

#: src/SUMMARY.md src/borrowing/shared.md
msgid "Borrowing a Value"
msgstr "칉mprumutul unei valori"

#: src/SUMMARY.md src/borrowing/borrowck.md
msgid "Borrow Checking"
msgstr "Verificarea 칥mprumuturilor"

#: src/SUMMARY.md src/borrowing/examples.md
#, fuzzy
msgid "Borrow Errors"
msgstr "칉mprumuta탵i erorile"

#: src/SUMMARY.md src/borrowing/interior-mutability.md
msgid "Interior Mutability"
msgstr "Mutabilitate intern캒"

#: src/SUMMARY.md src/borrowing/exercise.md
msgid "Exercise: Health Statistics"
msgstr "Exerci탵iu: statistici de s캒n캒tate"

#: src/SUMMARY.md src/lifetimes.md
msgid "Lifetimes"
msgstr "Durata de via탵캒"

#: src/SUMMARY.md src/lifetimes/lifetime-annotations.md
msgid "Lifetime Annotations"
msgstr "Duratele de via탵캒 칥n anot캒ri"

#: src/SUMMARY.md
msgid "Lifetime Elision"
msgstr "Extinderea duratei de via탵캒"

#: src/SUMMARY.md
msgid "Struct Lifetimes"
msgstr "Durata de via탵캒 a structurilor"

#: src/SUMMARY.md src/lifetimes/exercise.md
msgid "Exercise: Protobuf Parsing"
msgstr "Exerci탵iu: Parsarea Protobuf"

#: src/SUMMARY.md
msgid "Day 4: Morning"
msgstr "Ziua 1: Diminea탵a"

#: src/SUMMARY.md src/iterators.md
msgid "Iterators"
msgstr "Iteratori"

#: src/SUMMARY.md src/iterators/iterator.md src/bare-metal/no_std.md
msgid "`Iterator`"
msgstr "`Iterator`"

#: src/SUMMARY.md src/iterators/intoiterator.md
msgid "`IntoIterator`"
msgstr "`IntoIterator`"

#: src/SUMMARY.md
msgid "`FromIterator`"
msgstr "`FromIterator`"

#: src/SUMMARY.md src/iterators/exercise.md
msgid "Exercise: Iterator Method Chaining"
msgstr "Exerci탵iu: 칉nl캒ntuirea metodelor iterator"

#: src/SUMMARY.md src/modules.md src/modules/modules.md
msgid "Modules"
msgstr "Module"

#: src/SUMMARY.md src/modules/filesystem.md
msgid "Filesystem Hierarchy"
msgstr "Ierarhia sistemului de fi탳iere"

#: src/SUMMARY.md src/modules/visibility.md
msgid "Visibility"
msgstr "Vizibilitate"

#: src/SUMMARY.md
msgid "`use`, `super`, `self`"
msgstr "`use`, `super`, `self`"

#: src/SUMMARY.md src/modules/exercise.md
msgid "Exercise: Modules for a GUI Library"
msgstr "Exerci탵iu: Module pentru o biblioteca pentru interfa탵a grafic캒"

#: src/SUMMARY.md src/testing.md src/chromium/testing.md
msgid "Testing"
msgstr "Testare"

#: src/SUMMARY.md
msgid "Test Modules"
msgstr "Module de testare"

#: src/SUMMARY.md src/testing/other.md
msgid "Other Types of Tests"
msgstr "Alte tipuri de teste"

#: src/SUMMARY.md src/testing/lints.md
msgid "Compiler Lints and Clippy"
msgstr "Corec탵ii compilator 탳i Clippy"

#: src/SUMMARY.md src/testing/exercise.md
msgid "Exercise: Luhn Algorithm"
msgstr "Exerci탵iu: Algoritmul Luhn"

#: src/SUMMARY.md
msgid "Day 4: Afternoon"
msgstr "Ziua 4: Dup캒-amiaza"

#: src/SUMMARY.md src/error-handling.md
msgid "Error Handling"
msgstr "Gestionarea erorilor"

#: src/SUMMARY.md src/error-handling/panics.md
msgid "Panics"
msgstr "Panic캒"

#: src/SUMMARY.md src/error-handling/try.md
msgid "Try Operator"
msgstr "Operatorul 'try'"

#: src/SUMMARY.md src/error-handling/try-conversions.md
msgid "Try Conversions"
msgstr "Conversii 'try'"

#: src/SUMMARY.md
msgid "`Error` Trait"
msgstr "Tr캒s캒turi 'Error'"

#: src/SUMMARY.md src/error-handling/thiserror-and-anyhow.md
msgid "`thiserror` and `anyhow`"
msgstr "`thiserror` 탳i `anyhow`"

#: src/SUMMARY.md
msgid "Exercise: Rewriting with `Result`"
msgstr "Exerci탵iu: rescrierea cu `Result`"

#: src/SUMMARY.md src/unsafe-rust.md src/unsafe-rust/unsafe.md
msgid "Unsafe Rust"
msgstr "Rust nesigur"

#: src/SUMMARY.md
msgid "Unsafe"
msgstr "Nesigur"

#: src/SUMMARY.md src/unsafe-rust/dereferencing.md
msgid "Dereferencing Raw Pointers"
msgstr "Dereferen탵ierea pointerilor bru탵i"

#: src/SUMMARY.md src/unsafe-rust/mutable-static.md
msgid "Mutable Static Variables"
msgstr "Variabile statice mutabile"

#: src/SUMMARY.md src/unsafe-rust/unions.md
msgid "Unions"
msgstr "Sindicate (Unions)"

#: src/SUMMARY.md src/unsafe-rust/unsafe-functions.md
msgid "Unsafe Functions"
msgstr "Func탵ii nesigure"

#: src/SUMMARY.md
msgid "Unsafe Traits"
msgstr "Tr캒s캒turi nesigure"

#: src/SUMMARY.md
msgid "Exercise: FFI Wrapper"
msgstr "칉npachetare sigur캒 prin FFI"

#: src/SUMMARY.md src/bare-metal/android.md
msgid "Android"
msgstr "Android"

#: src/SUMMARY.md src/android/setup.md src/chromium/setup.md
msgid "Setup"
msgstr "Setare"

#: src/SUMMARY.md src/android/build-rules.md
msgid "Build Rules"
msgstr "Reguli de construc탵ie"

#: src/SUMMARY.md
msgid "Binary"
msgstr "Programe binare"

#: src/SUMMARY.md
msgid "Library"
msgstr "Biblioteci"

#: src/SUMMARY.md src/android/aidl.md
msgid "AIDL"
msgstr "AIDL"

#: src/SUMMARY.md src/android/aidl/birthday-service.md
#, fuzzy
msgid "Birthday Service Tutorial"
msgstr "/** Interfa탵캒 de serviciu de ziua de na탳tere. */"

#: src/SUMMARY.md
msgid "Interface"
msgstr "Interfa탵캒"

#: src/SUMMARY.md
#, fuzzy
msgid "Service API"
msgstr "Serviciul API"

#: src/SUMMARY.md
msgid "Service"
msgstr "Serviciu"

#: src/SUMMARY.md
msgid "Server"
msgstr "Server"

#: src/SUMMARY.md src/android/aidl/example-service/deploy.md
msgid "Deploy"
msgstr "Lanseaza"

#: src/SUMMARY.md
msgid "Client"
msgstr "Client"

#: src/SUMMARY.md src/android/aidl/example-service/changing-definition.md
msgid "Changing API"
msgstr "Schimbarea API-ului"

#: src/SUMMARY.md
#, fuzzy
msgid "Updating Implementations"
msgstr "Implementare"

#: src/SUMMARY.md
#, fuzzy
msgid "AIDL Types"
msgstr "Tipuri"

#: src/SUMMARY.md src/android/aidl/types/primitives.md
#, fuzzy
msgid "Primitive Types"
msgstr "Tipuri primitive"

#: src/SUMMARY.md src/android/aidl/types/arrays.md
#, fuzzy
msgid "Array Types"
msgstr "Array-uri"

#: src/SUMMARY.md src/android/aidl/types/objects.md
#, fuzzy
msgid "Sending Objects"
msgstr "Obiecte cu tr캒s캒turi"

#: src/SUMMARY.md src/android/aidl/types/parcelables.md
#, fuzzy
msgid "Parcelables"
msgstr "Variabile"

#: src/SUMMARY.md src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "Sending Files"
msgstr "Trimiterea fi탳ierelor"

#: src/SUMMARY.md src/android/testing/googletest.md
msgid "GoogleTest"
msgstr "GoogleTest"

#: src/SUMMARY.md src/android/testing/mocking.md
msgid "Mocking"
msgstr "Imitarea"

#: src/SUMMARY.md src/android/logging.md src/bare-metal/aps/logging.md
msgid "Logging"
msgstr "Jurnalizare (loguri)"

#: src/SUMMARY.md src/android/interoperability.md
msgid "Interoperability"
msgstr "Interoperabilitate"

#: src/SUMMARY.md
msgid "With C"
msgstr "Cu C"

#: src/SUMMARY.md
msgid "Calling C with Bindgen"
msgstr "Apelarea C cu Bindgen"

#: src/SUMMARY.md
msgid "Calling Rust from C"
msgstr "Apelarea Rust din C"

#: src/SUMMARY.md src/android/interoperability/cpp.md
msgid "With C++"
msgstr "Cu C++"

#: src/SUMMARY.md src/android/interoperability/cpp/bridge.md
msgid "The Bridge Module"
msgstr "Modulul de interconectare"

#: src/SUMMARY.md
msgid "Rust Bridge"
msgstr "Interconectarea cu Rust"

#: src/SUMMARY.md src/android/interoperability/cpp/generated-cpp.md
msgid "Generated C++"
msgstr "Cod C++ generat"

#: src/SUMMARY.md
msgid "C++ Bridge"
msgstr "Interconectarea cu C++"

#: src/SUMMARY.md src/android/interoperability/cpp/shared-types.md
msgid "Shared Types"
msgstr "Tipuri partajate"

#: src/SUMMARY.md src/android/interoperability/cpp/shared-enums.md
msgid "Shared Enums"
msgstr "Enumer캒ri partajate"

#: src/SUMMARY.md src/android/interoperability/cpp/rust-result.md
msgid "Rust Error Handling"
msgstr "Gestionarea erorilor 칥n Rust"

#: src/SUMMARY.md src/android/interoperability/cpp/cpp-exception.md
msgid "C++ Error Handling"
msgstr "Gestionarea erorilor 칥n C++"

#: src/SUMMARY.md src/android/interoperability/cpp/type-mapping.md
msgid "Additional Types"
msgstr "Tipuri suplimentare"

#: src/SUMMARY.md
msgid "Building for Android: C++"
msgstr "Construirea pentru Android: C++"

#: src/SUMMARY.md
msgid "Building for Android: Genrules"
msgstr "Construirea pentru Android: reguli de generare"

#: src/SUMMARY.md
msgid "Building for Android: Rust"
msgstr "Construirea pentru Android: Rust"

#: src/SUMMARY.md
msgid "With Java"
msgstr "Cu Java"

#: src/SUMMARY.md src/exercises/android/morning.md
#: src/exercises/bare-metal/morning.md src/exercises/bare-metal/afternoon.md
#: src/concurrency/sync-exercises.md src/concurrency/async-exercises.md
msgid "Exercises"
msgstr "Exerci탵ii"

#: src/SUMMARY.md
msgid "Chromium"
msgstr "Chromium"

#: src/SUMMARY.md src/chromium/cargo.md
msgid "Comparing Chromium and Cargo Ecosystems"
msgstr "Compararea ecosistemelor Chromium 탳i Cargo"

#: src/SUMMARY.md
msgid "Policy"
msgstr "Politici"

#: src/SUMMARY.md
msgid "Unsafe Code"
msgstr "Cod nesigur"

#: src/SUMMARY.md src/chromium/build-rules/depending.md
msgid "Depending on Rust Code from Chromium C++"
msgstr "칉n func탵ie de codul Rust din Chromium C++"

#: src/SUMMARY.md src/chromium/build-rules/vscode.md
msgid "Visual Studio Code"
msgstr "Visual Studio Code"

#: src/SUMMARY.md src/exercises/chromium/third-party.md
msgid "Exercise"
msgstr "Exerci탵iu"

#: src/SUMMARY.md src/chromium/testing/rust-gtest-interop.md
msgid "`rust_gtest_interop` Library"
msgstr "Biblioteca `rust_gtest_interop`"

#: src/SUMMARY.md src/chromium/testing/build-gn.md
msgid "GN Rules for Rust Tests"
msgstr "Reguli GN pentru testele Rust"

#: src/SUMMARY.md src/chromium/testing/chromium-import-macro.md
msgid "`chromium::import!` Macro"
msgstr "Macro-ul `chromium::import!`"

#: src/SUMMARY.md src/chromium/interoperability-with-cpp.md
msgid "Interoperability with C++"
msgstr "Interoperabilitatea cu C++"

#: src/SUMMARY.md src/chromium/interoperability-with-cpp/example-bindings.md
msgid "Example Bindings"
msgstr "Exemple de leg캒turi"

#: src/SUMMARY.md src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid "Limitations of CXX"
msgstr "Limit캒ri ale CXX"

#: src/SUMMARY.md src/chromium/interoperability-with-cpp/error-handling.md
msgid "CXX Error Handling"
msgstr "Gestionarea erorilor 칥n CXX"

#: src/SUMMARY.md
msgid "Error Handling: QR Example"
msgstr "Gestionarea erorilor: exemplu QR"

#: src/SUMMARY.md
msgid "Error Handling: PNG Example"
msgstr "Gestionarea erorilor: exemplu PNG"

#: src/SUMMARY.md
msgid "Using CXX in Chromium"
msgstr "Utilizarea CXX 칥n Chromium"

#: src/SUMMARY.md src/chromium/adding-third-party-crates.md
msgid "Adding Third Party Crates"
msgstr "Ad캒ugarea de l캒zi ale unor ter탵e p캒r탵i"

#: src/SUMMARY.md
msgid "Configuring Cargo.toml"
msgstr "Configurarea Cargo.toml"

#: src/SUMMARY.md
#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
msgid "Configuring `gnrt_config.toml`"
msgstr "Configurarea `gnrt_config.toml`"

#: src/SUMMARY.md src/chromium/adding-third-party-crates/downloading-crates.md
msgid "Downloading Crates"
msgstr "Desc캒rcarea de l캒zi"

#: src/SUMMARY.md
#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid "Generating `gn` Build Rules"
msgstr "Generarea regulilor de compilare `gn`"

#: src/SUMMARY.md src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Resolving Problems"
msgstr "Rezolvarea problemelor"

#: src/SUMMARY.md
#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
msgid "Build Scripts Which Generate Code"
msgstr "Scripturi de construire care genereaz캒 cod"

#: src/SUMMARY.md
#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
msgid "Build Scripts Which Build C++ or Take Arbitrary Actions"
msgstr ""
"Scripturi de construire care construiesc C++ sau efectueaz캒 ac탵iuni arbitrare"

#: src/SUMMARY.md
#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
msgid "Depending on a Crate"
msgstr "Dependin탵e de crater"

#: src/SUMMARY.md
msgid "Reviews and Audits"
msgstr "Revizuiri 탳i audituri"

#: src/SUMMARY.md
#, fuzzy
msgid "Checking into Chromium Source Code"
msgstr "Modific캒ri 칥n codul surs캒 Chromium"

#: src/SUMMARY.md src/chromium/adding-third-party-crates/keeping-up-to-date.md
msgid "Keeping Crates Up to Date"
msgstr "Actualizarea crate-urilor"

#: src/SUMMARY.md
msgid "Bringing It Together - Exercise"
msgstr "Reunind totul - Exerci탵iu"

#: src/SUMMARY.md src/exercises/chromium/solutions.md
msgid "Exercise Solutions"
msgstr "Solu탵iile exerci탵iilor"

#: src/SUMMARY.md
msgid "Bare Metal: Morning"
msgstr "Direct pe hardware: Diminea탵a"

#: src/SUMMARY.md src/bare-metal/no_std.md
msgid "`no_std`"
msgstr "`no_std`"

#: src/SUMMARY.md
msgid "A Minimal Example"
msgstr "Un exemplu minimalist"

#: src/SUMMARY.md src/bare-metal/no_std.md src/bare-metal/alloc.md
msgid "`alloc`"
msgstr "`alloc`"

#: src/SUMMARY.md src/bare-metal/microcontrollers.md
msgid "Microcontrollers"
msgstr "Microcontrolere"

#: src/SUMMARY.md src/bare-metal/microcontrollers/mmio.md
msgid "Raw MMIO"
msgstr "MMIO brut"

#: src/SUMMARY.md
msgid "PACs"
msgstr "PAC-uri"

#: src/SUMMARY.md
msgid "HAL Crates"
msgstr "L캒zi (crates) HAL"

#: src/SUMMARY.md
msgid "Board Support Crates"
msgstr "Crates cu suport pentru pl캒ci"

#: src/SUMMARY.md
msgid "The Type State Pattern"
msgstr "Modelul de stare de tip"

#: src/SUMMARY.md src/bare-metal/microcontrollers/embedded-hal.md
msgid "`embedded-hal`"
msgstr "`embedded-hal`"

#: src/SUMMARY.md src/bare-metal/microcontrollers/probe-rs.md
msgid "`probe-rs` and `cargo-embed`"
msgstr "`probe-rs` 탳i `cargo-embed`"

#: src/SUMMARY.md src/bare-metal/microcontrollers/debugging.md
msgid "Debugging"
msgstr "Depanare"

#: src/SUMMARY.md
msgid "Other Projects"
msgstr "Alte proiecte"

#: src/SUMMARY.md src/exercises/bare-metal/compass.md
#: src/exercises/bare-metal/solutions-morning.md
msgid "Compass"
msgstr "Compass"

#: src/SUMMARY.md src/concurrency/sync-exercises/solutions.md
#: src/concurrency/async-exercises/solutions.md
msgid "Solutions"
msgstr "Solu탵ii"

#: src/SUMMARY.md
msgid "Bare Metal: Afternoon"
msgstr "Bare Metal: Dup캒-amiaz캒"

#: src/SUMMARY.md
msgid "Application Processors"
msgstr "Procesatori de aplica탵ii"

#: src/SUMMARY.md src/bare-metal/aps/entry-point.md
msgid "Getting Ready to Rust"
msgstr "Preg캒ti탵i pentru Rust"

#: src/SUMMARY.md
msgid "Inline Assembly"
msgstr "Ansamblare 칥n linie"

#: src/SUMMARY.md
msgid "MMIO"
msgstr "MMIO"

#: src/SUMMARY.md
msgid "Let's Write a UART Driver"
msgstr "S캒 scriem un driver UART"

#: src/SUMMARY.md
msgid "More Traits"
msgstr "Mai multe tr캒s캒turi"

#: src/SUMMARY.md
msgid "A Better UART Driver"
msgstr "Un driver UART mai bun"

#: src/SUMMARY.md src/bare-metal/aps/better-uart/bitflags.md
msgid "Bitflags"
msgstr "Bitflags"

#: src/SUMMARY.md
msgid "Multiple Registers"
msgstr "Registre multiple"

#: src/SUMMARY.md src/bare-metal/aps/better-uart/driver.md
msgid "Driver"
msgstr "Un driver UART mai bun"

#: src/SUMMARY.md
msgid "Using It"
msgstr "Utilizarea acestuia"

#: src/SUMMARY.md src/bare-metal/aps/exceptions.md
msgid "Exceptions"
msgstr "Excep탵ii"

#: src/SUMMARY.md
msgid "Useful Crates"
msgstr "Crates (l캒zi) utile"

#: src/SUMMARY.md src/bare-metal/useful-crates/zerocopy.md
msgid "`zerocopy`"
msgstr "`zerocopy`"

#: src/SUMMARY.md src/bare-metal/useful-crates/aarch64-paging.md
msgid "`aarch64-paging`"
msgstr "`aarch64-paging`"

#: src/SUMMARY.md src/bare-metal/useful-crates/buddy_system_allocator.md
msgid "`buddy_system_allocator`"
msgstr "buddy_system_allocator`"

#: src/SUMMARY.md src/bare-metal/useful-crates/tinyvec.md
msgid "`tinyvec`"
msgstr "`tinyvec`"

#: src/SUMMARY.md src/bare-metal/useful-crates/spin.md
msgid "`spin`"
msgstr "`Spin`"

#: src/SUMMARY.md
msgid "`vmbase`"
msgstr "`vmbase`"

#: src/SUMMARY.md
msgid "RTC Driver"
msgstr "Conductor RTC"

#: src/SUMMARY.md
msgid "Concurrency: Morning"
msgstr "Concuren탵캒: Diminea탵a"

#: src/SUMMARY.md src/concurrency/threads.md
msgid "Threads"
msgstr "Conversatii"

#: src/SUMMARY.md src/concurrency/threads/plain.md
#, fuzzy
msgid "Plain Threads"
msgstr "Conversatii"

#: src/SUMMARY.md src/concurrency/threads/scoped.md
msgid "Scoped Threads"
msgstr "Fire de execu탵ie cu scop"

#: src/SUMMARY.md src/concurrency/channels.md
msgid "Channels"
msgstr "Canale"

#: src/SUMMARY.md src/concurrency/channels/senders-receivers.md
#, fuzzy
msgid "Senders and Receivers"
msgstr "Expeditori 탳i destinatari"

#: src/SUMMARY.md src/concurrency/channels/unbounded.md
msgid "Unbounded Channels"
msgstr "Canale nerestric탵ionate"

#: src/SUMMARY.md src/concurrency/channels/bounded.md
msgid "Bounded Channels"
msgstr "Canale delimitate"

#: src/SUMMARY.md src/concurrency/send-sync.md
msgid "`Send` and `Sync`"
msgstr "`Send` 탳i `Sync`"

#: src/SUMMARY.md src/concurrency/send-sync/marker-traits.md
#, fuzzy
msgid "Marker Traits"
msgstr "Mai multe tr캒s캒turi"

#: src/SUMMARY.md src/concurrency/send-sync/send.md
msgid "`Send`"
msgstr "Trimitere (send)"

#: src/SUMMARY.md src/concurrency/send-sync/sync.md
msgid "`Sync`"
msgstr "Sincronizare (sync)"

#: src/SUMMARY.md src/concurrency/send-sync/examples.md
msgid "Examples"
msgstr "Exemple"

#: src/SUMMARY.md src/concurrency/shared-state.md
msgid "Shared State"
msgstr "Statut comun"

#: src/SUMMARY.md src/concurrency/shared-state/arc.md
msgid "`Arc`"
msgstr "`Arc`"

#: src/SUMMARY.md src/concurrency/shared-state/mutex.md
msgid "`Mutex`"
msgstr "`Mutex`"

#: src/SUMMARY.md src/memory-management/review.md
#: src/error-handling/try-conversions.md
#: src/concurrency/shared-state/example.md
msgid "Example"
msgstr "Exemplu"

#: src/SUMMARY.md src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/sync-exercises/solutions.md
msgid "Dining Philosophers"
msgstr "Filozofii la mas캒"

#: src/SUMMARY.md src/concurrency/sync-exercises/link-checker.md
msgid "Multi-threaded Link Checker"
msgstr "Verificator de leg캒turi cu mai multe fire de execu탵ie"

#: src/SUMMARY.md
msgid "Concurrency: Afternoon"
msgstr "Concuren탵캒: Dup캒-amiaz캒"

#: src/SUMMARY.md src/concurrency/async.md
msgid "Async Basics"
msgstr "Bazele Async"

#: src/SUMMARY.md src/concurrency/async/async-await.md
msgid "`async`/`await`"
msgstr "async/await"

#: src/SUMMARY.md src/concurrency/async/futures.md
msgid "Futures"
msgstr "Futures"

#: src/SUMMARY.md src/concurrency/async/runtimes.md
#, fuzzy
msgid "Runtimes"
msgstr "Timpi de execu탵ie"

#: src/SUMMARY.md src/concurrency/async/runtimes/tokio.md
msgid "Tokio"
msgstr "Tokio"

#: src/SUMMARY.md src/concurrency/sync-exercises/link-checker.md
#: src/concurrency/async/tasks.md src/concurrency/async-exercises/chat-app.md
msgid "Tasks"
msgstr "Task-uri"

#: src/SUMMARY.md src/concurrency/async-control-flow.md
#, fuzzy
msgid "Channels and Control Flow"
msgstr "Fluxul de control"

#: src/SUMMARY.md src/concurrency/async-control-flow/channels.md
msgid "Async Channels"
msgstr "Canale asincrone"

#: src/SUMMARY.md src/concurrency/async-control-flow/join.md
msgid "Join"
msgstr "Al캒turare (join)"

#: src/SUMMARY.md src/concurrency/async-control-flow/select.md
msgid "Select"
msgstr "Selec탵ie (select)"

#: src/SUMMARY.md src/concurrency/async-pitfalls.md
msgid "Pitfalls"
msgstr "Capcane"

#: src/SUMMARY.md
msgid "Blocking the Executor"
msgstr "Blocarea executorului"

#: src/SUMMARY.md src/concurrency/async-pitfalls/pin.md
msgid "`Pin`"
msgstr "`Pin`"

#: src/SUMMARY.md src/concurrency/async-pitfalls/async-traits.md
msgid "Async Traits"
msgstr "Tr캒s캒turi asincrone"

#: src/SUMMARY.md src/concurrency/async-pitfalls/cancellation.md
msgid "Cancellation"
msgstr "Anulare"

#: src/SUMMARY.md src/concurrency/async-exercises/chat-app.md
#: src/concurrency/async-exercises/solutions.md
msgid "Broadcast Chat Application"
msgstr "Aplica탵ie de chat cu difuzare"

#: src/SUMMARY.md
msgid "Final Words"
msgstr "Ultimele cuvinte"

#: src/SUMMARY.md src/thanks.md
msgid "Thanks!"
msgstr "Va multumim !"

#: src/SUMMARY.md src/glossary.md
msgid "Glossary"
msgstr "Glosar"

#: src/SUMMARY.md
msgid "Other Resources"
msgstr "Alte resurse"

#: src/SUMMARY.md src/credits.md
msgid "Credits"
msgstr "Credite"

#: src/index.md
msgid ""
"[![Build workflow](https://img.shields.io/github/actions/workflow/status/"
"google/comprehensive-rust/build.yml?style=flat-square)](https://github.com/"
"google/comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain) [!"
"[GitHub contributors](https://img.shields.io/github/contributors/google/"
"comprehensive-rust?style=flat-square)](https://github.com/google/"
"comprehensive-rust/graphs/contributors) [![GitHub stars](https://img.shields."
"io/github/stars/google/comprehensive-rust?style=flat-square)](https://github."
"com/google/comprehensive-rust/stargazers)"
msgstr ""
"[![Fluxul de construc탵ie](https://img.shields.io/github/actions/workflow/"
"status/google/comprehensive-rust/build.yml?style=flat-square)](https://"
"github.com/google/comprehensive-rust/actions/workflows/build.yml?"
"query=branch%3Amain) [![Contribuitori GitHub](https://img.shields.io/github/"
"contributors/google/comprehensive-rust?style=flat-square)](https://github."
"com/google/comprehensive-rust/graphs/contributors) [![Stele GitHub](https://"
"img.shields.io/github/stars/google/comprehensive-rust?style=flat-square)]"
"(https://github.com/google/comprehensive-rust/stargazers)"

#: src/index.md
msgid ""
"This is a free Rust course developed by the Android team at Google. The "
"course covers the full spectrum of Rust, from basic syntax to advanced "
"topics like generics and error handling."
msgstr ""
"Acesta este un curs gratuit de Rust dezvoltat de echipa Android de la "
"Google. Cursul acoper캒 칥ntregul spectru Rust, de la sintaxa de baz캒 p칙n캒 la "
"subiecte avansate, cum ar fi genericele 탳i gestionarea erorilor."

#: src/index.md
msgid ""
"The latest version of the course can be found at <https://google.github.io/"
"comprehensive-rust/>. If you are reading somewhere else, please check there "
"for updates."
msgstr ""
"Cea mai recent캒 versiune a cursului poate fi g캒sit캒 la adresa <https://"
"google.github.io/comprehensive-rust/>. Dac캒 citi탵i 칥n alt캒 parte, v캒 rug캒m "
"s캒 verifica탵i acolo pentru actualiz캒ri."

#: src/index.md
#, fuzzy
msgid "The course is also available [as a PDF](comprehensive-rust.pdf)."
msgstr ""
"Cursul este, de asemenea, disponibil [칥n format PDF](comprehensive-rust.pdf)."

#: src/index.md
msgid ""
"The goal of the course is to teach you Rust. We assume you don't know "
"anything about Rust and hope to:"
msgstr ""
"Scopul cursului este de a v캒 칥nv캒탵a Rust. Presupunem c캒 nu 탳ti탵i nimic "
"despre Rust 탳i, la sf칙r탳it, sper캒m s캒:"

#: src/index.md
msgid "Give you a comprehensive understanding of the Rust syntax and language."
msgstr "Ave탵i o 칥n탵elegere cuprinz캒toare a sintaxei 탳i a limbajului Rust."

#: src/index.md
msgid "Enable you to modify existing programs and write new programs in Rust."
msgstr ""
"Pute탵i s캒 modifica탵i programele existente 탳i s캒 scrie탵i programe noi 칥n Rust."

#: src/index.md
msgid "Show you common Rust idioms."
msgstr "Cunoa탳te탵i expresii uzuale din Rust."

#: src/index.md
msgid "We call the first four course days Rust Fundamentals."
msgstr "Primele patru zile de curs se numesc Fundamentele Rust."

#: src/index.md
msgid ""
"Building on this, you're invited to dive into one or more specialized topics:"
msgstr ""
"Pornind de la acestea, sunte탵i invita탵i s캒 aprofunda탵i unul sau mai multe "
"subiecte specializate:"

#: src/index.md
msgid ""
"[Android](android.md): a half-day course on using Rust for Android platform "
"development (AOSP). This includes interoperability with C, C++, and Java."
msgstr ""
"[Android](android.md): un curs de o jum캒tate de zi despre utilizarea Rust "
"pentru dezvoltarea platformei Android (AOSP). Acesta include "
"interoperabilitatea cu C, C++ 탳i Java."

#: src/index.md
msgid ""
"[Chromium](chromium.md): a half-day course on using Rust within Chromium "
"based browsers. This includes interoperability with C++ and how to include "
"third-party crates in Chromium."
msgstr ""
"[Chromium](chromium.md): un curs de o jum캒tate de zi despre utilizarea Rust "
"pentru navigatoarele bazate pe Chromium. Acesta include interoperabilitatea "
"cu C++ 탳i  utilizarea crate-urilor ter탵e 칥n Chromium."

#: src/index.md
msgid ""
"[Bare-metal](bare-metal.md): a whole-day class on using Rust for bare-metal "
"(embedded) development. Both microcontrollers and application processors are "
"covered."
msgstr ""
"[Bare-metal](bare-metal.md): un curs de o zi 칥ntreag캒 despre utilizarea Rust "
"pentru dezvoltarea bare-metal (칥ncorporat캒). Sunt acoperite at칙t "
"microcontrolerele, c칙t 탳i procesoarele de aplica탵ii."

#: src/index.md
msgid ""
"[Concurrency](concurrency.md): a whole-day class on concurrency in Rust. We "
"cover both classical concurrency (preemptively scheduling using threads and "
"mutexes) and async/await concurrency (cooperative multitasking using "
"futures)."
msgstr ""
"[Concurrency](concurrency.md): un curs de o zi 칥ntreag캒 despre concuren탵a 칥n "
"Rust. Acoperim at칙t concuren탵a clasic캒 (programarea preemptiv캒 folosind fire "
"de execu탵ie 탳i mutexuri), c칙t 탳i concuren탵a async/await (multitasking "
"cooperativ folosind futures)."

#: src/index.md
msgid "Non-Goals"
msgstr "Alte obiective dec칙t cele de baz캒"

#: src/index.md
msgid ""
"Rust is a large language and we won't be able to cover all of it in a few "
"days. Some non-goals of this course are:"
msgstr ""
"Rust este un limbaj mare 탳i nu vom putea acoperi toate aspectele 칥n c칙teva "
"zile. C칙teva dintre non-obiectivele acestui curs sunt:"

#: src/index.md
msgid ""
"Learning how to develop macros: please see [Chapter 20.5 in the Rust Book]"
"(https://doc.rust-lang.org/book/ch20-05-macros.html) and [Rust by Example]"
"(https://doc.rust-lang.org/rust-by-example/macros.html) instead."
msgstr ""
"칉nv캒탵area modului de dezvoltare a macrocomenzilor: v캒 rug캒m s캒 consulta탵i 칥n "
"schimb [Capitolul 20.5 din Rust Book](https://doc.rust-lang.org/book/ch20-05-"
"macros.html) 탳i [Rust by Example](https://doc.rust-lang.org/rust-by-example/"
"macros.html)."

#: src/index.md
msgid "Assumptions"
msgstr "Ipoteze"

#: src/index.md
msgid ""
"The course assumes that you already know how to program. Rust is a "
"statically-typed language and we will sometimes make comparisons with C and "
"C++ to better explain or contrast the Rust approach."
msgstr ""
"Cursul porne탳te de la premisa c캒 탳ti탵i deja s캒 programa탵i. Rust este un "
"limbaj cu tipare static캒 탳i uneori vom face compara탵ii cu C 탳i C++ pentru a "
"explica mai bine sau a contrasta abordarea Rust."

#: src/index.md
msgid ""
"If you know how to program in a dynamically-typed language such as Python or "
"JavaScript, then you will be able to follow along just fine too."
msgstr ""
"Dac캒 탳ti탵i s캒 programa탵i 칥ntr-un limbaj cu tipuri dinamice, cum ar fi Python "
"sau JavaScript, atunci ve탵i putea s캒 v캒 descurca탵i foarte bine."

#: src/index.md
msgid ""
"This is an example of a _speaker note_. We will use these to add additional "
"information to the slides. This could be key points which the instructor "
"should cover as well as answers to typical questions which come up in class."
msgstr ""
"Acesta este un exemplu de _noti탵e pentru prezentator_. Le vom folosi pentru "
"a ad캒uga informa탵ii suplimentare la diapozitive. Acestea pot fi puncte cheie "
"pe care instructorul ar trebui s캒 le abordeze, precum 탳i r캒spunsuri la "
"칥ntreb캒ri tipice care apar 칥n clas캒."

#: src/running-the-course.md src/running-the-course/course-structure.md
msgid "This page is for the course instructor."
msgstr "Aceast캒 pagin캒 este destinat캒 instructorului de curs."

#: src/running-the-course.md
msgid ""
"Here is a bit of background information about how we've been running the "
"course internally at Google."
msgstr ""
"Iat캒 c칙teva informa탵ii de fond despre modul 칥n care am desf캒탳urat cursul 칥n "
"cadrul Google."

#: src/running-the-course.md
msgid ""
"We typically run classes from 9:00 am to 4:00 pm, with a 1 hour lunch break "
"in the middle. This leaves 3 hours for the morning class and 3 hours for the "
"afternoon class. Both sessions contain multiple breaks and time for students "
"to work on exercises."
msgstr ""
"De obicei, cursurile se desf캒탳oar캒 칥ntre orele 9:00 탳i 16:00, cu o pauz캒 de "
"mas캒 de o or캒 la mijloc. Astfel, r캒m칙n 3 ore pentru cursul de diminea탵캒 탳i 3 "
"ore pentru cursul de dup캒-amiaz캒. Ambele sesiuni includ multiple pauze "
"pentru a le permite cursan탵ilor s캒 lucreze la exerci탵ii."

#: src/running-the-course.md
msgid "Before you run the course, you will want to:"
msgstr "칉nainte de a parcurge cursul, ve탵i dori s캒:"

#: src/running-the-course.md
msgid ""
"Make yourself familiar with the course material. We've included speaker "
"notes to help highlight the key points (please help us by contributing more "
"speaker notes!). When presenting, you should make sure to open the speaker "
"notes in a popup (click the link with a little arrow next to \"Speaker "
"Notes\"). This way you have a clean screen to present to the class."
msgstr ""
"V캒 familiariza탵i cu materialul de curs. Am inclus note ale vorbitorului "
"pentru a eviden탵ia punctele cheie (v캒 rug캒m s캒 ne ajuta탵i contribuind cu mai "
"multe note pentru prezentare!). Atunci c칙nd prezenta탵i, asigura탵i-v캒 c캒 "
"deschide탵i notele prezentatorului 칥ntr-o fereastr캒 pop-up (face탵i clic pe "
"link-ul cu o s캒geat캒 mic캒 de l칙ng캒 \"Speaker Notes\"). 칉n acest fel, ve탵i "
"avea un ecran curat pentru a prezenta 칥n fa탵a clasei."

#: src/running-the-course.md
msgid ""
"Decide on the dates. Since the course takes four days, we recommend that you "
"schedule the days over two weeks. Course participants have said that they "
"find it helpful to have a gap in the course since it helps them process all "
"the information we give them."
msgstr ""
"Decide탵i datele. Deoarece cursul dureaz캒 patru zile\\i, v캒 recomand캒m s캒 "
"programa탵i zilele pe parcursul a dou캒 s캒pt캒m칙ni. Participan탵ii la curs au "
"spus c캒 li se pare util s캒 existe un interval 칥n timpul cursului, deoarece "
"칥i ajut캒 s캒 proceseze toate informa탵iile pe care le oferim."

#: src/running-the-course.md
msgid ""
"Find a room large enough for your in-person participants. We recommend a "
"class size of 15-25 people. That's small enough that people are comfortable "
"asking questions --- it's also small enough that one instructor will have "
"time to answer the questions. Make sure the room has _desks_ for yourself "
"and for the students: you will all need to be able to sit and work with your "
"laptops. In particular, you will be doing a lot of live-coding as an "
"instructor, so a lectern won't be very helpful for you."
msgstr ""
"G캒si탵i o sal캒 suficient de mare pentru participan탵ii prezen탵i. V캒 recomand캒m "
"o clas캒 de 15-25 de persoane. Este suficient de mic캒 pentru ca oamenii s캒 se "
"simt캒 confortabil s캒 pun캒 칥ntreb캒ri --- este, de asemenea, suficient de mic캒 "
"pentru ca un instructor s캒 aib캒 timp s캒 r캒spund캒 la 칥ntreb캒ri. Asigura탵i-v캒 "
"c캒 sala are _locuri/birouri pentru dumneavoastr캒 탳i pentru studen탵i: cu "
"to탵ii ve탵i avea nevoie s캒 pute탵i sta jos 탳i s캒 lucra탵i cu laptopurile. 칉n "
"special, 칥n calitate de instructor, ve탵i face o mul탵ime de live-coding, a탳a "
"c캒 un pupitru nu v캒 va fi de mare ajutor."

#: src/running-the-course.md
msgid ""
"On the day of your course, show up to the room a little early to set things "
"up. We recommend presenting directly using `mdbook serve` running on your "
"laptop (see the [installation instructions](https://github.com/google/"
"comprehensive-rust#building)). This ensures optimal performance with no lag "
"as you change pages. Using your laptop will also allow you to fix typos as "
"you or the course participants spot them."
msgstr ""
"Ajunge탵i 칥n sal캒 cu suficient timp 칥nainte pentru a preg캒ti totul. V캒 "
"recomand캒m s캒 prezenta탵i direct folosind `mdbook serve` care ruleaz캒 pe "
"laptopul dumneavoastr캒 (consulta탵i [instruc탵iuni de instalare](https://"
"github.com/google/comprehensive-rust#building)). Acest lucru asigur캒 o "
"performan탵캒 optim캒, f캒r캒 칥nt칙rzieri 칥n timp ce schimba탵i paginile. Folosirea "
"laptopului v캒 va permite, de asemenea, s캒 corecta탵i gre탳elile de tipar pe "
"m캒sur캒 ce dumneavoastr캒 sau participan탵ii la curs le descoperi탵i."

#: src/running-the-course.md
msgid ""
"Let people solve the exercises by themselves or in small groups. We "
"typically spend 30-45 minutes on exercises in the morning and in the "
"afternoon (including time to review the solutions). Make sure to ask people "
"if they're stuck or if there is anything you can help with. When you see "
"that several people have the same problem, call it out to the class and "
"offer a solution, e.g., by showing people where to find the relevant "
"information in the standard library."
msgstr ""
"L캒sa탵i participan탵ii s캒 rezolve exerci탵iile singuri sau 칥n grupuri mici. 칉n "
"mod obi탳nuit, dedic캒m 30-45 de minute exerci탵iilor diminea탵a 탳i dup캒-amiaza "
"(inclusiv timpul necesar pentru revizuirea solu탵iilor). Asigura탵i-v캒 c캒 칥i "
"칥ntreba탵i pe cursan탵i dac캒 s-au blocat sau dac캒 exist캒 ceva cu care 칥i "
"pute탵i ajuta. C칙nd vede탵i c캒 mai multe persoane au aceea탳i problem캒, "
"anun탵a탵i clasa 탳i oferi탵i o solu탵ie, de exemplu, ar캒t칙nd unde se pot g캒si "
"informa탵iile relevante 칥n biblioteca standard."

#: src/running-the-course.md
msgid ""
"That is all, good luck running the course! We hope it will be as much fun "
"for you as it has been for us!"
msgstr ""
"Asta e tot, mult succes 칥n prezentarea cursului! Sper캒m c캒 va fi la fel de "
"distractiv pentru voi cum a fost pentru noi!"

#: src/running-the-course.md
msgid ""
"Please [provide feedback](https://github.com/google/comprehensive-rust/"
"discussions/86) afterwards so that we can keep improving the course. We "
"would love to hear what worked well for you and what can be made better. "
"Your students are also very welcome to [send us feedback](https://github.com/"
"google/comprehensive-rust/discussions/100)!"
msgstr ""
"V캒 rug캒m s캒 [oferi탵i sugestii](https://github.com/google/comprehensive-rust/"
"discussions/86) dup캒 aceea, astfel 칥nc칙t s캒 putem 칥mbun캒t캒탵i cursul. Dorim "
"s캒 afl캒m ce a func탵ionat bine pentru dumneavoastr캒 탳i ce putem 칥mbun캒t캒탵i. "
"Studen탵ii dumneavoastr캒 sunt, de asemenea, foarte bineveni탵i s캒 [ne trimit캒 "
"feedback](https://github.com/google/comprehensive-rust/discussions/100)!"

#: src/running-the-course/course-structure.md
msgid "Rust Fundamentals"
msgstr "Fundamentele Rust"

#: src/running-the-course/course-structure.md
msgid ""
"The first four days make up [Rust Fundamentals](../welcome-day-1.md). The "
"days are fast paced and we cover a lot of ground!"
msgstr ""
"Primele patru zile alc캒tuiesc [Fundamentele Rust](../welcome-day-1.md). "
"Cursul se desf캒탳oar캒 칥ntr-un ritm rapid 탳i acoperim o mul탵ime de subiecte!"

#: src/running-the-course/course-structure.md
msgid "Course schedule:"
msgstr "Programul cursului:"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "Day 1 Morning (2 hours and 5 minutes, including breaks)"
msgstr "Ziua 3 Diminea탵a (2 ore 탳i 15 minute, inclusiv pauzele)"

#: src/running-the-course/course-structure.md
msgid "[Welcome](../welcome-day-1.md) (5 minutes)"
msgstr "[Introducere](../welcome-day-1.md) (5 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Hello, World](../hello-world.md) (15 minutes)"
msgstr "[Hello, World](../hello-world.md) (20 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Types and Values](../types-and-values.md) (40 minutes)"
msgstr "[Tipuri 탳i valori](../types-and-values.md) (1 or캒 탳i 5 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Control Flow Basics](../control-flow-basics.md) (40 minutes)"
msgstr "[Bazele fluxului de control](../control-flow-basics.md) (1 or캒)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "Day 1 Afternoon (2 hours and 35 minutes, including breaks)"
msgstr "Ziua 1 Dup캒-amiaza (2 ore 탳i 55 de minute, inclusiv pauzele)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Tuples and Arrays](../tuples-and-arrays.md) (35 minutes)"
msgstr "[Tupluri 탳i array-uri](../tupluri-탳i-array-uri.md) (1 or캒)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[References](../references.md) (55 minutes)"
msgstr "[Referin탵e](../references.md) (50 minute)"

#: src/running-the-course/course-structure.md
msgid "[User-Defined Types](../user-defined-types.md) (50 minutes)"
msgstr "[Tipuri definite de utilizator](../user-defined-types.md) (50 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "Day 2 Morning (2 hours and 10 minutes, including breaks)"
msgstr "Ziua 2 Diminea탵a (3 ore 탳i 5 minute, inclusiv pauzele)"

#: src/running-the-course/course-structure.md
msgid "[Welcome](../welcome-day-2.md) (3 minutes)"
msgstr "[Introducere](../welcome-day-2.md) (3 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Pattern Matching](../pattern-matching.md) (1 hour)"
msgstr "[Potrivirea 탳abloanelor](../pattern-matching.md) (50 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Methods and Traits](../methods-and-traits.md) (50 minutes)"
msgstr "[Metode 탳i tr캒s캒turi](../methods-and-traits.md) (55 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "Day 2 Afternoon (4 hours, including breaks)"
msgstr "Ziua 3 Dup캒-amiaza (2 ore 탳i 20 de minute, inclusiv pauzele)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Generics](../generics.md) (40 minutes)"
msgstr "[Generice](../generics.md) (45 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Standard Library Types](../std-types.md) (1 hour and 20 minutes)"
msgstr "[Tipuri de bibliotec캒 standard](../std-types.md) (1 or캒 탳i 10 minute)"

#: src/running-the-course/course-structure.md
msgid "[Standard Library Traits](../std-traits.md) (1 hour and 40 minutes)"
msgstr ""
"[Tr캒s캒turi ale bibliotecii standard](../std-traits.md) (1 or캒 탳i 40 de "
"minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "Day 3 Morning (2 hours and 20 minutes, including breaks)"
msgstr "Ziua 3 Diminea탵a (2 ore 탳i 15 minute, inclusiv pauzele)"

#: src/running-the-course/course-structure.md
msgid "[Welcome](../welcome-day-3.md) (3 minutes)"
msgstr "[Introducere](../welcome-day-3.md) (3 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Memory Management](../memory-management.md) (1 hour)"
msgstr "[Managementul memoriei](../memory-management.md) (1 or캒 탳i 10 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Smart Pointers](../smart-pointers.md) (55 minutes)"
msgstr "[Pointeri inteligen탵i](../smart-pointers.md) (45 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "Day 3 Afternoon (1 hour and 55 minutes, including breaks)"
msgstr "Ziua 3 Dup캒-amiaza (2 ore 탳i 20 de minute, inclusiv pauzele)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Borrowing](../borrowing.md) (55 minutes)"
msgstr "[칉mprumut](../칥mprumut.md) (1 or캒)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Lifetimes](../lifetimes.md) (50 minutes)"
msgstr "[Referin탵e](../references.md) (50 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "Day 4 Morning (2 hours and 40 minutes, including breaks)"
msgstr "Ziua 4 Diminea탵a (3 ore 탳i 5 minute, inclusiv pauzele)"

#: src/running-the-course/course-structure.md
msgid "[Welcome](../welcome-day-4.md) (3 minutes)"
msgstr "[Intorducere](../welcome-day-4.md) (3 minute)"

#: src/running-the-course/course-structure.md
msgid "[Iterators](../iterators.md) (45 minutes)"
msgstr "[Iteratori](../iteratori.md) (45 minute)"

#: src/running-the-course/course-structure.md
msgid "[Modules](../modules.md) (40 minutes)"
msgstr "[Module](../modules.md) (40 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Testing](../testing.md) (45 minutes)"
msgstr "[Testare](../testing.md) (1 or캒 탳i 5 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "Day 4 Afternoon (2 hours and 10 minutes, including breaks)"
msgstr "Ziua 3 Dup캒-amiaza (2 ore 탳i 20 de minute, inclusiv pauzele)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Error Handling](../error-handling.md) (55 minutes)"
msgstr "[Gestionarea erorilor](../error-handling.md) (45 minute)"

#: src/running-the-course/course-structure.md
msgid "[Unsafe Rust](../unsafe-rust.md) (1 hour and 5 minutes)"
msgstr "[Unsafe Rust](../unsafe-rust.md) (1 or캒 탳i 5 minute)"

#: src/running-the-course/course-structure.md
msgid "Deep Dives"
msgstr "Subiecte  aprofundate"

#: src/running-the-course/course-structure.md
msgid ""
"In addition to the 4-day class on Rust Fundamentals, we cover some more "
"specialized topics:"
msgstr ""
"칉n plus fa탵캒 de cursul de 4 zile despre fundamentele Rust, abord캒m c칙teva "
"subiecte mai specializate:"

#: src/running-the-course/course-structure.md
msgid "Rust in Android"
msgstr "Rust 칥n Android"

#: src/running-the-course/course-structure.md
msgid ""
"The [Rust in Android](../android.md) deep dive is a half-day course on using "
"Rust for Android platform development. This includes interoperability with "
"C, C++, and Java."
msgstr ""
"[Rust 칥n Android](../android.md) este un curs de o jum캒tate de zi despre "
"utilizarea Rust pentru dezvoltarea platformei Android. Acesta include "
"interoperabilitatea cu C, C++ 탳i Java."

#: src/running-the-course/course-structure.md
msgid ""
"You will need an [AOSP checkout](https://source.android.com/docs/setup/"
"download/downloading). Make a checkout of the [course repository](https://"
"github.com/google/comprehensive-rust) on the same machine and move the `src/"
"android/` directory into the root of your AOSP checkout. This will ensure "
"that the Android build system sees the `Android.bp` files in `src/android/`."
msgstr ""
"Ve탵i avea nevoie de un [sursele AOSP](https://source.android.com/docs/setup/"
"download/downloading). Efectua탵i o desc캒rcare a [resurselor cursului]"
"(https://github.com/google/comprehensive-rust) pe aceea탳i ma탳in캒 탳i muta탵i "
"directorul `src/android/` 칥n r캒d캒cina surselor AOSP. Acest lucru va asigura "
"c캒 sistemul de compilare Android vede fi탳ierele `Android.bp` din `src/"
"android/`."

#: src/running-the-course/course-structure.md
msgid ""
"Ensure that `adb sync` works with your emulator or real device and pre-build "
"all Android examples using `src/android/build_all.sh`. Read the script to "
"see the commands it runs and make sure they work when you run them by hand."
msgstr ""
"Asigura탵i-v캒 c캒 `adb sync` func탵ioneaz캒 cu emulatorul sau cu dispozitivul "
"real 탳i precompila탵i toate exemplele Android folosind `src/android/build_all."
"sh`. Citi탵i scriptul pentru a vedea comenzile pe care le execut캒 탳i "
"asigura탵i-v캒 c캒 acestea func탵ioneaz캒 atunci c칙nd le executa탵i manual."

#: src/running-the-course/course-structure.md
msgid "Rust in Chromium"
msgstr "Rust 칥n Chromium"

#: src/running-the-course/course-structure.md
msgid ""
"The [Rust in Chromium](../chromium.md) deep dive is a half-day course on "
"using Rust as part of the Chromium browser. It includes using Rust in "
"Chromium's `gn` build system, bringing in third-party libraries (\"crates\") "
"and C++ interoperability."
msgstr ""
"[Rust 칥n Chromium](../chromium.md) este un curs aprofundat de o jum캒tate de "
"zi despre utilizarea Rust ca parte a browserului Chromium. Acesta include "
"utilizarea Rust 칥n sistemul de compilare `gn` al Chromium, aducerea de "
"biblioteci ter탵e (\"crates\") 탳i interoperabilitatea C++."

#: src/running-the-course/course-structure.md
msgid ""
"You will need to be able to build Chromium --- a debug, component build is "
"[recommended](../chromium/setup.md) for speed but any build will work. "
"Ensure that you can run the Chromium browser that you've built."
msgstr ""
"Va trebui s캒 pute탵i construi Chromium --- este [recomandat](../chromium/"
"setup.md) un build de depanare, de componente pentru vitez캒, dar orice build "
"va func탵iona. Asigura탵i-v캒 c캒 pute탵i rula browserul Chromium pe care l-a탵i "
"construit."

#: src/running-the-course/course-structure.md
msgid "Bare-Metal Rust"
msgstr "Rust direct pe plac캒"

#: src/running-the-course/course-structure.md
msgid ""
"The [Bare-Metal Rust](../bare-metal.md) deep dive is a full day class on "
"using Rust for bare-metal (embedded) development. Both microcontrollers and "
"application processors are covered."
msgstr ""
"[Rust direct pe plac캒](../bare-metal.md) este un curs de o zi 칥ntreag캒 "
"despre utilizarea Rust pentru dezvoltarea bare-metal (embedded). Sunt "
"acoperite at칙t microcontrolerele, c칙t 탳i procesoarele de aplica탵ii."

#: src/running-the-course/course-structure.md
msgid ""
"For the microcontroller part, you will need to buy the [BBC micro:bit]"
"(https://microbit.org/) v2 development board ahead of time. Everybody will "
"need to install a number of packages as described on the [welcome page](../"
"bare-metal.md)."
msgstr ""
"Pentru partea de microcontroler, va trebui s캒 cump캒ra탵i din timp placa de "
"dezvoltare [BBC micro:bit](https://microbit.org/) v2. Toat캒 lumea va trebui "
"s캒 instaleze o serie de pachete, a탳a cum este descris pe [pagina de bun "
"venit](../bare-metal.md)."

#: src/running-the-course/course-structure.md
msgid "Concurrency in Rust"
msgstr "Concuren탵캒 칥n Rust"

#: src/running-the-course/course-structure.md
msgid ""
"The [Concurrency in Rust](../concurrency.md) deep dive is a full day class "
"on classical as well as `async`/`await` concurrency."
msgstr ""
"[Concuren탵a 칥n Rust] (../concurrency.md) este un curs de o zi 칥ntreag캒 "
"despre concuren탵a clasic캒, precum 탳i despre concuren탵a `async`/`await`."

#: src/running-the-course/course-structure.md
msgid ""
"You will need a fresh crate set up and the dependencies downloaded and ready "
"to go. You can then copy/paste the examples into `src/main.rs` to experiment "
"with them:"
msgstr ""
"Ve탵i avea nevoie de un nou crate configurat 탳i de dependen탵ele desc캒rcate 탳i "
"preg캒tite. Pute탵i apoi s캒 copia탵i exemplele 칥n `src/main.rs` pentru a "
"experimenta cu ele:"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "{{%course outline Concurrency}}"
msgstr "{{%course outline Concurrency}}"

#: src/running-the-course/course-structure.md
msgid "Format"
msgstr "Format"

#: src/running-the-course/course-structure.md
msgid ""
"The course is meant to be very interactive and we recommend letting the "
"questions drive the exploration of Rust!"
msgstr ""
"Cursul se dore탳te a fi foarte interactiv 탳i v캒 recomand캒m s캒 l캒sa탵i "
"칥ntreb캒rile s캒 conduc캒 explorarea Rust!"

#: src/running-the-course/keyboard-shortcuts.md
msgid "There are several useful keyboard shortcuts in mdBook:"
msgstr "칉n mdBook exist캒 mai multe comenzi rapide utile de la tastatur캒:"

#: src/running-the-course/keyboard-shortcuts.md
msgid "Arrow-Left"
msgstr "S캒geat캒-st칙nga"

#: src/running-the-course/keyboard-shortcuts.md
msgid ": Navigate to the previous page."
msgstr ": Naviga탵i la pagina anterioar캒."

#: src/running-the-course/keyboard-shortcuts.md
msgid "Arrow-Right"
msgstr "S캒geat캒-dreapta"

#: src/running-the-course/keyboard-shortcuts.md
msgid ": Navigate to the next page."
msgstr ": Naviga탵i la pagina urm캒toare."

#: src/running-the-course/keyboard-shortcuts.md src/cargo/code-samples.md
msgid "Ctrl + Enter"
msgstr "Ctrl + Enter"

#: src/running-the-course/keyboard-shortcuts.md
msgid ": Execute the code sample that has focus."
msgstr ": Executa탵i mostra de cod care are focusul."

#: src/running-the-course/keyboard-shortcuts.md
msgid "s"
msgstr "S"

#: src/running-the-course/keyboard-shortcuts.md
msgid ": Activate the search bar."
msgstr ": Activa탵i bara de c캒utare."

#: src/running-the-course/translations.md
msgid ""
"The course has been translated into other languages by a set of wonderful "
"volunteers:"
msgstr ""
"Cursul a fost tradus 칥n alte limbi de c캒tre o serie de voluntari minuna탵i:"

#: src/running-the-course/translations.md
msgid ""
"[Brazilian Portuguese](https://google.github.io/comprehensive-rust/pt-BR/) "
"by [@rastringer](https://github.com/rastringer), [@hugojacob](https://github."
"com/hugojacob), [@joaovicmendes](https://github.com/joaovicmendes), and "
"[@henrif75](https://github.com/henrif75)."
msgstr ""
"[Brazilian캒 portughez캒](https://google.github.io/comprehensive-rust/pt-BR/) "
"de [@rastringer](https://github.com/rastringer), [@hugojacob](https://github."
"com/hugojacob), [@joaovicmendes](https://github.com/joaovicmendes) 탳i "
"[@henrif75](https://github.com/henrif75)."

#: src/running-the-course/translations.md
msgid ""
"[Chinese (Simplified)](https://google.github.io/comprehensive-rust/zh-CN/) "
"by [@suetfei](https://github.com/suetfei), [@wnghl](https://github.com/"
"wnghl), [@anlunx](https://github.com/anlunx), [@kongy](https://github.com/"
"kongy), [@noahdragon](https://github.com/noahdragon), [@superwhd](https://"
"github.com/superwhd), [@SketchK](https://github.com/SketchK), and [@nodmp]"
"(https://github.com/nodmp)."
msgstr ""
"[Chinez캒 (simplificat캒)](https://google.github.io/comprehensive-rust/zh-CN/) "
"de [@suetfei](https://github.com/suetfei), [@wnghl](https://github.com/"
"wnghl), [@anlunx](https://github.com/anlunx), [@kongy](https://github.com/"
"kongy), [@noahdragon](https://github.com/noahdragon), [@superwhd](https://"
"github.com/superwhd), [@SketchK](https://github.com/SketchK), 탳i [@nodmp]"
"(https://github.com/nodmp)."

#: src/running-the-course/translations.md
msgid ""
"[Chinese (Traditional)](https://google.github.io/comprehensive-rust/zh-TW/) "
"by [@hueich](https://github.com/hueich), [@victorhsieh](https://github.com/"
"victorhsieh), [@mingyc](https://github.com/mingyc), [@kuanhungchen](https://"
"github.com/kuanhungchen), and [@johnathan79717](https://github.com/"
"johnathan79717)."
msgstr ""
"[Chinez캒 (tradi탵ional캒)](https://google.github.io/comprehensive-rust/zh-TW/) "
"de [@hueich](https://github.com/hueich), [@victorhsieh](https://github.com/"
"victorhsieh), [@mingyc](https://github.com/mingyc), [@kuanhungchen](https://"
"github.com/kuanhungchen), 탳i [@johnathan79717](https://github.com/"
"johnathan79717)."

#: src/running-the-course/translations.md
#, fuzzy
msgid ""
"[Korean](https://google.github.io/comprehensive-rust/ko/) by [@keispace]"
"(https://github.com/keispace), [@jiyongp](https://github.com/jiyongp), "
"[@jooyunghan](https://github.com/jooyunghan), and [@namhyung](https://github."
"com/namhyung)."
msgstr ""
"[Corean캒](https://google.github.io/comprehensive-rust/ko/) de [@keispace]"
"(https://github.com/keispace), [@jiyongp](https://github.com/jiyongp) 탳i "
"[@jooyunghan](https://github.com/jooyunghan)."

#: src/running-the-course/translations.md
msgid ""
"[Spanish](https://google.github.io/comprehensive-rust/es/) by [@deavid]"
"(https://github.com/deavid)."
msgstr ""
"[Spaniol캒](https://google.github.io/comprehensive-rust/es/) de [@deavid]"
"(https://github.com/deavid)."

#: src/running-the-course/translations.md
msgid ""
"Use the language picker in the top-right corner to switch between languages."
msgstr ""
"Utiliza탵i selectorul de limb캒 din col탵ul din dreapta sus pentru a comuta "
"칥ntre limbi."

#: src/running-the-course/translations.md
msgid "Incomplete Translations"
msgstr "Traduceri incomplete"

#: src/running-the-course/translations.md
msgid ""
"There is a large number of in-progress translations. We link to the most "
"recently updated translations:"
msgstr ""
"Exist캒 un num캒r mare de traduceri 칥n curs de realizare. Iat캒 cele mai "
"recente traduceri actualizate:"

#: src/running-the-course/translations.md
msgid ""
"[Bengali](https://google.github.io/comprehensive-rust/bn/) by [@raselmandol]"
"(https://github.com/raselmandol)."
msgstr ""
"[Bengalez캒](https://google.github.io/comprehensive-rust/bn/) de "
"[@raselmandol](https://github.com/raselmandol)."

#: src/running-the-course/translations.md
#, fuzzy
msgid ""
"[French](https://google.github.io/comprehensive-rust/fr/) by [@KookaS]"
"(https://github.com/KookaS), [@vcaen](https://github.com/vcaen) and "
"[@AdrienBaudemont](https://github.com/AdrienBaudemont)."
msgstr ""
"[Francez캒](https://google.github.io/comprehensive-rust/fr/) de [@KookaS]"
"(https://github.com/KookaS) 탳i [@vcaen](https://github.com/vcaen)."

#: src/running-the-course/translations.md
msgid ""
"[German](https://google.github.io/comprehensive-rust/de/) by [@Throvn]"
"(https://github.com/Throvn) and [@ronaldfw](https://github.com/ronaldfw)."
msgstr ""
"[German캒](https://google.github.io/comprehensive-rust/de/) de [@Throvn]"
"(https://github.com/Throvn) 탳i [@ronaldfw](https://github.com/ronaldfw)."

#: src/running-the-course/translations.md
msgid ""
"[Japanese](https://google.github.io/comprehensive-rust/ja/) by [@CoinEZ-JPN]"
"(https://github.com/CoinEZ) and [@momotaro1105](https://github.com/"
"momotaro1105)."
msgstr ""
"[Japonez캒](https://google.github.io/comprehensive-rust/ja/) de [@CoinEZ-JPN]"
"(https://github.com/CoinEZ) 탳i [@momotaro1105](https://github.com/"
"momotaro1105)."

#: src/running-the-course/translations.md
#, fuzzy
msgid ""
"[Italian](https://google.github.io/comprehensive-rust/it/) by "
"[@henrythebuilder](https://github.com/henrythebuilder) and [@detro](https://"
"github.com/detro)."
msgstr ""
"[German캒](https://google.github.io/comprehensive-rust/de/) de [@Throvn]"
"(https://github.com/Throvn) 탳i [@ronaldfw](https://github.com/ronaldfw)."

#: src/running-the-course/translations.md
msgid ""
"If you want to help with this effort, please see [our instructions](https://"
"github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md) for how to "
"get going. Translations are coordinated on the [issue tracker](https://"
"github.com/google/comprehensive-rust/issues/282)."
msgstr ""
"Dac캒 dori탵i s캒 contribui탵i la acest efort, v캒 rug캒m s캒 consulta탵i "
"[instruc탵iunile noastre](https://github.com/google/comprehensive-rust/blob/"
"main/TRANSLATIONS.md) pentru a afla cum s캒 칥ncepe탵i. Traducerile sunt "
"coordonate pe [issue tracker](https://github.com/google/comprehensive-rust/"
"issues/282)."

#: src/cargo.md
msgid ""
"When you start reading about Rust, you will soon meet [Cargo](https://doc."
"rust-lang.org/cargo/), the standard tool used in the Rust ecosystem to build "
"and run Rust applications. Here we want to give a brief overview of what "
"Cargo is and how it fits into the wider ecosystem and how it fits into this "
"training."
msgstr ""
"C칙nd 칥ncepe탵i s캒 citi탵i despre Rust, ve탵i face cuno탳tin탵캒 cu [Cargo](https://"
"doc.rust-lang.org/cargo/), instrumentul standard utilizat 칥n ecosistemul "
"Rust pentru a construi 탳i rula aplica탵ii Rust. Aici dorim s캒 oferim o scurt캒 "
"prezentare general캒 a ceea ce este Cargo 탳i a modului 칥n care se integreaz캒 "
"칥n ecosistemul mai larg 탳i cum se 칥ncadreaz캒 칥n acest curs de formare."

#: src/cargo.md
msgid "Installation"
msgstr "Instalare"

#: src/cargo.md
msgid "**Please follow the instructions on <https://rustup.rs/>.**"
msgstr "**V캒 rug캒m s캒 urma탵i instruc탵iunile de pe <https://rustup.rs/>.**"

#: src/cargo.md
msgid ""
"This will give you the Cargo build tool (`cargo`) and the Rust compiler "
"(`rustc`). You will also get `rustup`, a command line utility that you can "
"use to install to different compiler versions."
msgstr ""
"Astfel ve탵i avea acces la instrumentul de compilare Cargo (`cargo`) 탳i "
"compilatorul Rust (`rustc`). De asemenea, ve탵i ob탵ine `rustup`, un utilitar "
"de linie de comand캒 pe care 칥l pute탵i utiliza pentru a instala la diferite "
"versiuni de compilator."

#: src/cargo.md
msgid ""
"After installing Rust, you should configure your editor or IDE to work with "
"Rust. Most editors do this by talking to [rust-analyzer](https://rust-"
"analyzer.github.io/), which provides auto-completion and jump-to-definition "
"functionality for [VS Code](https://code.visualstudio.com/), [Emacs](https://"
"rust-analyzer.github.io/manual.html#emacs), [Vim/Neovim](https://rust-"
"analyzer.github.io/manual.html#vimneovim), and many others. There is also a "
"different IDE available called [RustRover](https://www.jetbrains.com/rust/)."
msgstr ""
"Dup캒 instalarea Rust, trebuie s캒 v캒 configura탵i editorul sau IDE-ul pentru a "
"lucra cu Rust. Majoritatea editorilor fac acest lucru comunic칙nd cu [rust-"
"analyzer](https://rust-analyzer.github.io/), care ofer캒 func탵ionalitate de "
"autocompletare 탳i de salt la defini탵ie pentru [VS Code](https://code."
"visualstudio.com/), [Emacs](https://rust-analyzer.github.io/manual."
"html#emacs), [Vim/Neovim](https://rust-analyzer.github.io/manual."
"html#vimneovim) 탳i multe altele. Exist캒, de asemenea, un alt IDE disponibil, "
"numit [RustRover](https://www.jetbrains.com/rust/)."

#: src/cargo.md
msgid ""
"On Debian/Ubuntu, you can also install Cargo, the Rust source and the [Rust "
"formatter](https://github.com/rust-lang/rustfmt) via `apt`. However, this "
"gets you an outdated rust version and may lead to unexpected behavior. The "
"command would be:"
msgstr ""
"Pe Debian/Ubuntu, pute탵i instala, de asemenea, Cargo, sursele Rust 탳i "
"[instrumentul de formatare Rust](https://github.com/rust-lang/rustfmt) prin "
"`apt`. Dar ve탵i avea acces la o versiune Rust 칥nvechit캒 care poate duce la "
"un comportament nea탳teptat. Comanda ar fi:"

#: src/cargo/rust-ecosystem.md
msgid "The Rust Ecosystem"
msgstr "Ecosistemul Rust"

#: src/cargo/rust-ecosystem.md
msgid ""
"The Rust ecosystem consists of a number of tools, of which the main ones are:"
msgstr ""
"Ecosistemul Rust este format dintr-un num캒r de instrumente, dintre care "
"principalele sunt:"

#: src/cargo/rust-ecosystem.md
msgid ""
"`rustc`: the Rust compiler which turns `.rs` files into binaries and other "
"intermediate formats."
msgstr ""
"`rustc`: compilatorul Rust care transform캒 fi탳ierele `.rs` 칥n fi탳iere binare "
"탳i alte formate intermediare."

#: src/cargo/rust-ecosystem.md
msgid ""
"`cargo`: the Rust dependency manager and build tool. Cargo knows how to "
"download dependencies, usually hosted on <https://crates.io>, and it will "
"pass them to `rustc` when building your project. Cargo also comes with a "
"built-in test runner which is used to execute unit tests."
msgstr ""
"`cargo`: managerul de dependen탵e Rust 탳i instrumentul de construc탵ie. Cargo "
"탳tie cum s캒 descarce dependen탵ele, de obicei g캒zduite pe <https://crates."
"io>, 탳i le va transmite la `rustc` atunci c칙nd v캒 construi탵i proiectul. "
"Cargo vine, de asemenea, cu un instrument de rulat testele 칥ncorporat care "
"este folosit pentru a executa testele unitare."

#: src/cargo/rust-ecosystem.md
msgid ""
"`rustup`: the Rust toolchain installer and updater. This tool is used to "
"install and update `rustc` and `cargo` when new versions of Rust are "
"released. In addition, `rustup` can also download documentation for the "
"standard library. You can have multiple versions of Rust installed at once "
"and `rustup` will let you switch between them as needed."
msgstr ""
"`rustup`: programul de instalare 탳i actualizare a lan탵ului de instrumente "
"Rust. Acest instrument este utilizat pentru a instala 탳i actualiza `rustc` "
"탳i `cargo` atunci c칙nd sunt lansate noi versiuni de Rust. 칉n plus, `rustup` "
"poate desc캒rca 탳i documenta탵ia pentru biblioteca standard. Pute탵i avea mai "
"multe versiuni de Rust instalate 칥n acela탳i timp, iar `rustup` v캒 va permite "
"s캒 trece탵i de la una la alta 칥n func탵ie de necesit캒탵i."

#: src/cargo/rust-ecosystem.md src/types-and-values/hello-world.md
#: src/references/exclusive.md src/memory-management/move.md
#: src/error-handling/try.md src/android/setup.md
#: src/concurrency/async/async-await.md
msgid "Key points:"
msgstr "Puncte-cheie:"

#: src/cargo/rust-ecosystem.md
msgid ""
"Rust has a rapid release schedule with a new release coming out every six "
"weeks. New releases maintain backwards compatibility with old releases --- "
"plus they enable new functionality."
msgstr ""
"Rust are un program de actualizare rapid캒, cu o nou캒 versiune la fiecare "
"탳ase s캒pt캒m칙ni. Noile versiuni men탵in compatibilitatea cu versiunile vechi "
"탳i adaug캒 noi func탵ionalit캒탵i."

#: src/cargo/rust-ecosystem.md
msgid ""
"There are three release channels: \"stable\", \"beta\", and \"nightly\"."
msgstr ""
"Exist캒 trei canale de actualizare: \"stable\", \"beta\" 탳i \"nightly\"."

#: src/cargo/rust-ecosystem.md
msgid ""
"New features are being tested on \"nightly\", \"beta\" is what becomes "
"\"stable\" every six weeks."
msgstr ""
"Noile caracteristici sunt testate pe \"nightly\", \"beta\" este ceea ce "
"devine \"stabil\" la fiecare 탳ase s캒pt캒m칙ni."

#: src/cargo/rust-ecosystem.md
msgid ""
"Dependencies can also be resolved from alternative [registries](https://doc."
"rust-lang.org/cargo/reference/registries.html), git, folders, and more."
msgstr ""
"De asemenea, dependen탵ele pot fi rezolvate din [registre](https://doc.rust-"
"lang.org/cargo/reference/registries.html) alternative, git, dosare 탳i altele."

#: src/cargo/rust-ecosystem.md
msgid ""
"Rust also has [editions](https://doc.rust-lang.org/edition-guide/): the "
"current edition is Rust 2021. Previous editions were Rust 2015 and Rust 2018."
msgstr ""
"Rust are, de asemenea, [edi탵ii](https://doc.rust-lang.org/edition-guide/): "
"edi탵ia curent캒 este Rust 2021. Edi탵iile anterioare au fost Rust 2015 탳i Rust "
"2018."

#: src/cargo/rust-ecosystem.md
msgid ""
"The editions are allowed to make backwards incompatible changes to the "
"language."
msgstr ""
"Noile edi탵iile au dreptul de a face modific캒ri ale limbajului incompatibile "
"cu versiuni mai vechi."

#: src/cargo/rust-ecosystem.md
msgid ""
"To prevent breaking code, editions are opt-in: you select the edition for "
"your crate via the `Cargo.toml` file."
msgstr ""
"Pentru a preveni stricarea codului, edi탵iile sunt op탵ionale: selecta탵i "
"edi탵ia pentru crate-ul dumneavoastr캒 prin intermediul fi탳ierului `Cargo."
"toml`."

#: src/cargo/rust-ecosystem.md
msgid ""
"To avoid splitting the ecosystem, Rust compilers can mix code written for "
"different editions."
msgstr ""
"Pentru a evita divizarea ecosistemului, compilatoarele Rust pot amesteca "
"coduri scrise pentru edi탵ii diferite."

#: src/cargo/rust-ecosystem.md
msgid ""
"Mention that it is quite rare to ever use the compiler directly not through "
"`cargo` (most users never do)."
msgstr ""
"Men탵ion캒m c캒 este destul de rar s캒 folosi탵i compilatorul direct 탳i nu prin "
"`cargo` (majoritatea utilizatorilor nu o fac niciodat캒)."

#: src/cargo/rust-ecosystem.md
msgid ""
"It might be worth alluding that Cargo itself is an extremely powerful and "
"comprehensive tool. It is capable of many advanced features including but "
"not limited to:"
msgstr ""
"Cargo este un instrument extrem de puternic 탳i cuprinz캒tor. Acesta are multe "
"caracteristici avansate, incluz칙nd:"

#: src/cargo/rust-ecosystem.md
msgid "Project/package structure"
msgstr "Structura proiectului/pachetului"

#: src/cargo/rust-ecosystem.md
msgid "[workspaces](https://doc.rust-lang.org/cargo/reference/workspaces.html)"
msgstr ""
"[spa탵ii de lucru](https://doc.rust-lang.org/cargo/reference/workspaces.html)"

#: src/cargo/rust-ecosystem.md
msgid "Dev Dependencies and Runtime Dependency management/caching"
msgstr ""
"Gestionarea/arhivarea dependen탵elor de dezvoltare 탳i a dependen탵elor de timp "
"de execu탵ie"

#: src/cargo/rust-ecosystem.md
msgid ""
"[build scripting](https://doc.rust-lang.org/cargo/reference/build-scripts."
"html)"
msgstr ""
"[scripturile de build](https://doc.rust-lang.org/cargo/reference/build-"
"scripts.html)"

#: src/cargo/rust-ecosystem.md
msgid ""
"[global installation](https://doc.rust-lang.org/cargo/commands/cargo-install."
"html)"
msgstr ""
"[instalarea global캒](https://doc.rust-lang.org/cargo/commands/cargo-install."
"html)"

#: src/cargo/rust-ecosystem.md
msgid ""
"It is also extensible with sub command plugins as well (such as [cargo "
"clippy](https://github.com/rust-lang/rust-clippy))."
msgstr ""
"Este, de asemenea, extensibil cu pluginuri de subcomand캒 (cum ar fi [cargo "
"clippy](https://github.com/rust-lang/rust-clippy))."

#: src/cargo/rust-ecosystem.md
msgid ""
"Read more from the [official Cargo Book](https://doc.rust-lang.org/cargo/)"
msgstr ""
"Citi탵i mai multe din [cartea oficial캒 Cargo](https://doc.rust-lang.org/"
"cargo/)"

#: src/cargo/code-samples.md
msgid "Code Samples in This Training"
msgstr "Exemple de cod 칥n aceast curs"

#: src/cargo/code-samples.md
msgid ""
"For this training, we will mostly explore the Rust language through examples "
"which can be executed through your browser. This makes the setup much easier "
"and ensures a consistent experience for everyone."
msgstr ""
"칉n cadrul acestui curs, vom explora limbajul Rust 칥n principal prin exemple "
"care pot fi executate prin intermediul browserului dumneavoastr캒. Acest "
"lucru face configurarea mult mai u탳oar캒 탳i asigur캒 o experien탵캒 coerent캒 "
"pentru toat캒 lumea."

#: src/cargo/code-samples.md
msgid ""
"Installing Cargo is still encouraged: it will make it easier for you to do "
"the exercises. On the last day, we will do a larger exercise which shows you "
"how to work with dependencies and for that you need Cargo."
msgstr ""
"Instalarea Cargo este 칥n continuare 칥ncurajat캒: v캒 va fi mai u탳or s캒 face탵i "
"exerci탵iile. 칉n ultima zi, vom face un exerci탵iu mai amplu care v캒 va ar캒ta "
"cum s캒 lucra탵i cu dependen탵ele 탳i pentru care ave탵i nevoie de Cargo."

#: src/cargo/code-samples.md
msgid "The code blocks in this course are fully interactive:"
msgstr "Blocurile de cod din acest curs sunt complet interactive:"

#: src/cargo/code-samples.md src/cargo/running-locally.md
msgid "\"Edit me!\""
msgstr "\"Editeaz캒-m캒!\""

#: src/cargo/code-samples.md
msgid "You can use "
msgstr "Pute탵i utiliza "

#: src/cargo/code-samples.md
msgid " to execute the code when focus is in the text box."
msgstr " pentru a executa codul atunci c칙nd focusul se afl캒 칥n caseta de text."

#: src/cargo/code-samples.md
msgid ""
"Most code samples are editable like shown above. A few code samples are not "
"editable for various reasons:"
msgstr ""
"Majoritatea mostrelor de cod sunt editabile, a탳a cum se arat캒 mai sus. "
"C칙teva mostre de cod nu sunt editabile din diverse motive:"

#: src/cargo/code-samples.md
msgid ""
"The embedded playgrounds cannot execute unit tests. Copy-paste the code and "
"open it in the real Playground to demonstrate unit tests."
msgstr ""
"Zonele de 칥ncercare 칥ncorporate nu pot executa teste unitare. Copia탵i 탳i "
"lipi탵i codul 탳i deschide탵i-l 칥n locul de zona de lucru local캒 pentru a "
"demonstra testele unitare."

#: src/cargo/code-samples.md
msgid ""
"The embedded playgrounds lose their state the moment you navigate away from "
"the page! This is the reason that the students should solve the exercises "
"using a local Rust installation or via the Playground."
msgstr ""
"Zonele de 칥ncercare 칥ncorporate 칥탳i pierd starea 칥n momentul 칥n care "
"naviga탵i 칥n afara paginii! Acesta este motivul pentru care elevii trebuie s캒 "
"rezolve exerci탵iile folosind o instalare local캒 de Rust sau prin intermediul "
"zonei de 칥ncercare."

#: src/cargo/running-locally.md
msgid "Running Code Locally with Cargo"
msgstr "Rularea codului la nivel local cu Cargo"

#: src/cargo/running-locally.md
msgid ""
"If you want to experiment with the code on your own system, then you will "
"need to first install Rust. Do this by following the [instructions in the "
"Rust Book](https://doc.rust-lang.org/book/ch01-01-installation.html). This "
"should give you a working `rustc` and `cargo`. At the time of writing, the "
"latest stable Rust release has these version numbers:"
msgstr ""
"Dac캒 dori탵i s캒 experimenta탵i cu codul pe propriul sistem, va trebui s캒 "
"instala탵i mai 칥nt칙i Rust. Face탵i acest lucru urm칙nd [instruc탵iunile din "
"Cartea Rust](https://doc.rust-lang.org/book/ch01-01-installation.html). Ve탵i "
"avea astfel un `rustc` 탳i un `cargo` func탵ional. La momentul scrierii "
"acestui articol, cea mai recent캒 versiune stabil캒 Rust are versiunea:"

#: src/cargo/running-locally.md
msgid ""
"You can use any later version too since Rust maintains backwards "
"compatibility."
msgstr ""
"Pute탵i utiliza 탳i orice versiune ulterioar캒, deoarece Rust p캒streaz캒 "
"compatibilitatea cu versiunile anterioare."

#: src/cargo/running-locally.md
msgid ""
"With this in place, follow these steps to build a Rust binary from one of "
"the examples in this training:"
msgstr ""
"Ulterior urma탵i ace탳ti pa탳i pentru a construi un binar Rust din unul dintre "
"exemplele din acest curs de instruire:"

#: src/cargo/running-locally.md
msgid "Click the \"Copy to clipboard\" button on the example you want to copy."
msgstr ""
"Ap캒sa탵i pe butonul \"Copy to clipboard\" (Copiere 칥n clipboard) al "
"exemplului pe care dori탵i s캒 칥l copia탵i."

#: src/cargo/running-locally.md
msgid ""
"Use `cargo new exercise` to create a new `exercise/` directory for your code:"
msgstr ""
"Utiliza탵i `cargo new exercise` pentru a crea un nou director `exercise/` "
"pentru codul dumneavoastr캒:"

#: src/cargo/running-locally.md
msgid ""
"Navigate into `exercise/` and use `cargo run` to build and run your binary:"
msgstr ""
"Naviga탵i 칥n `exercise/` 탳i folosi탵i `cargo run` pentru a construi 탳i rula "
"binarul dumneavoastr캒:"

#: src/cargo/running-locally.md
msgid ""
"Replace the boiler-plate code in `src/main.rs` with your own code. For "
"example, using the example on the previous page, make `src/main.rs` look like"
msgstr ""
"칉nlocui탵i codul generic din `src/main.rs` cu propriul cod. De exemplu, "
"folosind exemplul de pe pagina anterioar캒, face탵i`src/main.rs` s캒 arate "
"astfel"

#: src/cargo/running-locally.md
msgid "Use `cargo run` to build and run your updated binary:"
msgstr "Utiliza탵i `cargo run` pentru a construi 탳i rula binarul actualizat:"

#: src/cargo/running-locally.md
msgid ""
"Use `cargo check` to quickly check your project for errors, use `cargo "
"build` to compile it without running it. You will find the output in `target/"
"debug/` for a normal debug build. Use `cargo build --release` to produce an "
"optimized release build in `target/release/`."
msgstr ""
"Folosi탵i `cargo check` pentru a verifica rapid dac캒 proiectul dumneavoastr캒 "
"are erori, folosi탵i `cargo build` pentru a-l compila f캒r캒 a-l rula. Ve탵i "
"g캒si rezultatul 칥n `target/debug/` pentru o compilare normal캒 de depanare. "
"Folosi탵i `cargo build --release` pentru a produce o compilare optimizat캒 de "
"lansare 칥n `target/release/`."

#: src/cargo/running-locally.md
msgid ""
"You can add dependencies for your project by editing `Cargo.toml`. When you "
"run `cargo` commands, it will automatically download and compile missing "
"dependencies for you."
msgstr ""
"Pute탵i ad캒uga dependen탵e pentru proiectul dumneavoastr캒 prin editarea `Cargo."
"toml`. C칙nd executa탵i comenzile `cargo`, acesta va desc캒rca 탳i compila "
"automat dependen탵ele lips캒 pentru dumneavoastr캒."

#: src/cargo/running-locally.md
msgid ""
"Try to encourage the class participants to install Cargo and use a local "
"editor. It will make their life easier since they will have a normal "
"development environment."
msgstr ""
"칉ncerca탵i s캒 칥ncuraja탵i participan탵ii la curs s캒 instaleze Cargo 탳i s캒 "
"utilizeze un editor local. Acest lucru le va face via탵a mai u탳oar캒, deoarece "
"vor avea un mediu de dezvoltare normal."

#: src/welcome-day-1.md
msgid "Welcome to Day 1"
msgstr "Bine a탵i venit la Ziua 1"

#: src/welcome-day-1.md
msgid ""
"This is the first day of Rust Fundamentals. We will cover a lot of ground "
"today:"
msgstr ""
"Aceasta este prima zi a cursului Rust Fundamentals. Vom acoperi o mul탵ime de "
"subiecte ast캒zi:"

#: src/welcome-day-1.md
msgid ""
"Basic Rust syntax: variables, scalar and compound types, enums, structs, "
"references, functions, and methods."
msgstr ""
"Sintaxa de baz캒 Rust: variabile, tipuri scalare 탳i compuse, enumera탵ii, "
"structuri, referin탵e, func탵ii 탳i metode."

#: src/welcome-day-1.md
msgid "Types and type inference."
msgstr "Tipuri 탳i inferen탵a de tip."

#: src/welcome-day-1.md
msgid "Control flow constructs: loops, conditionals, and so on."
msgstr "Construc탵ii ale fluxului de control: bucle, condi탵ionale 탳i altele."

#: src/welcome-day-1.md
msgid "User-defined types: structs and enums."
msgstr "Tipuri definite de utilizator: structurile 탳i enumera탵iile."

#: src/welcome-day-1.md
msgid "Pattern matching: destructuring enums, structs, and arrays."
msgstr ""
"G캒sirea de tipare: destructurarea enumera탵iilor, structurilor 탳i a "
"tablourilor."

#: src/welcome-day-1.md src/welcome-day-2.md src/welcome-day-3.md
#: src/welcome-day-4.md src/concurrency/welcome.md
#: src/concurrency/welcome-async.md
msgid "Schedule"
msgstr "Program"

#: src/welcome-day-1.md src/welcome-day-1-afternoon.md src/welcome-day-2.md
#: src/welcome-day-2-afternoon.md src/welcome-day-3.md
#: src/welcome-day-3-afternoon.md src/welcome-day-4.md
#: src/welcome-day-4-afternoon.md src/concurrency/welcome.md
#: src/concurrency/welcome-async.md
msgid "In this session:"
msgstr "칉n aceast캒 sesiune:"

#: src/welcome-day-1.md
msgid "[Welcome](./welcome-day-1.md) (5 minutes)"
msgstr "[Introducere](./welcome-day-1.md) (5 minute)"

#: src/welcome-day-1.md
#, fuzzy
msgid "[Hello, World](./hello-world.md) (15 minutes)"
msgstr "[Hello, World](./hello-world.md) (20 minute)"

#: src/welcome-day-1.md
#, fuzzy
msgid "[Types and Values](./types-and-values.md) (40 minutes)"
msgstr "[Tipuri 탳i valori](./types-and-values.md) (1 or캒 탳i 5 minute)"

#: src/welcome-day-1.md
#, fuzzy
msgid "[Control Flow Basics](./control-flow-basics.md) (40 minutes)"
msgstr "[Bazele fluxului de control](./control-flow-basics.md) (1 or캒)"

#: src/welcome-day-1.md
#, fuzzy
msgid ""
"Including 10 minute breaks, this session should take about 2 hours and 5 "
"minutes"
msgstr ""
"Incluz칙nd pauzele de 10 minute, aceast캒 sesiune ar trebui s캒 dureze "
"aproximativ 2 ore 탳i 55 de minute"

#: src/welcome-day-1.md
msgid "Please remind the students that:"
msgstr "V캒 rug캒m s캒 le reaminti탵i cursan탵ilor c캒:"

#: src/welcome-day-1.md
msgid ""
"They should ask questions when they get them, don't save them to the end."
msgstr ""
"Ar trebui s캒 pun캒 칥ntreb캒ri atunci c칙nd le primesc, nu s캒 le lase pentru "
"final."

#: src/welcome-day-1.md
msgid ""
"The class is meant to be interactive and discussions are very much "
"encouraged!"
msgstr ""
"Clasa se dore탳te a fi interactiv캒, iar discu탵iile sunt foarte 칥ncurajate!"

#: src/welcome-day-1.md
msgid ""
"As an instructor, you should try to keep the discussions relevant, i.e., "
"keep the discussions related to how Rust does things vs some other language. "
"It can be hard to find the right balance, but err on the side of allowing "
"discussions since they engage people much more than one-way communication."
msgstr ""
"칉n calitate de instructor, ar trebui s캒 칥ncerca탵i s캒 p캒stra탵i discu탵iile "
"relevante, adic캒 s캒 p캒stra탵i discu탵iile legate de modul 칥n care Rust face "
"lucrurile 칥n compara탵ie cu un alt limbaj. Poate fi greu s캒 g캒si탵i echilibrul "
"potrivit, dar e de preferat s캒 permite탵i discu탵iile, deoarece acestea "
"antreneaz캒 oamenii mult mai mult dec칙t comunicarea unidirec탵ional캒."

#: src/welcome-day-1.md
msgid ""
"The questions will likely mean that we talk about things ahead of the slides."
msgstr ""
"칉ntreb캒rile vor 칥nsemna probabil c캒 vom vorbi despre lucruri 칥nainte de "
"prezentarea slide-urilor."

#: src/welcome-day-1.md
msgid ""
"This is perfectly okay! Repetition is an important part of learning. "
"Remember that the slides are just a support and you are free to skip them as "
"you like."
msgstr ""
"Acest lucru este perfect 칥n regul캒! Repeti탵ia este o parte important캒 a "
"칥nv캒탵캒rii. Nu uita탵i c캒 diapozitivele sunt doar un suport 탳i c캒 sunte탵i "
"liberi s캒 le s캒ri탵i dup캒 cum dori탵i."

#: src/welcome-day-1.md
msgid ""
"The idea for the first day is to show the \"basic\" things in Rust that "
"should have immediate parallels in other languages. The more advanced parts "
"of Rust come on the subsequent days."
msgstr ""
"Ideea pentru prima zi este de a ar캒ta lucrurile \"de baz캒\" din Rust care ar "
"trebui s캒 aib캒 paralele imediate cu alte limbaje. P캒r탵ile mai avansate din "
"Rust vor fi prezentate 칥n zilele urm캒toare."

#: src/welcome-day-1.md
msgid ""
"If you're teaching this in a classroom, this is a good place to go over the "
"schedule. Note that there is an exercise at the end of each segment, "
"followed by a break. Plan to cover the exercise solution after the break. "
"The times listed here are a suggestion in order to keep the course on "
"schedule. Feel free to be flexible and adjust as necessary!"
msgstr ""
"Dac캒 preda탵i acest curs 칥n clas캒, acesta este un loc bun pentru a trece 칥n "
"revist캒 programul. Re탵ine탵i c캒 exist캒 un exerci탵iu la sf칙r탳itul fiec캒rui "
"segment, urmat de o pauz캒. Planifica탵i s캒 acoperi탵i solu탵ia exerci탵iului "
"dup캒 pauz캒. Orele listate aici sunt o sugestie pentru a men탵ine cursul 칥n "
"program. Nu ezita탵i s캒 fi탵i flexibili 탳i s캒 v캒 adapta탵i dup캒 cum este "
"necesar!"

#: src/hello-world.md src/types-and-values.md src/control-flow-basics.md
#: src/tuples-and-arrays.md src/references.md src/user-defined-types.md
#: src/pattern-matching.md src/methods-and-traits.md src/generics.md
#: src/std-types.md src/std-traits.md src/memory-management.md
#: src/smart-pointers.md src/borrowing.md src/lifetimes.md src/iterators.md
#: src/modules.md src/testing.md src/error-handling.md src/unsafe-rust.md
#: src/concurrency/threads.md src/concurrency/channels.md
#: src/concurrency/send-sync.md src/concurrency/shared-state.md
#: src/concurrency/sync-exercises.md src/concurrency/async.md
#: src/concurrency/async-control-flow.md src/concurrency/async-pitfalls.md
#: src/concurrency/async-exercises.md
msgid "In this segment:"
msgstr "칉n acest segment:"

#: src/hello-world.md
msgid "[What is Rust?](./hello-world/what-is-rust.md) (10 minutes)"
msgstr "[Ce este Rust?](./hello-world/what-is-rust.md) (10 minute)"

#: src/hello-world.md
msgid "[Benefits of Rust](./hello-world/benefits.md) (3 minutes)"
msgstr "[Avantajele Rust](./hello-world/benefits.md) (3 minute)"

#: src/hello-world.md
msgid "[Playground](./hello-world/playground.md) (2 minutes)"
msgstr "[Terenul de joac캒](./hello-world/playground.md) (2 minute)"

#: src/hello-world.md src/concurrency/send-sync.md
msgid "This segment should take about 15 minutes"
msgstr "Acest segment ar trebui s캒 dureze aproximativ 15 minute"

#: src/hello-world/what-is-rust.md
msgid ""
"Rust is a new programming language which had its [1.0 release in 2015]"
"(https://blog.rust-lang.org/2015/05/15/Rust-1.0.html):"
msgstr ""
"Rust este un nou limbaj de programare care a avut [versiunea 1.0 칥n 2015]"
"(https://blog.rust-lang.org/2015/05/15/Rust-1.0.html):"

#: src/hello-world/what-is-rust.md
msgid "Rust is a statically compiled language in a similar role as C++"
msgstr "Rust este un limbaj compilat static, cu un rol similar cu C++"

#: src/hello-world/what-is-rust.md
msgid "`rustc` uses LLVM as its backend."
msgstr "`rustc` folose탳te LLVM ca backend."

#: src/hello-world/what-is-rust.md
msgid ""
"Rust supports many [platforms and architectures](https://doc.rust-lang.org/"
"nightly/rustc/platform-support.html):"
msgstr ""
"Rust suport캒 multe [platforme 탳i arhitecturi](https://doc.rust-lang.org/"
"nightly/rustc/platform-support.html):"

#: src/hello-world/what-is-rust.md
msgid "x86, ARM, WebAssembly, ..."
msgstr "x86, ARM, WebAssembly, ..."

#: src/hello-world/what-is-rust.md
msgid "Linux, Mac, Windows, ..."
msgstr "Linux, Mac, Windows, ..."

#: src/hello-world/what-is-rust.md
msgid "Rust is used for a wide range of devices:"
msgstr "Rust este utilizat pentru o gam캒 larg캒 de dispozitive:"

#: src/hello-world/what-is-rust.md
msgid "firmware and boot loaders,"
msgstr "firmware 탳i boot leaders,"

#: src/hello-world/what-is-rust.md
msgid "smart displays,"
msgstr "ecrane inteligente,"

#: src/hello-world/what-is-rust.md
msgid "mobile phones,"
msgstr "telefoane mobile,"

#: src/hello-world/what-is-rust.md
msgid "desktops,"
msgstr "desktop-uri,"

#: src/hello-world/what-is-rust.md
msgid "servers."
msgstr "servere."

#: src/hello-world/what-is-rust.md
msgid "Rust fits in the same area as C++:"
msgstr "Rust se 칥ncadreaz캒 칥n aceea탳i zon캒 ca 탳i C++:"

#: src/hello-world/what-is-rust.md
msgid "High flexibility."
msgstr "Flexibilitate ridicat캒."

#: src/hello-world/what-is-rust.md
msgid "High level of control."
msgstr "Nivel ridicat de control."

#: src/hello-world/what-is-rust.md
msgid ""
"Can be scaled down to very constrained devices such as microcontrollers."
msgstr ""
"Poate fi redus pentru a rula pe dispozitive foarte limitate, cum ar fi "
"microcontrolerele."

#: src/hello-world/what-is-rust.md
msgid "Has no runtime or garbage collection."
msgstr "Nu are nevoie de mediu de execu탵ie 탳i nici de colectare de gunoi."

#: src/hello-world/what-is-rust.md
msgid "Focuses on reliability and safety without sacrificing performance."
msgstr ""
"Se concentreaz캒 pe fiabilitate 탳i siguran탵캒 f캒r캒 a sacrifica performan탵a."

#: src/hello-world/benefits.md
msgid "Some unique selling points of Rust:"
msgstr "C칙teva caracteristici ale Rust:"

#: src/hello-world/benefits.md
msgid ""
"_Compile time memory safety_ - whole classes of memory bugs are prevented at "
"compile time"
msgstr ""
"_Siguran탵a memoriei la compilare_ - clase 칥ntregi de erori de memorie sunt "
"prevenite la compilare"

#: src/hello-world/benefits.md
msgid "No uninitialized variables."
msgstr "Nu exist캒 variabile neini탵ializate."

#: src/hello-world/benefits.md
msgid "No double-frees."
msgstr "Nu exist캒 eliber캒ri duble de memorie."

#: src/hello-world/benefits.md
msgid "No use-after-free."
msgstr "Nu se utilizeaz캒 dup캒 eliberare."

#: src/hello-world/benefits.md
msgid "No `NULL` pointers."
msgstr "Nu exist캒 pointeri `NULL`."

#: src/hello-world/benefits.md
msgid "No forgotten locked mutexes."
msgstr "Nu s-au uitat mutexuri blocate."

#: src/hello-world/benefits.md
msgid "No data races between threads."
msgstr "Nu exist캒 concuren탵캒 la date 칥ntre firele de execu탵ie."

#: src/hello-world/benefits.md
msgid "No iterator invalidation."
msgstr "Nu sunt invalid캒ri ale iteratorilor."

#: src/hello-world/benefits.md
msgid ""
"_No undefined runtime behavior_ - what a Rust statement does is never left "
"unspecified"
msgstr ""
"_F캒r캒 comportament nedefinit 칥n timp de execu탵ie_ - ceea ce face o "
"declara탵ie Rust nu este niciodat캒 nespecificat"

#: src/hello-world/benefits.md
msgid "Array access is bounds checked."
msgstr "Accesul la matrice este verificat 칥n func탵ie de limite."

#: src/hello-world/benefits.md
msgid "Integer overflow is defined (panic or wrap-around)."
msgstr "Este definit캒 dep캒탳irea num캒rului 칥ntreg (panic캒 sau wrap-around)."

#: src/hello-world/benefits.md
msgid ""
"_Modern language features_ - as expressive and ergonomic as higher-level "
"languages"
msgstr ""
"_Caracteristicile limbajelor moderne_ - la fel de expresive 탳i ergonomice ca "
"탳i limbajele de nivel superior"

#: src/hello-world/benefits.md
msgid "Enums and pattern matching."
msgstr "Enums 탳i g캒sirea de modele."

#: src/hello-world/benefits.md
msgid "Generics."
msgstr "Tipuri generice."

#: src/hello-world/benefits.md
msgid "No overhead FFI."
msgstr "FFI f캒r캒 costuri suplimentare."

#: src/hello-world/benefits.md
msgid "Zero-cost abstractions."
msgstr "Abstrac탵ii f캒r캒 costuri."

#: src/hello-world/benefits.md
msgid "Great compiler errors."
msgstr "Erorile de compilare importante."

#: src/hello-world/benefits.md
msgid "Built-in dependency manager."
msgstr "Manager de dependen탵e 칥ncorporat."

#: src/hello-world/benefits.md
msgid "Built-in support for testing."
msgstr "Suport pentru testare 칥ncorporat."

#: src/hello-world/benefits.md
msgid "Excellent Language Server Protocol support."
msgstr "Suport excelent pentru protocolul serverului de limb캒."

#: src/hello-world/benefits.md
msgid ""
"Do not spend much time here. All of these points will be covered in more "
"depth later."
msgstr ""
"Nu petrece탵i mult timp aici. Toate aceste puncte vor fi abordate mai 칥n "
"profunzime mai t칙rziu."

#: src/hello-world/benefits.md
msgid ""
"Make sure to ask the class which languages they have experience with. "
"Depending on the answer you can highlight different features of Rust:"
msgstr ""
"Nu uita탵i s캒 칥ntreba탵i elevii din clas캒 cu ce limbaje au experien탵캒. 칉n "
"func탵ie de r캒spuns, pute탵i eviden탵ia diferite caracteristici ale Rust:"

#: src/hello-world/benefits.md
msgid ""
"Experience with C or C++: Rust eliminates a whole class of _runtime errors_ "
"via the borrow checker. You get performance like in C and C++, but you don't "
"have the memory unsafety issues. In addition, you get a modern language with "
"constructs like pattern matching and built-in dependency management."
msgstr ""
"Experien탵캒 cu C sau C++: Rust elimin캒 o 칥ntreag캒 clas캒 de erori de execu탵ie "
"prin intermediul verificatorului de 칥mprumuturi. Ob탵ine탵i performan탵e ca 칥n "
"C 탳i C++, dar nu ave탵i probleme de nesiguran탵캒 a memoriei. 칉n plus, ob탵ine탵i "
"un limbaj modern, cu construc탵ii precum 탳abloane de potrivire 탳i gestionarea "
"integrat캒 a dependen탵elor."

#: src/hello-world/benefits.md
msgid ""
"Experience with Java, Go, Python, JavaScript...: You get the same memory "
"safety as in those languages, plus a similar high-level language feeling. In "
"addition you get fast and predictable performance like C and C++ (no garbage "
"collector) as well as access to low-level hardware (should you need it)"
msgstr ""
"Experien탵캒 cu Java, Go, Python, JavaScript...: Ob탵ine탵i aceea탳i siguran탵캒 a "
"memoriei ca 칥n aceste limbaje, plus o senza탵ie similar캒 de limbaj de nivel "
"칥nalt. 칉n plus, ob탵ine탵i performan탵e rapide 탳i previzibile ca 칥n C 탳i C++ "
"(f캒r캒 colector de memorie), precum 탳i acces la hardware de nivel sc캒zut "
"(dac캒 ave탵i nevoie)"

#: src/hello-world/playground.md
msgid ""
"The [Rust Playground](https://play.rust-lang.org/) provides an easy way to "
"run short Rust programs, and is the basis for the examples and exercises in "
"this course. Try running the \"hello-world\" program it starts with. It "
"comes with a few handy features:"
msgstr ""
"[Rust Playground](https://play.rust-lang.org/) ofer캒 o modalitate u탳oar캒 de "
"a rula programe Rust scurte 탳i reprezint캒 baza pentru exemplele 탳i "
"exerci탵iile din acest curs. 칉ncerca탵i s캒 rula탵i programul \"hello-world\" cu "
"care 칥ncepe. Acesta vine cu c칙teva caracteristici utile:"

#: src/hello-world/playground.md
msgid ""
"Under \"Tools\", use the `rustfmt` option to format your code in the "
"\"standard\" way."
msgstr ""
"칉n sec탵iunea \"Tools\", utiliza탵i op탵iunea `rustfmt` pentru a formata codul "
"칥n mod \"standard\"."

#: src/hello-world/playground.md
msgid ""
"Rust has two main \"profiles\" for generating code: Debug (extra runtime "
"checks, less optimization) and Release (fewer runtime checks, lots of "
"optimization). These are accessible under \"Debug\" at the top."
msgstr ""
"Rust are dou캒 \"profiluri\" principale pentru generarea de cod: Debug "
"(verific캒ri suplimentare 칥n timpul execu탵iei, mai pu탵in캒 optimizare) 탳i "
"Release (mai pu탵ine verific캒ri 칥n timpul execu탵iei, mult캒 optimizare). "
"Acestea sunt accesibile sub \"Debug\" 칥n partea de sus."

#: src/hello-world/playground.md
msgid ""
"If you're interested, use \"ASM\" under \"...\" to see the generated "
"assembly code."
msgstr ""
"Dac캒 sunte탵i interesa탵i, utiliza탵i \"ASM\" sub \"...\" pentru a vedea codul "
"de asamblare generat."

#: src/hello-world/playground.md
msgid ""
"As students head into the break, encourage them to open up the playground "
"and experiment a little. Encourage them to keep the tab open and try things "
"out during the rest of the course. This is particularly helpful for advanced "
"students who want to know more about Rust's optimizations or generated "
"assembly."
msgstr ""
"칉ncuraja탵i cursan탵ii s캒 experimenteze 칥n mediul de lucru virtual pe "
"parcursul restului cursului. Acest lucru este deosebit de util pentru "
"studen탵ii avansa탵i care doresc s캒 afle mai multe despre optimiz캒rile Rust "
"sau despre codul 칥n limbaj de asamblare generat."

#: src/types-and-values.md
#, fuzzy
msgid "[Hello, World](./types-and-values/hello-world.md) (5 minutes)"
msgstr "[Hello, World](./hello-world/hello-world.md) (5 minute)"

#: src/types-and-values.md
msgid "[Variables](./types-and-values/variables.md) (5 minutes)"
msgstr "[Variabile](./types-and-values/variables.md) (5 minute)"

#: src/types-and-values.md
#, fuzzy
msgid "[Values](./types-and-values/values.md) (5 minutes)"
msgstr "[Valori](./types-and-values/values.md) (10 minute)"

#: src/types-and-values.md
#, fuzzy
msgid "[Arithmetic](./types-and-values/arithmetic.md) (3 minutes)"
msgstr "[Aritmetic캒](./types-and-values/arithmetic.md) (5 minute)"

#: src/types-and-values.md
#, fuzzy
msgid "[Type Inference](./types-and-values/inference.md) (3 minutes)"
msgstr "[Inferen탵캒 de tip](./types-and-values/inference.md) (5 minute)"

#: src/types-and-values.md
#, fuzzy
msgid "[Exercise: Fibonacci](./types-and-values/exercise.md) (15 minutes)"
msgstr "[Exerci탵iu: Fibonacci](./types-and-values/exercise.md) (30 minute)"

#: src/types-and-values.md src/control-flow-basics.md src/generics.md
#: src/modules.md
#, fuzzy
msgid "This segment should take about 40 minutes"
msgstr "Acest segment ar trebui s캒 dureze aproximativ 40 de minute"

#: src/types-and-values/hello-world.md
msgid ""
"Let us jump into the simplest possible Rust program, a classic Hello World "
"program:"
msgstr ""
"S캒 trecem la cel mai simplu program Rust posibil, un program clasic Bun캒 "
"Lume:"

#: src/types-and-values/hello-world.md
msgid "\"Hello 游깴!\""
msgstr "\"Bun캒 ziua 游깴!\""

#: src/types-and-values/hello-world.md
msgid "What you see:"
msgstr "Ce vede탵i:"

#: src/types-and-values/hello-world.md
msgid "Functions are introduced with `fn`."
msgstr "Func탵iile sunt introduse cu `fn`."

#: src/types-and-values/hello-world.md
msgid "Blocks are delimited by curly braces like in C and C++."
msgstr "Blocurile sunt delimitate prin paranteze curbe, ca 칥n C 탳i C++."

#: src/types-and-values/hello-world.md
msgid "The `main` function is the entry point of the program."
msgstr "Func탵ia `main` este punctul de intrare al programului."

#: src/types-and-values/hello-world.md
msgid "Rust has hygienic macros, `println!` is an example of this."
msgstr "Rust are macro-uri igienice, `println!` este un exemplu 칥n acest sens."

#: src/types-and-values/hello-world.md
msgid "Rust strings are UTF-8 encoded and can contain any Unicode character."
msgstr ""
"탲irurile de caractere Rust sunt codificate UTF-8 탳i pot con탵ine orice "
"caracter Unicode."

#: src/types-and-values/hello-world.md
msgid ""
"This slide tries to make the students comfortable with Rust code. They will "
"see a ton of it over the next four days so we start small with something "
"familiar."
msgstr ""
"Aceast캒 pagin캒 칥ncearc캒 s캒 칥i fac캒 pe cursan탵i s캒 se simt캒 confortabil cu "
"codul Rust. Ei vor vedea o mul탵ime de astfel de fi탳iere 칥n urm캒toarele trei "
"zile, a탳a c캒 vom 칥ncepe cu ceva familiar."

#: src/types-and-values/hello-world.md
msgid ""
"Rust is very much like other languages in the C/C++/Java tradition. It is "
"imperative and it doesn't try to reinvent things unless absolutely necessary."
msgstr ""
"Rust se aseam캒n캒 foarte mult cu alte limbaje de genul C/C++/Java. Este "
"imperativ 탳i nu 칥ncearc캒 s캒 reinventeze lucrurile dec칙t dac캒 este absolut "
"necesar."

#: src/types-and-values/hello-world.md
msgid "Rust is modern with full support for things like Unicode."
msgstr "Rust este modern, cu suport complet pentru lucruri precum Unicode."

#: src/types-and-values/hello-world.md
msgid ""
"Rust uses macros for situations where you want to have a variable number of "
"arguments (no function [overloading](../control-flow-basics/functions.md))."
msgstr ""
"Rust folose탳te macrocomenzi pentru situa탵iile 칥n care dori탵i s캒 ave탵i un "
"num캒r variabil de argumente (f캒r캒 [supra칥nc캒rcare](basic-syntax/functions-"
"interlude.md) de func탵ii )."

#: src/types-and-values/hello-world.md
msgid ""
"Macros being 'hygienic' means they don't accidentally capture identifiers "
"from the scope they are used in. Rust macros are actually only [partially "
"hygienic](https://veykril.github.io/tlborm/decl-macros/minutiae/hygiene."
"html)."
msgstr ""
"Fiind \"igienice\", macrourile 칥nseamn캒 c캒 nu capteaz캒 accidental "
"identificatori din domeniul de aplicare 칥n care sunt utilizate. Macro-urile "
"Rust sunt de fapt doar [par탵ial igienice](https://veykril.github.io/tlborm/"
"decl-macros/minutiae/hygiene.html)."

#: src/types-and-values/hello-world.md
msgid ""
"Rust is multi-paradigm. For example, it has powerful [object-oriented "
"programming features](https://doc.rust-lang.org/book/ch17-00-oop.html), and, "
"while it is not a functional language, it includes a range of [functional "
"concepts](https://doc.rust-lang.org/book/ch13-00-functional-features.html)."
msgstr ""
"Rust este multi-paradigm캒. De exemplu, are [caracteristici puternice de "
"programare orientat캒 pe obiecte](https://doc.rust-lang.org/book/ch17-00-oop."
"html) 탳i, de탳i nu este un limbaj func탵ional, include o serie de [concepte "
"func탵ionale](https://doc.rust-lang.org/book/ch13-00-functional-features."
"html)."

#: src/types-and-values/variables.md
msgid ""
"Rust provides type safety via static typing. Variable bindings are made with "
"`let`:"
msgstr ""
"Rust ofer캒 siguran탵캒 de tip prin intermediul tipiz캒rii statice. Leg캒turile "
"variabilelor sunt imuabile 칥n mod implicit:"

#: src/types-and-values/variables.md src/control-flow-basics/loops/for.md
#: src/control-flow-basics/blocks-and-scopes.md
msgid "\"x: {x}\""
msgstr "\"x: {x}\""

#: src/types-and-values/variables.md
msgid ""
"// x = 20;\n"
"    // println!(\"x: {x}\");\n"
msgstr ""
"// x = 20;\n"
"    // println!(\"x: {x}\");\n"

#: src/types-and-values/variables.md
msgid ""
"Uncomment the `x = 20` to demonstrate that variables are immutable by "
"default. Add the `mut` keyword to allow changes."
msgstr ""
"Scoate탵i comentariul `x = 20` pentru a demonstra c캒 variabilele sunt "
"imuabile 칥n mod implicit. Ad캒uga탵i cuv칙ntul cheie `mut` pentru a permite "
"modific캒ri."

#: src/types-and-values/variables.md
msgid ""
"The `i32` here is the type of the variable. This must be known at compile "
"time, but type inference (covered later) allows the programmer to omit it in "
"many cases."
msgstr ""
"Aici `i32` este tipul variabilei. Acesta trebuie s캒 fie cunoscut la "
"compilare, dar inferen탵a de tip (abordat캒 mai t칙rziu) permite "
"programatorului s캒 o omit캒 칥n multe cazuri."

#: src/types-and-values/values.md
msgid ""
"Here are some basic built-in types, and the syntax for literal values of "
"each type."
msgstr ""
"Iat캒 c칙teva tipuri de baz캒 칥ncorporate 탳i sintaxa pentru valorile literale "
"ale fiec캒rui tip."

#: src/types-and-values/values.md src/unsafe-rust/exercise.md
msgid "Types"
msgstr "Tipuri"

#: src/types-and-values/values.md
msgid "Literals"
msgstr "Literale"

#: src/types-and-values/values.md
msgid "Signed integers"
msgstr "Numere 칥ntregi cu semn"

#: src/types-and-values/values.md
msgid "`i8`, `i16`, `i32`, `i64`, `i128`, `isize`"
msgstr "`i8`, `i16`, `i32`, `i64`, `i128`, `isize`"

#: src/types-and-values/values.md
msgid "`-10`, `0`, `1_000`, `123_i64`"
msgstr "`-10`, `0`, `1_000`, `123_i64`"

#: src/types-and-values/values.md
msgid "Unsigned integers"
msgstr "칉ntregi f캒r캒 semn"

#: src/types-and-values/values.md
msgid "`u8`, `u16`, `u32`, `u64`, `u128`, `usize`"
msgstr "`u8`, `u16`, `u32`, `u64`, `u128`, `usize`"

#: src/types-and-values/values.md
msgid "`0`, `123`, `10_u16`"
msgstr "`0`, `123`, `10_u16`"

#: src/types-and-values/values.md
msgid "Floating point numbers"
msgstr "Numere 칥n virgul캒 mobil캒"

#: src/types-and-values/values.md
msgid "`f32`, `f64`"
msgstr "`f32`, `f64`"

#: src/types-and-values/values.md
msgid "`3.14`, `-10.0e20`, `2_f32`"
msgstr "`3.14`, `-10.0e20`, `2_f32`"

#: src/types-and-values/values.md
msgid "Unicode scalar values"
msgstr "Valori scalare Unicode"

#: src/types-and-values/values.md src/android/aidl/types/primitives.md
msgid "`char`"
msgstr "`char`"

#: src/types-and-values/values.md
msgid "`'a'`, `'풤'`, `''`"
msgstr "`'a'`, `'풤'`, `''`"

#: src/types-and-values/values.md
msgid "Booleans"
msgstr "Booleeni"

#: src/types-and-values/values.md src/android/aidl/types/primitives.md
msgid "`bool`"
msgstr "`bool`"

#: src/types-and-values/values.md
msgid "`true`, `false`"
msgstr "`true`, `false`"

#: src/types-and-values/values.md
msgid "The types have widths as follows:"
msgstr "Tipurile au lungimi dup캒 cum urmeaz캒:"

#: src/types-and-values/values.md
msgid "`iN`, `uN`, and `fN` are _N_ bits wide,"
msgstr "`iN`, `uN`, 탳i `fN` au o lungime de _N_ bi탵i,"

#: src/types-and-values/values.md
msgid "`isize` and `usize` are the width of a pointer,"
msgstr "`isize` 탳i `usize` reprezint캒 lungimea unui pointer,"

#: src/types-and-values/values.md
msgid "`char` is 32 bits wide,"
msgstr "`char` are o lungime de 32 de bi탵i,"

#: src/types-and-values/values.md
msgid "`bool` is 8 bits wide."
msgstr "`bool` are o lungime de 8 bi탵i."

#: src/types-and-values/values.md
msgid "There are a few syntaxes which are not shown above:"
msgstr "Exist캒 c칙teva elemente de sintax캒 care nu sunt prezentate mai sus:"

#: src/types-and-values/values.md
msgid ""
"All underscores in numbers can be left out, they are for legibility only. So "
"`1_000` can be written as `1000` (or `10_00`), and `123_i64` can be written "
"as `123i64`."
msgstr ""
"Toate sublinierile din numere pot fi omise, ele sunt folosite doar pentru "
"lizibilitate. Astfel, `1_000` poate fi scris ca `1000` (sau `10_00`), iar "
"`123_i64` poate fi scris ca `123i64`."

#: src/types-and-values/arithmetic.md
msgid "\"result: {}\""
msgstr "\"result: {}\""

#: src/types-and-values/arithmetic.md
msgid ""
"This is the first time we've seen a function other than `main`, but the "
"meaning should be clear: it takes three integers, and returns an integer. "
"Functions will be covered in more detail later."
msgstr ""
"Aceasta este prima dat캒 c칙nd vedem o alt캒 func탵ie dec칙t `main`, dar "
"semnifica탵ia ar trebui s캒 fie clar캒: prime탳te trei numere 칥ntregi 탳i "
"returneaz캒 un num캒r 칥ntreg. Func탵iile vor fi tratate mai 칥n detaliu mai "
"t칙rziu."

#: src/types-and-values/arithmetic.md
msgid "Arithmetic is very similar to other languages, with similar precedence."
msgstr ""
"Aritmetica este foarte asem캒n캒toare cu cea din alte limbaje, cu preceden탵캒 "
"similar캒."

#: src/types-and-values/arithmetic.md
msgid ""
"What about integer overflow? In C and C++ overflow of _signed_ integers is "
"actually undefined, and might do different things on different platforms or "
"compilers. In Rust, it's defined."
msgstr ""
"Cum r캒m칙ne cu dep캒탳irea de numere 칥ntregi? 칉n C 탳i C++, dep캒탳irea num캒rului "
"de numere 칥ntregi cu semn este, de fapt, nedefinit캒 탳i poate avea efecte "
"diferite pe diferite platforme sau compilatoare. 칉n Rust, este definit캒."

#: src/types-and-values/arithmetic.md
#, fuzzy
msgid ""
"Change the `i32`'s to `i16` to see an integer overflow, which panics "
"(checked) in a debug build and wraps in a release build. There are other "
"options, such as overflowing, saturating, and carrying. These are accessed "
"with method syntax, e.g., `(a * b).saturating_add(b * c).saturating_add(c * "
"a)`."
msgstr ""
"Schimba탵i `i32` 칥n `i16` pentru a vedea o dep캒탳ire de num캒r 칥ntreg, care "
"intr캒 칥n panic캒 (verificat캒) 칥ntr-o compilare de depanare 탳i care se "
"칥nf캒탳oar캒 칥ntr-o compilare de release. Exist캒 탳i alte op탵iuni, cum ar fi "
"dep캒탳irea, saturarea 탳i re탵inerea dep캒탳irii. Acestea sunt accesate cu "
"sintaxa metodei, de exemplu, `(a * b).saturating_add(b * c).saturating_add(c "
"* a)`."

#: src/types-and-values/arithmetic.md
msgid ""
"In fact, the compiler will detect overflow of constant expressions, which is "
"why the example requires a separate function."
msgstr ""
"De fapt, compilatorul va detecta dep캒탳irea expresiilor constante, motiv "
"pentru care exemplul necesit캒 o func탵ie separat캒."

#: src/types-and-values/inference.md
msgid "Rust will look at how the variable is _used_ to determine the type:"
msgstr ""
"Rust se va uita la modul 칥n care variabila este _utilizat캒_ pentru a "
"determina tipul:"

#: src/types-and-values/inference.md
msgid ""
"This slide demonstrates how the Rust compiler infers types based on "
"constraints given by variable declarations and usages."
msgstr ""
"Aceast캒 pagin캒 demonstreaz캒 modul 칥n care compilatorul Rust deduce tipurile "
"pe baza constr칙ngerilor date de declara탵iile 탳i utiliz캒rile variabilelor."

#: src/types-and-values/inference.md
msgid ""
"It is very important to emphasize that variables declared like this are not "
"of some sort of dynamic \"any type\" that can hold any data. The machine "
"code generated by such declaration is identical to the explicit declaration "
"of a type. The compiler does the job for us and helps us write more concise "
"code."
msgstr ""
"Este foarte important s캒 subliniem c캒 variabilele declarate astfel nu sunt "
"de un fel de \"tip dinamic\" care poate con탵ine orice date. Codul ma탳in캒 "
"generat de o astfel de declara탵ie este identic cu declara탵ia explicit캒 a "
"unui tip. Compilatorul face treaba 칥n locul nostru 탳i ne ajut캒 s캒 scriem un "
"cod mai concis."

#: src/types-and-values/inference.md
msgid ""
"When nothing constrains the type of an integer literal, Rust defaults to "
"`i32`. This sometimes appears as `{integer}` in error messages. Similarly, "
"floating-point literals default to `f64`."
msgstr ""
"Atunci c칙nd nu exist캒 constr칙ngeri pentru tipul unui literal de num캒r "
"칥ntreg, Rust folose탳te 칥n mod implicit `i32`. Acest lucru apare uneori ca "
"`{integer}` 칥n mesajele de eroare. 칉n mod similar, literalii 칥n virgul캒 "
"mobil캒 sunt 칥n mod implicit `f64`."

#: src/types-and-values/inference.md
msgid "// ERROR: no implementation for `{float} == {integer}`\n"
msgstr "// EROARE: nicio implementare pentru `{float} == {integer}`\n"

#: src/types-and-values/exercise.md
#, fuzzy
msgid ""
"The Fibonacci sequence begins with `[0,1]`. For n>1, the n'th Fibonacci "
"number is calculated recursively as the sum of the n-1'th and n-2'th "
"Fibonacci numbers."
msgstr ""
"Primul 탳i al doilea num캒r Fibonacci sunt ambele `1`. Pentru n>2, cel de-al n-"
"lea num캒r Fibonacci se calculeaz캒 recursiv ca sum캒 a celor dou캒 numere "
"anterioare."

#: src/types-and-values/exercise.md
msgid ""
"Write a function `fib(n)` that calculates the n'th Fibonacci number. When "
"will this function panic?"
msgstr ""
"Scrie탵i o func탵ie `fib(n)` care s캒 calculeze al n-lea num캒r Fibonacci. C칙nd "
"va intra 칥n panic캒 aceast캒 func탵ie?"

#: src/types-and-values/exercise.md
msgid "// The base case.\n"
msgstr "// Cazul de baz캒.\n"

#: src/types-and-values/exercise.md src/control-flow-basics/exercise.md
msgid "\"Implement this\""
msgstr ""
"칉ncerca탵i s캒 rezolva탵i mai 칥nt칙i problema 칥n mod \"simplu\", folosind "
"buclele `for` 탳i numere 칥ntregi. Apoi, revede탵i solu탵ia 탳i 칥ncerca탵i s캒 o "
"implementa탵i cu iteratori."

#: src/types-and-values/exercise.md
msgid "// The recursive case.\n"
msgstr "// Cazul recursiv.\n"

#: src/types-and-values/exercise.md src/types-and-values/solution.md
#, fuzzy
msgid "\"fib({n}) = {}\""
msgstr "\"fib(n) = {}\""

#: src/control-flow-basics.md
#, fuzzy
msgid "[if Expressions](./control-flow-basics/if.md) (4 minutes)"
msgstr "[Macrouri](./control-flow-basics/macros.md) (2 minute)"

#: src/control-flow-basics.md
msgid "[Loops](./control-flow-basics/loops.md) (5 minutes)"
msgstr "[Bucle](./control-flow-basics/loops.md) (5 minute)"

#: src/control-flow-basics.md
#, fuzzy
msgid ""
"[break and continue](./control-flow-basics/break-continue.md) (4 minutes)"
msgstr ""
"[`break` 탳i `continue`](./control-flow-basics/break-continue.md) (5 minute)"

#: src/control-flow-basics.md
#, fuzzy
msgid ""
"[Blocks and Scopes](./control-flow-basics/blocks-and-scopes.md) (5 minutes)"
msgstr ""
"[Blocuri 탳i domenii de aplicare](./control-flow-basics/blocks-and-scopes.md) "
"(10 minute)"

#: src/control-flow-basics.md
msgid "[Functions](./control-flow-basics/functions.md) (3 minutes)"
msgstr "[Func탵ii](./control-flow-basics/functions.md) (3 minute)"

#: src/control-flow-basics.md
msgid "[Macros](./control-flow-basics/macros.md) (2 minutes)"
msgstr "[Macrouri](./control-flow-basics/macros.md) (2 minute)"

#: src/control-flow-basics.md
#, fuzzy
msgid ""
"[Exercise: Collatz Sequence](./control-flow-basics/exercise.md) (15 minutes)"
msgstr ""
"[Exerci탵iu: Secven탵a Collatz](./control-flow-basics/exerci탵iu.md) (30 minute)"

#: src/control-flow-basics/if.md
msgid "`if` expressions"
msgstr "Expresii 'if'"

#: src/control-flow-basics/if.md
msgid ""
"You use [`if` expressions](https://doc.rust-lang.org/reference/expressions/"
"if-expr.html#if-expressions) exactly like `if` statements in other languages:"
msgstr ""
"[Expresiile `if`](https://doc.rust-lang.org/reference/expressions/if-expr."
"html#if-expressions) se utilizeaz캒 exact ca 탳i instruc탵iunile `if` din alte "
"limbaje:"

#: src/control-flow-basics/if.md
#, fuzzy
msgid "\"zero!\""
msgstr "\"zero!\""

#: src/control-flow-basics/if.md
#, fuzzy
msgid "\"biggish\""
msgstr "\"m캒ricel\""

#: src/control-flow-basics/if.md
msgid "\"huge\""
msgstr "\"imens\""

#: src/control-flow-basics/if.md
msgid ""
"In addition, you can use `if` as an expression. The last expression of each "
"block becomes the value of the `if` expression:"
msgstr ""
"칉n plus, pute탵i utiliza `if` ca expresie. Ultima expresie din fiecare bloc "
"devine valoarea expresiei `if`:"

#: src/control-flow-basics/if.md
msgid "\"small\""
msgstr "\"mic\""

#: src/control-flow-basics/if.md
msgid "\"large\""
msgstr "\"mare\""

#: src/control-flow-basics/if.md
msgid "\"number size: {}\""
msgstr "\"dimensiunea num캒rului: {}\""

#: src/control-flow-basics/if.md
msgid ""
"Because `if` is an expression and must have a particular type, both of its "
"branch blocks must have the same type. Show what happens if you add `;` "
"after `\"small\"` in the second example."
msgstr ""
"Deoarece `if` este o expresie 탳i trebuie s캒 aib캒 un anumit tip, ambele "
"blocuri de ramificare trebuie s캒 aib캒 acela탳i tip. S캒 vedem ce se 칥nt칙mpl캒 "
"dac캒 ad캒uga탵i `;` dup캒 `x / 2` 칥n al doilea exemplu."

#: src/control-flow-basics/if.md
msgid ""
"When `if` is used in an expression, the expression must have a `;` to "
"separate it from the next statement. Remove the `;` before `println!` to see "
"the compiler error."
msgstr ""
"Atunci c칙nd `if` este utilizat 칥ntr-o expresie, expresia trebuie s캒 aib캒 un "
"`;` pentru a o separa de urm캒toarea declara탵ie. Elimina탵i `;` 칥nainte de "
"`println!` pentru a vedea eroarea de compilare."

#: src/control-flow-basics/loops.md
msgid "There are three looping keywords in Rust: `while`, `loop`, and `for`:"
msgstr ""
"칉n Rust exist캒 trei cuvinte cheie pentru bucle: `while`, `loop` 탳i `for`:"

#: src/control-flow-basics/loops.md
msgid "`while`"
msgstr "Bucle `while let`"

#: src/control-flow-basics/loops.md
msgid ""
"The [`while` keyword](https://doc.rust-lang.org/reference/expressions/loop-"
"expr.html#predicate-loops) works much like in other languages, executing the "
"loop body as long as the condition is true."
msgstr ""
"Cuv칙ntul cheie [`while`](https://doc.rust-lang.org/reference/expressions/"
"loop-expr.html#predicate-loops) func탵ioneaz캒 foarte asem캒n캒tor cu alte "
"limbaje, execut칙nd bucla c칙t timp condi탵ia este adev캒rat캒."

#: src/control-flow-basics/loops.md
msgid "\"Final x: {x}\""
msgstr "\"Final x: {x}\""

#: src/control-flow-basics/loops/for.md
#, fuzzy
msgid ""
"The [`for` loop](https://doc.rust-lang.org/std/keyword.for.html) iterates "
"over ranges of values or the items in a collection:"
msgstr ""
"Buclele [`for`](https://doc.rust-lang.org/std/keyword.for.html) sunt "
"utilizate pentru a itera peste o gam캒 de valori:"

#: src/control-flow-basics/loops/for.md
#, fuzzy
msgid "\"elem: {elem}\""
msgstr "\"elem: {elem}\""

#: src/control-flow-basics/loops/for.md
#, fuzzy
msgid ""
"Under the hood `for` loops use a concept called \"iterators\" to handle "
"iterating over different kinds of ranges/collections. Iterators will be "
"discussed in more detail later."
msgstr ""
"칉n cadrul buclelor `for` se utilizeaz캒 un concept numit \"iteratori\" pentru "
"a gestiona itera탵ia peste diferite tipuri de intervale/colec탵ii. Iteratorii "
"vor fi discuta탵i mai 칥n detaliu mai t칙rziu."

#: src/control-flow-basics/loops/for.md
msgid ""
"Note that the `for` loop only iterates to `4`. Show the `1..=5` syntax for "
"an inclusive range."
msgstr ""
"Re탵ine탵i c캒 bucla `for` va itera doar p칙n캒 la `4`. Prezenta탵i sintaxa `1.."
"=5` pentru un interval inclusiv."

#: src/control-flow-basics/loops/loop.md
msgid ""
"The [`loop` statement](https://doc.rust-lang.org/std/keyword.loop.html) just "
"loops forever, until a `break`."
msgstr ""
"Buclele [`loop`](https://doc.rust-lang.org/std/keyword.loop.html) ruleaz캒 칥n "
"continuu p칙n캒 se 칥nt칙lne탳te o instruc탵iune `break`."

#: src/control-flow-basics/loops/loop.md
msgid "\"{i}\""
msgstr "\"{i}\""

#: src/control-flow-basics/break-continue.md
msgid ""
"If you want to immediately start the next iteration use [`continue`](https://"
"doc.rust-lang.org/reference/expressions/loop-expr.html#continue-expressions)."
msgstr ""
"Dac캒 dori탵i s캒 칥ncepe탵i imediat urm캒toarea itera탵ie, utiliza탵i [`continue`]"
"(https://doc.rust-lang.org/reference/expressions/loop-expr.html#continue-"
"expressions)."

#: src/control-flow-basics/break-continue.md
msgid ""
"If you want to exit any kind of loop early, use [`break`](https://doc.rust-"
"lang.org/reference/expressions/loop-expr.html#break-expressions). For "
"`loop`, this can take an optional expression that becomes the value of the "
"`loop` expression."
msgstr ""
"Dac캒 dori탵i s캒 ie탳i탵i mai devreme dintr-o bucl캒, utiliza탵i [`break`](https://"
"doc.rust-lang.org/reference/expressions/loop-expr.html#break-expressions). "
"`loop` poate folosi o expresie op탵ional캒 care devine valoarea buclei."

#: src/control-flow-basics/break-continue.md src/std-traits/exercise.md
#: src/std-traits/solution.md src/smart-pointers/trait-objects.md
#: src/borrowing/interior-mutability.md src/modules/exercise.md
#: src/modules/solution.md src/android/build-rules/library.md
#: src/android/interoperability/cpp/rust-bridge.md
#: src/concurrency/async-pitfalls/cancellation.md
msgid "\"{}\""
msgstr "\"{}\""

#: src/control-flow-basics/break-continue/labels.md
msgid ""
"Both `continue` and `break` can optionally take a label argument which is "
"used to break out of nested loops:"
msgstr ""
"At칙t `continue`, c칙t 탳i `break` pot primi op탵ional un argument de tip label, "
"care este utilizat pentru a ie탳i din buclele imbricate:"

#: src/control-flow-basics/break-continue/labels.md
#, fuzzy
msgid "\"elements searched: {elements_searched}\""
msgstr "\"elemente c캒utate: {elements_searched}\""

#: src/control-flow-basics/break-continue/labels.md
msgid ""
"Note that `loop` is the only looping construct which returns a non-trivial "
"value. This is because it's guaranteed to be entered at least once (unlike "
"`while` and `for` loops)."
msgstr ""
"Re탵ine탵i c캒 `loop` este singura construc탵ie de bucl캒 care returneaz캒 o "
"valoare non-trivial캒. Garanteaz캒 c캒 bocla este rulat캒 cel pu탵in o dat캒 (spre "
"deosebire de buclele `while` 탳i `for`)."

#: src/control-flow-basics/blocks-and-scopes.md
msgid "Blocks"
msgstr "Blocuri"

#: src/control-flow-basics/blocks-and-scopes.md
msgid ""
"A block in Rust contains a sequence of expressions, enclosed by braces `{}`. "
"Each block has a value and a type, which are those of the last expression of "
"the block:"
msgstr ""
"Un bloc 칥n Rust con탵ine o secven탵캒 de expresii. Fiecare bloc are o valoare "
"탳i un tip, care sunt cele ale ultimei expresii din bloc:"

#: src/control-flow-basics/blocks-and-scopes.md
msgid "\"y: {y}\""
msgstr "\"y: {y}\""

#: src/control-flow-basics/blocks-and-scopes.md
msgid ""
"If the last expression ends with `;`, then the resulting value and type is "
"`()`."
msgstr ""
"Dac캒 ultima expresie se termin캒 cu `;`, atunci valoarea 탳i tipul rezultat "
"este `()`."

#: src/control-flow-basics/blocks-and-scopes.md
msgid ""
"You can show how the value of the block changes by changing the last line in "
"the block. For instance, adding/removing a semicolon or using a `return`."
msgstr ""
"Pute탵i ar캒ta cum se modific캒 valoarea blocului modific칙nd ultima linie din "
"bloc. De exemplu, ad캒ug칙nd/elimin칙nd un punct 탳i virgul캒 sau folosind un "
"`return`."

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid "A variable's scope is limited to the enclosing block."
msgstr ""
"Domeniul de aplicare al unei variabile este limitat la blocul care o con탵ine."

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid ""
"You can shadow variables, both those from outer scopes and variables from "
"the same scope:"
msgstr ""
"Pute탵i dedubla variabilele, at칙t cele din domenii de aplicare exterioare, "
"c칙t 탳i variabilele din acela탳i domeniu de aplicare:"

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid "\"before: {a}\""
msgstr "\"칥nainte: {a}\""

#: src/control-flow-basics/blocks-and-scopes/scopes.md src/generics/exercise.md
#: src/generics/solution.md src/std-traits/from-and-into.md
#: src/lifetimes/solution.md
msgid "\"hello\""
msgstr "\"hello\""

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid "\"inner scope: {a}\""
msgstr "\"domeniul de aplicare interior: {a}\""

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid "\"shadowed in inner scope: {a}\""
msgstr "\"dedublat캒 칥n domeniul interior: {a}\""

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid "\"after: {a}\""
msgstr "\"캠up캒: {a}\""

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid ""
"Show that a variable's scope is limited by adding a `b` in the inner block "
"in the last example, and then trying to access it outside that block."
msgstr ""
"Ar캒ta탵i c캒 domeniul de aplicare al unei variabile este limitat prin "
"ad캒ugarea unui `b` 칥n blocul interior din ultimul exemplu 탳i apoi prin "
"칥ncercarea de a o accesa 칥n afara blocului."

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid ""
"Shadowing is different from mutation, because after shadowing both "
"variable's memory locations exist at the same time. Both are available under "
"the same name, depending where you use it in the code."
msgstr ""
"Defini탵ie: Dedublarea este diferit캒 de muta탵ie, deoarece dup캒 dedublare "
"ambele loca탵ii de memorie ale variabilei exist캒 칥n acela탳i timp. Ambele sunt "
"disponibile sub acela탳i nume, 칥n func탵ie de locul 칥n care se utilizeaz캒 칥n "
"cod."

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid "A shadowing variable can have a different type."
msgstr "O variabil캒 dedublat캒 poate avea un tip diferit."

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid ""
"Shadowing looks obscure at first, but is convenient for holding on to values "
"after `.unwrap()`."
msgstr ""
"Dedublarea pare obscur캒 la 칥nceput, dar este convenabil캒 pentru a p캒stra "
"valorile dup캒 `.unwrap()`."

#: src/control-flow-basics/functions.md
msgid ""
"Declaration parameters are followed by a type (the reverse of some "
"programming languages), then a return type."
msgstr ""
"Parametrii de declara탵ie sunt urma탵i de un tip (invers dec칙t 칥n alte limbaje "
"de programare), apoi de tipul valorii returnate."

#: src/control-flow-basics/functions.md
msgid ""
"The last expression in a function body (or any block) becomes the return "
"value. Simply omit the `;` at the end of the expression. The `return` "
"keyword can be used for early return, but the \"bare value\" form is "
"idiomatic at the end of a function (refactor `gcd` to use a `return`)."
msgstr ""
"Ultima expresie din corpul unei func탵ii (sau din orice bloc) devine valoarea "
"de returnare. Pur 탳i simplu omite탵i `;` de la sf칙r탳itul expresiei. Cuv칙ntul "
"cheie `return` se poate folosi pentru a ie탳i anticipat din func탵ie, dar "
"\"valoarea brut캒\" este idiomatic캒 la sf칙r탳itul func탵iei (rescrie탵i `gcr` "
"pentru a utiliza un `return`)."

#: src/control-flow-basics/functions.md
msgid ""
"Some functions have no return value, and return the 'unit type', `()`. The "
"compiler will infer this if the `-> ()` return type is omitted."
msgstr ""
"Unele func탵ii nu au nicio valoare de retur 탳i returneaz캒 \"tipul unitate\", "
"`()`. Compilatorul va deduce acest lucru 칥n cazul 칥n care tipul de returnare "
"`-> ()` este omis."

#: src/control-flow-basics/functions.md
msgid ""
"Overloading is not supported -- each function has a single implementation."
msgstr ""
"Supra칥nc캒rcarea nu este suportat캒  fiecare func탵ie are o singur캒 "
"implementare."

#: src/control-flow-basics/functions.md
msgid ""
"Always takes a fixed number of parameters. Default arguments are not "
"supported. Macros can be used to support variadic functions."
msgstr ""
"Accept캒 칥ntotdeauna un num캒r fix de parametri. Argumentele implicite nu sunt "
"acceptate. Se pot utiliza macrocomenzi pentru a sprijini func탵iile variadice."

#: src/control-flow-basics/functions.md
msgid ""
"Always takes a single set of parameter types. These types can be generic, "
"which will be covered later."
msgstr ""
"Accept캒 칥ntotdeauna un singur set de tipuri de parametri. Acestea pot fi "
"generice, despre care vom discuta mai t칙rziu."

#: src/control-flow-basics/macros.md
msgid ""
"Macros are expanded into Rust code during compilation, and can take a "
"variable number of arguments. They are distinguished by a `!` at the end. "
"The Rust standard library includes an assortment of useful macros."
msgstr ""
"Macrocomenzile sunt expandate 칥n codul Rust 칥n timpul compil캒rii 탳i pot "
"primi un num캒r variabil de argumente. Ele se disting prin ad캒ugarea unui `!` "
"la sf칙r탳it. Biblioteca standard Rust include o gam캒 칥ntreag캒 de macro-uri "
"utile."

#: src/control-flow-basics/macros.md
msgid ""
"`println!(format, ..)` prints a line to standard output, applying formatting "
"described in [`std::fmt`](https://doc.rust-lang.org/std/fmt/index.html)."
msgstr ""
"`println!(format, ..)` afi탳eaz캒 o linie la ie탳irea standard, aplic칙nd "
"formatarea specificat캒 칥n [`std::fmt`](https://doc.rust-lang.org/std/fmt/"
"index.html)."

#: src/control-flow-basics/macros.md
msgid ""
"`format!(format, ..)` works just like `println!` but returns the result as a "
"string."
msgstr ""
"`format!(format, ..)` func탵ioneaz캒 la fel ca `println!`, dar returneaz캒 "
"rezultatul sub forma unui 탳ir de caractere."

#: src/control-flow-basics/macros.md
msgid "`dbg!(expression)` logs the value of the expression and returns it."
msgstr "`dbg!(expresie)` 칥nregistreaz캒 valoarea expresiei 탳i o returneaz캒."

#: src/control-flow-basics/macros.md
msgid ""
"`todo!()` marks a bit of code as not-yet-implemented. If executed, it will "
"panic."
msgstr ""
"`todo!()` marcheaz캒 o bucat캒 de cod ca fiind neimplementat캒 칥nc캒. Dac캒 este "
"executat, va intra 칥n panic캒."

#: src/control-flow-basics/macros.md
msgid ""
"`unreachable!()` marks a bit of code as unreachable. If executed, it will "
"panic."
msgstr ""
"`unreachable!()` marcheaz캒 un fragment de cod ca fiind inaccesibil. Dac캒 "
"este executat, programul va intra 칥n panic캒."

#: src/control-flow-basics/macros.md
msgid "\"{n}! = {}\""
msgstr "\"{n}! = {}\""

#: src/control-flow-basics/macros.md
msgid ""
"The takeaway from this section is that these common conveniences exist, and "
"how to use them. Why they are defined as macros, and what they expand to, is "
"not especially critical."
msgstr ""
"Trebuie s캒 re탵ine탵i cum s캒 folosi탵i aceste facilit캒탵i comune. De ce sunt "
"definite ca macro-uri 탳i la ce se extind acestea nu este deosebit de "
"important."

#: src/control-flow-basics/macros.md
#, fuzzy
msgid ""
"The course does not cover defining macros, but a later section will describe "
"use of derive macros."
msgstr ""
"Cursul nu acoper캒 definirea macrocomenzilor, dar o sec탵iune ulterioar캒 va "
"descrie utilizarea macrocomenzilor `derive`."

#: src/control-flow-basics/exercise.md
msgid ""
"The [Collatz Sequence](https://en.wikipedia.org/wiki/Collatz_conjecture) is "
"defined as follows, for an arbitrary n"
msgstr ""
"[Secven탵a Collatz](https://en.wikipedia.org/wiki/Collatz_conjecture) se "
"define탳te dup캒 cum urmeaz캒, pentru un num캒r n arbitrar"

#: src/control-flow-basics/exercise.md
msgid "1"
msgstr "1"

#: src/control-flow-basics/exercise.md
msgid " greater than zero:"
msgstr " mai mare dec칙t zero:"

#: src/control-flow-basics/exercise.md
msgid "If _n"
msgstr "If _n"

#: src/control-flow-basics/exercise.md
msgid "i"
msgstr "i"

#: src/control-flow-basics/exercise.md
msgid "_ is 1, then the sequence terminates at _n"
msgstr "_ este 1, atunci secven탵a se termin캒 la _n"

#: src/control-flow-basics/exercise.md
msgid "_."
msgstr "_."

#: src/control-flow-basics/exercise.md
msgid "_ is even, then _n"
msgstr "_ este par, atunci _n"

#: src/control-flow-basics/exercise.md
msgid "i+1"
msgstr "i+1"

#: src/control-flow-basics/exercise.md
msgid " = n"
msgstr " = n"

#: src/control-flow-basics/exercise.md
msgid " / 2_."
msgstr " / 2_."

#: src/control-flow-basics/exercise.md
msgid "_ is odd, then _n"
msgstr "_ este impar, atunci _n"

#: src/control-flow-basics/exercise.md
msgid " = 3 * n"
msgstr " = 3 * n"

#: src/control-flow-basics/exercise.md
msgid " + 1_."
msgstr " + 1_."

#: src/control-flow-basics/exercise.md
msgid "For example, beginning with _n"
msgstr "De exemplu, 칥ncep칙nd cu _n"

#: src/control-flow-basics/exercise.md
msgid "_ = 3:"
msgstr "_ = 3:"

#: src/control-flow-basics/exercise.md
msgid "3 is odd, so _n"
msgstr "3 este impar, deci _n"

#: src/control-flow-basics/exercise.md
msgid "2"
msgstr "2"

#: src/control-flow-basics/exercise.md
msgid "_ = 3 * 3 + 1 = 10;"
msgstr "_ = 3 * 3 + 1 = 10;"

#: src/control-flow-basics/exercise.md
msgid "10 is even, so _n"
msgstr "10 este par, deci _n"

#: src/control-flow-basics/exercise.md src/bare-metal/aps/better-uart.md
msgid "3"
msgstr "3"

#: src/control-flow-basics/exercise.md
msgid "_ = 10 / 2 = 5;"
msgstr "_ = 10 / 2 = 5;"

#: src/control-flow-basics/exercise.md
msgid "5 is odd, so _n"
msgstr "5 este impar, deci _n"

#: src/control-flow-basics/exercise.md src/bare-metal/aps/better-uart.md
msgid "4"
msgstr "4"

#: src/control-flow-basics/exercise.md
msgid "_ = 3 * 5 + 1 = 16;"
msgstr "_ = 3 * 5 + 1 = 16;"

#: src/control-flow-basics/exercise.md
msgid "16 is even, so _n"
msgstr "16 este par, deci _n"

#: src/control-flow-basics/exercise.md
msgid "5"
msgstr "5"

#: src/control-flow-basics/exercise.md
msgid "_ = 16 / 2 = 8;"
msgstr "_ = 16 / 2 = 8;"

#: src/control-flow-basics/exercise.md
msgid "8 is even, so _n"
msgstr "8 este par, deci _n"

#: src/control-flow-basics/exercise.md src/bare-metal/aps/better-uart.md
msgid "6"
msgstr "6"

#: src/control-flow-basics/exercise.md
msgid "_ = 8 / 2 = 4;"
msgstr "_ = 8 / 2 = 4;"

#: src/control-flow-basics/exercise.md
msgid "4 is even, so _n"
msgstr "4 este par, deci _n"

#: src/control-flow-basics/exercise.md
msgid "7"
msgstr "7"

#: src/control-flow-basics/exercise.md
msgid "_ = 4 / 2 = 2;"
msgstr "_ = 4 / 2 = 2;"

#: src/control-flow-basics/exercise.md
msgid "2 is even, so _n"
msgstr "2 este par, deci _n"

#: src/control-flow-basics/exercise.md src/bare-metal/aps/better-uart.md
msgid "8"
msgstr "8"

#: src/control-flow-basics/exercise.md
msgid "_ = 1; and"
msgstr "_ = 1; and"

#: src/control-flow-basics/exercise.md
msgid "the sequence terminates."
msgstr "secven탵a se termin캒."

#: src/control-flow-basics/exercise.md
msgid ""
"Write a function to calculate the length of the collatz sequence for a given "
"initial `n`."
msgstr ""
"Scrie탵i o func탵ie care s캒 calculeze lungimea secven탵ei Collatz pentru un "
"anumit `n` ini탵ial."

#: src/control-flow-basics/exercise.md src/control-flow-basics/solution.md
msgid "/// Determine the length of the collatz sequence beginning at `n`.\n"
msgstr "/// Determina탵i lungimea secven탵ei collatz care 칥ncepe la `n`.\n"

#: src/control-flow-basics/solution.md src/concurrency/threads/scoped.md
msgid "\"Length: {}\""
msgstr "\"Length: {}\""

#: src/welcome-day-1-afternoon.md src/welcome-day-2-afternoon.md
#: src/welcome-day-3-afternoon.md src/welcome-day-4-afternoon.md
msgid "Welcome Back"
msgstr "Bine a탵i revenit"

#: src/welcome-day-1-afternoon.md
#, fuzzy
msgid "[Tuples and Arrays](./tuples-and-arrays.md) (35 minutes)"
msgstr "[Tupluri 탳i vectori](./tuples-and-arrays.md) (1 or캒)"

#: src/welcome-day-1-afternoon.md
#, fuzzy
msgid "[References](./references.md) (55 minutes)"
msgstr "[Referin탵e](../references.md) (50 minute)"

#: src/welcome-day-1-afternoon.md
msgid "[User-Defined Types](./user-defined-types.md) (50 minutes)"
msgstr "[Tipuri definite de utilizator](../user-defined-types.md) (50 minute)"

#: src/welcome-day-1-afternoon.md
#, fuzzy
msgid ""
"Including 10 minute breaks, this session should take about 2 hours and 35 "
"minutes"
msgstr ""
"Incluz칙nd pauzele de 10 minute, aceast캒 sesiune ar trebui s캒 dureze "
"aproximativ 2 ore 탳i 55 de minute"

#: src/tuples-and-arrays.md
#, fuzzy
msgid "[Arrays](./tuples-and-arrays/arrays.md) (5 minutes)"
msgstr ""
"[Tupluri 탳i vectori](./tuples-and-arrays/tuples-and-arrays.md)  (10 minute)"

#: src/tuples-and-arrays.md
#, fuzzy
msgid "[Tuples](./tuples-and-arrays/tuples.md) (5 minutes)"
msgstr ""
"[Tupluri 탳i vectori](./tuples-and-arrays/tuples-and-arrays.md)  (10 minute)"

#: src/tuples-and-arrays.md
msgid "[Array Iteration](./tuples-and-arrays/iteration.md) (3 minutes)"
msgstr "[Iterarea pe vectori](./tuples-and-arrays/iteration.md) (3 minute)"

#: src/tuples-and-arrays.md
#, fuzzy
msgid ""
"[Patterns and Destructuring](./tuples-and-arrays/destructuring.md) (5 "
"minutes)"
msgstr "[Destructurare](./tuples-and-arrays/destructuring.md) (5 minute)"

#: src/tuples-and-arrays.md
#, fuzzy
msgid "[Exercise: Nested Arrays](./tuples-and-arrays/exercise.md) (15 minutes)"
msgstr ""
"[Exerci탵iu: vectori imbrica탵i](./tuples-and-arrays/exercise.mds) (30 minute)"

#: src/tuples-and-arrays.md
#, fuzzy
msgid "This segment should take about 35 minutes"
msgstr "Acest segment ar trebui s캒 dureze aproximativ 55 de minute"

#: src/tuples-and-arrays/arrays.md
msgid ""
"A value of the array type `[T; N]` holds `N` (a compile-time constant) "
"elements of the same type `T`. Note that the length of the array is _part of "
"its type_, which means that `[u8; 3]` and `[u8; 4]` are considered two "
"different types. Slices, which have a size determined at runtime, are "
"covered later."
msgstr ""
"O valoare de tip tablou `[T; N]` con탵ine `N` (o constant캒 de timp de "
"compilare) elemente de acela탳i tip `T`. Re탵ine탵i c캒 lungimea tabloului este "
"_parte a tipului s캒u_, ceea ce 칥nseamn캒 c캒 `[u8; 3]` 탳i `[u8; 4]` sunt "
"considerate dou캒 tipuri diferite."

#: src/tuples-and-arrays/arrays.md
msgid ""
"Try accessing an out-of-bounds array element. Array accesses are checked at "
"runtime. Rust can usually optimize these checks away, and they can be "
"avoided using unsafe Rust."
msgstr ""
"칉ncerca탵i s캒 accesa탵i un element de tablou 칥n afara limitelor. Acces캒rile "
"elementelor din tablou sunt verificate 칥n timpul execu탵iei. De obicei, Rust "
"poate optimiza aceste verific캒ri, iar acestea pot fi evitate folosind unsafe "
"Rust."

#: src/tuples-and-arrays/arrays.md
msgid "We can use literals to assign values to arrays."
msgstr "Putem utiliza literali pentru a atribui valori la matrice."

#: src/tuples-and-arrays/arrays.md
msgid ""
"The `println!` macro asks for the debug implementation with the `?` format "
"parameter: `{}` gives the default output, `{:?}` gives the debug output. "
"Types such as integers and strings implement the default output, but arrays "
"only implement the debug output. This means that we must use debug output "
"here."
msgstr ""
"Macroul `println!` solicit캒 implementarea de depanare cu parametrul de "
"format `?`: `{}` ofer캒 ie탳irea implicit캒, `{:?}` ofer캒 ie탳irea de depanare. "
"Tipuri precum 칥ntregi 탳i 탳iruri de caractere implementeaz캒 ie탳irea "
"implicit캒, dar matricile implementeaz캒 doar ie탳irea de depanare. Aceasta "
"칥nseamn캒 c캒 trebuie s캒 folosim aici ie탳irea de depanare."

#: src/tuples-and-arrays/arrays.md
msgid ""
"Adding `#`, eg `{a:#?}`, invokes a \"pretty printing\" format, which can be "
"easier to read."
msgstr ""
"Ad캒ug칙nd `#`, de exemplu `{a:#?}`, se invoc캒 un format de tip캒rire "
"\"frumos\", care poate fi mai u탳or de citit."

#: src/tuples-and-arrays/tuples.md
msgid "Like arrays, tuples have a fixed length."
msgstr "Tuplurile au o lungime fix캒, 칥ntocmai vectorilor."

#: src/tuples-and-arrays/tuples.md
msgid "Tuples group together values of different types into a compound type."
msgstr "Tuplurile grupeaz캒 valori de tipuri diferite 칥ntr-un tip compus."

#: src/tuples-and-arrays/tuples.md
msgid ""
"Fields of a tuple can be accessed by the period and the index of the value, "
"e.g. `t.0`, `t.1`."
msgstr ""
"C칙mpurile unui tuplu pot fi accesate prin punct 탳i indicele valorii, de "
"exemplu `t.0`, `t.1`."

#: src/tuples-and-arrays/tuples.md
#, fuzzy
msgid ""
"The empty tuple `()` is referred to as the \"unit type\" and signifies "
"absence of a return value, akin to `void` in other languages."
msgstr ""
"Tupla goal캒 `()` este denumit캒 \"tip unitate\" 탳i semnific캒 absen탵a unei "
"valori de returnare, asem캒n캒toare cu `void` din alte limbaje."

#: src/tuples-and-arrays/iteration.md
msgid "The `for` statement supports iterating over arrays (but not tuples)."
msgstr ""
"Instruc탵iunea `for` permite itera탵ia peste tablouri (dar nu 탳i peste "
"tupluri)."

#: src/tuples-and-arrays/iteration.md
msgid ""
"This functionality uses the `IntoIterator` trait, but we haven't covered "
"that yet."
msgstr ""
"Aceast캒 func탵ionalitate utilizeaz캒 tr캒s캒tura `IntoIterator`, dar 칥nc캒 nu am "
"abordat캒-o 칥n cadrul cursului."

#: src/tuples-and-arrays/iteration.md
msgid ""
"The `assert_ne!` macro is new here. There are also `assert_eq!` and `assert!"
"` macros. These are always checked while, debug-only variants like "
"`debug_assert!` compile to nothing in release builds."
msgstr ""
"Macroul `assert_ne!` este nou aici. Exist캒, de asemenea, macrourile "
"`assert_eq!` 탳i `assert!`. Acestea sunt 칥ntotdeauna verificate, 칥n timp ce "
"variantele destinate depan캒rii, cum ar fi `debug_assert!`, nu se compileaz캒 "
"칥n versiunile de lansare."

#: src/tuples-and-arrays/destructuring.md
#, fuzzy
msgid ""
"When working with tuples and other structured values it's common to want to "
"extract the inner values into local variables. This can be done manually by "
"directly accessing the inner values:"
msgstr ""
"Atunci c칙nd se lucreaz캒 cu tupluri 탳i alte valori structurate, este obi탳nuit "
"s캒 se doreasc캒 extragerea valorilor interioare 칥n variabile locale. Acest "
"lucru se poate face manual prin accesarea direct캒 a valorilor interioare:"

#: src/tuples-and-arrays/destructuring.md
#, fuzzy
msgid "\"left: {left}, right: {right}\""
msgstr "\"st칙nga: {left}, dreapta: {right}\""

#: src/tuples-and-arrays/destructuring.md
#, fuzzy
msgid ""
"However, Rust also supports using pattern matching to destructure a larger "
"value into its constituent parts:"
msgstr ""
"Cu toate acestea, Rust suport캒, de asemenea, utilizarea potrivirii de tipare "
"pentru a destructura o valoare mai mare 칥n p캒r탵ile sale constitutive:"

#: src/tuples-and-arrays/destructuring.md
#, fuzzy
msgid ""
"The patterns used here are \"irrefutable\", meaning that the compiler can "
"statically verify that the value on the right of `=` has the same structure "
"as the pattern."
msgstr ""
"Tiparele utilizate aici sunt \"irefutabile\", ceea ce 칥nseamn캒 c캒 "
"compilatorul poate verifica static c캒 valoarea din dreapta lui `=` are "
"aceea탳i structur캒 ca 탳i modelul."

#: src/tuples-and-arrays/destructuring.md
#, fuzzy
msgid ""
"A variable name is an irrefutable pattern that always matches any value, "
"hence why we can also use `let` to declare a single variable."
msgstr ""
"Un nume de variabil캒 este un model irefutabil care se potrive탳te 칥ntotdeauna "
"cu orice valoare, de aceea putem folosi 탳i `let` pentru a declara o singur캒 "
"variabil캒."

#: src/tuples-and-arrays/destructuring.md
#, fuzzy
msgid ""
"Rust also supports using patterns in conditionals, allowing for equality "
"comparison and destructuring to happen at the same time. This form of "
"pattern matching will be discussed in more detail later."
msgstr ""
"Rust accept캒, de asemenea, utilizarea modelelor 칥n condi탵ionale, permi탵칙nd "
"compararea egalit캒탵ii 탳i destructurarea 칥n acela탳i timp. Aceast캒 form캒 de "
"potrivire a modelelor va fi discutat캒 mai 칥n detaliu mai t칙rziu."

#: src/tuples-and-arrays/destructuring.md
#, fuzzy
msgid ""
"Edit the examples above to show the compiler error when the pattern doesn't "
"match the value being matched on."
msgstr ""
"Modifica탵i exemplele de mai sus pentru a afi탳a eroarea compilatorului atunci "
"c칙nd modelul nu se potrive탳te cu valoarea pe care se face potrivirea."

#: src/tuples-and-arrays/exercise.md
msgid "Arrays can contain other arrays:"
msgstr "Vectorii pot con탵ine al탵i vectori:"

#: src/tuples-and-arrays/exercise.md
msgid "What is the type of this variable?"
msgstr "Care este tipul acestei variabile?"

#: src/tuples-and-arrays/exercise.md
msgid ""
"Use an array such as the above to write a function `transpose` which will "
"transpose a matrix (turn rows into columns):"
msgstr ""
"Folosi탵i cele de mai sus pentru a scrie o func탵ie `transpose` care va "
"transpune o matrice (transform캒 r칙ndurile 칥n coloane):"

#: src/tuples-and-arrays/exercise.md
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and implement the "
"function. This function only operates on 3x3 matrices."
msgstr ""
"Copia탵i codul de mai jos 칥n <https://play.rust-lang.org/> 탳i implementa탵i "
"func탵ia."

#: src/tuples-and-arrays/exercise.md src/borrowing/exercise.md
#: src/unsafe-rust/exercise.md
msgid "// TODO: remove this when you're done with your implementation.\n"
msgstr ""
"// TODO: elimina탵i acest comentariu atunci c칙nd a탵i terminat cu "
"implementarea.\n"

#: src/tuples-and-arrays/exercise.md src/tuples-and-arrays/solution.md
msgid "//\n"
msgstr "//\n"

#: src/tuples-and-arrays/exercise.md src/tuples-and-arrays/solution.md
msgid "// <-- the comment makes rustfmt add a newline\n"
msgstr "// <-- comentariul face ca rustfmt s캒 adauge o linie nou캒\n"

#: src/tuples-and-arrays/exercise.md src/tuples-and-arrays/solution.md
msgid "\"matrix: {:#?}\""
msgstr "\"Matricea: {:#?}\""

#: src/tuples-and-arrays/exercise.md src/tuples-and-arrays/solution.md
msgid "\"transposed: {:#?}\""
msgstr "\"transpus: {:#?}\""

#: src/references.md
msgid "[Shared References](./references/shared.md) (10 minutes)"
msgstr "[Referin탵e partajate](./references/shared.md) (10 minute)"

#: src/references.md
msgid "[Exclusive References](./references/exclusive.md) (10 minutes)"
msgstr "[Referin탵e exclusive](./references/exclusive.md) (10 minute)"

#: src/references.md
#, fuzzy
msgid "[Slices: &\\[T\\]](./references/slices.md) (10 minutes)"
msgstr "[Slices: &\\[T\\]](./slices-and-lifetimes/slices.md) (10 minute)"

#: src/references.md
#, fuzzy
msgid "[Strings](./references/strings.md) (10 minutes)"
msgstr "[탲iruri](./types-and-values/strings.md) (10 minute)"

#: src/references.md
#, fuzzy
msgid "[Exercise: Geometry](./references/exercise.md) (15 minutes)"
msgstr "[Exerci탵iu: Geometrie](./references/exercise.md) (30 minute)"

#: src/references.md src/smart-pointers.md src/borrowing.md
#: src/error-handling.md src/concurrency/async-pitfalls.md
#, fuzzy
msgid "This segment should take about 55 minutes"
msgstr "Acest segment ar trebui s캒 dureze aproximativ 55 de minute"

#: src/references/shared.md
#, fuzzy
msgid ""
"A reference provides a way to access another value without taking "
"responsibility for the value, and is also called \"borrowing\". Shared "
"references are read-only, and the referenced data cannot change."
msgstr ""
"O referin탵캒 ofer캒 o modalitate de a accesa o alt캒 valoare f캒r캒 a prelua "
"responsabilitatea pentru valoarea respectiv캒, fiind denumit캒 탳i "
"\"칥mprumut\". Referin탵ele partajate sunt numai pentru citire, iar datele la "
"care se face referire nu se pot modifica."

#: src/references/shared.md
#, fuzzy
msgid ""
"A shared reference to a type `T` has type `&T`. A reference value is made "
"with the `&` operator. The `*` operator \"dereferences\" a reference, "
"yielding its value."
msgstr ""
"O referin탵캒 partajat캒 la un tip `T` are tipul `&T`. O valoare de referin탵캒 "
"se realizeaz캒 cu ajutorul operatorului `&`. Operatorul `*` \"de-"
"referen탵iaz캒\" o referin탵캒, ob탵in칙nd valoarea acesteia."

#: src/references/shared.md
msgid "Rust will statically forbid dangling references:"
msgstr "Rust va interzice 칥n mod static referin탵ele invalide:"

#: src/references/shared.md
#, fuzzy
msgid ""
"A reference is said to \"borrow\" the value it refers to, and this is a good "
"model for students not familiar with pointers: code can use the reference to "
"access the value, but is still \"owned\" by the original variable. The "
"course will get into more detail on ownership in day 3."
msgstr ""
"Se spune c캒 o referin탵캒 \"칥mprumut캒\" valoarea la care se refer캒, iar acesta "
"este un model bun pentru elevii care nu sunt familiariza탵i cu indicatoarele: "
"codul poate folosi referin탵a pentru a accesa valoarea, dar este 칥n "
"continuare \"de탵inut캒\" de variabila original캒. Cursul va intra 칥n mai multe "
"detalii despre proprietate 칥n ziua 3."

#: src/references/shared.md
#, fuzzy
msgid ""
"References are implemented as pointers, and a key advantage is that they can "
"be much smaller than the thing they point to. Students familiar with C or C+"
"+ will recognize references as pointers. Later parts of the course will "
"cover how Rust prevents the memory-safety bugs that come from using raw "
"pointers."
msgstr ""
"Referin탵ele sunt implementate sub form캒 de pointeri, iar un avantaj cheie "
"este c캒 pot fi mult mai mici dec칙t obiectul spre care indic캒. Studen탵ii "
"familiariza탵i cu C sau C++ vor recunoa탳te referin탵ele ca fiind pointeri. "
"P캒r탵ile ulterioare ale cursului vor acoperi modul 칥n care Rust previne "
"erorile de siguran탵캒 a memoriei care apar 칥n cazul utiliz캒rii de pointeri "
"brute."

#: src/references/shared.md
#, fuzzy
msgid ""
"Rust does not automatically create references for you - the `&` is always "
"required."
msgstr ""
"Rust nu creeaz캒 automat referin탵e pentru dumneavoastr캒 - `&` este "
"칥ntotdeauna necesar."

#: src/references/shared.md
#, fuzzy
msgid ""
"Rust will auto-dereference in some cases, in particular when invoking "
"methods (try `r.is_ascii()`). There is no need for an `->` operator like in "
"C++."
msgstr ""
"Rust va face auto-dereferen탵iere 칥n unele cazuri, 칥n special atunci c칙nd "
"invoc캒 metode (칥ncerca탵i `ref_x.count_ones()`)."

#: src/references/shared.md
#, fuzzy
msgid ""
"In this example, `r` is mutable so that it can be reassigned (`r = &b`). "
"Note that this re-binds `r`, so that it refers to something else. This is "
"different from C++, where assignment to a reference changes the referenced "
"value."
msgstr ""
"칉n acest exemplu, `r` este mutabil, astfel 칥nc칙t poate fi realocat (`r = "
"&b`). Re탵ine탵i c캒 acest lucru reia `r`, astfel 칥nc칙t acesta se refer캒 la "
"altceva. Acest lucru este diferit de C++, unde atribuirea unei referin탵e "
"modific캒 valoarea la care se face referire."

#: src/references/shared.md
#, fuzzy
msgid ""
"A shared reference does not allow modifying the value it refers to, even if "
"that value was mutable. Try `*r = 'X'`."
msgstr ""
"O referin탵캒 partajat캒 nu permite modificarea valorii la care se refer캒, "
"chiar dac캒 valoarea respectiv캒 era mutabil캒. 칉ncerca탵i `*r = 'X'`."

#: src/references/shared.md
#, fuzzy
msgid ""
"Rust is tracking the lifetimes of all references to ensure they live long "
"enough. Dangling references cannot occur in safe Rust. `x_axis` would return "
"a reference to `point`, but `point` will be deallocated when the function "
"returns, so this will not compile."
msgstr ""
"Rust urm캒re탳te durata de via탵캒 a tuturor referin탵elor pentru a se asigura c캒 "
"acestea tr캒iesc suficient de mult. 칉n Rust sigur nu pot ap캒rea referin탵e "
"care s캒 stea 칥n suspensie. `x_axis` ar trebui s캒 returneze o referin탵캒 la "
"`point`, dar `point` va fi dezalocat atunci c칙nd func탵ia se 칥ntoarce, deci "
"nu va fi compilat."

#: src/references/shared.md
msgid "We will talk more about borrowing when we get to ownership."
msgstr ""
"Vom vorbi mai multe despre 칥mprumuturi atunci c칙nd vom ajunge la posesie."

#: src/references/exclusive.md
#, fuzzy
msgid ""
"Exclusive references, also known as mutable references, allow changing the "
"value they refer to. They have type `&mut T`."
msgstr ""
"Referin탵ele exclusive, cunoscute 탳i sub denumirea de referin탵e mutabile, "
"permit modificarea valorii la care se refer캒. Ele au tipul `&mut T`."

#: src/references/exclusive.md
#, fuzzy
msgid ""
"\"Exclusive\" means that only this reference can be used to access the "
"value. No other references (shared or exclusive) can exist at the same time, "
"and the referenced value cannot be accessed while the exclusive reference "
"exists. Try making an `&point.0` or changing `point.0` while `x_coord` is "
"alive."
msgstr ""
"\"Exclusiv\" 칥nseamn캒 c캒 numai aceast캒 referin탵캒 poate fi utilizat캒 pentru a "
"accesa valoarea. Nici o alt캒 referin탵캒 (partajat캒 sau exclusiv캒) nu poate "
"exista 칥n acela탳i timp, iar valoarea la care se face referire nu poate fi "
"accesat캒 at칙t timp c칙t exist캒 o referin탵캒 exclusiv캒. 칉ncerca탵i s캒 face탵i un "
"`&punct.0` sau s캒 modifica탵i `punct.0` 칥n timp ce `x_coord` este 칥n via탵캒."

#: src/references/exclusive.md
#, fuzzy
msgid ""
"Be sure to note the difference between `let mut x_coord: &i32` and `let "
"x_coord: &mut i32`. The first one represents a shared reference which can be "
"bound to different values, while the second represents an exclusive "
"reference to a mutable value."
msgstr ""
"Nu uita탵i s캒 observa탵i diferen탵a dintre `let mut ref_x: &i32` 탳i `let ref_x: "
"&mut i32`. Primul reprezint캒 o referin탵캒 mutabil캒 care poate fi legat캒 la "
"diferite valori, 칥n timp ce al doilea reprezint캒 o referin탵캒 la o valoare "
"mutabil캒."

#: src/references/slices.md
msgid "Slices"
msgstr "Felii"

#: src/references/slices.md
msgid "A slice gives you a view into a larger collection:"
msgstr "O felie (elice) v캒 ofer캒 o imagine a unei colec탵ii mai mari:"

#: src/references/slices.md
#, fuzzy
msgid "Slices borrow data from the sliced type."
msgstr "Feliile 칥mprumut캒 date din tipul por탵ionat."

#: src/references/slices.md
msgid "Question: What happens if you modify `a[3]` right before printing `s`?"
msgstr ""
"칉ntrebare: Ce se 칥nt칙mpl캒 dac캒 modifica탵i `a[3]` chiar 칥nainte de a afi탳a "
"`s`?"

#: src/references/slices.md
msgid ""
"We create a slice by borrowing `a` and specifying the starting and ending "
"indexes in brackets."
msgstr ""
"Cre캒m o felie prin 칥mprumutarea lui `a` 탳i specificarea indicilor de 칥nceput "
"탳i de sf칙r탳it 칥ntre paranteze."

#: src/references/slices.md
msgid ""
"If the slice starts at index 0, Rust's range syntax allows us to drop the "
"starting index, meaning that `&a[0..a.len()]` and `&a[..a.len()]` are "
"identical."
msgstr ""
"Dac캒 felia 칥ncepe la indexul 0, sintaxa intervalului din Rust ne permite s캒 "
"renun탵캒m la indexul de pornire, ceea ce 칥nseamn캒 c캒 `&a[0..a.len()]` 탳i "
"`&a[..a.len()]` sunt identice."

#: src/references/slices.md
msgid ""
"The same is true for the last index, so `&a[2..a.len()]` and `&a[2..]` are "
"identical."
msgstr ""
"Acela탳i lucru este valabil 탳i pentru ultimul indice, astfel 칥nc칙t `&a[2..a."
"len()]` 탳i `&a[2..]` sunt identice."

#: src/references/slices.md
#, fuzzy
msgid ""
"To easily create a slice of the full array, we can therefore use `&a[..]`."
msgstr ""
"Pentru a crea cu u탳urin탵캒 o por탵iune din 칥ntrega matrice, putem folosi "
"`&a[...]`."

#: src/references/slices.md
#, fuzzy
msgid ""
"`s` is a reference to a slice of `i32`s. Notice that the type of `s` "
"(`&[i32]`) no longer mentions the array length. This allows us to perform "
"computation on slices of different sizes."
msgstr ""
"`s` este o referin탵캒 la o felie de `i32`s. Observa탵i c캒 tipul lui `s` "
"(`&[i32]`) nu mai men탵ioneaz캒 dimensiunile matricei. Acest lucru ne permite "
"s캒 efectu캒m calcule pe felii de dimensiuni diferite."

#: src/references/slices.md
#, fuzzy
msgid ""
"Slices always borrow from another object. In this example, `a` has to remain "
"'alive' (in scope) for at least as long as our slice."
msgstr ""
"Feliile 칥mprumut캒 칥ntotdeauna de la un alt obiect. 칉n acest exemplu, `a` "
"trebuie s캒 r캒m칙n캒 \"칥n via탵캒\" (칥n domeniul de aplicare) cel pu탵in c칙t felia "
"noastr캒. "

#: src/references/slices.md
#, fuzzy
msgid ""
"The question about modifying `a[3]` can spark an interesting discussion, but "
"the answer is that for memory safety reasons you cannot do it through `a` at "
"this point in the execution, but you can read the data from both `a` and `s` "
"safely. It works before you created the slice, and again after the "
"`println`, when the slice is no longer used."
msgstr ""
"칉ntrebarea despre modificarea lui `a[3]` poate st칙rni o discu탵ie "
"interesant캒, dar r캒spunsul este c캒, din motive de siguran탵캒 a memoriei, nu "
"se poate face acest lucru prin `a` 칥n acest moment al execu탵iei, dar se pot "
"citi datele at칙t din `a`, c칙t 탳i din `s` 칥n siguran탵캒. Func탵ioneaz캒 칥nainte "
"de a crea felia 탳i din nou dup캒 `println`, c칙nd felia nu mai este utilizat캒. "
"Mai multe detalii vor fi explicate 칥n sec탵iunea de verificare a "
"칥mprumuturilor."

#: src/references/strings.md
msgid "We can now understand the two string types in Rust:"
msgstr "Acum putem 칥n탵elege cele dou캒 tipuri de 탳iruri de caractere din Rust:"

#: src/references/strings.md
#, fuzzy
msgid "`&str` is a slice of UTF-8 encoded bytes, similar to `&[u8]`."
msgstr "`&str` este o felie de octe탵i codifica탵i UTF-8, similar cu `&[u8]`."

#: src/references/strings.md
#, fuzzy
msgid ""
"`String` is an owned buffer of UTF-8 encoded bytes, similar to `Vec<T>`."
msgstr "`&str` este o felie de octe탵i codifica탵i UTF-8, similar cu `&[u8]`."

#: src/references/strings.md src/std-traits/read-and-write.md
#, fuzzy
msgid "\"World\""
msgstr "\"Lumea\""

#: src/references/strings.md
#, fuzzy
msgid "\"s1: {s1}\""
msgstr "\"s1: {s1}\""

#: src/references/strings.md
#, fuzzy
msgid "\"Hello \""
msgstr "\"hello\""

#: src/references/strings.md src/memory-management/move.md
msgid "\"s2: {s2}\""
msgstr "\"s2: {s2}\""

#: src/references/strings.md
#, fuzzy
msgid "\"s3: {s3}\""
msgstr "\"s3: {s3}\""

#: src/references/strings.md
#, fuzzy
msgid ""
"`&str` introduces a string slice, which is an immutable reference to UTF-8 "
"encoded string data stored in a block of memory. String literals "
"(`\"Hello\"`), are stored in the program's binary."
msgstr ""
"`&str` indic캒 o por탵iune dintr-un 탳ir de caractere, care este o referin탵캒 "
"imuabil캒 la date de 탳ir de caractere codificate UTF-8 stocate 칥ntr-un bloc "
"de memorie. 탲irurile literale (`\"Hello\"`) sunt stocate 칥n binarul "
"programului."

#: src/references/strings.md
#, fuzzy
msgid ""
"Rust's `String` type is a wrapper around a vector of bytes. As with a "
"`Vec<T>`, it is owned."
msgstr ""
"Tipul `String` (탳ir de caractere) din Rust este un 칥nveli탳 칥n jurul unui "
"vector de octe탵i. La fel ca 탳i 칥n cazul unui `Vec<T>`, acesta este propriu."

#: src/references/strings.md
#, fuzzy
msgid ""
"As with many other types `String::from()` creates a string from a string "
"literal; `String::new()` creates a new empty string, to which string data "
"can be added using the `push()` and `push_str()` methods."
msgstr ""
"Ca 탳i 칥n cazul multor alte tipuri, `String::from()` creeaz캒 un 탳ir de "
"caractere dintr-un literal de 탳ir; `String::new()` creeaz캒 un nou 탳ir de "
"caractere gol, la care se pot ad캒uga date de 탳iruri de caractere folosind "
"metodele `push()` 탳i `push_str()`."

#: src/references/strings.md
#, fuzzy
msgid ""
"The `format!()` macro is a convenient way to generate an owned string from "
"dynamic values. It accepts the same format specification as `println!()`."
msgstr ""
"Macroul `format!()` este o modalitate convenabil캒 de a genera un 탳ir de "
"caractere proprii din valori dinamice. Accept캒 aceea탳i specifica탵ie de "
"format ca 탳i `println!()`."

#: src/references/strings.md
#, fuzzy
msgid ""
"You can borrow `&str` slices from `String` via `&` and optionally range "
"selection. If you select a byte range that is not aligned to character "
"boundaries, the expression will panic. The `chars` iterator iterates over "
"characters and is preferred over trying to get character boundaries right."
msgstr ""
"Pute탵i 칥mprumuta felii `&str` de la `String` prin `&` 탳i, op탵ional, prin "
"selectarea intervalului. Dac캒 selecta탵i un interval de octe탵i care nu este "
"aliniat la limitele caracterelor, expresia va intra 칥n panic캒. Iteratorul "
"`chars` iter캒 peste caractere 탳i este de preferat 칥n locul 칥ncerc캒rii de a "
"ob탵ine limite de caractere corecte."

#: src/references/strings.md
#, fuzzy
msgid ""
"For C++ programmers: think of `&str` as `std::string_view` from C++, but the "
"one that always points to a valid string in memory. Rust `String` is a rough "
"equivalent of `std::string` from C++ (main difference: it can only contain "
"UTF-8 encoded bytes and will never use a small-string optimization)."
msgstr ""
"Pentru programatorii din C++: g칙ndi탵i-v캒 la `&str` ca la `const char*` din C+"
"+, dar cel care indic캒 칥ntotdeauna un 탳ir de caractere valid 칥n memorie. "
"Rust `String` este un echivalent aproximativ al lui `std::string` din C++ "
"(principala diferen탵캒: poate con탵ine numai octe탵i codifica탵i UTF-8 탳i nu va "
"folosi niciodat캒 o optimizare pentru 탳iruri mici)."

#: src/references/strings.md
#, fuzzy
msgid "Byte strings literals allow you to create a `&[u8]` value directly:"
msgstr "탲irurile de octe탵i v캒 permit s캒 crea탵i direct o valoare `&[u8]`:"

#: src/references/strings.md
msgid ""
"Raw strings allow you to create a `&str` value with escapes disabled: "
"`r\"\\n\" == \"\\\\n\"`. You can embed double-quotes by using an equal "
"amount of `#` on either side of the quotes:"
msgstr ""
"탲irurile brute de caractere v캒 permit s캒 crea탵i o valoare `&str` av칙nd "
"caracterele speciale dezactivate: `r\"\\n\" == \"\\n\"`. Pute탵i 칥ncorpora "
"ghilimele duble folosind o cantitate egal캒 de `#` de o parte 탳i de alta a "
"lor:"

#: src/references/exercise.md
#, fuzzy
msgid ""
"We will create a few utility functions for 3-dimensional geometry, "
"representing a point as `[f64;3]`. It is up to you to determine the function "
"signatures."
msgstr ""
"Vom crea c칙teva func탵ii de utilitate pentru geometria tridimensional캒, "
"reprezent칙nd un punct ca `[f64;3]`. Depinde de dumneavoastr캒 s캒 determina탵i "
"semn캒turile func탵iilor."

#: src/references/exercise.md
#, fuzzy
msgid ""
"// Calculate the magnitude of a vector by summing the squares of its "
"coordinates\n"
"// and taking the square root. Use the `sqrt()` method to calculate the "
"square\n"
"// root, like `v.sqrt()`.\n"
msgstr ""
"// Calculeaz캒 m캒rimea unui vector prin 칥nsumarea p캒tratelor coordonatelor "
"sale\n"
"// 탳i lu칙nd r캒d캒cina p캒trat캒. Utiliza탵i metoda `sqrt()` pentru a calcula "
"p캒tratul\n"
"// r캒d캒cina p캒trat캒, cum ar fi `v.sqrt()`.\n"

#: src/references/exercise.md
#, fuzzy
msgid ""
"// Normalize a vector by calculating its magnitude and dividing all of its\n"
"// coordinates by that magnitude.\n"
msgstr ""
"// Normaliza탵i un vector prin calcularea magnitudinii sale 탳i 칥mp캒r탵irea "
"tuturor vectorilor s캒i\n"
"// coordonate la aceast캒 m캒rime.\n"

#: src/references/exercise.md
msgid "// Use the following `main` to test your work.\n"
msgstr "// Folosi탵i urm캒toarea func탵ie `main` pentru a v캒 testa munca.\n"

#: src/references/exercise.md src/references/solution.md
msgid "\"Magnitude of a unit vector: {}\""
msgstr "\"Magnitudinea unui vector unitar: {}\""

#: src/references/exercise.md src/references/solution.md
msgid "\"Magnitude of {v:?}: {}\""
msgstr "\"Magnitudine de {v:?}: {}\""

#: src/references/exercise.md src/references/solution.md
msgid "\"Magnitude of {v:?} after normalization: {}\""
msgstr "\"Magnitudinea lui {v:?} dup캒 normalizare: {}\""

#: src/references/solution.md
msgid "/// Calculate the magnitude of the given vector.\n"
msgstr "/// Calculeaz캒 magnitudinea vectorului dat.\n"

#: src/references/solution.md
msgid ""
"/// Change the magnitude of the vector to 1.0 without changing its "
"direction.\n"
msgstr ""
"/// Modifica탵i magnitudinea vectorului la 1.0 f캒r캒 a-i schimba direc탵ia.\n"

#: src/user-defined-types.md
msgid "[Named Structs](./user-defined-types/named-structs.md) (10 minutes)"
msgstr "[Structuri cu nume](./user-defined-types/named-structs.md) (10 minute)"

#: src/user-defined-types.md
msgid "[Tuple Structs](./user-defined-types/tuple-structs.md) (10 minutes)"
msgstr ""
"[Structuri de tuplu](./user-defined-types/tuple-structs.md) (10 minute)"

#: src/user-defined-types.md
msgid "[Enums](./user-defined-types/enums.md) (5 minutes)"
msgstr "[Enums](./user-defined-types/enums.md) (5 minute)"

#: src/user-defined-types.md
#, fuzzy
msgid "[Static](./user-defined-types/static.md) (5 minutes)"
msgstr "[Static 탳i Const](./user-defined-types/static-and-const.md) (5 minute)"

#: src/user-defined-types.md
msgid "[Type Aliases](./user-defined-types/aliases.md) (2 minutes)"
msgstr "[Aliasuri de tip](./user-defined-types/aliases.md) (2 minute)"

#: src/user-defined-types.md
#, fuzzy
msgid ""
"[Exercise: Elevator Events](./user-defined-types/exercise.md) (15 minutes)"
msgstr ""
"[Exerci탵iu: Evenimente de lift](./user-defined-types/exercise.md) (15 minute)"

#: src/user-defined-types.md src/methods-and-traits.md src/lifetimes.md
msgid "This segment should take about 50 minutes"
msgstr "Acest segment ar trebui s캒 dureze aproximativ 50 de minute"

#: src/user-defined-types/named-structs.md
msgid "Like C and C++, Rust has support for custom structs:"
msgstr "La fel ca 칥n C 탳i C++, Rust are suport pentru structuri personalizate:"

#: src/user-defined-types/named-structs.md
msgid "\"{} is {} years old\""
msgstr "\"{} are {} ani\""

#: src/user-defined-types/named-structs.md
#: src/android/interoperability/with-c/bindgen.md
msgid "\"Peter\""
msgstr "\"Peter\""

#: src/user-defined-types/named-structs.md
msgid "\"Avery\""
msgstr "\"Avery\""

#: src/user-defined-types/named-structs.md
msgid "\"Jackie\""
msgstr "\"Jackie\""

#: src/user-defined-types/named-structs.md src/user-defined-types/enums.md
#: src/pattern-matching/match.md src/methods-and-traits/methods.md
msgid "Key Points:"
msgstr "Puncte-cheie:"

#: src/user-defined-types/named-structs.md
msgid "Structs work like in C or C++."
msgstr "Structurile func탵ioneaz캒 ca 칥n C sau C++."

#: src/user-defined-types/named-structs.md
msgid "Like in C++, and unlike in C, no typedef is needed to define a type."
msgstr ""
"La fel ca 칥n C++ 탳i spre deosebire de C, nu este nevoie de un typedef pentru "
"a defini un tip."

#: src/user-defined-types/named-structs.md
msgid "Unlike in C++, there is no inheritance between structs."
msgstr "Spre deosebire de C++, nu exist캒 mo탳tenire 칥ntre structuri."

#: src/user-defined-types/named-structs.md
#, fuzzy
msgid ""
"This may be a good time to let people know there are different types of "
"structs."
msgstr ""
"Acesta ar putea fi un moment bun pentru a informa oamenii c캒 exist캒 diferite "
"tipuri de structuri."

#: src/user-defined-types/named-structs.md
#, fuzzy
msgid ""
"Zero-sized structs (e.g. `struct Foo;`) might be used when implementing a "
"trait on some type but don't have any data that you want to store in the "
"value itself."
msgstr ""
"Structurile de dimensiune zero (de exemplu, `struct Foo;`) pot fi utilizate "
"atunci c칙nd se implementeaz캒 o tr캒s캒tur캒 pe un anumit tip, dar nu ave탵i date "
"pe care dori탵i s캒 le stoca탵i 칥n valoarea 칥n sine."

#: src/user-defined-types/named-structs.md
#, fuzzy
msgid ""
"The next slide will introduce Tuple structs, used when the field names are "
"not important."
msgstr ""
"Urm캒torul diapozitiv va prezenta structurile Tuple, utilizate atunci c칙nd "
"numele c칙mpurilor nu sunt importante."

#: src/user-defined-types/named-structs.md
#, fuzzy
msgid ""
"If you already have variables with the right names, then you can create the "
"struct using a shorthand."
msgstr ""
"Dac캒 ave탵i deja variabile cu numele corecte, pute탵i crea structura folosind "
"o prescurtare:"

#: src/user-defined-types/named-structs.md
#, fuzzy
msgid ""
"The syntax `..avery` allows us to copy the majority of the fields from the "
"old struct without having to explicitly type it all out. It must always be "
"the last element."
msgstr ""
"Sintaxa `..peter` ne permite s캒 copiem majoritatea c칙mpurilor din vechea "
"structur캒 f캒r캒 a fi nevoie s캒 le scriem 칥n mod explicit pe toate. Acesta "
"trebuie s캒 fie 칥ntotdeauna ultimul element."

#: src/user-defined-types/tuple-structs.md
#, fuzzy
msgid "If the field names are unimportant, you can use a tuple struct:"
msgstr ""
"칉n cazul 칥n care numele c칙mpurilor nu sunt importante, pute탵i utiliza o "
"structur캒 de tip tuple:"

#: src/user-defined-types/tuple-structs.md
msgid "\"({}, {})\""
msgstr "\"({}, {})\""

#: src/user-defined-types/tuple-structs.md
#, fuzzy
msgid "This is often used for single-field wrappers (called newtypes):"
msgstr ""
"Acest lucru este adesea utilizat pentru 칥nveli탳urile cu un singur c칙mp "
"(denumite newtypes):"

#: src/user-defined-types/tuple-structs.md
msgid "\"Ask a rocket scientist at NASA\""
msgstr "\"칉ntreba탵i un specialist 칥n rachete de la NASA\""

#: src/user-defined-types/tuple-structs.md
#: src/android/interoperability/cpp/cpp-bridge.md
#: src/bare-metal/microcontrollers/type-state.md
#: src/concurrency/async-pitfalls/cancellation.md
msgid "// ...\n"
msgstr "// ...\n"

#: src/user-defined-types/tuple-structs.md
#, fuzzy
msgid ""
"Newtypes are a great way to encode additional information about the value in "
"a primitive type, for example:"
msgstr ""
"Newtypes reprezint캒 o modalitate excelent캒 de a codifica informa탵ii "
"suplimentare despre valoarea unui tip primitiv, de exemplu:"

#: src/user-defined-types/tuple-structs.md
#, fuzzy
msgid "The number is measured in some units: `Newtons` in the example above."
msgstr ""
"Num캒rul este m캒surat 칥n anumite unit캒탵i: `Newtons` 칥n exemplul de mai sus."

#: src/user-defined-types/tuple-structs.md
#, fuzzy
msgid ""
"The value passed some validation when it was created, so you no longer have "
"to validate it again at every use: `PhoneNumber(String)` or `OddNumber(u32)`."
msgstr ""
"Valoarea a trecut printr-o validare atunci c칙nd a fost creat캒, astfel 칥nc칙t "
"nu mai trebuie s캒 o valida탵i din nou la fiecare utilizare: "
"`PhoneNumber(String)` sau `OddNumber(u32)`."

#: src/user-defined-types/tuple-structs.md
#, fuzzy
msgid ""
"Demonstrate how to add a `f64` value to a `Newtons` type by accessing the "
"single field in the newtype."
msgstr ""
"Demonstra탵i cum s캒 ad캒uga탵i o valoare `f64` la un tip `Newtons` prin "
"accesarea unui singur c칙mp din noul tip."

#: src/user-defined-types/tuple-structs.md
#, fuzzy
msgid ""
"Rust generally doesn't like inexplicit things, like automatic unwrapping or "
"for instance using booleans as integers."
msgstr ""
"칉n general, Rust nu agreeaz캒 lucrurile inexplicabile, cum ar fi desfacerea "
"automat캒 sau, de exemplu, utilizarea booleenilor ca numere 칥ntregi."

#: src/user-defined-types/tuple-structs.md
msgid "Operator overloading is discussed on Day 3 (generics)."
msgstr "Supra칥nc캒rcarea operatorilor este discutat캒 칥n ziua 3 (generice)."

#: src/user-defined-types/tuple-structs.md
#, fuzzy
msgid ""
"The example is a subtle reference to the [Mars Climate Orbiter](https://en."
"wikipedia.org/wiki/Mars_Climate_Orbiter) failure."
msgstr ""
"Exemplul este o referire subtil캒 la e탳ecul [Mars Climate Orbiter] (https://"
"en.wikipedia.org/wiki/Mars_Climate_Orbiter)."

#: src/user-defined-types/enums.md
msgid ""
"The `enum` keyword allows the creation of a type which has a few different "
"variants:"
msgstr ""
"Cuv칙ntul cheie `enum` permite crearea unui tip care are c칙teva variante "
"diferite:"

#: src/user-defined-types/enums.md
msgid "// Simple variant\n"
msgstr "// Variant캒 simpl캒\n"

#: src/user-defined-types/enums.md
msgid "// Tuple variant\n"
msgstr "// Varianta cu tupluri\n"

#: src/user-defined-types/enums.md
#, fuzzy
msgid "// Struct variant\n"
msgstr "// Variant캒 de structur캒\n"

#: src/user-defined-types/enums.md
msgid "\"On this turn: {:?}\""
msgstr "\"칉n acest tur: {:?}\""

#: src/user-defined-types/enums.md
#, fuzzy
msgid "Enumerations allow you to collect a set of values under one type."
msgstr "Enumer캒rile v캒 permit s캒 colecta탵i un set de valori sub un singur tip"

#: src/user-defined-types/enums.md
#, fuzzy
msgid ""
"`Direction` is a type with variants. There are two values of `Direction`: "
"`Direction::Left` and `Direction::Right`."
msgstr ""
"`Direction` este un tip cu variante. Exist캒 dou캒 valori pentru `Direction`: "
"`Direction::Left` 탳i `Direction::Right`."

#: src/user-defined-types/enums.md
#, fuzzy
msgid ""
"`PlayerMove` is a type with three variants. In addition to the payloads, "
"Rust will store a discriminant so that it knows at runtime which variant is "
"in a `PlayerMove` value."
msgstr ""
"`PlayerMove` este un tip cu trei variante. 칉n plus fa탵캒 de sarcinile utile, "
"Rust va stoca un discriminant, astfel 칥nc칙t s캒 탳tie la momentul execu탵iei ce "
"variant캒 se afl캒 칥ntr-o valoare `PlayerMove`."

#: src/user-defined-types/enums.md
#, fuzzy
msgid "This might be a good time to compare structs and enums:"
msgstr ""
"Acesta ar putea fi un moment bun pentru a compara structurile 탳i "
"enumera탵iile:"

#: src/user-defined-types/enums.md
#, fuzzy
msgid ""
"In both, you can have a simple version without fields (unit struct) or one "
"with different types of fields (variant payloads)."
msgstr ""
"칉n ambele, pute탵i avea o versiune simpl캒 f캒r캒 c칙mpuri (unit struct) sau una "
"cu diferite tipuri de c칙mpuri (varianta payloads). "

#: src/user-defined-types/enums.md
#, fuzzy
msgid ""
"You could even implement the different variants of an enum with separate "
"structs but then they wouldn't be the same type as they would if they were "
"all defined in an enum."
msgstr ""
"A탵i putea chiar s캒 implementa탵i diferitele variante ale unui enum cu "
"structuri separate, dar atunci acestea nu ar fi de acela탳i tip ca 칥n cazul "
"칥n care ar fi definite toate 칥ntr-un enum."

#: src/user-defined-types/enums.md
#, fuzzy
msgid "Rust uses minimal space to store the discriminant."
msgstr "Rust utilizeaz캒 un spa탵iu minim pentru a stoca discriminantul."

#: src/user-defined-types/enums.md
#, fuzzy
msgid "If necessary, it stores an integer of the smallest required size"
msgstr ""
"Dac캒 este necesar, se stocheaz캒 un num캒r 칥ntreg de cea mai mic캒 dimensiune "
"necesar캒"

#: src/user-defined-types/enums.md
#, fuzzy
msgid ""
"If the allowed variant values do not cover all bit patterns, it will use "
"invalid bit patterns to encode the discriminant (the \"niche "
"optimization\"). For example, `Option<&u8>` stores either a pointer to an "
"integer or `NULL` for the `None` variant."
msgstr ""
"칉n cazul 칥n care valorile variantelor permise nu acoper캒 toate modelele de "
"bi탵i, se vor utiliza modele de bi탵i nevalabile pentru a codifica "
"discriminantul (\"optimizarea ni탳ei\"). De exemplu, `Option<&u8>` stocheaz캒 "
"fie un pointer la un 칥ntreg, fie `NULL` pentru varianta `None`."

#: src/user-defined-types/enums.md
msgid ""
"You can control the discriminant if needed (e.g., for compatibility with C):"
msgstr ""
"Pute탵i controla discriminantul dac캒 este necesar (de exemplu, pentru "
"compatibilitate cu C):"

#: src/user-defined-types/enums.md
msgid ""
"Without `repr`, the discriminant type takes 2 bytes, because 10001 fits 2 "
"bytes."
msgstr ""
"F캒r캒 `repr`, tipul de discriminant are nevoie de 2 octe탵i, deoarece 10001 se "
"reprezint캒 cu 2 octe탵i."

#: src/user-defined-types/enums.md src/user-defined-types/static.md
#: src/memory-management/review.md src/memory-management/move.md
#: src/smart-pointers/box.md src/borrowing/shared.md
msgid "More to Explore"
msgstr "Mai multe de explorat"

#: src/user-defined-types/enums.md
msgid ""
"Rust has several optimizations it can employ to make enums take up less "
"space."
msgstr ""
"Rust are mai multe optimiz캒ri pe care le poate folosi pentru ca enumera탵iile "
"s캒 ocupe mai pu탵in spa탵iu."

#: src/user-defined-types/enums.md
msgid ""
"Null pointer optimization: For [some types](https://doc.rust-lang.org/std/"
"option/#representation), Rust guarantees that `size_of::<T>()` equals "
"`size_of::<Option<T>>()`."
msgstr ""
"Optimizarea pointerilor nuli: Pentru [unele tipuri](https://doc.rust-lang."
"org/std/option/#representation) Rust garanteaz캒 c캒 `size_of::<T>()` este "
"egal cu `size_of::&lt;Op탵iune<T>&gt;()`."

#: src/user-defined-types/enums.md
msgid ""
"Example code if you want to show how the bitwise representation _may_ look "
"like in practice. It's important to note that the compiler provides no "
"guarantees regarding this representation, therefore this is totally unsafe."
msgstr ""
"Exemplu de cod pentru a putea ar캒ta 칥n practic캒 reprezentarea pe bi탵i. "
"Compilatorul nu ofer캒 nicio garan탵ie 칥n ceea ce prive탳te aceast캒 "
"reprezentare, prin urmare este total nesigur캒."

#: src/user-defined-types/static.md
msgid "`static`"
msgstr "'Static'"

#: src/user-defined-types/static.md
msgid ""
"Static variables will live during the whole execution of the program, and "
"therefore will not move:"
msgstr ""
"Variabilele statice vor fi valabile pe toat캒 durata execu탵iei programului "
"탳i, prin urmare, nu se vor muta:"

#: src/user-defined-types/static.md
msgid "\"Welcome to RustOS 3.14\""
msgstr "\"RustOS 3.14 v캒 salut캒\""

#: src/user-defined-types/static.md
msgid "\"{BANNER}\""
msgstr "\"{BANNER}\""

#: src/user-defined-types/static.md
#, fuzzy
msgid ""
"As noted in the [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-"
"vs-static.html), these are not inlined upon use and have an actual "
"associated memory location. This is useful for unsafe and embedded code, and "
"the variable lives through the entirety of the program execution. When a "
"globally-scoped value does not have a reason to need object identity, "
"`const` is generally preferred."
msgstr ""
"Dup캒 cum se men탵ioneaz캒 칥n [Rust RFC Book](https://rust-lang.github.io/"
"rfcs/0246-const-vs-static.html), acestea nu sunt incluse 칥n cod la utilizare "
"탳i au o loca탵ie de memorie real캒 asociat캒. Acest lucru este util pentru "
"codul nesigur 탳i care ruleaza  direct pe device (embedded) , iar variabila "
"exist캒 pe toat캒 durata execu탵iei programului. Atunci c칙nd o valoare cu "
"acoperire global캒 nu are nevoie de identitatea obiectului, `const` este 칥n "
"general preferat."

#: src/user-defined-types/static.md
#, fuzzy
msgid "`static` is similar to mutable global variables in C++."
msgstr ""
"`static`, pe de alt캒 parte, este mult mai asem캒n캒toar cu o variabil캒 global캒 "
"`const` sau mutabil캒 칥n C++."

#: src/user-defined-types/static.md
msgid ""
"`static` provides object identity: an address in memory and state as "
"required by types with interior mutability such as `Mutex<T>`."
msgstr ""
"`static` asigur캒 identitatea obiectului: o adres캒 칥n memorie 탳i starea "
"necesar캒 pentru tipurile cu mutabilitate interioar캒, cum ar fi `Mutex<T>`."

#: src/user-defined-types/static.md
#, fuzzy
msgid ""
"Because `static` variables are accessible from any thread, they must be "
"`Sync`. Interior mutability is possible through a [`Mutex`](https://doc.rust-"
"lang.org/std/sync/struct.Mutex.html), atomic or similar."
msgstr ""
"Deoarece variabilele `statice` sunt accesibile din orice fir de execu탵ie, "
"ele trebuie s캒 fie `Sync`. Mutabilitatea interioar캒 este posibil캒 prin "
"intermediul unui [`Mutex`](https://doc.rust-lang.org/std/sync/struct.Mutex."
"html), atomic sau similar. De asemenea, este posibil s캒 ave탵i variabile "
"statice mutabile, dar acestea necesit캒 sincronizare manual캒, astfel 칥nc칙t "
"orice acces la ele necesit캒 cod `unsafe`. Ne vom uita la [mutable statics]"
"(../unsafe/mutable-static-variables.md) 칥n capitolul despre Unsafe Rust."

#: src/user-defined-types/static.md
#, fuzzy
msgid "Thread-local data can be created with the macro `std::thread_local`."
msgstr ""
"Datele `thread_local` pot fi create cu ajutorul macroului `std::"
"thread_local`."

#: src/user-defined-types/const.md
msgid "`const`"
msgstr "`const`"

#: src/user-defined-types/const.md
#, fuzzy
msgid ""
"Constants are evaluated at compile time and their values are inlined "
"wherever they are used:"
msgstr ""
"Variabilele constante sunt evaluate la compilare, iar valorile lor sunt "
"칥nlocuite 칥n cod ori de c칙te ori sunt utilizate:"

#: src/user-defined-types/const.md
msgid ""
"According to the [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-"
"vs-static.html) these are inlined upon use."
msgstr ""
"칉n conformitate cu [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-"
"const-vs-static.html), acestea sunt 칥nlocuite 칥n cod la utilizare."

#: src/user-defined-types/const.md
msgid ""
"Only functions marked `const` can be called at compile time to generate "
"`const` values. `const` functions can however be called at runtime."
msgstr ""
"Numai func탵iile marcate `const` pot fi apelate la compilare pentru a genera "
"valori `const`. Func탵iile `const` totu탳i pot fi apelate 칥n timpul execu탵iei."

#: src/user-defined-types/const.md
#, fuzzy
msgid "Mention that `const` behaves semantically similar to C++'s `constexpr`"
msgstr ""
"Men탵iona탵i faptul c캒 칥n Rust `const` are un comportament semantic similar cu "
"`constexpr` din C++."

#: src/user-defined-types/const.md
msgid ""
"It isn't super common that one would need a runtime evaluated constant, but "
"it is helpful and safer than using a static."
msgstr ""
"Nu este foarte des 칥nt칙lnit cazul 칥n care cineva ar avea nevoie de o "
"constant캒 evaluat캒 칥n timp de execu탵ie, dar este util캒 탳i mai sigur캒 dec칙t "
"utilizarea unei constante statice."

#: src/user-defined-types/aliases.md
#, fuzzy
msgid ""
"A type alias creates a name for another type. The two types can be used "
"interchangeably."
msgstr ""
"Un alias de tip creeaz캒 un nume pentru un alt tip. Cele dou캒 tipuri pot fi "
"utilizate 칥n mod interschimbabil."

#: src/user-defined-types/aliases.md
#, fuzzy
msgid "// Aliases are more useful with long, complex types:\n"
msgstr "// Aliasurile sunt mai utile 칥n cazul tipurilor lungi 탳i complexe:\n"

#: src/user-defined-types/aliases.md
#, fuzzy
msgid "C programmers will recognize this as similar to a `typedef`."
msgstr ""
"Programatorii C vor recunoa탳te acest lucru ca fiind similar cu un `typedef`."

#: src/user-defined-types/exercise.md
#, fuzzy
msgid ""
"We will create a data structure to represent an event in an elevator control "
"system. It is up to you to define the types and functions to construct "
"various events. Use `#[derive(Debug)]` to allow the types to be formatted "
"with `{:?}`."
msgstr ""
"Vom crea o structur캒 de date pentru a reprezenta un eveniment 칥ntr-un sistem "
"de control al ascensorului. Depinde de dumneavoastr캒 s캒 defini탵i tipurile 탳i "
"func탵iile pentru a construi diverse evenimente. Utiliza탵i `#[derive(Debug)]` "
"pentru a permite formatarea tipurilor cu `{:?}`."

#: src/user-defined-types/exercise.md
#, fuzzy
msgid ""
"This exercise only requires creating and populating data structures so that "
"`main` runs without errors. The next part of the course will cover getting "
"data out of these structures."
msgstr ""
"Acest exerci탵iu necesit캒 doar crearea 탳i popularea structurilor de date "
"astfel 칥nc칙t `main` s캒 ruleze f캒r캒 erori. Urm캒toarea parte a cursului se va "
"ocupa de extragerea datelor din aceste structuri."

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid ""
"/// An event in the elevator system that the controller must react to.\n"
msgstr ""
"/// Un eveniment din sistemul de ascensoare la care trebuie s캒 reac탵ioneze "
"controlerul.\n"

#: src/user-defined-types/exercise.md
#, fuzzy
msgid "// TODO: add required variants\n"
msgstr "// TODO: ad캒uga탵i variantele necesare\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "/// A direction of travel.\n"
msgstr "/// O direc탵ie de deplasare.\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "/// The car has arrived on the given floor.\n"
msgstr "/// Ma탳ina a ajuns la etajul dat.\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "/// The car doors have opened.\n"
msgstr "/// Portierele ma탳inii s-au deschis.\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "/// The car doors have closed.\n"
msgstr "/// U탳ile ma탳inii s-au 칥nchis.\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid ""
"/// A directional button was pressed in an elevator lobby on the given "
"floor.\n"
msgstr ""
"/// Un buton direc탵ional a fost ap캒sat 칥n holul liftului de la etajul dat.\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "/// A floor button was pressed in the elevator car.\n"
msgstr "/// Un buton de podea a fost ap캒sat 칥n cabina liftului.\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "\"A ground floor passenger has pressed the up button: {:?}\""
msgstr "\"Un pasager de la parter a ap캒sat butonul de urcare: {:?}\""

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "\"The car has arrived on the ground floor: {:?}\""
msgstr "\"Ma탳ina a ajuns la parter: {:?}\""

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "\"The car door opened: {:?}\""
msgstr "\"S-a deschis portiera ma탳inii: {:?}\""

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "\"A passenger has pressed the 3rd floor button: {:?}\""
msgstr "\"Un pasager a ap캒sat butonul de la etajul 3: {:?}\""

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "\"The car door closed: {:?}\""
msgstr "\"U탳a ma탳inii s-a 칥nchis: {:?}\""

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "\"The car has arrived on the 3rd floor: {:?}\""
msgstr "\"Ma탳ina a ajuns la etajul 3: {:?}\""

#: src/user-defined-types/solution.md
#, fuzzy
msgid "/// A button was pressed.\n"
msgstr "/// A fost ap캒sat un buton.\n"

#: src/user-defined-types/solution.md
#, fuzzy
msgid "/// The car has arrived at the given floor.\n"
msgstr "/// Ma탳ina a ajuns la etajul dat.\n"

#: src/user-defined-types/solution.md
#, fuzzy
msgid "/// The car's doors have opened.\n"
msgstr "/// Portierele ma탳inii s-au deschis.\n"

#: src/user-defined-types/solution.md
#, fuzzy
msgid "/// The car's doors have closed.\n"
msgstr "/// Portierele ma탳inii s-au 칥nchis.\n"

#: src/user-defined-types/solution.md
#, fuzzy
msgid "/// A floor is represented as an integer.\n"
msgstr "/// Un etaj este reprezentat ca un num캒r 칥ntreg.\n"

#: src/user-defined-types/solution.md
#, fuzzy
msgid "/// A user-accessible button.\n"
msgstr "/// Un buton accesibil utilizatorului.\n"

#: src/user-defined-types/solution.md
#, fuzzy
msgid "/// A button in the elevator lobby on the given floor.\n"
msgstr "/// Un buton 칥n holul liftului de la etajul dat.\n"

#: src/user-defined-types/solution.md
#, fuzzy
msgid "/// A floor button within the car.\n"
msgstr "/// Un buton de podea 칥n interiorul ma탳inii.\n"

#: src/welcome-day-2.md
msgid "Welcome to Day 2"
msgstr "Bine a탵i venit 칥n ziua a doua"

#: src/welcome-day-2.md
#, fuzzy
msgid ""
"Now that we have seen a fair amount of Rust, today will focus on Rust's type "
"system:"
msgstr ""
"Acum, c캒 am v캒zut o cantitate destul de mare de rugin캒, vom continua cu:"

#: src/welcome-day-2.md
#, fuzzy
msgid "Pattern matching: extracting data from structures."
msgstr ""
"G캒sirea de tipare: destructurarea enumera탵iilor, structurilor 탳i a "
"tablourilor."

#: src/welcome-day-2.md
#, fuzzy
msgid "Methods: associating functions with types."
msgstr "Metode: asocierea func탵iilor cu tipurile."

#: src/welcome-day-2.md
#, fuzzy
msgid "Traits: behaviors shared by multiple types."
msgstr "Tr캒s캒turi: comportamente 칥mp캒rt캒탳ite de mai multe tipuri."

#: src/welcome-day-2.md
#, fuzzy
msgid "Generics: parameterizing types on other types."
msgstr "Generice: parametrizarea tipurilor pe alte tipuri."

#: src/welcome-day-2.md
#, fuzzy
msgid ""
"Standard library types and traits: a tour of Rust's rich standard library."
msgstr ""
"Tipuri 탳i tr캒s캒turi ale bibliotecii standard: un tur al bogatei biblioteci "
"standard Rust."

#: src/welcome-day-2.md
#, fuzzy
msgid "[Welcome](./welcome-day-2.md) (3 minutes)"
msgstr "[Introducere](../welcome-day-2.md) (3 minute)"

#: src/welcome-day-2.md
#, fuzzy
msgid "[Pattern Matching](./pattern-matching.md) (1 hour)"
msgstr "[Potrivirea 탳abloanelor](../pattern-matching.md) (50 minute)"

#: src/welcome-day-2.md
#, fuzzy
msgid "[Methods and Traits](./methods-and-traits.md) (50 minutes)"
msgstr "[Metode 탳i tr캒s캒turi](./methods-and-traits.md) (55 minute)"

#: src/welcome-day-2.md src/welcome-day-4-afternoon.md
#, fuzzy
msgid ""
"Including 10 minute breaks, this session should take about 2 hours and 10 "
"minutes"
msgstr ""
"Incluz칙nd pauzele de 10 minute, aceast캒 sesiune ar trebui s캒 dureze "
"aproximativ 2 ore 탳i 15 minute"

#: src/pattern-matching.md
#, fuzzy
msgid "[Matching Values](./pattern-matching/match.md) (10 minutes)"
msgstr "[Potrivirea 탳abloanelor](../pattern-matching.md) (50 minute)"

#: src/pattern-matching.md
#, fuzzy
msgid ""
"[Destructuring Structs](./pattern-matching/destructuring-structs.md) (4 "
"minutes)"
msgstr "[Destructurare](./pattern-matching/destructuring.md) (10 minute)"

#: src/pattern-matching.md
#, fuzzy
msgid ""
"[Destructuring Enums](./pattern-matching/destructuring-enums.md) (4 minutes)"
msgstr "[Destructurare](./pattern-matching/destructuring.md) (10 minute)"

#: src/pattern-matching.md
#, fuzzy
msgid "[Let Control Flow](./pattern-matching/let-control-flow.md) (10 minutes)"
msgstr ""
"[Las캒 controlul s캒 curg캒](./pattern-matching/let-control-flow.md) (10 minute)"

#: src/pattern-matching.md
#, fuzzy
msgid ""
"[Exercise: Expression Evaluation](./pattern-matching/exercise.md) (30 "
"minutes)"
msgstr ""
"[Exerci탵iu: Evaluarea expresiilor](./pattern-matching/exercise.md) (30 "
"minute)"

#: src/pattern-matching.md src/memory-management.md
msgid "This segment should take about 1 hour"
msgstr "Acest segment ar trebui s캒 dureze aproximativ 1 or캒"

#: src/pattern-matching/match.md
msgid ""
"The `match` keyword lets you match a value against one or more _patterns_. "
"The comparisons are done from top to bottom and the first match wins."
msgstr ""
"Cuv칙ntul cheie `match` v캒 permite s캒 compara탵i o valoare cu unul sau mai "
"multe _탳abloane_. Compara탵iile se fac de sus 칥n jos, iar prima potrivire "
"c칙탳tig캒."

#: src/pattern-matching/match.md
msgid "The patterns can be simple values, similarly to `switch` in C and C++:"
msgstr "Modelele pot fi valori simple, la fel ca `switch` 칥n C 탳i C++:"

#: src/pattern-matching/match.md
msgid "'x'"
msgstr "'x'"

#: src/pattern-matching/match.md
msgid "'q'"
msgstr "'q'"

#: src/pattern-matching/match.md
#, fuzzy
msgid "\"Quitting\""
msgstr "\"Renun탵area\""

#: src/pattern-matching/match.md src/generics/exercise.md
#: src/generics/solution.md src/std-traits/solution.md
#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "'a'"
msgstr "'a'"

#: src/pattern-matching/match.md
msgid "'s'"
msgstr "'s'"

#: src/pattern-matching/match.md
msgid "'w'"
msgstr "'w'"

#: src/pattern-matching/match.md
msgid "'d'"
msgstr "'d'"

#: src/pattern-matching/match.md
msgid "\"Moving around\""
msgstr "\"Permutarea\""

#: src/pattern-matching/match.md src/error-handling/exercise.md
#: src/error-handling/solution.md
msgid "'0'"
msgstr "'0'"

#: src/pattern-matching/match.md src/error-handling/exercise.md
#: src/error-handling/solution.md
msgid "'9'"
msgstr "'9'"

#: src/pattern-matching/match.md
msgid "\"Number input\""
msgstr "\"Introducere num캒r\""

#: src/pattern-matching/match.md
msgid "\"Lowercase: {key}\""
msgstr "\"Litera mic캒: {key}\""

#: src/pattern-matching/match.md
msgid "\"Something else\""
msgstr "\"Altceva\""

#: src/pattern-matching/match.md
#, fuzzy
msgid ""
"The `_` pattern is a wildcard pattern which matches any value. The "
"expressions _must_ be exhaustive, meaning that it covers every possibility, "
"so `_` is often used as the final catch-all case."
msgstr ""
"탲ablonul `_` este un model jocker care se potrive탳te cu orice valoare. "
"Expresiile _trebuie_ s캒 fie irefutabile, ceea ce 칥nseamn캒 c캒 acoper캒 orice "
"posibilitate, astfel 칥nc칙t `_` este adesea utilizat ca ultim caz universal."

#: src/pattern-matching/match.md
msgid ""
"Match can be used as an expression. Just like `if`, each match arm must have "
"the same type. The type is the last expression of the block, if any. In the "
"example above, the type is `()`."
msgstr ""
"Potrivirea se poate folosi ca o expresie. Similar cu 'if', cele dou캒 p캒r탵i "
"ale expresiei trebuie s캒 aib캒 acela탳i tip. Dac캒 exist캒, ultima expresie din "
"bloc d캒 tipul. 칉n exemplul anterior, tipul este '()'."

#: src/pattern-matching/match.md
#, fuzzy
msgid ""
"A variable in the pattern (`key` in this example) will create a binding that "
"can be used within the match arm."
msgstr ""
"O variabil캒 din model (`key` 칥n acest exemplu) va crea o leg캒tur캒 care poate "
"fi utilizat캒 칥n cadrul bra탵ului de potrivire."

#: src/pattern-matching/match.md
#, fuzzy
msgid "A match guard causes the arm to match only if the condition is true."
msgstr ""
"O protec탵ie de potrivire face ca bra탵ul s캒 se potriveasc캒 numai dac캒 "
"condi탵ia este adev캒rat캒."

#: src/pattern-matching/match.md
#, fuzzy
msgid ""
"You might point out how some specific characters are being used when in a "
"pattern"
msgstr ""
"A탵i putea indica modul 칥n care sunt folosite anumite caractere specifice "
"atunci c칙nd se afl캒 칥ntr-un 탳ablon"

#: src/pattern-matching/match.md
msgid "`|` as an `or`"
msgstr "`|` ca un `or` (sau)"

#: src/pattern-matching/match.md
msgid "`..` can expand as much as it needs to be"
msgstr "`...` se poate extinde at칙t c칙t este nevoie"

#: src/pattern-matching/match.md
msgid "`1..=5` represents an inclusive range"
msgstr "`1..=5` reprezint캒 un interval inclusiv"

#: src/pattern-matching/match.md
msgid "`_` is a wild card"
msgstr "`_` este un 'joker'"

#: src/pattern-matching/match.md
msgid ""
"Match guards as a separate syntax feature are important and necessary when "
"we wish to concisely express more complex ideas than patterns alone would "
"allow."
msgstr ""
"G캒rzile de potrivire, ca o caracteristic캒 sintactic캒 separat캒, sunt "
"importante 탳i necesare atunci c칙nd dorim s캒 exprim캒m 칥n mod concis idei mai "
"complexe dec칙t ne-ar permite doar 탳abloanele."

#: src/pattern-matching/match.md
msgid ""
"They are not the same as separate `if` expression inside of the match arm. "
"An `if` expression inside of the branch block (after `=>`) happens after the "
"match arm is selected. Failing the `if` condition inside of that block won't "
"result in other arms of the original `match` expression being considered."
msgstr ""
"Acestea sunt diferite de expresia `if` din interiorul ramurii de potrivire. "
"O expresie `if` 칥n interiorul blocului de ramificare (dup캒 `=>`) apare dup캒 "
"ce este selectat캒 ramura de potrivire. 칉n cazul 칥n care nu se 칥ndepline탳te "
"condi탵ia `if` din interiorul blocului respectiv, nu vor fi luate 칥n "
"considerare alte ramuri ale expresiei `match` originale."

#: src/pattern-matching/match.md
msgid ""
"The condition defined in the guard applies to every expression in a pattern "
"with an `|`."
msgstr ""
"Condi탵ia definit캒 칥n gard캒 se aplic캒 fiec캒rei expresii dintr-un model cu `|`."

#: src/pattern-matching/destructuring-structs.md
msgid "Structs"
msgstr "Structuri"

#: src/pattern-matching/destructuring-structs.md
#, fuzzy
msgid "Like tuples, Struct can also be destructured by matching:"
msgstr ""
"Ca 탳i tuplurile, structurile 탳i enumera탵iile pot fi, de asemenea, "
"destructurate prin potrivire:"

#: src/pattern-matching/destructuring-structs.md
#, fuzzy
msgid "\"x.0 = 1, b = {b}, y = {y}\""
msgstr "\"x.0 = 1, b = {b}, y = {y}\""

#: src/pattern-matching/destructuring-structs.md
#, fuzzy
msgid "\"y = 2, x = {i:?}\""
msgstr "\"y = 2, x = {i:?}\""

#: src/pattern-matching/destructuring-structs.md
#, fuzzy
msgid "\"y = {y}, other fields were ignored\""
msgstr "\"y = {y}, celelalte c칙mpuri au fost ignorate\""

#: src/pattern-matching/destructuring-structs.md
msgid "Change the literal values in `foo` to match with the other patterns."
msgstr ""
"Modifica탵i valorile literale din `foo` pentru a se potrivi cu celelalte "
"modele."

#: src/pattern-matching/destructuring-structs.md
msgid "Add a new field to `Foo` and make changes to the pattern as needed."
msgstr ""
"Ad캒uga탵i un nou c칙mp la `Foo` 탳i modifica탵i 탳ablonul dup캒 cum este necesar."

#: src/pattern-matching/destructuring-structs.md
msgid ""
"The distinction between a capture and a constant expression can be hard to "
"spot. Try changing the `2` in the second arm to a variable, and see that it "
"subtly doesn't work. Change it to a `const` and see it working again."
msgstr ""
"Distinc탵ia dintre o captur캒 탳i o expresie constant캒 poate fi greu de "
"observat. 칉ncerca탵i s캒 schimba탵i `2` din a dou캒 ramur캒 cu o variabil캒 탳i "
"vede탵i c캒, 칥n mod subtil, nu mai func탵ioneaz캒. Schimba탵i-o 칥ntr-o `const` 탳i "
"vede탵i c캒 func탵ioneaz캒 din nou."

#: src/pattern-matching/destructuring-enums.md
#, fuzzy
msgid "Like tuples, enums can also be destructured by matching:"
msgstr ""
"Ca 탳i tuplurile, structurile 탳i enumera탵iile pot fi, de asemenea, "
"destructurate prin potrivire:"

#: src/pattern-matching/destructuring-enums.md
msgid ""
"Patterns can also be used to bind variables to parts of your values. This is "
"how you inspect the structure of your types. Let us start with a simple "
"`enum` type:"
msgstr ""
"Modelele pot fi, de asemenea, utilizate pentru a lega variabilele de p캒r탵i "
"ale valorilor din variabile. 칉n acest fel pute탵i inspecta structura "
"tipurilor dumneavoastr캒. S캒 칥ncepem cu un tip simplu `enum`:"

#: src/pattern-matching/destructuring-enums.md
#, fuzzy
msgid "\"cannot divide {n} into two equal parts\""
msgstr "\"nu poate 칥mp캒r탵i {n} 칥n dou캒 p캒r탵i egale\""

#: src/pattern-matching/destructuring-enums.md
#, fuzzy
msgid "\"{n} divided in two is {half}\""
msgstr "\"{n} 칥mp캒r탵it la doi este {half}\""

#: src/pattern-matching/destructuring-enums.md
#, fuzzy
msgid "\"sorry, an error happened: {msg}\""
msgstr "\"칉mi pare r캒u, s-a produs o eroare: {msg}\""

#: src/pattern-matching/destructuring-enums.md
msgid ""
"Here we have used the arms to _destructure_ the `Result` value. In the first "
"arm, `half` is bound to the value inside the `Ok` variant. In the second "
"arm, `msg` is bound to the error message."
msgstr ""
"Aici am folosit ramifica탵iile pentru a _destructura_ valoarea `Result`. Pe "
"prima ramur캒 `half` este legat de valoarea din interiorul variantei `Ok`. Pe "
"cea de-a doua ramur캒, `msg` este legat de mesajul de eroare."

#: src/pattern-matching/destructuring-enums.md
msgid ""
"The `if`/`else` expression is returning an enum that is later unpacked with "
"a `match`."
msgstr ""
"Expresia `if`/`else` returneaz캒 o enumera탵ie care este ulterior descompus캒 "
"cu un `match`."

#: src/pattern-matching/destructuring-enums.md
msgid ""
"You can try adding a third variant to the enum definition and displaying the "
"errors when running the code. Point out the places where your code is now "
"inexhaustive and how the compiler tries to give you hints."
msgstr ""
"Pute탵i 칥ncerca s캒 ad캒uga탵i o a treia variant캒 la defini탵ia enumer캒rii 탳i s캒 "
"afi탳a탵i erorile atunci c칙nd executa탵i codul. Eviden탵ia탵i locurile 칥n care "
"codul dvs. este acum neexhaustiv 탳i modul 칥n care compilatorul 칥ncearc캒 s캒 "
"v캒 ofere indicii."

#: src/pattern-matching/destructuring-enums.md
#, fuzzy
msgid ""
"The values in the enum variants can only be accessed after being pattern "
"matched."
msgstr ""
"Valorile din variantele enum pot fi accesate numai dup캒 ce au fost comparate "
"cu un model. Modelul leag캒 referin탵ele la c칙mpurile din \"bra탵ul de "
"potrivire\" dup캒 `=>`."

#: src/pattern-matching/destructuring-enums.md
#, fuzzy
msgid ""
"Demonstrate what happens when the search is inexhaustive. Note the advantage "
"the Rust compiler provides by confirming when all cases are handled."
msgstr ""
"Demonstra탵i ce se 칥nt칙mpl캒 atunci c칙nd c캒utarea este neexhaustiv캒. Observa탵i "
"avantajul pe care 칥l ofer캒 compilatorul Rust prin confirmarea momentului 칥n "
"care sunt tratate toate cazurile. "

#: src/pattern-matching/destructuring-enums.md
#, fuzzy
msgid ""
"Save the result of `divide_in_two` in the `result` variable and `match` it "
"in a loop. That won't compile because `msg` is consumed when matched. To fix "
"it, match `&result` instead of `result`. That will make `msg` a reference so "
"it won't be consumed. This [\"match ergonomics\"](https://rust-lang.github."
"io/rfcs/2005-match-ergonomics.html) appeared in Rust 2018. If you want to "
"support older Rust, replace `msg` with `ref msg` in the pattern."
msgstr ""
"Salva탵i rezultatul `divide_in_two` 칥n variabila `result` 탳i `match` 칥ntr-o "
"bucl캒. Acest lucru nu va fi compilat deoarece `msg` este consumat atunci "
"c칙nd se potrive탳te. Pentru a remedia problema, potrivi탵i `&result` 칥n loc de "
"`result`. Acest lucru va face din `msg` o referin탵캒, astfel 칥nc칙t nu va fi "
"consumat캒. Acest [\"match ergonomics\"](https://rust-lang.github.io/"
"rfcs/2005-match-ergonomics.html) a ap캒rut 칥n Rust 2018. Dac캒 dori탵i s캒 "
"sprijini탵i Rust mai vechi, 칥nlocui탵i `msg` cu `ref msg` 칥n model."

#: src/pattern-matching/let-control-flow.md
msgid ""
"Rust has a few control flow constructs which differ from other languages. "
"They are used for pattern matching:"
msgstr ""
"Rust are c칙teva construc탵ii pentru controlul fluxului care difer캒 de alte "
"limbaje. Acestea sunt utilizate pentru potrivirea 탳abloanelor:"

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "`if let` expressions"
msgstr "Expresii 'if let'"

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "`while let` expressions"
msgstr "Expresii 'while let'"

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "`match` expressions"
msgstr "Expresii 'match'"

#: src/pattern-matching/let-control-flow.md
msgid ""
"The [`if let` expression](https://doc.rust-lang.org/reference/expressions/if-"
"expr.html#if-let-expressions) lets you execute different code depending on "
"whether a value matches a pattern:"
msgstr ""
"Expresia [`if let`](https://doc.rust-lang.org/reference/expressions/if-expr."
"html#if-let-expressions) v캒 permite s캒 executa탵i un cod diferit 칥n func탵ie "
"de potrivirea unei valori cu un 탳ablon:"

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "\"slept for {:?}\""
msgstr "\"dormit pentru {:?}\""

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "`let else` expressions"
msgstr "Expresii while let"

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid ""
"For the common case of matching a pattern and returning from the function, "
"use [`let else`](https://doc.rust-lang.org/rust-by-example/flow_control/"
"let_else.html). The \"else\" case must diverge (`return`, `break`, or panic "
"- anything but falling off the end of the block)."
msgstr ""
"Pentru cazul obi탳nuit de potrivire a unui model 탳i de 칥ntoarcere din "
"func탵ie, utiliza탵i [`let else`](https://doc.rust-lang.org/rust-by-example/"
"flow_control/let_else.html). Cazul \"else\" trebuie s캒 difere (`return`, "
"`break` sau panic캒 - orice altceva 칥n afar캒 de c캒derea de la sf칙r탳itul "
"blocului)."

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "\"got None\""
msgstr "\"Nu am primit nimic\""

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "\"got empty string\""
msgstr "\"a primit un 탳ir gol\""

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "\"not a hex digit\""
msgstr "\"nu o cifr캒 hexagonal캒\""

#: src/pattern-matching/let-control-flow.md src/pattern-matching/solution.md
msgid "\"result: {:?}\""
msgstr "\"result: {:?}\""

#: src/pattern-matching/let-control-flow.md src/generics/trait-bounds.md
#: src/smart-pointers/solution.md src/testing/solution.md
#: src/android/testing.md src/android/testing/googletest.md
#, fuzzy
msgid "\"foo\""
msgstr "\"foo\""

#: src/pattern-matching/let-control-flow.md
msgid ""
"Like with `if let`, there is a [`while let`](https://doc.rust-lang.org/"
"reference/expressions/loop-expr.html#predicate-pattern-loops) variant which "
"repeatedly tests a value against a pattern:"
msgstr ""
"Ca 탳i 칥n cazul lui `if let`, exist캒 o variant캒 [`while let`](https://doc."
"rust-lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops) "
"care testeaz캒 칥n mod repetat o valoare 칥n raport cu un model:"

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid ""
"Here [`String::pop`](https://doc.rust-lang.org/stable/std/string/struct."
"String.html#method.pop) returns `Some(c)` until the string is empty, after "
"which it will return `None`. The `while let` lets us keep iterating through "
"all items."
msgstr ""
"Aici, iteratorul returnat de `v.into_iter()` va returna un `Option<i32>` la "
"fiecare apel la `next()`. Acesta returneaz캒 `Some(x)` p칙n캒 c칙nd termin캒, "
"dup캒 care va returna `None`. Metoda `while let` ne permite s캒 continu캒m "
"itera탵ia prin toate elementele."

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "if-let"
msgstr "Fluxul de control"

#: src/pattern-matching/let-control-flow.md
msgid ""
"Unlike `match`, `if let` does not have to cover all branches. This can make "
"it more concise than `match`."
msgstr ""
"Spre deosebire de `match`, `if let` nu trebuie s캒 acopere toate ramurile. "
"Acest lucru 칥l poate face mai concis dec칙t `match`."

#: src/pattern-matching/let-control-flow.md
msgid "A common usage is handling `Some` values when working with `Option`."
msgstr ""
"O utilizare obi탳nuit캒 este manipularea valorilor `Some` atunci c칙nd se "
"lucreaz캒 cu `Option`."

#: src/pattern-matching/let-control-flow.md
msgid ""
"Unlike `match`, `if let` does not support guard clauses for pattern matching."
msgstr ""
"Spre deosebire de `match`, `if let` nu accept캒 clauze de protec탵ie pentru "
"potrivirea de tipare."

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "let-else"
msgstr "let-else"

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid ""
"`if-let`s can pile up, as shown. The `let-else` construct supports "
"flattening this nested code. Rewrite the awkward version for students, so "
"they can see the transformation."
msgstr ""
"`if-let`s se poate acumula, dup캒 cum se arat캒. Construc탵ia `let-else` "
"permite aplatizarea acestui cod imbricate. Rescrie탵i versiunea ciudat캒 "
"pentru elevi, astfel 칥nc칙t ace탳tia s캒 poat캒 vedea transformarea."

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "The rewritten version is:"
msgstr "Versiunea rescris캒 este:"

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "while-let"
msgstr "bucle `while let`"

#: src/pattern-matching/let-control-flow.md
msgid ""
"Point out that the `while let` loop will keep going as long as the value "
"matches the pattern."
msgstr ""
"Preciza탵i c캒 bucla `while let` va continua at칙ta timp c칙t valoarea se "
"potrive탳te cu modelul."

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid ""
"You could rewrite the `while let` loop as an infinite loop with an if "
"statement that breaks when there is no value to unwrap for `name.pop()`. The "
"`while let` provides syntactic sugar for the above scenario."
msgstr ""
"A탵i putea rescrie bucla `while let` ca o bucl캒 infinit캒 cu o instruc탵iune if "
"care se 칥ntrerupe atunci c칙nd nu mai exist캒 nicio valoare de desf캒cut pentru "
"`iter.next()`. `while let` ofer캒 zah캒r sintactic pentru scenariul de mai sus."

#: src/pattern-matching/exercise.md
#, fuzzy
msgid "Let's write a simple recursive evaluator for arithmetic expressions."
msgstr "S캒 scriem un evaluator recursiv pentru expresii aritmetice simplu."

#: src/pattern-matching/exercise.md
#, fuzzy
msgid ""
"The `Box` type here is a smart pointer, and will be covered in detail later "
"in the course. An expression can be \"boxed\" with `Box::new` as seen in the "
"tests. To evaluate a boxed expression, use the deref operator (`*`) to "
"\"unbox\" it: `eval(*boxed_expr)`."
msgstr ""
"Tipul `Box` de aici este un pointer inteligent 탳i va fi tratat 칥n detaliu "
"mai t칙rziu 칥n curs. O expresie poate fi \"칥ncadrat캒\" cu `Box::new`, a탳a cum "
"se vede 칥n teste. Pentru a evalua o expresie 칥ncadrat캒, utiliza탵i operatorul "
"de diferen탵iere pentru a o \"despacheta\": `eval(*boxed_expr)`."

#: src/pattern-matching/exercise.md
#, fuzzy
msgid ""
"Some expressions cannot be evaluated and will return an error. The standard "
"[`Result<Value, String>`](https://doc.rust-lang.org/std/result/enum.Result."
"html) type is an enum that represents either a successful value "
"(`Ok(Value)`) or an error (`Err(String)`). We will cover this type in detail "
"later."
msgstr ""
"Unele expresii nu pot fi evaluate 탳i vor returna o eroare. Tipul `Res` "
"reprezint캒 fie o valoare de succes, fie o eroare cu un mesaj. Acest tip este "
"foarte asem캒n캒tor cu `Result` din biblioteca standard, pe care 칥l vom vedea "
"mai t칙rziu."

#: src/pattern-matching/exercise.md
#, fuzzy
msgid ""
"Copy and paste the code into the Rust playground, and begin implementing "
"`eval`. The final product should pass the tests. It may be helpful to use "
"`todo!()` and get the tests to pass one-by-one. You can also skip a test "
"temporarily with `#[ignore]`:"
msgstr ""
"Copia탵i 탳i lipi탵i codul 칥n locul de joac캒 Rust 탳i 칥ncepe탵i s캒 implementa탵i "
"`eval`. Produsul final ar trebui s캒 treac캒 testele. Poate fi util s캒 "
"folosi탵i `todo!()` 탳i s캒 ob탵ine탵i testele s캒 treac캒 unul c칙te unul."

#: src/pattern-matching/exercise.md
#, fuzzy
msgid ""
"If you finish early, try writing a test that results in division by zero or "
"integer overflow. How could you handle this with `Result` instead of a panic?"
msgstr ""
"Dac캒 termina탵i mai devreme, 칥ncerca탵i s캒 scrie탵i un test care are ca "
"rezultat o dep캒탳ire de num캒r 칥ntreg. Cum a탵i putea gestiona acest lucru cu "
"`Res::Err` 칥n loc de o panic캒?"

#: src/pattern-matching/exercise.md src/pattern-matching/solution.md
#, fuzzy
msgid "/// An operation to perform on two subexpressions.\n"
msgstr "/// O opera탵ie care trebuie efectuat캒 asupra a dou캒 subexpresii.\n"

#: src/pattern-matching/exercise.md src/pattern-matching/solution.md
#, fuzzy
msgid "/// An expression, in tree form.\n"
msgstr "/// O expresie, 칥n form캒 de arbore.\n"

#: src/pattern-matching/exercise.md src/pattern-matching/solution.md
#, fuzzy
msgid "/// An operation on two subexpressions.\n"
msgstr "/// O opera탵ie asupra a dou캒 subexpresii.\n"

#: src/pattern-matching/exercise.md src/pattern-matching/solution.md
#, fuzzy
msgid "/// A literal value\n"
msgstr "/// O valoare literal캒\n"

#: src/pattern-matching/exercise.md src/pattern-matching/solution.md
#, fuzzy
msgid "\"division by zero\""
msgstr "\"칥mp캒r탵irea la zero\""

#: src/pattern-matching/solution.md
#, fuzzy
msgid "\"expr: {:?}\""
msgstr "\"expr: {:?}\""

#: src/methods-and-traits.md
#, fuzzy
msgid "[Methods](./methods-and-traits/methods.md) (10 minutes)"
msgstr "[Metode](./methods-and-traits/methods.md) (10 minute)"

#: src/methods-and-traits.md
#, fuzzy
msgid "[Traits](./methods-and-traits/traits.md) (15 minutes)"
msgstr "[Tr캒s캒turi](./methods-and-traits/traits.md) (10 minute)"

#: src/methods-and-traits.md
#, fuzzy
msgid "[Deriving](./methods-and-traits/deriving.md) (3 minutes)"
msgstr "[Derivare](./methods-and-traits/deriving.md) (5 minute)"

#: src/methods-and-traits.md
#, fuzzy
msgid ""
"[Exercise: Generic Logger](./methods-and-traits/exercise.md) (20 minutes)"
msgstr ""
"[Exerci탵iu: Logger generic](./methods-and-traits/exercise.md) (20 minute)"

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"Rust allows you to associate functions with your new types. You do this with "
"an `impl` block:"
msgstr ""
"Rust v캒 permite s캒 asocia탵i func탵ii cu noile dvs. tipuri. Acest lucru se "
"face cu ajutorul unui bloc `impl`:"

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "// No receiver, a static method\n"
msgstr "// F캒r캒 receptor, o metod캒 static캒\n"

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "// Exclusive borrowed read-write access to self\n"
msgstr "// Acces exclusiv 칥mprumutat de citire-scriere pentru sine\n"

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "// Shared and read-only borrowed access to self\n"
msgstr "// Acces 칥mprumutat partajat 탳i numai pentru citire la sine\n"

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "\"Recorded {} laps for {}:\""
msgstr "\"칉nregistrat {} ture pentru {}:\""

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "\"Lap {idx}: {lap} sec\""
msgstr "\"Tur {idx}: {lap} sec\""

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "// Exclusive ownership of self\n"
msgstr "// Proprietatea exclusiv캒 a sinelui\n"

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "\"Race {} is finished, total lap time: {}\""
msgstr "\"Cursa {} s-a 칥ncheiat, timp total pe tur: {}\""

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "\"Monaco Grand Prix\""
msgstr "\"Marele Premiu de la Monaco\""

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "// race.add_lap(42);\n"
msgstr "// race.add_lap(42);\n"

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"The `self` arguments specify the \"receiver\" - the object the method acts "
"on. There are several common receivers for a method:"
msgstr ""
"Simbolul `&self` de mai sus indic캒 faptul c캒 metoda 칥mprumut캒 obiectul 칥n "
"mod imuabil. Exist캒 탳i al탵i receptori posibili pentru o metod캒:"

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"`&self`: borrows the object from the caller using a shared and immutable "
"reference. The object can be used again afterwards."
msgstr ""
"`&self`: 칥mprumut캒 obiectul de la apelant folosind o referin탵캒 partajat캒 탳i "
"imuabil캒. Obiectul poate fi utilizat din nou ulterior."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"`&mut self`: borrows the object from the caller using a unique and mutable "
"reference. The object can be used again afterwards."
msgstr ""
"`&mut self`: 칥mprumut캒 obiectul de la apelant folosind o referin탵캒 unic캒 탳i "
"mutabil캒. Obiectul poate fi utilizat din nou ulterior."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"`self`: takes ownership of the object and moves it away from the caller. The "
"method becomes the owner of the object. The object will be dropped "
"(deallocated) when the method returns, unless its ownership is explicitly "
"transmitted. Complete ownership does not automatically mean mutability."
msgstr ""
"`self`: preia proprietatea asupra obiectului 탳i 칥l 칥ndep캒rteaz캒 de la "
"apelant. Metoda devine proprietarul obiectului. Obiectul va fi abandonat "
"(dezalocat) la 칥ntoarcerea metodei, cu excep탵ia cazului 칥n care proprietatea "
"sa este transmis캒 칥n mod explicit. Proprietatea complet캒 nu 칥nseamn캒 automat "
"mutabilitate."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "`mut self`: same as above, but the method can mutate the object."
msgstr "`mut self`: la fel ca mai sus, dar metoda poate muta obiectul."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"No receiver: this becomes a static method on the struct. Typically used to "
"create constructors which are called `new` by convention."
msgstr ""
"F캒r캒 receptor: aceasta devine o metod캒 static캒 pe structura. Se utilizeaz캒 "
"de obicei pentru a crea constructori care sunt numi탵i `new` prin conven탵ie."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "It can be helpful to introduce methods by comparing them to functions."
msgstr ""
"Poate fi util캒 introducerea metodelor prin compararea lor cu func탵iile."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"Methods are called on an instance of a type (such as a struct or enum), the "
"first parameter represents the instance as `self`."
msgstr ""
"Metodele sunt apelate pe o instan탵캒 a unui tip (cum ar fi un struct sau "
"enum), primul parametru reprezint캒 instan탵a ca `self`."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"Developers may choose to use methods to take advantage of method receiver "
"syntax and to help keep them more organized. By using methods we can keep "
"all the implementation code in one predictable place."
msgstr ""
"Dezvoltatorii pot alege s캒 foloseasc캒 metode pentru a profita de sintaxa "
"receptorului de metode 탳i pentru a le men탵ine mai bine organizate. Prin "
"utilizarea metodelor putem p캒stra tot codul de implementare 칥ntr-un singur "
"loc previzibil."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "Point out the use of the keyword `self`, a method receiver."
msgstr "Indica탵i utilizarea cuv칙ntului cheie `self`, un receptor de metod캒."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"Show that it is an abbreviated term for `self: Self` and perhaps show how "
"the struct name could also be used."
msgstr ""
"Ar캒ta탵i c캒 este un termen prescurtat pentru \"sine\": Self` 탳i, eventual, "
"ar캒ta탵i cum ar putea fi folosit 탳i numele structurii."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"Explain that `Self` is a type alias for the type the `impl` block is in and "
"can be used elsewhere in the block."
msgstr ""
"Explica탵i c캒 `Self` este un alias de tip pentru tipul 칥n care se afl캒 blocul "
"`impl` 탳i poate fi utilizat 칥n alt캒 parte a blocului."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"Note how `self` is used like other structs and dot notation can be used to "
"refer to individual fields."
msgstr ""
"Observa탵i cum `self` este utilizat ca 탳i alte structuri 탳i cum nota탵ia cu "
"puncte poate fi utilizat캒 pentru a se referi la c칙mpuri individuale."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"This might be a good time to demonstrate how the `&self` differs from `self` "
"by trying to run `finish` twice."
msgstr ""
"Acesta ar putea fi un moment bun pentru a demonstra cum difer캒 `&self` de "
"`self` prin modificarea codului 탳i 칥ncercarea de a rula say_hello de dou캒 "
"ori."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"Beyond variants on `self`, there are also [special wrapper types](https://"
"doc.rust-lang.org/reference/special-types-and-traits.html) allowed to be "
"receiver types, such as `Box<Self>`."
msgstr ""
"칉n afar캒 de variantele lui `self`, exist캒 탳i [tipuri speciale de 칥nveli탳]"
"(https://doc.rust-lang.org/reference/special-types-and-traits.html) care pot "
"fi tipuri de receptor, cum ar fi `Box<Self>`."

#: src/methods-and-traits/traits.md
#, fuzzy
msgid ""
"Rust lets you abstract over types with traits. They're similar to interfaces:"
msgstr ""
"Rust v캒 permite s캒 abstractiza탵i tipurile cu ajutorul tr캒s캒turilor. Acestea "
"sunt similare cu interfe탵ele:"

#: src/methods-and-traits/traits.md
#, fuzzy
msgid "/// Return a sentence from this pet.\n"
msgstr "// Reexporta탵i tipurile din acest modul.\n"

#: src/methods-and-traits/traits.md
#, fuzzy
msgid "/// Print a string to the terminal greeting this pet.\n"
msgstr "/// Tip캒re탳te un mesaj de salut pe ie탳irea standard.\n"

#: src/methods-and-traits/traits.md
#, fuzzy
msgid ""
"A trait defines a number of methods that types must have in order to "
"implement the trait."
msgstr ""
"O tr캒s캒tur캒 define탳te un num캒r de metode pe care tipurile trebuie s캒 le aib캒 "
"pentru a implementa tr캒s캒tura respectiv캒."

#: src/methods-and-traits/traits.md
#, fuzzy
msgid ""
"In the \"Generics\" segment, next, we will see how to build functionality "
"that is generic over all types implementing a trait."
msgstr ""
"칉n continuare, 칥n segmentul \"Generics\", vom vedea cum s캒 construim o "
"func탵ionalitate care este generic캒 pentru toate tipurile care implementeaz캒 "
"o tr캒s캒tur캒."

#: src/methods-and-traits/traits/implementing.md
#, fuzzy
msgid "\"Oh you're a cutie! What's your name? {}\""
msgstr "\"Oh, e탳ti un dr캒gu탵! Cum te cheam캒? {}\""

#: src/methods-and-traits/traits/implementing.md
#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid "\"Woof, my name is {}!\""
msgstr "\"Woof, numele meu este {}!\""

#: src/methods-and-traits/traits/implementing.md
#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid "\"Fido\""
msgstr "\"Fido\""

#: src/methods-and-traits/traits/implementing.md
#, fuzzy
msgid ""
"To implement `Trait` for `Type`, you use an `impl Trait for Type { .. }` "
"block."
msgstr ""
"Tr캒s캒turile sunt implementate 칥ntr-un `impl <trait> pentru <type> { .. }`."

#: src/methods-and-traits/traits/implementing.md
#, fuzzy
msgid ""
"Unlike Go interfaces, just having matching methods is not enough: a `Cat` "
"type with a `talk()` method would not automatically satisfy `Pet` unless it "
"is in an `impl Pet` block."
msgstr ""
"Spre deosebire de interfe탵ele Go, simpla potrivire a metodelor nu este "
"suficient캒: un tip `Cat` cu o metod캒 `talk()` nu ar satisface automat `Pet` "
"dec칙t dac캒 se afl캒 칥ntr-un bloc `impl Pet`."

#: src/methods-and-traits/traits/implementing.md
#, fuzzy
msgid ""
"Traits may provide default implementations of some methods. Default "
"implementations can rely on all the methods of the trait. In this case, "
"`greet` is provided, and relies on `talk`."
msgstr ""
"Tr캒s캒turile pot specifica metode preimplementate (implicite) 탳i metode pe "
"care utilizatorii trebuie s캒 le implementeze ei 칥n탳i탳i. Metodele cu "
"implement캒ri implicite se pot baza pe metodele obligatorii."

#: src/methods-and-traits/traits/supertraits.md
#, fuzzy
msgid ""
"A trait can require that types implementing it also implement other traits, "
"called _supertraits_. Here, any type implementing `Pet` must implement "
"`Animal`."
msgstr ""
"O tr캒s캒tur캒 poate impune ca tipurile care o implementeaz캒 s캒 implementeze 탳i "
"alte tr캒s캒turi, numite _supertraits_. Aici, orice tip care implementeaz캒 "
"`Pet` trebuie s캒 implementeze `Animal`."

#: src/methods-and-traits/traits/supertraits.md
#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid "\"Rex\""
msgstr "\"Rex\""

#: src/methods-and-traits/traits/supertraits.md
#, fuzzy
msgid "\"{} has {} legs\""
msgstr "\"{} are {} ani\""

#: src/methods-and-traits/traits/supertraits.md
#, fuzzy
msgid ""
"This is sometimes called \"trait inheritance\" but students should not "
"expect this to behave like OO inheritance. It just specifies an additional "
"requirement on implementations of a trait."
msgstr ""
"Acest lucru se nume탳te uneori \"mo탳tenire de tr캒s캒turi\", dar studen탵ii nu "
"trebuie s캒 se a탳tepte ca aceasta s캒 se comporte ca mo탳tenirea OO. Aceasta "
"specific캒 doar o cerin탵캒 suplimentar캒 pentru implement캒rile unei tr캒s캒turi."

#: src/methods-and-traits/traits/associated-types.md
#, fuzzy
msgid ""
"Associated types are placeholder types which are supplied by the trait "
"implementation."
msgstr ""
"Tipurile asociate sunt tipuri de tip \"placeholder\" care sunt furnizate de "
"implementarea tr캒s캒turii."

#: src/methods-and-traits/traits/associated-types.md
#: src/concurrency/async-control-flow/join.md
msgid "\"{:?}\""
msgstr "\"{:?}\""

#: src/methods-and-traits/traits/associated-types.md
#, fuzzy
msgid ""
"Associated types are sometimes also called \"output types\". The key "
"observation is that the implementer, not the caller, chooses this type."
msgstr ""
"Tipurile asociate sunt uneori denumite 탳i \"tipuri de ie탳ire\". Observa탵ia "
"cheie este c캒 acest tip este ales de c캒tre implementator, nu de c캒tre "
"apelant."

#: src/methods-and-traits/traits/associated-types.md
#, fuzzy
msgid ""
"Many standard library traits have associated types, including arithmetic "
"operators and `Iterator`."
msgstr ""
"Multe tr캒s캒turi de bibliotec캒 standard au tipuri asociate, inclusiv "
"operatorii aritmetici 탳i `Iterator`."

#: src/methods-and-traits/deriving.md
#, fuzzy
msgid ""
"Supported traits can be automatically implemented for your custom types, as "
"follows:"
msgstr ""
"Tr캒s캒turile acceptate pot fi implementate automat pentru tipurile dvs. "
"personalizate, dup캒 cum urmeaz캒:"

#: src/methods-and-traits/deriving.md
#, fuzzy
msgid "// Default trait adds `default` constructor.\n"
msgstr "// Caracteristica implicit캒 adaug캒 constructorul `default`.\n"

#: src/methods-and-traits/deriving.md
#, fuzzy
msgid "// Clone trait adds `clone` method.\n"
msgstr "// Tr캒s캒tura Clone adaug캒 metoda `clone`.\n"

#: src/methods-and-traits/deriving.md
#, fuzzy
msgid "\"EldurScrollz\""
msgstr "\"EldurScrollz\""

#: src/methods-and-traits/deriving.md
#, fuzzy
msgid "// Debug trait adds support for printing with `{:?}`.\n"
msgstr "// Tr캒s캒tura Debug adaug캒 suport pentru imprimarea cu `{:?}`.\n"

#: src/methods-and-traits/deriving.md
#, fuzzy
msgid "\"{:?} vs. {:?}\""
msgstr "탲ir de caractere (string) versus str"

#: src/methods-and-traits/deriving.md
#, fuzzy
msgid ""
"Derivation is implemented with macros, and many crates provide useful derive "
"macros to add useful functionality. For example, `serde` can derive "
"serialization support for a struct using `#[derive(Serialize)]`."
msgstr ""
"Derivarea este implementat캒 cu macro-uri, iar multe crates ofer캒 macro-uri "
"derive utile pentru a ad캒uga func탵ionalit캒탵i utile. De exemplu, `serde` "
"poate deriva suportul de serializare pentru o structur캒 folosind "
"`#[derive(Serialize)]`."

#: src/methods-and-traits/exercise.md
#, fuzzy
msgid "Exercise: Logger Trait"
msgstr "Exerci탵iu: Logger generic"

#: src/methods-and-traits/exercise.md
#, fuzzy
msgid ""
"Let's design a simple logging utility, using a trait `Logger` with a `log` "
"method. Code which might log its progress can then take an `&impl Logger`. "
"In testing, this might put messages in the test logfile, while in a "
"production build it would send messages to a log server."
msgstr ""
"S캒 proiect캒m un utilitar de logare simplu, folosind o tr캒s캒tur캒 `Logger` cu "
"o metod캒 `log`. Codul care ar putea 칥nregistra progresul s캒u poate lua un "
"`&impl Logger`. 칉n timpul testelor, acesta ar putea plasa mesaje 칥n fi탳ierul "
"de jurnal de test, 칥n timp ce 칥n cazul unei compil캒ri de produc탵ie ar "
"trimite mesaje c캒tre un server de jurnal."

#: src/methods-and-traits/exercise.md
#, fuzzy
msgid ""
"However, the `StderrLogger` given below logs all messages, regardless of "
"verbosity. Your task is to write a `VerbosityFilter` type that will ignore "
"messages above a maximum verbosity."
msgstr ""
"Cu toate acestea, `StderrLogger` dat mai jos 칥nregistreaz캒 toate mesajele, "
"indiferent de verbozitate. Sarcina dvs. este de a scrie un tip "
"`VerbosityFilter` care s캒 ignore mesajele care dep캒탳esc o verbozitate maxim캒."

#: src/methods-and-traits/exercise.md
#, fuzzy
msgid ""
"This is a common pattern: a struct wrapping a trait implementation and "
"implementing that same trait, adding behavior in the process. What other "
"kinds of wrappers might be useful in a logging utility?"
msgstr ""
"Acesta este un model comun: o structur캒 care 칥nf캒탳oar캒 o implementare a unei "
"tr캒s캒turi 탳i care implementeaz캒 aceea탳i tr캒s캒tur캒, ad캒ug칙nd comportament 칥n "
"acest proces. Ce alte tipuri de 칥nveli탳uri ar putea fi utile 칥ntr-un "
"utilitar de logare?"

#: src/methods-and-traits/exercise.md src/methods-and-traits/solution.md
#, fuzzy
msgid "/// Log a message at the given verbosity level.\n"
msgstr "/// 칉nregistra탵i un mesaj la nivelul de verbozitate dat.\n"

#: src/methods-and-traits/exercise.md src/methods-and-traits/solution.md
#, fuzzy
msgid "\"verbosity={verbosity}: {message}\""
msgstr "\"verbosity={verbosity}: {message}\""

#: src/methods-and-traits/exercise.md src/methods-and-traits/solution.md
#, fuzzy
msgid "\"FYI\""
msgstr "\"FYI\""

#: src/methods-and-traits/exercise.md src/methods-and-traits/solution.md
#, fuzzy
msgid "\"Uhoh\""
msgstr "\"Uhoh\""

#: src/methods-and-traits/exercise.md
#, fuzzy
msgid "// TODO: Define and implement `VerbosityFilter`.\n"
msgstr "// TODO: Defini탵i 탳i implementa탵i `VerbosityFilter`.\n"

#: src/methods-and-traits/solution.md
#, fuzzy
msgid "/// Only log messages up to the given verbosity level.\n"
msgstr ""
"/// 칉nregistra탵i numai mesajele de jurnal p칙n캒 la nivelul de verbozitate "
"dat.\n"

#: src/welcome-day-2-afternoon.md
#, fuzzy
msgid "[Generics](./generics.md) (40 minutes)"
msgstr "[Generice](../generics.md) (45 minute)"

#: src/welcome-day-2-afternoon.md
#, fuzzy
msgid "[Standard Library Types](./std-types.md) (1 hour and 20 minutes)"
msgstr "[Tipuri de bibliotec캒 standard](../std-types.md) (1 or캒 탳i 10 minute)"

#: src/welcome-day-2-afternoon.md
#, fuzzy
msgid "[Standard Library Traits](./std-traits.md) (1 hour and 40 minutes)"
msgstr ""
"[Tr캒s캒turi ale bibliotecii standard](../std-traits.md) (1 or캒 탳i 40 de "
"minute)"

#: src/welcome-day-2-afternoon.md
#, fuzzy
msgid "Including 10 minute breaks, this session should take about 4 hours"
msgstr ""
"Incluz칙nd pauzele de 10 minute, aceast캒 sesiune ar trebui s캒 dureze "
"aproximativ 2 ore 탳i 55 de minute"

#: src/generics.md
#, fuzzy
msgid "[Generic Functions](./generics/generic-functions.md) (5 minutes)"
msgstr "[Func탵ii generice](./generics/generic-functions.md) (5 minute)"

#: src/generics.md
#, fuzzy
msgid "[Generic Data Types](./generics/generic-data.md) (10 minutes)"
msgstr "[Tipuri de date generice](./generics/generic-data.md) (15 minute)"

#: src/generics.md
#, fuzzy
msgid "[Trait Bounds](./generics/trait-bounds.md) (10 minutes)"
msgstr "[Limite ale tr캒s캒turilor](./generics/trait-bounds.md) (10 minute)"

#: src/generics.md
#, fuzzy
msgid "[impl Trait](./generics/impl-trait.md) (5 minutes)"
msgstr "[impl Trait](./generics/impl-trait.md) (5 minute)"

#: src/generics.md
#, fuzzy
msgid "[Exercise: Generic min](./generics/exercise.md) (10 minutes)"
msgstr "[Exerci탵iu: Generic min](./generics/exercise.md) (10 minute)"

#: src/generics/generic-functions.md
#, fuzzy
msgid ""
"Rust supports generics, which lets you abstract algorithms or data "
"structures (such as sorting or a binary tree) over the types used or stored."
msgstr ""
"Rust suport캒 generice, ceea ce v캒 permite s캒 abstractiza탵i algoritmi sau "
"structuri de date (cum ar fi sortarea sau un arbore binar) peste tipurile "
"utilizate sau stocate."

#: src/generics/generic-functions.md
#, fuzzy
msgid "/// Pick `even` or `odd` depending on the value of `n`.\n"
msgstr "/// Alege `even` sau `odd` 칥n func탵ie de valoarea lui `n`.\n"

#: src/generics/generic-functions.md
#, fuzzy
msgid "\"picked a number: {:?}\""
msgstr "\"a ales un num캒r: {:?}\""

#: src/generics/generic-functions.md
#, fuzzy
msgid "\"picked a tuple: {:?}\""
msgstr "\"a ales un tuple: {:?}\""

#: src/generics/generic-functions.md
#, fuzzy
msgid "\"dog\""
msgstr "\"c칙ine\""

#: src/generics/generic-functions.md
#, fuzzy
msgid "\"cat\""
msgstr "\"cat\""

#: src/generics/generic-functions.md
#, fuzzy
msgid ""
"Rust infers a type for T based on the types of the arguments and return "
"value."
msgstr ""
"Rust deduce un tip pentru T pe baza tipurilor argumentelor 탳i a valorii de "
"returnare."

#: src/generics/generic-functions.md
#, fuzzy
msgid ""
"This is similar to C++ templates, but Rust partially compiles the generic "
"function immediately, so that function must be valid for all types matching "
"the constraints. For example, try modifying `pick` to return `even + odd` if "
"`n == 0`. Even if only the `pick` instantiation with integers is used, Rust "
"still considers it invalid. C++ would let you do this."
msgstr ""
"Acest lucru este similar cu 탳abloanele C++, dar Rust compileaz캒 par탵ial "
"func탵ia generic캒 imediat, astfel 칥nc칙t func탵ia trebuie s캒 fie valabil캒 "
"pentru toate tipurile care corespund constr칙ngerilor. De exemplu, 칥ncerca탵i "
"s캒 modifica탵i `pick` pentru a returna `even + odd` dac캒 `n == 0`. Chiar dac캒 "
"se utilizeaz캒 doar instan탵ierea `pick` cu numere 칥ntregi, Rust o consider캒 "
"칥n continuare invalid캒. C++ v-ar permite s캒 face탵i acest lucru."

#: src/generics/generic-functions.md
#, fuzzy
msgid ""
"Generic code is turned into non-generic code based on the call sites. This "
"is a zero-cost abstraction: you get exactly the same result as if you had "
"hand-coded the data structures without the abstraction."
msgstr ""
"Aceasta este o abstractizare cu costuri zero: ob탵ine탵i exact acela탳i "
"rezultat ca 탳i cum a탵i fi codat manual structurile de date f캒r캒 "
"abstractizare."

#: src/generics/generic-data.md
#, fuzzy
msgid "You can use generics to abstract over the concrete field type:"
msgstr ""
"Pute탵i utiliza elementele generice pentru a face abstrac탵ie de tipul de c칙mp "
"concret:"

#: src/generics/generic-data.md
#, fuzzy
msgid "\"{integer:?} and {float:?}\""
msgstr "\"{integer:?} 탳i {float:?}\""

#: src/generics/generic-data.md
#, fuzzy
msgid "\"coords: {:?}\""
msgstr "\"coords: {:?}\""

#: src/generics/generic-data.md
#, fuzzy
msgid ""
"_Q:_ Why `T` is specified twice in `impl<T> Point<T> {}`? Isn't that "
"redundant?"
msgstr ""
"칥ntrebare: De ce `T` este specificat de dou캒 ori 칥n `impl<T> Point<T> {}`? "
"Nu este redundant?"

#: src/generics/generic-data.md
#, fuzzy
msgid ""
"This is because it is a generic implementation section for generic type. "
"They are independently generic."
msgstr ""
"Acest lucru se datoreaz캒 faptului c캒 este o sec탵iune de implementare "
"generic캒 pentru un tip generic. Acestea sunt generice 칥n mod independent."

#: src/generics/generic-data.md
#, fuzzy
msgid "It means these methods are defined for any `T`."
msgstr "Aceasta 칥nseamn캒 c캒 aceste metode sunt definite pentru orice `T`."

#: src/generics/generic-data.md
#, fuzzy
msgid "It is possible to write `impl Point<u32> { .. }`."
msgstr "Este posibil s캒 se scrie `impl Point<u32> { .. }`. "

#: src/generics/generic-data.md
#, fuzzy
msgid ""
"`Point` is still generic and you can use `Point<f64>`, but methods in this "
"block will only be available for `Point<u32>`."
msgstr ""
"`Point` este 칥n continuare generic 탳i pute탵i utiliza `Point<f64>`, dar "
"metodele din acest bloc vor fi disponibile numai pentru `Point<u32>`."

#: src/generics/generic-data.md
#, fuzzy
msgid ""
"Try declaring a new variable `let p = Point { x: 5, y: 10.0 };`. Update the "
"code to allow points that have elements of different types, by using two "
"type variables, e.g., `T` and `U`."
msgstr ""
"칉ncerca탵i s캒 declara탵i o nou캒 variabil캒 `let p = Point { x: 5, y: 10.0 };`. "
"Actualiza탵i codul pentru a permite puncte care au elemente de tipuri "
"diferite, utiliz칙nd dou캒 variabile de tip, de exemplu, `T` 탳i `U`."

#: src/generics/generic-traits.md
#, fuzzy
msgid ""
"Traits can also be generic, just like types and functions. A trait's "
"parameters get concrete types when it is used."
msgstr ""
"Tr캒s캒turile pot fi, de asemenea, generice, la fel ca tipurile 탳i func탵iile. "
"Parametrii unei tr캒s캒turi primesc tipuri concrete atunci c칙nd aceasta este "
"utilizat캒."

#: src/generics/generic-traits.md
#, fuzzy
msgid "\"Converted from integer: {from}\""
msgstr "\"Convertit din num캒r 칥ntreg: {from}\""

#: src/generics/generic-traits.md
#, fuzzy
msgid "\"Converted from bool: {from}\""
msgstr "\"Convertit din bool: {from}\""

#: src/generics/generic-traits.md
#, fuzzy
msgid "\"{from_int:?}, {from_bool:?}\""
msgstr "\"{from_int:?}, {from_bool:?}\""

#: src/generics/generic-traits.md
#, fuzzy
msgid ""
"The `From` trait will be covered later in the course, but its [definition in "
"the `std` docs](https://doc.rust-lang.org/std/convert/trait.From.html) is "
"simple."
msgstr ""
"Tr캒s캒tura `From` va fi abordat캒 mai t칙rziu 칥n curs, dar [defini탵ia sa din "
"documenta탵ia `std`](https://doc.rust-lang.org/std/convert/trait.From.html) "
"este simpl캒."

#: src/generics/generic-traits.md
#, fuzzy
msgid ""
"Implementations of the trait do not need to cover all possible type "
"parameters. Here, `Foo::From(\"hello\")` would not compile because there is "
"no `From<&str>` implementation for `Foo`."
msgstr ""
"Nu este necesar ca implement캒rile tr캒s캒turii s캒 acopere to탵i parametrii de "
"tip posibili. Aici, `Foo::From(\"hello\")` nu ar fi compilat deoarece nu "
"exist캒 o implementare `From<&str>` pentru `Foo`."

#: src/generics/generic-traits.md
#, fuzzy
msgid ""
"Generic traits take types as \"input\", while associated types are a kind of "
"\"output\" type. A trait can have multiple implementations for different "
"input types."
msgstr ""
"Tr캒s캒turile generice iau tipuri ca \"intrare\", 칥n timp ce tipurile asociate "
"sunt un fel de tipuri de \"ie탳ire\". O tr캒s캒tur캒 poate avea mai multe "
"implement캒ri pentru diferite tipuri de intrare."

#: src/generics/generic-traits.md
#, fuzzy
msgid ""
"In fact, Rust requires that at most one implementation of a trait match for "
"any type T. Unlike some other languages, Rust has no heuristic for choosing "
"the \"most specific\" match. There is work on adding this support, called "
"[specialization](https://rust-lang.github.io/rfcs/1210-impl-specialization."
"html)."
msgstr ""
"De fapt, Rust cere ca cel mult o implementare a unei tr캒s캒turi s캒 se "
"potriveasc캒 pentru orice tip T. Spre deosebire de alte limbaje, Rust nu are "
"o euristic캒 pentru alegerea celei mai \"specifice\" potriviri. Se lucreaz캒 "
"la ad캒ugarea acestui suport, numit [specializare](https://rust-lang.github."
"io/rfcs/1210-impl-specialization.html)."

#: src/generics/trait-bounds.md
msgid ""
"When working with generics, you often want to require the types to implement "
"some trait, so that you can call this trait's methods."
msgstr ""
"Atunci c칙nd lucra탵i cu metode generice, deseori dori탵i s캒 solicita탵i ca "
"tipurile s캒 implementeze o anumit캒 tr캒s캒tur캒, astfel 칥nc칙t s캒 pute탵i apela "
"metodele acestei tr캒s캒turi."

#: src/generics/trait-bounds.md
msgid "You can do this with `T: Trait` or `impl Trait`:"
msgstr "Pute탵i face acest lucru cu `T: Trait` sau `impl Trait`:"

#: src/generics/trait-bounds.md
#, fuzzy
msgid "// struct NotClonable;\n"
msgstr "// struct NotClonable;\n"

#: src/generics/trait-bounds.md
#, fuzzy
msgid "\"{pair:?}\""
msgstr ""
"```rust,editable\n"
"fn duplicate<T: Clone>(a: T) -> (T, T) {\n"
"    (a.clone(), a.clone())\n"
"}\n"
"\n"
"// Syntactic sugar for:\n"
"//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"
"fn add_42_millions(x: impl Into<i32>) -> i32 {\n"
"    x.into() + 42_000_000\n"
"}\n"
"\n"
"// struct NotClonable;\n"
"\n"
"fn main() {\n"
"    let foo = String::from(\"foo\");\n"
"    let pair = duplicate(foo);\n"
"    println!(\"{pair:?}\");\n"
"\n"
"    let many = add_42_millions(42_i8);\n"
"    println!(\"{many}\");\n"
"    let many_more = add_42_millions(10_000_000);\n"
"    println!(\"{many_more}\");\n"
"}\n"
"```"

#: src/generics/trait-bounds.md
#, fuzzy
msgid "Try making a `NonClonable` and passing it to `duplicate`."
msgstr "칉ncerca탵i s캒 crea탵i un `NonClonable` 탳i s캒 칥l trece탵i la `duplicate`."

#: src/generics/trait-bounds.md
#, fuzzy
msgid "When multiple traits are necessary, use `+` to join them."
msgstr ""
"Atunci c칙nd sunt necesare mai multe tr캒s캒turi, utiliza탵i `+` pentru a le uni."

#: src/generics/trait-bounds.md
msgid "Show a `where` clause, students will encounter it when reading code."
msgstr ""
"Ar캒ta탵i o clauz캒 `where`, elevii o vor 칥nt칙lni atunci c칙nd vor citi codul."

#: src/generics/trait-bounds.md
msgid "It declutters the function signature if you have many parameters."
msgstr "Aranjeaz캒 semn캒tura func탵iei dac캒 are mul탵i parametri."

#: src/generics/trait-bounds.md
msgid "It has additional features making it more powerful."
msgstr "Are caracteristici suplimentare care 칥l fac mai puternic."

#: src/generics/trait-bounds.md
msgid ""
"If someone asks, the extra feature is that the type on the left of \":\" can "
"be arbitrary, like `Option<T>`."
msgstr ""
"Dac캒 cineva 칥ntreab캒, caracteristica suplimentar캒 este c캒 tipul din st칙nga "
"lui \":\" poate fi arbitrar, cum ar fi `Option<T>`."

#: src/generics/trait-bounds.md
#, fuzzy
msgid ""
"Note that Rust does not (yet) support specialization. For example, given the "
"original `duplicate`, it is invalid to add a specialized `duplicate(a: u32)`."
msgstr ""
"Re탵ine탵i c캒 Rust nu suport캒 (칥nc캒) specializarea. De exemplu, av칙nd 칥n "
"vedere `duplicate` original, nu este valid s캒 se adauge un `duplicate(a: "
"u32)` specializat."

#: src/generics/impl-trait.md
msgid ""
"Similar to trait bounds, an `impl Trait` syntax can be used in function "
"arguments and return values:"
msgstr ""
"La fel ca 칥n cazul limitelor tr캒s캒turilor, o sintax캒 `impl Trait` poate fi "
"utilizat캒 칥n argumentele func탵iilor 탳i 칥n valorile returnate:"

#: src/generics/impl-trait.md
#, fuzzy
msgid ""
"// Syntactic sugar for:\n"
"//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"
msgstr ""
"// Zah캒r sintactic pentru:\n"
"// fn add_42_millions&lt;T: Into<i32>&gt;(x: T) -&gt; i32 {\n"

#: src/generics/impl-trait.md
#, fuzzy
msgid "\"{many}\""
msgstr ""
"Proiectul Rust g캒zduie탳te multe resurse. Acestea se refer캒 la Rust 칥n "
"general:"

#: src/generics/impl-trait.md
#, fuzzy
msgid "\"{many_more}\""
msgstr "\"{many_more}\""

#: src/generics/impl-trait.md
#, fuzzy
msgid "\"debuggable: {debuggable:?}\""
msgstr "\"debuggable: {debuggable:?}\""

#: src/generics/impl-trait.md
#, fuzzy
msgid ""
"`impl Trait` allows you to work with types which you cannot name. The "
"meaning of `impl Trait` is a bit different in the different positions."
msgstr ""
"Semnifica탵ia lui `impl Trait` este pu탵in diferit캒 칥n diferitele pozi탵ii."

#: src/generics/impl-trait.md
#, fuzzy
msgid ""
"For a parameter, `impl Trait` is like an anonymous generic parameter with a "
"trait bound."
msgstr ""
"Pentru un parametru, `impl Trait` este ca un parametru generic anonim cu o "
"tr캒s캒tur캒 legat캒."

#: src/generics/impl-trait.md
#, fuzzy
msgid ""
"For a return type, it means that the return type is some concrete type that "
"implements the trait, without naming the type. This can be useful when you "
"don't want to expose the concrete type in a public API."
msgstr ""
"Pentru un tip de returnare, 칥nseamn캒 c캒 tipul de returnare este un tip "
"concret care implementeaz캒 tr캒s캒tura, f캒r캒 a numi tipul. Acest lucru poate "
"fi util atunci c칙nd nu dori탵i s캒 expune탵i tipul concret 칥ntr-o API public캒."

#: src/generics/impl-trait.md
#, fuzzy
msgid ""
"Inference is hard in return position. A function returning `impl Foo` picks "
"the concrete type it returns, without writing it out in the source. A "
"function returning a generic type like `collect<B>() -> B` can return any "
"type satisfying `B`, and the caller may need to choose one, such as with "
"`let x: Vec<_> = foo.collect()` or with the turbofish, `foo.collect::"
"<Vec<_>>()`."
msgstr ""
"Inferen탵a este dificil캒 칥n pozi탵ia de retur. O func탵ie care returneaz캒 `impl "
"Foo` alege tipul concret pe care 칥l returneaz캒, f캒r캒 a scrie acest lucru 칥n "
"surs캒. O func탵ie care returneaz캒 un tip generic, cum ar fi `collect<B>() -"
"&gt; B`, poate returna orice tip care satisface `B`, iar apelantul poate fi "
"nevoit s캒 aleag캒 unul, ca 칥n cazul lui `let x: Vec<_> = foo.collect()` sau "
"cu turbofishul, `foo.collect::&lt;Vec<_>&gt;()`."

#: src/generics/impl-trait.md
#, fuzzy
msgid ""
"What is the type of `debuggable`? Try `let debuggable: () = ..` to see what "
"the error message shows."
msgstr ""
"Care este tipul de `debuggable`? 칉ncerca탵i `let debuggable: () = ..` pentru "
"a vedea ce afi탳eaz캒 mesajul de eroare."

#: src/generics/exercise.md
#, fuzzy
msgid ""
"In this short exercise, you will implement a generic `min` function that "
"determines the minimum of two values, using the [`Ord`](https://doc.rust-"
"lang.org/stable/std/cmp/trait.Ord.html) trait."
msgstr ""
"칉n acest scurt exerci탵iu, ve탵i implementa o func탵ie generic캒 `min` care "
"determin캒 minimul a dou캒 valori, utiliz칙nd o tr캒s캒tur캒 `LessThan`."

#: src/generics/exercise.md
#, fuzzy
msgid "// TODO: implement the `min` function used in `main`.\n"
msgstr "// TODO: implementa탵i func탵ia `min` folosit캒 칥n `main`.\n"

#: src/generics/exercise.md src/generics/solution.md
#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "'z'"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    inspect(&[0, -2, 3]);\n"
"    inspect(&[0, -2, 3, 4]);\n"
"}\n"
"\n"
"#[rustfmt::skip]\n"
"fn inspect(slice: &[i32]) {\n"
"    println!(\"Spune-mi despre {slice:?}\");\n"
"    match slice {\n"
"        &[0, y, z] => println!(\"Primul element 0, y = {y}, 탳i z = {z}\"),\n"
"        &[1, ..]   => println!(\"Primul element este 1 탳i restul sunt "
"ignorate\"),\n"
"        _          => println!(\"Toate elementele au fost ignorate\"),\n"
"    }\n"
"}\n"
"```"

#: src/generics/exercise.md src/generics/solution.md
#, fuzzy
msgid "'7'"
msgstr "'x'"

#: src/generics/exercise.md src/generics/solution.md
msgid "'1'"
msgstr "'1'"

#: src/generics/exercise.md src/generics/solution.md
#, fuzzy
msgid "\"goodbye\""
msgstr "\"La revedere\""

#: src/generics/exercise.md src/generics/solution.md
#, fuzzy
msgid "\"bat\""
msgstr "\"bat\""

#: src/generics/exercise.md src/generics/solution.md
#, fuzzy
msgid "\"armadillo\""
msgstr "\"Armadillo\""

#: src/generics/exercise.md
#, fuzzy
msgid ""
"Show students the [`Ord`](https://doc.rust-lang.org/stable/std/cmp/trait.Ord."
"html) trait and [`Ordering`](https://doc.rust-lang.org/stable/std/cmp/enum."
"Ordering.html) enum."
msgstr ""
"[`OsStr`](https://doc.rust-lang.org/std/ffi/struct.OsStr.html) 탳i "
"[`OsString`](https://doc.rust-lang.org/std/ffi/struct.OsString.html)"

#: src/std-types.md
#, fuzzy
msgid "[Standard Library](./std-types/std.md) (3 minutes)"
msgstr "[Biblioteca standard](./std-types/std.md) (3 minute)"

#: src/std-types.md
#, fuzzy
msgid "[Documentation](./std-types/docs.md) (5 minutes)"
msgstr "[Documenta탵ie](./std-types/docs.md) (5 minute)"

#: src/std-types.md
#, fuzzy
msgid "[Option](./std-types/option.md) (10 minutes)"
msgstr "[Op탵iune](./std-types/option.md) (10 minute)"

#: src/std-types.md
#, fuzzy
msgid "[Result](./std-types/result.md) (10 minutes)"
msgstr "[Rezultat](./std-types/result.md) (10 minute)"

#: src/std-types.md
#, fuzzy
msgid "[String](./std-types/string.md) (10 minutes)"
msgstr "[String](./std-types/string.md) (10 minute)"

#: src/std-types.md
#, fuzzy
msgid "[Vec](./std-types/vec.md) (10 minutes)"
msgstr "[Vec](./std-types/vec.md) (10 minute)"

#: src/std-types.md
#, fuzzy
msgid "[HashMap](./std-types/hashmap.md) (10 minutes)"
msgstr "[HashMap](./std-types/hashmap.md) (10 minute)"

#: src/std-types.md
#, fuzzy
msgid "[Exercise: Counter](./std-types/exercise.md) (20 minutes)"
msgstr "[Exerci탵iu: Contorizare](./std-types/exercise.md) (10 minute)"

#: src/std-types.md
#, fuzzy
msgid "This segment should take about 1 hour and 20 minutes"
msgstr "Acest segment ar trebui s캒 dureze aproximativ 1 or캒 탳i 10 minute"

#: src/std-types.md
#, fuzzy
msgid ""
"For each of the slides in this section, spend some time reviewing the "
"documentation pages, highlighting some of the more common methods."
msgstr ""
"Pentru fiecare dintre diapozitivele din aceast캒 sec탵iune, petrece탵i ceva "
"timp examin칙nd paginile de documenta탵ie, subliniind unele dintre cele mai "
"comune metode."

#: src/std-types/std.md
#, fuzzy
msgid ""
"Rust comes with a standard library which helps establish a set of common "
"types used by Rust libraries and programs. This way, two libraries can work "
"together smoothly because they both use the same `String` type."
msgstr ""
"Rust vine cu o bibliotec캒 standard care ajut캒 la stabilirea unui set de "
"tipuri comune utilizate de bibliotecile 탳i programele Rust. 칉n acest fel, "
"dou캒 biblioteci pot lucra 칥mpreun캒 f캒r캒 probleme, deoarece ambele utilizeaz캒 "
"acela탳i tip `String`."

#: src/std-types/std.md
#, fuzzy
msgid ""
"In fact, Rust contains several layers of the Standard Library: `core`, "
"`alloc` and `std`."
msgstr ""
"De fapt, Rust con탵ine mai multe straturi ale bibliotecii standard: `core`, "
"`alloc` 탳i `std`."

#: src/std-types/std.md
#, fuzzy
msgid ""
"`core` includes the most basic types and functions that don't depend on "
"`libc`, allocator or even the presence of an operating system."
msgstr ""
"`core` include cele mai de baz캒 tipuri 탳i func탵ii care nu depind de `libc`, "
"de alocator sau chiar de prezen탵a unui sistem de operare."

#: src/std-types/std.md
#, fuzzy
msgid ""
"`alloc` includes types which require a global heap allocator, such as `Vec`, "
"`Box` and `Arc`."
msgstr ""
"`alloc` include tipuri care necesit캒 un alocator global de heap, cum ar fi "
"`Vec`, `Box` 탳i `Arc`."

#: src/std-types/std.md
#, fuzzy
msgid ""
"Embedded Rust applications often only use `core`, and sometimes `alloc`."
msgstr ""
"Aplica탵iile Rust 칥ncorporate folosesc adesea doar `core` 탳i uneori `alloc`."

#: src/std-types/docs.md
#, fuzzy
msgid "Rust comes with extensive documentation. For example:"
msgstr "Rust este 칥nso탵it de o documenta탵ie extins캒. De exemplu:"

#: src/std-types/docs.md
#, fuzzy
msgid ""
"All of the details about [loops](https://doc.rust-lang.org/stable/reference/"
"expressions/loop-expr.html)."
msgstr ""
"Dac캒 dori탵i s캒 ie탳i탵i mai devreme dintr-o bucl캒, utiliza탵i [`break`](https://"
"doc.rust-lang.org/reference/expressions/loop-expr.html#break-expressions),"

#: src/std-types/docs.md
#, fuzzy
msgid ""
"Primitive types like [`u8`](https://doc.rust-lang.org/stable/std/primitive."
"u8.html)."
msgstr ""
"Tipuri primitive precum [`u8`](https://doc.rust-lang.org/stable/std/"
"primitive.u8.html)."

#: src/std-types/docs.md
#, fuzzy
msgid ""
"Standard library types like [`Option`](https://doc.rust-lang.org/stable/std/"
"option/enum.Option.html) or [`BinaryHeap`](https://doc.rust-lang.org/stable/"
"std/collections/struct.BinaryHeap.html)."
msgstr ""
"[`str`](https://doc.rust-lang.org/std/primitive.str.html) 탳i [`String`]"
"(https://doc.rust-lang.org/std/string/struct.String.html)"

#: src/std-types/docs.md
#, fuzzy
msgid "In fact, you can document your own code:"
msgstr "De fapt, v캒 pute탵i documenta propriul cod:"

#: src/std-types/docs.md
#, fuzzy
msgid ""
"/// Determine whether the first argument is divisible by the second "
"argument.\n"
"///\n"
"/// If the second argument is zero, the result is false.\n"
msgstr ""
"/// Determin캒 dac캒 primul argument este divizibil cu al doilea argument.\n"
"///\n"
"/// Dac캒 al doilea argument este zero, rezultatul este fals.\n"

#: src/std-types/docs.md
#, fuzzy
msgid ""
"The contents are treated as Markdown. All published Rust library crates are "
"automatically documented at [`docs.rs`](https://docs.rs) using the [rustdoc]"
"(https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html) tool. It is "
"idiomatic to document all public items in an API using this pattern."
msgstr ""
"Con탵inutul este tratat ca Markdown. Toate crates cu bibliotec캒 Rust "
"publicate sunt documentate automat la [`docs.rs`](https://docs.rs) folosind "
"instrumentul [rustdoc](https://doc.rust-lang.org/rustdoc/what-is-rustdoc."
"html). Documentarea tuturor elementelelor publice dintr-un API, folosind "
"acest model, este idiomatic캒. Fragmentele de cod pot documenta utilizarea 탳i "
"vor fi folosite ca teste unitare."

#: src/std-types/docs.md
#, fuzzy
msgid ""
"To document an item from inside the item (such as inside a module), use `//!"
"` or `/*! .. */`, called \"inner doc comments\":"
msgstr ""
"Pentru a documenta un element din interiorul elementului (cum ar fi 칥n "
"interiorul unui modul), utiliza탵i `//!` sau `/*! ... */`, denumite "
"\"comentarii interne ale documentului\":"

#: src/std-types/docs.md
#, fuzzy
msgid ""
"//! This module contains functionality relating to divisibility of "
"integers.\n"
msgstr ""
"//! Acest modul con탵ine func탵ionalit캒탵i referitoare la divizibilitatea "
"numerelor 칥ntregi.\n"

#: src/std-types/docs.md
#, fuzzy
msgid ""
"Show students the generated docs for the `rand` crate at <https://docs.rs/"
"rand>."
msgstr ""
"Ar캒ta탵i studen탵ilor documenta탵ia generat캒 pentru cr캒iasa `rand` la [`docs.rs/"
"rand`](https://docs.rs/rand)."

#: src/std-types/option.md
msgid "Option"
msgstr "Op탵iune"

#: src/std-types/option.md
#, fuzzy
msgid ""
"We have already seen some use of `Option<T>`. It stores either a value of "
"type `T` or nothing. For example, [`String::find`](https://doc.rust-lang.org/"
"stable/std/string/struct.String.html#method.find) returns an `Option<usize>`."
msgstr ""
"Am v캒zut deja cum se utilizeaz캒 `Op탵iunea<T>`. Acesta stocheaz캒 fie o "
"valoare de tip `T`, fie nimic. De exemplu, [`String::find`](https://doc.rust-"
"lang.org/stable/std/string/struct.String.html#method.find) returneaz캒 o "
"`Op탵iune<usize>`."

#: src/std-types/option.md
#, fuzzy
msgid "\"L칬we 返 L칠opard Gepardi\""
msgstr "\"L칬we 返 L칠opard Gepardi\""

#: src/std-types/option.md
#, fuzzy
msgid "'칠'"
msgstr "'칠'"

#: src/std-types/option.md
#, fuzzy
msgid "\"find returned {position:?}\""
msgstr "\"find returned {position:?}\""

#: src/std-types/option.md
#, fuzzy
msgid "'Z'"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    inspect(&[0, -2, 3]);\n"
"    inspect(&[0, -2, 3, 4]);\n"
"}\n"
"\n"
"#[rustfmt::skip]\n"
"fn inspect(slice: &[i32]) {\n"
"    println!(\"Spune-mi despre {slice:?}\");\n"
"    match slice {\n"
"        &[0, y, z] => println!(\"Primul element 0, y = {y}, 탳i z = {z}\"),\n"
"        &[1, ..]   => println!(\"Primul element este 1 탳i restul sunt "
"ignorate\"),\n"
"        _          => println!(\"Toate elementele au fost ignorate\"),\n"
"    }\n"
"}\n"
"```"

#: src/std-types/option.md
#, fuzzy
msgid "\"Character not found\""
msgstr "\"Caracterul nu a fost g캒sit\""

#: src/std-types/option.md
#, fuzzy
msgid "`Option` is widely used, not just in the standard library."
msgstr ""
"`Option` 탳i `Result` sunt utilizate pe scar캒 larg캒, nu doar 칥n biblioteca "
"standard."

#: src/std-types/option.md
#, fuzzy
msgid ""
"`unwrap` will return the value in an `Option`, or panic. `expect` is similar "
"but takes an error message."
msgstr ""
"`unwrap` va returna valoarea 칥ntr-un `Option` sau va intra 칥n panic캒. "
"`expect` este similar, dar prime탳te un mesaj de eroare."

#: src/std-types/option.md
#, fuzzy
msgid ""
"You can panic on None, but you can't \"accidentally\" forget to check for "
"None."
msgstr ""
"Pute탵i intra 칥n panic캒 la None, dar nu pute탵i uita \"din gre탳eal캒\" s캒 "
"verifica탵i None."

#: src/std-types/option.md
#, fuzzy
msgid ""
"It's common to `unwrap`/`expect` all over the place when hacking something "
"together, but production code typically handles `None` in a nicer fashion."
msgstr ""
"Este obi탳nuit s캒 se foloseasc캒 `unwrap`/`expect` peste tot atunci c칙nd se "
"lucreaz캒 칥mpreun캒, dar codul de produc탵ie trateaz캒 de obicei `None` 칥ntr-un "
"mod mai pl캒cut."

#: src/std-types/option.md
#, fuzzy
msgid ""
"The niche optimization means that `Option<T>` often has the same size in "
"memory as `T`."
msgstr ""
"Optimizarea ni탳ei 칥nseamn캒 c캒 `Op탵iunea<T>` are adesea aceea탳i dimensiune 칥n "
"memorie ca `T`."

#: src/std-types/result.md
msgid "Result"
msgstr "Rezultat"

#: src/std-types/result.md
#, fuzzy
msgid ""
"`Result` is similar to `Option`, but indicates the success or failure of an "
"operation, each with a different type. This is similar to the `Res` defined "
"in the expression exercise, but generic: `Result<T, E>` where `T` is used in "
"the `Ok` variant and `E` appears in the `Err` variant."
msgstr ""
"`Result` este similar cu `Option`, dar indic캒 succesul sau e탳ecul unei "
"opera탵ii, fiecare cu un tip diferit. Acesta este similar cu `Res` definit 칥n "
"exerci탵iul de exprimare, dar generic: `Result<T, E>` unde `T` este folosit "
"칥n varianta `Ok` 탳i `E` apare 칥n varianta `Err`."

#: src/std-types/result.md
#, fuzzy
msgid "\"diary.txt\""
msgstr "\"diary.txt\""

#: src/std-types/result.md
#, fuzzy
msgid "\"Dear diary: {contents} ({bytes} bytes)\""
msgstr "\"Drag캒 jurnalule: {contents} ({bytes} bytes)\""

#: src/std-types/result.md
#, fuzzy
msgid "\"Could not read file content\""
msgstr "\"Nu s-a putut citi con탵inutul fi탳ierului\""

#: src/std-types/result.md
#, fuzzy
msgid "\"The diary could not be opened: {err}\""
msgstr "\"Jurnalul nu a putut fi deschis: {err}\""

#: src/std-types/result.md
#, fuzzy
msgid ""
"As with `Option`, the successful value sits inside of `Result`, forcing the "
"developer to explicitly extract it. This encourages error checking. In the "
"case where an error should never happen, `unwrap()` or `expect()` can be "
"called, and this is a signal of the developer intent too."
msgstr ""
"Ca 탳i 칥n cazul lui `Option`, valoarea de succes se afl캒 칥n interiorul lui "
"`Result`, oblig칙nd dezvoltatorul s캒 o extrag캒 칥n mod explicit. Acest lucru "
"칥ncurajeaz캒 verificarea erorilor. 칉n cazul 칥n care o eroare nu ar trebui s캒 "
"apar캒 niciodat캒, se poate apela la `unwrap()` sau `expect()`, iar acesta "
"este 탳i el un semnal al inten탵iei dezvoltatorului."

#: src/std-types/result.md
#, fuzzy
msgid ""
"`Result` documentation is a recommended read. Not during the course, but it "
"is worth mentioning. It contains a lot of convenience methods and functions "
"that help functional-style programming."
msgstr ""
"documenta탵ia `Result` este o lectur캒 recomandat캒. Nu 칥n timpul cursului, dar "
"merit캒 s캒 fie men탵ionat캒.  Con탵ine o mul탵ime de metode 탳i func탵ii "
"convenabile care ajut캒 la programarea 칥n stil func탵ional."

#: src/std-types/result.md
#, fuzzy
msgid ""
"`Result` is the standard type to implement error handling as we will see on "
"Day 4."
msgstr ""
"`Result` este tipul standard pentru a implementa gestionarea erorilor, dup캒 "
"cum vom vedea 칥n ziua 3."

#: src/std-types/string.md
msgid "String"
msgstr "Sir"

#: src/std-types/string.md
#, fuzzy
msgid ""
"[`String`](https://doc.rust-lang.org/std/string/struct.String.html) is a "
"growable UTF-8 encoded string:"
msgstr ""
"[`String`](https://doc.rust-lang.org/std/string/struct.String.html) este "
"bufferul standard de 탳iruri UTF-8, cu alocare 칥n heap, care poate cre탳te:"

#: src/std-types/string.md src/std-traits/read-and-write.md
#: src/memory-management/review.md src/testing/unit-tests.md
#: src/concurrency/threads/scoped.md
#, fuzzy
msgid "\"Hello\""
msgstr "\"hello\""

#: src/std-types/string.md
#, fuzzy
msgid "\"s1: len = {}, capacity = {}\""
msgstr "\"s1: len = {}, capacity = {}\""

#: src/std-types/string.md
msgid "'!'"
msgstr "'!'"

#: src/std-types/string.md
#, fuzzy
msgid "\"s2: len = {}, capacity = {}\""
msgstr "\"s2: len = {}, capacity = {}\""

#: src/std-types/string.md
#, fuzzy
msgid "\"游뻟릖셒""
msgstr "\"游뻟릖셒""

#: src/std-types/string.md
#, fuzzy
msgid "\"s3: len = {}, number of chars = {}\""
msgstr "\"s3: len = {}, num캒r de caractere = {}\""

#: src/std-types/string.md
#, fuzzy
msgid ""
"`String` implements [`Deref<Target = str>`](https://doc.rust-lang.org/std/"
"string/struct.String.html#deref-methods-str), which means that you can call "
"all `str` methods on a `String`."
msgstr ""
"`String` implementeaz캒 [`Deref<Target = str>`](https://doc.rust-lang.org/std/"
"string/struct.String.html#deref-methods-str), ceea ce 칥nseamn캒 c캒 pute탵i "
"apela toate metodele `str` pe un `String`."

#: src/std-types/string.md
#, fuzzy
msgid ""
"`String::new` returns a new empty string, use `String::with_capacity` when "
"you know how much data you want to push to the string."
msgstr ""
"`String::new` returneaz캒 un nou 탳ir de caractere gol, utiliza탵i `String::"
"with_capacity` atunci c칙nd 탳ti탵i c칙te date dori탵i s캒 introduce탵i 칥n 탳ir."

#: src/std-types/string.md
#, fuzzy
msgid ""
"`String::len` returns the size of the `String` in bytes (which can be "
"different from its length in characters)."
msgstr ""
"`String::len` returneaz캒 dimensiunea 탳irului `String` 칥n octe탵i (care poate "
"fi diferit캒 de lungimea sa 칥n caractere)."

#: src/std-types/string.md
#, fuzzy
msgid ""
"`String::chars` returns an iterator over the actual characters. Note that a "
"`char` can be different from what a human will consider a \"character\" due "
"to [grapheme clusters](https://docs.rs/unicode-segmentation/latest/"
"unicode_segmentation/struct.Graphemes.html)."
msgstr ""
"`String::chars` returneaz캒 un iterator peste caracterele actuale. Re탵ine탵i "
"c캒 un `char` poate fi diferit de ceea ce un om va considera un \"caracter\" "
"din cauza [grapheme clusters](https://docs.rs/unicode-segmentation/latest/"
"unicode_segmentation/struct.Graphemes.html)."

#: src/std-types/string.md
#, fuzzy
msgid ""
"When people refer to strings they could either be talking about `&str` or "
"`String`."
msgstr ""
"Atunci c칙nd oamenii se refer캒 la 탳iruri de caractere, ei pot vorbi fie "
"despre `&str`, fie despre `String`."

#: src/std-types/string.md
#, fuzzy
msgid ""
"When a type implements `Deref<Target = T>`, the compiler will let you "
"transparently call methods from `T`."
msgstr ""
"Atunci c칙nd un tip implementeaz캒 `Deref<Target = T>`, compilatorul v캒 va "
"permite s캒 apela탵i 칥n mod transparent metodele din `T`."

#: src/std-types/string.md
#, fuzzy
msgid ""
"We haven't discussed the `Deref` trait yet, so at this point this mostly "
"explains the structure of the sidebar in the documentation."
msgstr ""
"Nu am discutat 칥nc캒 despre tr캒s캒tura `Deref`, a탳a c캒, 칥n acest moment, acest "
"lucru explic캒 칥n mare parte structura barei laterale din documenta탵ie."

#: src/std-types/string.md
#, fuzzy
msgid ""
"`String` implements `Deref<Target = str>` which transparently gives it "
"access to `str`'s methods."
msgstr ""
"`String` implementeaz캒 `Deref<Target = str>`, ceea ce 칥i ofer캒 칥n mod "
"transparent acces la metodele lui `str`."

#: src/std-types/string.md
#, fuzzy
msgid "Write and compare `let s3 = s1.deref();` and `let s3 = &*s1;`."
msgstr "Scrie탵i 탳i compara탵i `let s3 = s1.deref();` 탳i `let s3 = &*s1;`."

#: src/std-types/string.md
#, fuzzy
msgid ""
"`String` is implemented as a wrapper around a vector of bytes, many of the "
"operations you see supported on vectors are also supported on `String`, but "
"with some extra guarantees."
msgstr ""
"`String` este implementat ca un 칥nveli탳 칥n jurul unui vector de octe탵i, "
"multe dintre opera탵iile pe care le vede탵i acceptate pentru vectori sunt "
"acceptate 탳i pentru `String`, dar cu unele garan탵ii suplimentare."

#: src/std-types/string.md
#, fuzzy
msgid "Compare the different ways to index a `String`:"
msgstr "Compara탵i diferitele moduri de a indexa un `String`:"

#: src/std-types/string.md
#, fuzzy
msgid ""
"To a character by using `s3.chars().nth(i).unwrap()` where `i` is in-bound, "
"out-of-bounds."
msgstr ""
"La un caracter prin utilizarea `s3.chars().nth(i).unwrap()` unde `i` este 칥n "
"interiorul limitelor, 칥n afara limitelor."

#: src/std-types/string.md
#, fuzzy
msgid ""
"To a substring by using `s3[0..4]`, where that slice is on character "
"boundaries or not."
msgstr ""
"La o sub탳ir캒 folosind `s3[0..4]`, unde acea felie se afl캒 sau nu la limitele "
"caracterelor."

#: src/std-types/string.md
#, fuzzy
msgid ""
"Many types can be converted to a string with the [`to_string`](https://doc."
"rust-lang.org/std/string/trait.ToString.html#tymethod.to_string) method. "
"This trait is automatically implemented for all types that implement "
"`Display`, so anything that can be formatted can also be converted to a "
"string."
msgstr ""
"Multe tipuri pot fi convertite 칥ntr-un 탳ir de caractere cu ajutorul metodei "
"[`to_string`](https://doc.rust-lang.org/std/string/trait.ToString."
"html#tymethod.to_string). Aceast캒 tr캒s캒tur캒 este implementat캒 automat pentru "
"toate tipurile care implementeaz캒 `Display`, astfel 칥nc칙t orice poate fi "
"formatat poate fi, de asemenea, convertit 칥ntr-un 탳ir de caractere."

#: src/std-types/vec.md
#, fuzzy
msgid ""
"[`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html) is the standard "
"resizable heap-allocated buffer:"
msgstr ""
"[`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html) este un buffer "
"standard redimensionabil alocat pe heap:"

#: src/std-types/vec.md
#, fuzzy
msgid "\"v1: len = {}, capacity = {}\""
msgstr "\"v1: len = {}, capacity = {}\""

#: src/std-types/vec.md
#, fuzzy
msgid "\"v2: len = {}, capacity = {}\""
msgstr "\"v2: len = {}, capacity = {}\""

#: src/std-types/vec.md
#, fuzzy
msgid "// Canonical macro to initialize a vector with elements.\n"
msgstr "// Macro canonic pentru a ini탵ializa un vector cu elemente.\n"

#: src/std-types/vec.md
#, fuzzy
msgid "// Retain only the even elements.\n"
msgstr "// Re탵ine doar elementele pare.\n"

#: src/std-types/vec.md
#, fuzzy
msgid "\"{v3:?}\""
msgstr "\"{v3:?}\""

#: src/std-types/vec.md
#, fuzzy
msgid "// Remove consecutive duplicates.\n"
msgstr "// Elimina탵i duplicatele consecutive.\n"

#: src/std-types/vec.md
#, fuzzy
msgid ""
"`Vec` implements [`Deref<Target = [T]>`](https://doc.rust-lang.org/std/vec/"
"struct.Vec.html#deref-methods-%5BT%5D), which means that you can call slice "
"methods on a `Vec`."
msgstr ""
"`Vec` implementeaz캒 [`Deref<Target = [T]>`]](https://doc.rust-lang.org/std/"
"vec/struct.Vec.html#deref-methods-%5BT%5D), ceea ce 칥nseamn캒 c캒 pute탵i apela "
"metode de feliere pe un `Vec`."

#: src/std-types/vec.md
#, fuzzy
msgid ""
"`Vec` is a type of collection, along with `String` and `HashMap`. The data "
"it contains is stored on the heap. This means the amount of data doesn't "
"need to be known at compile time. It can grow or shrink at runtime."
msgstr ""
"`Vec` este un tip de colec탵ie, al캒turi de `String` 탳i `HashMap`. Datele pe "
"care le con탵ine sunt stocate 칥n heap. Acest lucru 칥nseamn캒 c캒 nu este "
"necesar s캒 se cunoasc캒 cantitatea de date 칥n momentul compil캒rii. Aceasta "
"poate cre탳te sau se poate mic탳ora 칥n timpul execu탵iei."

#: src/std-types/vec.md
#, fuzzy
msgid ""
"Notice how `Vec<T>` is a generic type too, but you don't have to specify `T` "
"explicitly. As always with Rust type inference, the `T` was established "
"during the first `push` call."
msgstr ""
"Observa탵i cum `Vec<T>` este 탳i el un tip generic, dar nu trebuie s캒 "
"specifica탵i `T` 칥n mod explicit. Ca 칥ntotdeauna 칥n cazul inferen탵ei de tip "
"Rust, `T` a fost stabilit 칥n timpul primului apel `push`."

#: src/std-types/vec.md
#, fuzzy
msgid ""
"`vec![...]` is a canonical macro to use instead of `Vec::new()` and it "
"supports adding initial elements to the vector."
msgstr ""
"`vec![...]` este o macro canonic캒 care poate fi utilizat캒 칥n locul lui `Vec::"
"new()` 탳i permite ad캒ugarea de elemente ini탵iale 칥n vector."

#: src/std-types/vec.md
#, fuzzy
msgid ""
"To index the vector you use `[` `]`, but they will panic if out of bounds. "
"Alternatively, using `get` will return an `Option`. The `pop` function will "
"remove the last element."
msgstr ""
"Pentru a indexa vectorul se folose탳te `[` ` `]` `, dar se va crea panic캒 "
"dac캒 este 칥n afara limitelor. Alternativ, folosind `get` se va returna un "
"`Option`. Func탵ia `pop` va elimina ultimul element."

#: src/std-types/vec.md
#, fuzzy
msgid ""
"Slices are covered on day 3. For now, students only need to know that a "
"value of type `Vec` gives access to all of the documented slice methods, too."
msgstr ""
"Feliile sunt acoperite 칥n ziua 3. Deocamdat캒, studen탵ii trebuie doar s캒 탳tie "
"c캒 o valoare de tip `Vec` ofer캒 acces la toate metodele de feliere "
"documentate."

#: src/std-types/hashmap.md
#, fuzzy
msgid "Standard hash map with protection against HashDoS attacks:"
msgstr "Hart캒 hash standard cu protec탵ie 칥mpotriva atacurilor HashDoS:"

#: src/std-types/hashmap.md
#, fuzzy
msgid "\"Adventures of Huckleberry Finn\""
msgstr "\"Aventurile lui Huckleberry Finn\""

#: src/std-types/hashmap.md
#, fuzzy
msgid "\"Grimms' Fairy Tales\""
msgstr "\"Basmele lui Grimms\""

#: src/std-types/hashmap.md
#, fuzzy
msgid "\"Pride and Prejudice\""
msgstr "\"M칙ndrie 탳i Prejudecat캒\""

#: src/std-types/hashmap.md
#, fuzzy
msgid "\"Les Mis칠rables\""
msgstr "\"Les Mis칠rables\""

#: src/std-types/hashmap.md
#, fuzzy
msgid "\"We know about {} books, but not Les Mis칠rables.\""
msgstr "\"탲tim despre {} c캒r탵i, dar nu 탳i despre Les Mis칠rables.\""

#: src/std-types/hashmap.md
#, fuzzy
msgid "\"Alice's Adventure in Wonderland\""
msgstr "\"Aventura lui Alice 칥n 탴ara Minunilor\""

#: src/std-types/hashmap.md
#, fuzzy
msgid "\"{book}: {count} pages\""
msgstr "\"{book}: {count} pagini\""

#: src/std-types/hashmap.md
#, fuzzy
msgid "\"{book} is unknown.\""
msgstr "\"{book} este necunoscut.\""

#: src/std-types/hashmap.md
#, fuzzy
msgid "// Use the .entry() method to insert a value if nothing is found.\n"
msgstr ""
"// Utiliza탵i metoda .entry() pentru a introduce o valoare dac캒 nu se g캒se탳te "
"nimic.\n"

#: src/std-types/hashmap.md
#, fuzzy
msgid "\"{page_counts:#?}\""
msgstr "\"{page_counts:#?}\""

#: src/std-types/hashmap.md
#, fuzzy
msgid ""
"`HashMap` is not defined in the prelude and needs to be brought into scope."
msgstr ""
"`HashMap` nu este definit 칥n preludiu 탳i trebuie s캒 fie adus 칥n domeniul de "
"aplicare."

#: src/std-types/hashmap.md
#, fuzzy
msgid ""
"Try the following lines of code. The first line will see if a book is in the "
"hashmap and if not return an alternative value. The second line will insert "
"the alternative value in the hashmap if the book is not found."
msgstr ""
"칉ncerca탵i urm캒toarele linii de cod. Prima linie va verifica dac캒 o carte se "
"afl캒 칥n hashmap 탳i, 칥n caz contrar, va returna o valoare alternativ캒. A doua "
"linie va introduce valoarea alternativ캒 칥n hashmap dac캒 nu se g캒se탳te cartea."

#: src/std-types/hashmap.md
#, fuzzy
msgid "\"Harry Potter and the Sorcerer's Stone\""
msgstr "\"Harry Potter 탳i Piatra Vr캒jitoarelor\""

#: src/std-types/hashmap.md
#, fuzzy
msgid "\"The Hunger Games\""
msgstr "\"Jocurile foamei\""

#: src/std-types/hashmap.md
#, fuzzy
msgid "Unlike `vec!`, there is unfortunately no standard `hashmap!` macro."
msgstr ""
"Spre deosebire de `vec!`, din p캒cate nu exist캒 o macro standard `hashmap!`."

#: src/std-types/hashmap.md
#, fuzzy
msgid ""
"Although, since Rust 1.56, HashMap implements [`From<[(K, V); N]>`](https://"
"doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#impl-"
"From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E), which allows "
"us to easily initialize a hash map from a literal array:"
msgstr ""
"Cu toate c캒, 칥ncep칙nd cu Rust 1.56, HashMap implementeaz캒 [`From<[(K, V); "
"N]>`]](https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap."
"html#impl-From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E), "
"ceea ce ne permite s캒 ini탵ializ캒m cu u탳urin탵캒 o hart캒 hash dintr-o matrice "
"literal캒:"

#: src/std-types/hashmap.md
#, fuzzy
msgid ""
"Alternatively HashMap can be built from any `Iterator` which yields key-"
"value tuples."
msgstr ""
"Alternativ, HashMap poate fi construit din orice `Iterator` care produce "
"tupluri cheie-valoare."

#: src/std-types/hashmap.md
#, fuzzy
msgid ""
"We are showing `HashMap<String, i32>`, and avoid using `&str` as key to make "
"examples easier. Using references in collections can, of course, be done, "
"but it can lead into complications with the borrow checker."
msgstr ""
"Prezent캒m `HashMap<String, i32>` 탳i evit캒m s캒 folosim `&str` ca cheie pentru "
"a face exemplele mai u탳oare. Folosirea referin탵elor 칥n colec탵ii se poate "
"face, desigur, dar poate duce la complica탵ii cu verificatorul de 칥mprumuturi."

#: src/std-types/hashmap.md
#, fuzzy
msgid ""
"Try removing `to_string()` from the example above and see if it still "
"compiles. Where do you think we might run into issues?"
msgstr ""
"칉ncerca탵i s캒 elimina탵i `to_string()` din exemplul de mai sus 탳i vede탵i dac캒 "
"se compileaz캒 칥n continuare. Unde crede탵i c캒 am putea 칥nt칙mpina probleme?"

#: src/std-types/hashmap.md
#, fuzzy
msgid ""
"This type has several \"method-specific\" return types, such as `std::"
"collections::hash_map::Keys`. These types often appear in searches of the "
"Rust docs. Show students the docs for this type, and the helpful link back "
"to the `keys` method."
msgstr ""
"Acest tip are mai multe tipuri de returnare \"specifice metodei\", cum ar fi "
"`std::collections::hash_map::Keys`. Aceste tipuri apar adesea 칥n c캒ut캒rile "
"din documentele Rust. Ar캒ta탵i studen탵ilor documenta탵ia pentru acest tip 탳i "
"leg캒tura util캒 c캒tre metoda `keys`."

#: src/std-types/exercise.md
#, fuzzy
msgid ""
"In this exercise you will take a very simple data structure and make it "
"generic. It uses a [`std::collections::HashMap`](https://doc.rust-lang.org/"
"stable/std/collections/struct.HashMap.html) to keep track of which values "
"have been seen and how many times each one has appeared."
msgstr ""
"칉n acest exerci탵iu ve탵i lua o structur캒 de date foarte simpl캒 탳i o ve탵i face "
"generic캒. Aceasta utilizeaz캒 un [`std::collections::HashMap`](https://doc."
"rust-lang.org/stable/std/collections/struct.HashMap.html) pentru a 탵ine "
"eviden탵a valorilor care au fost v캒zute 탳i de c칙te ori a ap캒rut fiecare "
"dintre ele."

#: src/std-types/exercise.md
#, fuzzy
msgid ""
"The initial version of `Counter` is hard coded to only work for `u32` "
"values. Make the struct and its methods generic over the type of value being "
"tracked, that way `Counter` can track any type of value."
msgstr ""
"Versiunea ini탵ial캒 a lui `Counter` este codificat캒 칥n mod gre탳it pentru a "
"func탵iona numai pentru valori `u32`. Face탵i ca structura 탳i metodele sale s캒 "
"fie generice pentru tipul de valoare urm캒rit, astfel 칥nc칙t `Counter` s캒 "
"poat캒 urm캒ri orice tip de valoare."

#: src/std-types/exercise.md
#, fuzzy
msgid ""
"If you finish early, try using the [`entry`](https://doc.rust-lang.org/"
"stable/std/collections/struct.HashMap.html#method.entry) method to halve the "
"number of hash lookups required to implement the `count` method."
msgstr ""
"Dac캒 termina탵i mai devreme, 칥ncerca탵i s캒 folosi탵i metoda [`entry`](https://"
"doc.rust-lang.org/stable/std/collections/struct.HashMap.html#method.entry) "
"pentru a reduce la jum캒tate num캒rul de c캒ut캒ri hash necesare pentru a "
"implementa metoda `count`."

#: src/std-types/exercise.md src/std-types/solution.md
#, fuzzy
msgid ""
"/// Counter counts the number of times each value of type T has been seen.\n"
msgstr ""
"/// Contorul num캒r캒 num캒rul de ori de c칙te ori a fost v캒zut캒 fiecare valoare "
"de tip T.\n"

#: src/std-types/exercise.md src/std-types/solution.md
#, fuzzy
msgid "/// Create a new Counter.\n"
msgstr "/// Crea탵i un nou contor.\n"

#: src/std-types/exercise.md src/std-types/solution.md
#, fuzzy
msgid "/// Count an occurrence of the given value.\n"
msgstr "/// Num캒r캒 o apari탵ie a valorii date.\n"

#: src/std-types/exercise.md src/std-types/solution.md
#, fuzzy
msgid "/// Return the number of times the given value has been seen.\n"
msgstr "/// 칉ntoarce num캒rul de ori 칥n care valoarea dat캒 a fost v캒zut캒.\n"

#: src/std-types/exercise.md src/std-types/solution.md
#, fuzzy
msgid "\"saw {} values equal to {}\""
msgstr "\"a v캒zut {} valori egale cu {}\""

#: src/std-types/exercise.md src/std-types/solution.md
#, fuzzy
msgid "\"apple\""
msgstr "\"m캒r\""

#: src/std-types/exercise.md src/std-types/solution.md
#, fuzzy
msgid "\"orange\""
msgstr "\"portocaliu\""

#: src/std-types/exercise.md src/std-types/solution.md
#, fuzzy
msgid "\"got {} apples\""
msgstr "\"am primit {} mere\""

#: src/std-traits.md
#, fuzzy
msgid "[Comparisons](./std-traits/comparisons.md) (10 minutes)"
msgstr "[Compara탵ii](./std-traits/comparisons.md) (10 minute)"

#: src/std-traits.md
#, fuzzy
msgid "[Operators](./std-traits/operators.md) (10 minutes)"
msgstr "[Operatori](./std-traits/operators.md) (10 minute)"

#: src/std-traits.md
#, fuzzy
msgid "[From and Into](./std-traits/from-and-into.md) (10 minutes)"
msgstr "[De la 탳i 칥n](./std-traits/from-and-into.md) (10 minute)"

#: src/std-traits.md
#, fuzzy
msgid "[Casting](./std-traits/casting.md) (5 minutes)"
msgstr "[Casting](./std-traits/casting.md) (5 minute)"

#: src/std-traits.md
#, fuzzy
msgid "[Read and Write](./std-traits/read-and-write.md) (10 minutes)"
msgstr "[Citire 탳i scriere](./std-traits/read-and-write.md) (10 minute)"

#: src/std-traits.md
#, fuzzy
msgid "[Default, struct update syntax](./std-traits/default.md) (5 minutes)"
msgstr ""
"[Default, sintaxa de actualizare a structurii](./std-traits/default.md) (5 "
"minute)"

#: src/std-traits.md
#, fuzzy
msgid "[Closures](./std-traits/closures.md) (20 minutes)"
msgstr "[칉nchideri](./std-traits/closures.md) (20 minute)"

#: src/std-traits.md
#, fuzzy
msgid "[Exercise: ROT13](./std-traits/exercise.md) (30 minutes)"
msgstr "[Exerci탵iu: ROT13](./std-traits/exercise.md) (30 minute)"

#: src/std-traits.md
#, fuzzy
msgid "This segment should take about 1 hour and 40 minutes"
msgstr "Acest segment ar trebui s캒 dureze aproximativ 1 or캒 탳i 40 de minute"

#: src/std-traits.md
#, fuzzy
msgid ""
"As with the standard-library types, spend time reviewing the documentation "
"for each trait."
msgstr ""
"Ca 탳i 칥n cazul tipurilor de bibliotec캒 standard, petrece탵i timp examin칙nd "
"documenta탵ia pentru fiecare tr캒s캒tur캒."

#: src/std-traits.md
#, fuzzy
msgid "This section is long. Take a break midway through."
msgstr "Aceast캒 sec탵iune este lung캒. Lua탵i o pauz캒 la jum캒tatea drumului."

#: src/std-traits/comparisons.md
#, fuzzy
msgid ""
"These traits support comparisons between values. All traits can be derived "
"for types containing fields that implement these traits."
msgstr ""
"Aceste tr캒s캒turi sprijin캒 compara탵iile 칥ntre valori. Toate tr캒s캒turile pot "
"fi derivate pentru tipurile care con탵in c칙mpuri care implementeaz캒 aceste "
"tr캒s캒turi."

#: src/std-traits/comparisons.md
#, fuzzy
msgid "`PartialEq` and `Eq`"
msgstr "`Par탵ialEq` 탳i `Eq`"

#: src/std-traits/comparisons.md
#, fuzzy
msgid ""
"`PartialEq` is a partial equivalence relation, with required method `eq` and "
"provided method `ne`. The `==` and `!=` operators will call these methods."
msgstr ""
"`PartialEq` este o rela탵ie de echivalen탵캒 par탵ial캒, cu metoda obligatorie "
"`eq` 탳i metoda furnizat캒 `ne`. Operatorii `==` 탳i `!=` vor apela aceste "
"metode."

#: src/std-traits/comparisons.md
#, fuzzy
msgid ""
"`Eq` is a full equivalence relation (reflexive, symmetric, and transitive) "
"and implies `PartialEq`. Functions that require full equivalence will use "
"`Eq` as a trait bound."
msgstr ""
"`Eq` este o rela탵ie de echivalen탵캒 complet캒 (reflexiv캒, simetric캒 탳i "
"tranzitiv캒) 탳i implic캒 `Par탵ialEq`. Func탵iile care necesit캒 o echivalen탵캒 "
"complet캒 vor utiliza `Eq` ca o leg캒tur캒 de tr캒s캒tur캒."

#: src/std-traits/comparisons.md
#, fuzzy
msgid "`PartialOrd` and `Ord`"
msgstr "`Read` 탳i `Write`"

#: src/std-traits/comparisons.md
#, fuzzy
msgid ""
"`PartialOrd` defines a partial ordering, with a `partial_cmp` method. It is "
"used to implement the `<`, `<=`, `>=`, and `>` operators."
msgstr ""
"`PartialOrd` define탳te o ordine par탵ial캒, cu o metod캒 `partial_cmp`. Este "
"utilizat pentru a implementa operatorii `<`, `<=`, `>=` 탳i `>`."

#: src/std-traits/comparisons.md
#, fuzzy
msgid "`Ord` is a total ordering, with `cmp` returning `Ordering`."
msgstr "`Ord` este o ordine total캒, cu `cmp` return칙nd `Ordering`."

#: src/std-traits/comparisons.md
#, fuzzy
msgid ""
"`PartialEq` can be implemented between different types, but `Eq` cannot, "
"because it is reflexive:"
msgstr ""
"`PartialEq` poate fi implementat 칥ntre tipuri diferite, dar `Eq` nu poate fi "
"implementat, deoarece este reflexiv:"

#: src/std-traits/comparisons.md
#, fuzzy
msgid ""
"In practice, it's common to derive these traits, but uncommon to implement "
"them."
msgstr ""
"칉n practic캒, aceste tr캒s캒turi sunt des 칥nt칙lnite, dar implementarea lor este "
"mai pu탵in obi탳nuit캒."

#: src/std-traits/operators.md
#, fuzzy
msgid ""
"Operator overloading is implemented via traits in [`std::ops`](https://doc."
"rust-lang.org/std/ops/index.html):"
msgstr ""
"Supra칥nc캒rcarea operatorilor este implementat캒 prin intermediul tr캒s캒turilor "
"칥n [`std::ops`](https://doc.rust-lang.org/std/ops/index.html):"

#: src/std-traits/operators.md
#, fuzzy
msgid "\"{:?} + {:?} = {:?}\""
msgstr "\"{:?} + {:?} = {:?}\""

#: src/std-traits/operators.md src/memory-management/drop.md
#, fuzzy
msgid "Discussion points:"
msgstr "Puncte de discu탵ie:"

#: src/std-traits/operators.md
#, fuzzy
msgid ""
"You could implement `Add` for `&Point`. In which situations is that useful?"
msgstr "A탵i putea implementa `Add` pentru `&Point`. 칉n ce situa탵ii este util캒?"

#: src/std-traits/operators.md
#, fuzzy
msgid ""
"Answer: `Add:add` consumes `self`. If type `T` for which you are overloading "
"the operator is not `Copy`, you should consider overloading the operator for "
"`&T` as well. This avoids unnecessary cloning on the call site."
msgstr ""
"R캒spuns: `Add:add` consum캒 `self`. Dac캒 tipul `T` pentru care supra칥nc캒rca탵i "
"operatorul nu este `Copy`, ar trebui s캒 lua탵i 칥n considerare supra칥nc캒rcarea "
"operatorului 탳i pentru `&T`. Astfel se evit캒 clonarea inutil캒 pe locul de "
"apel."

#: src/std-traits/operators.md
#, fuzzy
msgid ""
"Why is `Output` an associated type? Could it be made a type parameter of the "
"method?"
msgstr ""
"De ce este `Output` un tip asociat? Ar putea fi transformat 칥ntr-un "
"parametru de tip al metodei?"

#: src/std-traits/operators.md
#, fuzzy
msgid ""
"Short answer: Function type parameters are controlled by the caller, but "
"associated types (like `Output`) are controlled by the implementer of a "
"trait."
msgstr ""
"R캒spuns scurt: Parametrii de tip func탵ie sunt controla탵i de c캒tre apelant, "
"dar tipurile asociate (cum ar fi `Output`) sunt controlate de c캒tre "
"implementatorul unei tr캒s캒turi."

#: src/std-traits/operators.md
#, fuzzy
msgid ""
"You could implement `Add` for two different types, e.g. `impl Add<(i32, "
"i32)> for Point` would add a tuple to a `Point`."
msgstr ""
"A탵i putea implementa `Add` pentru dou캒 tipuri diferite, de exemplu, `impl "
"Add<(i32, i32)> pentru Point` ar ad캒uga un tuple la un `Point`."

#: src/std-traits/from-and-into.md
#, fuzzy
msgid ""
"Types implement [`From`](https://doc.rust-lang.org/std/convert/trait.From."
"html) and [`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) to "
"facilitate type conversions:"
msgstr ""
"Tipurile implementeaz캒 [`From`](https://doc.rust-lang.org/std/convert/trait."
"From.html) 탳i [`Into`](https://doc.rust-lang.org/std/convert/trait.Into."
"html) pentru a facilita conversiile de tip:"

#: src/std-traits/from-and-into.md
#, fuzzy
msgid "\"{s}, {addr}, {one}, {bigger}\""
msgstr "\"{s}, {addr}, {one}, {bigger}\""

#: src/std-traits/from-and-into.md
#, fuzzy
msgid ""
"[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) is "
"automatically implemented when [`From`](https://doc.rust-lang.org/std/"
"convert/trait.From.html) is implemented:"
msgstr ""
"[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) este "
"implementat automat atunci c칙nd este implementat [`From`](https://doc.rust-"
"lang.org/std/convert/trait.From.html):"

#: src/std-traits/from-and-into.md
#, fuzzy
msgid ""
"That's why it is common to only implement `From`, as your type will get "
"`Into` implementation too."
msgstr ""
"De aceea, este obi탳nuit s캒 se implementeze doar `From`, deoarece tipul t캒u "
"va primi 탳i implementarea `Into`."

#: src/std-traits/from-and-into.md
#, fuzzy
msgid ""
"When declaring a function argument input type like \"anything that can be "
"converted into a `String`\", the rule is opposite, you should use `Into`. "
"Your function will accept types that implement `From` and those that _only_ "
"implement `Into`."
msgstr ""
"Atunci c칙nd declara탵i un tip de intrare de argument de func탵ie de tipul "
"\"orice poate fi convertit 칥ntr-un `String`\", regula este opus캒, trebuie s캒 "
"utiliza탵i `Into`. Func탵ia dvs. va accepta tipurile care implementeaz캒 `From` "
"탳i cele care implementeaz캒 _doar_ `Into`."

#: src/std-traits/casting.md
#, fuzzy
msgid ""
"Rust has no _implicit_ type conversions, but does support explicit casts "
"with `as`. These generally follow C semantics where those are defined."
msgstr ""
"Rust nu dispune de conversii de tip _implicite_, dar suport캒 transform캒ri "
"explicite cu `as`. 칉n general, acestea urmeaz캒 semantica C, acolo unde sunt "
"definite."

#: src/std-traits/casting.md
#, fuzzy
msgid "\"as u16: {}\""
msgstr "\"as u16: {}\""

#: src/std-traits/casting.md
#, fuzzy
msgid "\"as i16: {}\""
msgstr ""
"Biblioteca standard are o implementare a `From<i8> pentru i16`, ceea ce "
"칥nseamn캒 c캒 putem converti o variabil캒 `x` de tip `i8` 칥n `i16` prin "
"apelarea `i16::from(x)`. Sau, mai simplu, cu `x.into()`, deoarece "
"implementarea `From<i8> for i16` creeaz캒 automat o implementare a `Into<i16> "
"for i8`."

#: src/std-traits/casting.md
#, fuzzy
msgid "\"as u8: {}\""
msgstr "탲irurile de octe탵i v캒 permit s캒 crea탵i direct o valoare `&[u8]`:"

#: src/std-traits/casting.md
#, fuzzy
msgid ""
"The results of `as` are _always_ defined in Rust and consistent across "
"platforms. This might not match your intuition for changing sign or casting "
"to a smaller type -- check the docs, and comment for clarity."
msgstr ""
"Rezultatele lui `as` sunt _칥ntotdeauna_ definite 칥n Rust 탳i sunt consecvente "
"pe toate platformele. Este posibil ca acest lucru s캒 nu se potriveasc캒 cu "
"intui탵ia dvs. de a schimba semnul sau de a face casting la un tip mai mic - "
"verifica탵i documentele 탳i comenta탵i pentru claritate."

#: src/std-traits/casting.md
#, fuzzy
msgid ""
"Casting with `as` is a relatively sharp tool that is easy to use "
"incorrectly, and can be a source of subtle bugs as future maintenance work "
"changes the types that are used or the ranges of values in types. Casts are "
"best used only when the intent is to indicate unconditional truncation (e.g. "
"selecting the bottom 32 bits of a `u64` with `as u32`, regardless of what "
"was in the high bits)."
msgstr ""
"Casting-ul cu `as` este un instrument relativ ascu탵it, u탳or de utilizat 칥n "
"mod incorect 탳i poate fi o surs캒 de erori subtile pe m캒sur캒 ce viitoarele "
"lucr캒ri de 칥ntre탵inere modific캒 tipurile utilizate sau intervalele de valori "
"din tipuri. Castingurile se utilizeaz캒 cel mai bine numai atunci c칙nd "
"inten탵ia este de a indica o trunchiere necondi탵ionat캒 (de exemplu, "
"selectarea celor 32 de bi탵i inferiori ai unui `u64` cu `as u32`, indiferent "
"de ceea ce se afla 칥n bi탵ii superiori)."

#: src/std-traits/casting.md
#, fuzzy
msgid ""
"For infallible casts (e.g. `u32` to `u64`), prefer using `From` or `Into` "
"over `as` to confirm that the cast is in fact infallible. For fallible "
"casts, `TryFrom` and `TryInto` are available when you want to handle casts "
"that fit differently from those that don't."
msgstr ""
"칉n cazul unor distribu탵ii infailibile (de exemplu, de la `u32` la `u64`), se "
"prefer캒 utilizarea lui `From` sau `Into` 칥n locul lui `as` pentru a confirma "
"c캒 distribu탵ia este de fapt infailibil캒. Pentru distribu탵iile falibile, "
"`TryFrom` 탳i `TryInto` sunt disponibile atunci c칙nd dori탵i s캒 trata탵i "
"distribu탵iile care se potrivesc diferit de cele care nu se potrivesc."

#: src/std-traits/casting.md
#, fuzzy
msgid "Consider taking a break after this slide."
msgstr ""
"Lua탵i 칥n considerare posibilitatea de a lua o pauz캒 dup캒 acest diapozitiv."

#: src/std-traits/casting.md
#, fuzzy
msgid ""
"`as` is similar to a C++ static cast. Use of `as` in cases where data might "
"be lost is generally discouraged, or at least deserves an explanatory "
"comment."
msgstr ""
"`as` este similar cu un cast static din C++. Utilizarea lui `as` 칥n cazurile "
"칥n care datele ar putea fi pierdute este, 칥n general, descurajat캒 sau cel "
"pu탵in merit캒 un comentariu explicativ."

#: src/std-traits/casting.md
#, fuzzy
msgid "This is common in casting integers to `usize` for use as an index."
msgstr ""
"Acest lucru este obi탳nuit 칥n cazul 칥n care se transform캒 numere 칥ntregi 칥n "
"`usize` pentru a fi utilizate ca indici."

#: src/std-traits/read-and-write.md
#, fuzzy
msgid ""
"Using [`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) and "
"[`BufRead`](https://doc.rust-lang.org/std/io/trait.BufRead.html), you can "
"abstract over `u8` sources:"
msgstr ""
"Folosind [`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) 탳i "
"[`BufRead`](https://doc.rust-lang.org/std/io/trait.BufRead.html), pute탵i "
"face abstrac탵ie de sursele `u8`:"

#: src/std-traits/read-and-write.md
#, fuzzy
msgid "b\"foo\\nbar\\nbaz\\n\""
msgstr "b \"foo\\nbar\\nbaz\\n\""

#: src/std-traits/read-and-write.md
#, fuzzy
msgid "\"lines in slice: {}\""
msgstr "\"linii 칥n slice: {}\""

#: src/std-traits/read-and-write.md
#, fuzzy
msgid "\"lines in file: {}\""
msgstr "\"linii 칥n fi탳ier: {}\""

#: src/std-traits/read-and-write.md
#, fuzzy
msgid ""
"Similarly, [`Write`](https://doc.rust-lang.org/std/io/trait.Write.html) lets "
"you abstract over `u8` sinks:"
msgstr ""
"칉n mod similar, [`Write`](https://doc.rust-lang.org/std/io/trait.Write.html) "
"v캒 permite s캒 face탵i abstrac탵ie de `u8` sink-uri:"

#: src/std-traits/read-and-write.md
msgid "\"\\n\""
msgstr "\"\\n\""

#: src/std-traits/read-and-write.md
#, fuzzy
msgid "\"Logged: {:?}\""
msgstr "\"칉nregistrat: {:?}\""

#: src/std-traits/default.md
#, fuzzy
msgid "The `Default` Trait"
msgstr "Tr캒s캒tura `Default` (implicit)"

#: src/std-traits/default.md
#, fuzzy
msgid ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) trait "
"produces a default value for a type."
msgstr ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) "
"caracteristica produce o valoare implicit캒 pentru un tip."

#: src/std-traits/default.md
#, fuzzy
msgid "\"John Smith\""
msgstr "\"John Smith\""

#: src/std-traits/default.md
#, fuzzy
msgid "\"{default_struct:#?}\""
msgstr "'Default' (implicit), sintaxa de actualizare a structurilor"

#: src/std-traits/default.md
#, fuzzy
msgid "\"Y is set!\""
msgstr "\"Y este stabilit!\""

#: src/std-traits/default.md
#, fuzzy
msgid "\"{almost_default_struct:#?}\""
msgstr "\"{almost_default_struct:#?}\""

#: src/std-traits/default.md src/lifetimes/exercise.md
#: src/lifetimes/solution.md
#, fuzzy
msgid "\"{:#?}\""
msgstr "\"{:#?}\""

#: src/std-traits/default.md
#, fuzzy
msgid ""
"It can be implemented directly or it can be derived via `#[derive(Default)]`."
msgstr ""
"Poate fi implementat direct sau poate fi derivat prin `#[derive(Default)]`."

#: src/std-traits/default.md
#, fuzzy
msgid ""
"A derived implementation will produce a value where all fields are set to "
"their default values."
msgstr ""
"O implementare derivat캒 va produce o valoare 칥n care toate c칙mpurile sunt "
"setate la valorile lor implicite."

#: src/std-traits/default.md
#, fuzzy
msgid "This means all types in the struct must implement `Default` too."
msgstr ""
"Aceasta 칥nseamn캒 c캒 toate tipurile din structura trebuie s캒 implementeze 탳i "
"`Default`."

#: src/std-traits/default.md
#, fuzzy
msgid ""
"Standard Rust types often implement `Default` with reasonable values (e.g. "
"`0`, `\"\"`, etc)."
msgstr ""
"Tipurile standard Rust implementeaz캒 adesea `Default` cu valori rezonabile "
"(de exemplu, `0`, `\"\"`, etc.)."

#: src/std-traits/default.md
#, fuzzy
msgid "The partial struct initialization works nicely with default."
msgstr "Copierea par탵ial캒 a structurii func탵ioneaz캒 bine 칥n mod implicit."

#: src/std-traits/default.md
#, fuzzy
msgid ""
"The Rust standard library is aware that types can implement `Default` and "
"provides convenience methods that use it."
msgstr ""
"Biblioteca standard Rust este con탳tient캒 de faptul c캒 tipurile pot "
"implementa `Default` 탳i ofer캒 metode de convenien탵캒 care 칥l utilizeaz캒."

#: src/std-traits/default.md
#, fuzzy
msgid ""
"The `..` syntax is called [struct update syntax](https://doc.rust-lang.org/"
"book/ch05-01-defining-structs.html#creating-instances-from-other-instances-"
"with-struct-update-syntax)."
msgstr ""
"sintaxa `..` se nume탳te [struct update syntax](https://doc.rust-lang.org/"
"book/ch05-01-defining-structs.html#creating-instances-from-other-instances-"
"with-struct-update-syntax)"

#: src/std-traits/closures.md
#, fuzzy
msgid ""
"Closures or lambda expressions have types which cannot be named. However, "
"they implement special [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn."
"html), [`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), and "
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) traits:"
msgstr ""
"칉nchiderile sau expresiile lambda au tipuri care nu pot fi numite. Cu toate "
"acestea, ele implementeaz캒 tr캒s캒turile speciale [`Fn`](https://doc.rust-lang."
"org/std/ops/trait.Fn.html), [`FnMut`](https://doc.rust-lang.org/std/ops/"
"trait.FnMut.html) 탳i [`FnOnce`](https://doc.rust-lang.org/std/ops/trait."
"FnOnce.html):"

#: src/std-traits/closures.md
#, fuzzy
msgid "\"Calling function on {input}\""
msgstr "Apelarea func탵iilor nesigure"

#: src/std-traits/closures.md
#, fuzzy
msgid "\"add_3: {}\""
msgstr "\"add_3: {}\""

#: src/std-traits/closures.md
#, fuzzy
msgid "\"accumulate: {}\""
msgstr "\"acumuleaz캒: {}\""

#: src/std-traits/closures.md
#, fuzzy
msgid "\"multiply_sum: {}\""
msgstr "\"multiply_sum: {}\""

#: src/std-traits/closures.md
#, fuzzy
msgid ""
"An `Fn` (e.g. `add_3`) neither consumes nor mutates captured values, or "
"perhaps captures nothing at all. It can be called multiple times "
"concurrently."
msgstr ""
"Un `Fn` (de exemplu, `add_3`) nu consum캒 탳i nici nu modific캒 valorile "
"capturate, sau poate nu capteaz캒 nimic. Acesta poate fi apelat de mai multe "
"ori simultan."

#: src/std-traits/closures.md
#, fuzzy
msgid ""
"An `FnMut` (e.g. `accumulate`) might mutate captured values. You can call it "
"multiple times, but not concurrently."
msgstr ""
"Un `FnMut` (de exemplu, `accumulate`) poate modifica valorile capturate. Se "
"poate apela de mai multe ori, dar nu concomitent."

#: src/std-traits/closures.md
#, fuzzy
msgid ""
"If you have an `FnOnce` (e.g. `multiply_sum`), you may only call it once. It "
"might consume captured values."
msgstr ""
"Dac캒 ave탵i un `FnOnce` (de exemplu, `multiply_sum`), 칥l pute탵i apela doar o "
"singur캒 dat캒. Acesta ar putea consuma valori capturate."

#: src/std-traits/closures.md
#, fuzzy
msgid ""
"`FnMut` is a subtype of `FnOnce`. `Fn` is a subtype of `FnMut` and `FnOnce`. "
"I.e. you can use an `FnMut` wherever an `FnOnce` is called for, and you can "
"use an `Fn` wherever an `FnMut` or `FnOnce` is called for."
msgstr ""
"`FnMut` este un subtip al `FnOnce`. `Fn` este un subtip al lui `FnMut` 탳i "
"`FnOnce`. Adic캒, pute탵i utiliza un `FnMut` oriunde se solicit캒 un `FnOnce` "
"탳i pute탵i utiliza un `Fn` oriunde se solicit캒 un `FnMut` sau un `FnOnce`."

#: src/std-traits/closures.md
#, fuzzy
msgid ""
"When you define a function that takes a closure, you should take `FnOnce` if "
"you can (i.e. you call it once), or `FnMut` else, and last `Fn`. This allows "
"the most flexibility for the caller."
msgstr ""
"Atunci c칙nd defini탵i o func탵ie care ia o 칥nchidere, ar trebui s캒 lua탵i "
"`FnOnce` dac캒 pute탵i (adic캒 s캒 o apela탵i o singur캒 dat캒), sau `FnMut` 칥n caz "
"contrar, 탳i 칥n final `Fn`. Acest lucru permite cea mai mare flexibilitate "
"pentru apelant."

#: src/std-traits/closures.md
#, fuzzy
msgid ""
"In contrast, when you have a closure, the most flexible you can have is `Fn` "
"(it can be passed everywhere), then `FnMut`, and lastly `FnOnce`."
msgstr ""
"칉n schimb, atunci c칙nd ave탵i o 칥nchidere, cea mai flexibil캒 este `Fn` (poate "
"fi trecut캒 peste tot), apoi `FnMut` 탳i, 칥n cele din urm캒, `FnOnce`."

#: src/std-traits/closures.md
#, fuzzy
msgid ""
"The compiler also infers `Copy` (e.g. for `add_3`) and `Clone` (e.g. "
"`multiply_sum`), depending on what the closure captures."
msgstr ""
"Compilatorul deduce, de asemenea, `Copy` (de exemplu, pentru `add_3`) 탳i "
"`Clone` (de exemplu, `multiply_sum`), 칥n func탵ie de ceea ce capteaz캒 "
"칥nchiderea."

#: src/std-traits/closures.md
#, fuzzy
msgid ""
"By default, closures will capture by reference if they can. The `move` "
"keyword makes them capture by value."
msgstr ""
"칉n mod implicit, 칥nchiderile vor captura prin referin탵캒 dac캒 pot. Cuv칙ntul "
"cheie `move` le face s캒 captureze prin valoare."

#: src/std-traits/closures.md src/smart-pointers/trait-objects.md
#, fuzzy
msgid "\"{} {}\""
msgstr "\"{} {}\""

#: src/std-traits/closures.md
#, fuzzy
msgid "\"Hi\""
msgstr "\"Bun캒\""

#: src/std-traits/closures.md
#, fuzzy
msgid "\"Greg\""
msgstr "\"Salut캒ri\""

#: src/std-traits/exercise.md
#, fuzzy
msgid ""
"In this example, you will implement the classic [\"ROT13\" cipher](https://"
"en.wikipedia.org/wiki/ROT13). Copy this code to the playground, and "
"implement the missing bits. Only rotate ASCII alphabetic characters, to "
"ensure the result is still valid UTF-8."
msgstr ""
"칉n acest exemplu, ve탵i implementa cifra clasic캒 [\"ROT13\"](https://en."
"wikipedia.org/wiki/ROT13). Copia탵i acest cod pe terenul de joac캒 탳i "
"implementa탵i bi탵ii lips캒. Roti탵i numai caracterele alfabetice ASCII, pentru "
"a v캒 asigura c캒 rezultatul este 칥nc캒 valid UTF-8."

#: src/std-traits/exercise.md
#, fuzzy
msgid "// Implement the `Read` trait for `RotDecoder`.\n"
msgstr "// Implementa탵i caracteristica `Read` pentru `RotDecoder`.\n"

#: src/std-traits/exercise.md src/std-traits/solution.md
#, fuzzy
msgid "\"Gb trg gb gur bgure fvqr!\""
msgstr "\"Gb trg gb gb gur bgure fvqr!\""

#: src/std-traits/exercise.md src/std-traits/solution.md
#, fuzzy
msgid "\"To get to the other side!\""
msgstr "\"Pentru a ajunge pe partea cealalt캒!\""

#: src/std-traits/exercise.md
#, fuzzy
msgid ""
"What happens if you chain two `RotDecoder` instances together, each rotating "
"by 13 characters?"
msgstr ""
"Ce se 칥nt칙mpl캒 dac캒 칥nl캒n탵ui탵i dou캒 instan탵e `RotDecoder` 칥mpreun캒, fiecare "
"rotindu-se cu 13 caractere?"

#: src/std-traits/solution.md
#, fuzzy
msgid "'A'"
msgstr "'A'"

#: src/welcome-day-3.md
#, fuzzy
msgid "Welcome to Day 3"
msgstr "Bine a탵i venit 칥n ziua 3"

#: src/welcome-day-3.md
#, fuzzy
msgid "Today, we will cover:"
msgstr "Ast캒zi, vom aborda:"

#: src/welcome-day-3.md
#, fuzzy
msgid ""
"Memory management, lifetimes, and the borrow checker: how Rust ensures "
"memory safety."
msgstr ""
"Gestionarea memoriei, durata de via탵캒 탳i verificatorul de 칥mprumuturi: cum "
"asigur캒 Rust siguran탵a memoriei."

#: src/welcome-day-3.md
#, fuzzy
msgid "Smart pointers: standard library pointer types."
msgstr "Indicatori inteligen탵i: tipuri de pointeri din biblioteca standard."

#: src/welcome-day-3.md
#, fuzzy
msgid "[Welcome](./welcome-day-3.md) (3 minutes)"
msgstr "[Introducere](../welcome-day-3.md) (3 minute)"

#: src/welcome-day-3.md
#, fuzzy
msgid "[Memory Management](./memory-management.md) (1 hour)"
msgstr "[Managementul memoriei](../memory-management.md) (1 or캒 탳i 10 minute)"

#: src/welcome-day-3.md
#, fuzzy
msgid "[Smart Pointers](./smart-pointers.md) (55 minutes)"
msgstr "[Pointeri inteligen탵i](../smart-pointers.md) (45 minute)"

#: src/welcome-day-3.md
#, fuzzy
msgid ""
"Including 10 minute breaks, this session should take about 2 hours and 20 "
"minutes"
msgstr ""
"Incluz칙nd pauzele de 10 minute, aceast캒 sesiune ar trebui s캒 dureze "
"aproximativ 2 ore 탳i 20 de minute"

#: src/memory-management.md
#, fuzzy
msgid "[Review of Program Memory](./memory-management/review.md) (5 minutes)"
msgstr ""
"[Revizuirea memoriei programului](./memory-management/review.md) (5 minute)"

#: src/memory-management.md
#, fuzzy
msgid ""
"[Approaches to Memory Management](./memory-management/approaches.md) (10 "
"minutes)"
msgstr ""
"[Abord캒ri ale managementului memoriei](./memory-management/approaches.md) "
"(10 minute)"

#: src/memory-management.md
#, fuzzy
msgid "[Ownership](./memory-management/ownership.md) (5 minutes)"
msgstr "[Proprietate](./memory-management/ownership.md) (5 minute)"

#: src/memory-management.md
#, fuzzy
msgid "[Move Semantics](./memory-management/move.md) (5 minutes)"
msgstr "[Semantica mut캒rii](./memory-management/move.md) (10 minute)"

#: src/memory-management.md
#, fuzzy
msgid "[Clone](./memory-management/clone.md) (2 minutes)"
msgstr "[Clone](./memory-management/clone.md) (2 minute)"

#: src/memory-management.md
#, fuzzy
msgid "[Copy Types](./memory-management/copy-types.md) (5 minutes)"
msgstr "[Tipuri de copiere](./memory-management/copy-types.md) (5 minute)"

#: src/memory-management.md
#, fuzzy
msgid "[Drop](./memory-management/drop.md) (10 minutes)"
msgstr "[Drop](./memory-management/drop.md) (10 minute)"

#: src/memory-management.md
#, fuzzy
msgid "[Exercise: Builder Type](./memory-management/exercise.md) (20 minutes)"
msgstr ""
"[Exerci탵iu: Tipul de constructor](./memory-management/exercise.md) (20 "
"minute)"

#: src/memory-management/review.md
#, fuzzy
msgid "Programs allocate memory in two ways:"
msgstr "Programele aloc캒 memoria 칥n dou캒 moduri:"

#: src/memory-management/review.md
msgid "Stack: Continuous area of memory for local variables."
msgstr "Stiva: zona continu캒 de memorie pentru variabilele locale."

#: src/memory-management/review.md
msgid "Values have fixed sizes known at compile time."
msgstr "Valorile au dimensiuni fixe cunoscute 칥n momentul compil캒rii."

#: src/memory-management/review.md
msgid "Extremely fast: just move a stack pointer."
msgstr "Extrem de rapid: este suficient s캒 muta탵i un pointer la stiv캒."

#: src/memory-management/review.md
msgid "Easy to manage: follows function calls."
msgstr "U탳or de gestionat: urm캒re탳te apelurile de func탵ii."

#: src/memory-management/review.md
msgid "Great memory locality."
msgstr "Pozi탵ionate bun캒 a memoriei."

#: src/memory-management/review.md
msgid "Heap: Storage of values outside of function calls."
msgstr "Heap: stocarea valorilor 칥n afara apelurilor de func탵ii."

#: src/memory-management/review.md
msgid "Values have dynamic sizes determined at runtime."
msgstr "Valorile au dimensiuni dinamice determinate la momentul execu탵iei."

#: src/memory-management/review.md
msgid "Slightly slower than the stack: some book-keeping needed."
msgstr "Pu탵in mai lent dec칙t stiva: este nevoie de o anumit캒 contabilitate."

#: src/memory-management/review.md
#, fuzzy
msgid "No guarantee of memory locality."
msgstr "Nu exist캒 nicio garan탵ie a pozi탵ion캒rii memoriei."

#: src/memory-management/review.md
msgid ""
"Creating a `String` puts fixed-sized metadata on the stack and dynamically "
"sized data, the actual string, on the heap:"
msgstr ""
"Crearea unui `String` plaseaz캒 metadatele de dimensiuni fixe pe stiv캒 탳i "
"datele de dimensiuni dinamice, 탳irul propriu-zis, pe heap:"

#: src/memory-management/review.md
msgid ""
"Mention that a `String` is backed by a `Vec`, so it has a capacity and "
"length and can grow if mutable via reallocation on the heap."
msgstr ""
"Men탵iona탵i c캒 un `String` este sus탵inut de un `Vec`, deci are o capacitate "
"탳i o lungime 탳i poate cre탳te dac캒 este mutabil prin realocare pe heap."

#: src/memory-management/review.md
msgid ""
"If students ask about it, you can mention that the underlying memory is heap "
"allocated using the [System Allocator](https://doc.rust-lang.org/std/alloc/"
"struct.System.html) and custom allocators can be implemented using the "
"[Allocator API](https://doc.rust-lang.org/std/alloc/index.html)"
msgstr ""
"Dac캒 cursan탵ii v캒 칥ntreab캒 despre acest lucru, pute탵i men탵iona c캒 memoria de "
"baz캒 este alocat캒 칥n heap cu ajutorul [System Allocator](https://doc.rust-"
"lang.org/std/alloc/struct.System.html) 탳i c캒 alocatorii personaliza탵i pot fi "
"implementa탵i cu ajutorul [Allocator API](https://doc.rust-lang.org/std/alloc/"
"index.html)"

#: src/memory-management/review.md
msgid ""
"We can inspect the memory layout with `unsafe` Rust. However, you should "
"point out that this is rightfully unsafe!"
msgstr ""
"Putem inspecta dispunerea memoriei cu `unsafe` Rust. Cu toate acestea, ar "
"trebui s캒 preciza탵i c캒 acest lucru este, pe bun캒 dreptate, nesigur!"

#: src/memory-management/review.md src/testing/unit-tests.md
msgid "' '"
msgstr "' '"

#: src/memory-management/review.md
#, fuzzy
msgid "\"world\""
msgstr "\"lume\""

#: src/memory-management/review.md
#, fuzzy
msgid ""
"// DON'T DO THIS AT HOME! For educational purposes only.\n"
"    // String provides no guarantees about its layout, so this could lead "
"to\n"
"    // undefined behavior.\n"
msgstr ""
"// NU FACE탴I ASTA ACAS캑! Doar 칥n scopuri educa탵ionale.\n"
"    // 탲irul de caractere nu ofer캒 nicio garan탵ie cu privire la aspectul "
"s캒u, astfel 칥nc칙t acest lucru ar putea duce la\n"
"    // comportament nedefinit.\n"

#: src/memory-management/review.md
#, fuzzy
msgid "\"capacity = {capacity}, ptr = {ptr:#x}, len = {len}\""
msgstr "\"capacity = {capacity}, ptr = {ptr:#x}, len = {len}\""

#: src/memory-management/approaches.md
msgid "Traditionally, languages have fallen into two broad categories:"
msgstr "칉n mod tradi탵ional, limbajele se 칥mpart 칥n dou캒 mari categorii:"

#: src/memory-management/approaches.md
msgid "Full control via manual memory management: C, C++, Pascal, ..."
msgstr "Control total prin gestionarea manual캒 a memoriei: C, C++, Pascal, ..."

#: src/memory-management/approaches.md
#, fuzzy
msgid "Programmer decides when to allocate or free heap memory."
msgstr "Programatorul decide c칙nd s캒 aloce sau s캒 elibereze memoria heap."

#: src/memory-management/approaches.md
#, fuzzy
msgid ""
"Programmer must determine whether a pointer still points to valid memory."
msgstr ""
"Programatorul trebuie s캒 determine dac캒 un pointer mai indic캒 o memorie "
"valid캒."

#: src/memory-management/approaches.md
#, fuzzy
msgid "Studies show, programmers make mistakes."
msgstr "Studiile arat캒 c캒 programatorii fac gre탳eli."

#: src/memory-management/approaches.md
msgid ""
"Full safety via automatic memory management at runtime: Java, Python, Go, "
"Haskell, ..."
msgstr ""
"Siguran탵캒 total캒 prin gestionarea automat캒 a memoriei 칥n timpul execu탵iei: "
"Java, Python, Go, Haskell, ..."

#: src/memory-management/approaches.md
#, fuzzy
msgid ""
"A runtime system ensures that memory is not freed until it can no longer be "
"referenced."
msgstr ""
"Un sistem de execu탵ie se asigur캒 c캒 memoria nu este eliberat캒 p칙n캒 c칙nd nu "
"mai poate fi utilizat캒 ca referin탵캒."

#: src/memory-management/approaches.md
#, fuzzy
msgid ""
"Typically implemented with reference counting, garbage collection, or RAII."
msgstr ""
"De obicei, se implementeaz캒 cu num캒rarea referin탵elor, colectarea gunoiului "
"sau RAII."

#: src/memory-management/approaches.md
msgid "Rust offers a new mix:"
msgstr "Rust ofer캒 un nou캒 abordare:"

#: src/memory-management/approaches.md
msgid ""
"Full control _and_ safety via compile time enforcement of correct memory "
"management."
msgstr ""
"Control total _탳i_ siguran탵캒 prin aplicarea 칥n timpul compil캒rii a "
"gestion캒rii corecte a memoriei."

#: src/memory-management/approaches.md
msgid "It does this with an explicit ownership concept."
msgstr ""
"Acest lucru se realizeaz캒 cu ajutorul unui concept explicit de posesie."

#: src/memory-management/approaches.md
#, fuzzy
msgid ""
"This slide is intended to help students coming from other languages to put "
"Rust in context."
msgstr ""
"Aceast캒 diapozitiv캒 este menit캒 s캒-i ajute pe studen탵ii care vin din alte "
"limbi s캒 pun캒 Rust 칥n context."

#: src/memory-management/approaches.md
#, fuzzy
msgid ""
"C must manage heap manually with `malloc` and `free`. Common errors include "
"forgetting to call `free`, calling it multiple times for the same pointer, "
"or dereferencing a pointer after the memory it points to has been freed."
msgstr ""
"C trebuie s캒 gestioneze manual heap cu `malloc` 탳i `free`. Printre erorile "
"frecvente se num캒r캒 uitarea apel캒rii lui `free`, apelarea de mai multe ori "
"pentru acela탳i pointer sau dereferen탵ierea unui pointer dup캒 ce memoria la "
"care acesta indic캒 a fost eliberat캒."

#: src/memory-management/approaches.md
#, fuzzy
msgid ""
"C++ has tools like smart pointers (`unique_ptr`, `shared_ptr`) that take "
"advantage of language guarantees about calling destructors to ensure memory "
"is freed when a function returns. It is still quite easy to mis-use these "
"tools and create similar bugs to C."
msgstr ""
"C++ dispune de instrumente precum pointeri inteligen탵i (`unique_ptr`, "
"`shared_ptr`) care profit캒 de garan탵iile limbajului privind apelarea "
"destructoriilor pentru a se asigura c캒 memoria este eliberat캒 atunci c칙nd o "
"func탵ie se 칥ntoarce. Este 칥nc캒 destul de u탳or s캒 se utilizeze 칥n mod gre탳it "
"aceste instrumente 탳i s캒 se creeze erori similare cu cele din C."

#: src/memory-management/approaches.md
#, fuzzy
msgid ""
"Java, Go, and Python rely on the garbage collector to identify memory that "
"is no longer reachable and discard it. This guarantees that any pointer can "
"be dereferenced, eliminating use-after-free and other classes of bugs. But, "
"GC has a runtime cost and is difficult to tune properly."
msgstr ""
"Java, Go 탳i Python se bazeaz캒 pe colectorul de gunoi pentru a identifica "
"memoria care nu mai este accesibil캒 탳i pentru a o elimina. Acest lucru "
"garanteaz캒 faptul c캒 orice pointer poate fi dereferen탵iat, elimin칙nd astfel "
"utilizarea dup캒 liber 탳i alte clase de erori. 칉ns캒, GC are un cost 칥n timpul "
"execu탵iei 탳i este dificil de reglat corespunz캒tor."

#: src/memory-management/approaches.md
#, fuzzy
msgid ""
"Rust's ownership and borrowing model can, in many cases, get the performance "
"of C, with alloc and free operations precisely where they are required -- "
"zero cost. It also provides tools similar to C++'s smart pointers. When "
"required, other options such as reference counting are available, and there "
"are even third-party crates available to support runtime garbage collection "
"(not covered in this class)."
msgstr ""
"Modelul de proprietate 탳i 칥mprumut al Rust poate, 칥n multe cazuri, s캒 ob탵in캒 "
"performan탵a lui C, cu aloc캒ri 탳i opera탵iuni gratuite exact acolo unde sunt "
"necesare - cost zero. De asemenea, acesta ofer캒 instrumente similare cu "
"indicatoarele inteligente din C++. Atunci c칙nd este necesar, sunt "
"disponibile 탳i alte op탵iuni, cum ar fi num캒rarea referin탵elor, 탳i exist캒 "
"chiar 탳i cratere de la ter탵i disponibile pentru a sprijini colectarea "
"gunoiului 칥n timpul execu탵iei (nu sunt acoperite 칥n acest curs)."

#: src/memory-management/ownership.md
#, fuzzy
msgid ""
"All variable bindings have a _scope_ where they are valid and it is an error "
"to use a variable outside its scope:"
msgstr ""
"Toate leg캒turile de variabile au un _scop_ 칥n care sunt valabile 탳i este o "
"eroare s캒 folose탳ti o variabil캒 칥n afara domeniului s캒u de aplicare:"

#: src/memory-management/ownership.md
#, fuzzy
msgid ""
"We say that the variable _owns_ the value. Every Rust value has precisely "
"one owner at all times."
msgstr "Spunem c캒 variabila _de탵ine_ valoarea."

#: src/memory-management/ownership.md
#, fuzzy
msgid ""
"At the end of the scope, the variable is _dropped_ and the data is freed. A "
"destructor can run here to free up resources."
msgstr ""
"La sf칙r탳itul domeniului de aplicare, variabila este \"eliminat캒\", iar "
"datele sunt eliberate."

#: src/memory-management/ownership.md
#, fuzzy
msgid ""
"Students familiar with garbage-collection implementations will know that a "
"garbage collector starts with a set of \"roots\" to find all reachable "
"memory. Rust's \"single owner\" principle is a similar idea."
msgstr ""
"Studen탵ii familiariza탵i cu implement캒rile de colectare a gunoiului 탳tiu c캒 "
"un colector de gunoi 칥ncepe cu un set de \"r캒d캒cini\" pentru a g캒si toat캒 "
"memoria accesibil캒. Principiul \"proprietarului unic\" din Rust este o idee "
"similar캒."

#: src/memory-management/move.md
msgid "An assignment will transfer _ownership_ between variables:"
msgstr "O atribuire va transfera _posesia_ 칥ntre variabile:"

#: src/memory-management/move.md
#, fuzzy
msgid "\"Hello!\""
msgstr "\"hello\""

#: src/memory-management/move.md
#, fuzzy
msgid "// println!(\"s1: {s1}\");\n"
msgstr "// println!(\"s1: {s1}\");\n"

#: src/memory-management/move.md
msgid "The assignment of `s1` to `s2` transfers ownership."
msgstr "Atribuirea lui `s1` la `s2` transfer캒 posesiunea."

#: src/memory-management/move.md
msgid "When `s1` goes out of scope, nothing happens: it does not own anything."
msgstr ""
"C칙nd `s1` iese din domeniul de aplicare, nu se 칥nt칙mpl캒 nimic: nu posed캒 "
"nimic."

#: src/memory-management/move.md
msgid "When `s2` goes out of scope, the string data is freed."
msgstr ""
"Atunci c칙nd `s2` iese din domeniul de aplicare, datele 탳irului de caractere "
"sunt eliberate."

#: src/memory-management/move.md
msgid "Before move to `s2`:"
msgstr "칉nainte de mutarea 칥n `s2`:"

#: src/memory-management/move.md
msgid "After move to `s2`:"
msgstr "Dup캒 mutarea 칥n `s2`:"

#: src/memory-management/move.md
#, fuzzy
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - -.\n"
":                           :     :                                     :\n"
":    s1 \"(inaccessible)\"    :     :                                     :\n"
":   +-----------+-------+   :     :   +----+----+----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| H  | e  | l  | l  | o  | !  |   :\n"
":   | len       |     6 |   :  |  :   +----+----+----+----+----+----+   :\n"
":   | capacity  |     6 |   :  |  :                                     :\n"
":   +-----------+-------+   :  |  :                                     :\n"
":                           :  |  `- - - - - - - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     6 |   :\n"
":   | capacity  |     6 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stiva                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"(inaccesibl)\"    :     :                           :\n"
":   +덕덕덕덕+덕덕+   :     :   +덕+덕+덕+덕+   :\n"
":   | ptr       |   o++++>| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :  |  :   +덕+덕+덕+덕+   :\n"
":   | capacity  |     4 |   :  |  :                           :\n"
":   +덕덕덕덕+덕덕+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +덕덕덕덕+덕덕+   :  |\n"
":   | ptr       |   o++'\n"
":   | len       |     4 |   :\n"
":   | capacity  |     4 |   :\n"
":   +덕덕덕덕+덕덕+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/memory-management/move.md
msgid ""
"When you pass a value to a function, the value is assigned to the function "
"parameter. This transfers ownership:"
msgstr ""
"Atunci c칙nd transmite탵i o valoare unei func탵ii, valoarea este atribuit캒 "
"parametrului func탵iei. Acest lucru transfer캒 posesia:"

#: src/memory-management/move.md src/memory-management/clone.md
#, fuzzy
msgid "\"Hello {name}\""
msgstr "\"Bun캒 ziua {name}\""

#: src/memory-management/move.md src/memory-management/clone.md
#: src/android/interoperability/java.md
#, fuzzy
msgid "\"Alice\""
msgstr "Felii"

#: src/memory-management/move.md
#, fuzzy
msgid "// say_hello(name);\n"
msgstr "// say_hello(name);\n"

#: src/memory-management/move.md
msgid ""
"Mention that this is the opposite of the defaults in C++, which copies by "
"value unless you use `std::move` (and the move constructor is defined!)."
msgstr ""
"Men탵iona탵i c캒 acest lucru este opusul valorilor implicite din C++, care "
"copiaz캒 prin valoare, cu excep탵ia cazului 칥n care folosi탵i `std::move` (탳i "
"constructorul move este definit!)."

#: src/memory-management/move.md
msgid ""
"It is only the ownership that moves. Whether any machine code is generated "
"to manipulate the data itself is a matter of optimization, and such copies "
"are aggressively optimized away."
msgstr ""
"Doar posesia este cea care se schimb캒. Generarea codului ma탳in캒 pentru a "
"manipula datele 칥n sine este o chestiune de optimizare, iar astfel de copii "
"sunt optimizate 칥n mod agresiv."

#: src/memory-management/move.md
msgid ""
"Simple values (such as integers) can be marked `Copy` (see later slides)."
msgstr ""
"Valorile simple (cum ar fi numerele 칥ntregi) pot fi marcate cu `Copy` (a se "
"vedea slide-urile ulterioare)."

#: src/memory-management/move.md
msgid "In Rust, clones are explicit (by using `clone`)."
msgstr "칉n Rust, clonele sunt explicite (prin utilizarea lui `clone`)."

#: src/memory-management/move.md
#, fuzzy
msgid "In the `say_hello` example:"
msgstr "칉n exemplul `say_hello`:"

#: src/memory-management/move.md
msgid ""
"With the first call to `say_hello`, `main` gives up ownership of `name`. "
"Afterwards, `name` cannot be used anymore within `main`."
msgstr ""
"Odat캒 cu primul apel la `say_hello`, `main` nu mai de탵ine `name` 탳i, "
"ulterior, nu 칥l mai poate utiliza."

#: src/memory-management/move.md
msgid ""
"The heap memory allocated for `name` will be freed at the end of the "
"`say_hello` function."
msgstr ""
"Memoria heap alocat캒 pentru `name` va fi eliberat캒 la sf칙r탳itul func탵iei "
"`say_hello`."

#: src/memory-management/move.md
#, fuzzy
msgid ""
"`main` can retain ownership if it passes `name` as a reference (`&name`) and "
"if `say_hello` accepts a reference as a parameter."
msgstr ""
"`main` poate p캒stra proprietatea dac캒 transmite `name` ca referin탵캒 "
"(`&name`) 탳i dac캒 `say_hello` accept캒 o referin탵캒 ca parametru."

#: src/memory-management/move.md
#, fuzzy
msgid ""
"Alternatively, `main` can pass a clone of `name` in the first call (`name."
"clone()`)."
msgstr ""
"Alternativ, `main` poate transmite o clon캒 a lui `name` la primul apel "
"(`name.clone()`)."

#: src/memory-management/move.md
#, fuzzy
msgid ""
"Rust makes it harder than C++ to inadvertently create copies by making move "
"semantics the default, and by forcing programmers to make clones explicit."
msgstr ""
"Rust face mai dificil캒 dec칙t C++ crearea de copii din gre탳eal캒, f캒c칙nd ca "
"semantica de mutare s캒 fie cea implicit캒 탳i oblig칙nd programatorii s캒 fac캒 "
"clonele explicite."

#: src/memory-management/move.md
msgid "Defensive Copies in Modern C++"
msgstr "Copii defensive 칥n C++ modern"

#: src/memory-management/move.md
msgid "Modern C++ solves this differently:"
msgstr "C++ modern rezolv캒 acest lucru 칥n mod diferit:"

#: src/memory-management/move.md
#, fuzzy
msgid "\"Cpp\""
msgstr "\"Cpp\""

#: src/memory-management/move.md
#, fuzzy
msgid "// Duplicate the data in s1.\n"
msgstr "// Duplicarea datelor din s1.\n"

#: src/memory-management/move.md
msgid ""
"The heap data from `s1` is duplicated and `s2` gets its own independent copy."
msgstr ""
"Datele din heap de la `s1` sunt duplicate, iar `s2` prime탳te propria copie "
"independent캒."

#: src/memory-management/move.md
msgid "When `s1` and `s2` go out of scope, they each free their own memory."
msgstr ""
"Atunci c칙nd `s1` 탳i `s2` ies din domeniul de aplicare, fiecare 칥탳i "
"elibereaz캒 propria memorie."

#: src/memory-management/move.md
#, fuzzy
msgid "Before copy-assignment:"
msgstr "칉nainte de atribuirea copiilor:"

#: src/memory-management/move.md
#, fuzzy
msgid "After copy-assignment:"
msgstr "Dup캒 atribuirea copiilor:"

#: src/memory-management/move.md
msgid ""
"C++ has made a slightly different choice than Rust. Because `=` copies data, "
"the string data has to be cloned. Otherwise we would get a double-free when "
"either string goes out of scope."
msgstr ""
"칉n C++ a fost f캒cut캒 o alegere u탳or diferit캒 fa탵캒 de Rust. Deoarece `=` "
"copiaz캒 date, datele 탳irului de caractere trebuie clonate. 칉n caz contrar, "
"am ob탵ine o dubl캒 eliberare atunci c칙nd oricare dintre 탳iruri iese din "
"domeniu."

#: src/memory-management/move.md
msgid ""
"C++ also has [`std::move`](https://en.cppreference.com/w/cpp/utility/move), "
"which is used to indicate when a value may be moved from. If the example had "
"been `s2 = std::move(s1)`, no heap allocation would take place. After the "
"move, `s1` would be in a valid but unspecified state. Unlike Rust, the "
"programmer is allowed to keep using `s1`."
msgstr ""
"C++ are, de asemenea, [`std::move`](https://en.cppreference.com/w/cpp/"
"utility/move), care este utilizat pentru a indica c칙nd o valoare poate fi "
"mutat캒. Dac캒 exemplul ar fi fost `s2 = std::move(s1)`, nu ar fi avut loc "
"nicio alocare de heap. Dup캒 mutare, `s1` ar fi 칥ntr-o stare valid캒, dar "
"nespecificat캒. Spre deosebire de Rust, programatorului i se permite s캒 "
"continue s캒 foloseasc캒 `s1`."

#: src/memory-management/move.md
msgid ""
"Unlike Rust, `=` in C++ can run arbitrary code as determined by the type "
"which is being copied or moved."
msgstr ""
"Spre deosebire de Rust, `=` 칥n C++ poate rula cod arbitrar 칥n func탵ie de "
"tipul care este copiat sau mutat."

#: src/memory-management/clone.md
msgid "Clone"
msgstr "Clonare"

#: src/memory-management/clone.md
#, fuzzy
msgid ""
"Sometimes you _want_ to make a copy of a value. The `Clone` trait "
"accomplishes this."
msgstr ""
"Uneori, dori탵i s캒 face탵i o copie a unei valori. Caracteristica `Clone` "
"realizeaz캒 acest lucru."

#: src/memory-management/clone.md
#, fuzzy
msgid ""
"The idea of `Clone` is to make it easy to spot where heap allocations are "
"occurring. Look for `.clone()` and a few others like `vec!` or `Box::new`."
msgstr ""
"Ideea lui `Clone` este de a face mai u탳or de observat unde au loc aloc캒ri de "
"heap. C캒uta탵i `.clone()` 탳i alte c칙teva ca `Vec::new` sau `Box::new`."

#: src/memory-management/clone.md
#, fuzzy
msgid ""
"It's common to \"clone your way out\" of problems with the borrow checker, "
"and return later to try to optimize those clones away."
msgstr ""
"Este obi탳nuit s캒 \"clonezi\" problemele cu verificatorul de 칥mprumuturi 탳i "
"s캒 revii mai t칙rziu pentru a 칥ncerca s캒 optimizezi acele clone."

#: src/memory-management/clone.md
#, fuzzy
msgid ""
"`clone` generally performs a deep copy of the value, meaning that if you e."
"g. clone an array, all of the elements of the array are cloned as well."
msgstr ""
"`clone` efectueaz캒 칥n general o copie profund캒 a valorii, ceea ce 칥nseamn캒 "
"c캒, dac캒, de exemplu, clonezi un array, toate elementele array-ului sunt "
"clonate 탳i ele."

#: src/memory-management/clone.md
#, fuzzy
msgid ""
"The behavior for `clone` is user-defined, so it can perform custom cloning "
"logic if needed."
msgstr ""
"Comportamentul pentru `clone` este definit de utilizator, astfel 칥nc칙t "
"acesta poate efectua o logic캒 de clonare personalizat캒, dac캒 este necesar."

#: src/memory-management/copy-types.md
#, fuzzy
msgid ""
"While move semantics are the default, certain types are copied by default:"
msgstr ""
"칉n timp ce semantica de mutare este cea implicit캒, anumite tipuri sunt "
"copiate 칥n mod implicit:"

#: src/memory-management/copy-types.md
#, fuzzy
msgid "These types implement the `Copy` trait."
msgstr "Aceste tipuri implementeaz캒 tr캒s캒tura `Copy`."

#: src/memory-management/copy-types.md
#, fuzzy
msgid "You can opt-in your own types to use copy semantics:"
msgstr ""
"Pute탵i opta pentru ca propriile tipuri s캒 utilizeze semantica de copiere:"

#: src/memory-management/copy-types.md
#, fuzzy
msgid "After the assignment, both `p1` and `p2` own their own data."
msgstr "Dup캒 atribuire, at칙t `p1` c칙t 탳i `p2` de탵in propriile date."

#: src/memory-management/copy-types.md
#, fuzzy
msgid "We can also use `p1.clone()` to explicitly copy the data."
msgstr "De asemenea, putem folosi `p1.clone()` pentru a copia explicit datele."

#: src/memory-management/copy-types.md
#, fuzzy
msgid "Copying and cloning are not the same thing:"
msgstr "Copierea 탳i clonarea nu sunt acela탳i lucru:"

#: src/memory-management/copy-types.md
#, fuzzy
msgid ""
"Copying refers to bitwise copies of memory regions and does not work on "
"arbitrary objects."
msgstr ""
"Copierea se refer캒 la copiile pe bi탵i ale regiunilor de memorie 탳i nu "
"func탵ioneaz캒 pe obiecte arbitrare."

#: src/memory-management/copy-types.md
#, fuzzy
msgid ""
"Copying does not allow for custom logic (unlike copy constructors in C++)."
msgstr ""
"Copierea nu permite o logic캒 personalizat캒 (spre deosebire de constructorii "
"de copiere din C++)."

#: src/memory-management/copy-types.md
#, fuzzy
msgid ""
"Cloning is a more general operation and also allows for custom behavior by "
"implementing the `Clone` trait."
msgstr ""
"Clonarea este o opera탵iune mai general캒 탳i permite, de asemenea, un "
"comportament personalizat prin implementarea tr캒s캒turii `Clone`."

#: src/memory-management/copy-types.md
#, fuzzy
msgid "Copying does not work on types that implement the `Drop` trait."
msgstr ""
"Copierea nu func탵ioneaz캒 pe tipurile care implementeaz캒 tr캒s캒tura `Drop`."

#: src/memory-management/copy-types.md
#, fuzzy
msgid "In the above example, try the following:"
msgstr "칉n exemplul de mai sus, 칥ncerca탵i urm캒toarele:"

#: src/memory-management/copy-types.md
#, fuzzy
msgid ""
"Add a `String` field to `struct Point`. It will not compile because `String` "
"is not a `Copy` type."
msgstr ""
"Ad캒uga탵i un c칙mp `String` la `struct Point`. Nu se va compila deoarece "
"`String` nu este un tip `Copy`."

#: src/memory-management/copy-types.md
#, fuzzy
msgid ""
"Remove `Copy` from the `derive` attribute. The compiler error is now in the "
"`println!` for `p1`."
msgstr ""
"Elimin캒 `Copy` din atributul `derive`. Eroarea de compilare se afl캒 acum 칥n "
"`println!` pentru `p1`."

#: src/memory-management/copy-types.md
#, fuzzy
msgid "Show that it works if you clone `p1` instead."
msgstr "Ar캒ta탵i c캒 func탵ioneaz캒 dac캒 clona탵i `p1` 칥n locul lui."

#: src/memory-management/drop.md
#, fuzzy
msgid "The `Drop` Trait"
msgstr "Tr캒s캒tura `Drop` (c캒dere)"

#: src/memory-management/drop.md
#, fuzzy
msgid ""
"Values which implement [`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop."
"html) can specify code to run when they go out of scope:"
msgstr ""
"Valorile care implementeaz캒 [`Drop`](https://doc.rust-lang.org/std/ops/trait."
"Drop.html) pot specifica codul care trebuie executat atunci c칙nd ies din "
"domeniul de aplicare:"

#: src/memory-management/drop.md
#, fuzzy
msgid "\"Dropping {}\""
msgstr "\"Dropping {}\""

#: src/memory-management/drop.md src/concurrency/sync-exercises/link-checker.md
#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "\"a\""
msgstr "\"a\""

#: src/memory-management/drop.md src/android/testing/googletest.md
#, fuzzy
msgid "\"b\""
msgstr "\"b\""

#: src/memory-management/drop.md
#, fuzzy
msgid "\"c\""
msgstr "\"c\""

#: src/memory-management/drop.md
#, fuzzy
msgid "\"d\""
msgstr "'d'"

#: src/memory-management/drop.md
#, fuzzy
msgid "\"Exiting block B\""
msgstr "\"Ie탳irea din blocul B\""

#: src/memory-management/drop.md
#, fuzzy
msgid "\"Exiting block A\""
msgstr "\"Ie탳irea din blocul A\""

#: src/memory-management/drop.md
#, fuzzy
msgid "\"Exiting main\""
msgstr "\"Ie탳ire principal캒\""

#: src/memory-management/drop.md
#, fuzzy
msgid "Note that `std::mem::drop` is not the same as `std::ops::Drop::drop`."
msgstr ""
"Re탵ine탵i c캒 `std::mem::drop` nu este acela탳i lucru cu `std::ops::Drop::drop`."

#: src/memory-management/drop.md
#, fuzzy
msgid "Values are automatically dropped when they go out of scope."
msgstr ""
"Valorile sunt eliminate automat atunci c칙nd ies din domeniul de aplicare."

#: src/memory-management/drop.md
#, fuzzy
msgid ""
"When a value is dropped, if it implements `std::ops::Drop` then its `Drop::"
"drop` implementation will be called."
msgstr ""
"Atunci c칙nd o valoare este eliminat캒, dac캒 implementeaz캒 `std::ops::Drop`, "
"atunci va fi apelat캒 implementarea `Drop::drop` a acesteia."

#: src/memory-management/drop.md
#, fuzzy
msgid ""
"All its fields will then be dropped too, whether or not it implements `Drop`."
msgstr ""
"Toate c칙mpurile sale vor fi apoi eliminate, indiferent dac캒 implementeaz캒 "
"sau nu `Drop`."

#: src/memory-management/drop.md
#, fuzzy
msgid ""
"`std::mem::drop` is just an empty function that takes any value. The "
"significance is that it takes ownership of the value, so at the end of its "
"scope it gets dropped. This makes it a convenient way to explicitly drop "
"values earlier than they would otherwise go out of scope."
msgstr ""
"`std::mem::drop` este doar o func탵ie goal캒 care accept캒 orice valoare. "
"Semnifica탵ia este c캒 preia proprietatea asupra valorii, astfel 칥nc칙t la "
"sf칙r탳itul domeniului s캒u de aplicare aceasta este eliminat캒. Acest lucru o "
"face o modalitate convenabil캒 de a renun탵a 칥n mod explicit la valori mai "
"devreme dec칙t ar fi ie탳it altfel din domeniul de aplicare."

#: src/memory-management/drop.md
#, fuzzy
msgid ""
"This can be useful for objects that do some work on `drop`: releasing locks, "
"closing files, etc."
msgstr ""
"Acest lucru poate fi util pentru obiectele care efectueaz캒 anumite "
"activit캒탵i la `drop`: eliberarea de blocaje, 칥nchiderea fi탳ierelor etc."

#: src/memory-management/drop.md
#, fuzzy
msgid "Why doesn't `Drop::drop` take `self`?"
msgstr "De ce `Drop::drop` nu ia `self`?"

#: src/memory-management/drop.md
#, fuzzy
msgid ""
"Short-answer: If it did, `std::mem::drop` would be called at the end of the "
"block, resulting in another call to `Drop::drop`, and a stack overflow!"
msgstr ""
"R캒spuns scurt: Dac캒 ar fi f캒cut-o, `std::mem::drop` ar fi fost apelat la "
"sf칙r탳itul blocului, rezult칙nd un alt apel la `Drop::drop` 탳i o dep캒탳ire a "
"stivei!"

#: src/memory-management/drop.md
#, fuzzy
msgid "Try replacing `drop(a)` with `a.drop()`."
msgstr "칉ncerca탵i s캒 칥nlocui탵i `drop(a)` cu `a.drop()`."

#: src/memory-management/exercise.md
#, fuzzy
msgid ""
"In this example, we will implement a complex data type that owns all of its "
"data. We will use the \"builder pattern\" to support building a new value "
"piece-by-piece, using convenience functions."
msgstr ""
"칉n acest exemplu, vom implementa un tip de date complex care de탵ine toate "
"datele sale. Vom utiliza \"modelul de constructor\" pentru a sprijini "
"construirea unei noi valori bucat캒 cu bucat캒, utiliz칙nd func탵ii de confort."

#: src/memory-management/exercise.md
#, fuzzy
msgid "Fill in the missing pieces."
msgstr "Completa탵i piesele lips캒."

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "/// A representation of a software package.\n"
msgstr "/// O reprezentare a unui pachet software.\n"

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid ""
"/// Return a representation of this package as a dependency, for use in\n"
"    /// building other packages.\n"
msgstr ""
"/// Returneaz캒 o reprezentare a acestui pachet ca dependen탵캒, pentru a fi "
"utilizat캒 칥n\n"
"    /// construirea altor pachete.\n"

#: src/memory-management/exercise.md
#, fuzzy
msgid "\"1\""
msgstr "`dbg_size!(bool)`: dimensiune 1 octet, aliniere: 1 octet,"

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid ""
"/// A builder for a Package. Use `build()` to create the `Package` itself.\n"
msgstr ""
"/// Un constructor pentru un pachet. Utiliza탵i `build()` pentru a crea "
"`Pachet` 칥nsu탳i.\n"

#: src/memory-management/exercise.md
#, fuzzy
msgid "\"2\""
msgstr ""
"Acela탳i lucru este valabil 탳i pentru ultimul indice, astfel 칥nc칙t `&a[2..a."
"len()]` 탳i `&a[2..]` sunt identice."

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "/// Set the package version.\n"
msgstr "/// Seteaz캒 versiunea pachetului.\n"

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "/// Set the package authors.\n"
msgstr "/// Seteaz캒 autorii pachetului.\n"

#: src/memory-management/exercise.md
#, fuzzy
msgid "\"3\""
msgstr "Codifica탵i ambele func탵ii pentru a opera pe matrici 3 칑 3."

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "/// Add an additional dependency.\n"
msgstr "/// Ad캒uga탵i o dependen탵캒 suplimentar캒.\n"

#: src/memory-management/exercise.md
#, fuzzy
msgid "\"4\""
msgstr "\"4\""

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "/// Set the language. If not set, language defaults to None.\n"
msgstr "/// Seta탵i limba. Dac캒 nu este setat캒, limba este implicit캒 la None.\n"

#: src/memory-management/exercise.md
#, fuzzy
msgid "\"5\""
msgstr "[Introducere](./welcome-day-1.md) (5 minute)"

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "\"base64\""
msgstr "\"base64\""

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "\"0.13\""
msgstr "\"0.13\""

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "\"base64: {base64:?}\""
msgstr "\"base64: {base64:?}\""

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "\"log\""
msgstr "\"log\""

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "\"0.4\""
msgstr "\"0.4\""

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "\"log: {log:?}\""
msgstr "\"log: {log:?}\""

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "\"serde\""
msgstr "\"serde\""

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "\"djmitche\""
msgstr "\"djmitche\""

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "\"4.0\""
msgstr "\"4.0\""

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "\"serde: {serde:?}\""
msgstr "\"serde: {serde:?}\""

#: src/memory-management/solution.md
#, fuzzy
msgid "\"0.1\""
msgstr "\"0.1\""

#: src/smart-pointers.md
#, fuzzy
msgid "[Box"
msgstr "Cutie (box)"

#: src/smart-pointers.md
#, fuzzy
msgid "](./smart-pointers/box.md) (10 minutes)"
msgstr "](./smart-pointers/box.md) (10 minute)"

#: src/smart-pointers.md
#, fuzzy
msgid "[Rc](./smart-pointers/rc.md) (5 minutes)"
msgstr "[Rc](./smart-pointers/rc.md) (5 minute)"

#: src/smart-pointers.md
#, fuzzy
msgid "[Trait Objects](./smart-pointers/trait-objects.md) (10 minutes)"
msgstr ""
"[Obiecte de tr캒s캒turi](./methods-and-traits/trait-objects.md) (10 minute)"

#: src/smart-pointers.md
#, fuzzy
msgid "[Exercise: Binary Tree](./smart-pointers/exercise.md) (30 minutes)"
msgstr "[Exerci탵iu: Arbore binar](./smart-pointers/exercise.md) (30 minute)"

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"[`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) is an owned "
"pointer to data on the heap:"
msgstr ""
"[`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) este un pointer "
"de탵inut c캒tre datele de pe heap:"

#: src/smart-pointers/box.md
#, fuzzy
msgid "\"five: {}\""
msgstr "\"cinci: {}\""

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"`Box<T>` implements `Deref<Target = T>`, which means that you can [call "
"methods from `T` directly on a `Box<T>`](https://doc.rust-lang.org/std/ops/"
"trait.Deref.html#more-on-deref-coercion)."
msgstr ""
"`Box<T>` implementeaz캒 `Deref<Target = T>`, ceea ce 칥nseamn캒 c캒 pute탵i "
"[apela metode din `T` direct pe un `Box<T>`](https://doc.rust-lang.org/std/"
"ops/trait.Deref.html#more-on-deref-coercion)."

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"Recursive data types or data types with dynamic sizes need to use a `Box`:"
msgstr ""
"Tipurile de date recursive sau tipurile de date cu dimensiuni dinamice "
"trebuie s캒 utilizeze un `Box`:"

#: src/smart-pointers/box.md
#, fuzzy
msgid "/// A non-empty list: first element and the rest of the list.\n"
msgstr "/// O list캒 nevid캒: primul element 탳i restul listei.\n"

#: src/smart-pointers/box.md
#, fuzzy
msgid "/// An empty list.\n"
msgstr "/// O list캒 goal캒.\n"

#: src/smart-pointers/box.md
#, fuzzy
msgid "\"{list:?}\""
msgstr ""
"[Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial."
"github.io/too-many-lists/): explorarea 칥n profunzime a regulilor de "
"gestionare a memoriei din Rust, prin implementarea c칙torva tipuri diferite "
"de structuri de liste."

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - - - .     .- - - - - - - - - - - - - - - - - - - - "
"- - - - -.\n"
":                            :     :                                                 :\n"
":    "
"list                    :     :                                                 :\n"
":   +---------+----+----+    :     :    +---------+----+----+    +------+----"
"+----+  :\n"
":   | Element | 1  | o--+----+-----+--->| Element | 2  | o--+--->| Nil  | // "
"| // |  :\n"
":   +---------+----+----+    :     :    +---------+----+----+    +------+----"
"+----+  :\n"
":                            :     :                                                 :\n"
":                            :     :                                                 :\n"
"'- - - - - - - - - - - - - - '     '- - - - - - - - - - - - - - - - - - - - "
"- - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stiva Heap\n"
".- - - - - - - - - - - - -. .- - - - - - - - - - - - - - - - - - - - - - - "
"-.\n"
": : : :\n"
": list캒 : : : :\n"
":   +------+----+----+ : : +------+----+----+ +------+----+----+ :\n"
":   | Cons | 1 | o--+----+-----+--->| Cons | 2 | o--++--->| Nil | // | // // "
"| :\n"
":   +------+----+----+ : : +------+----+----+ +------+----+----+ :\n"
": : : :\n"
": : : :\n"
"'- - - - - - - - - - - - -' '- - - - - - - - - - - - - - - - - - - - - - - "
"-'\n"
"```"

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"`Box` is like `std::unique_ptr` in C++, except that it's guaranteed to be "
"not null."
msgstr ""
"`Box` este ca 탳i `std::unique_ptr` 칥n C++, cu excep탵ia faptului c캒 este "
"garantat a nu fi nul."

#: src/smart-pointers/box.md
#, fuzzy
msgid "A `Box` can be useful when you:"
msgstr "Un `Box` poate fi util atunci c칙nd:"

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"have a type whose size that can't be known at compile time, but the Rust "
"compiler wants to know an exact size."
msgstr ""
"au un tip a c캒rui dimensiune nu poate fi cunoscut캒 la compilare, dar "
"compilatorul Rust dore탳te s캒 탳tie o dimensiune exact캒."

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"want to transfer ownership of a large amount of data. To avoid copying large "
"amounts of data on the stack, instead store the data on the heap in a `Box` "
"so only the pointer is moved."
msgstr ""
"dori탵i s캒 transfera탵i proprietatea asupra unei cantit캒탵i mari de date. "
"Pentru a evita copierea unor cantit캒탵i mari de date pe stiv캒, stoca탵i 칥n "
"schimb datele pe heap 칥ntr-un `Box`, astfel 칥nc칙t s캒 fie mutat doar "
"pointerul."

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"If `Box` was not used and we attempted to embed a `List` directly into the "
"`List`, the compiler would not be able to compute a fixed size for the "
"struct in memory (the `List` would be of infinite size)."
msgstr ""
"Dac캒 nu se folosea `Box` 탳i 칥ncercam s캒 칥ncorpor캒m o `List` direct 칥n "
"`List`, compilatorul nu ar fi calculat o dimensiune fix캒 a structurii 칥n "
"memorie (`List` ar fi avut o dimensiune infinit캒)."

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"`Box` solves this problem as it has the same size as a regular pointer and "
"just points at the next element of the `List` in the heap."
msgstr ""
"`Box` rezolv캒 aceast캒 problem캒, deoarece are aceea탳i dimensiune ca un "
"pointer obi탳nuit 탳i indic캒 doar urm캒torul element din `List` 칥n heap."

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"Remove the `Box` in the List definition and show the compiler error. We get "
"the message \"recursive without indirection\", because for data recursion, "
"we have to use indirection, a `Box` or reference of some kind, instead of "
"storing the value directly."
msgstr ""
"Elimina탵i `Box` din defini탵ia Listei 탳i afi탳a탵i eroarea de compilare. "
"\"Recursiv cu indirec탵ie\" este un indiciu c캒 poate dori탵i s캒 folosi탵i un "
"Box sau o referin탵캒 de un anumit tip, 칥n loc s캒 stoca탵i direct o valoare."

#: src/smart-pointers/box.md
msgid "Niche Optimization"
msgstr "Optimizari de ni탳캒"

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"Though `Box` looks like `std::unique_ptr` in C++, it cannot be empty/null. "
"This makes `Box` one of the types that allow the compiler to optimize "
"storage of some enums."
msgstr ""
"De탳i `Box` seam캒n캒 cu `std::unique_ptr` 칥n C++, acesta nu poate fi gol/null. "
"Acest lucru face ca `Box` s캒 fie unul dintre tipurile care permit "
"compilatorului s캒 optimizeze stocarea unor enumera탵ii."

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"For example, `Option<Box<T>>` has the same size, as just `Box<T>`, because "
"compiler uses NULL-value to discriminate variants instead of using explicit "
"tag ([\"Null Pointer Optimization\"](https://doc.rust-lang.org/std/option/"
"#representation)):"
msgstr ""
"De exemplu, `Op탵iune&lt;Box<T>&gt;` are aceea탳i dimensiune ca 탳i `Box<T>`, "
"deoarece compilatorul utilizeaz캒 valoarea NULL pentru a discrimina "
"variantele 칥n loc s캒 utilizeze o etichet캒 explicit캒 ([\"Optimizarea "
"pointerului nul\"](https://doc.rust-lang.org/std/option/#representation)):"

#: src/smart-pointers/box.md
#, fuzzy
msgid "\"Just box\""
msgstr "\"Just box\""

#: src/smart-pointers/box.md
#, fuzzy
msgid "\"Optional box\""
msgstr "Op탵iune"

#: src/smart-pointers/box.md
#, fuzzy
msgid "\"Size of just_box: {}\""
msgstr "\"Dimensiunea just_box: {}\""

#: src/smart-pointers/box.md
#, fuzzy
msgid "\"Size of optional_box: {}\""
msgstr "\"Dimensiunea cutiei op탵ionale_box: {}\""

#: src/smart-pointers/box.md
#, fuzzy
msgid "\"Size of none: {}\""
msgstr "\"칥nainte: {a}\""

#: src/smart-pointers/rc.md
#, fuzzy
msgid ""
"[`Rc`](https://doc.rust-lang.org/std/rc/struct.Rc.html) is a reference-"
"counted shared pointer. Use this when you need to refer to the same data "
"from multiple places:"
msgstr ""
"[`Rc`](https://doc.rust-lang.org/std/rc/struct.Rc.html) este un pointer "
"partajat cu num캒r캒toare de referin탵e. Folosi탵i-l atunci c칙nd trebuie s캒 "
"face탵i referire la acelea탳i date din mai multe locuri:"

#: src/smart-pointers/rc.md
#, fuzzy
msgid "\"a: {a}\""
msgstr "\"a: {a}\""

#: src/smart-pointers/rc.md
#, fuzzy
msgid "\"b: {b}\""
msgstr "\"b: {b}\""

#: src/smart-pointers/rc.md
#, fuzzy
msgid ""
"See [`Arc`](../concurrency/shared_state/arc.md) and [`Mutex`](https://doc."
"rust-lang.org/std/sync/struct.Mutex.html) if you are in a multi-threaded "
"context."
msgstr ""
"Consulta탵i [`Arc`](../concurrency/shared_state/arc.md) 탳i [`Mutex`](https://"
"doc.rust-lang.org/std/sync/struct.Mutex.html) dac캒 v캒 afla탵i 칥ntr-un context "
"cu mai multe fire."

#: src/smart-pointers/rc.md
#, fuzzy
msgid ""
"You can _downgrade_ a shared pointer into a [`Weak`](https://doc.rust-lang."
"org/std/rc/struct.Weak.html) pointer to create cycles that will get dropped."
msgstr ""
"Pute탵i transforma un pointer partajat 칥ntr-un pointer [`Weak`](https://doc."
"rust-lang.org/std/rc/struct.Weak.html) pentru a crea cicluri care vor fi "
"abandonate."

#: src/smart-pointers/rc.md
#, fuzzy
msgid ""
"`Rc`'s count ensures that its contained value is valid for as long as there "
"are references."
msgstr ""
"num캒r캒toarea lui `Rc` asigur캒 c캒 valoarea sa con탵inut캒 este valabil캒 at칙ta "
"timp c칙t exist캒 referin탵e."

#: src/smart-pointers/rc.md
#, fuzzy
msgid "`Rc` in Rust is like `std::shared_ptr` in C++."
msgstr "`Rc` 칥n Rust este ca `std::shared_ptr` 칥n C++."

#: src/smart-pointers/rc.md
#, fuzzy
msgid ""
"`Rc::clone` is cheap: it creates a pointer to the same allocation and "
"increases the reference count. Does not make a deep clone and can generally "
"be ignored when looking for performance issues in code."
msgstr ""
"`Rc::clone` este ieftin: creeaz캒 un pointer la aceea탳i alocare 탳i cre탳te "
"num캒rul de referin탵e. Nu realizeaz캒 o clon캒 profund캒 탳i poate fi 칥n general "
"ignorat캒 atunci c칙nd se caut캒 probleme de performan탵캒 칥n cod."

#: src/smart-pointers/rc.md
#, fuzzy
msgid ""
"`make_mut` actually clones the inner value if necessary (\"clone-on-write\") "
"and returns a mutable reference."
msgstr ""
"`make_mut` cloneaz캒 de fapt valoarea interioar캒 dac캒 este necesar (\"clone-"
"on-write\") 탳i returneaz캒 o referin탵캒 mutabil캒."

#: src/smart-pointers/rc.md
#, fuzzy
msgid "Use `Rc::strong_count` to check the reference count."
msgstr "Utiliza탵i `Rc::strong_count` pentru a verifica num캒rul de referin탵e."

#: src/smart-pointers/rc.md
#, fuzzy
msgid ""
"`Rc::downgrade` gives you a _weakly reference-counted_ object to create "
"cycles that will be dropped properly (likely in combination with `RefCell`)."
msgstr ""
"`Rc::downgrade` v캒 ofer캒 un obiect cu un num캒r slab de referin탵e pentru a "
"crea cicluri care vor fi abandonate 칥n mod corespunz캒tor (probabil 칥n "
"combina탵ie cu `RefCell`, pe slide-ul urm캒tor)."

#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid ""
"Trait objects allow for values of different types, for instance in a "
"collection:"
msgstr ""
"Obiectele de tr캒s캒turi permit valori de diferite tipuri, de exemplu 칥ntr-o "
"colec탵ie:"

#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid "\"Miau!\""
msgstr "\"Miau!\""

#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid "\"Hello, who are you? {}\""
msgstr "\"Bun캒 ziua, cine e탳ti? {}\""

#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid "Memory layout after allocating `pets`:"
msgstr "Dispunerea memoriei dup캒 alocarea `pets`:"

#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                           :     :                                             :\n"
":    \"pets: Vec<dyn Pet>\"   :     :   \"data: Cat\"         +----+----+----"
"+----+ :\n"
":   +-----------+-------+   :     :  +-------+-------+    | F  | i  | d  | "
"o  | :\n"
":   | ptr       |   o---+---+--.  :  | lives |     9 |    +----+----+----"
"+----+ :\n"
":   | len       |     2 |   :  |  :  +-------+-------+      "
"^                   :\n"
":   | capacity  |     2 |   :  |  :       ^                 "
"|                   :\n"
":   +-----------+-------+   :  |  :       |                 "
"'-------.           :\n"
":                           :  |  :       |               data:"
"\"Dog\"|           :\n"
":                           :  |  :       |              +-------+--|-------"
"+   :\n"
"`- - - - - - - - - - - - - -'  |  :   +---|-+-----+      | name  |  o, 4, 4 "
"|   :\n"
"                               `--+-->| o o | o o-|----->| age   |        5 "
"|   :\n"
"                                  :   +-|---+-|---+      +-------+----------"
"+   :\n"
"                                  :     |     "
"|                                 :\n"
"                                  `- - -| - - |- - - - - - - - - - - - - - - "
"- -'\n"
"                                        |     |\n"
"                                        |     |                      "
"\"Program text\"\n"
"                                  .- - -| - - |- - - - - - - - - - - - - - - "
"- -.\n"
"                                  :     |     |       "
"vtable                    :\n"
"                                  :     |     |      +----------------------"
"+   :\n"
"                                  :     |     `----->| \"<Dog as Pet>::"
"talk\" |   :\n"
"                                  :     |            +----------------------"
"+   :\n"
"                                  :     |             "
"vtable                    :\n"
"                                  :     |            +----------------------"
"+   :\n"
"                                  :     '----------->| \"<Cat as Pet>::"
"talk\" |   :\n"
"                                  :                  +----------------------"
"+   :\n"
"                                  :                                             :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"
msgstr ""
"```bob\n"
" Stiva Heap\n"
".- - - - - - - - - - - - - -. .- - - - - - - - - - - - - - - - - - - - - - "
"-.\n"
": : : :\n"
": animale de companie : : : +----+----+----+----+----+ :\n"
":   +-----------+-------+ : : : +-----+-----+ .-&gt;| F | i | d | o | :\n"
":   | ptr | o---++-+-+-----+--&gt;| o o | o o | o o | | | +----+----+----"
"+----+----+ :\n"
":   | len | 2 | : : : +-|-|-|-+-|-|-|-+ `---------. :\n"
":   | capacitate | 2 | : :     | | | | | | date | :\n"
":   +-----------+-------+ : :     | | | | +-------+--|-------+ :\n"
": : :     | | | | '--&gt;|| nume | o, 4, 4 | :\n"
": : :     | | | | | v칙rst캒 | 5 | :\n"
"`- - - - - - - - - - - - - -' :     | | | +-------+----------+ :\n"
"                                  :     | | | :\n"
"                                  :     | | | | vtable :\n"
"                                  :     | | | +----------------------+ :\n"
"                                  :     | | '----&gt;| \"<Dog as Pet>::"
"talk\" | :\n"
"                                  :     | | +----------------------+ :\n"
"                                  :     | | :\n"
"                                  :     | | date :\n"
"                                  :     | | +-------+-------+ :\n"
"                                  :     | '--&gt;| vie탵i | 9 | :\n"
"                                  :     | +-------+-------+ :\n"
"                                  :     | :\n"
"                                  :     | vtable :\n"
"                                  :     | +----------------------+ :\n"
"                                  : '----&gt;|| \"<Cat as Pet>::talk\" | :\n"
"                                  : +----------------------+ :\n"
"                                  : :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"

#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid ""
"Types that implement a given trait may be of different sizes. This makes it "
"impossible to have things like `Vec<dyn Pet>` in the example above."
msgstr ""
"Tipurile care implementeaz캒 o anumit캒 tr캒s캒tur캒 pot avea dimensiuni "
"diferite. Acest lucru face imposibil캒 existen탵a unor lucruri precum `Vec<dyn "
"Pet>` 칥n exemplul de mai sus."

#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid ""
"`dyn Pet` is a way to tell the compiler about a dynamically sized type that "
"implements `Pet`."
msgstr ""
"`dyn Pet` este o modalitate de a indica compilatorului un tip dimensionat "
"dinamic care implementeaz캒 `Pet`."

#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid ""
"In the example, `pets` is allocated on the stack and the vector data is on "
"the heap. The two vector elements are _fat pointers_:"
msgstr ""
"칉n acest exemplu, `pets` este alocat pe stiv캒, iar datele vectorului se afl캒 "
"pe heap. Cele dou캒 elemente ale vectorului sunt _fat pointeri_:"

#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid ""
"A fat pointer is a double-width pointer. It has two components: a pointer to "
"the actual object and a pointer to the [virtual method table](https://en."
"wikipedia.org/wiki/Virtual_method_table) (vtable) for the `Pet` "
"implementation of that particular object."
msgstr ""
"Un pointer gras este un pointer cu l캒탵ime dubl캒. Acesta are dou캒 componente: "
"un pointer la obiectul real 탳i un pointer la [virtual method table](https://"
"en.wikipedia.org/wiki/Virtual_method_table) (vtable) pentru implementarea "
"`Pet` a obiectului respectiv."

#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid ""
"The data for the `Dog` named Fido is the `name` and `age` fields. The `Cat` "
"has a `lives` field."
msgstr ""
"Datele pentru `Dog` numit Fido sunt c칙mpurile `name` 탳i `age`. Pentru `Cat` "
"exist캒 un c칙mp `lives`."

#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid "Compare these outputs in the above example:"
msgstr "Compara탵i aceste ie탳iri 칥n exemplul de mai sus:"

#: src/smart-pointers/exercise.md
#, fuzzy
msgid ""
"A binary tree is a tree-type data structure where every node has two "
"children (left and right). We will create a tree where each node stores a "
"value. For a given node N, all nodes in a N's left subtree contain smaller "
"values, and all nodes in N's right subtree will contain larger values."
msgstr ""
"Un arbore binar este o structur캒 de date de tip arbore 칥n care fiecare nod "
"are doi copii (st칙nga 탳i dreapta). Vom crea un arbore 칥n care fiecare nod "
"stocheaz캒 o valoare. Pentru un anumit nod N, toate nodurile din subarborele "
"st칙ng al lui N con탵in valori mai mici, iar toate nodurile din subarborele "
"drept al lui N vor con탵ine valori mai mari."

#: src/smart-pointers/exercise.md
#, fuzzy
msgid "Implement the following types, so that the given tests pass."
msgstr "Implementa탵i urm캒toarele tipuri, astfel 칥nc칙t testele date s캒 treac캒."

#: src/smart-pointers/exercise.md
#, fuzzy
msgid ""
"Extra Credit: implement an iterator over a binary tree that returns the "
"values in order."
msgstr ""
"Credit suplimentar: implementa탵i un iterator pe un arbore binar care "
"returneaz캒 valorile 칥n ordine."

#: src/smart-pointers/exercise.md src/smart-pointers/solution.md
#, fuzzy
msgid "/// A node in the binary tree.\n"
msgstr "/// Un nod 칥n arborele binar.\n"

#: src/smart-pointers/exercise.md src/smart-pointers/solution.md
#, fuzzy
msgid "/// A possibly-empty subtree.\n"
msgstr "/// Un subarbore posibil gol.\n"

#: src/smart-pointers/exercise.md src/smart-pointers/solution.md
#, fuzzy
msgid ""
"/// A container storing a set of values, using a binary tree.\n"
"///\n"
"/// If the same value is added multiple times, it is only stored once.\n"
msgstr ""
"/// Un container care stocheaz캒 un set de valori, utiliz칙nd un arbore "
"binar.\n"
"///\n"
"/// 칉n cazul 칥n care aceea탳i valoare este ad캒ugat캒 de mai multe ori, aceasta "
"este stocat캒 o singur캒 dat캒.\n"

#: src/smart-pointers/exercise.md
#, fuzzy
msgid "// Implement `new`, `insert`, `len`, and `has` for `Subtree`.\n"
msgstr "// Implementa탵i `new`, `insert`, `len` 탳i `has`.\n"

#: src/smart-pointers/exercise.md src/smart-pointers/solution.md
#, fuzzy
msgid "// not a unique item\n"
msgstr "// nu este un element unic\n"

#: src/smart-pointers/solution.md src/android/testing/googletest.md
#, fuzzy
msgid "\"bar\""
msgstr "\"bar\""

#: src/welcome-day-3-afternoon.md
#, fuzzy
msgid "[Borrowing](./borrowing.md) (55 minutes)"
msgstr "[칉mprumut](../칥mprumut.md) (1 or캒)"

#: src/welcome-day-3-afternoon.md
#, fuzzy
msgid "[Lifetimes](./lifetimes.md) (50 minutes)"
msgstr "[Referin탵e](../references.md) (50 minute)"

#: src/welcome-day-3-afternoon.md
#, fuzzy
msgid ""
"Including 10 minute breaks, this session should take about 1 hour and 55 "
"minutes"
msgstr ""
"Incluz칙nd pauzele de 10 minute, aceast캒 sesiune ar trebui s캒 dureze "
"aproximativ 3 ore 탳i 5 minute"

#: src/borrowing.md
#, fuzzy
msgid "[Borrowing a Value](./borrowing/shared.md) (10 minutes)"
msgstr "[칉mprumut칙nd o valoare](./칥mprumut/칥mp캒rt캒탳it.md) (10 minute)"

#: src/borrowing.md
#, fuzzy
msgid "[Borrow Checking](./borrowing/borrowck.md) (10 minutes)"
msgstr "[Verificarea 칥mprumutului](./칥mprumut/칥mprumutck.md) (10 minute)"

#: src/borrowing.md
#, fuzzy
msgid "[Borrow Errors](./borrowing/examples.md) (3 minutes)"
msgstr "[칉mprumut](../칥mprumut.md) (1 or캒)"

#: src/borrowing.md
#, fuzzy
msgid "[Interior Mutability](./borrowing/interior-mutability.md) (10 minutes)"
msgstr ""
"[Mutabilitatea interioar캒](./칥mprumut/interior-mutability.md) (10 minute)"

#: src/borrowing.md
#, fuzzy
msgid "[Exercise: Health Statistics](./borrowing/exercise.md) (20 minutes)"
msgstr ""
"[Exerci탵iu: Statistici 칥n domeniul s캒n캒t캒탵ii](./칥mprumut/exerci탵iu.md) (30 "
"minute)"

#: src/borrowing/shared.md
#, fuzzy
msgid ""
"As we saw before, instead of transferring ownership when calling a function, "
"you can let a function _borrow_ the value:"
msgstr ""
"칉n loc s캒 transfera탵i proprietatea atunci c칙nd apela탵i o func탵ie, pute탵i "
"l캒sa o func탵ie s캒 _칥mprumute_ valoarea:"

#: src/borrowing/shared.md
#, fuzzy
msgid "The `add` function _borrows_ two points and returns a new point."
msgstr "Func탵ia `add` adun캒 dou캒 puncte 탳i returneaz캒 un nou punct."

#: src/borrowing/shared.md
#, fuzzy
msgid "The caller retains ownership of the inputs."
msgstr "Apelantul p캒streaz캒 dreptul de proprietate asupra intr캒rilor."

#: src/borrowing/shared.md
#, fuzzy
msgid ""
"This slide is a review of the material on references from day 1, expanding "
"slightly to include function arguments and return values."
msgstr ""
"Acest diapozitiv reprezint캒 o revizuire a materialului despre referin탵e din "
"ziua 1, cu o u탳oar캒 extindere pentru a include argumentele func탵iilor 탳i "
"valorile de returnare."

#: src/borrowing/shared.md
#, fuzzy
msgid "Notes on stack returns:"
msgstr "Note privind return캒rile de stiv캒:"

#: src/borrowing/shared.md
#, fuzzy
msgid ""
"Demonstrate that the return from `add` is cheap because the compiler can "
"eliminate the copy operation. Change the above code to print stack addresses "
"and run it on the [Playground](https://play.rust-lang.org/?"
"version=stable&mode=release&edition=2021&gist=0cb13be1c05d7e3446686ad9947c4671) "
"or look at the assembly in [Godbolt](https://rust.godbolt.org/). In the "
"\"DEBUG\" optimization level, the addresses should change, while they stay "
"the same when changing to the \"RELEASE\" setting:"
msgstr ""
"Demonstra탵i c캒 칥ntoarcerea din `add` este ieftin캒 deoarece compilatorul "
"poate elimina opera탵ia de copiere. Modifica탵i codul de mai sus pentru a "
"imprima adresele stivei 탳i rula탵i-l pe [Playground](https://play.rust-lang."
"org/) sau examina탵i ansamblul 칥n [Godbolt](https://rust.godbolt.org/). 칉n "
"nivelul de optimizare \"DEBUG\", adresele ar trebui s캒 se schimbe, 칥n timp "
"ce ele r캒m칙n acelea탳i atunci c칙nd trece탵i la setarea \"RELEASE\":"

#: src/borrowing/shared.md
#, fuzzy
msgid "The Rust compiler can do return value optimization (RVO)."
msgstr "Compilatorul Rust poate face optimizarea valorii de returnare (RVO)."

#: src/borrowing/shared.md
#, fuzzy
msgid ""
"In C++, copy elision has to be defined in the language specification because "
"constructors can have side effects. In Rust, this is not an issue at all. If "
"RVO did not happen, Rust will always perform a simple and efficient `memcpy` "
"copy."
msgstr ""
"칉n C++, eliziunea de copiere trebuie definit캒 칥n specifica탵iile limbajului, "
"deoarece constructorii pot avea efecte secundare. 칉n Rust, acest lucru nu "
"reprezint캒 deloc o problem캒. Dac캒 RVO nu a avut loc, Rust va efectua "
"칥ntotdeauna o copie `memcpy` simpl캒 탳i eficient캒."

#: src/borrowing/borrowck.md
#, fuzzy
msgid ""
"Rust's _borrow checker_ puts constraints on the ways you can borrow values. "
"For a given value, at any time:"
msgstr ""
"Rust impune constr칙ngeri asupra modalit캒탵ilor 칥n care pute탵i 칥mprumuta "
"valori:"

#: src/borrowing/borrowck.md
#, fuzzy
msgid "You can have one or more shared references to the value, _or_"
msgstr "Pute탵i avea una sau mai multe valori `&T` la un moment dat, _sau_"

#: src/borrowing/borrowck.md
#, fuzzy
msgid "You can have exactly one exclusive reference to the value."
msgstr "Pute탵i avea exact o singur캒 valoare `&mut T`."

#: src/borrowing/borrowck.md
#, fuzzy
msgid ""
"Note that the requirement is that conflicting references not _exist_ at the "
"same point. It does not matter where the reference is dereferenced."
msgstr ""
"Re탵ine탵i c캒 cerin탵a este ca referin탵ele conflictuale s캒 nu _existe_ 칥n "
"acela탳i punct. Nu conteaz캒 unde este dereferen탵iat캒 referin탵a."

#: src/borrowing/borrowck.md
#, fuzzy
msgid ""
"The above code does not compile because `a` is borrowed as mutable (through "
"`c`) and as immutable (through `b`) at the same time."
msgstr ""
"Codul de mai sus nu se compileaz캒 pentru c캒 `a` este 칥mprumutat ca mutabil "
"(prin `c`) 탳i ca imuabil (prin `b`) 칥n acela탳i timp."

#: src/borrowing/borrowck.md
#, fuzzy
msgid ""
"Move the `println!` statement for `b` before the scope that introduces `c` "
"to make the code compile."
msgstr ""
"Muta탵i instruc탵iunea `println!` pentru `b` 칥nainte de domeniul de aplicare "
"care introduce `c` pentru a face codul s캒 fie compilat."

#: src/borrowing/borrowck.md
#, fuzzy
msgid ""
"After that change, the compiler realizes that `b` is only ever used before "
"the new mutable borrow of `a` through `c`. This is a feature of the borrow "
"checker called \"non-lexical lifetimes\"."
msgstr ""
"Dup캒 aceast캒 modificare, compilatorul 칥탳i d캒 seama c캒 `b` este folosit doar "
"칥nainte de noul 칥mprumut mutabil de la `a` la `c`. Aceasta este o "
"caracteristic캒 a verificatorului de 칥mprumuturi numit캒 \"durate de via탵캒 non-"
"lexicale\"."

#: src/borrowing/borrowck.md
#, fuzzy
msgid ""
"The exclusive reference constraint is quite strong. Rust uses it to ensure "
"that data races do not occur. Rust also _relies_ on this constraint to "
"optimize code. For example, a value behind a shared reference can be safely "
"cached in a register for the lifetime of that reference."
msgstr ""
"Constr칙ngerea de referin탵캒 exclusiv캒 este destul de puternic캒. Rust o "
"folose탳te pentru a se asigura c캒 nu se produc curse de date. De asemenea, "
"Rust se bazeaz캒 pe aceast캒 constr칙ngere pentru a optimiza codul. De exemplu, "
"o valoare din spatele unei referin탵e partajate poate fi stocat캒 칥n siguran탵캒 "
"칥ntr-un registru pe durata de via탵캒 a referin탵ei respective."

#: src/borrowing/borrowck.md
#, fuzzy
msgid ""
"The borrow checker is designed to accommodate many common patterns, such as "
"taking exclusive references to different fields in a struct at the same "
"time. But, there are some situations where it doesn't quite \"get it\" and "
"this often results in \"fighting with the borrow checker.\""
msgstr ""
"Verificatorul de 칥mprumuturi este conceput pentru a se adapta la multe "
"modele comune, cum ar fi preluarea de referin탵e exclusive la diferite "
"c칙mpuri dintr-o structur캒 칥n acela탳i timp. Dar, exist캒 unele situa탵ii 칥n "
"care nu prea \"칥n탵elege\", ceea ce duce adesea la \"lupta cu verificatorul "
"de 칥mprumuturi\""

#: src/borrowing/examples.md
#, fuzzy
msgid ""
"As a concrete example of how these borrowing rules prevent memory errors, "
"consider the case of modifying a collection while there are references to "
"its elements:"
msgstr ""
"Ca exemplu concret al modului 칥n care aceste reguli de 칥mprumut previn "
"erorile de memorie, lua탵i 칥n considerare cazul modific캒rii unei colec탵ii 칥n "
"timp ce exist캒 referin탵e la elementele sale:"

#: src/borrowing/examples.md
#, fuzzy
msgid "\"{elem}\""
msgstr "\"elem: {elem}\""

#: src/borrowing/examples.md
#, fuzzy
msgid "Similarly, consider the case of iterator invalidation:"
msgstr "칉n mod similar, lua탵i 칥n considerare cazul invalid캒rii iteratorilor:"

#: src/borrowing/examples.md
#, fuzzy
msgid ""
"In both of these cases, modifying the collection by pushing new elements "
"into it can potentially invalidate existing references to the collection's "
"elements if the collection has to reallocate."
msgstr ""
"칉n ambele cazuri, modificarea colec탵iei prin introducerea de noi elemente 칥n "
"colec탵ie poate invalida referin탵ele existente la elementele colec탵iei dac캒 "
"colec탵ia trebuie realocat캒."

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid ""
"In some situations, it's necessary to modify data behind a shared (read-"
"only) reference. For example, a shared data structure might have an internal "
"cache, and wish to update that cache from read-only methods."
msgstr ""
"칉n unele situa탵ii, este necesar s캒 se modifice datele din spatele unei "
"referin탵e partajate (numai pentru citire). De exemplu, o structur캒 de date "
"partajat캒 ar putea avea o memorie cache intern캒 탳i ar putea dori s캒 "
"actualizeze aceast캒 memorie cache prin metode numai pentru citire."

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid ""
"The \"interior mutability\" pattern allows exclusive (mutable) access behind "
"a shared reference. The standard library provides several ways to do this, "
"all while still ensuring safety, typically by performing a runtime check."
msgstr ""
"Modelul \"mutabilit캒탵ii interioare\" permite accesul exclusiv (mutabil) 칥n "
"spatele unei referin탵e partajate. Biblioteca standard ofer캒 mai multe "
"modalit캒탵i de a face acest lucru, toate asigur칙nd 칥n acela탳i timp siguran탵a, "
"de obicei prin efectuarea unei verific캒ri 칥n timpul execu탵iei."

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid "`RefCell`"
msgstr "Celula/RefCell"

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid "// Note that `cell` is NOT declared as mutable.\n"
msgstr "// Re탵ine탵i c캒 `cell` NU este declarat ca fiind mutabil.\n"

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid ""
"// This triggers an error at runtime.\n"
"        // let other = cell.borrow();\n"
"        // println!(\"{}\", *other);\n"
msgstr ""
"// Acest lucru declan탳eaz캒 o eroare 칥n timpul execu탵iei.\n"
"        // let other = cell.borrow();\n"
"        // println!(\"{}\", *other);\n"

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid "\"{cell:?}\""
msgstr "Celula/RefCell"

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid "`Cell`"
msgstr "`Celula<T>`"

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid ""
"`Cell` wraps a value and allows getting or setting the value, even with a "
"shared reference to the `Cell`. However, it does not allow any references to "
"the value. Since there are no references, borrowing rules cannot be broken."
msgstr ""
"`Cell` 칥nf캒탳oar캒 o valoare 탳i permite ob탵inerea sau stabilirea valorii, "
"chiar 탳i cu o referin탵캒 partajat캒 la `Cell`. Cu toate acestea, nu permite "
"referin탵e la valoarea respectiv캒. Deoarece nu exist캒 referin탵e, regulile de "
"칥mprumut nu pot fi 칥nc캒lcate."

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid ""
"The main thing to take away from this slide is that Rust provides _safe_ "
"ways to modify data behind a shared reference. There are a variety of ways "
"to ensure that safety, and `RefCell` and `Cell` are two of them."
msgstr ""
"Principalul lucru care trebuie re탵inut din acest diapozitiv este c캒 Rust "
"ofer캒 modalit캒탵i _sigure_ de a modifica datele din spatele unei referin탵e "
"partajate. Exist캒 o varietate de moduri de a asigura aceast캒 siguran탵캒, iar "
"`RefCell` 탳i `Cell` sunt dou캒 dintre ele."

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid ""
"`RefCell` enforces Rust's usual borrowing rules (either multiple shared "
"references or a single exclusive reference) with a runtime check. In this "
"case, all borrows are very short and never overlap, so the checks always "
"succeed."
msgstr ""
"`RefCell` aplic캒 regulile obi탳nuite de 칥mprumut din Rust (fie mai multe "
"referin탵e partajate, fie o singur캒 referin탵캒 exclusiv캒) cu o verificare 칥n "
"timpul execu탵iei. 칉n acest caz, toate 칥mprumuturile sunt foarte scurte 탳i nu "
"se suprapun niciodat캒, astfel 칥nc칙t verific캒rile reu탳esc 칥ntotdeauna."

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid ""
"The extra block in the `RefCell` example is to end the borrow created by the "
"call to `borrow_mut` before we print the cell. Trying to print a borrowed "
"`RefCell` just shows the message `\"{borrowed}\"`."
msgstr ""
"Blocul suplimentar din exemplul `RefCell` are rolul de a 칥ncheia 칥mprumutul "
"creat prin apelul la `borrow_mut` 칥nainte de a imprima celula. 칉ncercarea de "
"a imprima o `RefCell` 칥mprumutat캒 nu face dec칙t s캒 afi탳eze mesajul "
"`\"{borrowed}\"`."

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid ""
"`Cell` is a simpler means to ensure safety: it has a `set` method that takes "
"`&self`. This needs no runtime check, but requires moving values, which can "
"have its own cost."
msgstr ""
"`Cell` este un mijloc mai simplu de a asigura siguran탵a: are o metod캒 `set` "
"care ia `&self`. Acest lucru nu necesit캒 o verificare 칥n timpul execu탵iei, "
"dar necesit캒 mutarea valorilor, ceea ce poate avea propriile costuri."

#: src/borrowing/exercise.md
#, fuzzy
msgid ""
"You're working on implementing a health-monitoring system. As part of that, "
"you need to keep track of users' health statistics."
msgstr ""
"Lucra탵i la implementarea unui sistem de monitorizare a s캒n캒t캒탵ii. 칉n cadrul "
"acestuia, trebuie s캒 탵ine탵i eviden탵a statisticilor de s캒n캒tate ale "
"utilizatorilor."

#: src/borrowing/exercise.md
#, fuzzy
msgid ""
"You'll start with a stubbed function in an `impl` block as well as a `User` "
"struct definition. Your goal is to implement the stubbed out method on the "
"`User` `struct` defined in the `impl` block."
msgstr ""
"Ve탵i 칥ncepe cu ni탳te func탵ii stubbed 칥ntr-un bloc `impl`, precum 탳i cu o "
"defini탵ie a structurii `User`. Scopul dumneavoastr캒 este de a implementa "
"metodele stubbed out pe `struct` `User` definit캒 칥n blocul `impl`."

#: src/borrowing/exercise.md
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing "
"method:"
msgstr ""
"Copia탵i codul de mai jos 칥n <https://play.rust-lang.org/> 탳i completa탵i "
"metodele lips캒:"

#: src/borrowing/exercise.md
#, fuzzy
msgid ""
"\"Update a user's statistics based on measurements from a visit to the "
"doctor\""
msgstr ""
"\"Actualiza탵i statisticile unui utilizator pe baza m캒sur캒torilor de la o "
"vizit캒 la medic\""

#: src/borrowing/exercise.md src/borrowing/solution.md
#: src/android/build-rules/library.md
#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "\"Bob\""
msgstr "\"Bob\""

#: src/borrowing/exercise.md src/borrowing/solution.md
#, fuzzy
msgid "\"I'm {} and my age is {}\""
msgstr "\"Eu sunt {} 탳i v칙rsta mea este {}\""

#: src/lifetimes.md
#, fuzzy
msgid ""
"[Lifetime Annotations](./lifetimes/lifetime-annotations.md) (10 minutes)"
msgstr ""
"[Adnot캒ri privind durata de via탵캒](./slices-and-lifetimes/lifetime-"
"annotations.md) (10 minute)"

#: src/lifetimes.md
#, fuzzy
msgid "[Lifetime Elision](./lifetimes/lifetime-elision.md) (5 minutes)"
msgstr ""
"[Lifetime Elision](./slices-and-lifetimes/lifetime-elision.md) (5 minute)"

#: src/lifetimes.md
#, fuzzy
msgid "[Struct Lifetimes](./lifetimes/struct-lifetimes.md) (5 minutes)"
msgstr ""
"[Struct Lifetimes](./slices-and-lifetimes/struct-lifetimes.md) (5 minute)"

#: src/lifetimes.md
#, fuzzy
msgid "[Exercise: Protobuf Parsing](./lifetimes/exercise.md) (30 minutes)"
msgstr ""
"[Exerci탵iu: Parsarea Protobuf](./slices-and-lifetimes/exercise.md) (30 "
"minute)"

#: src/lifetimes/lifetime-annotations.md
#, fuzzy
msgid ""
"A reference has a _lifetime_, which must not \"outlive\" the value it refers "
"to. This is verified by the borrow checker."
msgstr ""
"O referin탵캒 are o _durat캒 de via탵캒_, care nu trebuie s캒 \"supravie탵uiasc캒\" "
"valorii la care se refer캒. Acest lucru este verificat de c캒tre verificatorul "
"de 칥mprumut."

#: src/lifetimes/lifetime-annotations.md
#, fuzzy
msgid ""
"The lifetime can be implicit - this is what we have seen so far. Lifetimes "
"can also be explicit: `&'a Point`, `&'document str`. Lifetimes start with "
"`'` and `'a` is a typical default name. Read `&'a Point` as \"a borrowed "
"`Point` which is valid for at least the lifetime `a`\"."
msgstr ""
"Durata de via탵캒 poate fi implicit캒 - aceasta este ceea ce am v캒zut p칙n캒 "
"acum. Duratele de via탵캒 pot fi, de asemenea, explicite: `&'a Point`, "
"`&'document str`. Duratele de via탵캒 칥ncep cu `'`, iar `'a` este un nume "
"implicit tipic. Citi탵i `&'a Point` ca \"un `Point` 칥mprumutat care este "
"valabil cel pu탵in pentru durata de via탵캒 `a`\"."

#: src/lifetimes/lifetime-annotations.md
#, fuzzy
msgid ""
"Lifetimes are always inferred by the compiler: you cannot assign a lifetime "
"yourself. Explicit lifetime annotations create constraints where there is "
"ambiguity; the compiler verifies that there is a valid solution."
msgstr ""
"Adnot캒rile privind durata de via탵캒 creeaz캒 constr칙ngeri; compilatorul "
"verific캒 dac캒 exist캒 o solu탵ie valid캒."

#: src/lifetimes/lifetime-annotations.md
#, fuzzy
msgid ""
"Lifetimes become more complicated when considering passing values to and "
"returning values from functions."
msgstr ""
"Duratele de via탵캒 devin mai complicate atunci c칙nd se ia 칥n considerare "
"transmiterea valorilor c캒tre 탳i returnarea valorilor din func탵ii."

#: src/lifetimes/lifetime-annotations.md
#, fuzzy
msgid "// What is the lifetime of p3?\n"
msgstr "// Care este durata de via탵캒 a lui p3?\n"

#: src/lifetimes/lifetime-annotations.md
#, fuzzy
msgid "\"p3: {p3:?}\""
msgstr "\"p3: {p3:?}\""

#: src/lifetimes/lifetime-annotations.md
#, fuzzy
msgid ""
"In this example, the compiler does not know what lifetime to infer for `p3`. "
"Looking inside the function body shows that it can only safely assume that "
"`p3`'s lifetime is the shorter of `p1` and `p2`. But just like types, Rust "
"requires explicit annotations of lifetimes on function arguments and return "
"values."
msgstr ""
"칉n acest exemplu, compilatorul nu 탳tie ce durat캒 de via탵캒 s캒 deduc캒 pentru "
"`p3`. Privind 칥n interiorul corpului func탵iei arat캒 c캒 poate doar s캒 "
"presupun캒 칥n mod sigur c캒 durata de via탵캒 a lui `p3` este cea mai scurt캒 "
"dintre `p1` 탳i `p2`. Dar, la fel ca tipurile, Rust necesit캒 adnot캒ri "
"explicite ale duratei de via탵캒 pentru argumentele func탵iilor 탳i valorile de "
"returnare."

#: src/lifetimes/lifetime-annotations.md
#, fuzzy
msgid "Add `'a` appropriately to `left_most`:"
msgstr "Ad캒uga탵i `'a` 칥n mod corespunz캒tor la `left_most`:"

#: src/lifetimes/lifetime-annotations.md
#, fuzzy
msgid ""
"This says, \"given p1 and p2 which both outlive `'a`, the return value lives "
"for at least `'a`."
msgstr ""
"Acest lucru spune: \"date fiind p1 탳i p2, care am칙ndou캒 tr캒iesc mai mult de "
"`'a`, valoarea de 칥ntoarcere tr캒ie탳te cel pu탵in `'a`."

#: src/lifetimes/lifetime-annotations.md
#, fuzzy
msgid ""
"In common cases, lifetimes can be elided, as described on the next slide."
msgstr ""
"칉n cazuri obi탳nuite, duratele de via탵캒 pot fi eludate, a탳a cum este descris "
"칥n slide-ul urm캒tor."

#: src/lifetimes/lifetime-elision.md
msgid "Lifetimes in Function Calls"
msgstr "Duratele de via탵캒 칥n apelurile de func탵ii"

#: src/lifetimes/lifetime-elision.md
#, fuzzy
msgid ""
"Lifetimes for function arguments and return values must be fully specified, "
"but Rust allows lifetimes to be elided in most cases with [a few simple "
"rules](https://doc.rust-lang.org/nomicon/lifetime-elision.html). This is not "
"inference -- it is just a syntactic shorthand."
msgstr ""
"Duratele de via탵캒 pentru argumentele func탵iilor 탳i valorile de retur trebuie "
"s캒 fie specificate 칥n 칥ntregime, dar Rust permite ca duratele de via탵캒 s캒 "
"fie eludate 칥n majoritatea cazurilor cu [c칙teva reguli simple](https://doc."
"rust-lang.org/nomicon/lifetime-elision.html)."

#: src/lifetimes/lifetime-elision.md
#, fuzzy
msgid "Each argument which does not have a lifetime annotation is given one."
msgstr ""
"Fiecare argument care nu are o adnotare de durat캒 de via탵캒 prime탳te una."

#: src/lifetimes/lifetime-elision.md
#, fuzzy
msgid ""
"If there is only one argument lifetime, it is given to all un-annotated "
"return values."
msgstr ""
"칉n cazul 칥n care exist캒 un singur argument pe durata de via탵캒, acesta este "
"atribuit tuturor valorilor de returnare neanun탵ate."

#: src/lifetimes/lifetime-elision.md
#, fuzzy
msgid ""
"If there are multiple argument lifetimes, but the first one is for `self`, "
"that lifetime is given to all un-annotated return values."
msgstr ""
"Dac캒 exist캒 mai multe durate de via탵캒 ale argumentelor, dar prima este "
"pentru `self`, aceast캒 durat캒 de via탵캒 este acordat캒 tuturor valorilor de "
"returnare neanun탵ate."

#: src/lifetimes/lifetime-elision.md
#, fuzzy
msgid "In this example, `cab_distance` is trivially elided."
msgstr "칉n acest exemplu, `cab_distance` este eliminat 칥n mod trivial."

#: src/lifetimes/lifetime-elision.md
#, fuzzy
msgid ""
"The `nearest` function provides another example of a function with multiple "
"references in its arguments that requires explicit annotation."
msgstr ""
"Func탵ia `nearest` ofer캒 un alt exemplu de func탵ie cu referin탵e multiple 칥n "
"argumentele sale care necesit캒 o adnotare explicit캒."

#: src/lifetimes/lifetime-elision.md
#, fuzzy
msgid "Try adjusting the signature to \"lie\" about the lifetimes returned:"
msgstr ""
"칉ncerca탵i s캒 ajusta탵i semn캒tura pentru a \"min탵i\" cu privire la perioadele "
"de via탵캒 returnate:"

#: src/lifetimes/lifetime-elision.md
#, fuzzy
msgid ""
"This won't compile, demonstrating that the annotations are checked for "
"validity by the compiler. Note that this is not the case for raw pointers "
"(unsafe), and this is a common source of errors with unsafe Rust."
msgstr ""
"Acest lucru nu se va compila, demonstr칙nd c캒 validitatea adnot캒rilor este "
"verificat캒 de compilator. Re탵ine탵i c캒 acest lucru nu este valabil 탳i pentru "
"pointeri brute (unsafe), iar aceasta este o surs캒 comun캒 de erori 칥n cazul "
"Rust unsafe."

#: src/lifetimes/lifetime-elision.md
#, fuzzy
msgid ""
"Students may ask when to use lifetimes. Rust borrows _always_ have "
"lifetimes. Most of the time, elision and type inference mean these don't "
"need to be written out. In more complicated cases, lifetime annotations can "
"help resolve ambiguity. Often, especially when prototyping, it's easier to "
"just work with owned data by cloning values where necessary."
msgstr ""
"Elevii pot 칥ntreba c칙nd trebuie s캒 foloseasc캒 duratele de via탵캒. "
"칉mprumuturile Rust au _칥ntotdeauna_ durate de via탵캒. De cele mai multe ori, "
"eliziunea 탳i inferen탵a de tip 칥nseamn캒 c캒 acestea nu trebuie s캒 fie scrise. "
"칉n cazuri mai complicate, adnot캒rile privind durata de via탵캒 pot ajuta la "
"rezolvarea ambiguit캒탵ii. De multe ori, 칥n special 칥n cazul prototipurilor, "
"este mai u탳or s캒 lucra탵i cu datele de탵inute prin clonarea valorilor acolo "
"unde este necesar."

#: src/lifetimes/struct-lifetimes.md
msgid "Lifetimes in Data Structures"
msgstr "Duratele de via탵캒 칥n structurile de date"

#: src/lifetimes/struct-lifetimes.md
#, fuzzy
msgid ""
"If a data type stores borrowed data, it must be annotated with a lifetime:"
msgstr ""
"칉n cazul 칥n care un tip de date stocheaz캒 date 칥mprumutate, acesta trebuie "
"s캒 fie adnotat cu o durat캒 de via탵캒:"

#: src/lifetimes/struct-lifetimes.md
#, fuzzy
msgid "\"Bye {text}!\""
msgstr "\"La revedere {text}!\""

#: src/lifetimes/struct-lifetimes.md
#, fuzzy
msgid "\"The quick brown fox jumps over the lazy dog.\""
msgstr "\"Vulpea cea iute 탳i brun캒 sare peste c칙inele lene탳.\""

#: src/lifetimes/struct-lifetimes.md
#, fuzzy
msgid "// erase(text);\n"
msgstr "// erase(text);\n"

#: src/lifetimes/struct-lifetimes.md
#, fuzzy
msgid "\"{fox:?}\""
msgstr "\"{fox:?}\""

#: src/lifetimes/struct-lifetimes.md
#, fuzzy
msgid "\"{dog:?}\""
msgstr "\"{dog:?}\""

#: src/lifetimes/struct-lifetimes.md
#, fuzzy
msgid ""
"In the above example, the annotation on `Highlight` enforces that the data "
"underlying the contained `&str` lives at least as long as any instance of "
"`Highlight` that uses that data."
msgstr ""
"칉n exemplul de mai sus, adnotarea pentru `Highlight` impune ca datele care "
"stau la baza `&str` con탵inute s캒 aib캒 o durat캒 de via탵캒 cel pu탵in egal캒 cu "
"cea a oric캒rei instan탵e de `Highlight` care utilizeaz캒 aceste date."

#: src/lifetimes/struct-lifetimes.md
#, fuzzy
msgid ""
"If `text` is consumed before the end of the lifetime of `fox` (or `dog`), "
"the borrow checker throws an error."
msgstr ""
"Dac캒 `text` este consumat 칥nainte de sf칙r탳itul duratei de via탵캒 a lui `fox` "
"(sau `dog`), verificatorul de 칥mprumuturi arunc캒 o eroare."

#: src/lifetimes/struct-lifetimes.md
#, fuzzy
msgid ""
"Types with borrowed data force users to hold on to the original data. This "
"can be useful for creating lightweight views, but it generally makes them "
"somewhat harder to use."
msgstr ""
"Tipurile cu date 칥mprumutate 칥i oblig캒 pe utilizatori s캒 p캒streze datele "
"originale. Acest lucru poate fi util pentru a crea vizualiz캒ri u탳oare, dar, "
"칥n general, le face ceva mai greu de utilizat."

#: src/lifetimes/struct-lifetimes.md
#, fuzzy
msgid "When possible, make data structures own their data directly."
msgstr ""
"Atunci c칙nd este posibil, face탵i ca structurile de date s캒 de탵in캒 direct "
"datele lor."

#: src/lifetimes/struct-lifetimes.md
#, fuzzy
msgid ""
"Some structs with multiple references inside can have more than one lifetime "
"annotation. This can be necessary if there is a need to describe lifetime "
"relationships between the references themselves, in addition to the lifetime "
"of the struct itself. Those are very advanced use cases."
msgstr ""
"Unele structuri cu referin탵e multiple 칥n interior pot avea mai multe "
"adnot캒ri de durat캒 de via탵캒. Acest lucru poate fi necesar 칥n cazul 칥n care "
"este necesar s캒 se descrie rela탵iile de durat캒 de via탵캒 칥ntre referin탵e, pe "
"l칙ng캒 durata de via탵캒 a structurii 칥n sine. Acestea sunt cazuri de utilizare "
"foarte avansate."

#: src/lifetimes/exercise.md
#, fuzzy
msgid ""
"In this exercise, you will build a parser for the [protobuf binary encoding]"
"(https://protobuf.dev/programming-guides/encoding/). Don't worry, it's "
"simpler than it seems! This illustrates a common parsing pattern, passing "
"slices of data. The underlying data itself is never copied."
msgstr ""
"칉n acest exerci탵iu, ve탵i construi un parser pentru [protobuf binary encoding]"
"(https://protobuf.dev/programming-guides/encoding/). Nu v캒 face탵i griji, "
"este mai simplu dec칙t pare! Aceasta ilustreaz캒 un model comun de parsare, "
"trec칙nd felii de date. Datele de baz캒 칥n sine nu sunt niciodat캒 copiate."

#: src/lifetimes/exercise.md
#, fuzzy
msgid ""
"Fully parsing a protobuf message requires knowing the types of the fields, "
"indexed by their field numbers. That is typically provided in a `proto` "
"file. In this exercise, we'll encode that information into `match` "
"statements in functions that get called for each field."
msgstr ""
"Analiza complet캒 a unui mesaj protobuf necesit캒 cunoa탳terea tipurilor de "
"c칙mpuri, indexate prin numerele de c칙mp. Acest lucru este furnizat de obicei "
"칥ntr-un fi탳ier `proto`. 칉n acest exerci탵iu, vom codifica aceste informa탵ii "
"칥n instruc탵iuni `match` 칥n func탵ii care sunt apelate pentru fiecare c칙mp."

#: src/lifetimes/exercise.md
#, fuzzy
msgid "We'll use the following proto:"
msgstr "Pute탵i utiliza urm캒torul `Cargo.toml`:"

#: src/lifetimes/exercise.md
#, fuzzy
msgid ""
"A proto message is encoded as a series of fields, one after the next. Each "
"is implemented as a \"tag\" followed by the value. The tag contains a field "
"number (e.g., `2` for the `id` field of a `Person` message) and a wire type "
"defining how the payload should be determined from the byte stream."
msgstr ""
"Un mesaj proto este codificat ca o serie de c칙mpuri, unul dup캒 altul. "
"Fiecare este implementat ca o \"etichet캒\" urmat캒 de valoare. Eticheta "
"con탵ine un num캒r de c칙mp (de exemplu, `2` pentru c칙mpul `id` al unui mesaj "
"`Person`) 탳i un tip de fir care define탳te modul 칥n care 칥nc캒rc캒tura util캒 ar "
"trebui s캒 fie determinat캒 din fluxul de octe탵i."

#: src/lifetimes/exercise.md
#, fuzzy
msgid ""
"Integers, including the tag, are represented with a variable-length encoding "
"called VARINT. Luckily, `parse_varint` is defined for you below. The given "
"code also defines callbacks to handle `Person` and `PhoneNumber` fields, and "
"to parse a message into a series of calls to those callbacks."
msgstr ""
"칉ntregii, inclusiv tag-ul, sunt reprezenta탵i cu o codificare de lungime "
"variabil캒 numit캒 VARINT. Din fericire, `parse_varint` este definit pentru "
"dumneavoastr캒 mai jos. Codul dat define탳te, de asemenea, callback-uri pentru "
"a gestiona c칙mpurile `Person` 탳i `PhoneNumber` 탳i pentru a analiza un mesaj "
"칥ntr-o serie de apeluri la aceste callback-uri."

#: src/lifetimes/exercise.md
#, fuzzy
msgid ""
"What remains for you is to implement the `parse_field` function and the "
"`ProtoMessage` trait for `Person` and `PhoneNumber`."
msgstr ""
"Ceea ce v캒 r캒m칙ne de f캒cut este s캒 implementa탵i func탵ia `parse_field` 탳i "
"tr캒s캒tura `ProtoMessage` pentru `Person` 탳i `PhoneNumber`."

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "\"Invalid varint\""
msgstr "\"Invalid varint\""

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "\"Invalid wire-type\""
msgstr "\"Tip de fir invalid\""

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "\"Unexpected EOF\""
msgstr "\"Unexpected EOF\""

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "\"Invalid length\""
msgstr "\"Lungime invalid캒\""

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "\"Unexpected wire-type)\""
msgstr "\"Tip de fir nea탳teptat)\""

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "\"Invalid string (not UTF-8)\""
msgstr "\"탲ir nevalabil (nu UTF-8)\""

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "/// A wire type as seen on the wire.\n"
msgstr "/// Un tip de fir, a탳a cum se vede pe fir.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "/// The Varint WireType indicates the value is a single VARINT.\n"
msgstr "/// Varint WireType indic캒 faptul c캒 valoarea este un singur VARINT.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid ""
"//I64,  -- not needed for this exercise\n"
"    /// The Len WireType indicates that the value is a length represented as "
"a\n"
"    /// VARINT followed by exactly that number of bytes.\n"
msgstr ""
"//I64, -- nu este necesar pentru acest exerci탵iu\n"
"    /// Tipul de fir Len indic캒 faptul c캒 valoarea este o lungime "
"reprezentat캒 sub forma unui num캒r de caractere\n"
"    /// VARINT urmat de exact acest num캒r de octe탵i.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid ""
"/// The I32 WireType indicates that the value is precisely 4 bytes in\n"
"    /// little-endian order containing a 32-bit signed integer.\n"
msgstr ""
"/// I32 WireType indic캒 faptul c캒 valoarea este exact 4 octe탵i 칥n\n"
"    /// little-endian care con탵in un num캒r 칥ntreg semnat pe 32 de bi탵i.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "/// A field's value, typed based on the wire type.\n"
msgstr "/// Valoarea unui c칙mp, tipizat캒 칥n func탵ie de tipul de fir.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "//I64(i64),  -- not needed for this exercise\n"
msgstr "//I64(i64), -- nu este necesar pentru acest exerci탵iu\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "/// A field, containing the field number and its value.\n"
msgstr "/// Un c칙mp, care con탵ine num캒rul c칙mpului 탳i valoarea acestuia.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "//1 => WireType::I64,  -- not needed for this exercise\n"
msgstr "//1 => WireType::I64, -- nu este necesar pentru acest exerci탵iu\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid ""
"/// Parse a VARINT, returning the parsed value and the remaining bytes.\n"
msgstr ""
"/// Analizeaz캒 un VARINT, return칙nd valoarea analizat캒 탳i octe탵ii r캒ma탳i.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid ""
"// This is the last byte of the VARINT, so convert it to\n"
"            // a u64 and return it.\n"
msgstr ""
"// Acesta este ultimul octet din VARINT, deci converti탵i-l 칥n\n"
"            // un u64 탳i returna탵i-l.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "// More than 7 bytes is invalid.\n"
msgstr "// Mai mult de 7 octe탵i este invalid.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "/// Convert a tag into a field number and a WireType.\n"
msgstr "/// Converte탳te o etichet캒 칥ntr-un num캒r de c칙mp 탳i un tip de fir.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "/// Parse a field, returning the remaining bytes\n"
msgstr "/// Parseaz캒 un c칙mp, return칙nd octe탵ii r캒ma탳i\n"

#: src/lifetimes/exercise.md
#, fuzzy
msgid ""
"\"Based on the wire type, build a Field, consuming as many bytes as "
"necessary.\""
msgstr ""
"\"Pe baza tipului de fir, construi탵i un c칙mp, consum칙nd at칙탵ia octe탵i c칙탵i "
"sunt necesari.\""

#: src/lifetimes/exercise.md
#, fuzzy
msgid "\"Return the field, and any un-consumed bytes.\""
msgstr "\"칉ntoarce탵i c칙mpul 탳i to탵i octe탵ii neconsuma탵i.\""

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid ""
"/// Parse a message in the given data, calling `T::add_field` for each field "
"in\n"
"/// the message.\n"
"///\n"
"/// The entire input is consumed.\n"
msgstr ""
"/// Parseaz캒 un mesaj 칥n datele date, apel칙nd `T::add_field` pentru fiecare "
"c칙mp din\n"
"/// mesajul.\n"
"///\n"
"/// Se consum캒 칥ntreaga intrare.\n"

#: src/lifetimes/exercise.md
#, fuzzy
msgid "// TODO: Implement ProtoMessage for Person and PhoneNumber.\n"
msgstr "// TODO: Implementa탵i ProtoMessage pentru Person 탳i PhoneNumber.\n"

#: src/lifetimes/solution.md
#, fuzzy
msgid "// Unwrap error because `value` is definitely 4 bytes long.\n"
msgstr "// Eroare de dezarhivare deoarece `value` are o lungime de 4 bytes.\n"

#: src/lifetimes/solution.md
#, fuzzy
msgid "// skip everything else\n"
msgstr "// s캒ri탵i peste orice altceva\n"

#: src/lifetimes/solution.md
#, fuzzy
msgid "b\"hello\""
msgstr "b \"hello\""

#: src/welcome-day-4.md
#, fuzzy
msgid "Welcome to Day 4"
msgstr "Bine a탵i venit la Ziua 1"

#: src/welcome-day-4.md
#, fuzzy
msgid ""
"Today we will cover topics relating to building large-scale software in Rust:"
msgstr "Ast캒zi, vom aborda c칙teva subiecte mai avansate din Rust:"

#: src/welcome-day-4.md
#, fuzzy
msgid "Iterators: a deep dive on the `Iterator` trait."
msgstr "Iteratori: o scufundare 칥n profunzime 칥n tr캒s캒tura `Iterator`."

#: src/welcome-day-4.md
#, fuzzy
msgid "Modules and visibility."
msgstr "Module 탳i vizibilitate."

#: src/welcome-day-4.md
#, fuzzy
msgid "Testing."
msgstr "Testare"

#: src/welcome-day-4.md
#, fuzzy
msgid "Error handling: panics, `Result`, and the try operator `?`."
msgstr "Gestionarea erorilor: panici, `Result` 탳i operatorul try `?`."

#: src/welcome-day-4.md
#, fuzzy
msgid ""
"Unsafe Rust: the escape hatch when you can't express yourself in safe Rust."
msgstr ""
"Unsafe Rust: porti탵a de sc캒pare atunci c칙nd nu te po탵i exprima 칥n Rust sigur."

#: src/welcome-day-4.md
#, fuzzy
msgid "[Welcome](./welcome-day-4.md) (3 minutes)"
msgstr "[Intorducere](../welcome-day-4.md) (3 minute)"

#: src/welcome-day-4.md
#, fuzzy
msgid "[Iterators](./iterators.md) (45 minutes)"
msgstr "[Iteratori](../iteratori.md) (45 minute)"

#: src/welcome-day-4.md
#, fuzzy
msgid "[Modules](./modules.md) (40 minutes)"
msgstr "[Module](../modules.md) (40 minute)"

#: src/welcome-day-4.md
#, fuzzy
msgid "[Testing](./testing.md) (45 minutes)"
msgstr "[Testare](../testing.md) (1 or캒 탳i 5 minute)"

#: src/welcome-day-4.md
#, fuzzy
msgid ""
"Including 10 minute breaks, this session should take about 2 hours and 40 "
"minutes"
msgstr ""
"Incluz칙nd pauzele de 10 minute, aceast캒 sesiune ar trebui s캒 dureze "
"aproximativ 2 ore 탳i 20 de minute"

#: src/iterators.md
#, fuzzy
msgid "[Iterator](./iterators/iterator.md) (5 minutes)"
msgstr "[Iterator](./iterators/iterator.md) (5 minute)"

#: src/iterators.md
#, fuzzy
msgid "[IntoIterator](./iterators/intoiterator.md) (5 minutes)"
msgstr "[IntoIterator](./iterators/intoiterator.md) (5 minute)"

#: src/iterators.md
#, fuzzy
msgid "[FromIterator](./iterators/fromiterator.md) (5 minutes)"
msgstr "[FromIterator](./iterators/fromiterator.md) (5 minute)"

#: src/iterators.md
#, fuzzy
msgid ""
"[Exercise: Iterator Method Chaining](./iterators/exercise.md) (30 minutes)"
msgstr ""
"[Exerci탵iu: 칥nl캒n탵uirea metodelor Iterator](./iterators/exerci탵iu.md) (30 "
"minute)"

#: src/iterators.md src/testing.md
#, fuzzy
msgid "This segment should take about 45 minutes"
msgstr "Acest segment ar trebui s캒 dureze aproximativ 45 de minute"

#: src/iterators/iterator.md
#, fuzzy
msgid ""
"The [`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) "
"trait supports iterating over values in a collection. It requires a `next` "
"method and provides lots of methods. Many standard library types implement "
"`Iterator`, and you can implement it yourself, too:"
msgstr ""
"Caracteristica [`Iterator`](https://doc.rust-lang.org/std/iter/trait."
"Iterator.html) permite itera탵ia peste valorile dintr-o colec탵ie. Aceasta "
"necesit캒 o metod캒 `next` 탳i ofer캒 o mul탵ime de metode. Multe tipuri de "
"bibliotec캒 standard implementeaz캒 `Iterator` 탳i o pute탵i implementa 탳i "
"dumneavoastr캒:"

#: src/iterators/iterator.md
#, fuzzy
msgid "\"fib({i}): {n}\""
msgstr "\"fib({i}): {n}\""

#: src/iterators/iterator.md
#, fuzzy
msgid ""
"The `Iterator` trait implements many common functional programming "
"operations over collections (e.g. `map`, `filter`, `reduce`, etc). This is "
"the trait where you can find all the documentation about them. In Rust these "
"functions should produce the code as efficient as equivalent imperative "
"implementations."
msgstr ""
"Caracteristica `Iterator` implementeaz캒 multe opera탵ii comune de programare "
"func탵ional캒 asupra colec탵iilor (de exemplu, `map`, `filter`, `reduce` etc.). "
"Aceasta este tr캒s캒tura 칥n care pute탵i g캒si toat캒 documenta탵ia referitoare la "
"acestea. 칉n Rust, aceste func탵ii ar trebui s캒 produc캒 cod la fel de eficient "
"ca 탳i implement캒rile imperative echivalente."

#: src/iterators/iterator.md
#, fuzzy
msgid ""
"`IntoIterator` is the trait that makes for loops work. It is implemented by "
"collection types such as `Vec<T>` and references to them such as `&Vec<T>` "
"and `&[T]`. Ranges also implement it. This is why you can iterate over a "
"vector with `for i in some_vec { .. }` but `some_vec.next()` doesn't exist."
msgstr ""
"`IntoIterator` este tr캒s캒tura care face ca buclele for s캒 func탵ioneze. Este "
"implementat캒 prin tipuri de colec탵ii, cum ar fi `Vec<T>` 탳i referin탵e la "
"acestea, cum ar fi `&amp;Vec<T>` 탳i `&amp;[T]`. De asemenea, este "
"implementat캒 탳i 칥n cazul intervalelor. Acesta este motivul pentru care "
"pute탵i itera un vector cu `for i in some_vec { ... }`, dar `some_vec.next()` "
"nu exist캒."

#: src/iterators/intoiterator.md
#, fuzzy
msgid ""
"The `Iterator` trait tells you how to _iterate_ once you have created an "
"iterator. The related trait [`IntoIterator`](https://doc.rust-lang.org/std/"
"iter/trait.IntoIterator.html) defines how to create an iterator for a type. "
"It is used automatically by the `for` loop."
msgstr ""
"Tr캒s캒tura `Iterator` v캒 spune cum s캒 _itera탵i_ dup캒 ce a탵i creat un "
"iterator. Tr캒s캒tura conex캒 `IntoIterator` v캒 spune cum s캒 crea탵i iteratorul:"

#: src/iterators/intoiterator.md
#, fuzzy
msgid "\"point = {x}, {y}\""
msgstr "\"point = {x}, {y}\""

#: src/iterators/intoiterator.md
#, fuzzy
msgid ""
"Click through to the docs for `IntoIterator`. Every implementation of "
"`IntoIterator` must declare two types:"
msgstr ""
"Sintaxa de aici 칥nseamn캒 c캒 fiecare implementare a lui `IntoIterator` "
"trebuie s캒 declare dou캒 tipuri:"

#: src/iterators/intoiterator.md
#, fuzzy
msgid "`Item`: the type to iterate over, such as `i8`,"
msgstr "`Item`: tipul peste care iter캒m, cum ar fi `i8`,"

#: src/iterators/intoiterator.md
#, fuzzy
msgid "`IntoIter`: the `Iterator` type returned by the `into_iter` method."
msgstr "`IntoIter`: tipul `Iterator` returnat de metoda `into_iter`."

#: src/iterators/intoiterator.md
#, fuzzy
msgid ""
"Note that `IntoIter` and `Item` are linked: the iterator must have the same "
"`Item` type, which means that it returns `Option<Item>`"
msgstr ""
"Re탵ine탵i c캒 `IntoIter` 탳i `Item` sunt legate: iteratorul trebuie s캒 aib캒 "
"acela탳i tip `Item`, ceea ce 칥nseamn캒 c캒 returneaz캒 `Op탵iune`<Item>`"

#: src/iterators/intoiterator.md
#, fuzzy
msgid "The example iterates over all combinations of x and y coordinates."
msgstr "Exemplul itera peste toate combina탵iile de coordonate x 탳i y."

#: src/iterators/intoiterator.md
#, fuzzy
msgid ""
"Try iterating over the grid twice in `main`. Why does this fail? Note that "
"`IntoIterator::into_iter` takes ownership of `self`."
msgstr ""
"칉ncerca탵i s캒 itera탵i peste gril캒 de dou캒 ori 칥n `main`. De ce nu reu탳e탳te "
"acest lucru? Re탵ine탵i c캒 `IntoIterator::into_iter` preia proprietatea lui "
"`self`."

#: src/iterators/intoiterator.md
#, fuzzy
msgid ""
"Fix this issue by implementing `IntoIterator` for `&Grid` and storing a "
"reference to the `Grid` in `GridIter`."
msgstr ""
"Rezolva탵i aceast캒 problem캒 implement칙nd `IntoIterator` pentru `&Grid` 탳i "
"stoc칙nd o referin탵캒 la `Grid` 칥n `GridIter`."

#: src/iterators/intoiterator.md
#, fuzzy
msgid ""
"The same problem can occur for standard library types: `for e in "
"some_vector` will take ownership of `some_vector` and iterate over owned "
"elements from that vector. Use `for e in &some_vector` instead, to iterate "
"over references to elements of `some_vector`."
msgstr ""
"Aceea탳i problem캒 poate ap캒rea 탳i 칥n cazul tipurilor din biblioteca standard: "
"`for e in some_vector` va prelua proprietatea lui `some_vector` 탳i va itera "
"peste elementele de탵inute din acel vector. Folosi탵i 칥n schimb `for e in "
"&some_vector` pentru a itera peste referin탵ele la elementele din "
"`some_vector`."

#: src/iterators/fromiterator.md
msgid "FromIterator"
msgstr "FromIterator"

#: src/iterators/fromiterator.md
#, fuzzy
msgid ""
"[`FromIterator`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html) "
"lets you build a collection from an [`Iterator`](https://doc.rust-lang.org/"
"std/iter/trait.Iterator.html)."
msgstr ""
"[`FromIterator`]](https://doc.rust-lang.org/std/iter/trait.FromIterator."
"html) v캒 permite s캒 construi탵i o colec탵ie dintr-un [`Iterator`](https://doc."
"rust-lang.org/std/iter/trait.Iterator.html)."

#: src/iterators/fromiterator.md
#, fuzzy
msgid "\"prime_squares: {prime_squares:?}\""
msgstr "\"prime_squares: {prime_squares:?}\""

#: src/iterators/fromiterator.md
#, fuzzy
msgid "`Iterator` implements"
msgstr "`Iterator`"

#: src/iterators/fromiterator.md
#, fuzzy
msgid "There are two ways to specify `B` for this method:"
msgstr "Exist캒 dou캒 moduri de a specifica `B` pentru aceast캒 metod캒:"

#: src/iterators/fromiterator.md
#, fuzzy
msgid ""
"With the \"turbofish\": `some_iterator.collect::<COLLECTION_TYPE>()`, as "
"shown. The `_` shorthand used here lets Rust infer the type of the `Vec` "
"elements."
msgstr ""
"Cu \"turbofish\": `some_iterator.collect::<COLLECTION_TYPE>()`, dup캒 cum se "
"arat캒. Prescurtarea `_` folosit캒 aici 칥i permite lui Rust s캒 deduc캒 tipul "
"elementelor `Vec`."

#: src/iterators/fromiterator.md
#, fuzzy
msgid ""
"With type inference: `let prime_squares: Vec<_> = some_iterator.collect()`. "
"Rewrite the example to use this form."
msgstr ""
"Cu inferen탵캒 de tip: `let prime_squares: Vec<_> = some_iterator.collect()`. "
"Rescrie탵i exemplul pentru a utiliza aceast캒 form캒."

#: src/iterators/fromiterator.md
#, fuzzy
msgid ""
"There are basic implementations of `FromIterator` for `Vec`, `HashMap`, etc. "
"There are also more specialized implementations which let you do cool things "
"like convert an `Iterator<Item = Result<V, E>>` into a `Result<Vec<V>, E>`."
msgstr ""
"Exist캒, de asemenea, implement캒ri care v캒 permit s캒 face탵i lucruri "
"interesante, cum ar fi convertirea unui `Iterator&lt;Item = Rezultat<V, "
"E>&gt;` 칥ntr-un `Resultat&lt;Vec<V>, E&gt;`."

#: src/iterators/exercise.md
#, fuzzy
msgid ""
"In this exercise, you will need to find and use some of the provided methods "
"in the [`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) "
"trait to implement a complex calculation."
msgstr ""
"Pute탵i implementa tr캒s캒tura [`Iterator`](https://doc.rust-lang.org/std/iter/"
"trait.Iterator.html) pe propriile tipuri:"

#: src/iterators/exercise.md
#, fuzzy
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and make the tests "
"pass. Use an iterator expression and `collect` the result to construct the "
"return value."
msgstr ""
"Copia탵i urm캒torul cod 칥n <https://play.rust-lang.org/> 탳i face탵i ca testele "
"s캒 treac캒. 칉ncerca탵i s캒 evita탵i s캒 aloca탵i un `Vec` pentru rezultatele "
"intermediare:"

#: src/iterators/exercise.md src/iterators/solution.md
#, fuzzy
msgid ""
"/// Calculate the differences between elements of `values` offset by "
"`offset`,\n"
"/// wrapping around from the end of `values` to the beginning.\n"
"///\n"
"/// Element `n` of the result is `values[(n+offset)%len] - values[n]`.\n"
msgstr ""
"/// Calculeaz캒 diferen탵ele dintre elementele din `valorile` decalate cu "
"`offset`,\n"
"/// 칥nf캒탳ur칙ndu-se de la sf칙r탳itul lui `values` la 칥nceput.\n"
"///\n"
"/// Elementul `n` al rezultatului este `values[(n+offset)%len] - "
"values[n]`.\n"

#: src/modules.md
#, fuzzy
msgid "[Modules](./modules/modules.md) (3 minutes)"
msgstr "[Module](./module/modules/modules.md) (5 minute)"

#: src/modules.md
#, fuzzy
msgid "[Filesystem Hierarchy](./modules/filesystem.md) (5 minutes)"
msgstr "[Ierarhia sistemului de fi탳iere](./modules/filesystem.md) (5 minute)"

#: src/modules.md
#, fuzzy
msgid "[Visibility](./modules/visibility.md) (5 minutes)"
msgstr "[Vizibilitate](./modules/visibility.md) (5 minute)"

#: src/modules.md
#, fuzzy
msgid "[use, super, self](./modules/paths.md) (10 minutes)"
msgstr "[use, super, self](./modules/paths.md) (10 minute)"

#: src/modules.md
#, fuzzy
msgid ""
"[Exercise: Modules for a GUI Library](./modules/exercise.md) (15 minutes)"
msgstr ""
"[Exerci탵iu: Module pentru o bibliotec캒 GUI](./modules/exercise.md) (15 "
"minute)"

#: src/modules/modules.md
#, fuzzy
msgid "We have seen how `impl` blocks let us namespace functions to a type."
msgstr ""
"Am v캒zut cum blocurile `impl` ne permit s캒 atribuim func탵ii de namespace la "
"un tip."

#: src/modules/modules.md
#, fuzzy
msgid "Similarly, `mod` lets us namespace types and functions:"
msgstr ""
"칉n mod similar, `mod` ne permite s캒 folosim tipuri 탳i func탵ii de spa탵iu de "
"nume:"

#: src/modules/modules.md
#, fuzzy
msgid "\"In the foo module\""
msgstr "\"칉n modulul foo\""

#: src/modules/modules.md
#, fuzzy
msgid "\"In the bar module\""
msgstr "\"칉n modulul de bar\""

#: src/modules/modules.md
#, fuzzy
msgid ""
"Packages provide functionality and include a `Cargo.toml` file that "
"describes how to build a bundle of 1+ crates."
msgstr ""
"Pachetele ofer캒 func탵ionalitate 탳i includ un fi탳ier `Cargo.toml` care "
"descrie cum se construie탳te un pachet de 1+ crates."

#: src/modules/modules.md
#, fuzzy
msgid ""
"Crates are a tree of modules, where a binary crate creates an executable and "
"a library crate compiles to a library."
msgstr ""
"Crates reprezint캒 un arbore de module, 칥n care un crate binar creeaz캒 un "
"executabil, iar un crate de bibliotec캒 compileaz캒 o bibliotec캒."

#: src/modules/modules.md
#, fuzzy
msgid "Modules define organization, scope, and are the focus of this section."
msgstr ""
"Modulele definesc organizarea, domeniul de aplicare 탳i reprezint캒 punctul "
"central al acestei sec탵iuni."

#: src/modules/filesystem.md
#, fuzzy
msgid ""
"Omitting the module content will tell Rust to look for it in another file:"
msgstr ""
"Omiterea con탵inutului modulului 칥i va spune lui Rust s캒 칥l caute 칥ntr-un alt "
"fi탳ier:"

#: src/modules/filesystem.md
#, fuzzy
msgid ""
"This tells rust that the `garden` module content is found at `src/garden."
"rs`. Similarly, a `garden::vegetables` module can be found at `src/garden/"
"vegetables.rs`."
msgstr ""
"Acest lucru 칥i spune lui Rust c캒 con탵inutul modulului `garden` se g캒se탳te la "
"`src/garden.rs`. 칉n mod similar, un modul `garden::vegetables` se g캒se탳te la "
"`src/garden/vegetables.rs`."

#: src/modules/filesystem.md
#, fuzzy
msgid "The `crate` root is in:"
msgstr "R캒d캒cina `crate` este 칥n:"

#: src/modules/filesystem.md
#, fuzzy
msgid "`src/lib.rs` (for a library crate)"
msgstr "`src/lib.rs` (pentru o bibliotec캒)"

#: src/modules/filesystem.md
#, fuzzy
msgid "`src/main.rs` (for a binary crate)"
msgstr "`src/main.rs` (pentru un crate binar)"

#: src/modules/filesystem.md
#, fuzzy
msgid ""
"Modules defined in files can be documented, too, using \"inner doc "
"comments\". These document the item that contains them -- in this case, a "
"module."
msgstr ""
"Modulele definite 칥n fi탳iere pot fi, de asemenea, documentate, folosind "
"\"inner doc comments\". Acestea documenteaz캒 elementul care le con탵ine - 칥n "
"acest caz, un modul."

#: src/modules/filesystem.md
#, fuzzy
msgid ""
"//! This module implements the garden, including a highly performant "
"germination\n"
"//! implementation.\n"
msgstr ""
"//! Acest modul implementeaz캒 gr캒dina, inclusiv o germina탵ie foarte "
"performant캒\n"
"//! foarte performant캒.\n"

#: src/modules/filesystem.md
#, fuzzy
msgid "// Re-export types from this module.\n"
msgstr "// Reexporta탵i tipurile din acest modul.\n"

#: src/modules/filesystem.md
#, fuzzy
msgid "/// Sow the given seed packets.\n"
msgstr "/// Sem캒na탵i pachetele de semin탵e date.\n"

#: src/modules/filesystem.md
#, fuzzy
msgid "/// Harvest the produce in the garden that is ready.\n"
msgstr "/// Recolta탵i produsele din gr캒din캒 care sunt gata.\n"

#: src/modules/filesystem.md
#, fuzzy
msgid ""
"Before Rust 2018, modules needed to be located at `module/mod.rs` instead of "
"`module.rs`, and this is still a working alternative for editions after 2018."
msgstr ""
"칉nainte de Rust 2018, modulele trebuiau s캒 fie localizate la `module/mod.rs` "
"칥n loc de `module.rs`, iar aceasta este 칥nc캒 o alternativ캒 func탵ional캒 "
"pentru edi탵iile dup캒 2018."

#: src/modules/filesystem.md
#, fuzzy
msgid ""
"The main reason to introduce `filename.rs` as alternative to `filename/mod."
"rs` was because many files named `mod.rs` can be hard to distinguish in IDEs."
msgstr ""
"Motivul principal pentru care s-a introdus `filename.rs` ca alternativ캒 la "
"`filename/mod.rs` a fost acela c캒 multe fi탳iere numite `mod.rs` pot fi greu "
"de distins 칥n IDE-uri."

#: src/modules/filesystem.md
#, fuzzy
msgid "Deeper nesting can use folders, even if the main module is a file:"
msgstr ""
"칉n cazul 칥n care este vorba de o 칥nglobare mai profund캒, se pot utiliza "
"dosare, chiar dac캒 modulul principal este un fi탳ier:"

#: src/modules/filesystem.md
#, fuzzy
msgid ""
"The place rust will look for modules can be changed with a compiler "
"directive:"
msgstr ""
"Locul 칥n care rust va c캒uta modulele poate fi schimbat cu o directiv캒 de "
"compilare:"

#: src/modules/filesystem.md
#, fuzzy
msgid "\"some/path.rs\""
msgstr "\"some/path.rs\""

#: src/modules/filesystem.md
#, fuzzy
msgid ""
"This is useful, for example, if you would like to place tests for a module "
"in a file named `some_module_test.rs`, similar to the convention in Go."
msgstr ""
"Acest lucru este util, de exemplu, dac캒 dori탵i s캒 plasa탵i testele pentru un "
"modul 칥ntr-un fi탳ier numit `some_module_test.rs`, similar conven탵iei din Go."

#: src/modules/visibility.md
#, fuzzy
msgid "Modules are a privacy boundary:"
msgstr "Modulele reprezint캒 o limit캒 de confiden탵ialitate:"

#: src/modules/visibility.md
#, fuzzy
msgid "Module items are private by default (hides implementation details)."
msgstr ""
"Elementele modulului sunt private 칥n mod implicit (ascunde detaliile de "
"implementare)."

#: src/modules/visibility.md
#, fuzzy
msgid "Parent and sibling items are always visible."
msgstr "Elementele p캒rin탵ilor 탳i ale fra탵ilor sunt 칥ntotdeauna vizibile."

#: src/modules/visibility.md
#, fuzzy
msgid ""
"In other words, if an item is visible in module `foo`, it's visible in all "
"the descendants of `foo`."
msgstr ""
"Cu alte cuvinte, dac캒 un element este vizibil 칥n modulul `foo`, el este "
"vizibil 칥n to탵i descenden탵ii lui `foo`."

#: src/modules/visibility.md
#, fuzzy
msgid "\"outer::private\""
msgstr "\"outer::private\""

#: src/modules/visibility.md
#, fuzzy
msgid "\"outer::public\""
msgstr "\"outer::public\""

#: src/modules/visibility.md
#, fuzzy
msgid "\"outer::inner::private\""
msgstr "\"outer::inner::private\""

#: src/modules/visibility.md
#, fuzzy
msgid "\"outer::inner::public\""
msgstr "\"outer::inner::public\""

#: src/modules/visibility.md
#, fuzzy
msgid "Use the `pub` keyword to make modules public."
msgstr "Utiliza탵i cuv칙ntul cheie `pub` pentru a face modulele publice."

#: src/modules/visibility.md
#, fuzzy
msgid ""
"Additionally, there are advanced `pub(...)` specifiers to restrict the scope "
"of public visibility."
msgstr ""
"칉n plus, exist캒 specificatori avansa탵i `pub(...)` pentru a restric탵iona "
"domeniul de aplicare al vizibilit캒탵ii publice."

#: src/modules/visibility.md
#, fuzzy
msgid ""
"See the [Rust Reference](https://doc.rust-lang.org/reference/visibility-and-"
"privacy.html#pubin-path-pubcrate-pubsuper-and-pubself)."
msgstr ""
"A se vedea [Rust Reference](https://doc.rust-lang.org/reference/visibility-"
"and-privacy.html#pubin-path-pubcrate-pubsuper-and-pubself)."

#: src/modules/visibility.md
#, fuzzy
msgid "Configuring `pub(crate)` visibility is a common pattern."
msgstr "Configurarea vizibilit캒탵ii `pub(crate)` este un model comun."

#: src/modules/visibility.md
#, fuzzy
msgid "Less commonly, you can give visibility to a specific path."
msgstr "Mai rar, pute탵i oferi vizibilitate unei anumite c캒i de acces."

#: src/modules/visibility.md
#, fuzzy
msgid ""
"In any case, visibility must be granted to an ancestor module (and all of "
"its descendants)."
msgstr ""
"칉n orice caz, vizibilitatea trebuie s캒 fie acordat캒 unui modul str캒mo탳 (탳i "
"tuturor descenden탵ilor s캒i)."

#: src/modules/paths.md
#, fuzzy
msgid "use, super, self"
msgstr "`use`, `super`, `self`"

#: src/modules/paths.md
#, fuzzy
msgid ""
"A module can bring symbols from another module into scope with `use`. You "
"will typically see something like this at the top of each module:"
msgstr ""
"Un modul poate aduce simboluri dintr-un alt modul 칥n domeniul de aplicare cu "
"`use`. De obicei, ve탵i vedea ceva de genul acesta 칥n partea de sus a "
"fiec캒rui modul:"

#: src/modules/paths.md
msgid "Paths"
msgstr "Trasee"

#: src/modules/paths.md
#, fuzzy
msgid "Paths are resolved as follows:"
msgstr "C캒ile de acces se rezolv캒 dup캒 cum urmeaz캒:"

#: src/modules/paths.md
#, fuzzy
msgid "As a relative path:"
msgstr "Ca o cale relativ캒:"

#: src/modules/paths.md
#, fuzzy
msgid "`foo` or `self::foo` refers to `foo` in the current module,"
msgstr "`foo` sau `self::foo` se refer캒 la `foo` din modulul curent,"

#: src/modules/paths.md
#, fuzzy
msgid "`super::foo` refers to `foo` in the parent module."
msgstr "`super::foo` se refer캒 la `foo` din modulul p캒rinte."

#: src/modules/paths.md
#, fuzzy
msgid "As an absolute path:"
msgstr "Ca o cale absolut캒:"

#: src/modules/paths.md
#, fuzzy
msgid "`crate::foo` refers to `foo` in the root of the current crate,"
msgstr "`crate::foo` se refer캒 la `foo` din r캒d캒cina cratei curente,"

#: src/modules/paths.md
#, fuzzy
msgid "`bar::foo` refers to `foo` in the `bar` crate."
msgstr "`bar::foo` se refer캒 la `foo` din cadrul `bar` crate."

#: src/modules/paths.md
#, fuzzy
msgid ""
"It is common to \"re-export\" symbols at a shorter path. For example, the "
"top-level `lib.rs` in a crate might have"
msgstr ""
"Se obi탳nuie탳te s캒 se \"reexporte\" simboluri pe o cale mai scurt캒. De "
"exemplu, la nivelul superior `lib.rs` dintr-o cutie poate avea"

#: src/modules/paths.md
#, fuzzy
msgid ""
"making `DiskStorage` and `NetworkStorage` available to other crates with a "
"convenient, short path."
msgstr ""
"f캒c칙nd ca `DiskStorage` 탳i `NetworkStorage` s캒 fie disponibile pentru alte "
"crates cu o cale scurt캒 탳i convenabil캒."

#: src/modules/paths.md
#, fuzzy
msgid ""
"For the most part, only items that appear in a module need to be `use`'d. "
"However, a trait must be in scope to call any methods on that trait, even if "
"a type implementing that trait is already in scope. For example, to use the "
"`read_to_string` method on a type implementing the `Read` trait, you need to "
"`use std::io::Read`."
msgstr ""
"칉n cea mai mare parte, numai elementele care apar 칥ntr-un modul trebuie s캒 "
"fie \"utilizate\". Cu toate acestea, o tr캒s캒tur캒 trebuie s캒 se afle 칥n "
"domeniul de aplicare pentru a apela orice metod캒 a acelei tr캒s캒turi, chiar "
"dac캒 un tip care implementeaz캒 acea tr캒s캒tur캒 se afl캒 deja 칥n domeniul de "
"aplicare. De exemplu, pentru a utiliza metoda `read_to_string` pe un tip "
"care implementeaz캒 tr캒s캒tura `Read`, trebuie s캒 `use std::io::Read`."

#: src/modules/paths.md
#, fuzzy
msgid ""
"The `use` statement can have a wildcard: `use std::io::*`. This is "
"discouraged because it is not clear which items are imported, and those "
"might change over time."
msgstr ""
"Instruc탵iunea `use` poate avea un wildcard: `use std::io::*`. Acest lucru "
"este descurajat deoarece nu este clar ce elemente sunt importate, iar "
"acestea se pot schimba 칥n timp."

#: src/modules/exercise.md
#, fuzzy
msgid ""
"In this exercise, you will reorganize a small GUI Library implementation. "
"This library defines a `Widget` trait and a few implementations of that "
"trait, as well as a `main` function."
msgstr ""
"칉n acest exerci탵iu, ve탵i reorganiza o mic캒 implementare a unei biblioteci "
"GUI. Aceast캒 bibliotec캒 define탳te o tr캒s캒tur캒 `Widget` 탳i c칙teva "
"implement캒ri ale acestei tr캒s캒turi, precum 탳i o func탵ie `main`."

#: src/modules/exercise.md
#, fuzzy
msgid ""
"It is typical to put each type or set of closely-related types into its own "
"module, so each widget type should get its own module."
msgstr ""
"De obicei, fiecare tip sau set de tipuri str칙ns legate 칥ntre ele este inclus "
"칥n propriul modul, astfel 칥nc칙t fiecare tip de widget ar trebui s캒 aib캒 "
"propriul s캒u modul."

#: src/modules/exercise.md
#, fuzzy
msgid "Cargo Setup"
msgstr "Setare"

#: src/modules/exercise.md
#, fuzzy
msgid ""
"The Rust playground only supports one file, so you will need to make a Cargo "
"project on your local filesystem:"
msgstr ""
"Locul de joac캒 Rust accept캒 doar un singur fi탳ier, a탳a c캒 va trebui s캒 "
"crea탵i un proiect Cargo 칥n sistemul de fi탳iere local:"

#: src/modules/exercise.md
#, fuzzy
msgid ""
"Edit the resulting `src/main.rs` to add `mod` statements, and add additional "
"files in the `src` directory."
msgstr ""
"Modifica탵i fi탳ierul `src/main.rs` rezultat pentru a ad캒uga declara탵iile "
"`mod` 탳i ad캒uga탵i fi탳iere suplimentare 칥n directorul `src`."

#: src/modules/exercise.md
msgid "Source"
msgstr "Surs캒"

#: src/modules/exercise.md
#, fuzzy
msgid "Here's the single-module implementation of the GUI library:"
msgstr "Iat캒 implementarea unui singur modul al bibliotecii GUI:"

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "/// Natural width of `self`.\n"
msgstr "/// L캒탵imea natural캒 a lui `self`.\n"

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "/// Draw the widget into a buffer.\n"
msgstr "/// Desena탵i widget-ul 칥ntr-un buffer.\n"

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "/// Draw the widget on standard output.\n"
msgstr "/// Deseneaz캒 widget-ul pe ie탳irea standard.\n"

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "\"{buffer}\""
msgstr "\"{buffer}\""

#: src/modules/exercise.md
#, fuzzy
msgid "// Add 4 paddings for borders\n"
msgstr "// Ad캒uga탵i 4 padding-uri pentru margini\n"

#: src/modules/exercise.md
#, fuzzy
msgid ""
"// TODO: Change draw_into to return Result<(), std::fmt::Error>. Then use "
"the\n"
"        // ?-operator here instead of .unwrap().\n"
msgstr ""
"// TODO: Modifica탵i draw_into pentru a returna Result<(), std::fmt::Error>. "
"Apoi, utiliza탵i\n"
"        // ?-operator aici 칥n loc de .unwrap().\n"

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "\"+-{:-<inner_width$}-+\""
msgstr "\"+-{:-<inner_width$}-+\""

#: src/modules/exercise.md src/modules/solution.md src/testing/unit-tests.md
#: src/testing/solution.md
#, fuzzy
msgid "\"\""
msgstr "\"\""

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "\"| {:^inner_width$} |\""
msgstr "\"| {:^inner_width$} |\""

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "\"+={:=<inner_width$}=+\""
msgstr "\"+={:=<inner_width$}=+\""

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "\"| {:inner_width$} |\""
msgstr "\"| {:inner_width$} |\""

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "// add a bit of padding\n"
msgstr "// ad캒uga탵i un pic de umplutur캒\n"

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "\"+{:-<width$}+\""
msgstr "\"+{:-<width$}+\""

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "\"|{:^width$}|\""
msgstr "\"|{:^width$}|\""

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "\"Rust GUI Demo 1.23\""
msgstr "\"Rust GUI Demo 1.23\""

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "\"This is a small text GUI demo.\""
msgstr "\"Acesta este un mic text demonstrativ GUI.\""

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "\"Click me!\""
msgstr "\"Face탵i clic pe mine!\""

#: src/modules/exercise.md
#, fuzzy
msgid ""
"Encourage students to divide the code in a way that feels natural for them, "
"and get accustomed to the required `mod`, `use`, and `pub` declarations. "
"Afterward, discuss what organizations are most idiomatic."
msgstr ""
"칉ncuraja탵i elevii s캒 칥mpart캒 codul 칥ntr-un mod natural pentru ei 탳i s캒 se "
"obi탳nuiasc캒 cu declara탵iile obligatorii `mod`, `use` 탳i `pub`. Dup캒 aceea, "
"discuta탵i ce organiza탵ii sunt cele mai idiomatice."

#: src/modules/solution.md
#, fuzzy
msgid "// ---- src/widgets.rs ----\n"
msgstr "// ---- src/widgets.rs ---- ----\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ---- src/widgets/label.rs ----\n"
msgstr "// ---- src/widgets/label.rs ---- ----\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ANCHOR_END: Label-width\n"
msgstr "// ANCHOR_END: L캒탵imea etichetei\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ANCHOR: Label-draw_into\n"
msgstr "// ANCHET캑: Label-draw_into\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ANCHOR_END: Label-draw_into\n"
msgstr "// ANCHOR_END: Eticheta-drapeaz캒_칥n\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ---- src/widgets/button.rs ----\n"
msgstr "// ---- src/widgets/button.rs ---- ----\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ANCHOR_END: Button-width\n"
msgstr "// ANCHOR_END: L캒탵imea butonului\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ANCHOR: Button-draw_into\n"
msgstr "// ANCHET캑: Button-draw_into\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ANCHOR_END: Button-draw_into\n"
msgstr "// ANCHOR_END: Buton-draw_into\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ---- src/widgets/window.rs ----\n"
msgstr "// ---- src/widgets/window.rs ---- ----\n"

#: src/modules/solution.md
#, fuzzy
msgid ""
"// ANCHOR_END: Window-width\n"
"        // Add 4 paddings for borders\n"
msgstr ""
"// ANCHOR_END: L캒탵imea ferestrei\n"
"        // Ad캒uga탵i 4 padding-uri pentru margini\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ANCHOR: Window-draw_into\n"
msgstr "// ANCHET캑: Window-draw_into\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ANCHOR_END: Window-draw_into\n"
msgstr "// ANCHOR_END: Window-draw_into\n"

#: src/modules/solution.md
#, fuzzy
msgid ""
"// TODO: after learning about error handling, you can change\n"
"        // draw_into to return Result<(), std::fmt::Error>. Then use\n"
"        // the ?-operator here instead of .unwrap().\n"
msgstr ""
"// TODO: dup캒 ce a탵i 칥nv캒탵at despre gestionarea erorilor, pute탵i schimba\n"
"        // draw_into pentru a returna Result<(), std::fmt::Error>. Apoi, "
"utiliza탵i\n"
"        // operatorul ?- aici 칥n loc de .unwrap().\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ---- src/main.rs ----\n"
msgstr "// ---- src/main.rs ----\n"

#: src/testing.md
#, fuzzy
msgid "[Test Modules](./testing/unit-tests.md) (5 minutes)"
msgstr "[Module de testare](./testing/unit-tests.md) (5 minute)"

#: src/testing.md
#, fuzzy
msgid "[Other Types of Tests](./testing/other.md) (5 minutes)"
msgstr "[Alte tipuri de teste](./testing/other.md) (10 minute)"

#: src/testing.md
#, fuzzy
msgid "[Compiler Lints and Clippy](./testing/lints.md) (3 minutes)"
msgstr "[Compilatorul Lints 탳i Clippy](./testing/lints.md) (5 minute)"

#: src/testing.md
#, fuzzy
msgid "[Exercise: Luhn Algorithm](./testing/exercise.md) (30 minutes)"
msgstr "[Exerci탵iu: Algoritmul Luhn](./testing/exerci탵iu.md) (30 minute)"

#: src/testing/unit-tests.md
msgid "Unit Tests"
msgstr "Teste unitare"

#: src/testing/unit-tests.md
#, fuzzy
msgid "Rust and Cargo come with a simple unit test framework:"
msgstr "Rust 탳i Cargo vin cu un cadru simplu de testare a unit캒탵ilor:"

#: src/testing/unit-tests.md
#, fuzzy
msgid "Unit tests are supported throughout your code."
msgstr "Testele unitare sunt acceptate 칥n tot codul dumneavoastr캒."

#: src/testing/unit-tests.md
#, fuzzy
msgid "Integration tests are supported via the `tests/` directory."
msgstr ""
"Testele de integrare sunt suportate prin intermediul directorului `tests/`."

#: src/testing/unit-tests.md
#, fuzzy
msgid ""
"Tests are marked with `#[test]`. Unit tests are often put in a nested "
"`tests` module, using `#[cfg(test)]` to conditionally compile them only when "
"building tests."
msgstr ""
"Testele sunt marcate cu `#[test]`. Testele unitare sunt deseori plasate 칥ntr-"
"un modul `tests` imbricate, folosind `#[cfg(test)]` pentru a le compila "
"condi탵ionat numai atunci c칙nd se construiesc testele."

#: src/testing/unit-tests.md
#, fuzzy
msgid "\"Hello World\""
msgstr "Bun캒 lume"

#: src/testing/unit-tests.md
#, fuzzy
msgid "This lets you unit test private helpers."
msgstr "Acest lucru v캒 permite s캒 testa탵i unitar ajutoarele private."

#: src/testing/unit-tests.md
#, fuzzy
msgid "The `#[cfg(test)]` attribute is only active when you run `cargo test`."
msgstr ""
"Atributul `#[cfg(test)]` este activ numai atunci c칙nd executa탵i `cargo test`."

#: src/testing/unit-tests.md
#, fuzzy
msgid "Run the tests in the playground in order to show their results."
msgstr ""
"Executa탵i testele 칥n locul de joac캒 pentru a ar캒ta rezultatele acestora."

#: src/testing/other.md
msgid "Integration Tests"
msgstr "Teste de integrare"

#: src/testing/other.md
#, fuzzy
msgid "If you want to test your library as a client, use an integration test."
msgstr ""
"Dac캒 dori탵i s캒 v캒 testa탵i biblioteca ca 탳i client, utiliza탵i un test de "
"integrare."

#: src/testing/other.md
#, fuzzy
msgid "Create a `.rs` file under `tests/`:"
msgstr "Crea탵i un fi탳ier `.rs` 칥n `tests/`:"

#: src/testing/other.md
#, fuzzy
msgid "// tests/my_library.rs\n"
msgstr "// tests/my_library.rs\n"

#: src/testing/other.md
#, fuzzy
msgid "These tests only have access to the public API of your crate."
msgstr "Aceste teste au acces numai la API-ul public al seriei dumneavoastr캒."

#: src/testing/other.md
msgid "Documentation Tests"
msgstr "Teste de documentare"

#: src/testing/other.md
#, fuzzy
msgid "Rust has built-in support for documentation tests:"
msgstr "Rust are un suport 칥ncorporat pentru testele de documentare:"

#: src/testing/other.md
#, fuzzy
msgid ""
"/// Shortens a string to the given length.\n"
"///\n"
"/// ```\n"
"/// # use playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"
msgstr ""
"```rust\n"
"/// Scurteaz캒 un 탳ir de caractere la lungimea dat캒.\n"
"///\n"
"/// ```\n"
"/// # folose탳te playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"
"pub fn shorten_string(s: &str, length: usize) -> &str {\n"
"    &s[..std::cmp::min(length, s.len())]]\n"
"}\n"
"```"

#: src/testing/other.md
#, fuzzy
msgid "Code blocks in `///` comments are automatically seen as Rust code."
msgstr ""
"Blocurile de cod din comentariile `///` sunt considerate automat ca fiind "
"cod Rust."

#: src/testing/other.md
#, fuzzy
msgid "The code will be compiled and executed as part of `cargo test`."
msgstr "Codul va fi compilat 탳i executat ca parte din `cargo test`."

#: src/testing/other.md
#, fuzzy
msgid ""
"Adding `#` in the code will hide it from the docs, but will still compile/"
"run it."
msgstr ""
"Ad캒ugarea lui `# ` 칥n cod 칥l va ascunde din documenta탵ie, dar 칥l va compila/"
"executa 칥n continuare."

#: src/testing/other.md
#, fuzzy
msgid ""
"Test the above code on the [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."
msgstr ""
"Testa탵i codul de mai sus pe [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."

#: src/testing/lints.md
#, fuzzy
msgid ""
"The Rust compiler produces fantastic error messages, as well as helpful "
"built-in lints. [Clippy](https://doc.rust-lang.org/clippy/) provides even "
"more lints, organized into groups that can be enabled per-project."
msgstr ""
"Compilatorul Rust produce mesaje de eroare fantastice, precum 탳i indica탵ii "
"칥ncorporate utile. [Clippy](https://doc.rust-lang.org/clippy/) ofer캒 탳i mai "
"multe indicii, organizate 칥n grupuri care pot fi activate pentru fiecare "
"proiect 칥n parte."

#: src/testing/lints.md
#, fuzzy
msgid "\"X probably fits in a u16, right? {}\""
msgstr "\"X probabil c캒 칥ncape 칥ntr-un u16, nu? {}\""

#: src/testing/lints.md
#, fuzzy
msgid ""
"Run the code sample and examine the error message. There are also lints "
"visible here, but those will not be shown once the code compiles. Switch to "
"the Playground site to show those lints."
msgstr ""
"Rula탵i exemplul de cod 탳i examina탵i mesajul de eroare. Aici sunt vizibile 탳i "
"linte, dar acestea nu vor fi afi탳ate odat캒 ce codul se compileaz캒. Trece탵i "
"la site-ul Playground pentru a afi탳a aceste linte."

#: src/testing/lints.md
#, fuzzy
msgid ""
"After resolving the lints, run `clippy` on the playground site to show "
"clippy warnings. Clippy has extensive documentation of its lints, and adds "
"new lints (including default-deny lints) all the time."
msgstr ""
"Dup캒 ce a탵i rezolvat problemele, rula탵i `clippy` pe site-ul locului de joac캒 "
"pentru a afi탳a avertismentele clippy. Clippy are o documenta탵ie extins캒 a "
"lints-urilor sale 탳i adaug캒 noi lints (inclusiv lints default-deny) tot "
"timpul."

#: src/testing/lints.md
#, fuzzy
msgid ""
"Note that errors or warnings with `help: ...` can be fixed with `cargo fix` "
"or via your editor."
msgstr ""
"Re탵ine탵i c캒 erorile sau avertismentele cu `help: ...` pot fi corectate cu "
"`cargo fix` sau prin intermediul editorului dumneavoastr캒."

#: src/testing/exercise.md
msgid "Luhn Algorithm"
msgstr "Algoritmul Luhn"

#: src/testing/exercise.md
msgid ""
"The [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm) is used "
"to validate credit card numbers. The algorithm takes a string as input and "
"does the following to validate the credit card number:"
msgstr ""
"[Algoritmul Luhn](https://en.wikipedia.org/wiki/Luhn_algorithm) este "
"utilizat pentru a valida numerele cardurilor de credit. Algoritmul prime탳te "
"un 탳ir de caractere ca intrare 탳i face urm캒toarele opera탵ii pentru a valida "
"num캒rul cardului de credit:"

#: src/testing/exercise.md
#, fuzzy
msgid "Ignore all spaces. Reject number with fewer than two digits."
msgstr "Ignor캒 toate spa탵iile. Respinge num캒rul cu mai pu탵in de dou캒 cifre."

#: src/testing/exercise.md
#, fuzzy
msgid ""
"Moving from **right to left**, double every second digit: for the number "
"`1234`, we double `3` and `1`. For the number `98765`, we double `6` and `8`."
msgstr ""
"Merg칙nd de la **dreapta la st칙nga**, se dubleaz캒 fiecare a doua cifr캒: "
"pentru num캒rul `1234`, dubl캒m `3` 탳i `1`. Pentru num캒rul `98765`, se "
"dubleaz캒 `6` 탳i `8`."

#: src/testing/exercise.md
msgid ""
"After doubling a digit, sum the digits if the result is greater than 9. So "
"doubling `7` becomes `14` which becomes `1 + 4 = 5`."
msgstr ""
"Dup캒 ce o cifr캒 a fost dublat캒, se adun캒 cifrele dac캒 rezultatul este mai "
"mare de 9. Astfel, c칙nd se dubleaz캒 `7` se ob탵ine `14` care devine `1 + 4 = "
"5`."

#: src/testing/exercise.md
msgid "Sum all the undoubled and doubled digits."
msgstr "Se adun캒 toate cifrele nedublate 탳i dublate."

#: src/testing/exercise.md
msgid "The credit card number is valid if the sum ends with `0`."
msgstr "Num캒rul cardului de credit este valabil dac캒 suma se termin캒 cu `0`."

#: src/testing/exercise.md
#, fuzzy
msgid ""
"The provided code provides a buggy implementation of the luhn algorithm, "
"along with two basic unit tests that confirm that most the algorithm is "
"implemented correctly."
msgstr ""
"Codul furnizat ofer캒 o implementare eronat캒 a algoritmului luhn, 칥mpreun캒 cu "
"dou캒 teste unitare de baz캒 care confirm캒 c캒 majoritatea algoritmului este "
"implementat corect."

#: src/testing/exercise.md
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and write additional "
"tests to uncover bugs in the provided implementation, fixing any bugs you "
"find."
msgstr ""
"Copia탵i codul de mai jos 칥n <https://play.rust-lang.org/> 탳i completa탵i "
"func탵iile 탳i metodele care lipsesc:"

#: src/testing/exercise.md src/testing/solution.md
#, fuzzy
msgid "\"4263 9826 4026 9299\""
msgstr "\"4263 9826 4026 9299\""

#: src/testing/exercise.md src/testing/solution.md
#, fuzzy
msgid "\"4539 3195 0343 6467\""
msgstr "\"4539 3195 0343 6467\""

#: src/testing/exercise.md src/testing/solution.md
#, fuzzy
msgid "\"7992 7398 713\""
msgstr "\"7992 7398 713\""

#: src/testing/exercise.md src/testing/solution.md
#, fuzzy
msgid "\"4223 9826 4026 9299\""
msgstr "\"4223 9826 4026 9299\""

#: src/testing/exercise.md src/testing/solution.md
#, fuzzy
msgid "\"4539 3195 0343 6476\""
msgstr "\"4539 3195 0343 6476\""

#: src/testing/exercise.md src/testing/solution.md
#, fuzzy
msgid "\"8273 1232 7352 0569\""
msgstr "\"8273 1232 7352 0569\""

#: src/testing/solution.md
#, fuzzy
msgid "// This is the buggy version that appears in the problem.\n"
msgstr "// Aceasta este versiunea cu erori care apare 칥n problem캒.\n"

#: src/testing/solution.md
#, fuzzy
msgid "// This is the solution and passes all of the tests below.\n"
msgstr "// Aceasta este solu탵ia 탳i trece toate testele de mai jos.\n"

#: src/testing/solution.md
#, fuzzy
msgid "\"1234 5678 1234 5670\""
msgstr "\"1234 5678 1234 5670\""

#: src/testing/solution.md
#, fuzzy
msgid "\"Is {cc_number} a valid credit card number? {}\""
msgstr "\"Este {cc_number} un num캒r de card de credit valid? {}\""

#: src/testing/solution.md
#, fuzzy
msgid "\"yes\""
msgstr "Da (ini탵ializat la compilare)"

#: src/testing/solution.md
#, fuzzy
msgid "\"no\""
msgstr "\"nu\""

#: src/testing/solution.md
#, fuzzy
msgid "\"foo 0 0\""
msgstr "\"foo 0 0 0\""

#: src/testing/solution.md
#, fuzzy
msgid "\" \""
msgstr "\" \""

#: src/testing/solution.md
#, fuzzy
msgid "\"  \""
msgstr "\"  \""

#: src/testing/solution.md
#, fuzzy
msgid "\"    \""
msgstr "\"    \""

#: src/testing/solution.md
#, fuzzy
msgid "\"0\""
msgstr "'0'"

#: src/testing/solution.md
#, fuzzy
msgid "\" 0 0 \""
msgstr "\" 0 0 \""

#: src/welcome-day-4-afternoon.md
#, fuzzy
msgid "[Error Handling](./error-handling.md) (55 minutes)"
msgstr "[Gestionarea erorilor](../error-handling.md) (45 minute)"

#: src/welcome-day-4-afternoon.md
#, fuzzy
msgid "[Unsafe Rust](./unsafe-rust.md) (1 hour and 5 minutes)"
msgstr "[Unsafe Rust](../unsafe-rust.md) (1 or캒 탳i 5 minute)"

#: src/error-handling.md
#, fuzzy
msgid "[Panics](./error-handling/panics.md) (3 minutes)"
msgstr "[Panici](./error-handling/panics.md) (3 minute)"

#: src/error-handling.md
#, fuzzy
msgid "[Try Operator](./error-handling/try.md) (5 minutes)"
msgstr "[Operator de 칥ncercare](./error-handling/try.md) (5 minute)"

#: src/error-handling.md
#, fuzzy
msgid "[Try Conversions](./error-handling/try-conversions.md) (5 minutes)"
msgstr ""
"[칉ncerca탵i conversiile](./error-handling/try-conversions.md) (5 minute)"

#: src/error-handling.md
#, fuzzy
msgid "[Error Trait](./error-handling/error.md) (5 minutes)"
msgstr "[Error Trait](./error-handling/error.md) (5 minute)"

#: src/error-handling.md
#, fuzzy
msgid ""
"[thiserror and anyhow](./error-handling/thiserror-and-anyhow.md) (5 minutes)"
msgstr ""
"[thiserror and anyhow](./error-handling/thiserror-and-anyhow.md) (5 minute)"

#: src/error-handling.md
#, fuzzy
msgid ""
"[Exercise: Rewriting with Result](./error-handling/exercise.md) (30 minutes)"
msgstr ""
"[Exerci탵iu: Rescrierea cu rezultat](./error-handling/exercise.md) (20 minute)"

#: src/error-handling/panics.md
#, fuzzy
msgid "Rust handles fatal errors with a \"panic\"."
msgstr "Rust trateaz캒 erorile fatale cu un \"panic\"."

#: src/error-handling/panics.md
#, fuzzy
msgid "Rust will trigger a panic if a fatal error happens at runtime:"
msgstr ""
"Rust va declan탳a o panic캒 칥n cazul 칥n care se produce o eroare fatal캒 칥n "
"timpul execu탵iei:"

#: src/error-handling/panics.md
#, fuzzy
msgid "\"v[100]: {}\""
msgstr "\"v[100]: {}\""

#: src/error-handling/panics.md
#, fuzzy
msgid "Panics are for unrecoverable and unexpected errors."
msgstr "Panica este pentru erori irecuperabile 탳i nea탳teptate."

#: src/error-handling/panics.md
#, fuzzy
msgid "Panics are symptoms of bugs in the program."
msgstr "Panicile sunt simptome ale unor erori 칥n program."

#: src/error-handling/panics.md
#, fuzzy
msgid "Runtime failures like failed bounds checks can panic"
msgstr ""
"E탳ecurile 칥n timpul execu탵iei, cum ar fi verific캒rile e탳uate ale limitelor, "
"pot provoca panic캒"

#: src/error-handling/panics.md
#, fuzzy
msgid "Assertions (such as `assert!`) panic on failure"
msgstr "Afirma탵iile (cum ar fi `assert!`) intr캒 칥n panic캒 칥n caz de e탳ec"

#: src/error-handling/panics.md
#, fuzzy
msgid "Purpose-specific panics can use the `panic!` macro."
msgstr "Panicile cu scop specific pot utiliza macroul `panic!`."

#: src/error-handling/panics.md
#, fuzzy
msgid ""
"A panic will \"unwind\" the stack, dropping values just as if the functions "
"had returned."
msgstr ""
"O panic캒 va \"derula\" stiva, elimin칙nd valorile ca 탳i cum func탵iile s-ar fi "
"칥ntors."

#: src/error-handling/panics.md
#, fuzzy
msgid ""
"Use non-panicking APIs (such as `Vec::get`) if crashing is not acceptable."
msgstr ""
"Folosi탵i API-uri care nu se blocheaz캒 (cum ar fi `Vec::get`) dac캒 nu este "
"acceptabil캒 blocarea."

#: src/error-handling/panics.md
#, fuzzy
msgid ""
"By default, a panic will cause the stack to unwind. The unwinding can be "
"caught:"
msgstr ""
"칉n mod implicit, o panic캒 va determina derularea stivei. Desf캒탳urarea poate "
"fi prins캒:"

#: src/error-handling/panics.md
#, fuzzy
msgid "\"No problem here!\""
msgstr "\"Nici o problem캒 aici!\""

#: src/error-handling/panics.md
#, fuzzy
msgid "\"{result:?}\""
msgstr "\"result: {}\""

#: src/error-handling/panics.md
#, fuzzy
msgid "\"oh no!\""
msgstr "\"Oh, nu!\""

#: src/error-handling/panics.md
#, fuzzy
msgid ""
"Catching is unusual; do not attempt to implement exceptions with "
"`catch_unwind`!"
msgstr ""
"Capturarea este neobi탳nuit캒; nu 칥ncerca탵i s캒 implementa탵i excep탵ii cu "
"`catch_unwind`!"

#: src/error-handling/panics.md
#, fuzzy
msgid ""
"This can be useful in servers which should keep running even if a single "
"request crashes."
msgstr ""
"Acest lucru poate fi util 칥n cazul serverelor care trebuie s캒 continue s캒 "
"func탵ioneze chiar dac캒 o singur캒 cerere se blocheaz캒."

#: src/error-handling/panics.md
#, fuzzy
msgid "This does not work if `panic = 'abort'` is set in your `Cargo.toml`."
msgstr ""
"Acest lucru nu func탵ioneaz캒 dac캒 `panic = 'abort'` este setat 칥n `Cargo."
"toml`."

#: src/error-handling/try.md
#, fuzzy
msgid ""
"Runtime errors like connection-refused or file-not-found are handled with "
"the `Result` type, but matching this type on every call can be cumbersome. "
"The try-operator `?` is used to return errors to the caller. It lets you "
"turn the common"
msgstr ""
"Erorile 칥n timpul execu탵iei, cum ar fi connection-refused sau file-not-"
"found, sunt tratate cu tipul `Result`, dar potrivirea acestui tip la fiecare "
"apel poate fi greoaie. Operatorul try `?` este utilizat pentru a returna "
"erorile c캒tre apelant. Acesta v캒 permite s캒 transforma탵i op탵iunea comun캒"

#: src/error-handling/try.md
#, fuzzy
msgid "into the much simpler"
msgstr "칥n mult mai simplu"

#: src/error-handling/try.md
#, fuzzy
msgid "We can use this to simplify our error handling code:"
msgstr ""
"Putem folosi acest lucru pentru a simplifica codul de tratare a erorilor:"

#: src/error-handling/try.md
#, fuzzy
msgid "//fs::write(\"config.dat\", \"alice\").unwrap();\n"
msgstr "//fs::write(\"config.dat\", \"alice\").unwrap();\n"

#: src/error-handling/try.md src/error-handling/try-conversions.md
#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "\"config.dat\""
msgstr "\"config.dat\""

#: src/error-handling/try.md src/error-handling/try-conversions.md
#, fuzzy
msgid "\"username or error: {username:?}\""
msgstr "\"nume de utilizator sau eroare: {username:?}\""

#: src/error-handling/try.md
#, fuzzy
msgid "Simplify the `read_username` function to use `?`."
msgstr "Simplificarea func탵iei `read_username` pentru a folosi `?`."

#: src/error-handling/try.md
#, fuzzy
msgid "The `username` variable can be either `Ok(string)` or `Err(error)`."
msgstr "Variabila `username` poate fi fie `Ok(string)`, fie `Err(error)`."

#: src/error-handling/try.md
#, fuzzy
msgid ""
"Use the `fs::write` call to test out the different scenarios: no file, empty "
"file, file with username."
msgstr ""
"Utiliza탵i apelul `fs::write` pentru a testa diferite scenarii: niciun "
"fi탳ier, fi탳ier gol, fi탳ier cu nume de utilizator."

#: src/error-handling/try.md
#, fuzzy
msgid ""
"Note that `main` can return a `Result<(), E>` as long as it implements `std::"
"process::Termination`. In practice, this means that `E` implements `Debug`. "
"The executable will print the `Err` variant and return a nonzero exit status "
"on error."
msgstr ""
"Re탵ine탵i c캒 `main` poate returna un `Result<(), E>` at칙ta timp c칙t "
"implementeaz캒 `std::process:Termination`. 칉n practic캒, acest lucru 칥nseamn캒 "
"c캒 `E` implementeaz캒 `Debug`. Executabilul va imprima varianta `Err` 탳i va "
"returna o stare de ie탳ire diferit캒 de zero 칥n caz de eroare."

#: src/error-handling/try-conversions.md
#, fuzzy
msgid ""
"The effective expansion of `?` is a little more complicated than previously "
"indicated:"
msgstr ""
"Extinderea efectiv캒 a lui `?` este pu탵in mai complicat캒 dec칙t s-a ar캒tat "
"anterior:"

#: src/error-handling/try-conversions.md
#, fuzzy
msgid "works the same as"
msgstr "func탵ioneaz캒 la fel ca"

#: src/error-handling/try-conversions.md
#, fuzzy
msgid ""
"The `From::from` call here means we attempt to convert the error type to the "
"type returned by the function. This makes it easy to encapsulate errors into "
"higher-level errors."
msgstr ""
"Apelul `From::from` de aici 칥nseamn캒 c캒 칥ncerc캒m s캒 convertim tipul de "
"eroare 칥n tipul returnat de func탵ie."

#: src/error-handling/try-conversions.md
#, fuzzy
msgid "\"IO error: {e}\""
msgstr "\"Eroare IO: {e}\""

#: src/error-handling/try-conversions.md
#, fuzzy
msgid "\"Found no username in {path}\""
msgstr "\"Nu am g캒sit niciun nume de utilizator 칥n {path}\""

#: src/error-handling/try-conversions.md
#, fuzzy
msgid "//std::fs::write(\"config.dat\", \"\").unwrap();\n"
msgstr "//fs::write(\"config.dat\", \"\").unwrap();\n"

#: src/error-handling/try-conversions.md
#, fuzzy
msgid ""
"The `?` operator must return a value compatible with the return type of the "
"function. For `Result`, it means that the error types have to be compatible. "
"A function that returns `Result<T, ErrorOuter>` can only use `?` on a value "
"of type `Result<U, ErrorInner>` if `ErrorOuter` and `ErrorInner` are the "
"same type or if `ErrorOuter` implements `From<ErrorInner>`."
msgstr ""
"Operatorul `?` trebuie s캒 returneze o valoare compatibil캒 cu tipul de retur "
"al func탵iei. Pentru `Result`, aceasta 칥nseamn캒 c캒 tipurile de eroare trebuie "
"s캒 fie compatibile. O func탵ie care returneaz캒 `Result<T, ErrorOuter>` poate "
"folosi `?` pentru o valoare de tip `Result<U, ErrorInner>` numai dac캒 "
"`ErrorOuter` 탳i `ErrorInner` sunt de acela탳i tip sau dac캒 `ErrorOuter` "
"implementeaz캒 `From<ErrorInner>`."

#: src/error-handling/try-conversions.md
#, fuzzy
msgid ""
"A common alternative to a `From` implementation is `Result::map_err`, "
"especially when the conversion only happens in one place."
msgstr ""
"O alternativ캒 obi탳nuit캒 la o implementare `From` este `Result::map_err`, 칥n "
"special atunci c칙nd conversia are loc 칥ntr-un singur loc."

#: src/error-handling/try-conversions.md
#, fuzzy
msgid ""
"There is no compatibility requirement for `Option`. A function returning "
"`Option<T>` can use the `?` operator on `Option<U>` for arbitrary `T` and "
"`U` types."
msgstr ""
"Nu exist캒 nicio cerin탵캒 de compatibilitate pentru `Option`. O func탵ie care "
"returneaz캒 `Option<T>` poate utiliza operatorul `?` pe `Option<U>` pentru "
"tipuri arbitrare `T` 탳i `U`."

#: src/error-handling/try-conversions.md
#, fuzzy
msgid ""
"A function that returns `Result` cannot use `?` on `Option` and vice versa. "
"However, `Option::ok_or` converts `Option` to `Result` whereas `Result::ok` "
"turns `Result` into `Option`."
msgstr ""
"O func탵ie care returneaz캒 `Result` nu poate utiliza `?` pentru `Option` 탳i "
"invers. Cu toate acestea, `Option::ok_or` transform캒 `Option` 칥n `Result`, "
"칥n timp ce `Result::ok` transform캒 `Result` 칥n `Option`."

#: src/error-handling/error.md
msgid "Dynamic Error Types"
msgstr "Tipuri de erori dinamice"

#: src/error-handling/error.md
#, fuzzy
msgid ""
"Sometimes we want to allow any type of error to be returned without writing "
"our own enum covering all the different possibilities. The `std::error::"
"Error` trait makes it easy to create a trait object that can contain any "
"error."
msgstr ""
"Uneori dorim s캒 permitem returnarea oric캒rui tip de eroare f캒r캒 a scrie "
"propriul nostru enum care s캒 acopere toate posibilit캒탵ile diferite. `std::"
"error::Error` faciliteaz캒 acest lucru."

#: src/error-handling/error.md
#, fuzzy
msgid "\"count.dat\""
msgstr "\"count.dat\""

#: src/error-handling/error.md
#, fuzzy
msgid "\"1i3\""
msgstr "\"1i3\""

#: src/error-handling/error.md
#, fuzzy
msgid "\"Count: {count}\""
msgstr "\"Conte: {count}\""

#: src/error-handling/error.md
#, fuzzy
msgid "\"Error: {err}\""
msgstr "\"Eroare: {err}\""

#: src/error-handling/error.md
#, fuzzy
msgid ""
"The `read_count` function can return `std::io::Error` (from file operations) "
"or `std::num::ParseIntError` (from `String::parse`)."
msgstr ""
"Func탵ia `read_count` poate returna `std::io::Error` (din opera탵iile cu "
"fi탳iere) sau `std::num::ParseIntError` (din `String::parse`)."

#: src/error-handling/error.md
#, fuzzy
msgid ""
"Boxing errors saves on code, but gives up the ability to cleanly handle "
"different error cases differently in the program. As such it's generally not "
"a good idea to use `Box<dyn Error>` in the public API of a library, but it "
"can be a good option in a program where you just want to display the error "
"message somewhere."
msgstr ""
"Acest lucru economise탳te cod, dar renun탵캒 la capacitatea de a trata 칥n mod "
"curat diferite cazuri de eroare 칥n mod diferit 칥n program. Ca atare, 칥n "
"general nu este o idee bun캒 s캒 folosi탵i `Box<dyn Error>` 칥n API-ul public al "
"unei biblioteci, dar poate fi o op탵iune bun캒 칥ntr-un program 칥n care dori탵i "
"doar s캒 afi탳a탵i mesajul de eroare undeva."

#: src/error-handling/error.md
#, fuzzy
msgid ""
"Make sure to implement the `std::error::Error` trait when defining a custom "
"error type so it can be boxed. But if you need to support the `no_std` "
"attribute, keep in mind that the `std::error::Error` trait is currently "
"compatible with `no_std` in [nightly](https://github.com/rust-lang/rust/"
"issues/103765) only."
msgstr ""
"Asigura탵i-v캒 c캒 implementa탵i tr캒s캒tura `std::error::Error` atunci c칙nd "
"defini탵i un tip de eroare personalizat, astfel 칥nc칙t acesta s캒 poat캒 fi "
"칥ncadrat. Dar dac캒 ave탵i nevoie s캒 suporta탵i atributul `no_std`, re탵ine탵i c캒 "
"tr캒s캒tura `std::error::Error` este 칥n prezent compatibil캒 cu `no_std` doar "
"칥n [nightly](https://github.com/rust-lang/rust/issues/103765)."

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid ""
"The [`thiserror`](https://docs.rs/thiserror/) and [`anyhow`](https://docs.rs/"
"anyhow/) crates are widely used to simplify error handling."
msgstr ""
"Cr캒iasa [thiserror](https://docs.rs/thiserror/) este o modalitate popular캒 "
"de a crea o enumera탵ie a erorilor, a탳a cum am f캒cut pe pagina anterioar캒:"

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid ""
"`thiserror` is often used in libraries to create custom error types that "
"implement `From<T>`."
msgstr ""
"`thiserror` este adesea utilizat 칥n biblioteci pentru a crea tipuri de erori "
"personalizate care implementeaz캒 `From<T>`."

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid ""
"`anyhow` is often used by applications to help with error handling in "
"functions, including adding contextual information to your errors."
msgstr ""
"`anyhow` este adesea utilizat de aplica탵ii pentru a ajuta la gestionarea "
"erorilor 칥n func탵ii, inclusiv ad캒ugarea de informa탵ii contextuale la erori."

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "\"Found no username in {0}\""
msgstr "\"Nu am g캒sit niciun nume de utilizator 칥n {0}\""

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "\"Failed to open {path}\""
msgstr "\"Nu s-a reu탳it deschiderea {path}\""

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "\"Failed to read\""
msgstr "\"Nu a reu탳it s캒 citeasc캒\""

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "//fs::write(\"config.dat\", \"\").unwrap();\n"
msgstr "//fs::write(\"config.dat\", \"\").unwrap();\n"

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "\"Username: {username}\""
msgstr "\"Nume de utilizator: {username}\""

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "\"Error: {err:?}\""
msgstr "\"Eroare: {err:?}\""

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "`thiserror`"
msgstr "`Error`"

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid ""
"The `Error` derive macro is provided by `thiserror`, and has lots of useful "
"attributes to help define error types in a compact way."
msgstr ""
"Macroul derivat `Error` este furnizat de `thiserror` 탳i are o mul탵ime de "
"atribute utile pentru a ajuta la definirea tipurilor de erori 칥ntr-un mod "
"compact."

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "The `std::error::Error` trait is derived automatically."
msgstr "Caracteristica `std::error::Error` este derivat캒 automat."

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "The message from `#[error]` is used to derive the `Display` trait."
msgstr ""
"Mesajul din `#[error]` este utilizat pentru a ob탵ine caracteristica "
"`Display`."

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "`anyhow`"
msgstr "\"oricum"

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid ""
"`anyhow::Error` is essentially a wrapper around `Box<dyn Error>`. As such "
"it's again generally not a good choice for the public API of a library, but "
"is widely used in applications."
msgstr ""
"`anyhow::Error` este 칥n esen탵캒 un 칥nveli탳 칥n jurul lui `Box<dyn Error>`. Ca "
"atare, 칥n general, nu este o alegere bun캒 pentru API-ul public al unei "
"biblioteci, dar este utilizat pe scar캒 larg캒 칥n aplica탵ii."

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "`anyhow::Result<V>` is a type alias for `Result<V, anyhow::Error>`."
msgstr ""
"`anyhow::Result<V>` este un alias de tip pentru `Result<V, anyhow::Error>`."

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid ""
"Actual error type inside of it can be extracted for examination if necessary."
msgstr ""
"Tipul real de eroare din interiorul acestuia poate fi extras pentru "
"examinare, dac캒 este necesar."

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid ""
"Functionality provided by `anyhow::Result<T>` may be familiar to Go "
"developers, as it provides similar usage patterns and ergonomics to `(T, "
"error)` from Go."
msgstr ""
"Func탵ionalitatea oferit캒 de `anyhow::Result<T>` poate fi cunoscut캒 "
"dezvoltatorilor Go, deoarece ofer캒 modele de utilizare 탳i ergonomie similare "
"cu `(T, error)` din Go."

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid ""
"`anyhow::Context` is a trait implemented for the standard `Result` and "
"`Option` types. `use anyhow::Context` is necessary to enable `.context()` "
"and `.with_context()` on those types."
msgstr ""
"`anyhow::Context` este o tr캒s캒tur캒 implementat캒 pentru tipurile standard "
"`Result` 탳i `Option`. `use anyhow::Context` este necesar pentru a activa `."
"context()` 탳i `.with_context()` pentru aceste tipuri."

#: src/error-handling/exercise.md
#, fuzzy
msgid "Exercise: Rewriting with Result"
msgstr "Exerci탵iu: rescrierea cu `Result`"

#: src/error-handling/exercise.md
#, fuzzy
msgid ""
"The following implements a very simple parser for an expression language. "
"However, it handles errors by panicking. Rewrite it to instead use idiomatic "
"error handling and propagate errors to a return from `main`. Feel free to "
"use `thiserror` and `anyhow`."
msgstr ""
"Urm캒torul exemplu implementeaz캒 un parser foarte simplu pentru un limbaj de "
"expresii. Cu toate acestea, acesta gestioneaz캒 erorile prin panic캒. "
"Rescrie탵i-l pentru a utiliza 칥n schimb o gestionare idiomatic캒 a erorilor 탳i "
"pentru a propaga erorile la o 칥ntoarcere din `main`. Nu ezita탵i s캒 folosi탵i "
"`thiserror` 탳i `anyhow`."

#: src/error-handling/exercise.md
#, fuzzy
msgid ""
"HINT: start by fixing error handling in the `parse` function. Once that is "
"working correctly, update `Tokenizer` to implement "
"`Iterator<Item=Result<Token, TokenizerError>>` and handle that in the parser."
msgstr ""
"SUGESTIE: 칥ncepe탵i prin a remedia gestionarea erorilor 칥n func탵ia `parse`. "
"Odat캒 ce aceasta func탵ioneaz캒 corect, actualiza탵i `Tokenizer` pentru a "
"implementa `Iterator<Item=Result<Token, TokenizerError>>`` 탳i gestiona탵i "
"acest lucru 칥n parser."

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "/// An arithmetic operator.\n"
msgstr "/// Un operator aritmetic.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "/// A token in the expression language.\n"
msgstr "/// Un simbol 칥n limbajul de exprimare.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "/// An expression in the expression language.\n"
msgstr "/// O expresie 칥n limbajul de expresie.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "/// A reference to a variable.\n"
msgstr "/// O referin탵캒 la o variabil캒.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "/// A literal number.\n"
msgstr "/// Un num캒r literal.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "/// A binary operation.\n"
msgstr "/// O opera탵iune binar캒.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "'_'"
msgstr "'_'"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "'+'"
msgstr "'+'"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "'-'"
msgstr "'-'"

#: src/error-handling/exercise.md
#, fuzzy
msgid "\"Unexpected character {c}\""
msgstr "\"Caracter nea탳teptat {c}\""

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "\"Unexpected end of input\""
msgstr "\"Sf칙r탳itul nea탳teptat al intr캒rii\""

#: src/error-handling/exercise.md
#, fuzzy
msgid "\"Invalid 32-bit integer'\""
msgstr "\"Num캒r 칥ntreg de 32 de bi탵i invalid\""

#: src/error-handling/exercise.md
#, fuzzy
msgid "\"Unexpected token {tok:?}\""
msgstr "\"Jetoane nea탳teptate {tok:?}\""

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "// Look ahead to parse a binary operation if present.\n"
msgstr ""
"// Se uit캒 칥nainte pentru a analiza o opera탵iune binar캒, dac캒 este "
"prezent캒.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "\"10+foo+20-30\""
msgstr "\"10+foo+20-30\""

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "\"{expr:?}\""
msgstr "\"{expr:?}\""

#: src/error-handling/solution.md
#, fuzzy
msgid "\"Unexpected character '{0}' in input\""
msgstr "\"Caracter nea탳teptat \"{0}\" 칥n intrare\""

#: src/error-handling/solution.md
#, fuzzy
msgid "\"Tokenizer error: {0}\""
msgstr "\"Eroare de tokenizare: {0}\""

#: src/error-handling/solution.md
#, fuzzy
msgid "\"Unexpected token {0:?}\""
msgstr "\"Jetoane nea탳teptate {0:?}\""

#: src/error-handling/solution.md
#, fuzzy
msgid "\"Invalid number\""
msgstr "\"Num캒r invalid\""

#: src/unsafe-rust.md
#, fuzzy
msgid "[Unsafe](./unsafe-rust/unsafe.md) (5 minutes)"
msgstr "[Nesigur](./unsafe-rust/unsafe.md) (5 minute)"

#: src/unsafe-rust.md
#, fuzzy
msgid ""
"[Dereferencing Raw Pointers](./unsafe-rust/dereferencing.md) (10 minutes)"
msgstr ""
"[Dereferen탵ierea pointerilor brute](./unsafe-rust/dereferencing.md) (10 "
"minute)"

#: src/unsafe-rust.md
#, fuzzy
msgid "[Mutable Static Variables](./unsafe-rust/mutable-static.md) (5 minutes)"
msgstr ""
"[Variabile statice mutabile](./unsafe-rust/mutable-static.md) (5 minute)"

#: src/unsafe-rust.md
#, fuzzy
msgid "[Unions](./unsafe-rust/unions.md) (5 minutes)"
msgstr "[Uniuni](./unsafe-rust/unions.md) (5 minute)"

#: src/unsafe-rust.md
#, fuzzy
msgid "[Unsafe Functions](./unsafe-rust/unsafe-functions.md) (5 minutes)"
msgstr "[Func탵ii nesigure](./unsafe-rust/unsafe-functions.md) (5 minute)"

#: src/unsafe-rust.md
#, fuzzy
msgid "[Unsafe Traits](./unsafe-rust/unsafe-traits.md) (5 minutes)"
msgstr "[Tr캒s캒turi nesigure](./unsafe-rust/unsafe-traits.md) (5 minute)"

#: src/unsafe-rust.md
msgid "[Exercise: FFI Wrapper](./unsafe-rust/exercise.md) (30 minutes)"
msgstr "[Exerci탵iu: 칉mpachetare FFI](./unsafe-rust/exercise.md) (30 minute)"

#: src/unsafe-rust.md
msgid "This segment should take about 1 hour and 5 minutes"
msgstr "Acest segment ar trebui s캒 dureze aproximativ 1 or캒 탳i 5 minute"

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid "The Rust language has two parts:"
msgstr "Limbajul Rust are dou캒 p캒r탵i:"

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid "**Safe Rust:** memory safe, no undefined behavior possible."
msgstr "**Safe Rust:** sigur 칥n memorie, f캒r캒 comportament nedefinit posibil."

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid ""
"**Unsafe Rust:** can trigger undefined behavior if preconditions are "
"violated."
msgstr ""
"**Unsafe Rust:** poate declan탳a un comportament nedefinit dac캒 sunt "
"칥nc캒lcate condi탵iile prealabile."

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid ""
"We saw mostly safe Rust in this course, but it's important to know what "
"Unsafe Rust is."
msgstr ""
"칉n acest curs vom vedea mai ales Rust sigur, dar este important s캒 탳tim ce "
"este Rust nesigur."

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid ""
"Unsafe code is usually small and isolated, and its correctness should be "
"carefully documented. It is usually wrapped in a safe abstraction layer."
msgstr ""
"Codul nesigur este, de obicei, mic 탳i izolat, iar corectitudinea sa trebuie "
"documentat캒 cu aten탵ie. Acesta este de obicei acoperit de un strat de "
"abstractizare sigur."

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid "Unsafe Rust gives you access to five new capabilities:"
msgstr "Unsafe Rust v캒 ofer캒 acces la cinci noi capacit캒탵i:"

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid "Dereference raw pointers."
msgstr "Dereferen탵ierea indicatoarelor brute."

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid "Access or modify mutable static variables."
msgstr "Accesarea sau modificarea variabilelor statice mutabile."

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid "Access `union` fields."
msgstr "Accesa탵i c칙mpurile `union`."

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid "Call `unsafe` functions, including `extern` functions."
msgstr "Apelarea func탵iilor `unsafe`, inclusiv a func탵iilor `extern`."

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid "Implement `unsafe` traits."
msgstr "Implementarea tr캒s캒turilor `unsafe`."

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid ""
"We will briefly cover unsafe capabilities next. For full details, please see "
"[Chapter 19.1 in the Rust Book](https://doc.rust-lang.org/book/ch19-01-"
"unsafe-rust.html) and the [Rustonomicon](https://doc.rust-lang.org/nomicon/)."
msgstr ""
"칉n continuare vom aborda pe scurt capacit캒탵ile nesigure. Pentru detalii "
"complete, v캒 rug캒m s캒 consulta탵i [Capitolul 19.1 din Rust Book](https://doc."
"rust-lang.org/book/ch19-01-unsafe-rust.html) 탳i [Rustonomicon](https://doc."
"rust-lang.org/nomicon/)."

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid ""
"Unsafe Rust does not mean the code is incorrect. It means that developers "
"have turned off some compiler safety features and have to write correct code "
"by themselves. It means the compiler no longer enforces Rust's memory-safety "
"rules."
msgstr ""
"Unsafe Rust nu 칥nseamn캒 c캒 codul este incorect. 칉nseamn캒 c캒 dezvoltatorii au "
"dezactivat caracteristicile de siguran탵캒 ale compilatorului 탳i trebuie s캒 "
"scrie singuri codul corect. 칉nseamn캒 c캒 compilatorul nu mai aplic캒 regulile "
"de siguran탵캒 a memoriei din Rust."

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid "Creating pointers is safe, but dereferencing them requires `unsafe`:"
msgstr ""
"Crearea de pointeri este sigur캒, dar dereferen탵ierea lor necesit캒 `unsafe`:"

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid "\"careful!\""
msgstr "\"Aten탵ie!\""

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid ""
"// SAFETY: r1 and r2 were obtained from references and so are guaranteed to\n"
"    // be non-null and properly aligned, the objects underlying the "
"references\n"
"    // from which they were obtained are live throughout the whole unsafe\n"
"    // block, and they are not accessed either through the references or\n"
"    // concurrently through any other pointers.\n"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    let mut num = 5;\n"
"\n"
"    let r1 = &mut num as *mut i32;\n"
"    let r2 = r1 as *const i32;\n"
"\n"
"    // Sigur, deoarece r1 탳i r2 au fost ob탵inute din referin탵e 탳i deci sunt\n"
"    // garantate ca fiind non-null 탳i aliniate corespunz캒tor, obiectele care "
"stau la baza lor\n"
"    // referin탵ele din care au fost ob탵inute sunt vii pe tot parcursul\n"
"    // 칥ntregul bloc nesigur, 탳i nu sunt accesate nici prin intermediul "
"blocului\n"
"    // referin탵e, nici 칥n acela탳i timp prin intermediul altor pointeri.\n"
"    unsafe {\n"
"        println!(\"r1 este: {}\", *r1);\n"
"        *r1 = 10;\n"
"        println!(\"r2 este: {}\", *r2);\n"
"    }\n"
"}\n"
"```"

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid "\"r1 is: {}\""
msgstr "\"r1 este: {}\""

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid "\"uhoh\""
msgstr "\"uhoh\""

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid "\"r2 is: {}\""
msgstr "\"r2 este: {}\""

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid ""
"// NOT SAFE. DO NOT DO THIS.\n"
"    /*\n"
"    let r3: &String = unsafe { &*r1 };\n"
"    drop(s);\n"
"    println!(\"r3 is: {}\", *r3);\n"
"    */"
msgstr ""
"// NU ESTE SIGUR. NU FACE탴I ACEST LUCRU.\n"
"    /*\n"
"    let r3: &String = unsafe { &*r1 };\n"
"    drop(s);\n"
"    println!(\"r3 este: {}\", *r3);\n"
"    */"

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid ""
"It is good practice (and required by the Android Rust style guide) to write "
"a comment for each `unsafe` block explaining how the code inside it "
"satisfies the safety requirements of the unsafe operations it is doing."
msgstr ""
"Este o bun캒 practic캒 (탳i este cerut캒 de ghidul de stil Android Rust) s캒 "
"scrie탵i un comentariu pentru fiecare bloc `unsafe`, explic칙nd modul 칥n care "
"codul din interiorul acestuia 칥ndepline탳te cerin탵ele de siguran탵캒 ale "
"opera탵iilor nesigure pe care le efectueaz캒."

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid ""
"In the case of pointer dereferences, this means that the pointers must be "
"[_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), i.e.:"
msgstr ""
"칉n cazul dereferen탵ierii pointerilor, aceasta 칥nseamn캒 c캒 pointerii trebuie "
"s캒 fie [_valabili_](https://doc.rust-lang.org/std/ptr/index.html#safety), "
"adic캒:"

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid "The pointer must be non-null."
msgstr "Pointerul trebuie s캒 nu fie nul."

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid ""
"The pointer must be _dereferenceable_ (within the bounds of a single "
"allocated object)."
msgstr ""
"Pointerul trebuie s캒 fie _dereferen탵iabil_ (칥n limitele unui singur obiect "
"alocat)."

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid "The object must not have been deallocated."
msgstr "Obiectul nu trebuie s캒 fi fost dezalocat."

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid "There must not be concurrent accesses to the same location."
msgstr "Nu trebuie s캒 existe accese simultane la aceea탳i loca탵ie."

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid ""
"If the pointer was obtained by casting a reference, the underlying object "
"must be live and no reference may be used to access the memory."
msgstr ""
"칉n cazul 칥n care pointerul a fost ob탵inut prin turnarea unei referin탵e, "
"obiectul subiacent trebuie s캒 fie viu 탳i nu se poate utiliza nicio referin탵캒 "
"pentru a accesa memoria."

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid "In most cases the pointer must also be properly aligned."
msgstr ""
"칉n cele mai multe cazuri, indicatorul trebuie, de asemenea, s캒 fie bine "
"aliniat."

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid ""
"The \"NOT SAFE\" section gives an example of a common kind of UB bug: `*r1` "
"has the `'static` lifetime, so `r3` has type `&'static String`, and thus "
"outlives `s`. Creating a reference from a pointer requires _great care_."
msgstr ""
"Sec탵iunea \"NOT SAFE\" ofer캒 un exemplu de un tip comun de eroare UB: `*r1` "
"are durata de via탵캒 `'static`, astfel 칥nc칙t `r3` are tipul `&'static String` "
"탳i, prin urmare, tr캒ie탳te mai mult dec칙t `s`. Crearea unei referin탵e dintr-"
"un pointer necesit캒 _grea aten탵ie_."

#: src/unsafe-rust/mutable-static.md
#, fuzzy
msgid "It is safe to read an immutable static variable:"
msgstr "Este sigur s캒 citi탵i o variabil캒 static캒 imuabil캒:"

#: src/unsafe-rust/mutable-static.md
#, fuzzy
msgid "\"Hello, world!\""
msgstr "Bun캒 lume"

#: src/unsafe-rust/mutable-static.md
#, fuzzy
msgid "\"HELLO_WORLD: {HELLO_WORLD}\""
msgstr "\"HELLO_WORLD: {HELLO_WORLD}\""

#: src/unsafe-rust/mutable-static.md
#, fuzzy
msgid ""
"However, since data races can occur, it is unsafe to read and write mutable "
"static variables:"
msgstr ""
"Cu toate acestea, deoarece pot ap캒rea curse de date, nu este sigur s캒 se "
"citeasc캒 탳i s캒 se scrie variabilele statice mutabile:"

#: src/unsafe-rust/mutable-static.md
#, fuzzy
msgid ""
"// SAFETY: There are no other threads which could be accessing `COUNTER`.\n"
msgstr "// SIGURAN탴캑: Nu exist캒 alte fire care ar putea accesa `COUNTER`.\n"

#: src/unsafe-rust/mutable-static.md
#, fuzzy
msgid "\"COUNTER: {COUNTER}\""
msgstr "\"COUNTER: {COUNTER}\""

#: src/unsafe-rust/mutable-static.md
#, fuzzy
msgid ""
"The program here is safe because it is single-threaded. However, the Rust "
"compiler is conservative and will assume the worst. Try removing the "
"`unsafe` and see how the compiler explains that it is undefined behavior to "
"mutate a static from multiple threads."
msgstr ""
"Programul de aici este sigur, deoarece are un singur fir de execu탵ie. Cu "
"toate acestea, compilatorul Rust este conservator 탳i va presupune ce este "
"mai r캒u. 칉ncerca탵i s캒 elimina탵i `unsafe` 탳i s캒 vede탵i cum compilatorul "
"explic캒 faptul c캒 este un comportament nedefinit s캒 muta탵i o static캒 din mai "
"multe fire de execu탵ie."

#: src/unsafe-rust/mutable-static.md
#, fuzzy
msgid ""
"Using a mutable static is generally a bad idea, but there are some cases "
"where it might make sense in low-level `no_std` code, such as implementing a "
"heap allocator or working with some C APIs."
msgstr ""
"Utilizarea unui static mutabil este, 칥n general, o idee proast캒, dar exist캒 "
"unele cazuri 칥n care ar putea avea sens 칥n codul `no_std` de nivel sc캒zut, "
"cum ar fi implementarea unui alocator de heap sau lucrul cu unele API-uri C."

#: src/unsafe-rust/unions.md
#, fuzzy
msgid "Unions are like enums, but you need to track the active field yourself:"
msgstr ""
"Uniunile sunt ca 탳i enumera탵iile, dar trebuie s캒 urm캒ri탵i singur c칙mpul "
"activ:"

#: src/unsafe-rust/unions.md
#, fuzzy
msgid "\"int: {}\""
msgstr "\"int: {}\""

#: src/unsafe-rust/unions.md
#, fuzzy
msgid "\"bool: {}\""
msgstr "\"bool: {}\""

#: src/unsafe-rust/unions.md
#, fuzzy
msgid "// Undefined behavior!\n"
msgstr "Nici un comportament nedefinit 칥n timpul execu탵iei:"

#: src/unsafe-rust/unions.md
#, fuzzy
msgid ""
"Unions are very rarely needed in Rust as you can usually use an enum. They "
"are occasionally needed for interacting with C library APIs."
msgstr ""
"Uniunile sunt foarte rar necesare 칥n Rust, deoarece pute탵i utiliza de obicei "
"un enum. Ele sunt ocazional necesare pentru a interac탵iona cu API-urile "
"bibliotecilor C."

#: src/unsafe-rust/unions.md
#, fuzzy
msgid ""
"If you just want to reinterpret bytes as a different type, you probably want "
"[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn."
"transmute.html) or a safe wrapper such as the [`zerocopy`](https://crates.io/"
"crates/zerocopy) crate."
msgstr ""
"Dac캒 dori탵i doar s캒 reinterpreta탵i octe탵ii ca fiind de un tip diferit, "
"probabil c캒 dori탵i [`std::mem::transmute`](https://doc.rust-lang.org/stable/"
"std/mem/fn.transmute.html) sau un 칥nveli탳 sigur, cum ar fi [`zerocopy`]"
"(https://crates.io/crates/zerocopy)."

#: src/unsafe-rust/unsafe-functions.md
msgid "Calling Unsafe Functions"
msgstr "Apelarea func탵iilor nesigure"

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"A function or method can be marked `unsafe` if it has extra preconditions "
"you must uphold to avoid undefined behaviour:"
msgstr ""
"O func탵ie sau o metod캒 poate fi marcat캒 `unsafe` dac캒 are condi탵ii "
"prealabile suplimentare pe care trebuie s캒 le respecta탵i pentru a evita un "
"comportament nedefinit:"

#: src/unsafe-rust/unsafe-functions.md src/unsafe-rust/exercise.md
#: src/unsafe-rust/solution.md src/android/interoperability/with-c.md
#: src/android/interoperability/with-c/rust.md
#: src/android/interoperability/cpp/cpp-bridge.md
#: src/exercises/chromium/build-rules.md src/bare-metal/aps/inline-assembly.md
#: src/bare-metal/aps/better-uart/using.md src/bare-metal/aps/logging/using.md
#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "\"C\""
msgstr "\"C\""

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid "\"游딭갣游깶\""
msgstr "\"游딭갣游깶\""

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"// SAFETY: The indices are in the correct order, within the bounds of the\n"
"    // string slice, and lie on UTF-8 sequence boundaries.\n"
msgstr ""
"// Sigur, deoarece indicii sunt 칥n ordinea corect캒, 칥n limitele lui\n"
"    // 탳irului de caractere 탳i se afl캒 pe limitele secven탵ei UTF-8.\n"

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid "\"emoji: {}\""
msgstr "\"emoji: {}\""

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid "\"char count: {}\""
msgstr "\"char count: {}\""

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"// SAFETY: `abs` doesn't deal with pointers and doesn't have any safety\n"
"    // requirements.\n"
msgstr ""
"// SIGURAN탴캑: `abs` nu se ocup캒 de pointeri 탳i nu are nicio siguran탵캒\n"
"    // cerin탵e.\n"

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid "\"Absolute value of -3 according to C: {}\""
msgstr "\"Valoarea absolut캒 a lui -3 칥n conformitate cu C: {}\""

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"// Not upholding the UTF-8 encoding requirement breaks memory safety!\n"
"    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
"    // println!(\"char count: {}\", count_chars(unsafe {\n"
"    // emojis.get_unchecked(0..3) }));\n"
msgstr ""
"// Nerespectarea cerin탵ei de codificare UTF-8 칥ncalc캒 siguran탵a memoriei!\n"
"    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
"    // println!(\"char count: {}\", count_chars(unsafe {\n"
"    // emojis.get_ununchecked(0..3) }));\n"

#: src/unsafe-rust/unsafe-functions.md
msgid "Writing Unsafe Functions"
msgstr "Scrierea func탵iilor nesigure"

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"You can mark your own functions as `unsafe` if they require particular "
"conditions to avoid undefined behaviour."
msgstr ""
"Pute탵i marca propriile func탵ii ca fiind \"nesigure\" dac캒 acestea necesit캒 "
"anumite condi탵ii pentru a evita un comportament nedefinit."

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"/// Swaps the values pointed to by the given pointers.\n"
"///\n"
"/// # Safety\n"
"///\n"
"/// The pointers must be valid and properly aligned.\n"
msgstr ""
"/// Schimb캒 valorile indicate de indicatoarele date.\n"
"///\n"
"/// # Siguran탵캒\n"
"///\n"
"/// Punctele trebuie s캒 fie valide 탳i aliniate corespunz캒tor.\n"

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid "// SAFETY: ...\n"
msgstr "// ...\n"

#: src/unsafe-rust/unsafe-functions.md
msgid "\"a = {}, b = {}\""
msgstr "\"a = {}, b = {}\""

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"`get_unchecked`, like most `_unchecked` functions, is unsafe, because it can "
"create UB if the range is incorrect. `abs` is incorrect for a different "
"reason: it is an external function (FFI). Calling external functions is "
"usually only a problem when those functions do things with pointers which "
"might violate Rust's memory model, but in general any C function might have "
"undefined behaviour under any arbitrary circumstances."
msgstr ""
"Aceasta este de obicei o problem캒 doar pentru func탵iile externe care fac "
"lucruri cu pointeri care ar putea 칥nc캒lca modelul de memorie Rust, dar 칥n "
"general orice func탵ie C poate avea un comportament nedefinit 칥n orice "
"circumstan탵e arbitrare."

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"The `\"C\"` in this example is the ABI; [other ABIs are available too]"
"(https://doc.rust-lang.org/reference/items/external-blocks.html)."
msgstr ""
"칉n acest exemplu, `\"C\"` este ABI; [sunt disponibile 탳i alte ABI-uri]"
"(https://doc.rust-lang.org/reference/items/external-blocks.html)."

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"We wouldn't actually use pointers for a `swap` function - it can be done "
"safely with references."
msgstr ""
"De fapt, nu vom folosi pointeri pentru acest lucru, deoarece acest lucru "
"poate fi realizat 칥n siguran탵캒 cu referin탵e."

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"Note that unsafe code is allowed within an unsafe function without an "
"`unsafe` block. We can prohibit this with `#[deny(unsafe_op_in_unsafe_fn)]`. "
"Try adding it and see what happens. This will likely change in a future Rust "
"edition."
msgstr ""
"Re탵ine탵i c캒 codul nesigur este permis 칥n cadrul unei func탵ii nesigure f캒r캒 "
"un bloc `unsafe`. Putem interzice acest lucru cu "
"`#[deny(unsafe_op_in_unsafe_fn)]`. 칉ncerca탵i s캒-l ad캒uga탵i 탳i vede탵i ce se "
"칥nt칙mpl캒."

#: src/unsafe-rust/unsafe-traits.md
msgid "Implementing Unsafe Traits"
msgstr "Implementarea tr캒s캒turilor nesigure"

#: src/unsafe-rust/unsafe-traits.md
#, fuzzy
msgid ""
"Like with functions, you can mark a trait as `unsafe` if the implementation "
"must guarantee particular conditions to avoid undefined behaviour."
msgstr ""
"Ca 탳i 칥n cazul func탵iilor, pute탵i marca o tr캒s캒tur캒 ca fiind \"nesigur캒\" "
"dac캒 implementarea trebuie s캒 garanteze anumite condi탵ii pentru a evita un "
"comportament nedefinit."

#: src/unsafe-rust/unsafe-traits.md
#, fuzzy
msgid ""
"For example, the `zerocopy` crate has an unsafe trait that looks [something "
"like this](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html):"
msgstr ""
"De exemplu, categoria `zerocopy` are o tr캒s캒tur캒 nesigur캒 care arat캒 [ceva "
"de genul acesta](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes."
"html):"

#: src/unsafe-rust/unsafe-traits.md
#, fuzzy
msgid ""
"/// ...\n"
"/// # Safety\n"
"/// The type must have a defined representation and no padding.\n"
msgstr ""
"/// ...\n"
"/// # Siguran탵캒\n"
"/// Tipul trebuie s캒 aib캒 o reprezentare definit캒 탳i s캒 nu aib캒 umplutur캒.\n"

#: src/unsafe-rust/unsafe-traits.md
#, fuzzy
msgid "// SAFETY: `u32` has a defined representation and no padding.\n"
msgstr ""
"// Sigur, deoarece u32 are o reprezentare definit캒 탳i nu are umplutur캒.\n"

#: src/unsafe-rust/unsafe-traits.md
#, fuzzy
msgid ""
"There should be a `# Safety` section on the Rustdoc for the trait explaining "
"the requirements for the trait to be safely implemented."
msgstr ""
"Ar trebui s캒 existe o sec탵iune `# Siguran탵캒` 칥n Rustdoc pentru tr캒s캒tura "
"care s캒 explice cerin탵ele pentru ca tr캒s캒tura s캒 fie implementat캒 칥n "
"siguran탵캒."

#: src/unsafe-rust/unsafe-traits.md
#, fuzzy
msgid ""
"The actual safety section for `AsBytes` is rather longer and more "
"complicated."
msgstr ""
"Sec탵iunea de siguran탵캒 efectiv캒 pentru `AsBytes` este mai lung캒 탳i mai "
"complicat캒."

#: src/unsafe-rust/unsafe-traits.md
#, fuzzy
msgid "The built-in `Send` and `Sync` traits are unsafe."
msgstr "Tr캒s캒turile 칥ncorporate `Send` 탳i `Sync` sunt nesigure."

#: src/unsafe-rust/exercise.md
msgid "Safe FFI Wrapper"
msgstr "칉nf캒탳ur캒torul FFI sigur"

#: src/unsafe-rust/exercise.md
msgid ""
"Rust has great support for calling functions through a _foreign function "
"interface_ (FFI). We will use this to build a safe wrapper for the `libc` "
"functions you would use from C to read the names of files in a directory."
msgstr ""
"Rust are un suport excelent pentru apelarea func탵iilor prin intermediul unei "
"interfe탵e de func탵ii str캒ine (FFI). Vom folosi acest lucru pentru a construi "
"un 칥nveli탳 sigur pentru func탵iile `libc` pe care le-a탵i folosi din C pentru "
"a citi numele fi탳ierelor dintr-un director."

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "You will want to consult the manual pages:"
msgstr "Va trebui s캒 consulta탵i paginile din manual:"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "[`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)"
msgstr "[`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "[`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)"
msgstr "[`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "[`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"
msgstr "[`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid ""
"You will also want to browse the [`std::ffi`](https://doc.rust-lang.org/std/"
"ffi/) module. There you find a number of string types which you need for the "
"exercise:"
msgstr ""
"De asemenea, ve탵i dori s캒 naviga탵i 칥n modulul [`std::ffi`](https://doc.rust-"
"lang.org/std/ffi/). Acolo ve탵i g캒si o serie de tipuri de 탳iruri de caractere "
"de care ave탵i nevoie pentru exerci탵iu:"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "Encoding"
msgstr "Codificare"

#: src/unsafe-rust/exercise.md
msgid "Use"
msgstr "Folose탳te"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid ""
"[`str`](https://doc.rust-lang.org/std/primitive.str.html) and [`String`]"
"(https://doc.rust-lang.org/std/string/struct.String.html)"
msgstr ""
"[`str`](https://doc.rust-lang.org/std/primitive.str.html) 탳i [`String`]"
"(https://doc.rust-lang.org/std/string/struct.String.html)"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "UTF-8"
msgstr ""
"탲irurile de caractere Rust sunt codificate UTF-8 탳i pot con탵ine orice "
"caracter Unicode."

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "Text processing in Rust"
msgstr "Prelucrarea textului 칥n Rust"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid ""
"[`CStr`](https://doc.rust-lang.org/std/ffi/struct.CStr.html) and [`CString`]"
"(https://doc.rust-lang.org/std/ffi/struct.CString.html)"
msgstr ""
"[`CStr`](https://doc.rust-lang.org/std/ffi/struct.CStr.html) 탳i [`CString`]"
"(https://doc.rust-lang.org/std/ffi/struct.CString.html)"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "NUL-terminated"
msgstr "Terminat cu NUL"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "Communicating with C functions"
msgstr "Comunicarea cu func탵iile C"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid ""
"[`OsStr`](https://doc.rust-lang.org/std/ffi/struct.OsStr.html) and "
"[`OsString`](https://doc.rust-lang.org/std/ffi/struct.OsString.html)"
msgstr ""
"[`OsStr`](https://doc.rust-lang.org/std/ffi/struct.OsStr.html) 탳i "
"[`OsString`](https://doc.rust-lang.org/std/ffi/struct.OsString.html)"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "OS-specific"
msgstr "Specific sistemului de operare"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "Communicating with the OS"
msgstr "Comunicarea cu sistemul de operare"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "You will convert between all these types:"
msgstr "Ve탵i face conversia 칥ntre toate aceste tipuri:"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid ""
"`&str` to `CString`: you need to allocate space for a trailing `\\0` "
"character,"
msgstr ""
"`&str` 칥n `CString`: trebuie s캒 aloca탵i spa탵iu pentru un caracter `\\0` la "
"sf칙r탳it,"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "`CString` to `*const i8`: you need a pointer to call C functions,"
msgstr ""
"`CString` la `*const i8`: ave탵i nevoie de un pointer pentru a apela "
"func탵iile C,"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid ""
"`*const i8` to `&CStr`: you need something which can find the trailing `\\0` "
"character,"
msgstr ""
"`*const i8` la `&CStr`: ave탵i nevoie de ceva care s캒 poat캒 g캒si caracterul "
"`\\0` din urm캒,"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid ""
"`&CStr` to `&[u8]`: a slice of bytes is the universal interface for \"some "
"unknown data\","
msgstr ""
"`&CStr` la `&[u8]`: o por탵iune de octe탵i este interfa탵a universal캒 pentru "
"\"unele date necunoscute\","

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid ""
"`&[u8]` to `&OsStr`: `&OsStr` is a step towards `OsString`, use [`OsStrExt`]"
"(https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html) to create it,"
msgstr ""
"`&&[u8]` la `&OsStr`: `&OsStr` este un pas spre `OsString`, utiliza탵i "
"[`OsStrExt`](https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html) "
"pentru a-l crea,"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid ""
"`&OsStr` to `OsString`: you need to clone the data in `&OsStr` to be able to "
"return it and call `readdir` again."
msgstr ""
"`&OsStr` 칥n `OsString`: trebuie s캒 clona탵i datele din `&OsStr` pentru a le "
"putea returna 탳i a apela din nou `readdir`."

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid ""
"The [Nomicon](https://doc.rust-lang.org/nomicon/ffi.html) also has a very "
"useful chapter about FFI."
msgstr ""
"[Nomicon](https://doc.rust-lang.org/nomicon/ffi.html) are, de asemenea, un "
"capitol foarte util despre FFI."

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing "
"functions and methods:"
msgstr ""
"Copia탵i codul de mai jos 칥n <https://play.rust-lang.org/> 탳i completa탵i "
"func탵iile 탳i metodele care lipsesc:"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#, fuzzy
msgid "\"macos\""
msgstr "\"macos\""

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#, fuzzy
msgid "// Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
msgstr "// Tip opac. A se vedea https://doc.rust-lang.org/nomicon/ffi.html.\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#, fuzzy
msgid ""
"// Layout according to the Linux man page for readdir(3), where ino_t and\n"
"    // off_t are resolved according to the definitions in\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"
msgstr ""
"// Dispunere 칥n conformitate cu pagina de manual Linux pentru readdir(3), "
"unde ino_t 탳i\n"
"    // off_t sunt rezolvate 칥n conformitate cu defini탵iile din\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#, fuzzy
msgid "// Layout according to the macOS man page for dir(5).\n"
msgstr ""
"// Dispunere 칥n conformitate cu pagina de manual macOS pentru dir(5).\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#, fuzzy
msgid "\"x86_64\""
msgstr "\"x86_64\""

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#, fuzzy
msgid ""
"// See https://github.com/rust-lang/libc/issues/414 and the section on\n"
"        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).\n"
"        //\n"
"        // \"Platforms that existed before these updates were available\" "
"refers\n"
"        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and "
"PowerPC.\n"
msgstr ""
"// A se vedea https://github.com/rust-lang/libc/issues/414 탳i sec탵iunea "
"privind\n"
"        // _DARWIN_FEATURE_64_BIT_INODE din pagina de manual macOS pentru "
"stat(2).\n"
"        //\n"
"        // \"Platformele care existau 칥nainte ca aceste actualiz캒ri s캒 fie "
"disponibile\" se refer캒 la\n"
"        // la macOS (spre deosebire de iOS / wearOS / etc.) pe Intel 탳i "
"PowerPC.\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#, fuzzy
msgid "\"readdir$INODE64\""
msgstr "\"readdir$INODE64\""

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#, fuzzy
msgid ""
"// Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
msgstr ""
"// Apela탵i opendir 탳i returna탵i o valoare Ok dac캒 a func탵ionat,\n"
"        // 칥n caz contrar, se returneaz캒 Err cu un mesaj.\n"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "// Keep calling readdir until we get a NULL pointer back.\n"
msgstr ""
"// Continua탵i s캒 apela탵i readdir p칙n캒 c칙nd primim 칥napoi un pointer NULL.\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#, fuzzy
msgid "// Call closedir as needed.\n"
msgstr "// Chema탵i closedir dup캒 cum este necesar.\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "\".\""
msgstr "\".\""

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#, fuzzy
msgid "\"files: {:#?}\""
msgstr ""
"Copia탵i urm캒torul cod server 탳i client 칥n `src/bin/server.rs` 탳i, respectiv, "
"`src/bin/client.rs`. Sarcina dumneavoastr캒 este de a completa aceste fi탳iere "
"a탳a cum este descris mai jos."

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "\"Invalid path: {err}\""
msgstr "\"Invalid path: {err}\""

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "// SAFETY: path.as_ptr() cannot be NULL.\n"
msgstr "// SAFETY: path.as_ptr() nu poate fi NULL.\n"

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "\"Could not open {:?}\""
msgstr "\"Nu s-a putut deschide {:?}\""

#: src/unsafe-rust/solution.md
#, fuzzy
msgid ""
"// Keep calling readdir until we get a NULL pointer back.\n"
"        // SAFETY: self.dir is never NULL.\n"
msgstr ""
"// Continua탵i s캒 apela탵i readdir p칙n캒 c칙nd primim 칥napoi un pointer NULL.\n"
"        // SIGURAN탴캑: self.dir nu este niciodat캒 NULL.\n"

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "// We have reached the end of the directory.\n"
msgstr "// Am ajuns la sf칙r탳itul directorului.\n"

#: src/unsafe-rust/solution.md
#, fuzzy
msgid ""
"// SAFETY: dirent is not NULL and dirent.d_name is NUL\n"
"        // terminated.\n"
msgstr ""
"// SAFETY: dirent nu este NULL 탳i dirent.d_name este NUL\n"
"        // terminat.\n"

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "// SAFETY: self.dir is not NULL.\n"
msgstr "// SIGURAN탴캑: self.dir nu este NULL.\n"

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "\"Could not close {:?}\""
msgstr "\"Nu s-a putut 칥nchide {:?}\""

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "\"no-such-directory\""
msgstr "\"no-such-directory\""

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "\"Non UTF-8 character in path\""
msgstr "\"Caracter non-UTF-8 칥n calea de acces\""

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "\"..\""
msgstr "\"..\""

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "\"foo.txt\""
msgstr "\"foo.txt\""

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "\"The Foo Diaries\\n\""
msgstr "\"The Foo Diaries\\n\""

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "\"bar.png\""
msgstr "\"bar.png\""

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "\"<PNG>\\n\""
msgstr "\"<PNG>\\n\""

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "\"crab.rs\""
msgstr "\"crab.rs\""

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "\"//! Crab\\n\""
msgstr "\"//! Crab\\n\""

#: src/android.md
#, fuzzy
msgid "Welcome to Rust in Android"
msgstr "Bine a탵i venit la Rust 칥n Android"

#: src/android.md
#, fuzzy
msgid ""
"Rust is supported for system software on Android. This means that you can "
"write new services, libraries, drivers or even firmware in Rust (or improve "
"existing code as needed)."
msgstr ""
"Rust este acceptat pentru dezvoltarea platformei native pe Android. Acest "
"lucru 칥nseamn캒 c캒 pute탵i scrie noi servicii de sistem de operare 칥n Rust, "
"precum 탳i extinde serviciile existente."

#: src/android.md
#, fuzzy
msgid ""
"We will attempt to call Rust from one of your own projects today. So try to "
"find a little corner of your code base where we can move some lines of code "
"to Rust. The fewer dependencies and \"exotic\" types the better. Something "
"that parses some raw bytes would be ideal."
msgstr ""
"Vom 칥ncerca s캒 칥l sun캒m pe Rust de la unul dintre proiectele dumneavoastr캒 "
"ast캒zi. A탳adar, 칥ncerca탵i s캒 g캒si탵i un col탵i탳or din baza dumneavoastr캒 de "
"cod 칥n care s캒 putem muta c칙teva linii de cod 칥n Rust. Cu c칙t mai pu탵ine "
"dependen탵e 탳i tipuri \"exotice\", cu at칙t mai bine. Ceva care analizeaz캒 "
"ni탳te octe탵i brute ar fi ideal."

#: src/android.md
#, fuzzy
msgid ""
"The speaker may mention any of the following given the increased use of Rust "
"in Android:"
msgstr ""
"Vorbitorul poate men탵iona oricare dintre urm캒toarele, av칙nd 칥n vedere "
"utilizarea sporit캒 a Rust 칥n Android:"

#: src/android.md
#, fuzzy
msgid ""
"Service example: [DNS over HTTP](https://security.googleblog.com/2022/07/dns-"
"over-http3-in-android.html)"
msgstr ""
"Exemplu de serviciu: [DNS prin HTTP](https://security.googleblog.com/2022/07/"
"dns-over-http3-in-android.html)"

#: src/android.md
#, fuzzy
msgid ""
"Libraries: [Rutabaga Virtual Graphics Interface](https://crosvm.dev/book/"
"appendix/rutabaga_gfx.html)"
msgstr ""
"Biblioteci: [Rutabaga Virtual Graphics Interface](https://crosvm.dev/book/"
"appendix/rutabaga_gfx.html)"

#: src/android.md
#, fuzzy
msgid ""
"Kernel Drivers: [Binder](https://lore.kernel.org/rust-for-linux/20231101-"
"rust-binder-v1-0-08ba9197f637@google.com/)"
msgstr ""
"Driverele nucleului: [Binder](https://lore.kernel.org/rust-for-"
"linux/20231101-rust-binder-v1-0-08ba9197f637@google.com/)"

#: src/android.md
#, fuzzy
msgid ""
"Firmware: [pKVM firmware](https://security.googleblog.com/2023/10/bare-metal-"
"rust-in-android.html)"
msgstr ""
"Firmware: [pKVM firmware](https://security.googleblog.com/2023/10/bare-metal-"
"rust-in-android.html)"

#: src/android/setup.md
#, fuzzy
msgid ""
"We will be using a Cuttlefish Android Virtual Device to test our code. Make "
"sure you have access to one or create a new one with:"
msgstr ""
"Vom folosi un dispozitiv virtual Android pentru a testa codul nostru. "
"Asigura탵i-v캒 c캒 ave탵i acces la unul sau crea탵i unul nou cu:"

#: src/android/setup.md
#, fuzzy
msgid ""
"Please see the [Android Developer Codelab](https://source.android.com/docs/"
"setup/start) for details."
msgstr ""
"V캒 rug캒m s캒 consulta탵i [Android Developer Codelab](https://source.android."
"com/docs/setup/start) pentru detalii."

#: src/android/setup.md
#, fuzzy
msgid ""
"Cuttlefish is a reference Android device designed to work on generic Linux "
"desktops. MacOS support is also planned."
msgstr ""
"Cuttlefish este un dispozitiv Android de referin탵캒 conceput pentru a "
"func탵iona pe desktop-uri Linux generice. De asemenea, este planificat 탳i "
"suport pentru MacOS."

#: src/android/setup.md
#, fuzzy
msgid ""
"The Cuttlefish system image maintains high fidelity to real devices, and is "
"the ideal emulator to run many Rust use cases."
msgstr ""
"Imaginea de sistem Cuttlefish p캒streaz캒 o fidelitate ridicat캒 fa탵캒 de "
"dispozitivele reale 탳i este emulatorul ideal pentru a rula multe cazuri de "
"utilizare Rust."

#: src/android/build-rules.md
#, fuzzy
msgid "The Android build system (Soong) supports Rust via a number of modules:"
msgstr ""
"Sistemul de compilare Android (Soong) accept캒 Rust prin intermediul unui "
"num캒r de module:"

#: src/android/build-rules.md
msgid "Module Type"
msgstr "Tipul de modul"

#: src/android/build-rules.md
msgid "Description"
msgstr "Descriere"

#: src/android/build-rules.md
#, fuzzy
msgid "`rust_binary`"
msgstr ""
"```javascript\n"
"rust_binary {\n"
"    name: \"cxx_test\",\n"
"    srcs: [\"lib.rs\"],\n"
"    rustlibs: [\"libcxx\"],\n"
"    static_libs: [\"libcxx_test_cpp\"],\n"
"}\n"
"```"

#: src/android/build-rules.md
#, fuzzy
msgid "Produces a Rust binary."
msgstr "Produce un binar Rust."

#: src/android/build-rules.md
#, fuzzy
msgid "`rust_library`"
msgstr "`rust_library`"

#: src/android/build-rules.md
#, fuzzy
msgid "Produces a Rust library, and provides both `rlib` and `dylib` variants."
msgstr ""
"Produce o bibliotec캒 Rust 탳i ofer캒 at칙t variantele `rlib`, c칙t 탳i `dylib`."

#: src/android/build-rules.md
#, fuzzy
msgid "`rust_ffi`"
msgstr "`rust_ffi`"

#: src/android/build-rules.md
#, fuzzy
msgid ""
"Produces a Rust C library usable by `cc` modules, and provides both static "
"and shared variants."
msgstr ""
"Produce o bibliotec캒 Rust C utilizabil캒 de modulele `cc` 탳i ofer캒 at칙t "
"variante statice c칙t 탳i partajate."

#: src/android/build-rules.md
#, fuzzy
msgid "`rust_proc_macro`"
msgstr "`rust_proc_macro`"

#: src/android/build-rules.md
#, fuzzy
msgid ""
"Produces a `proc-macro` Rust library. These are analogous to compiler "
"plugins."
msgstr ""
"Produce o bibliotec캒 Rust `proc-macro`. Acestea sunt analoge cu plugin-urile "
"de compilator."

#: src/android/build-rules.md
#, fuzzy
msgid "`rust_test`"
msgstr "`rust_test`"

#: src/android/build-rules.md
#, fuzzy
msgid "Produces a Rust test binary that uses the standard Rust test harness."
msgstr ""
"Produce un binar de testare Rust care utilizeaz캒 harna탳amentul standard de "
"testare Rust."

#: src/android/build-rules.md
#, fuzzy
msgid "`rust_fuzz`"
msgstr "`rust_fuzz`"

#: src/android/build-rules.md
#, fuzzy
msgid "Produces a Rust fuzz binary leveraging `libfuzzer`."
msgstr "Produce un binar Rust fuzz folosind `libfuzzer`."

#: src/android/build-rules.md
#, fuzzy
msgid "`rust_protobuf`"
msgstr "`rust_protobuf`"

#: src/android/build-rules.md
#, fuzzy
msgid ""
"Generates source and produces a Rust library that provides an interface for "
"a particular protobuf."
msgstr ""
"Genereaz캒 sursa 탳i produce o bibliotec캒 Rust care ofer캒 o interfa탵캒 pentru "
"un anumit protobuf."

#: src/android/build-rules.md
#, fuzzy
msgid "`rust_bindgen`"
msgstr "`rust_bindgen`"

#: src/android/build-rules.md
#, fuzzy
msgid ""
"Generates source and produces a Rust library containing Rust bindings to C "
"libraries."
msgstr ""
"Genereaz캒 sursa 탳i produce o bibliotec캒 Rust care con탵ine leg캒turi Rust "
"pentru bibliotecile C."

#: src/android/build-rules.md
#, fuzzy
msgid "We will look at `rust_binary` and `rust_library` next."
msgstr "칉n continuare vom analiza `rust_binary` 탳i `rust_library`."

#: src/android/build-rules.md
#, fuzzy
msgid "Additional items speaker may mention:"
msgstr "Alte elemente pe care vorbitorul le poate men탵iona:"

#: src/android/build-rules.md
#, fuzzy
msgid ""
"Cargo is not optimized for multi-language repos, and also downloads packages "
"from the internet."
msgstr ""
"Cargo nu este optimizat pentru depozite multilingve 탳i, de asemenea, "
"descarc캒 pachete de pe internet."

#: src/android/build-rules.md
#, fuzzy
msgid ""
"For compliance and performance, Android must have crates in-tree. It must "
"also interop with C/C++/Java code. Soong fills that gap."
msgstr ""
"Pentru conformitate 탳i performan탵캒, Android trebuie s캒 aib캒 cratere 칥n "
"copac. De asemenea, trebuie s캒 interac탵ioneze cu codul C/C++/Java. Soong "
"umple acest gol."

#: src/android/build-rules.md
#, fuzzy
msgid ""
"Soong has many similarities to Bazel, which is the open-source variant of "
"Blaze (used in google3)."
msgstr ""
"Soong are multe asem캒n캒ri cu Bazel, care este varianta open-source a lui "
"Blaze (utilizat캒 칥n google3)."

#: src/android/build-rules.md
#, fuzzy
msgid ""
"There is a plan to transition [Android](https://source.android.com/docs/"
"setup/build/bazel/introduction), [ChromeOS](https://chromium.googlesource."
"com/chromiumos/bazel/), and [Fuchsia](https://source.android.com/docs/setup/"
"build/bazel/introduction) to Bazel."
msgstr ""
"Exist캒 un plan de tranzi탵ie de la [Android](https://source.android.com/docs/"
"setup/build/bazel/introduction), [ChromeOS](https://chromium.googlesource."
"com/chromiumos/bazel/) 탳i [Fuchsia](https://source.android.com/docs/setup/"
"build/bazel/introduction) la Bazel."

#: src/android/build-rules.md
#, fuzzy
msgid "Learning Bazel-like build rules is useful for all Rust OS developers."
msgstr ""
"칉nv캒탵area regulilor de compilare de tip Bazel este util캒 pentru to탵i "
"dezvoltatorii Rust OS."

#: src/android/build-rules.md
#, fuzzy
msgid "Fun fact: Data from Star Trek is a Soong-type Android."
msgstr "Fapt amuzant: Data din Star Trek este un Android de tip Soong."

#: src/android/build-rules/binary.md
#, fuzzy
msgid "Rust Binaries"
msgstr "Binare Rust"

#: src/android/build-rules/binary.md
#, fuzzy
msgid ""
"Let us start with a simple application. At the root of an AOSP checkout, "
"create the following files:"
msgstr ""
"S캒 칥ncepem cu o aplica탵ie simpl캒. La r캒d캒cina unei verific캒ri AOSP, crea탵i "
"urm캒toarele fi탳iere:"

#: src/android/build-rules/binary.md src/android/build-rules/library.md
#, fuzzy
msgid "_hello_rust/Android.bp_:"
msgstr "hello_rust/Android.bp_:"

#: src/android/build-rules/binary.md
#, fuzzy
msgid "\"hello_rust\""
msgstr "\"hello_rust\""

#: src/android/build-rules/binary.md src/android/build-rules/library.md
#: src/android/logging.md
#, fuzzy
msgid "\"src/main.rs\""
msgstr "src/main.rs_:"

#: src/android/build-rules/binary.md src/android/build-rules/library.md
#, fuzzy
msgid "_hello_rust/src/main.rs_:"
msgstr "hello_rust/src/main.rs_:"

#: src/android/build-rules/binary.md src/android/build-rules/library.md
#, fuzzy
msgid "//! Rust demo.\n"
msgstr "//! Demo Rust.\n"

#: src/android/build-rules/binary.md src/android/build-rules/library.md
#, fuzzy
msgid "/// Prints a greeting to standard output.\n"
msgstr "/// Tip캒re탳te un mesaj de salut pe ie탳irea standard.\n"

#: src/android/build-rules/binary.md src/exercises/chromium/build-rules.md
#, fuzzy
msgid "\"Hello from Rust!\""
msgstr "\"Bun캒 ziua de la Rust!\""

#: src/android/build-rules/binary.md
#, fuzzy
msgid "You can now build, push, and run the binary:"
msgstr "Acum pute탵i s캒 construi탵i, s캒 distribui탵i 탳i s캒 rula탵i fi탳ierul binar:"

#: src/android/build-rules/binary.md
#, fuzzy
msgid ""
"```shell\n"
"m hello_rust\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust\" /data/local/tmp\n"
"adb shell /data/local/tmp/hello_rust\n"
"```"
msgstr ""
"```shell\n"
"m hello_rust\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust /data/local/tmp\"\n"
"adb shell /data/local/tmp/hello_rust\n"
"```"

#: src/android/build-rules/library.md
#, fuzzy
msgid "Rust Libraries"
msgstr "Biblioteci Rust"

#: src/android/build-rules/library.md
#, fuzzy
msgid "You use `rust_library` to create a new Rust library for Android."
msgstr ""
"Utiliza탵i `rust_library` pentru a crea o nou캒 bibliotec캒 Rust pentru Android."

#: src/android/build-rules/library.md
#, fuzzy
msgid "Here we declare a dependency on two libraries:"
msgstr "Aici declar캒m o dependen탵캒 fa탵캒 de dou캒 biblioteci:"

#: src/android/build-rules/library.md
#, fuzzy
msgid "`libgreeting`, which we define below,"
msgstr "`libgreeting`, pe care 칥l definim mai jos,"

#: src/android/build-rules/library.md
#, fuzzy
msgid ""
"`libtextwrap`, which is a crate already vendored in [`external/rust/crates/`]"
"(https://cs.android.com/android/platform/superproject/+/master:external/rust/"
"crates/)."
msgstr ""
"`libtextwrap`, care este un crate deja v칙ndut 칥n [`external/rust/crates/`]"
"(https://cs.android.com/android/platform/superproject/+/master:external/rust/"
"crates/)."

#: src/android/build-rules/library.md
#, fuzzy
msgid "\"hello_rust_with_dep\""
msgstr "\"hello_rust_with_dep\""

#: src/android/build-rules/library.md
#, fuzzy
msgid "\"libgreetings\""
msgstr "\"libgreetings\""

#: src/android/build-rules/library.md
#, fuzzy
msgid "\"libtextwrap\""
msgstr "\"libtextwrap\""

#: src/android/build-rules/library.md
#, fuzzy
msgid "// Need this to avoid dynamic link error.\n"
msgstr "// Este necesar pentru a evita eroarea de link dinamic.\n"

#: src/android/build-rules/library.md
#, fuzzy
msgid "\"greetings\""
msgstr "\"Salut캒ri\""

#: src/android/build-rules/library.md
#: src/android/aidl/example-service/service.md src/android/testing.md
#: src/android/interoperability/java.md
#, fuzzy
msgid "\"src/lib.rs\""
msgstr "src/main.rs_:"

#: src/android/build-rules/library.md
#, fuzzy
msgid "_hello_rust/src/lib.rs_:"
msgstr "hello_rust/src/lib.rs_:"

#: src/android/build-rules/library.md
#, fuzzy
msgid "//! Greeting library.\n"
msgstr "//! Biblioteca de felicit캒ri.\n"

#: src/android/build-rules/library.md
#, fuzzy
msgid "/// Greet `name`.\n"
msgstr "/// Saluta탵i `name`.\n"

#: src/android/build-rules/library.md
#, fuzzy
msgid "\"Hello {name}, it is very nice to meet you!\""
msgstr "\"Bun캒 ziua {name}, m캒 bucur s캒 v캒 cunosc!\""

#: src/android/build-rules/library.md
#, fuzzy
msgid "You build, push, and run the binary like before:"
msgstr "Construi탵i, distribui탵i 탳i rula탵i programul binar la fel ca 칥nainte:"

#: src/android/build-rules/library.md
#, fuzzy
msgid ""
"```shell\n"
"m hello_rust_with_dep\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/hello_rust_with_dep\n"
"```"
msgstr ""
"```shell\n"
"m hello_rust_with_dep\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/hello_rust_with_dep\n"
"```"

#: src/android/aidl.md
#, fuzzy
msgid ""
"The [Android Interface Definition Language (AIDL)](https://developer.android."
"com/guide/components/aidl) is supported in Rust:"
msgstr ""
"Limbajul [Android Interface Definition Language (AIDL)](https://developer."
"android.com/guide/components/aidl) este acceptat 칥n Rust:"

#: src/android/aidl.md
#, fuzzy
msgid "Rust code can call existing AIDL servers,"
msgstr "Codul Rust poate apela serverele AIDL existente,"

#: src/android/aidl.md
#, fuzzy
msgid "You can create new AIDL servers in Rust."
msgstr "Pute탵i crea noi servere AIDL 칥n Rust."

#: src/android/aidl/birthday-service.md
#, fuzzy
msgid ""
"To illustrate how to use Rust with Binder, we're going to walk through the "
"process of creating a Binder interface. We're then going to both implement "
"the described service and write client code that talks to that service."
msgstr ""
"Pentru a ilustra cum s캒 folosim Rust cu Binder, vom parcurge procesul de "
"creare a unei interfe탵e Binder. Apoi, vom implementa serviciul descris 탳i "
"vom scrie codul clientului care vorbe탳te cu serviciul respectiv."

#: src/android/aidl/example-service/interface.md
#, fuzzy
msgid "AIDL Interfaces"
msgstr "Interfe탵e AIDL"

#: src/android/aidl/example-service/interface.md
#, fuzzy
msgid "You declare the API of your service using an AIDL interface:"
msgstr "Declara탵i API-ul serviciului dumneavoastr캒 utiliz칙nd o interfa탵캒 AIDL:"

#: src/android/aidl/example-service/interface.md
#: src/android/aidl/example-service/service-bindings.md
#, fuzzy
msgid ""
"_birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl_:"
msgstr ""
"_birthday_service/aidl/com/exemple/birthdayservice/IBirthdayService.aidl_:"

#: src/android/aidl/example-service/interface.md
#: src/android/aidl/example-service/service-bindings.md
#: src/android/aidl/example-service/changing-definition.md
#, fuzzy
msgid "/** Birthday service interface. */"
msgstr "/** Interfa탵캒 de serviciu de ziua de na탳tere. */"

#: src/android/aidl/example-service/interface.md
#: src/android/aidl/example-service/service-bindings.md
#: src/android/aidl/example-service/changing-definition.md
#, fuzzy
msgid "/** Generate a Happy Birthday message. */"
msgstr "/** Genereaz캒 un mesaj de \"La mul탵i ani\". */"

#: src/android/aidl/example-service/interface.md
#, fuzzy
msgid "_birthday_service/aidl/Android.bp_:"
msgstr "_birthday_service/aidl/Android.bp_:"

#: src/android/aidl/example-service/interface.md
#, fuzzy
msgid "\"com.example.birthdayservice\""
msgstr "\"com.example.birthdayservice\""

#: src/android/aidl/example-service/interface.md
#, fuzzy
msgid "\"com/example/birthdayservice/*.aidl\""
msgstr ""
"_birthday_service/aidl/com/exemple/birthdayservice/IBirthdayService.aidl_:"

#: src/android/aidl/example-service/interface.md
#, fuzzy
msgid "// Rust is not enabled by default\n"
msgstr "// Rust nu este activat 칥n mod implicit\n"

#: src/android/aidl/example-service/interface.md
#, fuzzy
msgid ""
"Note that the directory structure under the `aidl/` directory needs to match "
"the package name used in the AIDL file, i.e. the package is `com.example."
"birthdayservice` and the file is at `aidl/com/example/IBirthdayService.aidl`."
msgstr ""
"Re탵ine탵i c캒 structura directoarelor din directorul `aidl/` trebuie s캒 "
"corespund캒 cu numele pachetului utilizat 칥n fi탳ierul AIDL, de exemplu, "
"pachetul este `com.example.birthdayservice`, iar fi탳ierul se afl캒 la `aidl/"
"com/example/IBirthdayService.aidl`."

#: src/android/aidl/example-service/service-bindings.md
#, fuzzy
msgid "Generated Service API"
msgstr "Serviciul generat API"

#: src/android/aidl/example-service/service-bindings.md
#, fuzzy
msgid ""
"Binder generates a trait corresponding to the interface definition. trait to "
"talk to the service."
msgstr ""
"Binder genereaz캒 o tr캒s캒tur캒 corespunz캒toare defini탵iei interfe탵ei. "
"tr캒s캒tur캒 pentru a vorbi cu serviciul."

#: src/android/aidl/example-service/service-bindings.md
#, fuzzy
msgid "_Generated trait_:"
msgstr "Cod Rust generat:"

#: src/android/aidl/example-service/service-bindings.md
#, fuzzy
msgid ""
"Your service will need to implement this trait, and your client will use "
"this trait to talk to the service."
msgstr ""
"Serviciul dvs. va trebui s캒 implementeze aceast캒 tr캒s캒tur캒, iar clientul "
"dvs. va folosi aceast캒 tr캒s캒tur캒 pentru a vorbi cu serviciul."

#: src/android/aidl/example-service/service-bindings.md
#, fuzzy
msgid ""
"The generated bindings can be found at `out/soong/.intermediates/<path to "
"module>/`."
msgstr ""
"Leg캒turile generate pot fi g캒site la `out/soong/.intermediates/<path to "
"module>/`."

#: src/android/aidl/example-service/service-bindings.md
#, fuzzy
msgid ""
"Point out how the generated function signature, specifically the argument "
"and return types, correspond the interface definition."
msgstr ""
"Eviden탵ia탵i modul 칥n care semn캒tura func탵iei generate, 칥n special tipurile "
"de argumente 탳i de retur, corespund defini탵iei interfe탵ei."

#: src/android/aidl/example-service/service-bindings.md
#, fuzzy
msgid ""
"`String` for an argument results in a different Rust type than `String` as a "
"return type."
msgstr ""
"`String` pentru un argument are ca rezultat un tip Rust diferit de `String` "
"ca tip de returnare."

#: src/android/aidl/example-service/service.md
#, fuzzy
msgid "Service Implementation"
msgstr "Implementarea serviciilor"

#: src/android/aidl/example-service/service.md
#, fuzzy
msgid "We can now implement the AIDL service:"
msgstr "Acum putem implementa serviciul AIDL:"

#: src/android/aidl/example-service/service.md
#: src/android/aidl/example-service/changing-implementation.md
#, fuzzy
msgid "_birthday_service/src/lib.rs_:"
msgstr "_birthday_service/src/lib.rs_:"

#: src/android/aidl/example-service/service.md
#, fuzzy
msgid "/// The `IBirthdayService` implementation.\n"
msgstr "Implementarea serviciilor"

#: src/android/aidl/example-service/service.md
#: src/android/aidl/example-service/changing-implementation.md
#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "\"Happy Birthday {name}, congratulations with the {years} years!\""
msgstr "\"La mul탵i ani {name}, felicit캒ri cu {years} ani!\""

#: src/android/aidl/example-service/service.md
#: src/android/aidl/example-service/server.md
#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "_birthday_service/Android.bp_:"
msgstr "_birthday_service/Android.bp_:"

#: src/android/aidl/example-service/service.md
#: src/android/aidl/example-service/server.md
#, fuzzy
msgid "\"libbirthdayservice\""
msgstr "_birthday_service/src/lib.rs_:"

#: src/android/aidl/example-service/service.md
#: src/android/aidl/example-service/server.md
#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "\"birthdayservice\""
msgstr "_birthday_service/src/lib.rs_:"

#: src/android/aidl/example-service/service.md
#: src/android/aidl/example-service/server.md
#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "\"com.example.birthdayservice-rust\""
msgstr "\"com.example.birthdayservice-rust\""

#: src/android/aidl/example-service/service.md
#: src/android/aidl/example-service/server.md
#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "\"libbinder_rs\""
msgstr "\"libbinder_rs\""

#: src/android/aidl/example-service/service.md
#, fuzzy
msgid ""
"Point out the path to the generated `IBirthdayService` trait, and explain "
"why each of the segments is necessary."
msgstr ""
"Indica탵i calea c캒tre tr캒s캒tura generat캒 `IBirthdayService` 탳i explica탵i de "
"ce este necesar fiecare dintre segmente."

#: src/android/aidl/example-service/service.md
#, fuzzy
msgid ""
"TODO: What does the `binder::Interface` trait do? Are there methods to "
"override? Where source?"
msgstr ""
"TODO: Ce face tr캒s캒tura `binder::Interface`? Exist캒 metode de suprascriere? "
"Unde se afl캒 sursa?"

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid "AIDL Server"
msgstr "Server AIDL"

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid "Finally, we can create a server which exposes the service:"
msgstr "칉n cele din urm캒, putem crea un server care s캒 expun캒 serviciul:"

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid "_birthday_service/src/server.rs_:"
msgstr "_birthday_service/src/server.rs_:"

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid "//! Birthday service.\n"
msgstr "//! Slujb캒 de ziua de na탳tere.\n"

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid "/// Entry point for birthday service.\n"
msgstr "/// Punct de intrare pentru serviciul de aniversare.\n"

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid "\"Failed to register service\""
msgstr "\"Nu a reu탳it s캒 칥nregistreze serviciul\""

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid "\"birthday_server\""
msgstr "_birthday_service/src/lib.rs_:"

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid "\"src/server.rs\""
msgstr "src/bin/server.rs_:"

#: src/android/aidl/example-service/server.md
#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "// To avoid dynamic link error.\n"
msgstr "// Pentru a evita eroarea de leg캒tur캒 dinamic캒.\n"

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid ""
"The process for taking a user-defined service implementation (in this case "
"the `BirthdayService` type, which implements the `IBirthdayService`) and "
"starting it as a Binder service has multiple steps, and may appear more "
"complicated than students are used to if they've used Binder from C++ or "
"another language. Explain to students why each step is necessary."
msgstr ""
"Procesul de preluare a implement캒rii unui serviciu definit de utilizator (칥n "
"acest caz, tipul `BirthdayService`, care implementeaz캒 `IBirthdayService`) "
"탳i pornirea acestuia ca serviciu Binder are mai mul탵i pa탳i 탳i poate p캒rea "
"mai complicat dec칙t sunt obi탳nui탵i studen탵ii care au folosit Binder din C++ "
"sau dintr-un alt limbaj. Explica탵i-le elevilor de ce este necesar fiecare "
"pas."

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid "Create an instance of your service type (`BirthdayService`)."
msgstr "Crea탵i o instan탵캒 a tipului dvs. de serviciu (`BirthdayService`)."

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid ""
"Wrap the service object in corresponding `Bn*` type (`BnBirthdayService` in "
"this case). This type is generated by Binder and provides the common Binder "
"functionality that would be provided by the `BnBinder` base class in C++. We "
"don't have inheritance in Rust, so instead we use composition, putting our "
"`BirthdayService` within the generated `BnBinderService`."
msgstr ""
"칉nf캒탳ura탵i obiectul serviciului 칥n tipul `Bn*` corespunz캒tor "
"(`BnBirthdayService` 칥n acest caz). Acest tip este generat de Binder 탳i "
"ofer캒 func탵ionalitatea comun캒 Binder care ar fi furnizat캒 de clasa de baz캒 "
"`BnBinder` 칥n C++. 칉n Rust nu avem mo탳tenire, a탳a c캒 칥n schimb folosim "
"compozi탵ia, pun칙nd `BirthdayService` 칥n cadrul `BnBinderService` generat."

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid ""
"Call `add_service`, giving it a service identifier and your service object "
"(the `BnBirthdayService` object in the example)."
msgstr ""
"Apela탵i `add_service`, d칙ndu-i un identificator de serviciu 탳i obiectul "
"serviciului dumneavoastr캒 (obiectul `BnBirthdayService` 칥n exemplul de fa탵캒)."

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid ""
"Call `join_thread_pool` to add the current thread to Binder's thread pool "
"and start listening for connections."
msgstr ""
"Apela탵i `join_thread_pool` pentru a ad캒uga firul curent la fondul de fire al "
"Binder 탳i pentru a 칥ncepe s캒 asculte conexiunile."

#: src/android/aidl/example-service/deploy.md
#, fuzzy
msgid "We can now build, push, and start the service:"
msgstr "Acum putem construi, 칥mpinge 탳i porni serviciul:"

#: src/android/aidl/example-service/deploy.md
#, fuzzy
msgid ""
"```shell\n"
"m birthday_server\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_server\" /data/local/"
"tmp\n"
"adb root\n"
"adb shell /data/local/tmp/birthday_server\n"
"```"
msgstr ""
"```shell\n"
"m birthday_server\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/birthday_server\n"
"```"

#: src/android/aidl/example-service/deploy.md
#, fuzzy
msgid "In another terminal, check that the service runs:"
msgstr "칉ntr-un alt terminal, verifica탵i dac캒 serviciul ruleaz캒:"

#: src/android/aidl/example-service/deploy.md
#, fuzzy
msgid "You can also call the service with `service call`:"
msgstr "De asemenea, pute탵i apela serviciul cu `service call`:"

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "AIDL Client"
msgstr "Client AIDL"

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "Finally, we can create a Rust client for our new service."
msgstr ""
"칉n cele din urm캒, putem crea un client Rust pentru noul nostru serviciu."

#: src/android/aidl/example-service/client.md
#: src/android/aidl/example-service/changing-implementation.md
#, fuzzy
msgid "_birthday_service/src/client.rs_:"
msgstr "_birthday_service/src/client.rs_:"

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "/// Call the birthday service.\n"
msgstr "/// Apelarea serviciului de aniversare.\n"

#: src/android/aidl/example-service/client.md src/android/aidl/types/objects.md
#: src/android/aidl/types/parcelables.md
#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "\"Failed to connect to BirthdayService\""
msgstr "\"Nu a reu탳it s캒 se conecteze la BirthdayService\""

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "// Call the service.\n"
msgstr "/// Apelarea serviciului de aniversare.\n"

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "\"{msg}\""
msgstr ""
"```rust,editable\n"
"enum Result {\n"
"    Ok(i32),\n"
"    Err(String),\n"
"}\n"
"\n"
"fn divide_in_two(n: i32) -> Result {\n"
"    if n % 2 == 0 {\n"
"        Result::Ok(n / 2)\n"
"    } else {\n"
"        Result::Err(format!(\"nu se poate 칥mp캒r탵i {n} 칥n dou캒 p캒r탵i "
"egale\"))\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let n = 100;\n"
"    match divide_in_two(n) {\n"
"        Result::Ok(half) => println!(\"{n} 칥mp캒r탵it la doi este {half}\"),\n"
"        Result::Err(msg) => println!(\"regret, a ap캒rut o eroare: {msg}\"),\n"
"    }\n"
"}\n"
"```"

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "\"birthday_client\""
msgstr "_birthday_service/src/client.rs_:"

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "\"src/client.rs\""
msgstr "src/bin/client.rs_:"

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "Notice that the client does not depend on `libbirthdayservice`."
msgstr "Observa탵i c캒 clientul nu depinde de `libbirthdayservice`."

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "Build, push, and run the client on your device:"
msgstr "Crea탵i, distribui탵i 탳i rula탵i clientul pe dispozitivul dvs:"

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid ""
"```shell\n"
"m birthday_client\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_client\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/birthday_client Charlie 60\n"
"```"
msgstr ""
"```shell\n"
"m birthday_client\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_client /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/birthday_client Charlie 60\n"
"```"

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid ""
"`Strong<dyn IBirthdayService>` is the trait object representing the service "
"that the client has connected to."
msgstr ""
"`Strong<dyn IBirthdayService>` este obiectul tr캒s캒tur캒 care reprezint캒 "
"serviciul la care s-a conectat clientul."

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid ""
"`Strong` is a custom smart pointer type for Binder. It handles both an in-"
"process ref count for the service trait object, and the global Binder ref "
"count that tracks how many processes have a reference to the object."
msgstr ""
"`Strong` este un tip de pointer inteligent personalizat pentru Binder. "
"Acesta gestioneaz캒 at칙t un num캒r de referin탵e 칥n cadrul procesului pentru "
"obiectul de serviciu, c칙t 탳i num캒rul global de referin탵e Binder care "
"urm캒re탳te c칙te procese au o referin탵캒 la obiect."

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid ""
"Note that the trait object that the client uses to talk to the service uses "
"the exact same trait that the server implements. For a given Binder "
"interface, there is a single Rust trait generated that both client and "
"server use."
msgstr ""
"Re탵ine탵i c캒 obiectul de tr캒s캒tur캒 pe care clientul 칥l utilizeaz캒 pentru a "
"vorbi cu serviciul utilizeaz캒 exact aceea탳i tr캒s캒tur캒 pe care o "
"implementeaz캒 serverul. Pentru o anumit캒 interfa탵캒 Binder, exist캒 o singur캒 "
"tr캒s캒tur캒 Rust generat캒 pe care o utilizeaz캒 at칙t clientul, c칙t 탳i serverul."

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid ""
"Use the same service identifier used when registering the service. This "
"should ideally be defined in a common crate that both the client and server "
"can depend on."
msgstr ""
"Utiliza탵i acela탳i identificator de serviciu utilizat la 칥nregistrarea "
"serviciului. Ideal ar fi ca acesta s캒 fie definit 칥ntr-o caset캒 comun캒 de "
"care s캒 depind캒 at칙t clientul, c칙t 탳i serverul."

#: src/android/aidl/example-service/changing-definition.md
#, fuzzy
msgid ""
"Let us extend the API with more functionality: we want to let clients "
"specify a list of lines for the birthday card:"
msgstr ""
"S캒 extindem API-ul cu mai multe func탵ionalit캒탵i: dorim s캒 permitem "
"clien탵ilor s캒 specifice o list캒 de linii pentru felicitarea de ziua de "
"na탳tere:"

#: src/android/aidl/example-service/changing-definition.md
#, fuzzy
msgid "This results in an updated trait definition for `IBirthdayService`:"
msgstr ""
"Aceasta are ca rezultat o defini탵ie actualizat캒 a tr캒s캒turii pentru "
"`IBirthdayService`:"

#: src/android/aidl/example-service/changing-definition.md
#, fuzzy
msgid ""
"Note how the `String[]` in the AIDL definition is translated as a "
"`&[String]` in Rust, i.e. that idiomatic Rust types are used in the "
"generated bindings wherever possible:"
msgstr ""
"Observa탵i cum `String[]` din defini탵ia AIDL este tradus ca `&[String]` 칥n "
"Rust, adic캒 tipurile idiomatice Rust sunt utilizate 칥n leg캒turile generate "
"ori de c칙te ori este posibil:"

#: src/android/aidl/example-service/changing-definition.md
#, fuzzy
msgid "`in` array arguments are translated to slices."
msgstr "argumentele matricei `in` sunt transformate 칥n felii."

#: src/android/aidl/example-service/changing-definition.md
#, fuzzy
msgid "`out` and `inout` args are translated to `&mut Vec<T>`."
msgstr "argetele `out` 탳i `inout` sunt traduse 칥n `&amp;mut Vec<T>`."

#: src/android/aidl/example-service/changing-definition.md
#, fuzzy
msgid "Return values are translated to returning a `Vec<T>`."
msgstr "Valorile de returnare sunt convertite 칥n returnarea unui `Vec<T>`."

#: src/android/aidl/example-service/changing-implementation.md
#, fuzzy
msgid "Updating Client and Service"
msgstr "Actualizarea clientului 탳i a serviciului"

#: src/android/aidl/example-service/changing-implementation.md
#, fuzzy
msgid "Update the client and server code to account for the new API."
msgstr ""
"Actualiza탵i codul clientului 탳i al serverului pentru a 탵ine cont de noul API."

#: src/android/aidl/example-service/changing-implementation.md
msgid "'\\n'"
msgstr "'\\n'"

#: src/android/aidl/example-service/changing-implementation.md
#, fuzzy
msgid "\"Habby birfday to yuuuuu\""
msgstr "\"Habby birfday to yuuuuuuu\""

#: src/android/aidl/example-service/changing-implementation.md
#, fuzzy
msgid "\"And also: many more\""
msgstr "\"탲i, de asemenea, multe altele\""

#: src/android/aidl/example-service/changing-implementation.md
#, fuzzy
msgid ""
"TODO: Move code snippets into project files where they'll actually be built?"
msgstr ""
"TODO: S캒 mut캒m fragmentele de cod 칥n fi탳ierele de proiect, unde vor fi "
"construite efectiv?"

#: src/android/aidl/types.md
#, fuzzy
msgid "Working With AIDL Types"
msgstr "Lucrul cu tipurile AIDL"

#: src/android/aidl/types.md
#, fuzzy
msgid "AIDL types translate into the appropriate idiomatic Rust type:"
msgstr "Tipurile AIDL se traduc 칥n tipul idiomatic Rust corespunz캒tor:"

#: src/android/aidl/types.md
#, fuzzy
msgid "Primitive types map (mostly) to idiomatic Rust types."
msgstr ""
"Tipurile primitive se adapteaz캒 (칥n mare parte) la tipurile idiomatice Rust."

#: src/android/aidl/types.md
#, fuzzy
msgid "Collection types like slices, `Vec`s and string types are supported."
msgstr ""
"Sunt acceptate tipuri de colec탵ii precum slices, `Vec`s 탳i tipuri de 탳iruri "
"de caractere."

#: src/android/aidl/types.md
#, fuzzy
msgid ""
"References to AIDL objects and file handles can be sent between clients and "
"services."
msgstr ""
"Referin탵ele la obiecte AIDL 탳i la m칙nerele de fi탳iere pot fi trimise 칥ntre "
"clien탵i 탳i servicii."

#: src/android/aidl/types.md
#, fuzzy
msgid "File handles and parcelables are fully supported."
msgstr "M칙nerele de fi탳iere 탳i pachetele sunt pe deplin acceptate."

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "Primitive types map (mostly) idiomatically:"
msgstr "Tipurile primitive se mapeaz캒 (칥n mare parte) 칥n mod idiomatic:"

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "AIDL Type"
msgstr "AIDL"

#: src/android/aidl/types/primitives.md src/android/aidl/types/arrays.md
#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "Rust Type"
msgstr "Rugin캒 prin exemplu"

#: src/android/aidl/types/primitives.md
msgid "Note"
msgstr "Noti탵캒"

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "`boolean`"
msgstr "`bool`"

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "`byte`"
msgstr "`byte`"

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "`i8`"
msgstr ""
"Biblioteca standard are o implementare a `From<i8> pentru i16`, ceea ce "
"칥nseamn캒 c캒 putem converti o variabil캒 `x` de tip `i8` 칥n `i16` prin "
"apelarea `i16::from(x)`. Sau, mai simplu, cu `x.into()`, deoarece "
"implementarea `From<i8> for i16` creeaz캒 automat o implementare a `Into<i16> "
"for i8`."

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "Note that bytes are signed."
msgstr "// Mai mult de 7 octe탵i este invalid.\n"

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "`u16`"
msgstr "`u16`"

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "Note the usage of `u16`, NOT `u32`."
msgstr "Re탵ine탵i utilizarea lui `u16`, NU `u32`."

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "`int`"
msgstr "`int`"

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "`i32`"
msgstr ""
"Ar fi avut loc o copiere implicit캒 a matricei. Din moment ce `i32` este un "
"tip care implic캒 copiere, atunci `[i32; 3]` implic캒, de asemenea, copierea."

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "`long`"
msgstr ""
"Preciza탵i c캒 bucla `while let` va continua at칙ta timp c칙t valoarea se "
"potrive탳te cu modelul."

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "`i64`"
msgstr "`i64`"

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "`float`"
msgstr "`float`"

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "`f32`"
msgstr "`f32`"

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "`double`"
msgstr "Eliber캒ri dublate 칥n C++ modern"

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "`f64`"
msgstr "`f64`"

#: src/android/aidl/types/arrays.md
#, fuzzy
msgid ""
"The array types (`T[]`, `byte[]`, and `List<T>`) get translated to the "
"appropriate Rust array type depending on how they are used in the function "
"signature:"
msgstr ""
"Tipurile de matrice (`T[]`, `byte[]` 탳i `List<T>`) sunt convertite 칥n tipul "
"de matrice Rust corespunz캒tor, 칥n func탵ie de modul 칥n care sunt utilizate 칥n "
"semn캒tura func탵iei:"

#: src/android/aidl/types/arrays.md
msgid "Position"
msgstr "Pozi탵ie"

#: src/android/aidl/types/arrays.md
#, fuzzy
msgid "`in` argument"
msgstr "argument:"

#: src/android/aidl/types/arrays.md
#, fuzzy
msgid "`&[T]`"
msgstr "`Box<T>`"

#: src/android/aidl/types/arrays.md
#, fuzzy
msgid "`out`/`inout` argument"
msgstr "argument `out`/`inout`"

#: src/android/aidl/types/arrays.md
#, fuzzy
msgid "`&mut Vec<T>`"
msgstr "`Vec`"

#: src/android/aidl/types/arrays.md
msgid "Return"
msgstr "칉napoi"

#: src/android/aidl/types/arrays.md
#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`Vec<T>`"
msgstr "`Vec`"

#: src/android/aidl/types/arrays.md
#, fuzzy
msgid ""
"In Android 13 or higher, fixed-size arrays are supported, i.e. `T[N]` "
"becomes `[T; N]`. Fixed-size arrays can have multiple dimensions (e.g. "
"int\\[3\\]\\[4\\]). In the Java backend, fixed-size arrays are represented "
"as array types."
msgstr ""
"칉n Android 13 sau versiunile ulterioare, sunt acceptate matricele de "
"dimensiuni fixe, adic캒 `T[N]` devine `[T; N]`. Tablourile de dimensiuni fixe "
"pot avea dimensiuni multiple (de exemplu, int\\[3\\]\\[4\\]). 칉n backend-ul "
"Java, array-urile de dimensiuni fixe sunt reprezentate ca tipuri de array-"
"uri."

#: src/android/aidl/types/arrays.md
#, fuzzy
msgid "Arrays in parcelable fields always get translated to `Vec<T>`."
msgstr ""
"Array-urile din c칙mpurile parcelabile sunt 칥ntotdeauna convertite 칥n "
"`Vec<T>`."

#: src/android/aidl/types/objects.md
#, fuzzy
msgid ""
"AIDL objects can be sent either as a concrete AIDL type or as the type-"
"erased `IBinder` interface:"
msgstr ""
"Obiectele AIDL pot fi trimise fie ca un tip AIDL concret, fie ca interfa탵캒 "
"`IBinder`, care a fost eliminat캒 ca tip:"

#: src/android/aidl/types/objects.md
#, fuzzy
msgid ""
"**birthday_service/aidl/com/example/birthdayservice/IBirthdayInfoProvider."
"aidl**:"
msgstr ""
"_birthday_service/aidl/com/exemple/birthdayservice/IBirthdayService.aidl_:"

#: src/android/aidl/types/objects.md src/android/aidl/types/parcelables.md
#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid ""
"**birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl**:"
msgstr ""
"_birthday_service/aidl/com/exemple/birthdayservice/IBirthdayService.aidl_:"

#: src/android/aidl/types/objects.md
#, fuzzy
msgid "/** The same thing, but using a binder object. */"
msgstr "/** Acela탳i lucru, dar folosind un obiect binder. */"

#: src/android/aidl/types/objects.md
#, fuzzy
msgid "/** The same thing, but using `IBinder`. */"
msgstr "/** Acela탳i lucru, dar folosind `IBinder`. */"

#: src/android/aidl/types/objects.md src/android/aidl/types/parcelables.md
#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "**birthday_service/src/client.rs**:"
msgstr "_birthday_service/src/client.rs_:"

#: src/android/aidl/types/objects.md
#, fuzzy
msgid "/// Rust struct implementing the `IBirthdayInfoProvider` interface.\n"
msgstr "//! Implementarea interfe탵ei AIDL `IBirthdayService`.\n"

#: src/android/aidl/types/objects.md
#, fuzzy
msgid "// Create a binder object for the `IBirthdayInfoProvider` interface.\n"
msgstr "//! Implementarea interfe탵ei AIDL `IBirthdayService`.\n"

#: src/android/aidl/types/objects.md
#, fuzzy
msgid "// Send the binder object to the service.\n"
msgstr "/// Apelarea serviciului de aniversare.\n"

#: src/android/aidl/types/objects.md
#, fuzzy
msgid ""
"// Perform the same operation but passing the provider as an `SpIBinder`.\n"
msgstr ""
"// Efectua탵i aceea탳i opera탵iune, dar trec칙nd furnizorul ca un `SpIBinder`.\n"

#: src/android/aidl/types/objects.md
#, fuzzy
msgid ""
"Note the usage of `BnBirthdayInfoProvider`. This serves the same purpose as "
"`BnBirthdayService` that we saw previously."
msgstr ""
"Re탵ine탵i utilizarea lui `BnBirthdayInfoProvider`. Acesta are acela탳i scop ca "
"탳i `BnBirthdayService` pe care l-am v캒zut anterior."

#: src/android/aidl/types/parcelables.md
#, fuzzy
msgid "Binder for Rust supports sending parcelables directly:"
msgstr "Binder for Rust accept캒 trimiterea direct캒 de colete:"

#: src/android/aidl/types/parcelables.md
#, fuzzy
msgid ""
"**birthday_service/aidl/com/example/birthdayservice/BirthdayInfo.aidl**:"
msgstr ""
"_birthday_service/aidl/com/exemple/birthdayservice/IBirthdayService.aidl_:"

#: src/android/aidl/types/parcelables.md
#, fuzzy
msgid "/** The same thing, but with a parcelable. */"
msgstr "/** Acela탳i lucru, dar cu un parcelabil. */"

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid ""
"Files can be sent between Binder clients/servers using the "
"`ParcelFileDescriptor` type:"
msgstr ""
"Fi탳ierele pot fi trimise 칥ntre clien탵ii/serverele Binder utiliz칙nd tipul "
"`ParcelFileDescriptor`:"

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "/** The same thing, but loads info from a file. */"
msgstr "/** Acela탳i lucru, dar 칥ncarc캒 informa탵ii dintr-un fi탳ier. */"

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "// Open a file and put the birthday info in it.\n"
msgstr ""
"// Deschide탵i un fi탳ier 탳i pune탵i informa탵iile despre ziua de na탳tere 칥n "
"el.\n"

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "\"/data/local/tmp/birthday.info\""
msgstr "\"/data/local/tmp/birthday.info\""

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "\"{name}\""
msgstr "Nume registru"

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "\"{years}\""
msgstr "\"{years}\""

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "// Create a `ParcelFileDescriptor` from the file and send it.\n"
msgstr "// Crea탵i un `ParcelFileDescriptor` din fi탳ier 탳i trimite탵i-l.\n"

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "**birthday_service/src/lib.rs**:"
msgstr "_birthday_service/src/lib.rs_:"

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid ""
"// Convert the file descriptor to a `File`. `ParcelFileDescriptor` wraps\n"
"        // an `OwnedFd`, which can be cloned and then used to create a "
"`File`\n"
"        // object.\n"
msgstr ""
"// Conversia descriptorului de fi탳ier 칥ntr-un `File`. `ParcelFileDescriptor` "
"칥nf캒탳oar캒\n"
"        // un `OwnedFd`, care poate fi clonat 탳i apoi utilizat pentru a crea "
"un `File`\n"
"        // obiect.\n"

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "\"Invalid file handle\""
msgstr "\"Lungime invalid캒\""

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid ""
"`ParcelFileDescriptor` wraps an `OwnedFd`, and so can be created from a "
"`File` (or any other type that wraps an `OwnedFd`), and can be used to "
"create a new `File` handle on the other side."
msgstr ""
"`ParcelFileDescriptor` 칥nf캒탳oar캒 un `OwnedFd` 탳i, prin urmare, poate fi "
"creat dintr-un `File` (sau orice alt tip care 칥nf캒탳oar캒 un `OwnedFd`) 탳i "
"poate fi utilizat pentru a crea un nou handle `File` pe partea cealalt캒."

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid ""
"Other types of file descriptors can be wrapped and sent, e.g. TCP, UDP, and "
"UNIX sockets."
msgstr ""
"Alte tipuri de descriptori de fi탳iere pot fi 칥nf캒탳urate 탳i trimise, de "
"exemplu, TCP, UDP 탳i socket-uri UNIX."

#: src/android/testing.md
#, fuzzy
msgid "Testing in Android"
msgstr "Rust 칥n Android"

#: src/android/testing.md
#, fuzzy
msgid ""
"Building on [Testing](../testing.md), we will now look at how unit tests "
"work in AOSP. Use the `rust_test` module for your unit tests:"
msgstr ""
"Pornind de la [Testing](../testing.md), vom analiza acum modul 칥n care "
"func탵ioneaz캒 testele unitare 칥n AOSP. Utiliza탵i modulul `rust_test` pentru "
"testele unitare:"

#: src/android/testing.md
#, fuzzy
msgid "_testing/Android.bp_:"
msgstr "hello_rust/Android.bp_:"

#: src/android/testing.md
#, fuzzy
msgid "\"libleftpad\""
msgstr "\"libtextwrap\""

#: src/android/testing.md
#, fuzzy
msgid "\"leftpad\""
msgstr "\"leftpad\""

#: src/android/testing.md
#, fuzzy
msgid "\"libleftpad_test\""
msgstr "\"libbirthday_bindgen_test\""

#: src/android/testing.md
#, fuzzy
msgid "\"leftpad_test\""
msgstr "\"leftpad_test\""

#: src/android/testing.md src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"general-tests\""
msgstr "Rust nesigur"

#: src/android/testing.md
#, fuzzy
msgid "_testing/src/lib.rs_:"
msgstr "hello_rust/src/lib.rs_:"

#: src/android/testing.md
#, fuzzy
msgid "//! Left-padding library.\n"
msgstr "//! Biblioteca de felicit캒ri.\n"

#: src/android/testing.md
#, fuzzy
msgid "/// Left-pad `s` to `width`.\n"
msgstr "/// Introduce탵i la st칙nga `s` 칥n `width`.\n"

#: src/android/testing.md
msgid "\"{s:>width$}\""
msgstr "\"{s:>width$}\""

#: src/android/testing.md
#, fuzzy
msgid "\"  foo\""
msgstr "\"foo\""

#: src/android/testing.md
#, fuzzy
msgid "\"foobar\""
msgstr "\"foo\""

#: src/android/testing.md
#, fuzzy
msgid "You can now run the test with"
msgstr "Acum pute탵i s캒 genera탵i automat leg캒turile:"

#: src/android/testing.md
#, fuzzy
msgid "The output looks like this:"
msgstr "Abordarea general캒 arat캒 칥n felul urm캒tor:"

#: src/android/testing.md
#, fuzzy
msgid ""
"```text\n"
"INFO: Elapsed time: 2.666s, Critical Path: 2.40s\n"
"INFO: 3 processes: 2 internal, 1 linux-sandbox.\n"
"INFO: Build completed successfully, 3 total actions\n"
"//comprehensive-rust-android/testing:libleftpad_test_host            PASSED "
"in 2.3s\n"
"    PASSED  libleftpad_test.tests::long_string (0.0s)\n"
"    PASSED  libleftpad_test.tests::short_string (0.0s)\n"
"Test cases: finished with 2 passing and 0 failing out of 2 test cases\n"
"```"
msgstr ""
"```text\n"
"INFO: Timp scurs: 2.666s, Calea critic캒: 2.40s\n"
"INFO: 3 procese: 2 interne, 1 linux-sandbox.\n"
"INFO: Construirea s-a finalizat cu succes, 3 ac탵iuni totale\n"
"//comprehensive-rust-android/testing/testing:libleftpad_test_host A TRECUT "
"칥n 2.3s\n"
"    A TRECUT libleftpad_test.tests::long_string (0.0s)\n"
"    A TRECUT libleftpad_test.tests::short_string (0.0s)\n"
"Cazuri de testare: finalizat cu 2 cazuri de trecere 탳i 0 e탳ecuri din 2 "
"cazuri de testare\n"
"```"

#: src/android/testing.md
#, fuzzy
msgid ""
"Notice how you only mention the root of the library crate. Tests are found "
"recursively in nested modules."
msgstr ""
"Observa탵i c캒 a탵i men탵ionat doar r캒d캒cina bibliotecii. Testele se g캒sesc "
"recursiv 칥n modulele imbricate."

#: src/android/testing/googletest.md
#, fuzzy
msgid ""
"The [GoogleTest](https://docs.rs/googletest/) crate allows for flexible test "
"assertions using _matchers_:"
msgstr ""
"[googletest](https://docs.rs/googletest): Bibliotec캒 cuprinz캒toare de "
"testare a afirma탵iilor de testare 칥n tradi탵ia GoogleTest pentru C++."

#: src/android/testing/googletest.md
#, fuzzy
msgid "\"baz\""
msgstr "\"baz\""

#: src/android/testing/googletest.md
#, fuzzy
msgid "\"xyz\""
msgstr "\"xyz\""

#: src/android/testing/googletest.md
#, fuzzy
msgid ""
"If we change the last element to `\"!\"`, the test fails with a structured "
"error message pin-pointing the error:"
msgstr ""
"Dac캒 schimb캒m ultimul element 칥n `\"!\"`, testul e탳ueaz캒 cu un mesaj de "
"eroare structurat care indic캒 eroarea:"

#: src/android/testing/googletest.md
#, fuzzy
msgid ""
"GoogleTest is not part of the Rust Playground, so you need to run this "
"example in a local environment. Use `cargo add googletest` to quickly add it "
"to an existing Cargo project."
msgstr ""
"GoogleTest nu face parte din Rust Playground, a탳a c캒 trebuie s캒 executa탵i "
"acest exemplu 칥ntr-un mediu local. Utiliza탵i `cargo add googletest` pentru a-"
"l ad캒uga rapid la un proiect Cargo existent."

#: src/android/testing/googletest.md
#, fuzzy
msgid ""
"The `use googletest::prelude::*;` line imports a number of [commonly used "
"macros and types](https://docs.rs/googletest/latest/googletest/prelude/index."
"html)."
msgstr ""
"Linia `use googletest::prelude::*;` import캒 un num캒r de [macros 탳i tipuri "
"utilizate 칥n mod obi탳nuit](https://docs.rs/googletest/latest/googletest/"
"prelude/index.html)."

#: src/android/testing/googletest.md
#, fuzzy
msgid ""
"This just scratches the surface, there are many builtin matchers. Consider "
"going through the first chapter of [\"Advanced testing for Rust "
"applications\"](https://github.com/mainmatter/rust-advanced-testing-"
"workshop), a self-guided Rust course: it provides a guided introduction to "
"the library, with exercises to help you get comfortable with `googletest` "
"macros, its matchers and its overall philosophy."
msgstr ""
"Acest lucru este doar o mic캒 parte, deoarece exist캒 numeroase elemente de "
"potrivire 칥ncorporate. Lua탵i 칥n considerare parcurgerea primului capitol din "
"[\"Testare avansat캒 pentru aplica탵ii Rust\"](https://github.com/mainmatter/"
"rust-advanced-testing-workshop), un curs Rust auto-ghidat: acesta ofer캒 o "
"introducere ghidat캒 칥n bibliotec캒, cu exerci탵ii care s캒 v캒 ajute s캒 v캒 "
"acomoda탵i cu macro-urile `googletest`, cu potrivitorii s캒i 탳i cu filozofia "
"sa general캒."

#: src/android/testing/googletest.md
#, fuzzy
msgid ""
"A particularly nice feature is that mismatches in multi-line strings are "
"shown as a diff:"
msgstr ""
"O caracteristic캒 deosebit de pl캒cut캒 este faptul c캒 neconcordan탵ele 칥n "
"탳irurile de caractere de mai multe linii sunt afi탳ate sub forma unui dif:"

#: src/android/testing/googletest.md
#, fuzzy
msgid ""
"\"Memory safety found,\\n\\\n"
"                 Rust's strong typing guides the way,\\n\\\n"
"                 Secure code you'll write.\""
msgstr ""
"\"Memory safety found,\\n\\\n"
"                 Tiparea puternic캒 a lui Rust ne ghideaz캒 칥n acest sens\n"
"                 Cod sigur pe care 칥l ve탵i scrie.\""

#: src/android/testing/googletest.md
#, fuzzy
msgid ""
"\"Memory safety found,\\n\\\n"
"            Rust's silly humor guides the way,\\n\\\n"
"            Secure code you'll write.\""
msgstr ""
"\"Memory safety found,\\n\\\n"
"            Umorul caraghios al lui Rust ne ghideaz캒 칥n acest sens\n"
"            Cod sigur pe care 칥l vei scrie.\""

#: src/android/testing/googletest.md
#, fuzzy
msgid "shows a color-coded diff (colors not shown here):"
msgstr "prezint캒 o diferen탵캒 de culori (culorile nu sunt prezentate aici):"

#: src/android/testing/googletest.md
#, fuzzy
msgid ""
"The crate is a Rust port of [GoogleTest for C++](https://google.github.io/"
"googletest/)."
msgstr ""
"Crate este un port Rust al [GoogleTest for C++](https://google.github.io/"
"googletest/)."

#: src/android/testing/mocking.md
#, fuzzy
msgid ""
"For mocking, [Mockall](https://docs.rs/mockall/) is a widely used library. "
"You need to refactor your code to use traits, which you can then quickly "
"mock:"
msgstr ""
"Pentru mocking, [Mockall](https://docs.rs/mockall/) este o bibliotec캒 "
"utilizat캒 pe scar캒 larg캒. Trebuie s캒 v캒 refactoriza탵i codul pentru a utiliza "
"tr캒s캒turi, pe care le pute탵i apoi mock-ui rapid:"

#: src/android/testing/mocking.md
#, fuzzy
msgid ""
"Mockall is the recommended mocking library in Android (AOSP). There are "
"other [mocking libraries available on crates.io](https://crates.io/keywords/"
"mock), in particular in the area of mocking HTTP services. The other mocking "
"libraries work in a similar fashion as Mockall, meaning that they make it "
"easy to get a mock implementation of a given trait."
msgstr ""
"Sfatul de aici este pentru Android (AOSP), unde Mockall este biblioteca de "
"mocking recomandat캒. Exist캒 탳i alte [biblioteci de mocking disponibile pe "
"crates.io](https://crates.io/keywords/mock), 칥n special 칥n domeniul mocking-"
"ului serviciilor HTTP. Celelalte biblioteci de mocking func탵ioneaz캒 칥ntr-un "
"mod similar cu Mockall, ceea ce 칥nseamn캒 c캒 acestea faciliteaz캒 ob탵inerea "
"unei implement캒ri simulate a unei anumite tr캒s캒turi."

#: src/android/testing/mocking.md
#, fuzzy
msgid ""
"Note that mocking is somewhat _controversial_: mocks allow you to completely "
"isolate a test from its dependencies. The immediate result is faster and "
"more stable test execution. On the other hand, the mocks can be configured "
"wrongly and return output different from what the real dependencies would do."
msgstr ""
"Re탵ine탵i c캒 mocking-ul este oarecum _controversat_: mocks v캒 permite s캒 "
"izola탵i complet un test de dependen탵ele sale. Rezultatul imediat este o "
"execu탵ie mai rapid캒 탳i mai stabil캒 a testelor. Pe de alt캒 parte, mock-urile "
"pot fi configurate gre탳it 탳i pot returna rezultate diferite de cele pe care "
"le-ar face dependen탵ele reale."

#: src/android/testing/mocking.md
#, fuzzy
msgid ""
"If at all possible, it is recommended that you use the real dependencies. As "
"an example, many databases allow you to configure an in-memory backend. This "
"means that you get the correct behavior in your tests, plus they are fast "
"and will automatically clean up after themselves."
msgstr ""
"Dac캒 este posibil, se recomand캒 s캒 folosi탵i dependen탵ele reale. Ca exemplu, "
"multe baze de date v캒 permit s캒 configura탵i un backend 칥n memorie. Acest "
"lucru 칥nseamn캒 c캒 ob탵ine탵i comportamentul corect 칥n testele dvs., 칥n plus, "
"sunt rapide 탳i se vor cur캒탵a automat dup캒 ele 칥nsele."

#: src/android/testing/mocking.md
#, fuzzy
msgid ""
"Similarly, many web frameworks allow you to start an in-process server which "
"binds to a random port on `localhost`. Always prefer this over mocking away "
"the framework since it helps you test your code in the real environment."
msgstr ""
"칉n mod similar, multe cadre web v캒 permit s캒 porni탵i un server 칥n proces "
"care se leag캒 la un port aleatoriu pe `localhost`. Prefera탵i 칥ntotdeauna "
"acest lucru 칥n locul mocking-ului 칥n afara cadrului, deoarece v캒 ajut캒 s캒 v캒 "
"testa탵i codul 칥n mediul real."

#: src/android/testing/mocking.md
#, fuzzy
msgid ""
"Mockall is not part of the Rust Playground, so you need to run this example "
"in a local environment. Use `cargo add mockall` to quickly add Mockall to an "
"existing Cargo project."
msgstr ""
"Mockall nu face parte din Rust Playground, a탳a c캒 trebuie s캒 executa탵i acest "
"exemplu 칥ntr-un mediu local. Utiliza탵i `cargo add mockall` pentru a ad캒uga "
"rapid Mockall la un proiect Cargo existent."

#: src/android/testing/mocking.md
#, fuzzy
msgid ""
"Mockall has a lot more functionality. In particular, you can set up "
"expectations which depend on the arguments passed. Here we use this to mock "
"a cat which becomes hungry 3 hours after the last time it was fed:"
msgstr ""
"Mockall are mult mai multe func탵ionalit캒탵i. 칉n special, pute탵i configura "
"a탳tept캒ri care depind de argumentele transmise. Aici folosim acest lucru "
"pentru a imita o pisic캒 care devine fl캒m칙nd캒 la 3 ore dup캒 ce a fost hr캒nit캒 "
"ultima dat캒:"

#: src/android/testing/mocking.md
#, fuzzy
msgid ""
"You can use `.times(n)` to limit the number of times a mock method can be "
"called to `n` --- the mock will automatically panic when dropped if this "
"isn't satisfied."
msgstr ""
"Pute탵i utiliza `.times(n)` pentru a limita num캒rul de apeluri ale unei "
"metode mock la `n` --- mock-ul va intra automat 칥n panic캒 atunci c칙nd va fi "
"abandonat dac캒 acest lucru nu este 칥ndeplinit."

#: src/android/logging.md
#, fuzzy
msgid ""
"You should use the `log` crate to automatically log to `logcat` (on-device) "
"or `stdout` (on-host):"
msgstr ""
"Ar trebui s캒 folosi탵i caseta `log` pentru a 칥nregistra automat 칥n `logcat` "
"(pe dispozitiv) sau `stdout` (pe gazd캒):"

#: src/android/logging.md
#, fuzzy
msgid "_hello_rust_logs/Android.bp_:"
msgstr "salut_rust_logs/Android.bp_:"

#: src/android/logging.md
#, fuzzy
msgid "\"hello_rust_logs\""
msgstr "salut_rust_logs/Android.bp_:"

#: src/android/logging.md
#, fuzzy
msgid "\"liblog_rust\""
msgstr "\"liblog_rust\""

#: src/android/logging.md
#, fuzzy
msgid "\"liblogger\""
msgstr "\"liblogger\""

#: src/android/logging.md
#, fuzzy
msgid "_hello_rust_logs/src/main.rs_:"
msgstr "hello_rust_logs/src/main.rs_:"

#: src/android/logging.md
#, fuzzy
msgid "//! Rust logging demo.\n"
msgstr "//! Demonstra탵ie de logare Rust.\n"

#: src/android/logging.md
#, fuzzy
msgid "/// Logs a greeting.\n"
msgstr "/// 칉nregistreaz캒 o salutare.\n"

#: src/android/logging.md
#, fuzzy
msgid "\"rust\""
msgstr ""
"Concuren탵a 칥n Rust:\n"
"A se vedea [Concuren탵a 칥n Rust](concurrency.md)."

#: src/android/logging.md
#, fuzzy
msgid "\"Starting program.\""
msgstr "\"Program de pornire.\""

#: src/android/logging.md
#, fuzzy
msgid "\"Things are going fine.\""
msgstr "\"Lucrurile merg bine.\""

#: src/android/logging.md
#, fuzzy
msgid "\"Something went wrong!\""
msgstr "\"Ceva a mers prost!\""

#: src/android/logging.md src/android/interoperability/with-c/bindgen.md
#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "Build, push, and run the binary on your device:"
msgstr ""
"Crea탵i, distribui탵i 탳i rula탵i programul binar pe dispozitivul dumneavoastr캒:"

#: src/android/logging.md
#, fuzzy
msgid ""
"```shell\n"
"m hello_rust_logs\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/hello_rust_logs\n"
"```"
msgstr ""
"```shell\n"
"m hello_rust_logs\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/hello_rust_logs\n"
"```"

#: src/android/logging.md
#, fuzzy
msgid "The logs show up in `adb logcat`:"
msgstr "Jurnalele apar 칥n `adb logcat`:"

#: src/android/interoperability.md
#, fuzzy
msgid ""
"Rust has excellent support for interoperability with other languages. This "
"means that you can:"
msgstr ""
"Rust are un suport excelent pentru interoperabilitatea cu alte limbaje. "
"Acest lucru 칥nseamn캒 c캒 pute탵i:"

#: src/android/interoperability.md
#, fuzzy
msgid "Call Rust functions from other languages."
msgstr "Apelarea func탵iilor Rust din alte limbaje."

#: src/android/interoperability.md
#, fuzzy
msgid "Call functions written in other languages from Rust."
msgstr "Apelarea func탵iilor scrise 칥n alte limbaje din Rust."

#: src/android/interoperability.md
#, fuzzy
msgid ""
"When you call functions in a foreign language we say that you're using a "
"_foreign function interface_, also known as FFI."
msgstr ""
"Atunci c칙nd apela탵i func탵ii 칥ntr-o limb캒 str캒in캒, spunem c캒 utiliza탵i o "
"_interfa탵캒 de func탵ii str캒ine_, cunoscut캒 탳i sub numele de FFI."

#: src/android/interoperability/with-c.md
#, fuzzy
msgid "Interoperability with C"
msgstr "Interoperabilitatea cu C++"

#: src/android/interoperability/with-c.md
#, fuzzy
msgid ""
"Rust has full support for linking object files with a C calling convention. "
"Similarly, you can export Rust functions and call them from C."
msgstr ""
"Rust are un suport complet pentru legarea fi탳ierelor de obiecte cu o "
"conven탵ie de apelare C. 칉n mod similar, pute탵i exporta func탵ii Rust 탳i le "
"pute탵i apela din C."

#: src/android/interoperability/with-c.md
#, fuzzy
msgid "You can do it by hand if you want:"
msgstr "Pute탵i s캒 o face탵i manual, dac캒 dori탵i:"

#: src/android/interoperability/with-c.md
#, fuzzy
msgid "// SAFETY: `abs` doesn't have any safety requirements.\n"
msgstr "// SIGURAN탴캑: `abs` nu are nicio cerin탵캒 de siguran탵캒.\n"

#: src/android/interoperability/with-c.md
#, fuzzy
msgid "\"{x}, {abs_x}\""
msgstr "\"{x}, {abs_x}\""

#: src/android/interoperability/with-c.md
#, fuzzy
msgid ""
"We already saw this in the [Safe FFI Wrapper exercise](../../exercises/day-3/"
"safe-ffi-wrapper.md)."
msgstr ""
"Am v캒zut deja acest lucru 칥n [Exerci탵iul [Safe FFI Wrapper] (../../exerci탵ii/"
"zi-3/safe-ffi-wrapper.md)."

#: src/android/interoperability/with-c.md
#, fuzzy
msgid ""
"This assumes full knowledge of the target platform. Not recommended for "
"production."
msgstr ""
"Acest lucru presupune cunoa탳terea complet캒 a platformei 탵int캒. Nu se "
"recomand캒 pentru produc탵ie."

#: src/android/interoperability/with-c.md
#, fuzzy
msgid "We will look at better options next."
msgstr "칉n continuare, vom examina op탵iuni mai bune."

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "Using Bindgen"
msgstr "Utilizarea Bindgen"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid ""
"The [bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html) "
"tool can auto-generate bindings from a C header file."
msgstr ""
"Instrumentul [bindgen](https://rust-lang.github.io/rust-bindgen/introduction."
"html) poate genera automat leg캒turile dintr-un fi탳ier de antet C."

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "First create a small C library:"
msgstr "Mai 칥nt칙i crea탵i o mic캒 bibliotec캒 C:"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "_interoperability/bindgen/libbirthday.h_:"
msgstr "interoperabilitate/bindgen/libbirthday.h_:"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "_interoperability/bindgen/libbirthday.c_:"
msgstr "interoperabilitate/bindgen/libbirthday.c_:"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "<stdio.h>"
msgstr "<stdio.h>"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"libbirthday.h\""
msgstr ""
"```c\n"
"#include \"libbirthday.h\"\n"
"```"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"+--------------\\n\""
msgstr "\"fib(n) = {}\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"| Happy Birthday %s!\\n\""
msgstr "\"| La mul탵i ani %s!\\n\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"| Congratulations with the %i years!\\n\""
msgstr "\"| Felicit캒ri cu %i ani!\\n\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "Add this to your `Android.bp` file:"
msgstr "Ad캒uga탵i acest lucru la fi탳ierul `Android.bp`:"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "_interoperability/bindgen/Android.bp_:"
msgstr "interoperabilitate/bindgen/Android.bp_:"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"libbirthday\""
msgstr "\"libbirthday\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"libbirthday.c\""
msgstr "\"libbirthday.c\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid ""
"Create a wrapper header file for the library (not strictly needed in this "
"example):"
msgstr ""
"Crea탵i un fi탳ier de antet de 칥nf캒탳urare pentru bibliotec캒 (nu este strict "
"necesar 칥n acest exemplu):"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "_interoperability/bindgen/libbirthday_wrapper.h_:"
msgstr "interoperabilitate/bindgen/libbirthday_wrapper.h_:"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "You can now auto-generate the bindings:"
msgstr "Acum pute탵i s캒 genera탵i automat leg캒turile:"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"libbirthday_bindgen\""
msgstr "\"libbirthday_bindgen\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"birthday_bindgen\""
msgstr "`rust_bindgen`"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"libbirthday_wrapper.h\""
msgstr "\"libbirthday_wrapper.h\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"bindings\""
msgstr "Exemple de leg캒turi"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "Finally, we can use the bindings in our Rust program:"
msgstr "칉n cele din urm캒, putem utiliza leg캒turile 칥n programul nostru Rust:"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"print_birthday_card\""
msgstr "\"print_birthday_card\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"main.rs\""
msgstr "_main.rs_:"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "_interoperability/bindgen/main.rs_:"
msgstr "interoperabilitate/bindgen/main.rs_:"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "//! Bindgen demo.\n"
msgstr "//! Bindgen demo.\n"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid ""
"// SAFETY: The pointer we pass is valid because it came from a Rust\n"
"    // reference, and the `name` it contains refers to `name` above which "
"also\n"
"    // remains valid. `print_card` doesn't store either pointer to use "
"later\n"
"    // after it returns.\n"
msgstr ""
"// SIGURAN탴캑: Pointerul pe care 칥l trecem este valid pentru c캒 provine dintr-"
"un Rust\n"
"    // referin탵캒, iar `name` pe care 칥l con탵ine se refer캒 la `name` de mai "
"sus, care de asemenea\n"
"    // r캒m칙ne valabil. `print_card` nu stocheaz캒 niciunul dintre cei doi "
"pointeri pentru a-i folosi ulterior\n"
"    // dup캒 ce se 칥ntoarce.\n"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid ""
"```shell\n"
"m print_birthday_card\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/print_birthday_card\n"
"```"
msgstr ""
"```shell\n"
"m print_birthday_card\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/print_birthday_card\n"
"```"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "Finally, we can run auto-generated tests to ensure the bindings work:"
msgstr ""
"칉n cele din urm캒, putem rula teste generate automat pentru a ne asigura c캒 "
"leg캒turile func탵ioneaz캒:"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"libbirthday_bindgen_test\""
msgstr "\"libbirthday_bindgen_test\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\":libbirthday_bindgen\""
msgstr "\":libbirthday_bindgen\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"none\""
msgstr ""
"```rust,editabile\n"
"fn main() {\n"
"    match std::env::args().next().as_deref() {\n"
"        Some(\"cat\") => println!(\"Va face lucruri de pisic캒\"),\n"
"        Some(\"ls\") => println!(\"Va face ls unor fi탳iere\"),\n"
"        Some(\"mv\") => println!(\"Va muta ni탳te fi탳iere\"),\n"
"        Some(\"rm\") => println!(\"Uh, periculos!\"),\n"
"        None => println!(\"Hmm, niciun nume de program?\"),\n"
"        _ => println!(\"Nume de program necunoscut!\"),\n"
"    }\n"
"}\n"
"```"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "// Generated file, skip linting\n"
msgstr "// Fi탳ier generat, s캒ri탵i linting\n"

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "Calling Rust"
msgstr "Apelarea Rust din C"

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "Exporting Rust functions and types to C is easy:"
msgstr "Exportul func탵iilor 탳i tipurilor Rust 칥n C este u탳or:"

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "_interoperability/rust/libanalyze/analyze.rs_"
msgstr "interoperabilitate/interoperabilitate/rust/libanalyze/analyze.rs_"

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "//! Rust FFI demo.\n"
msgstr "//! Demonstra탵ie Rust FFI.\n"

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "/// Analyze the numbers.\n"
msgstr "/// Analiza탵i numerele.\n"

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "\"x ({x}) is smallest!\""
msgstr "\"x ({x}) este cel mai mic!\""

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "\"y ({y}) is probably larger than x ({x})\""
msgstr "\"y ({y}) este probabil mai mare dec칙t x ({x})\""

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "_interoperability/rust/libanalyze/analyze.h_"
msgstr "interoperabilitate/interoperabilitate/rust/libanalyze/analyze.h_"

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "_interoperability/rust/libanalyze/Android.bp_"
msgstr "interoperabilitate/interoperabilitate/rusine/libanaliza/Android.bp_"

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "\"libanalyze_ffi\""
msgstr "\"libanalyze_ffi\""

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "\"analyze_ffi\""
msgstr "\"analyze_ffi\""

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "\"analyze.rs\""
msgstr "\"analyze.rs\""

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "We can now call this from a C binary:"
msgstr "Acum putem apela acest lucru dintr-un binar C:"

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "_interoperability/rust/analyze/main.c_"
msgstr "interoperabilitate/rust/analiza/main.c_"

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "\"analyze.h\""
msgstr "\"analyze.h\""

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "_interoperability/rust/analyze/Android.bp_"
msgstr "interoperabilitate/칥nc캒lzire/antreprenoriat/analiza/Android.bp_"

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "\"analyze_numbers\""
msgstr "\"analyze_numbers\""

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "\"main.c\""
msgstr "\"main.c\""

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid ""
"```shell\n"
"m analyze_numbers\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/analyze_numbers\n"
"```"
msgstr ""
"```shell\n"
"m analyze_numbers\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/analyze_numbers\n"
"```"

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid ""
"`#[no_mangle]` disables Rust's usual name mangling, so the exported symbol "
"will just be the name of the function. You can also use `#[export_name = "
"\"some_name\"]` to specify whatever name you want."
msgstr ""
"`#[no_mangle]` dezactiveaz캒 manipularea obi탳nuit캒 a numelor din Rust, astfel "
"칥nc칙t simbolul exportat va fi doar numele func탵iei. De asemenea, pute탵i "
"utiliza `#[export_name = \"some_name\"]` pentru a specifica orice nume "
"dori탵i."

#: src/android/interoperability/cpp.md
#, fuzzy
msgid ""
"The [CXX crate](https://cxx.rs/) makes it possible to do safe "
"interoperability between Rust and C++."
msgstr ""
"[CXX crate](https://cxx.rs/) face posibil캒 realizarea unei "
"interoperabilit캒탵i sigure 칥ntre Rust 탳i C++."

#: src/android/interoperability/cpp.md
#, fuzzy
msgid "The overall approach looks like this:"
msgstr "Abordarea general캒 arat캒 칥n felul urm캒tor:"

#: src/android/interoperability/cpp/bridge.md
#, fuzzy
msgid ""
"CXX relies on a description of the function signatures that will be exposed "
"from each language to the other. You provide this description using extern "
"blocks in a Rust module annotated with the `#[cxx::bridge]` attribute macro."
msgstr ""
"CXX se bazeaz캒 pe o descriere a semn캒turilor func탵iilor care vor fi expuse "
"de la un limbaj la cel캒lalt. Aceast캒 descriere este furnizat캒 cu ajutorul "
"blocurilor externe dintr-un modul Rust adnotat cu macroul atribut `#[cxx::"
"bridge]`."

#: src/android/interoperability/cpp/bridge.md
#, fuzzy
msgid "\"org::blobstore\""
msgstr "\"org::blobstore\""

#: src/android/interoperability/cpp/bridge.md
#, fuzzy
msgid "// Shared structs with fields visible to both languages.\n"
msgstr "// Structuri partajate cu c칙mpuri vizibile pentru ambele limbi.\n"

#: src/android/interoperability/cpp/bridge.md
#: src/android/interoperability/cpp/generated-cpp.md
#, fuzzy
msgid "// Rust types and signatures exposed to C++.\n"
msgstr "// Tipuri 탳i semn캒turi Rust expuse 칥n C++.\n"

#: src/android/interoperability/cpp/bridge.md
#: src/android/interoperability/cpp/rust-bridge.md
#: src/android/interoperability/cpp/generated-cpp.md
#: src/android/interoperability/cpp/rust-result.md
#: src/chromium/interoperability-with-cpp/example-bindings.md
#: src/chromium/interoperability-with-cpp/error-handling-qr.md
#: src/chromium/interoperability-with-cpp/error-handling-png.md
#, fuzzy
msgid "\"Rust\""
msgstr ""
"Concuren탵a 칥n Rust:\n"
"A se vedea [Concuren탵a 칥n Rust](concurrency.md)."

#: src/android/interoperability/cpp/bridge.md
#: src/android/interoperability/cpp/cpp-bridge.md
#, fuzzy
msgid "// C++ types and signatures exposed to Rust.\n"
msgstr "// Tipuri 탳i semn캒turi C++ expuse 칥n Rust.\n"

#: src/android/interoperability/cpp/bridge.md
#: src/android/interoperability/cpp/cpp-bridge.md
#: src/android/interoperability/cpp/cpp-exception.md
#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid "\"C++\""
msgstr "Cu C"

#: src/android/interoperability/cpp/bridge.md
#: src/android/interoperability/cpp/cpp-bridge.md
#, fuzzy
msgid "\"include/blobstore.h\""
msgstr "\"include/blobstore.h\""

#: src/android/interoperability/cpp/bridge.md
#, fuzzy
msgid "The bridge is generally declared in an `ffi` module within your crate."
msgstr ""
"Puntea este, 칥n general, declarat캒 칥ntr-un modul `ffi` din cadrul seriei "
"dumneavoastr캒."

#: src/android/interoperability/cpp/bridge.md
#, fuzzy
msgid ""
"From the declarations made in the bridge module, CXX will generate matching "
"Rust and C++ type/function definitions in order to expose those items to "
"both languages."
msgstr ""
"Din declara탵iile f캒cute 칥n modulul punte, CXX va genera defini탵ii de tip/"
"func탵ie Rust 탳i C++ corespunz캒toare pentru a expune aceste elemente 칥n "
"ambele limbaje."

#: src/android/interoperability/cpp/bridge.md
#, fuzzy
msgid ""
"To view the generated Rust code, use [cargo-expand](https://github.com/"
"dtolnay/cargo-expand) to view the expanded proc macro. For most of the "
"examples you would use `cargo expand ::ffi` to expand just the `ffi` module "
"(though this doesn't apply for Android projects)."
msgstr ""
"Pentru a vizualiza codul Rust generat, utiliza탵i [cargo-expand](https://"
"github.com/dtolnay/cargo-expand) pentru a vizualiza macroul proc extins. "
"Pentru majoritatea exemplelor, ve탵i folosi `cargo expand ::ffi` pentru a "
"extinde doar modulul `ffi` (de탳i acest lucru nu se aplic캒 pentru proiectele "
"Android)."

#: src/android/interoperability/cpp/bridge.md
#, fuzzy
msgid "To view the generated C++ code, look in `target/cxxbridge`."
msgstr "Pentru a vizualiza codul C++ generat, c캒uta탵i 칥n `target/cxxbridge`."

#: src/android/interoperability/cpp/rust-bridge.md
#, fuzzy
msgid "Rust Bridge Declarations"
msgstr "Declara탵ii Rust Bridge"

#: src/android/interoperability/cpp/rust-bridge.md
#, fuzzy
msgid "// Opaque type\n"
msgstr "// Tip opac\n"

#: src/android/interoperability/cpp/rust-bridge.md
#, fuzzy
msgid "// Method on `MyType`\n"
msgstr "// Metoda pe `MyType`\n"

#: src/android/interoperability/cpp/rust-bridge.md
#, fuzzy
msgid "// Free function\n"
msgstr "func탵ie:"

#: src/android/interoperability/cpp/rust-bridge.md
#, fuzzy
msgid ""
"Items declared in the `extern \"Rust\"` reference items that are in scope in "
"the parent module."
msgstr ""
"Elementele declarate 칥n modulul `extern \"Rust\"` fac trimitere la elemente "
"care se afl캒 칥n domeniul de aplicare 칥n modulul p캒rinte."

#: src/android/interoperability/cpp/rust-bridge.md
#, fuzzy
msgid ""
"The CXX code generator uses your `extern \"Rust\"` section(s) to produce a C+"
"+ header file containing the corresponding C++ declarations. The generated "
"header has the same path as the Rust source file containing the bridge, "
"except with a .rs.h file extension."
msgstr ""
"Generatorul de cod CXX utilizeaz캒 sec탵iunea (sec탵iunile) `extern \"Rust\"` "
"pentru a produce un fi탳ier antet C++ care con탵ine declara탵iile C++ "
"corespunz캒toare. Antetul generat are aceea탳i cale ca 탳i fi탳ierul surs캒 Rust "
"care con탵ine puntea, dar cu extensia de fi탳ier .rs.h."

#: src/android/interoperability/cpp/generated-cpp.md
#, fuzzy
msgid "Results in (roughly) the following C++:"
msgstr "Rezult캒 (aproximativ) urm캒torul C++:"

#: src/android/interoperability/cpp/cpp-bridge.md
#, fuzzy
msgid "C++ Bridge Declarations"
msgstr "Declara탵ii de punte C++"

#: src/android/interoperability/cpp/cpp-bridge.md
#, fuzzy
msgid "Results in (roughly) the following Rust:"
msgstr "Rezult캒 (aproximativ) urm캒torul Rust:"

#: src/android/interoperability/cpp/cpp-bridge.md
#, fuzzy
msgid "\"org$blobstore$cxxbridge1$new_blobstore_client\""
msgstr "\"org$blobstore$cxxbridge1$new_blobstore_client\""

#: src/android/interoperability/cpp/cpp-bridge.md
#, fuzzy
msgid "\"org$blobstore$cxxbridge1$BlobstoreClient$put\""
msgstr "\"org$blobstore$cxxbridge1$BlobstoreClient$put\""

#: src/android/interoperability/cpp/cpp-bridge.md
#, fuzzy
msgid ""
"The programmer does not need to promise that the signatures they have typed "
"in are accurate. CXX performs static assertions that the signatures exactly "
"correspond with what is declared in C++."
msgstr ""
"Programatorul nu trebuie s캒 promit캒 c캒 semn캒turile pe care le-a introdus "
"sunt corecte. CXX efectueaz캒 verific캒ri statice pentru a se asigura c캒 "
"semn캒turile corespund exact cu ceea ce este declarat 칥n C++."

#: src/android/interoperability/cpp/cpp-bridge.md
#, fuzzy
msgid ""
"`unsafe extern` blocks allow you to declare C++ functions that are safe to "
"call from Rust."
msgstr ""
"blocurile `unsafe extern` v캒 permit s캒 declara탵i func탵ii C++ care pot fi "
"apelate 칥n siguran탵캒 din Rust."

#: src/android/interoperability/cpp/shared-types.md
#, fuzzy
msgid "// A=1, J=11, Q=12, K=13\n"
msgstr "// A=1, J=11, Q=12, K=13\n"

#: src/android/interoperability/cpp/shared-types.md
#, fuzzy
msgid "Only C-like (unit) enums are supported."
msgstr "Sunt acceptate numai enumera탵iile de tip C (unitate)."

#: src/android/interoperability/cpp/shared-types.md
#, fuzzy
msgid ""
"A limited number of traits are supported for `#[derive()]` on shared types. "
"Corresponding functionality is also generated for the C++ code, e.g. if you "
"derive `Hash` also generates an implementation of `std::hash` for the "
"corresponding C++ type."
msgstr ""
"Un num캒r limitat de tr캒s캒turi sunt acceptate pentru `#[derive()]` pe tipuri "
"partajate. Func탵ionalitatea corespunz캒toare este, de asemenea, generat캒 "
"pentru codul C++, de exemplu, dac캒 deriva탵i `Hash`, se genereaz캒 탳i o "
"implementare a `std::hash` pentru tipul C++ corespunz캒tor."

#: src/android/interoperability/cpp/shared-enums.md
msgid "Generated Rust:"
msgstr "Cod Rust generat:"

#: src/android/interoperability/cpp/shared-enums.md
msgid "Generated C++:"
msgstr "Cod C++ generat:"

#: src/android/interoperability/cpp/shared-enums.md
#, fuzzy
msgid ""
"On the Rust side, the code generated for shared enums is actually a struct "
"wrapping a numeric value. This is because it is not UB in C++ for an enum "
"class to hold a value different from all of the listed variants, and our "
"Rust representation needs to have the same behavior."
msgstr ""
"칉n ceea ce prive탳te Rust, codul generat pentru enumera탵iile partajate este "
"de fapt o structur캒 care 칥nf캒탳oar캒 o valoare numeric캒. Acest lucru se "
"datoreaz캒 faptului c캒 nu este UB 칥n C++ ca o clas캒 enum s캒 de탵in캒 o valoare "
"diferit캒 de toate variantele enumerate, iar reprezentarea noastr캒 Rust "
"trebuie s캒 aib캒 acela탳i comportament."

#: src/android/interoperability/cpp/rust-result.md
#, fuzzy
msgid "\"fallible1 requires depth > 0\""
msgstr "\"fallible1 necesit캒 ad칙ncime > 0\""

#: src/android/interoperability/cpp/rust-result.md
#, fuzzy
msgid "\"Success!\""
msgstr "\"Succes!\""

#: src/android/interoperability/cpp/rust-result.md
#, fuzzy
msgid ""
"Rust functions that return `Result` are translated to exceptions on the C++ "
"side."
msgstr ""
"Func탵iile Rust care returneaz캒 `Result` sunt transformate 칥n excep탵ii 칥n "
"limbajul C++."

#: src/android/interoperability/cpp/rust-result.md
#, fuzzy
msgid ""
"The exception thrown will always be of type `rust::Error`, which primarily "
"exposes a way to get the error message string. The error message will come "
"from the error type's `Display` impl."
msgstr ""
"Excep탵ia aruncat캒 va fi 칥ntotdeauna de tipul `rust::Error`, care expune 칥n "
"primul r칙nd o modalitate de a ob탵ine 탳irul de mesaje de eroare. Mesajul de "
"eroare va proveni din implantul `Display` al tipului de eroare."

#: src/android/interoperability/cpp/rust-result.md
#, fuzzy
msgid ""
"A panic unwinding from Rust to C++ will always cause the process to "
"immediately terminate."
msgstr ""
"O dezarhivare de panic캒 din Rust 칥n C++ va determina 칥ntotdeauna terminarea "
"imediat캒 a procesului."

#: src/android/interoperability/cpp/cpp-exception.md
#, fuzzy
msgid "\"example/include/example.h\""
msgstr "\"example/include/example.h\""

#: src/android/interoperability/cpp/cpp-exception.md
#, fuzzy
msgid "\"Error: {}\""
msgstr "Tr캒s캒turi 'Error'"

#: src/android/interoperability/cpp/cpp-exception.md
#, fuzzy
msgid ""
"C++ functions declared to return a `Result` will catch any thrown exception "
"on the C++ side and return it as an `Err` value to the calling Rust function."
msgstr ""
"Func탵iile C++ declarate pentru a returna un `Result` vor prinde orice "
"excep탵ie lansat캒 칥n partea C++ 탳i o vor returna ca valoare `Err` func탵iei "
"Rust care o apeleaz캒."

#: src/android/interoperability/cpp/cpp-exception.md
#, fuzzy
msgid ""
"If an exception is thrown from an extern \"C++\" function that is not "
"declared by the CXX bridge to return `Result`, the program calls C++'s `std::"
"terminate`. The behavior is equivalent to the same exception being thrown "
"through a `noexcept` C++ function."
msgstr ""
"Dac캒 o excep탵ie este aruncat캒 de o func탵ie extern캒 \"C++\" care nu este "
"declarat캒 de puntea CXX pentru a returna `Result`, programul apeleaz캒 `std::"
"terminate` din C++. Comportamentul este echivalent cu cel al unei excep탵ii "
"aruncate printr-o func탵ie `noexcept` C++."

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "C++ Type"
msgstr "Exemplu C++"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`rust::String`"
msgstr "`rust_bindgen`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`&str`"
msgstr "`&str`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`rust::Str`"
msgstr "`rust_test`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`CxxString`"
msgstr "Sir"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`std::string`"
msgstr "탳ir:"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`&[T]`/`&mut [T]`"
msgstr "`&[T]`/`&mut [T]`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`rust::Slice`"
msgstr "`rust_ffi`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`rust::Box<T>`"
msgstr "`rust::Box<T>`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`UniquePtr<T>`"
msgstr "`UniquePtr<T>`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`std::unique_ptr<T>`"
msgstr "`std::unique_ptr<T>`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`rust::Vec<T>`"
msgstr "`mpsc::Receiver<T>`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`CxxVector<T>`"
msgstr "`Celula<T>`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`std::vector<T>`"
msgstr "`mpsc::Receiver<T>`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid ""
"These types can be used in the fields of shared structs and the arguments "
"and returns of extern functions."
msgstr ""
"Aceste tipuri pot fi utilizate 칥n c칙mpurile structurilor partajate 탳i 칥n "
"argumentele 탳i return캒rile func탵iilor externe."

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid ""
"Note that Rust's `String` does not map directly to `std::string`. There are "
"a few reasons for this:"
msgstr ""
"Re탵ine탵i c캒 `String` din Rust nu se refer캒 direct la `std::string`. Exist캒 "
"c칙teva motive pentru acest lucru:"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid ""
"`std::string` does not uphold the UTF-8 invariant that `String` requires."
msgstr "`std::string` nu respect캒 invarianta UTF-8 pe care `String` o cere."

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid ""
"The two types have different layouts in memory and so can't be passed "
"directly between languages."
msgstr ""
"Cele dou캒 tipuri au configura탵ii diferite 칥n memorie 탳i, prin urmare, nu pot "
"fi transmise direct 칥ntre limbi."

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid ""
"`std::string` requires move constructors that don't match Rust's move "
"semantics, so a `std::string` can't be passed by value to Rust."
msgstr ""
"`std::string` necesit캒 constructori de mutare care nu se potrivesc cu "
"semantica de mutare a Rust, astfel 칥nc칙t un `std::string` nu poate fi "
"transmis ca valoare c캒tre Rust."

#: src/android/interoperability/cpp/android-build-cpp.md
#: src/android/interoperability/cpp/android-cpp-genrules.md
#: src/android/interoperability/cpp/android-build-rust.md
#, fuzzy
msgid "Building in Android"
msgstr "Construirea pentru Android: C++"

#: src/android/interoperability/cpp/android-build-cpp.md
#, fuzzy
msgid ""
"Create a `cc_library_static` to build the C++ library, including the CXX "
"generated header and source file."
msgstr ""
"Crea탵i o `cc_library_static` pentru a construi biblioteca C++, inclusiv "
"fi탳ierul surs캒 탳i antetul generat de CXX."

#: src/android/interoperability/cpp/android-build-cpp.md
#: src/android/interoperability/cpp/android-build-rust.md
#, fuzzy
msgid "\"libcxx_test_cpp\""
msgstr "\"libcxx_test_cpp\""

#: src/android/interoperability/cpp/android-build-cpp.md
#, fuzzy
msgid "\"cxx_test.cpp\""
msgstr "\"cxx_test.cpp\""

#: src/android/interoperability/cpp/android-build-cpp.md
#, fuzzy
msgid "\"cxx-bridge-header\""
msgstr "\"cxx-bridge-header\""

#: src/android/interoperability/cpp/android-build-cpp.md
#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid "\"libcxx_test_bridge_header\""
msgstr "\"libcxx_test_bridge_header\""

#: src/android/interoperability/cpp/android-build-cpp.md
#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid "\"libcxx_test_bridge_code\""
msgstr "\"libcxx_test_bridge_code\""

#: src/android/interoperability/cpp/android-build-cpp.md
#, fuzzy
msgid ""
"Point out that `libcxx_test_bridge_header` and `libcxx_test_bridge_code` are "
"the dependencies for the CXX-generated C++ bindings. We'll show how these "
"are setup on the next slide."
msgstr ""
"Indica탵i c캒 `libcxx_test_bridge_header` 탳i `libcxx_test_bridge_code` sunt "
"dependen탵ele pentru leg캒turile C++ generate de CXX. Vom ar캒ta cum sunt "
"configurate acestea 칥n slide-ul urm캒tor."

#: src/android/interoperability/cpp/android-build-cpp.md
#, fuzzy
msgid ""
"Note that you also need to depend on the `cxx-bridge-header` library in "
"order to pull in common CXX definitions."
msgstr ""
"Re탵ine탵i c캒 trebuie s캒 depinde탵i 탳i de biblioteca `cxx-bridge-header` pentru "
"a trage defini탵iile CXX comune."

#: src/android/interoperability/cpp/android-build-cpp.md
#, fuzzy
msgid ""
"Full docs for using CXX in Android can be found in [the Android docs]"
"(https://source.android.com/docs/setup/build/rust/building-rust-modules/"
"android-rust-patterns#rust-cpp-interop-using-cxx). You may want to share "
"that link with the class so that students know where they can find these "
"instructions again in the future."
msgstr ""
"Documenta탵ia complet캒 pentru utilizarea CXX 칥n Android poate fi g캒sit캒 칥n "
"[the Android docs](https://source.android.com/docs/setup/build/rust/building-"
"rust-modules/android-rust-patterns#rust-cpp-interop-using-cxx). Este posibil "
"s캒 dori탵i s캒 칥mp캒rt캒탳i탵i acest link cu clasa, astfel 칥nc칙t elevii s캒 탳tie "
"unde pot g캒si din nou aceste instruc탵iuni 칥n viitor."

#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid ""
"Create two genrules: One to generate the CXX header, and one to generate the "
"CXX source file. These are then used as inputs to the `cc_library_static`."
msgstr ""
"Crea탵i dou캒 reguli de gen: Una pentru a genera antetul CXX 탳i una pentru a "
"genera fi탳ierul surs캒 CXX. Acestea sunt apoi folosite ca intr캒ri 칥n "
"`cc_library_static`."

#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid ""
"// Generate a C++ header containing the C++ bindings\n"
"// to the Rust exported functions in lib.rs.\n"
msgstr ""
"// Genera탵i un antet C++ care s캒 con탵in캒 leg캒turile C++\n"
"// la func탵iile exportate Rust din lib.rs.\n"

#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid "\"cxxbridge\""
msgstr "\"cxxbridge\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid "\"$(location cxxbridge) $(in) --header > $(out)\""
msgstr "\"$(location cxxbridge) $(in) --header > $(out)\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
#: src/android/interoperability/cpp/android-build-rust.md
#, fuzzy
msgid "\"lib.rs\""
msgstr "\"lib.rs\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid "\"lib.rs.h\""
msgstr "\"lib.rs.h\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid "// Generate the C++ code that Rust calls into.\n"
msgstr "// Generarea codului C++ pe care Rust 칥l apeleaz캒.\n"

#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid "\"$(location cxxbridge) $(in) > $(out)\""
msgstr "\"$(loca탵ia cxxbridge) $(in) > $(out)\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid "\"lib.rs.cc\""
msgstr "\"lib.rs.cc\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid ""
"The `cxxbridge` tool is a standalone tool that generates the C++ side of the "
"bridge module. It is included in Android and available as a Soong tool."
msgstr ""
"Instrumentul `cxxbridge` este un instrument independent care genereaz캒 "
"partea C++ a modulului punte. Acesta este inclus 칥n Android 탳i este "
"disponibil ca instrument Soong."

#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid ""
"By convention, if your Rust source file is `lib.rs` your header file will be "
"named `lib.rs.h` and your source file will be named `lib.rs.cc`. This naming "
"convention isn't enforced, though."
msgstr ""
"Prin conven탵ie, dac캒 fi탳ierul surs캒 Rust este `lib.rs`, fi탳ierul de antet se "
"va numi `lib.rs.h`, iar fi탳ierul surs캒 se va numi `lib.rs.cc`. Totu탳i, "
"aceast캒 conven탵ie de denumire nu este impus캒."

#: src/android/interoperability/cpp/android-build-rust.md
#, fuzzy
msgid ""
"Create a `rust_binary` that depends on `libcxx` and your `cc_library_static`."
msgstr ""
"Crea탵i un `rust_binary` care depinde de `libcxx` 탳i de `cc_library_static`."

#: src/android/interoperability/cpp/android-build-rust.md
#, fuzzy
msgid "\"cxx_test\""
msgstr "\"cxx_test\""

#: src/android/interoperability/cpp/android-build-rust.md
#, fuzzy
msgid "\"libcxx\""
msgstr "\"libcxx\""

#: src/android/interoperability/java.md
#, fuzzy
msgid "Interoperability with Java"
msgstr "Interoperabilitate cu Java"

#: src/android/interoperability/java.md
#, fuzzy
msgid ""
"Java can load shared objects via [Java Native Interface (JNI)](https://en."
"wikipedia.org/wiki/Java_Native_Interface). The [`jni` crate](https://docs.rs/"
"jni/) allows you to create a compatible library."
msgstr ""
"Java poate 칥nc캒rca obiecte partajate prin intermediul [Java Native Interface "
"(JNI)](https://en.wikipedia.org/wiki/Java_Native_Interface). Cr캒iasa [`jni` "
"crate](https://docs.rs/jni/) v캒 permite s캒 crea탵i o bibliotec캒 compatibil캒."

#: src/android/interoperability/java.md
#, fuzzy
msgid "First, we create a Rust function to export to Java:"
msgstr "Mai 칥nt칙i, cre캒m o func탵ie Rust pentru a exporta 칥n Java:"

#: src/android/interoperability/java.md
#, fuzzy
msgid "_interoperability/java/src/lib.rs_:"
msgstr "interoperabilitate/java/src/lib.rs_:"

#: src/android/interoperability/java.md
#, fuzzy
msgid "//! Rust <-> Java FFI demo.\n"
msgstr "//! Rust <-> Java FFI demo.\n"

#: src/android/interoperability/java.md
#, fuzzy
msgid "/// HelloWorld::hello method implementation.\n"
msgstr "/// Implementarea metodei HelloWorld::hello.\n"

#: src/android/interoperability/java.md
#, fuzzy
msgid "\"system\""
msgstr "\"sistem\""

#: src/android/interoperability/java.md
#, fuzzy
msgid "\"Hello, {input}!\""
msgstr "\"Bun캒 ziua, {input}!\""

#: src/android/interoperability/java.md
#, fuzzy
msgid "_interoperability/java/Android.bp_:"
msgstr "interoperabilitate/java/Android.bp_:"

#: src/android/interoperability/java.md
#, fuzzy
msgid "\"libhello_jni\""
msgstr "\"libhello_jni\""

#: src/android/interoperability/java.md
#, fuzzy
msgid "\"hello_jni\""
msgstr "\"hello_jni\""

#: src/android/interoperability/java.md
#, fuzzy
msgid "\"libjni\""
msgstr "\"libjni\""

#: src/android/interoperability/java.md
#, fuzzy
msgid "We then call this function from Java:"
msgstr "칉n cele din urm캒, putem apela aceast캒 func탵ie din Java:"

#: src/android/interoperability/java.md
#, fuzzy
msgid "_interoperability/java/HelloWorld.java_:"
msgstr "interoperabilitate/java/HelloWorld.java_:"

#: src/android/interoperability/java.md
#, fuzzy
msgid "\"helloworld_jni\""
msgstr "\"helloworld_jni\""

#: src/android/interoperability/java.md
#, fuzzy
msgid "\"HelloWorld.java\""
msgstr "Bun캒 lume!"

#: src/android/interoperability/java.md
#, fuzzy
msgid "\"HelloWorld\""
msgstr "Bun캒 lume!"

#: src/android/interoperability/java.md
#, fuzzy
msgid "Finally, you can build, sync, and run the binary:"
msgstr ""
"칉n cele din urm캒, pute탵i s캒 construi탵i, s캒 sincroniza탵i 탳i s캒 executa탵i "
"programul binar:"

#: src/exercises/android/morning.md
#, fuzzy
msgid ""
"This is a group exercise: We will look at one of the projects you work with "
"and try to integrate some Rust into it. Some suggestions:"
msgstr ""
"Acesta este un exerci탵iu de grup: Ne vom uita la unul dintre proiectele la "
"care lucra탵i 탳i vom 칥ncerca s캒 integr캒m 칥n el Rust. C칙teva sugestii:"

#: src/exercises/android/morning.md
#, fuzzy
msgid "Call your AIDL service with a client written in Rust."
msgstr "Apela탵i serviciul AIDL cu un client scris 칥n Rust."

#: src/exercises/android/morning.md
#, fuzzy
msgid "Move a function from your project to Rust and call it."
msgstr "Muta탵i o func탵ie din proiectul dvs. 칥n Rust 탳i apela탵i-o."

#: src/exercises/android/morning.md
#, fuzzy
msgid ""
"No solution is provided here since this is open-ended: it relies on someone "
"in the class having a piece of code which you can turn in to Rust on the fly."
msgstr ""
"Nu se ofer캒 nicio solu탵ie aici, deoarece este o 칥ntrebare deschis캒: se "
"bazeaz캒 pe faptul c캒 cineva din clas캒 are o bucat캒 de cod pe care o pute탵i "
"transforma 칥n Rust din mers."

#: src/chromium.md
#, fuzzy
msgid "Welcome to Rust in Chromium"
msgstr "Bine a탵i venit la Rust 칥n Android"

#: src/chromium.md
#, fuzzy
msgid ""
"Rust is supported for third-party libraries in Chromium, with first-party "
"glue code to connect between Rust and existing Chromium C++ code."
msgstr ""
"Rust este suportat pentru bibliotecile ter탵ilor 칥n Chromium, cu un cod de "
"lipire de prima parte pentru a face leg캒tura 칥ntre Rust 탳i codul C++ "
"existent 칥n Chromium."

#: src/chromium.md
#, fuzzy
msgid ""
"Today, we'll call into Rust to do something silly with strings. If you've "
"got a corner of the code where you're displaying a UTF8 string to the user, "
"feel free to follow this recipe in your part of the codebase instead of the "
"exact part we talk about."
msgstr ""
"Ast캒zi, vom apela la Rust pentru a face ceva prostesc cu 탳iruri de "
"caractere. Dac캒 ave탵i un col탵 de cod 칥n care afi탳a탵i un 탳ir UTF8 "
"utilizatorului, nu ezita탵i s캒 urma탵i aceast캒 re탵et캒 칥n partea dvs. de baz캒 "
"de cod 칥n loc de partea despre care vorbim noi."

#: src/chromium/setup.md
#, fuzzy
msgid ""
"Make sure you can build and run Chromium. Any platform and set of build "
"flags is OK, so long as your code is relatively recent (commit position "
"1223636 onwards, corresponding to November 2023):"
msgstr ""
"Asigura탵i-v캒 c캒 pute탵i construi 탳i rula Chromium. Orice platform캒 탳i orice "
"set de indicatori de compilare este 칥n regul캒, at칙ta timp c칙t codul dvs. "
"este relativ recent (칥ncep칙nd cu pozi탵ia de commit 1223636, corespunz칙nd "
"lunii noiembrie 2023):"

#: src/chromium/setup.md
#, fuzzy
msgid ""
"(A component, debug build is recommended for quickest iteration time. This "
"is the default!)"
msgstr ""
"(Pentru un timp de itera탵ie c칙t mai scurt, se recomand캒 o component캒, o "
"construc탵ie de depanare. Aceasta este op탵iunea implicit캒)"

#: src/chromium/setup.md
#, fuzzy
msgid ""
"See [How to build Chromium](https://www.chromium.org/developers/how-tos/get-"
"the-code/) if you aren't already at that point. Be warned: setting up to "
"build Chromium takes time."
msgstr ""
"Consulta탵i [How to build Chromium](https://www.chromium.org/developers/how-"
"tos/get-the-code/) dac캒 nu a탵i ajuns deja 칥n acest punct. Fi탵i aten탵i: "
"configurarea pentru a construi Chromium necesit캒 timp."

#: src/chromium/setup.md
#, fuzzy
msgid "It's also recommended that you have Visual Studio code installed."
msgstr "De asemenea, se recomand캒 s캒 ave탵i instalat codul Visual Studio."

#: src/chromium/setup.md
#, fuzzy
msgid "About the exercises"
msgstr "Despre exerci탵ii"

#: src/chromium/setup.md
#, fuzzy
msgid ""
"This part of the course has a series of exercises which build on each other. "
"We'll be doing them spread throughout the course instead of just at the end. "
"If you don't have time to complete a certain part, don't worry: you can "
"catch up in the next slot."
msgstr ""
"Aceast캒 parte a cursului cuprinde o serie de exerci탵ii care se bazeaz캒 unul "
"pe cel캒lalt. Le vom face repartizate pe tot parcursul cursului 탳i nu doar la "
"sf칙r탳it. Dac캒 nu ave탵i timp s캒 termina탵i o anumit캒 parte, nu v캒 face탵i "
"griji: pute탵i recupera 칥n intervalul urm캒tor."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"The Rust community typically uses `cargo` and libraries from [crates.io]"
"(https://crates.io/). Chromium is built using `gn` and `ninja` and a curated "
"set of dependencies."
msgstr ""
"Comunitatea Rust folose탳te de obicei `cargo` 탳i bibliotecile din [crates.io]"
"(https://crates.io/). Chromium este construit folosind `gn` 탳i `ninja` 탳i un "
"set curatorial de dependen탵e."

#: src/chromium/cargo.md
#, fuzzy
msgid "When writing code in Rust, your choices are:"
msgstr "C칙nd scrie탵i cod 칥n Rust, ave탵i de ales 칥ntre:"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Use `gn` and `ninja` with the help of the templates from `//build/rust/*."
"gni` (e.g. `rust_static_library` that we'll meet later). This uses "
"Chromium's audited toolchain and crates."
msgstr ""
"Utiliza탵i `gn` 탳i `ninja` cu ajutorul 탳abloanelor din `//build/rust/*.gni` "
"(de exemplu `rust_static_library` pe care 칥l vom 칥nt칙lni mai t칙rziu). Acest "
"lucru utilizeaz캒 toolchain-ul 탳i crates auditate de Chromium."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Use `cargo`, but [restrict yourself to Chromium's audited toolchain and "
"crates](https://chromium.googlesource.com/chromium/src/+/refs/heads/main/"
"docs/rust.md#Using-cargo)"
msgstr ""
"Folosi탵i `cargo`, dar [limita탵i-v캒 la lan탵ul de instrumente 탳i la crates "
"auditate de Chromium](https://chromium.googlesource.com/chromium/src/+/refs/"
"heads/main/docs/rust.md#Using-cargo)"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Use `cargo`, trusting a [toolchain](https://rustup.rs/) and/or [crates "
"downloaded from the internet](https://crates.io/)"
msgstr ""
"Folosi탵i `cargo`, av칙nd 칥ncredere 칥ntr-un [toolchain](https://rustup.rs/) 탳i/"
"sau [l캒zi desc캒rcate de pe internet](https://crates.io/)"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"From here on we'll be focusing on `gn` and `ninja`, because this is how Rust "
"code can be built into the Chromium browser. At the same time, Cargo is an "
"important part of the Rust ecosystem and you should keep it in your toolbox."
msgstr ""
"De aici 칥ncolo ne vom concentra pe `gn` 탳i `ninja`, deoarece acesta este "
"modul 칥n care codul Rust poate fi integrat 칥n browserul Chromium. 칉n acela탳i "
"timp, Cargo este o parte important캒 a ecosistemului Rust 탳i ar trebui s캒 칥l "
"p캒stra탵i 칥n setul de instrumente."

#: src/chromium/cargo.md
#, fuzzy
msgid "Mini exercise"
msgstr "exerci탵iu:"

#: src/chromium/cargo.md
#, fuzzy
msgid "Split into small groups and:"
msgstr "칉mp캒r탵i탵i-v캒 칥n grupuri mici 탳i:"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Brainstorm scenarios where `cargo` may offer an advantage and assess the "
"risk profile of these scenarios."
msgstr ""
"G칙ndi탵i-v캒 la scenarii 칥n care \"칥nc캒rc캒tura\" poate oferi un avantaj 탳i "
"evalua탵i profilul de risc al acestor scenarii."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Discuss which tools, libraries, and groups of people need to be trusted when "
"using `gn` and `ninja`, offline `cargo`, etc."
msgstr ""
"Discuta탵i ce instrumente, biblioteci 탳i grupuri de persoane trebuie s캒 fie "
"de 칥ncredere atunci c칙nd se utilizeaz캒 `gn` 탳i `ninja`, `cargo` offline etc."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Ask students to avoid peeking at the speaker notes before completing the "
"exercise. Assuming folks taking the course are physically together, ask them "
"to discuss in small groups of 3-4 people."
msgstr ""
"Cere탵i elevilor s캒 evite s캒 trag캒 cu ochiul la notele vorbitorului 칥nainte "
"de a finaliza exerci탵iul. Presupun칙nd c캒 cei care urmeaz캒 cursul sunt fizic "
"칥mpreun캒, ruga탵i-i s캒 discute 칥n grupuri mici de 3-4 persoane."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Notes/hints related to the first part of the exercise (\"scenarios where "
"Cargo may offer an advantage\"):"
msgstr ""
"Note/sugestii legate de prima parte a exerci탵iului (\"scenarii 칥n care Cargo "
"poate oferi un avantaj\"):"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"It's fantastic that when writing a tool, or prototyping a part of Chromium, "
"one has access to the rich ecosystem of crates.io libraries. There is a "
"crate for almost anything and they are usually quite pleasant to use. "
"(`clap` for command-line parsing, `serde` for serializing/deserializing to/"
"from various formats, `itertools` for working with iterators, etc.)."
msgstr ""
"Este fantastic faptul c캒 atunci c칙nd se scrie un instrument sau se creeaz캒 "
"prototipuri pentru o parte din Chromium, se are acces la ecosistemul bogat "
"de biblioteci crates.io. Exist캒 un crate pentru aproape orice 탳i, de obicei, "
"acestea sunt destul de pl캒cute de utilizat. (`clap` pentru parsarea liniei "
"de comand캒, `serde` pentru serializare/deserializare 칥n/din diverse formate, "
"`itertools` pentru lucrul cu iteratori, etc.)."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"`cargo` makes it easy to try a library (just add a single line to `Cargo."
"toml` and start writing code)"
msgstr ""
"`cargo` face mai u탳oar캒 칥ncercarea unei biblioteci (doar ad캒uga탵i o singur캒 "
"linie la `Cargo.toml` 탳i 칥ncepe탵i s캒 scrie탵i cod)"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"It may be worth comparing how CPAN helped make `perl` a popular choice. Or "
"comparing with `python` + `pip`."
msgstr ""
"Poate c캒 merit캒 s캒 compar캒m modul 칥n care CPAN a ajutat la transformarea lui "
"`perl` 칥ntr-o alegere popular캒. Sau compar칙nd cu `python` + `pip`."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Development experience is made really nice not only by core Rust tools (e.g. "
"using `rustup` to switch to a different `rustc` version when testing a crate "
"that needs to work on nightly, current stable, and older stable) but also by "
"an ecosystem of third-party tools (e.g. Mozilla provides `cargo vet` for "
"streamlining and sharing security audits; `criterion` crate gives a "
"streamlined way to run benchmarks)."
msgstr ""
"Experien탵a de dezvoltare este foarte pl캒cut캒 nu numai prin instrumentele "
"Rust de baz캒 (de exemplu, utilizarea `rustup` pentru a trece la o versiune "
"diferit캒 de `rustc` atunci c칙nd se testeaz캒 un crate care trebuie s캒 "
"func탵ioneze pe nightly, current stable 탳i old stable), ci 탳i printr-un "
"ecosistem de instrumente ter탵e (de exemplu, Mozilla ofer캒 `cargo vet` pentru "
"simplificarea 탳i partajarea auditurilor de securitate; crate `criterion` "
"ofer캒 o modalitate simplificat캒 de a rula teste de referin탵캒)."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"`cargo` makes it easy to add a tool via `cargo install --locked cargo-vet`."
msgstr ""
"`cargo` faciliteaz캒 ad캒ugarea unui instrument prin `cargo install --locked "
"cargo-vet`."

#: src/chromium/cargo.md
#, fuzzy
msgid "It may be worth comparing with Chrome Extensions or VScode extensions."
msgstr ""
"Ar putea fi util캒 o compara탵ie cu extensiile Chrome Extensions sau VScode "
"Extensions."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Broad, generic examples of projects where `cargo` may be the right choice:"
msgstr ""
"Exemple generale, generice, de proiecte 칥n care `cargo` poate fi alegerea "
"potrivit캒:"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Perhaps surprisingly, Rust is becoming increasingly popular in the industry "
"for writing command line tools. The breadth and ergonomics of libraries is "
"comparable to Python, while being more robust (thanks to the rich "
"typesystem) and running faster (as a compiled, rather than interpreted "
"language)."
msgstr ""
"Poate surprinz캒tor, Rust devine din ce 칥n ce mai popular 칥n industrie pentru "
"scrierea instrumentelor de linie de comand캒. Amploarea 탳i ergonomia "
"bibliotecilor este comparabil캒 cu Python, fiind 칥n acela탳i timp mai robust "
"(datorit캒 sistemului de tipuri bogat) 탳i func탵ion칙nd mai rapid (fiind un "
"limbaj compilat, mai degrab캒 dec칙t interpretat)."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Participating in the Rust ecosystem requires using standard Rust tools like "
"Cargo. Libraries that want to get external contributions, and want to be "
"used outside of Chromium (e.g. in Bazel or Android/Soong build environments) "
"should probably use Cargo."
msgstr ""
"Participarea la ecosistemul Rust necesit캒 utilizarea instrumentelor standard "
"Rust, cum ar fi Cargo. Bibliotecile care doresc s캒 primeasc캒 contribu탵ii "
"externe 탳i care doresc s캒 fie utilizate 칥n afara Chromium (de exemplu, 칥n "
"Bazel sau 칥n mediile de compilare Android/Soong) ar trebui probabil s캒 "
"utilizeze Cargo."

#: src/chromium/cargo.md
#, fuzzy
msgid "Examples of Chromium-related projects that are `cargo`\\-based:"
msgstr "Exemple de proiecte legate de Chromium care sunt bazate pe `cargo`:"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"`serde_json_lenient` (experimented with in other parts of Google which "
"resulted in PRs with performance improvements)"
msgstr ""
"`serde_json_lenient` (experimentat 칥n alte p캒r탵i ale Google, ceea ce a dus "
"la PR-uri cu 칥mbun캒t캒탵iri de performan탵캒)"

#: src/chromium/cargo.md
#, fuzzy
msgid "Fontations libraries like `font-types`"
msgstr "Biblioteci de fonturi precum `font-types`"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"`gnrt` tool (we will meet it later in the course) which depends on `clap` "
"for command-line parsing and on `toml` for configuration files."
msgstr ""
"instrumentul `gnrt` (칥l vom 칥nt칙lni mai t칙rziu 칥n curs) care depinde de "
"`clap` pentru analiza liniei de comand캒 탳i de `toml` pentru fi탳ierele de "
"configurare."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Disclaimer: a unique reason for using `cargo` was unavailability of `gn` "
"when building and bootstrapping Rust standard library when building Rust "
"toolchain."
msgstr ""
"Avertisment: un motiv unic pentru a folosi `cargo` a fost indisponibilitatea "
"lui `gn` la construirea 탳i bootstraparea bibliotecii standard Rust la "
"construirea lan탵ului de instrumente Rust)"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"`run_gnrt.py` uses Chromium's copy of `cargo` and `rustc`. `gnrt` depends on "
"third-party libraries downloaded from the internet, but `run_gnrt.py` asks "
"`cargo` that only `--locked` content is allowed via `Cargo.lock`.)"
msgstr ""
"`run_gnrt.py` folose탳te copia Chromium a `cargo` 탳i `rustc`. `gnrt` depinde "
"de biblioteci ter탵e desc캒rcate de pe internet, prin `run_gnrt.py` cere "
"`cargo` ca numai con탵inutul `--blocat` s캒 fie permis prin `Cargo.lock`)"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Students may identify the following items as being implicitly or explicitly "
"trusted:"
msgstr ""
"Elevii pot identifica urm캒toarele elemente ca fiind de 칥ncredere implicit캒 "
"sau explicit캒:"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"`rustc` (the Rust compiler) which in turn depends on the LLVM libraries, the "
"Clang compiler, the `rustc` sources (fetched from GitHub, reviewed by Rust "
"compiler team), binary Rust compiler downloaded for bootstrapping"
msgstr ""
"`rustc` (compilatorul Rust), care la r칙ndul s캒u depinde de bibliotecile "
"LLVM, de compilatorul Clang, de sursele `rustc` (preluate de pe GitHub, "
"revizuite de echipa compilatorului Rust), de compilatorul binar Rust "
"desc캒rcat pentru bootstrap"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"`rustup` (it may be worth pointing out that `rustup` is developed under the "
"umbrella of the https://github.com/rust-lang/ organization - same as `rustc`)"
msgstr ""
"`rustup` (poate c캒 merit캒 subliniat faptul c캒 `rustup` este dezvoltat sub "
"umbrela organiza탵iei https://github.com/rust-lang/ - la fel ca `rustc`)"

#: src/chromium/cargo.md
#, fuzzy
msgid "`cargo`, `rustfmt`, etc."
msgstr "`cargo`, `rustfmt`, etc."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Various internal infrastructure (bots that build `rustc`, system for "
"distributing the prebuilt toolchain to Chromium engineers, etc.)"
msgstr ""
"Diferite infrastructuri interne (robo탵i care construiesc `rustc`, sistemul "
"de distribuire a lan탵ului de instrumente pre-construit c캒tre inginerii "
"Chromium, etc.)"

#: src/chromium/cargo.md
#, fuzzy
msgid "Cargo tools like `cargo audit`, `cargo vet`, etc."
msgstr "Instrumente pentru m캒rfuri, cum ar fi `cargo audit`, `cargo vet`, etc."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Rust libraries vendored into `//third_party/rust` (audited by "
"security@chromium.org)"
msgstr ""
"Biblioteci Rust v칙ndute 칥n `//third_party/rust` (auditate de "
"security@chromium.org)"

#: src/chromium/cargo.md
#, fuzzy
msgid "Other Rust libraries (some niche, some quite popular and commonly used)"
msgstr ""
"Alte biblioteci Rust (unele de ni탳캒, altele destul de populare 탳i utilizate "
"칥n mod obi탳nuit)"

#: src/chromium/policy.md
#, fuzzy
msgid "Chromium Rust policy"
msgstr "Politica privind rugina de crom"

#: src/chromium/policy.md
#, fuzzy
msgid ""
"Chromium does not yet allow first-party Rust except in rare cases as "
"approved by Chromium's [Area Tech Leads](https://source.chromium.org/"
"chromium/chromium/src/+/main:ATL_OWNERS)."
msgstr ""
"Chromium nu permite 칥nc캒 Rust de la prima parte, cu excep탵ia unor cazuri "
"rare, aprobate de [Area Tech Leads] (https://source.chromium.org/chromium/"
"chromium/src/+/main:ATL_OWNERS)."

#: src/chromium/policy.md
#, fuzzy
msgid ""
"Chromium's policy on third party libraries is outlined [here](https://"
"chromium.googlesource.com/chromium/src/+/main/docs/adding_to_third_party."
"md#rust) - Rust is allowed for third party libraries under various "
"circumstances, including if they're the best option for performance or for "
"security."
msgstr ""
"Politica Chromium cu privire la bibliotecile ter탵ilor este prezentat캒 [aici] "
"(https://chromium.googlesource.com/chromium/src/+/main/docs/"
"adding_to_third_party.md#rust) - Rust este permis pentru bibliotecile "
"ter탵ilor 칥n diverse circumstan탵e, inclusiv dac캒 acestea reprezint캒 cea mai "
"bun캒 op탵iune pentru performan탵캒 sau securitate."

#: src/chromium/policy.md
#, fuzzy
msgid ""
"Very few Rust libraries directly expose a C/C++ API, so that means that "
"nearly all such libraries will require a small amount of first-party glue "
"code."
msgstr ""
"Foarte pu탵ine biblioteci Rust expun direct un API C/C++, ceea ce 칥nseamn캒 c캒 "
"aproape toate aceste biblioteci vor necesita o cantitate mic캒 de cod glue de "
"la prima parte."

#: src/chromium/policy.md
#, fuzzy
msgid ""
"```bob\n"
"\"C++\"                           Rust\n"
".- - - - - - - - - -.           .- - - - - - - - - - - - - - - - - - - - - - "
"-.\n"
":                   :           :                                             :\n"
": Existing Chromium :           :  Chromium Rust              Existing "
"Rust   :\n"
": \"C++\"             :           :  \"wrapper\"                  "
"crate           :\n"
": +---------------+ :           : +----------------+          +-------------"
"+ :\n"
": |               | :           : |                |          |             "
"| :\n"
": |         o-----+-+-----------+-+->            o-+----------+-->          "
"| :\n"
": |               | : Language  : |                | Crate    |             "
"| :\n"
": +---------------+ : boundary  : +----------------+ API      +-------------"
"+ :\n"
":                   :           :                                             :\n"
"`- - - - - - - - - -'           `- - - - - - - - - - - - - - - - - - - - - - "
"-'\n"
"```"
msgstr ""
"```bob\n"
" Stiva Heap\n"
".- - - - - - - - - - - - -. .- - - - - - - - - - - - - - - - - - - - - - -.\n"
": : : :\n"
": list캒 : : : :\n"
":   +----+----+ : : +----+----+ +----+------+ :\n"
":   | 1 | o--+-----------+-----+--->| 2 | o--++--->| // | null | :\n"
":   +----+----+ : : +----+----+ +----+------+ :\n"
": : : :\n"
": : : :\n"
"`- - - - - - - - - - - - -' '- - - - - - - - - - - - - - - - - - - - - - -'\n"
"```"

#: src/chromium/policy.md
#, fuzzy
msgid ""
"First-party Rust glue code for a particular third-party crate should "
"normally be kept in `third_party/rust/<crate>/<version>/wrapper`."
msgstr ""
"Codul de lipire Rust de prima parte pentru o anumit캒 cr캒p캒tur캒 ter탵캒 parte "
"ar trebui s캒 fie p캒strat 칥n mod normal 칥n `third_party/rust/<crate>/"
"<version>/wrapper`."

#: src/chromium/policy.md
#, fuzzy
msgid "Because of this, today's course will be heavily focused on:"
msgstr "Din acest motiv, cursul de ast캒zi se va concentra pe:"

#: src/chromium/policy.md
#, fuzzy
msgid "Bringing in third-party Rust libraries (\"crates\")"
msgstr "Introducerea de biblioteci Rust de la ter탵i (\"crates\")"

#: src/chromium/policy.md
#, fuzzy
msgid "Writing glue code to be able to use those crates from Chromium C++."
msgstr ""
"Scrierea codului de lipire pentru a putea utiliza aceste crates din Chromium "
"C++."

#: src/chromium/policy.md
#, fuzzy
msgid "If this policy changes over time, the course will evolve to keep up."
msgstr ""
"Dac캒 aceast캒 politic캒 se schimb캒 칥n timp, cursul va evolua pentru a 탵ine "
"pasul cu ea."

#: src/chromium/build-rules.md
#, fuzzy
msgid "Build rules"
msgstr "Reguli de construc탵ie"

#: src/chromium/build-rules.md
#, fuzzy
msgid ""
"Rust code is usually built using `cargo`. Chromium builds with `gn` and "
"`ninja` for efficiency --- its static rules allow maximum parallelism. Rust "
"is no exception."
msgstr ""
"Codul Rust este de obicei construit folosind `cargo`. Chromium se "
"construie탳te cu `gn` 탳i `ninja` pentru eficien탵캒 --- regulile sale statice "
"permit un paralelism maxim. Rust nu face excep탵ie."

#: src/chromium/build-rules.md
#, fuzzy
msgid "Adding Rust code to Chromium"
msgstr "Ad캒ugarea de cod Rust 칥n Chromium"

#: src/chromium/build-rules.md
#, fuzzy
msgid ""
"In some existing Chromium `BUILD.gn` file, declare a `rust_static_library`:"
msgstr ""
"칉n unele fi탳iere Chromium `BUILD.gn` existente, declara탵i o "
"`rust_static_library`:"

#: src/chromium/build-rules.md
#, fuzzy
msgid ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"}\n"
"```"
msgstr ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"}\n"
"```"

#: src/chromium/build-rules.md
#, fuzzy
msgid ""
"You can also add `deps` on other Rust targets. Later we'll use this to "
"depend upon third party code."
msgstr ""
"De asemenea, pute탵i ad캒uga `deps` pe alte obiective Rust. Mai t칙rziu vom "
"folosi acest lucru pentru a depinde de codul ter탵ilor."

#: src/chromium/build-rules.md
#, fuzzy
msgid ""
"You must specify _both_ the crate root, _and_ a full list of sources. The "
"`crate_root` is the file given to the Rust compiler representing the root "
"file of the compilation unit --- typically `lib.rs`. `sources` is a complete "
"list of all source files which `ninja` needs in order to determine when "
"rebuilds are necessary."
msgstr ""
"Trebuie s캒 specifica탵i at칙t r캒d캒cina l캒zii, c칙t 탳i o list캒 complet캒 de "
"surse. `crate_root` este fi탳ierul dat compilatorului Rust care reprezint캒 "
"fi탳ierul r캒d캒cin캒 al unit캒탵ii de compilare --- de obicei `lib.rs`. `sources` "
"este o list캒 complet캒 a tuturor fi탳ierelor surs캒 de care `ninja` are nevoie "
"pentru a determina c칙nd sunt necesare reconstruc탵iile."

#: src/chromium/build-rules.md
#, fuzzy
msgid ""
"(There's no such thing as a Rust `source_set`, because in Rust, an entire "
"crate is a compilation unit. A `static_library` is the smallest unit.)"
msgstr ""
"(Nu exist캒 un astfel de lucru ca un `source_set` Rust, deoarece 칥n Rust, un "
"칥ntreg crate este o unitate de compilare. O `static_library` este cea mai "
"mic캒 unitate)"

#: src/chromium/build-rules.md
#, fuzzy
msgid ""
"Students might be wondering why we need a gn template, rather than using "
"[gn's built-in support for Rust static libraries](https://gn.googlesource."
"com/gn/+/main/docs/reference.md#func_static_library). The answer is that "
"this template provides support for CXX interop, Rust features, and unit "
"tests, some of which we'll use later."
msgstr ""
"Studen탵ii s-ar putea s캒 se 칥ntrebe de ce avem nevoie de un 탳ablon gn, 칥n loc "
"s캒 folosim [suportul 칥ncorporat al gn pentru bibliotecile statice Rust] "
"(https://gn.googlesource.com/gn/+/main/docs/reference."
"md#func_static_library). R캒spunsul este c캒 acest 탳ablon ofer캒 suport pentru "
"interopulare CXX, caracteristici Rust 탳i teste unitare, unele dintre acestea "
"urm칙nd s캒 le folosim mai t칙rziu."

#: src/chromium/build-rules/unsafe.md
#, fuzzy
msgid "Including `unsafe` Rust Code"
msgstr "Includerea codului Rust `unsafe` Rust"

#: src/chromium/build-rules/unsafe.md
#, fuzzy
msgid ""
"Unsafe Rust code is forbidden in `rust_static_library` by default --- it "
"won't compile. If you need unsafe Rust code, add `allow_unsafe = true` to "
"the gn target. (Later in the course we'll see circumstances where this is "
"necessary.)"
msgstr ""
"Codul Rust nesigur este interzis 칥n `rust_static_library` 칥n mod implicit "
"--- nu va fi compilat. Dac캒 ave탵i nevoie de cod Rust nesigur, ad캒uga탵i "
"`allow_unsafe = true` la 탵inta gn. (Mai t칙rziu 칥n curs vom vedea "
"circumstan탵e 칥n care acest lucru este necesar)"

#: src/chromium/build-rules/unsafe.md
#, fuzzy
msgid ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [\n"
"    \"lib.rs\",\n"
"    \"hippopotamus.rs\"\n"
"  ]\n"
"  allow_unsafe = true\n"
"}\n"
"```"
msgstr ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [\n"
"    \"lib.rs\",\n"
"    \"hippopotamus.rs\"\n"
"  ]\n"
"  allow_unsafe = true\n"
"}\n"
"```"

#: src/chromium/build-rules/depending.md
#, fuzzy
msgid "Simply add the above target to the `deps` of some Chromium C++ target."
msgstr ""
"Pur 탳i simplu ad캒uga탵i 탵inta de mai sus la `deps` a unei 탵inte Chromium C++."

#: src/chromium/build-rules/depending.md
#, fuzzy
msgid ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"}\n"
"\n"
"# or source_set, static_library etc.\n"
"component(\"preexisting_cpp\") {\n"
"  deps = [ \":my_rust_lib\" ]\n"
"}\n"
"```"
msgstr ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"}\n"
"\n"
"# sau source_set, static_library etc.\n"
"component(\"preexisting_cpp\") {\n"
"  deps = [ \":my_rust_lib\" ]\n"
"}\n"
"```"

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid ""
"Types are elided in Rust code, which makes a good IDE even more useful than "
"for C++. Visual Studio code works well for Rust in Chromium. To use it,"
msgstr ""
"Tipurile sunt elidate 칥n codul Rust, ceea ce face ca un IDE bun s캒 fie 탳i "
"mai util dec칙t 칥n cazul C++. Codul Visual Studio func탵ioneaz캒 bine pentru "
"Rust 칥n Chromium. Pentru a-l utiliza,"

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid ""
"Ensure your VSCode has the `rust-analyzer` extension, not earlier forms of "
"Rust support"
msgstr ""
"Asigura탵i-v캒 c캒 VSCode-ul dumneavoastr캒 are extensia `rust-analyzer`, nu "
"formele anterioare de suport Rust"

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid ""
"`gn gen out/Debug --export-rust-project` (or equivalent for your output "
"directory)"
msgstr ""
"`gn gen out/Debug --export-rust-project` (sau echivalent pentru directorul "
"de ie탳ire)"

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid "`ln -s out/Debug/rust-project.json rust-project.json`"
msgstr "`ln -s out/Debug/rust-project.json rust-project.json`"

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid ""
"A demo of some of the code annotation and exploration features of rust-"
"analyzer might be beneficial if the audience are naturally skeptical of IDEs."
msgstr ""
"O demonstra탵ie a unora dintre caracteristicile de adnotare 탳i explorare a "
"codului din rust-analyzer ar putea fi benefic캒 dac캒 audien탵a este sceptic캒 "
"칥n mod natural fa탵캒 de IDE-uri."

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid ""
"The following steps may help with the demo (but feel free to instead use a "
"piece of Chromium-related Rust that you are most familiar with):"
msgstr ""
"Urm캒torii pa탳i v캒 pot ajuta cu demonstra탵ia (dar nu ezita탵i s캒 folosi탵i 칥n "
"schimb o bucat캒 de Rust legat캒 de Chromium cu care sunte탵i cel mai "
"familiarizat):"

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid "Open `components/qr_code_generator/qr_code_generator_ffi_glue.rs`"
msgstr ""
"Deschide탵i `components/qr_code_generator/qr_code_generator_ffi_glue.rs`"

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid ""
"Place the cursor over the `QrCode::new` call (around line 26) in "
"\\`qr_code_generator_ffi_glue.rs"
msgstr ""
"A탳eza탵i cursorul pe apelul `QrCode::new` (칥n jurul liniei 26) 칥n "
"\\`qr_code_generator_ffi_glue.rs"

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid ""
"Demo **show documentation** (typical bindings: vscode = ctrl k i; vim/CoC = "
"K)."
msgstr ""
"Demo **afi탳eaz캒 documenta탵ia** (leg캒turi tipice: vscode = ctrl k i; vim/CoC "
"= K)."

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid ""
"Demo **go to definition** (typical bindings: vscode = F12; vim/CoC = g d). "
"(This will take you to `//third_party/rust/.../qr_code-.../src/lib.rs`.)"
msgstr ""
"Demonstra탵ie **deplasa탵i-v캒 la defini탵ie** (leg캒turi tipice: vscode = F12; "
"vim/CoC = g d). (Acest lucru v캒 va duce la `//third_party/rust/.../"
"qr_code-.../src/lib.rs`)"

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid ""
"Demo **outline** and navigate to the `QrCode::with_bits` method (around line "
"164; the outline is in the file explorer pane in vscode; typical vim/CoC "
"bindings = space o)"
msgstr ""
"Demo **outline** 탳i naviga탵i p칙n캒 la metoda `QrCode::with_bits` (칥n jurul "
"liniei 164; conturul este 칥n panoul de explorare a fi탳ierelor din vscode; "
"leg캒turi tipice vim/CoC = space o)"

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid ""
"Demo **type annotations** (there are quote a few nice examples in the "
"`QrCode::with_bits` method)"
msgstr ""
"Demonstra탵ie **Anota탵ii de tip** (exist캒 c칙teva exemple frumoase 칥n metoda "
"`QrCode::with_bits`)"

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid ""
"It may be worth pointing out that `gn gen ... --export-rust-project` will "
"need to be rerun after editing `BUILD.gn` files (which we will do a few "
"times throughout the exercises in this session)."
msgstr ""
"Ar putea fi util s캒 subliniem c캒 `gn gen ... --export-rust-project` va "
"trebui s캒 fie rulat din nou dup캒 editarea fi탳ierelor `BUILD.gn` (ceea ce vom "
"face de c칙teva ori 칥n timpul exerci탵iilor din aceast캒 sesiune)."

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid "Build rules exercise"
msgstr "Reguli de construc탵ie"

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"In your Chromium build, add a new Rust target to `//ui/base/BUILD.gn` "
"containing:"
msgstr ""
"칉n construc탵ia Chromium, ad캒uga탵i o nou캒 탵int캒 Rust la `//ui/base/BUILD.gn` "
"care s캒 con탵in캒:"

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"**Important**: note that `no_mangle` here is considered a type of unsafety "
"by the Rust compiler, so you'll need to allow unsafe code in your `gn` "
"target."
msgstr ""
"**Important**: re탵ine탵i c캒 `no_mangle` aici este considerat un tip de "
"nesiguran탵캒 de c캒tre compilatorul Rust, deci va trebui s캒 permite탵i cod "
"nesigur 칥n 탵inta `gn`."

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"Add this new Rust target as a dependency of `//ui/base:base`. Declare this "
"function at the top of `ui/base/resource/resource_bundle.cc` (later, we'll "
"see how this can be automated by bindings generation tools):"
msgstr ""
"Ad캒uga탵i aceast캒 nou캒 탵int캒 Rust ca dependen탵캒 a `//ui/base:base`. Declara탵i "
"aceast캒 func탵ie 칥n partea de sus a `ui/base/resource/resource_bundle.cc` "
"(mai t칙rziu, vom vedea cum poate fi automatizat acest lucru de c캒tre "
"instrumentele de generare a leg캒turilor):"

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"Call this function from somewhere in `ui/base/resource/resource_bundle.cc` - "
"we suggest the top of `ResourceBundle::MaybeMangleLocalizedString`. Build "
"and run Chromium, and ensure that \"Hello from Rust!\" is printed lots of "
"times."
msgstr ""
"Apela탵i aceast캒 func탵ie de undeva din `ui/base/resource/resource_bundle.cc` "
"- suger캒m partea de sus a `ResourceBundle::MaybeMangleLocalizedString`. "
"Construi탵i 탳i rula탵i Chromium 탳i asigura탵i-v캒 c캒 \"Hello from Rust!\" este "
"tip캒rit de multe ori."

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"If you use VSCode, now set up Rust to work well in VSCode. It will be useful "
"in subsequent exercises. If you've succeeded, you will be able to use right-"
"click \"Go to definition\" on `println!`."
msgstr ""
"Dac캒 utiliza탵i VSCode, configura탵i Rust pentru a func탵iona bine 칥n VSCode. "
"Aceasta va fi util캒 칥n exerci탵iile urm캒toare. Dac캒 a탵i reu탳it, ve탵i putea "
"folosi click dreapta \"Go to definition\" pe `println!`."

#: src/exercises/chromium/build-rules.md
#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Where to find help"
msgstr "Unde g캒si탵i ajutor"

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"The options available to the [`rust_static_library` gn template](https://"
"source.chromium.org/chromium/chromium/src/+/main:build/rust/"
"rust_static_library.gni;l=16)"
msgstr ""
"Op탵iunile disponibile pentru 탳ablonul [`rust_static_library` gn](https://"
"source.chromium.org/chromium/chromium/src/+/main:build/rust/"
"rust_static_library.gni;l=16)"

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"Information about [`#[no_mangle]`](https://doc.rust-lang.org/beta/reference/"
"abi.html#the-no_mangle-attribute)"
msgstr ""
"Informa탵ii despre [`#[no_mangle]`](https://doc.rust-lang.org/beta/reference/"
"abi.html#the-no_mangle-attribute)"

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"Information about [`extern \"C\"`](https://doc.rust-lang.org/std/keyword."
"extern.html)"
msgstr ""
"Informa탵ii despre [`extern \"C\"`](https://doc.rust-lang.org/std/keyword."
"extern.html)"

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"Information about gn's [`--export-rust-project`](https://gn.googlesource.com/"
"gn/+/main/docs/reference.md#compilation-database) switch"
msgstr ""
"Informa탵ii despre comutatorul [`--export-rust-project`](https://gn."
"googlesource.com/gn/+/main/docs/reference.md#compilation-database) de la "
"gn's [`--export-rust-project`](https://gn.googlesource.com/gn/+/main/docs/"
"reference.md#compilation-database)"

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"[How to install rust-analyzer in VSCode](https://code.visualstudio.com/docs/"
"languages/rust)"
msgstr ""
"[Cum se instaleaz캒 rust-analyzer 칥n VSCode](https://code.visualstudio.com/"
"docs/languages/rust)"

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"This example is unusual because it boils down to the lowest-common-"
"denominator interop language, C. Both C++ and Rust can natively declare and "
"call C ABI functions. Later in the course, we'll connect C++ directly to "
"Rust."
msgstr ""
"Acest exemplu este neobi탳nuit, deoarece se reduce la cel mai mic limbaj de "
"interoperabilitate, C. At칙t C++, c칙t 탳i Rust pot declara 탳i apela 칥n mod "
"nativ func탵ii ABI C. Mai t칙rziu, 칥n cadrul cursului, vom conecta C++ direct "
"la Rust."

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"`allow_unsafe = true` is required here because `#[no_mangle]` might allow "
"Rust to generate two functions with the same name, and Rust can no longer "
"guarantee that the right one is called."
msgstr ""
"`allow_unsafe = true` este necesar aici deoarece `#[no_mangle]` ar putea "
"permite ca Rust s캒 genereze dou캒 func탵ii cu acela탳i nume, iar Rust nu mai "
"poate garanta c캒 este apelat캒 cea corect캒."

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"If you need a pure Rust executable, you can also do that using the "
"`rust_executable` gn template."
msgstr ""
"Dac캒 ave탵i nevoie de un executabil Rust pur, pute탵i face acest lucru "
"folosind 탳ablonul gn `rust_executable`."

#: src/chromium/testing.md
#, fuzzy
msgid ""
"Rust community typically authors unit tests in a module placed in the same "
"source file as the code being tested. This was covered [earlier](../testing."
"md) in the course and looks like this:"
msgstr ""
"Comunitatea Rust autorizeaz캒 de obicei testele unitare 칥ntr-un modul plasat "
"칥n acela탳i fi탳ier surs캒 ca 탳i codul testat. Acest lucru a fost abordat [mai "
"devreme](../testing.md) 칥n cadrul cursului 탳i arat캒 astfel:"

#: src/chromium/testing.md
#, fuzzy
msgid ""
"In Chromium we place unit tests in a separate source file and we continue to "
"follow this practice for Rust --- this makes tests consistently discoverable "
"and helps to avoid rebuilding `.rs` files a second time (in the `test` "
"configuration)."
msgstr ""
"칉n Chromium plas캒m testele unitare 칥ntr-un fi탳ier surs캒 separat 탳i continu캒m "
"s캒 urm캒m aceast캒 practic캒 pentru Rust --- acest lucru face ca testele s캒 "
"poat캒 fi descoperite 칥n mod constant 탳i ajut캒 la evitarea reconstruirii "
"fi탳ierelor `.rs` a doua oar캒 (칥n configura탵ia `test`)."

#: src/chromium/testing.md
#, fuzzy
msgid ""
"This results in the following options for testing Rust code in Chromium:"
msgstr ""
"Acest lucru are ca rezultat urm캒toarele op탵iuni pentru testarea codului Rust "
"칥n Chromium:"

#: src/chromium/testing.md
#, fuzzy
msgid ""
"Native Rust tests (i.e. `#[test]`). Discouraged outside of `//third_party/"
"rust`."
msgstr ""
"Teste Rust native (adic캒 `#[test]`). Descurajat 칥n afara `//third_party/"
"rust`."

#: src/chromium/testing.md
#, fuzzy
msgid ""
"`gtest` tests authored in C++ and exercising Rust via FFI calls. Sufficient "
"when Rust code is just a thin FFI layer and the existing unit tests provide "
"sufficient coverage for the feature."
msgstr ""
"teste `gtest` scrise 칥n C++ 탳i care utilizeaz캒 Rust prin apeluri FFI. "
"Suficient atunci c칙nd codul Rust este doar un strat FFI sub탵ire 탳i testele "
"unitare existente ofer캒 o acoperire suficient캒 pentru aceast캒 caracteristic캒."

#: src/chromium/testing.md
#, fuzzy
msgid ""
"`gtest` tests authored in Rust and using the crate under test through its "
"public API (using `pub mod for_testing { ... }` if needed). This is the "
"subject of the next few slides."
msgstr ""
"`gtest` testele sunt scrise 칥n Rust 탳i utilizeaz캒 crate-ul testat prin "
"intermediul API-ului s캒u public (folosind `pub mod for_testing { ... }` dac캒 "
"este necesar). Acesta este subiectul urm캒toarelor slide-uri."

#: src/chromium/testing.md
#, fuzzy
msgid ""
"Mention that native Rust tests of third-party crates should eventually be "
"exercised by Chromium bots. (Such testing is needed rarely --- only after "
"adding or updating third-party crates.)"
msgstr ""
"Men탵iona탵i c캒 testele Rust native ale craterelor ter탵e ar trebui s캒 fie 칥n "
"cele din urm캒 exercitate de robo탵ii Chromium. (Astfel de test캒ri sunt "
"necesare rareori --- doar dup캒 ad캒ugarea sau actualizarea unor crates de la "
"ter탵i)"

#: src/chromium/testing.md
#, fuzzy
msgid ""
"Some examples may help illustrate when C++ `gtest` vs Rust `gtest` should be "
"used:"
msgstr ""
"C칙teva exemple pot ajuta la ilustrarea momentului 칥n care ar trebui s캒 se "
"utilizeze `gtest` din C++ vs `gtest` din Rust:"

#: src/chromium/testing.md
#, fuzzy
msgid ""
"QR has very little functionality in the first-party Rust layer (it's just a "
"thin FFI glue) and therefore uses the existing C++ unit tests for testing "
"both the C++ and the Rust implementation (parameterizing the tests so they "
"enable or disable Rust using a `ScopedFeatureList`)."
msgstr ""
"QR are foarte pu탵in캒 func탵ionalitate 칥n stratul Rust de prim캒 instan탵캒 (este "
"doar un strat sub탵ire de lipire FFI) 탳i, prin urmare, utilizeaz캒 testele "
"unitare C++ existente pentru testarea at칙t a implement캒rii C++, c칙t 탳i a "
"implement캒rii Rust (parametriz칙nd testele astfel 칥nc칙t s캒 activeze sau s캒 "
"dezactiveze Rust utiliz칙nd o `ScopedFeatureList`)."

#: src/chromium/testing.md
#, fuzzy
msgid ""
"Hypothetical/WIP PNG integration may need to implement memory-safe "
"implementation of pixel transformations that are provided by `libpng` but "
"missing in the `png` crate - e.g. RGBA => BGRA, or gamma correction. Such "
"functionality may benefit from separate tests authored in Rust."
msgstr ""
"Integrarea PNG ipotetic캒/WIP ar putea avea nevoie s캒 implementeze o "
"implementare sigur캒 칥n memorie a transform캒rilor de pixeli care sunt "
"furnizate de `libpng`, dar care lipsesc din `png` crate - de exemplu RGBA => "
"BGRA, sau corec탵ia gamma. O astfel de func탵ionalitate ar putea beneficia de "
"teste separate realizate 칥n Rust."

#: src/chromium/testing/rust-gtest-interop.md
#, fuzzy
msgid ""
"The [`rust_gtest_interop`](https://chromium.googlesource.com/chromium/src/+/"
"main/testing/rust_gtest_interop/README.md) library provides a way to:"
msgstr ""
"Biblioteca [`rust_gtest_interop`](https://chromium.googlesource.com/chromium/"
"src/+/main/testing/rust_gtest_interop/README.md) ofer캒 o modalitate de a:"

#: src/chromium/testing/rust-gtest-interop.md
#, fuzzy
msgid ""
"Use a Rust function as a `gtest` testcase (using the `#[gtest(...)]` "
"attribute)"
msgstr ""
"Utiliza탵i o func탵ie Rust ca 탳i testcase `gtest` (folosind atributul "
"`#[gtest(...)]`)"

#: src/chromium/testing/rust-gtest-interop.md
#, fuzzy
msgid ""
"Use `expect_eq!` and similar macros (similar to `assert_eq!` but not "
"panicking and not terminating the test when the assertion fails)."
msgstr ""
"Utiliza탵i `expect_eq!` 탳i macrocomenzi similare (similar cu `assert_eq!`, "
"dar f캒r캒 a intra 칥n panic캒 탳i f캒r캒 a 칥ncheia testul atunci c칙nd afirma탵ia "
"e탳ueaz캒)."

#: src/chromium/testing/rust-gtest-interop.md
msgid "Example:"
msgstr "Exemplu:"

#: src/chromium/testing/build-gn.md
#, fuzzy
msgid ""
"The simplest way to build Rust `gtest` tests is to add them to an existing "
"test binary that already contains tests authored in C++. For example:"
msgstr ""
"Cel mai simplu mod de a construi teste Rust `gtest` este de a le ad캒uga la "
"un binar de testare existent care con탵ine deja teste scrise 칥n C++. De "
"exemplu:"

#: src/chromium/testing/build-gn.md
#, fuzzy
msgid ""
"```gn\n"
"test(\"ui_base_unittests\") {\n"
"  ...\n"
"  sources += [ \"my_rust_lib_unittest.rs\" ]\n"
"  deps += [ \":my_rust_lib\" ]\n"
"}\n"
"```"
msgstr ""
"```gn\n"
"test(\"ui_base_unittests\") {\n"
"  ...\n"
"  sources += [ \"my_rust_lib_unittest.rs\" ]\n"
"  deps += [ \":my_rust_lib\" ]\n"
"}\n"
"```"

#: src/chromium/testing/build-gn.md
#, fuzzy
msgid ""
"Authoring Rust tests in a separate `static_library` also works, but requires "
"manually declaring the dependency on the support libraries:"
msgstr ""
"Autorizarea testelor Rust 칥ntr-o `static_library` separat캒 func탵ioneaz캒, de "
"asemenea, dar necesit캒 declararea manual캒 a dependen탵ei de bibliotecile de "
"suport:"

#: src/chromium/testing/build-gn.md
#, fuzzy
msgid ""
"```gn\n"
"rust_static_library(\"my_rust_lib_unittests\") {\n"
"  testonly = true\n"
"  is_gtest_unittests = true\n"
"  crate_root = \"my_rust_lib_unittest.rs\"\n"
"  sources = [ \"my_rust_lib_unittest.rs\" ]\n"
"  deps = [\n"
"    \":my_rust_lib\",\n"
"    \"//testing/rust_gtest_interop\",\n"
"  ]\n"
"}\n"
"\n"
"test(\"ui_base_unittests\") {\n"
"  ...\n"
"  deps += [ \":my_rust_lib_unittests\" ]\n"
"}\n"
"```"
msgstr ""
"```gn\n"
"rust_static_library(\"my_rust_lib_unittests\") {\n"
"  testonly = true\n"
"  is_gtest_unittests = true\n"
"  crate_root = \"my_rust_lib_unittest.rs\"\n"
"  sources = [ \"my_rust_lib_unittest.rs\" ]\n"
"  deps = [\n"
"    \":my_rust_lib\",\n"
"    \"//testing/rust_gtest_interop\",\n"
"  ]\n"
"}\n"
"\n"
"test(\"ui_base_unittests\") {\n"
"  ...\n"
"  deps += [ \":my_rust_lib_unittests\" ]\n"
"}\n"
"```"

#: src/chromium/testing/chromium-import-macro.md
#, fuzzy
msgid ""
"After adding `:my_rust_lib` to GN `deps`, we still need to learn how to "
"import and use `my_rust_lib` from `my_rust_lib_unittest.rs`. We haven't "
"provided an explicit `crate_name` for `my_rust_lib` so its crate name is "
"computed based on the full target path and name. Fortunately we can avoid "
"working with such an unwieldy name by using the `chromium::import!` macro "
"from the automatically-imported `chromium` crate:"
msgstr ""
"Dup캒 ce am ad캒ugat `:my_rust_lib` la GN `deps`, mai trebuie s캒 칥nv캒탵캒m cum "
"s캒 import캒m 탳i s캒 folosim `my_rust_lib` din `my_rust_lib_unittest.rs`. Nu am "
"furnizat un `crate_name` explicit pentru `my_rust_lib`, astfel 칥nc칙t numele "
"s캒u de crate este calculat pe baza c캒ii 탳i a numelui complet al 탵intei. Din "
"fericire, putem evita s캒 lucr캒m cu un astfel de nume greoi folosind macroul "
"`chromium::import!` din crate-ul `chromium` importat automat:"

#: src/chromium/testing/chromium-import-macro.md
#, fuzzy
msgid "\"//ui/base:my_rust_lib\""
msgstr "\"//ui/base:my_rust_lib\""

#: src/chromium/testing/chromium-import-macro.md
#, fuzzy
msgid "Under the covers the macro expands to something similar to:"
msgstr "Sub acoperire, macroul se extinde la ceva similar cu:"

#: src/chromium/testing/chromium-import-macro.md
#, fuzzy
msgid ""
"More information can be found in [the doc comment](https://source.chromium."
"org/chromium/chromium/src/+/main:build/rust/chromium_prelude/"
"chromium_prelude.rs?q=f:chromium_prelude.rs%20pub.use.*%5Cbimport%5Cb;%20-f:"
"third_party&ss=chromium%2Fchromium%2Fsrc) of the `chromium::import` macro."
msgstr ""
"Mai multe informa탵ii pot fi g캒site 칥n [comentariul doc](https://source."
"chromium.org/chromium/chromium/src/+/main:build/rust/chromium_prelude/"
"chromium_prelude.rs?q=f:chromium_prelude.rs%20pub.use.*%5Cbimport%5Cb;%20-f:"
"third_party&ss=chromium%2Fchromium%2Fsrc) al macroului `chromium::import`."

#: src/chromium/testing/chromium-import-macro.md
#, fuzzy
msgid ""
"`rust_static_library` supports specifying an explicit name via `crate_name` "
"property, but doing this is discouraged. And it is discouraged because the "
"crate name has to be globally unique. crates.io guarantees uniqueness of its "
"crate names so `cargo_crate` GN targets (generated by the `gnrt` tool "
"covered in a later section) use short crate names."
msgstr ""
"`rust_static_library` accept캒 specificarea unui nume explicit prin "
"intermediul propriet캒탵ii `crate_name`, dar acest lucru este descurajat. 탲i "
"este descurajat캒 deoarece numele de lad캒 trebuie s캒 fie unic la nivel "
"global. crates.io garanteaz캒 unicitatea numelor de lad캒, astfel 칥nc칙t "
"탵intele GN `cargo_crate` (generate de instrumentul `gnrt`, abordat 칥ntr-o "
"sec탵iune ulterioar캒) utilizeaz캒 nume de lad캒 scurte."

#: src/exercises/chromium/testing.md
#, fuzzy
msgid "Testing exercise"
msgstr "exerci탵iu:"

#: src/exercises/chromium/testing.md
#, fuzzy
msgid "Time for another exercise!"
msgstr "E timpul pentru un alt exerci탵iu!"

#: src/exercises/chromium/testing.md
#, fuzzy
msgid "In your Chromium build:"
msgstr "칉n construc탵ia Chromium:"

#: src/exercises/chromium/testing.md
#, fuzzy
msgid ""
"Add a testable function next to `hello_from_rust`. Some suggestions: adding "
"two integers received as arguments, computing the nth Fibonacci number, "
"summing integers in a slice, etc."
msgstr ""
"Ad캒uga탵i o func탵ie testabil캒 l칙ng캒 `hello_from_rust`. C칙teva sugestii: "
"adunarea a dou캒 numere 칥ntregi primite ca argumente, calcularea celui de-al "
"n-lea num캒r Fibonacci, 칥nsumarea numerelor 칥ntregi dintr-o felie etc."

#: src/exercises/chromium/testing.md
#, fuzzy
msgid "Add a separate `..._unittest.rs` file with a test for the new function."
msgstr ""
"Ad캒uga탵i un fi탳ier separat `..._unittest.rs` cu un test pentru noua func탵ie."

#: src/exercises/chromium/testing.md
#, fuzzy
msgid "Add the new tests to `BUILD.gn`."
msgstr "Ad캒uga탵i noile teste la `BUILD.gn`."

#: src/exercises/chromium/testing.md
#, fuzzy
msgid "Build the tests, run them, and verify that the new test works."
msgstr ""
"Construi탵i testele, rula탵i-le 탳i verifica탵i dac캒 noul test func탵ioneaz캒."

#: src/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"The Rust community offers multiple options for C++/Rust interop, with new "
"tools being developed all the time. At the moment, Chromium uses a tool "
"called CXX."
msgstr ""
"Comunitatea Rust ofer캒 mai multe op탵iuni pentru interopulare C++/Rust, noi "
"instrumente fiind dezvoltate 칥n permanen탵캒. 칉n prezent, Chromium utilizeaz캒 "
"un instrument numit CXX."

#: src/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"You describe your whole language boundary in an interface definition "
"language (which looks a lot like Rust) and then CXX tools generate "
"declarations for functions and types in both Rust and C++."
msgstr ""
"Descrie탵i 칥ntreaga grani탵캒 a limbajului 칥ntr-un limbaj de definire a "
"interfe탵elor (care seam캒n캒 foarte mult cu Rust) 탳i apoi instrumentele CXX "
"genereaz캒 declara탵ii pentru func탵ii 탳i tipuri at칙t 칥n Rust, c칙t 탳i 칥n C++."

#: src/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"See the [CXX tutorial](https://cxx.rs/tutorial.html) for a full example of "
"using this."
msgstr ""
"Consulta탵i [CXX tutorial](https://cxx.rs/tutorial.html) pentru un exemplu "
"complet de utilizare."

#: src/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"Talk through the diagram. Explain that behind the scenes, this is doing just "
"the same as you previously did. Point out that automating the process has "
"the following benefits:"
msgstr ""
"Vorbi탵i despre diagram캒. Explica탵i c캒, 칥n spatele scenei, aceasta face exact "
"ceea ce a탵i f캒cut anterior. Preciza탵i c캒 automatizarea procesului are "
"urm캒toarele avantaje:"

#: src/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"The tool guarantees that the C++ and Rust sides match (e.g. you get compile "
"errors if the `#[cxx::bridge]` doesn't match the actual C++ or Rust "
"definitions, but with out-of-sync manual bindings you'd get Undefined "
"Behavior)"
msgstr ""
"Instrumentul garanteaz캒 c캒 p캒r탵ile C++ 탳i Rust se potrivesc (de exemplu, "
"ve탵i ob탵ine erori de compilare dac캒 `#[cxx::bridge]` nu se potrive탳te cu "
"defini탵iile reale C++ sau Rust, dar cu leg캒turi manuale nesincronizate ve탵i "
"ob탵ine Comportament nedefinit)"

#: src/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"The tool automates generation of FFI thunks (small, C-ABI-compatible, free "
"functions) for non-C features (e.g. enabling FFI calls into Rust or C++ "
"methods; manual bindings would require authoring such top-level, free "
"functions manually)"
msgstr ""
"Instrumentul automatizeaz캒 generarea de thunks FFI (func탵ii libere mici, "
"compatibile cu C-ABI) pentru caracteristicile non-C (de exemplu, activarea "
"apelurilor FFI 칥n metodele Rust sau C++; leg캒turile manuale ar necesita "
"crearea manual캒 a unor astfel de func탵ii libere de nivel superior)"

#: src/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "The tool and the library can handle a set of core types - for example:"
msgstr ""
"Instrumentul 탳i biblioteca pot gestiona un set de tipuri de baz캒 - de "
"exemplu:"

#: src/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"`&[T]` can be passed across the FFI boundary, even though it doesn't "
"guarantee any particular ABI or memory layout. With manual bindings `std::"
"span<T>` / `&[T]` have to be manually destructured and rebuilt out of a "
"pointer and length - this is error-prone given that each language represents "
"empty slices slightly differently)"
msgstr ""
"`&amp;[T]` poate fi trecut peste grani탵a FFI, chiar dac캒 nu garanteaz캒 o "
"anumit캒 ABI sau o anumit캒 dispunere a memoriei. 칉n cazul leg캒turilor "
"manuale, `std::span<T>` / `&amp;[T]` trebuie s캒 fie destructurate 탳i "
"reconstruite manual dintr-un pointer 탳i o lungime - acest lucru este "
"predispus la erori, av칙nd 칥n vedere c캒 fiecare limbaj reprezint캒 feliile "
"goale 칥n mod u탳or diferit)"

#: src/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"Smart pointers like `std::unique_ptr<T>`, `std::shared_ptr<T>`, and/or `Box` "
"are natively supported. With manual bindings, one would have to pass C-ABI-"
"compatible raw pointers, which would increase lifetime and memory-safety "
"risks."
msgstr ""
"Indicatorii inteligen탵i, cum ar fi `std::unique_ptr<T>`, `std::"
"shared_ptr<T>` 탳i/sau `Box`, sunt suporta탵i nativ. 칉n cazul leg캒turilor "
"manuale, ar trebui s캒 se treac캒 pointeri brute compatibile cu C-ABI, ceea ce "
"ar cre탳te riscurile legate de durata de via탵캒 탳i siguran탵a memoriei."

#: src/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"`rust::String` and `CxxString` types understand and maintain differences in "
"string representation across the languages (e.g. `rust::String::lossy` can "
"build a Rust string from non-UTF8 input and `rust::String::c_str` can NUL-"
"terminate a string)."
msgstr ""
"tipurile `rust::String` 탳i `CxxString` 칥n탵eleg 탳i men탵in diferen탵ele de "
"reprezentare a 탳irurilor de caractere 칥ntre limbaje (de exemplu, `rust::"
"String::lossy` poate construi un 탳ir Rust de la o intrare non-UTF8 탳i `rust::"
"String::c_str` poate termina un 탳ir cu NUL)."

#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid ""
"CXX requires that the whole C++/Rust boundary is declared in `cxx::bridge` "
"modules inside `.rs` source code."
msgstr ""
"CXX cere ca 칥ntreaga grani탵캒 C++/Rust s캒 fie declarat캒 칥n modulele `cxx::"
"bridge` din codul surs캒 `.rs`."

#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid "\"example/include/blobstore.h\""
msgstr "\"example/include/blobstore.h\""

#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid "// Definitions of Rust types and functions go here\n"
msgstr "// Defini탵iile tipurilor 탳i func탵iilor Rust merg aici\n"

#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid "Point out:"
msgstr ""
"A탵i putea indica modul 칥n care sunt folosite anumite caractere specifice "
"atunci c칙nd se afl캒 칥ntr-un 탳ablon"

#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid ""
"Although this looks like a regular Rust `mod`, the `#[cxx::bridge]` "
"procedural macro does complex things to it. The generated code is quite a "
"bit more sophisticated - though this does still result in a `mod` called "
"`ffi` in your code."
msgstr ""
"De탳i acesta arat캒 ca un `mod` obi탳nuit din Rust, macroul procedural `#[cxx::"
"bridge]` 칥i face lucruri complexe. Codul generat este mult mai sofisticat - "
"de탳i acest lucru are ca rezultat un `mod` numit `ffi` 칥n codul dumneavoastr캒."

#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid "Native support for C++'s `std::unique_ptr` in Rust"
msgstr "Suport nativ pentru `std::unique_ptr` din C++ 칥n Rust"

#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid "Native support for Rust slices in C++"
msgstr "Suport pentru testare 칥ncorporat."

#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid "Calls from C++ to Rust, and Rust types (in the top part)"
msgstr "Apeluri din C++ 칥n Rust 탳i tipuri Rust (칥n partea de sus)"

#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid "Calls from Rust to C++, and C++ types (in the bottom part)"
msgstr "Apeluri din Rust 칥n C++ 탳i tipuri C++ (칥n partea de jos)"

#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid ""
"**Common misconception**: It _looks_ like a C++ header is being parsed by "
"Rust, but this is misleading. This header is never interpreted by Rust, but "
"simply `#include`d in the generated C++ code for the benefit of C++ "
"compilers."
msgstr ""
"**Incon탳tien탵캒 gre탳it캒 frecvent캒**: Se pare c캒 un antet C++ este analizat de "
"Rust, dar acest lucru este 칥n탳el캒tor. Acest antet nu este niciodat캒 "
"interpretat de Rust, ci este pur 탳i simplu `#inclus` 칥n codul C++ generat 칥n "
"beneficiul compilatoarelor C++."

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
#, fuzzy
msgid ""
"By far the most useful page when using CXX is the [type reference](https://"
"cxx.rs/bindings.html)."
msgstr ""
"Ar캒ta탵i coresponden탵a dintre [tipurile Rust 탳i C++](https://cxx.rs/bindings."
"html):"

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
#, fuzzy
msgid "CXX fundamentally suits cases where:"
msgstr "CXX se potrive탳te 칥n mod fundamental cazurilor 칥n care:"

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
#, fuzzy
msgid ""
"Your Rust-C++ interface is sufficiently simple that you can declare all of "
"it."
msgstr ""
"Interfa탵a Rust-C++ este suficient de simpl캒 pentru a o putea declara 칥n "
"칥ntregime."

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
#, fuzzy
msgid ""
"You're using only the types natively supported by CXX already, for example "
"`std::unique_ptr`, `std::string`, `&[u8]` etc."
msgstr ""
"Folosi탵i doar tipurile suportate nativ de CXX, de exemplu `std::unique_ptr`, "
"`std::string`, `&[u8]` etc."

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
#, fuzzy
msgid ""
"It has many limitations --- for example lack of support for Rust's `Option` "
"type."
msgstr ""
"Are multe limit캒ri --- de exemplu, lipsa de suport pentru tipul `Option` din "
"Rust."

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
#, fuzzy
msgid ""
"These limitations constrain us to using Rust in Chromium only for well "
"isolated \"leaf nodes\" rather than for arbitrary Rust-C++ interop. When "
"considering a use-case for Rust in Chromium, a good starting point is to "
"draft the CXX bindings for the language boundary to see if it appears simple "
"enough."
msgstr ""
"Aceste limit캒ri ne constr칙ng s캒 folosim Rust 칥n Chromium doar pentru "
"\"noduri de frunze\" bine izolate, mai degrab캒 dec칙t pentru o interfa탵캒 Rust-"
"C++ arbitrar캒. Atunci c칙nd se ia 칥n considerare un caz de utilizare pentru "
"Rust 칥n Chromium, un bun punct de plecare este s캒 se redacteze leg캒turile "
"CXX pentru limita limbajului pentru a vedea dac캒 pare suficient de simplu."

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
#, fuzzy
msgid ""
"You should also discuss some of the other sticky points with CXX, for "
"example:"
msgstr ""
"De asemenea, ar trebui s캒 discuta탵i cu CXX despre alte puncte sensibile, de "
"exemplu:"

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
#, fuzzy
msgid ""
"Its error handling is based around C++ exceptions (given on the next slide)"
msgstr ""
"Gestionarea erorilor se bazeaz캒 pe excep탵iile C++ (prezentate 칥n slide-ul "
"urm캒tor)"

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
#, fuzzy
msgid "Function pointers are awkward to use."
msgstr "Indicatorii de func탵ie sunt greu de utilizat."

#: src/chromium/interoperability-with-cpp/error-handling.md
#, fuzzy
msgid ""
"CXX's [support for `Result<T,E>`](https://cxx.rs/binding/result.html) relies "
"on C++ exceptions, so we can't use that in Chromium. Alternatives:"
msgstr ""
"CXX [suportul pentru `Result<T,E>`](https://cxx.rs/binding/result.html) se "
"bazeaz캒 pe excep탵iile C++, a탳a c캒 nu 칥l putem folosi 칥n Chromium. "
"Alternative:"

#: src/chromium/interoperability-with-cpp/error-handling.md
#, fuzzy
msgid "The `T` part of `Result<T, E>` can be:"
msgstr "Partea `T` din `Result<T, E>` poate fi:"

#: src/chromium/interoperability-with-cpp/error-handling.md
#, fuzzy
msgid ""
"Returned via out parameters (e.g. via `&mut T`). This requires that `T` can "
"be passed across the FFI boundary - for example `T` has to be:"
msgstr ""
"Se returneaz캒 prin intermediul parametrilor de ie탳ire (de exemplu, prin "
"`&mut T`). Acest lucru necesit캒 ca `T` s캒 poat캒 fi transmis peste grani탵a "
"FFI - de exemplu, `T` trebuie s캒 fie:"

#: src/chromium/interoperability-with-cpp/error-handling.md
#, fuzzy
msgid "A primitive type (like `u32` or `usize`)"
msgstr "Un tip primitiv (cum ar fi `u32` sau `usize`)"

#: src/chromium/interoperability-with-cpp/error-handling.md
#, fuzzy
msgid ""
"A type natively supported by `cxx` (like `UniquePtr<T>`) that has a suitable "
"default value to use in a failure case (_unlike_ `Box<T>`)."
msgstr ""
"Un tip suportat nativ de `cxx` (precum `UniquePtr<T>`) care are o valoare "
"implicit캒 adecvat캒 pentru a fi utilizat캒 칥n caz de e탳ec (spre deosebire de "
"`Box<T>`)."

#: src/chromium/interoperability-with-cpp/error-handling.md
#, fuzzy
msgid ""
"Retained on the Rust side, and exposed via reference. This may be needed "
"when `T` is a Rust type, which cannot be passed across the FFI boundary, and "
"cannot be stored in `UniquePtr<T>`."
msgstr ""
"Re탵inut캒 pe partea de rugin캒 탳i expus캒 prin referin탵캒. Acest lucru poate fi "
"necesar atunci c칙nd `T` este un tip Rust, care nu poate fi trecut peste "
"grani탵a FFI 탳i nu poate fi stocat 칥n `UniquePtr<T>`."

#: src/chromium/interoperability-with-cpp/error-handling.md
#, fuzzy
msgid "The `E` part of `Result<T, E>` can be:"
msgstr "Partea `E` din `Result<T, E>` poate fi:"

#: src/chromium/interoperability-with-cpp/error-handling.md
#, fuzzy
msgid ""
"Returned as a boolean (e.g. `true` representing success, and `false` "
"representing failure)"
msgstr ""
"Se returneaz캒 sub form캒 de boolean (de exemplu, `true` reprezint캒 succesul, "
"iar `false` reprezint캒 e탳ecul)"

#: src/chromium/interoperability-with-cpp/error-handling.md
#, fuzzy
msgid ""
"Preserving error details is in theory possible, but so far hasn't been "
"needed in practice."
msgstr ""
"P캒strarea detaliilor privind erorile este teoretic posibil캒, dar p칙n캒 칥n "
"prezent nu a fost necesar캒 칥n practic캒."

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
#, fuzzy
msgid "CXX Error Handling: QR Example"
msgstr "Gestionarea erorilor"

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
#, fuzzy
msgid ""
"The QR code generator is [an example](https://source.chromium.org/chromium/"
"chromium/src/+/main:components/qr_code_generator/qr_code_generator_ffi_glue."
"rs;l=13-18;drc=7bf1b75b910ca430501b9c6a74c1d18a0223ecca) where a boolean is "
"used to communicate success vs failure, and where the successful result can "
"be passed across the FFI boundary:"
msgstr ""
"Generatorul de coduri QR este [un exemplu](https://source.chromium.org/"
"chromium/chromium/src/+/main:components/qr_code_generator/"
"qr_code_generator_ffi_glue.rs;l=13-18;"
"drc=7bf1bb75b910ca430501b9c6a74c1d18a0223ecca) 칥n care se utilizeaz캒 un "
"boolean pentru a comunica succesul vs. e탳ecul 탳i 칥n care rezultatul de "
"succes poate fi transmis peste grani탵a FFI:"

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
#, fuzzy
msgid "\"qr_code_generator\""
msgstr "\"qr_code_generator\""

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
#, fuzzy
msgid ""
"Students may be curious about the semantics of the `out_qr_size` output. "
"This is not the size of the vector, but the size of the QR code (and "
"admittedly it is a bit redundant - this is the square root of the size of "
"the vector)."
msgstr ""
"Elevii pot fi curio탳i 칥n leg캒tur캒 cu semantica ie탳irii `out_qr_size`. "
"Aceasta nu este dimensiunea vectorului, ci dimensiunea codului QR (탳i, "
"trebuie s캒 recunoa탳tem, este un pic redundant캒 - este r캒d캒cina p캒trat캒 a "
"dimensiunii vectorului)."

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
#, fuzzy
msgid ""
"It may be worth pointing out the importance of initializing `out_qr_size` "
"before calling into the Rust function. Creation of a Rust reference that "
"points to uninitialized memory results in Undefined Behavior (unlike in C++, "
"when only the act of dereferencing such memory results in UB)."
msgstr ""
"Ar putea fi util s캒 subliniem importan탵a ini탵ializ캒rii `out_qr_size` 칥nainte "
"de a apela la func탵ia Rust. Crearea unei referin탵e Rust care indic캒 o "
"memorie neini탵ializat캒 are ca rezultat un comportament nedefinit (spre "
"deosebire de C++, c칙nd numai actul de dereferen탵iere a unei astfel de "
"memorii are ca rezultat UB)."

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
#, fuzzy
msgid ""
"If students ask about `Pin`, then explain why CXX needs it for mutable "
"references to C++ data: the answer is that C++ data can't be moved around "
"like Rust data, because it may contain self-referential pointers."
msgstr ""
"Dac캒 elevii 칥ntreab캒 despre `Pin`, explica탵i-le de ce CXX are nevoie de el "
"pentru referin탵ele mutabile la datele C++: r캒spunsul este c캒 datele C++ nu "
"pot fi mutate ca 탳i datele Rust, deoarece pot con탵ine pointeri "
"autoreferen탵iali."

#: src/chromium/interoperability-with-cpp/error-handling-png.md
#, fuzzy
msgid "CXX Error Handling: PNG Example"
msgstr "Gestionarea erorilor"

#: src/chromium/interoperability-with-cpp/error-handling-png.md
#, fuzzy
msgid ""
"A prototype of a PNG decoder illustrates what can be done when the "
"successful result cannot be passed across the FFI boundary:"
msgstr ""
"Un prototip al unui decodor PNG ilustreaz캒 ce se poate face atunci c칙nd "
"rezultatul pozitiv nu poate fi transmis peste grani탵a FFI:"

#: src/chromium/interoperability-with-cpp/error-handling-png.md
#, fuzzy
msgid "\"gfx::rust_bindings\""
msgstr "\"gfx::rust_bindings\""

#: src/chromium/interoperability-with-cpp/error-handling-png.md
#, fuzzy
msgid ""
"/// This returns an FFI-friendly equivalent of `Result<PngReader<'a>,\n"
"        /// ()>`.\n"
msgstr ""
"/// Aceasta returneaz캒 un echivalent FFI-friendly al `Result<PngReader<'a>,\n"
"        /// ()>`.\n"

#: src/chromium/interoperability-with-cpp/error-handling-png.md
#, fuzzy
msgid "/// C++ bindings for the `crate::png::ResultOfPngReader` type.\n"
msgstr "/// Leg캒turi C++ pentru tipul `crate::png::ResultOfPngReader`.\n"

#: src/chromium/interoperability-with-cpp/error-handling-png.md
#, fuzzy
msgid "/// C++ bindings for the `crate::png::PngReader` type.\n"
msgstr "/// Leg캒turi C++ pentru tipul `crate::png::PngReader`.\n"

#: src/chromium/interoperability-with-cpp/error-handling-png.md
#, fuzzy
msgid ""
"`PngReader` and `ResultOfPngReader` are Rust types --- objects of these "
"types cannot cross the FFI boundary without indirection of a `Box<T>`. We "
"can't have an `out_parameter: &mut PngReader`, because CXX doesn't allow C++ "
"to store Rust objects by value."
msgstr ""
"`PngReader` 탳i `ResultOfPngReader` sunt tipuri Rust --- obiectele din aceste "
"tipuri nu pot trece grani탵a FFI f캒r캒 o indirec탵iune a unui `Box<T>`. Nu "
"putem avea un `out_parameter: &amp;mut PngReader`, deoarece CXX nu permite "
"ca C++ s캒 stocheze obiecte Rust prin valoare."

#: src/chromium/interoperability-with-cpp/error-handling-png.md
#, fuzzy
msgid ""
"This example illustrates that even though CXX doesn't support arbitrary "
"generics nor templates, we can still pass them across the FFI boundary by "
"manually specializing / monomorphizing them into a non-generic type. In the "
"example `ResultOfPngReader` is a non-generic type that forwards into "
"appropriate methods of `Result<T, E>` (e.g. into `is_err`, `unwrap`, and/or "
"`as_mut`)."
msgstr ""
"Acest exemplu ilustreaz캒 faptul c캒, chiar dac캒 CXX nu accept캒 generici "
"arbitrari 탳i nici 탳abloane, putem totu탳i s캒 le trecem peste grani탵a FFI prin "
"specializarea / monomorfizarea manual캒 칥ntr-un tip non-generic. 칉n exemplu, "
"`ResultOfPngReader` este un tip ne-generic care se transmite 칥n metodele "
"corespunz캒toare ale `Result<T, E>` (de exemplu, 칥n `is_err`, `unwrap` 탳i/sau "
"`as_mut`)."

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
#, fuzzy
msgid "Using cxx in Chromium"
msgstr "Utilizarea CXX 칥n Chromium"

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
#, fuzzy
msgid ""
"In Chromium, we define an independent `#[cxx::bridge] mod` for each leaf-"
"node where we want to use Rust. You'd typically have one for each "
"`rust_static_library`. Just add"
msgstr ""
"칉n Chromium, definim un `#[cxx::bridge] mod` independent pentru fiecare nod "
"frunz캒 칥n care dorim s캒 folosim Rust. De obicei, ve탵i avea unul pentru "
"fiecare `rust_static_library`. Trebuie doar s캒 ad캒uga탵i"

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
#, fuzzy
msgid ""
"```gn\n"
"cxx_bindings = [ \"my_rust_file.rs\" ]\n"
"   # list of files containing #[cxx::bridge], not all source files\n"
"allow_unsafe = true\n"
"```"
msgstr ""
"```gn\n"
"cxx_bindings = [ \"my_rust_file.rs\" ]\n"
"   # list캒 de fi탳iere care con탵in #[cxx::bridge], nu toate fi탳ierele surs캒\n"
"allow_unsafe = true\n"
"```"

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
#, fuzzy
msgid ""
"to your existing `rust_static_library` target alongside `crate_root` and "
"`sources`."
msgstr ""
"la 탵inta `rust_static_library` existent캒, al캒turi de `crate_root` 탳i "
"`sources`."

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
#, fuzzy
msgid "C++ headers will be generated at a sensible location, so you can just"
msgstr ""
"Anteturile C++ vor fi generate 칥ntr-o loca탵ie sensibil캒, astfel 칥nc칙t pute탵i "
"doar s캒"

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
#, fuzzy
msgid "\"ui/base/my_rust_file.rs.h\""
msgstr "\"ui/base/my_rust_file.rs.h\""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
#, fuzzy
msgid ""
"You will find some utility functions in `//base` to convert to/from Chromium "
"C++ types to CXX Rust types --- for example [`SpanToRustSlice`](https://"
"source.chromium.org/chromium/chromium/src/+/main:base/containers/span_rust.h;"
"l=21)."
msgstr ""
"Ve탵i g캒si c칙teva func탵ii utilitare 칥n `//base` pentru a converti la/de la "
"tipurile Chromium C++ la tipurile CXX Rust --- de exemplu [`SpanToRustSlice`]"
"(https://source.chromium.org/chromium/chromium/src/+/main:base/containers/"
"span_rust.h;l=21)."

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
#, fuzzy
msgid "Students may ask --- why do we still need `allow_unsafe = true`?"
msgstr ""
"Studen탵ii se pot 칥ntreba --- de ce mai avem nevoie de `allow_unsafe = true`?"

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
#, fuzzy
msgid ""
"The broad answer is that no C/C++ code is \"safe\" by the normal Rust "
"standards. Calling back and forth to C/C++ from Rust may do arbitrary things "
"to memory, and compromise the safety of Rust's own data layouts. Presence of "
"_too many_ `unsafe` keywords in C/C++ interop can harm the signal-to-noise "
"ratio of such a keyword, and is [controversial](https://steveklabnik.com/"
"writing/the-cxx-debate), but strictly, bringing any foreign code into a Rust "
"binary can cause unexpected behavior from Rust's perspective."
msgstr ""
"R캒spunsul general este c캒 nici un cod C/C++ nu este \"sigur\" dup캒 "
"standardele Rust obi탳nuite. Apelarea din Rust c캒tre C/C++ poate face lucruri "
"arbitrare 칥n memorie 탳i poate compromite siguran탵a propriilor aranjamente de "
"date din Rust. Prezen탵a a _prea multor_ cuvinte cheie `unsafe` 칥n interop C/"
"C++ poate d캒una raportului semnal-zgomot al unui astfel de cuv칙nt cheie 탳i "
"este [controversat캒](https://steveklabnik.com/writing/the-cxx-debate), dar, "
"strict, aducerea oric캒rui cod str캒in 칥ntr-un binar Rust poate cauza un "
"comportament nea탳teptat din perspectiva Rust."

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
#, fuzzy
msgid ""
"The narrow answer lies in the diagram at the top of [this page](../"
"interoperability-with-cpp.md) --- behind the scenes, CXX generates Rust "
"`unsafe` and `extern \"C\"` functions just like we did manually in the "
"previous section."
msgstr ""
"R캒spunsul restr칙ns se afl캒 칥n diagrama din partea de sus a [acestei pagini]"
"(../interoperabilitate-cu-cpp.md) --- 칥n spatele scenei, CXX genereaz캒 "
"func탵ii Rust `unsafe` 탳i `extern \"C\"` exact a탳a cum am f캒cut manual 칥n "
"sec탵iunea anterioar캒."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Exercise: Interoperability with C++"
msgstr "Interoperabilitate cu C"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Part one"
msgstr "Prima parte"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"In the Rust file you previously created, add a `#[cxx::bridge]` which "
"specifies a single function, to be called from C++, called "
"`hello_from_rust`, taking no parameters and returning no value."
msgstr ""
"칉n fi탳ierul Rust pe care l-a탵i creat anterior, ad캒uga탵i un `#[cxx::bridge]` "
"care specific캒 o singur캒 func탵ie, care va fi apelat캒 din C++, numit캒 "
"`hello_from_rust`, care nu prime탳te parametri 탳i nu returneaz캒 nicio valoare."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"Modify your previous `hello_from_rust` function to remove `extern \"C\"` and "
"`#[no_mangle]`. This is now just a standard Rust function."
msgstr ""
"Modifica탵i func탵ia `hello_from_rust` anterioar캒 pentru a elimina `extern "
"\"C\"` 탳i `#[no_mangle]`. Aceasta este acum doar o func탵ie Rust standard."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Modify your `gn` target to build these bindings."
msgstr "Modifica탵i 탵inta `gn` pentru a construi aceste leg캒turi."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"In your C++ code, remove the forward-declaration of `hello_from_rust`. "
"Instead, include the generated header file."
msgstr ""
"칉n codul dvs. C++, elimina탵i declara탵ia forward a lui `hello_from_rust`. 칉n "
"schimb, include탵i fi탳ierul antet generat."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Build and run!"
msgstr "Construie탳te 탳i ruleaz캒!"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Part two"
msgstr "Partea a doua"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"It's a good idea to play with CXX a little. It helps you think about how "
"flexible Rust in Chromium actually is."
msgstr ""
"Este o idee bun캒 s캒 v캒 juca탵i pu탵in cu CXX. V캒 ajut캒 s캒 v캒 g칙ndi탵i la c칙t de "
"flexibil este de fapt Rust 칥n Chromium."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Some things to try:"
msgstr "C칙teva note:"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Call back into C++ from Rust. You will need:"
msgstr "Apelarea 칥napoi 칥n C++ din Rust. Ve탵i avea nevoie de:"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"An additional header file which you can `include!` from your `cxx::bridge`. "
"You'll need to declare your C++ function in that new header file."
msgstr ""
"Un fi탳ier header suplimentar pe care 칥l pute탵i `include!` din `cxx::bridge`. "
"Va trebui s캒 v캒 declara탵i func탵ia C++ 칥n acest nou fi탳ier de antet."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"An `unsafe` block to call such a function, or alternatively specify the "
"`unsafe` keyword in your `#[cxx::bridge]` [as described here](https://cxx.rs/"
"extern-c++.html#functions-and-member-functions)."
msgstr ""
"Un bloc `unsafe` pentru a apela o astfel de func탵ie sau, alternativ, "
"specifica탵i cuv칙ntul cheie `unsafe` 칥n `#[cxx::bridge]` [a탳a cum este "
"descris aici](https://cxx.rs/extern-c++.html#functions-and-member-functions)."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"You may also need to `#include \"third_party/rust/cxx/v1/crate/include/cxx."
"h\"`"
msgstr ""
"Este posibil s캒 ave탵i nevoie 탳i de `#include \"third_party/rust/cxx/v1/crate/"
"include/cxx.h\"``"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Pass a C++ string from C++ into Rust."
msgstr "Trece탵i un 탳ir C++ din C++ 칥n Rust."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Pass a reference to a C++ object into Rust."
msgstr "Trece탵i o referin탵캒 la un obiect C++ 칥n Rust."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"Intentionally get the Rust function signatures mismatched from the `#[cxx::"
"bridge]`, and get used to the errors you see."
msgstr ""
"Ob탵ine탵i 칥n mod inten탵ionat semn캒turile func탵iilor Rust nepotrivite din "
"`#[cxx::bridge]` 탳i obi탳nui탵i-v캒 cu erorile pe care le vede탵i."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"Intentionally get the C++ function signatures mismatched from the `#[cxx::"
"bridge]`, and get used to the errors you see."
msgstr ""
"Ob탵ine탵i 칥n mod inten탵ionat semn캒turile func탵iilor C++ nepotrivite din "
"`#[cxx::bridge]` 탳i obi탳nui탵i-v캒 cu erorile pe care le vede탵i."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"Pass a `std::unique_ptr` of some type from C++ into Rust, so that Rust can "
"own some C++ object."
msgstr ""
"Trece탵i un `std::unique_ptr` de un anumit tip din C++ 칥n Rust, astfel 칥nc칙t "
"Rust s캒 poat캒 de탵ine un obiect C++."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"Create a Rust object and pass it into C++, so that C++ owns it. (Hint: you "
"need a `Box`)."
msgstr ""
"Crea탵i un obiect Rust 탳i trece탵i-l 칥n C++, astfel 칥nc칙t C++ s캒 칥l de탵in캒. "
"(Indica탵ie: ave탵i nevoie de un `Box`)."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Declare some methods on a C++ type. Call them from Rust."
msgstr "Declararea unor metode pentru un tip C++. Apela탵i-le din Rust."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Declare some methods on a Rust type. Call them from C++."
msgstr "Declararea unor metode pentru un tip Rust. Apela탵i-le din C++."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Part three"
msgstr "Partea a treia"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"Now you understand the strengths and limitations of CXX interop, think of a "
"couple of use-cases for Rust in Chromium where the interface would be "
"sufficiently simple. Sketch how you might define that interface."
msgstr ""
"Acum c캒 a탵i 칥n탵eles punctele forte 탳i limit캒rile interoper캒rii CXX, g칙ndi탵i-"
"v캒 la c칙teva cazuri de utilizare pentru Rust 칥n Chromium 칥n care interfa탵a "
"ar fi suficient de simpl캒. Schi탵a탵i cum a탵i putea defini aceast캒 interfa탵캒."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "The [`cxx` binding reference](https://cxx.rs/bindings.html)"
msgstr ""
"Ar캒ta탵i coresponden탵a dintre [tipurile Rust 탳i C++](https://cxx.rs/bindings."
"html):"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"The [`rust_static_library` gn template](https://source.chromium.org/chromium/"
"chromium/src/+/main:build/rust/rust_static_library.gni;l=16)"
msgstr ""
"탲ablonul [`rust_static_library` gn](https://source.chromium.org/chromium/"
"chromium/src/+/main:build/rust/rust/rust_static_library.gni;l=16)"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Some of the questions you may encounter:"
msgstr "C칙teva dintre 칥ntreb캒rile pe care le pute탵i 칥nt칙lni:"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"I'm seeing a problem initializing a variable of type X with type Y, where X "
"and Y are both function types. This is because your C++ function doesn't "
"quite match the declaration in your `cxx::bridge`."
msgstr ""
"Am o problem캒 칥n ceea ce prive탳te ini탵ializarea unei variabile de tip X cu "
"tipul Y, unde X 탳i Y sunt ambele tipuri de func탵ii. Acest lucru se datoreaz캒 "
"faptului c캒 func탵ia dvs. C++ nu se potrive탳te cu declara탵ia din `cxx::"
"bridge`."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"I seem to be able to freely convert C++ references into Rust references. "
"Doesn't that risk UB? For CXX's _opaque_ types, no, because they are zero-"
"sized. For CXX trivial types yes, it's _possible_ to cause UB, although "
"CXX's design makes it quite difficult to craft such an example."
msgstr ""
"Se pare c캒 pot converti 칥n mod liber referin탵ele C++ 칥n referin탵e Rust. Nu "
"risc캒 asta UB? 칉n cazul tipurilor _opaque_ din CXX, nu, deoarece acestea "
"sunt de dimensiune zero. Pentru tipurile triviale din CXX, da, este "
"_posibil_ s캒 provoace UB, de탳i designul CXX face destul de dificil캒 crearea "
"unui astfel de exemplu."

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid ""
"Rust libraries are called \"crates\" and are found at [crates.io](https://"
"crates.io). It's _very easy_ for Rust crates to depend upon one another. So "
"they do!"
msgstr ""
"Bibliotecile Rust se numesc \"crates\" 탳i se g캒sesc la [crates.io](https://"
"crates.io). Este _foarte u탳or_ pentru crates Rust s캒 depind캒 unele de "
"altele. A탳a c캒 o fac!"

#: src/chromium/adding-third-party-crates.md
msgid "Property"
msgstr "Proprietate"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "C++ library"
msgstr "bibliotec캒:"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "Rust crate"
msgstr "Ecosistemul Rust"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "Build system"
msgstr ""
"Ve탵i avea nevoie de un [sursele AOSP](https://source.android.com/docs/setup/"
"download/downloading). Efectua탵i o desc캒rcare a [resurselor cursului]"
"(https://github.com/google/comprehensive-rust) pe aceea탳i ma탳in캒 탳i muta탵i "
"directorul `src/android/` 칥n r캒d캒cina surselor AOSP. Acest lucru va asigura "
"c캒 sistemul de compilare Android vede fi탳ierele `Android.bp` din `src/"
"android/`."

#: src/chromium/adding-third-party-crates.md
msgid "Lots"
msgstr "Multe"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "Consistent: `Cargo.toml`"
msgstr "Pute탵i utiliza urm캒torul `Cargo.toml`:"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "Typical library size"
msgstr "Dimensiunea tipic캒 a bibliotecii"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "Large-ish"
msgstr "Mare-ish"

#: src/chromium/adding-third-party-crates.md
msgid "Small"
msgstr "Mic"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "Transitive dependencies"
msgstr "Dependen탵e tranzitive"

#: src/chromium/adding-third-party-crates.md
msgid "Few"
msgstr "Iat캒 c칙teva link-uri utile pentru a ob탵ine ajutor pe parcurs"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "For a Chromium engineer, this has pros and cons:"
msgstr "Pentru un inginer Chromium, acest lucru are avantaje 탳i dezavantaje:"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid ""
"All crates use a common build system so we can automate their inclusion into "
"Chromium..."
msgstr ""
"Toate craterele folosesc un sistem comun de construire, astfel 칥nc칙t s캒 "
"putem automatiza includerea lor 칥n Chromium..."

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid ""
"... but, crates typically have transitive dependencies, so you will likely "
"have to bring in multiple libraries."
msgstr ""
"... dar, de obicei, crates are dependen탵e tranzitive, a탳a c캒 va trebui "
"probabil s캒 introduce탵i mai multe biblioteci."

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "We'll discuss:"
msgstr "Vom discuta:"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "How to put a crate in the Chromium source code tree"
msgstr "Cum se pune o caset캒 칥n arborele de cod surs캒 Chromium"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "How to make `gn` build rules for it"
msgstr "Cum s캒 faci regulile de construc탵ie `gn` pentru el"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "How to audit its source code for sufficient safety."
msgstr "Cum se auditeaz캒 codul surs캒 pentru a asigura o siguran탵캒 suficient캒."

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
#, fuzzy
msgid "Configuring the `Cargo.toml` file to add crates"
msgstr "Configurarea fi탳ierului `Cargo.toml` pentru a ad캒uga l캒zi"

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
#, fuzzy
msgid ""
"Chromium has a single set of centrally-managed direct crate dependencies. "
"These are managed through a single [`Cargo.toml`](https://source.chromium."
"org/chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/Cargo."
"toml):"
msgstr ""
"Chromium are un singur set de dependen탵e directe de crate gestionate la "
"nivel central. Acestea sunt gestionate prin intermediul unui singur [`Cargo."
"toml`](https://source.chromium.org/chromium/chromium/src/+/main:third_party/"
"rust/chromium_crates_io/Cargo.toml):"

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
#, fuzzy
msgid ""
"```toml\n"
"[dependencies]\n"
"bitflags = \"1\"\n"
"cfg-if = \"1\"\n"
"cxx = \"1\"\n"
"# lots more...\n"
"```"
msgstr ""
"```toml\n"
"[dependen탵e]\n"
"bitflags = \"1\"\n"
"cfg-if = \"1\"\n"
"cxx = \"1\"\n"
"# multe altele...\n"
"```"

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
#, fuzzy
msgid ""
"As with any other `Cargo.toml`, you can specify [more details about the "
"dependencies](https://doc.rust-lang.org/cargo/reference/specifying-"
"dependencies.html) --- most commonly, you'll want to specify the `features` "
"that you wish to enable in the crate."
msgstr ""
"Ca 탳i 칥n cazul oric캒rui alt `Cargo.toml`, pute탵i specifica [mai multe "
"detalii despre dependen탵e](https://doc.rust-lang.org/cargo/reference/"
"specifying-dependencies.html) --- cel mai frecvent, ve탵i dori s캒 specifica탵i "
"`features` pe care dori탵i s캒 le activa탵i 칥n crate."

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
#, fuzzy
msgid ""
"When adding a crate to Chromium, you'll often need to provide some extra "
"information in an additional file, `gnrt_config.toml`, which we'll meet next."
msgstr ""
"Atunci c칙nd ad캒uga탵i un crate la Chromium, va trebui adesea s캒 furniza탵i "
"c칙teva informa탵ii suplimentare 칥ntr-un fi탳ier suplimentar, `gnrt_config."
"toml`, pe care 칥l vom 칥nt칙lni 칥n continuare."

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
#, fuzzy
msgid ""
"Alongside `Cargo.toml` is [`gnrt_config.toml`](https://source.chromium.org/"
"chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/gnrt_config."
"toml). This contains Chromium-specific extensions to crate handling."
msgstr ""
"Al캒turi de `Cargo.toml` se afl캒 [`gnrt_config.toml`](https://source.chromium."
"org/chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/"
"gnrt_config.toml). Acesta con탵ine extensii specifice Chromium pentru "
"gestionarea crate-urilor."

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
#, fuzzy
msgid ""
"If you add a new crate, you should specify at least the `group`. This is one "
"of:"
msgstr ""
"Dac캒 ad캒uga탵i o lad캒 nou캒, trebuie s캒 specifica탵i cel pu탵in `group`. Acesta "
"este unul dintre urm캒toarele:"

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
#, fuzzy
msgid "For instance,"
msgstr "De exemplu,"

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
#, fuzzy
msgid ""
"Depending on the crate source code layout, you may also need to use this "
"file to specify where its `LICENSE` file(s) can be found."
msgstr ""
"칉n func탵ie de dispunerea codului surs캒 al crate-ului, este posibil s캒 fie "
"nevoie s캒 folosi탵i acest fi탳ier pentru a specifica unde pot fi g캒site "
"fi탳ierul (fi탳ierele) `LICENSE`."

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
#, fuzzy
msgid ""
"Later, we'll see some other things you will need to configure in this file "
"to resolve problems."
msgstr ""
"Mai t칙rziu, vom vedea alte lucruri pe care va trebui s캒 le configura탵i 칥n "
"acest fi탳ier pentru a rezolva problemele."

#: src/chromium/adding-third-party-crates/downloading-crates.md
#, fuzzy
msgid ""
"A tool called `gnrt` knows how to download crates and how to generate `BUILD."
"gn` rules."
msgstr ""
"Un instrument numit `gnrt` 탳tie cum s캒 descarce crates 탳i cum s캒 genereze "
"regulile `BUILD.gn`."

#: src/chromium/adding-third-party-crates/downloading-crates.md
#, fuzzy
msgid "To start, download the crate you want like this:"
msgstr "Pentru a 칥ncepe, desc캒rca탵i caseta pe care o dori탵i, astfel:"

#: src/chromium/adding-third-party-crates/downloading-crates.md
#, fuzzy
msgid ""
"Although the `gnrt` tool is part of the Chromium source code, by running "
"this command you will be downloading and running its dependencies from "
"`crates.io`. See [the earlier section](../cargo.md) discussing this security "
"decision."
msgstr ""
"De탳i instrumentul `gnrt` face parte din codul surs캒 Chromium, prin rularea "
"acestei comenzi ve탵i desc캒rca 탳i rula dependen탵ele sale de pe `crates.io`. "
"Consulta탵i [sec탵iunea anterioar캒](../cargo.md) 칥n care se discut캒 aceast캒 "
"decizie de securitate."

#: src/chromium/adding-third-party-crates/downloading-crates.md
#, fuzzy
msgid "This `vendor` command may download:"
msgstr "Aceast캒 comand캒 `vendor` poate desc캒rca:"

#: src/chromium/adding-third-party-crates/downloading-crates.md
#, fuzzy
msgid "Your crate"
msgstr "L캒zi (crates) utile"

#: src/chromium/adding-third-party-crates/downloading-crates.md
#, fuzzy
msgid "Direct and transitive dependencies"
msgstr "Dependen탵e directe 탳i tranzitive"

#: src/chromium/adding-third-party-crates/downloading-crates.md
#, fuzzy
msgid ""
"New versions of other crates, as required by `cargo` to resolve the complete "
"set of crates required by Chromium."
msgstr ""
"Versiuni noi ale altor crates, dup캒 cum este necesar pentru ca `cargo` s캒 "
"rezolve setul complet de crates cerut de Chromium."

#: src/chromium/adding-third-party-crates/downloading-crates.md
#, fuzzy
msgid ""
"Chromium maintains patches for some crates, kept in `//third_party/rust/"
"chromium_crates_io/patches`. These will be reapplied automatically, but if "
"patching fails you may need to take manual action."
msgstr ""
"Chromium men탵ine patch-uri pentru unele crates, p캒strate 칥n `//third_party/"
"rust/chromium_crates_io/patches`. Acestea vor fi reaplicate 칥n mod automat, "
"dar dac캒 patch-urile nu reu탳esc este posibil s캒 fie nevoie s캒 lua탵i m캒suri "
"manuale."

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
#, fuzzy
msgid ""
"Once you've downloaded the crate, generate the `BUILD.gn` files like this:"
msgstr "Dup캒 ce a탵i desc캒rcat crate, genera탵i fi탳ierele `BUILD.gn` astfel:"

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
#, fuzzy
msgid "Now run `git status`. You should find:"
msgstr "Acum rula탵i `git status`. Ar trebui s캒 g캒si탵i:"

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
#, fuzzy
msgid ""
"At least one new crate source code in `third_party/rust/chromium_crates_io/"
"vendor`"
msgstr ""
"Cel pu탵in un nou cod surs캒 de crate 칥n `third_party/rust/chromium_crates_io/"
"vendor`"

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
#, fuzzy
msgid ""
"At least one new `BUILD.gn` in `third_party/rust/<crate name>/v<major semver "
"version>`"
msgstr ""
"Cel pu탵in un nou `BUILD.gn` 칥n `third_party/rust/<crate name>/v<major semver "
"version>`"

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
#, fuzzy
msgid "An appropriate `README.chromium`"
msgstr "Un `README.chromium` adecvat"

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
#, fuzzy
msgid ""
"The \"major semver version\" is a [Rust \"semver\" version number](https://"
"doc.rust-lang.org/cargo/reference/semver.html)."
msgstr ""
"A se vedea [Rust Reference](https://doc.rust-lang.org/reference/type-layout."
"html)."

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
#, fuzzy
msgid ""
"Take a close look, especially at the things generated in `third_party/rust`."
msgstr ""
"Uita탵i-v캒 cu aten탵ie, 칥n special la lucrurile generate 칥n `third_party/rust`."

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
#, fuzzy
msgid ""
"Talk a little about semver --- and specifically the way that in Chromium "
"it's to allow multiple incompatible versions of a crate, which is "
"discouraged but sometimes necessary in the Cargo ecosystem."
msgstr ""
"Vorbi탵i pu탵in despre semver --- 탳i 칥n special despre modul 칥n care, 칥n "
"Chromium, permite mai multe versiuni incompatibile ale unei cutii, ceea ce "
"este descurajat, dar uneori necesar 칥n ecosistemul Cargo."

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid ""
"If your build fails, it may be because of a `build.rs`: programs which do "
"arbitrary things at build time. This is fundamentally at odds with the "
"design of `gn` and `ninja` which aim for static, deterministic, build rules "
"to maximize parallelism and repeatability of builds."
msgstr ""
"Dac캒 nu reu탳i탵i s캒 construi탵i, este posibil s캒 fie din cauza unui `build."
"rs`: programe care fac lucruri arbitrare 칥n momentul construirii. Acest "
"lucru este 칥n mod fundamental 칥n contradic탵ie cu proiectarea `gn` 탳i "
"`ninja`, care vizeaz캒 reguli de construire statice, deterministe, pentru a "
"maximiza paralelismul 탳i repetabilitatea compil캒rilor."

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid ""
"Some `build.rs` actions are automatically supported; others require action:"
msgstr ""
"Unele ac탵iuni `build.rs` sunt acceptate 칥n mod automat; altele necesit캒 o "
"ac탵iune:"

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid "build script effect"
msgstr "efect de script de construc탵ie"

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid "Supported by our gn templates"
msgstr "Sprijinit de 탳abloanele noastre gn"

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid "Work required by you"
msgstr "Lucr캒ri solicitate de dumneavoastr캒"

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid "Checking rustc version to configure features on and off"
msgstr ""
"Verificarea versiunii rustc pentru a configura func탵iile de activare 탳i "
"dezactivare"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Yes"
msgstr "Da"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "None"
msgstr "Nici unul"

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid "Checking platform or CPU to configure features on and off"
msgstr ""
"Verificarea platformei sau a unit캒탵ii centrale de procesare pentru a "
"configura func탵iile activate 탳i dezactivate"

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid "Generating code"
msgstr "Produse generice"

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid "Yes - specify in `gnrt_config.toml`"
msgstr "Da - specifica탵i 칥n `gnrt_config.toml`"

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid "Building C/C++"
msgstr "Construirea C/C++"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "No"
msgstr "Nu"

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid "Patch around it"
msgstr "Patch 칥n jurul ei"

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid "Arbitrary other actions"
msgstr "Alte ac탵iuni arbitrare"

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid ""
"Fortunately, most crates don't contain a build script, and fortunately, most "
"build scripts only do the top two actions."
msgstr ""
"Din fericire, cele mai multe cratere nu con탵in un script de construc탵ie 탳i, "
"din fericire, majoritatea scripturilor de construc탵ie efectueaz캒 doar "
"primele dou캒 ac탵iuni."

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
#, fuzzy
msgid ""
"If `ninja` complains about missing files, check the `build.rs` to see if it "
"writes source code files."
msgstr ""
"Dac캒 `ninja` se pl칙nge c캒 lipsesc fi탳iere, verifica탵i `build.rs` pentru a "
"vedea dac캒 scrie fi탳iere de cod surs캒."

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
#, fuzzy
msgid ""
"If so, modify [`gnrt_config.toml`](../configuring-gnrt-config-toml.md) to "
"add `build-script-outputs` to the crate. If this is a transitive dependency, "
"that is, one on which Chromium code should not directly depend, also add "
"`allow-first-party-usage=false`. There are several examples already in that "
"file:"
msgstr ""
"칉n acest caz, modifica탵i [`gnrt_config_config.toml`](../configuring-gnrt-"
"config-toml.md) pentru a ad캒uga `build-script-outputs` la crate. Dac캒 "
"aceasta este o dependen탵캒 tranzitiv캒, adic캒 una de care codul Chromium nu ar "
"trebui s캒 depind캒 direct, ad캒uga탵i 탳i `allow-first-party-usage=false`. "
"Exist캒 deja c칙teva exemple 칥n acel fi탳ier:"

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
#, fuzzy
msgid ""
"```toml\n"
"[crate.unicode-linebreak]\n"
"allow-first-party-usage = false\n"
"build-script-outputs = [\"tables.rs\"]\n"
"```"
msgstr ""
"```toml\n"
"[crate.unicode-linebreak]\n"
"allow-first-party-usage = false\n"
"build-script-outputs = [\"tables.rs\"]\n"
"```"

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
#, fuzzy
msgid ""
"Now rerun [`gnrt.py -- gen`](../generating-gn-build-rules.md) to regenerate "
"`BUILD.gn` files to inform ninja that this particular output file is input "
"to subsequent build steps."
msgstr ""
"Acum rula탵i din nou [`gnrt.py -- gen`](../generating-gn-gn-build-rules.md) "
"pentru a regenera fi탳ierele `BUILD.gn` pentru a informa ninja c캒 acest "
"fi탳ier de ie탳ire este o intrare pentru etapele ulterioare de construire."

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
#, fuzzy
msgid ""
"Some crates use the [`cc`](https://crates.io/crates/cc) crate to build and "
"link C/C++ libraries. Other crates parse C/C++ using [`bindgen`](https://"
"crates.io/crates/bindgen) within their build scripts. These actions can't be "
"supported in a Chromium context --- our gn, ninja and LLVM build system is "
"very specific in expressing relationships between build actions."
msgstr ""
"Unele crates utilizeaz캒 crate-ul [`cc`](https://crates.io/crates/cc) pentru "
"a construi 탳i lega bibliotecile C/C++. Alte crates analizeaz캒 C/C++ folosind "
"[`bindgen`](https://crates.io/crates/bindgen) 칥n scripturile lor de "
"compilare. Aceste ac탵iuni nu pot fi suportate 칥n contextul Chromium --- "
"sistemul nostru de compilare gn, ninja 탳i LLVM este foarte specific 칥n "
"exprimarea rela탵iilor dintre ac탵iunile de compilare."

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
#, fuzzy
msgid "So, your options are:"
msgstr "Deci, op탵iunile tale sunt:"

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
#, fuzzy
msgid "Avoid these crates"
msgstr "Evita탵i aceste l캒zi"

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
#, fuzzy
msgid "Apply a patch to the crate."
msgstr "Aplica탵i un plasture pe lad캒."

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
#, fuzzy
msgid ""
"Patches should be kept in `third_party/rust/chromium_crates_io/patches/"
"<crate>` - see for example the [patches against the `cxx` crate](https://"
"source.chromium.org/chromium/chromium/src/+/main:third_party/rust/"
"chromium_crates_io/patches/cxx/) - and will be applied automatically by "
"`gnrt` each time it upgrades the crate."
msgstr ""
"Patch-urile ar trebui p캒strate 칥n `third_party/rust/chromium_crates_io/"
"patches/<crate>` - a se vedea, de exemplu, [patches against the `cxx` crate]"
"(https://source.chromium.org/chromium/chromium/src/+/main:third_party/rust/"
"chromium_crates_io/patches/cxx/) - 탳i vor fi aplicate automat de c캒tre "
"`gnrt` de fiecare dat캒 c칙nd actualizeaz캒 crate-ul."

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
#, fuzzy
msgid ""
"Once you've added a third-party crate and generated build rules, depending "
"on a crate is simple. Find your `rust_static_library` target, and add a "
"`dep` on the `:lib` target within your crate."
msgstr ""
"Odat캒 ce a탵i ad캒ugat o caset캒 ter탵캒 parte 탳i a탵i generat reguli de "
"construc탵ie, este simplu s캒 depinde탵i de o caset캒. G캒si탵i 탵inta "
"`rust_static_library` 탳i ad캒uga탵i un `dep` pe 탵inta `:lib` 칥n cadrul crate-"
"ului dumneavoastr캒."

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
#, fuzzy
msgid "Specifically,"
msgstr "Specific sistemului de operare"

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
#, fuzzy
msgid ""
"```bob\n"
"                     +------------+      +----------------------+\n"
"\"//third_party/rust\" | crate name | \"/v\" | major semver version | \":"
"lib\"\n"
"                     +------------+      +----------------------+\n"
"```"
msgstr ""
"```bob\n"
"                     +------------+ +----------------------+\n"
"\"//third_party/rust\" | nume lad캒 | \"/v\" | versiunea major캒 a semver | \":"
"lib\"\n"
"                     +------------+ +----------------------+\n"
"```"

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
#, fuzzy
msgid ""
"```gn\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"  deps = [ \"//third_party/rust/example_rust_crate/v1:lib\" ]\n"
"}\n"
"```"
msgstr ""
"```gn\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"  deps = [ \"//third_party/rust/example_rust_crate/v1:lib\" ]\n"
"}\n"
"```"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
#, fuzzy
msgid "Auditing Third Party Crates"
msgstr "Auditul caselor ter탵ilor"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
#, fuzzy
msgid ""
"Adding new libraries is subject to Chromium's standard [policies](https://"
"chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/rust."
"md#Third_party-review), but of course also subject to security review. As "
"you may be bringing in not just a single crate but also transitive "
"dependencies, there may be a lot of code to review. On the other hand, safe "
"Rust code can have limited negative side effects. How should you review it?"
msgstr ""
"Ad캒ugarea de noi biblioteci este supus캒 [politicilor] standard ale Chromium "
"(https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/rust."
"md#Third_party-review), dar, bine칥n탵eles, este supus캒 탳i unei revizuiri de "
"securitate. Deoarece este posibil s캒 aduce탵i nu doar o singur캒 cr캒ias캒, ci "
"탳i dependen탵e tranzitive, este posibil s캒 existe o mul탵ime de cod de "
"revizuit. Pe de alt캒 parte, codul Rust sigur poate avea efecte secundare "
"negative limitate. Cum ar trebui s캒 칥l revizui탵i?"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
#, fuzzy
msgid ""
"Over time Chromium aims to move to a process based around [cargo vet]"
"(https://mozilla.github.io/cargo-vet/)."
msgstr ""
"칉n timp, Chromium 칥탳i propune s캒 treac캒 la un proces bazat pe [cargo vet]"
"(https://mozilla.github.io/cargo-vet/)."

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
#, fuzzy
msgid ""
"Meanwhile, for each new crate addition, we are checking for the following:"
msgstr "칉ntre timp, pentru fiecare nou캒 lad캒 ad캒ugat캒, verific캒m urm캒toarele:"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
#, fuzzy
msgid ""
"Understand why each crate is used. What's the relationship between crates? "
"If the build system for each crate contains a `build.rs` or procedural "
"macros, work out what they're for. Are they compatible with the way Chromium "
"is normally built?"
msgstr ""
"칉n탵elege탵i de ce este folosit캒 fiecare lad캒. Care este rela탵ia dintre l캒zi? "
"Dac캒 sistemul de compilare pentru fiecare crate con탵ine un `build.rs` sau "
"macroproceduri procedurale, 칥ncerca탵i s캒 afla탵i la ce folosesc. Sunt "
"compatibile cu modul 칥n care Chromium este construit 칥n mod normal?"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
#, fuzzy
msgid "Check each crate seems to be reasonably well maintained"
msgstr "Verifica탵i dac캒 fiecare lad캒 pare a fi rezonabil de bine 칥ntre탵inut캒"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
#, fuzzy
msgid ""
"Use `cd third-party/rust/chromium_crates_io; cargo audit` to check for known "
"vulnerabilities (first you'll need to `cargo install cargo-audit`, which "
"ironically involves downloading lots of dependencies from the internet[2](../"
"cargo.md))"
msgstr ""
"Folosi탵i `cd third-party/rust/chromium_crates_io; cargo audit` pentru a "
"verifica vulnerabilit캒탵ile cunoscute (mai 칥nt칙i va trebui s캒 `cargo install "
"cargo-audit`, care, 칥n mod ironic, implic캒 desc캒rcarea multor dependen탵e de "
"pe internet[2](../cargo.md)))"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
#, fuzzy
msgid ""
"Ensure any `unsafe` code is good enough for the [Rule of Two](https://"
"chromium.googlesource.com/chromium/src/+/main/docs/security/rule-of-2."
"md#unsafe-code-in-safe-languages)"
msgstr ""
"Asigura탵i-v캒 c캒 orice cod `unsafe` este suficient de bun pentru [Rule of Two]"
"(https://chromium.googlesource.com/chromium/src/+/main/docs/security/rule-"
"of-2.md#unsafe-code-in-safe-languages)"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
#, fuzzy
msgid "Check for any use of `fs` or `net` APIs"
msgstr "Verifica탵i dac캒 se utilizeaz캒 API-urile `fs` sau `net`"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
#, fuzzy
msgid ""
"Read all the code at a sufficient level to look for anything out of place "
"that might have been maliciously inserted. (You can't realistically aim for "
"100% perfection here: there's often just too much code.)"
msgstr ""
"Citi탵i tot codul la un nivel suficient pentru a c캒uta orice lucru care nu "
"este la locul lui 탳i care ar fi putut fi introdus 칥n mod r캒u inten탵ionat. "
"(칉n mod realist, nu pute탵i urm캒ri 100% perfec탵iune aici: de multe ori este "
"prea mult cod)"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
#, fuzzy
msgid ""
"These are just guidelines --- work with reviewers from `security@chromium."
"org` to work out the right way to become confident of the crate."
msgstr ""
"Acestea sunt doar linii directoare --- lucra탵i cu recenzen탵ii de la "
"`security@chromium.org` pentru a g캒si modul corect de a deveni 칥ncrez캒tor 칥n "
"lad캒."

#: src/chromium/adding-third-party-crates/checking-in.md
#, fuzzy
msgid "Checking Crates into Chromium Source Code"
msgstr "Verificarea Crates 칥n codul surs캒 Chromium"

#: src/chromium/adding-third-party-crates/checking-in.md
#, fuzzy
msgid "`git status` should reveal:"
msgstr "`git status` ar trebui s캒 arate:"

#: src/chromium/adding-third-party-crates/checking-in.md
#, fuzzy
msgid "Crate code in `//third_party/rust/chromium_crates_io`"
msgstr "Cod de cr캒i탵캒 칥n `//third_party/rust/chromium_crates_io`"

#: src/chromium/adding-third-party-crates/checking-in.md
#, fuzzy
msgid ""
"Metadata (`BUILD.gn` and `README.chromium`) in `//third_party/rust/<crate>/"
"<version>`"
msgstr ""
"Metadate (`BUILD.gn` 탳i `README.chromium`) 칥n `//third_party/rust/<crate>/"
"<version>`"

#: src/chromium/adding-third-party-crates/checking-in.md
#, fuzzy
msgid "Please also add an `OWNERS` file in the latter location."
msgstr ""
"V캒 rug캒m s캒 ad캒uga탵i, de asemenea, un fi탳ier `OWNERS` 칥n aceast캒 din urm캒 "
"loca탵ie."

#: src/chromium/adding-third-party-crates/checking-in.md
#, fuzzy
msgid ""
"You should land all this, along with your `Cargo.toml` and `gnrt_config."
"toml` changes, into the Chromium repo."
msgstr ""
"Ar trebui s캒 transfera탵i toate acestea, 칥mpreun캒 cu modific캒rile `Cargo."
"toml` 탳i `gnrt_config.toml`, 칥n repo-ul Chromium."

#: src/chromium/adding-third-party-crates/checking-in.md
#, fuzzy
msgid ""
"**Important**: you need to use `git add -f` because otherwise `.gitignore` "
"files may result in some files being skipped."
msgstr ""
"**Important**: trebuie s캒 folosi탵i `git add -f` pentru c캒 altfel fi탳ierele `."
"gitignore` pot duce la omiterea unor fi탳iere."

#: src/chromium/adding-third-party-crates/checking-in.md
#, fuzzy
msgid ""
"As you do so, you might find presubmit checks fail because of non-inclusive "
"language. This is because Rust crate data tends to include names of git "
"branches, and many projects still use non-inclusive terminology there. So "
"you may need to run:"
msgstr ""
"Pe m캒sur캒 ce face탵i acest lucru, s-ar putea s캒 constata탵i c캒 verific캒rile "
"칥nainte de trimitere e탳ueaz캒 din cauza limbajului neincluziv. Acest lucru se "
"datoreaz캒 faptului c캒 datele din Rust crate tind s캒 includ캒 nume de ramuri "
"git, iar multe proiecte 칥nc캒 folosesc terminologia neinclusiv캒 acolo. "
"A탳adar, este posibil s캒 fie nevoie s캒 rula탵i:"

#: src/chromium/adding-third-party-crates/keeping-up-to-date.md
#, fuzzy
msgid ""
"As the OWNER of any third party Chromium dependency, you are [expected to "
"keep it up to date with any security fixes](https://chromium.googlesource."
"com/chromium/src/+/main/docs/adding_to_third_party.md#add-owners). It is "
"hoped that we will soon automate this for Rust crates, but for now, it's "
"still your responsibility just as it is for any other third party dependency."
msgstr ""
"칉n calitate de PROPRIETAR al oric캒rei dependen탵e de Chromium de la ter탵i, "
"trebuie [s캒 o men탵ine탵i la zi cu toate corecturile de securitate] (https://"
"chromium.googlesource.com/chromium/src/+/main/docs/adding_to_third_party."
"md#add-owners). Se sper캒 c캒 칥n cur칙nd vom automatiza acest lucru pentru Rust "
"crates, dar, deocamdat캒, este 칥n continuare responsabilitatea dvs. la fel ca "
"pentru orice alt캒 dependen탵캒 ter탵캒 parte."

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid ""
"Add [uwuify](https://crates.io/crates/uwuify) to Chromium, turning off the "
"crate's [default features](https://doc.rust-lang.org/cargo/reference/"
"features.html#the-default-feature). Assume that the crate will be used in "
"shipping Chromium, but won't be used to handle untrustworthy input."
msgstr ""
"Ad캒uga탵i [uwuify](https://crates.io/crates/uwuify) la Chromium, dezactiv칙nd "
"[caracteristici implicite](https://doc.rust-lang.org/cargo/reference/"
"features.html#the-default-feature). Presupune탵i c캒 crate-ul va fi utilizat "
"칥n livrarea Chromium, dar nu va fi folosit pentru a gestiona intr캒rile "
"nesigure."

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid ""
"(In the next exercise we'll use uwuify from Chromium, but feel free to skip "
"ahead and do that now if you like. Or, you could create a new "
"[`rust_executable` target](https://source.chromium.org/chromium/chromium/src/"
"+/main:build/rust/rust_executable.gni) which uses `uwuify`)."
msgstr ""
"(칉n urm캒torul exerci탵iu vom folosi uwuify din Chromium, dar nu ezita탵i s캒 "
"trece탵i peste 탳i s캒 face탵i asta acum dac캒 dori탵i. Sau, pute탵i crea o nou캒 "
"탵int캒 [`rust_executable`](https://source.chromium.org/chromium/chromium/src/"
"+/main:build/rust/rust_executable.gni) care utilizeaz캒 `uwuify`)."

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid "Students will need to download lots of transitive dependencies."
msgstr "Elevii vor trebui s캒 descarce o mul탵ime de dependen탵e tranzitive."

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid "The total crates needed are:"
msgstr "Num캒rul total de l캒zi necesare este:"

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid "`instant`,"
msgstr "Constant"

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid "`lock_api`,"
msgstr "`lock_api`,"

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid "`parking_lot`,"
msgstr "`parking_lot`,"

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid "`parking_lot_core`,"
msgstr "`parking_lot_core`,"

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid "`redox_syscall`,"
msgstr "`redox_syscall`,"

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid "`scopeguard`,"
msgstr "`scopeguard`,"

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid "`smallvec`, and"
msgstr "`smallvec`, 탳i"

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid "`uwuify`."
msgstr "`uwuify`."

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid ""
"If students are downloading even more than that, they probably forgot to "
"turn off the default features."
msgstr ""
"Dac캒 elevii descarc캒 chiar mai mult dec칙t at칙t, probabil c캒 au uitat s캒 "
"dezactiveze func탵iile implicite."

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid ""
"Thanks to [Daniel Liu](https://github.com/Daniel-Liu-c0deb0t) for this crate!"
msgstr ""
"Mul탵umim lui [Daniel Liu](https://github.com/Daniel-Liu-c0deb0t) pentru "
"aceast캒 lad캒!"

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid "Bringing It Together --- Exercise"
msgstr "Reunind totul - Exerci탵iu"

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"In this exercise, you're going to add a whole new Chromium feature, bringing "
"together everything you already learned."
msgstr ""
"칉n acest exerci탵iu, ve탵i ad캒uga o func탵ie Chromium complet nou캒, reunind tot "
"ceea ce a탵i 칥nv캒탵at deja."

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid "The Brief from Product Management"
msgstr "Informarea din partea managementului de produs"

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"A community of pixies has been discovered living in a remote rainforest. "
"It's important that we get Chromium for Pixies delivered to them as soon as "
"possible."
msgstr ""
"A fost descoperit캒 o comunitate de z칙ne care tr캒ie탳te 칥ntr-o p캒dure "
"tropical캒 izolat캒. Este important s캒 le livr캒m Chromium pentru Pixies c칙t "
"mai cur칙nd posibil."

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"The requirement is to translate all Chromium's UI strings into Pixie "
"language."
msgstr ""
"Cerin탵a este de a traduce toate 탳irurile interfe탵ei de utilizare a Chromium "
"칥n limbajul Pixie."

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"There's not time to wait for proper translations, but fortunately pixie "
"language is very close to English, and it turns out there's a Rust crate "
"which does the translation."
msgstr ""
"Nu avem timp s캒 a탳tept캒m traduceri adecvate, dar din fericire, limba pixie "
"este foarte apropiat캒 de limba englez캒 탳i se pare c캒 exist캒 o caset캒 Rust "
"care face traducerea."

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"In fact, you already [imported that crate in the previous exercise](https://"
"crates.io/crates/uwuify)."
msgstr ""
"De fapt, a탵i [importat deja acea lad캒 칥n exerci탵iul anterior](https://crates."
"io/crates/uwuify)."

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"(Obviously, real translations of Chrome require incredible care and "
"diligence. Don't ship this!)"
msgstr ""
"(Evident, traducerile reale ale lui Chrome necesit캒 o aten탵ie 탳i o diligen탵캒 "
"incredibile. Nu expedia탵i asta!)"

#: src/exercises/chromium/bringing-it-together.md
msgid "Steps"
msgstr "Pa탳i"

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"Modify `ResourceBundle::MaybeMangleLocalizedString` so that it uwuifies all "
"strings before display. In this special build of Chromium, it should always "
"do this irrespective of the setting of `mangle_localized_strings_`."
msgstr ""
"Modific캒 `ResourceBundle::MaybeMangleLocalizedString` astfel 칥nc칙t s캒 "
"uwuifice toate 탳irurile 칥nainte de afi탳are. 칉n aceast캒 versiune special캒 a "
"Chromium, ar trebui s캒 fac캒 칥ntotdeauna acest lucru indiferent de setarea "
"lui `mangle_localized_strings_`."

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"If you've done everything right across all these exercises, congratulations, "
"you should have created Chrome for pixies!"
msgstr ""
"Dac캒 ai f캒cut totul bine 칥n toate aceste exerci탵ii, felicit캒ri, ar trebui s캒 "
"creezi Chrome pentru pixeli!"

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"UTF16 vs UTF8. Students should be aware that Rust strings are always UTF8, "
"and will probably decide that it's better to do the conversion on the C++ "
"side using `base::UTF16ToUTF8` and back again."
msgstr ""
"UTF16 vs UTF8. Studen탵ii ar trebui s캒 fie con탳tien탵i de faptul c캒 탳irurile "
"de caractere Rust sunt 칥ntotdeauna UTF8 탳i probabil vor decide c캒 este mai "
"bine s캒 fac캒 conversia pe partea C++ folosind `base::UTF16ToUTF8` 탳i invers."

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"If students decide to do the conversion on the Rust side, they'll need to "
"consider [`String::from_utf16`](https://doc.rust-lang.org/std/string/struct."
"String.html#method.from_utf16), consider error handling, and consider which "
"[CXX supported types can transfer a lot of u16s](https://cxx.rs/binding/"
"slice.html)."
msgstr ""
"Dac캒 studen탵ii decid s캒 fac캒 conversia pe partea Rust, ei vor trebui s캒 ia "
"칥n considerare [`String::from_utf16`](https://doc.rust-lang.org/std/string/"
"struct.String.html#method.from_utf16), s캒 ia 칥n considerare gestionarea "
"erorilor 탳i s캒 ia 칥n considerare care dintre tipurile acceptate de [CXX pot "
"transfera o mul탵ime de u16s](https://cxx.rs/binding/slice.html)."

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"Students may design the C++/Rust boundary in several different ways, e.g. "
"taking and returning strings by value, or taking a mutable reference to a "
"string. If a mutable reference is used, CXX will likely tell the student "
"that they need to use [`Pin`](https://doc.rust-lang.org/std/pin/). You may "
"need to explain what `Pin` does, and then explain why CXX needs it for "
"mutable references to C++ data: the answer is that C++ data can't be moved "
"around like Rust data, because it may contain self-referential pointers."
msgstr ""
"Elevii pot proiecta grani탵a C++/Rust 칥n mai multe moduri diferite, de "
"exemplu, preluarea 탳i returnarea 탳irurilor de caractere prin valoare sau "
"preluarea unei referin탵e mutabile la un 탳ir de caractere. 칉n cazul 칥n care "
"se utilizeaz캒 o referin탵캒 mutabil캒, CXX 칥i va spune probabil elevului c캒 "
"trebuie s캒 utilizeze [`Pin`](https://doc.rust-lang.org/std/pin/). Este "
"posibil s캒 fie necesar s캒 explica탵i ce face `Pin` 탳i apoi s캒 explica탵i de ce "
"CXX are nevoie de el pentru referin탵ele mutabile la datele C++: r캒spunsul "
"este c캒 datele C++ nu pot fi mutate ca datele Rust, deoarece pot con탵ine "
"pointeri autoreferen탵iali."

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"The C++ target containing `ResourceBundle::MaybeMangleLocalizedString` will "
"need to depend on a `rust_static_library` target. The student probably "
"already did this."
msgstr ""
"탴inta C++ care con탵ine `ResourceBundle::MaybeMangleLocalizedString` va "
"trebui s캒 depind캒 de o 탵int캒 `rust_static_library`. Probabil c캒 studentul a "
"f캒cut deja acest lucru."

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"The `rust_static_library` target will need to depend on `//third_party/rust/"
"uwuify/v0_2:lib`."
msgstr ""
"탴inta `rust_static_library` va trebui s캒 depind캒 de `//third_party/rust/"
"uwuify/v0_2:lib`."

#: src/exercises/chromium/solutions.md
#, fuzzy
msgid ""
"Solutions to the Chromium exercises can be found in [this series of CLs]"
"(https://chromium-review.googlesource.com/c/chromium/src/+/5096560)."
msgstr ""
"Solu탵iile la exerci탵iile cu Chromium se g캒sesc 칥n [aceast캒 serie de CL]"
"(https://chromium-review.googlesource.com/c/chromium/src/+/5096560)."

#: src/bare-metal.md
#, fuzzy
msgid "Welcome to Bare Metal Rust"
msgstr "Bine a탵i venit la Bare Metal Rust"

#: src/bare-metal.md
#, fuzzy
msgid ""
"This is a standalone one-day course about bare-metal Rust, aimed at people "
"who are familiar with the basics of Rust (perhaps from completing the "
"Comprehensive Rust course), and ideally also have some experience with bare-"
"metal programming in some other language such as C."
msgstr ""
"Acesta este un curs independent de o zi despre Rust, care se adreseaz캒 "
"persoanelor care sunt familiarizate cu elementele de baz캒 ale Rust (poate 칥n "
"urma absolvirii cursului Comprehensive Rust) 탳i care, 칥n mod ideal, au 탳i o "
"anumit캒 experien탵캒 칥n programarea bare-metal 칥ntr-un alt limbaj, cum ar fi C."

#: src/bare-metal.md
#, fuzzy
msgid ""
"Today we will talk about 'bare-metal' Rust: running Rust code without an OS "
"underneath us. This will be divided into several parts:"
msgstr ""
"Ast캒zi vom vorbi despre Rust \"bare-metal\": rularea codului Rust f캒r캒 un "
"sistem de operare sub noi. Acest subiect va fi 칥mp캒r탵it 칥n mai multe p캒r탵i:"

#: src/bare-metal.md
#, fuzzy
msgid "What is `no_std` Rust?"
msgstr "Ce este `no_std` Rust?"

#: src/bare-metal.md
#, fuzzy
msgid "Writing firmware for microcontrollers."
msgstr "Scrierea de firmware pentru microcontrolere."

#: src/bare-metal.md
#, fuzzy
msgid "Writing bootloader / kernel code for application processors."
msgstr "Scrierea codului bootloader / kernel pentru procesoarele de aplica탵ii."

#: src/bare-metal.md
#, fuzzy
msgid "Some useful crates for bare-metal Rust development."
msgstr "C칙teva l캒di탵e utile pentru dezvoltarea Rust pe suport metalic gol."

#: src/bare-metal.md
#, fuzzy
msgid ""
"For the microcontroller part of the course we will use the [BBC micro:bit]"
"(https://microbit.org/) v2 as an example. It's a [development board](https://"
"tech.microbit.org/hardware/) based on the Nordic nRF51822 microcontroller "
"with some LEDs and buttons, an I2C-connected accelerometer and compass, and "
"an on-board SWD debugger."
msgstr ""
"Pentru partea de microcontroler a cursului vom folosi [BBC micro:bit]"
"(https://microbit.org/) v2 ca exemplu. Este o [plac캒 de dezvoltare](https://"
"tech.microbit.org/hardware/) bazat캒 pe microcontrolerul Nordic nRF51822 cu "
"c칙teva LED-uri 탳i butoane, un accelerometru 탳i o busol캒 conectate I2C 탳i un "
"depanator SWD la bord."

#: src/bare-metal.md
#, fuzzy
msgid ""
"To get started, install some tools we'll need later. On gLinux or Debian:"
msgstr ""
"Pentru a 칥ncepe, instala탵i c칙teva instrumente de care vom avea nevoie mai "
"t칙rziu. Pe gLinux sau Debian:"

#: src/bare-metal.md
#, fuzzy
msgid ""
"And give users in the `plugdev` group access to the micro:bit programmer:"
msgstr ""
"탲i oferi탵i utilizatorilor din grupul `plugdev` acces la programatorul micro:"
"bit:"

#: src/bare-metal.md src/bare-metal/microcontrollers/debugging.md
#, fuzzy
msgid "On MacOS:"
msgstr "Pe MacOS:"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`core`"
msgstr "`core`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`std`"
msgstr "no_std"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "Slices, `&str`, `CStr`"
msgstr "Slices, `&str`, `CStr`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`NonZeroU8`..."
msgstr "`NonZeroU8`..."

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`Option`, `Result`"
msgstr "`Op탵iune`, `Rezultat`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`Display`, `Debug`, `write!`..."
msgstr "`Display`, `Debug`, `write!`..."

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`panic!`, `assert_eq!`..."
msgstr "`panic!`, `assert_eq!`..."

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`NonNull` and all the usual pointer-related functions"
msgstr "`NonNull` 탳i toate func탵iile obi탳nuite legate de pointer"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`Future` and `async`/`await`"
msgstr "`Future` 탳i `async`/`await`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`fence`, `AtomicBool`, `AtomicPtr`, `AtomicU32`..."
msgstr "`fence`, `AtomicBool`, `AtomicPtr`, `AtomicU32`..."

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`Duration`"
msgstr "`Durat캒`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`Box`, `Cow`, `Arc`, `Rc`"
msgstr "`Box`, `Cow`, `Arc`, `Rc`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`Vec`, `BinaryHeap`, `BtreeMap`, `LinkedList`, `VecDeque`"
msgstr "`Vec`, `BinaryHeap`, `BtreeMap`, `LinkedList`, `VecDeque`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`String`, `CString`, `format!`"
msgstr "`String`, `CString`, `format!`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`Error`"
msgstr "[Gestionarea erorilor](../error-handling.md) (45 minute)"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`Mutex`, `Condvar`, `Barrier`, `Once`, `RwLock`, `mpsc`"
msgstr "`Mutex`, `Condvar`, `Barrier`, `Once`, `RwLock`, `mpsc`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`File` and the rest of `fs`"
msgstr "`File` 탳i restul de `fs`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`println!`, `Read`, `Write`, `Stdin`, `Stdout` and the rest of `io`"
msgstr "`println!`, `Read`, `Write`, `Stdin`, `Stdout` 탳i restul de `io`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`Path`, `OsString`"
msgstr "`Path`, `OsString`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`net`"
msgstr "`net`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`Command`, `Child`, `ExitCode`"
msgstr "`Command`, `Child`, `ExitCode`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`spawn`, `sleep` and the rest of `thread`"
msgstr "`spawn`, `sleep` 탳i restul de `thread`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`SystemTime`, `Instant`"
msgstr "`SystemTime`, `Instant`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`HashMap` depends on RNG."
msgstr "`HashMap` depinde de RNG."

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`std` re-exports the contents of both `core` and `alloc`."
msgstr "`std` reexport캒 con탵inutul at칙t al lui `core` c칙t 탳i al lui `alloc`."

#: src/bare-metal/minimal.md
#, fuzzy
msgid "A minimal `no_std` program"
msgstr "Un program minimal `no_std`"

#: src/bare-metal/minimal.md
#, fuzzy
msgid "This will compile to an empty binary."
msgstr "Aceasta va compila un binar gol."

#: src/bare-metal/minimal.md
#, fuzzy
msgid "`std` provides a panic handler; without it we must provide our own."
msgstr ""
"`std` ofer캒 un gestionar de panic캒; 칥n lipsa acestuia, trebuie s캒 ne "
"furniz캒m propriul gestionar."

#: src/bare-metal/minimal.md
#, fuzzy
msgid "It can also be provided by another crate, such as `panic-halt`."
msgstr "Acesta poate fi furnizat 탳i de o alt캒 lad캒, cum ar fi `panic-halt`."

#: src/bare-metal/minimal.md
#, fuzzy
msgid ""
"Depending on the target, you may need to compile with `panic = \"abort\"` to "
"avoid an error about `eh_personality`."
msgstr ""
"칉n func탵ie de 탵int캒, este posibil s캒 fie nevoie s캒 compila탵i cu `panic = "
"\"abort\"` pentru a evita o eroare cu privire la `eh_personality`."

#: src/bare-metal/minimal.md
#, fuzzy
msgid ""
"Note that there is no `main` or any other entry point; it's up to you to "
"define your own entry point. This will typically involve a linker script and "
"some assembly code to set things up ready for Rust code to run."
msgstr ""
"Re탵ine탵i c캒 nu exist캒 niciun `main` sau alt punct de intrare; depinde de "
"dumneavoastr캒 s캒 v캒 defini탵i propriul punct de intrare. Acest lucru va "
"implica, de obicei, un script de linker 탳i ceva cod de asamblare pentru a "
"preg캒ti lucrurile pentru a permite rularea codului Rust."

#: src/bare-metal/alloc.md
#, fuzzy
msgid ""
"To use `alloc` you must implement a [global (heap) allocator](https://doc."
"rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html)."
msgstr ""
"Pentru a utiliza `alloc` trebuie s캒 implementa탵i un [alocator global (heap)]"
"(https://doc.rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html)."

#: src/bare-metal/alloc.md
#, fuzzy
msgid "// SAFETY: `HEAP` is only used here and `entry` is only called once.\n"
msgstr ""
"// Sigur, deoarece `HEAP` este folosit doar aici 탳i `entry` este apelat doar "
"o singur캒 dat캒.\n"

#: src/bare-metal/alloc.md
#, fuzzy
msgid "// Give the allocator some memory to allocate.\n"
msgstr "// Da탵i alocatorului o anumit캒 memorie de alocat.\n"

#: src/bare-metal/alloc.md
#, fuzzy
msgid "// Now we can do things that require heap allocation.\n"
msgstr "// Acum putem face lucruri care necesit캒 alocare de heap.\n"

#: src/bare-metal/alloc.md
#, fuzzy
msgid "\"A string\""
msgstr "탲ir"

#: src/bare-metal/alloc.md
#, fuzzy
msgid ""
"`buddy_system_allocator` is a third-party crate implementing a basic buddy "
"system allocator. Other crates are available, or you can write your own or "
"hook into your existing allocator."
msgstr ""
"`buddy_system_allocator` este un crate ter탵 care implementeaz캒 un alocator "
"de baz캒 pentru sistemul de prieteni. Sunt disponibile 탳i alte crates, sau "
"pute탵i s캒 v캒 scrie탵i propriul alocator sau s캒 v캒 conecta탵i la alocatorul "
"existent."

#: src/bare-metal/alloc.md
#, fuzzy
msgid ""
"The const parameter of `LockedHeap` is the max order of the allocator; i.e. "
"in this case it can allocate regions of up to 2\\*\\*32 bytes."
msgstr ""
"Parametrul const al `LockedHeap` este ordinea maxim캒 a alocatorului; adic캒, "
"칥n acest caz, acesta poate aloca regiuni de p칙n캒 la 2\\*\\*32 octe탵i."

#: src/bare-metal/alloc.md
#, fuzzy
msgid ""
"If any crate in your dependency tree depends on `alloc` then you must have "
"exactly one global allocator defined in your binary. Usually this is done in "
"the top-level binary crate."
msgstr ""
"Dac캒 orice crate din arborele de dependen탵캒 depinde de `alloc`, atunci "
"trebuie s캒 ave탵i exact un alocator global definit 칥n binarul dumneavoastr캒. "
"De obicei, acest lucru se face 칥n crate-ul binar de nivel superior."

#: src/bare-metal/alloc.md
#, fuzzy
msgid ""
"`extern crate panic_halt as _` is necessary to ensure that the `panic_halt` "
"crate is linked in so we get its panic handler."
msgstr ""
"`extern crate panic_halt as _` este necesar pentru a ne asigura c캒 crate-ul "
"`panic_halt` este legat, astfel 칥nc칙t s캒 ob탵inem gestionarul de panic캒 al "
"acestuia."

#: src/bare-metal/alloc.md
#, fuzzy
msgid "This example will build but not run, as it doesn't have an entry point."
msgstr ""
"Acest exemplu va fi construit, dar nu va fi executat, deoarece nu are un "
"punct de intrare."

#: src/bare-metal/microcontrollers.md
#, fuzzy
msgid ""
"The `cortex_m_rt` crate provides (among other things) a reset handler for "
"Cortex M microcontrollers."
msgstr ""
"Crate `cortex_m_rt` ofer캒 (printre altele) un gestionar de resetare pentru "
"microcontrolerele Cortex M."

#: src/bare-metal/microcontrollers.md
#, fuzzy
msgid ""
"Next we'll look at how to access peripherals, with increasing levels of "
"abstraction."
msgstr ""
"칉n continuare, vom examina modul de accesare a perifericelor, cu niveluri de "
"abstractizare din ce 칥n ce mai mari."

#: src/bare-metal/microcontrollers.md
#, fuzzy
msgid ""
"The `cortex_m_rt::entry` macro requires that the function have type `fn() -"
"> !`, because returning to the reset handler doesn't make sense."
msgstr ""
"Macroul `cortex_m_rt::entry` necesit캒 ca func탵ia s캒 aib캒 tipul `fn() -> !`, "
"deoarece 칥ntoarcerea la gestionarul de resetare nu are sens."

#: src/bare-metal/microcontrollers.md
#, fuzzy
msgid "Run the example with `cargo embed --bin minimal`"
msgstr "Rula탵i exemplul cu `cargo embed --bin minimal`"

#: src/bare-metal/microcontrollers/mmio.md
#, fuzzy
msgid ""
"Most microcontrollers access peripherals via memory-mapped IO. Let's try "
"turning on an LED on our micro:bit:"
msgstr ""
"Majoritatea microcontrolerelor acceseaz캒 perifericele prin intermediul IO "
"mapate 칥n memorie. S캒 칥ncerc캒m s캒 aprindem un LED pe micro:bit-ul nostru:"

#: src/bare-metal/microcontrollers/mmio.md
#, fuzzy
msgid "/// GPIO port 0 peripheral address\n"
msgstr "/// Adresa periferic캒 a portului GPIO 0\n"

#: src/bare-metal/microcontrollers/mmio.md
#, fuzzy
msgid "// GPIO peripheral offsets\n"
msgstr "// Decalajele perifericelor GPIO\n"

#: src/bare-metal/microcontrollers/mmio.md
#, fuzzy
msgid "// PIN_CNF fields\n"
msgstr "// C칙mpurile PIN_CNF\n"

#: src/bare-metal/microcontrollers/mmio.md
#: src/bare-metal/microcontrollers/pacs.md
#: src/bare-metal/microcontrollers/hals.md
#, fuzzy
msgid "// Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
msgstr "// Configura탵i pinii GPIO 0 21 탳i 28 ca ie탳iri push-pull.\n"

#: src/bare-metal/microcontrollers/mmio.md
#, fuzzy
msgid ""
"// SAFETY: The pointers are to valid peripheral control registers, and no\n"
"    // aliases exist.\n"
msgstr ""
"// Sigur, deoarece indicatorii sunt la registrele de control periferic "
"valide, 탳i\n"
"    // nu exist캒 alias-uri.\n"

#: src/bare-metal/microcontrollers/mmio.md
#: src/bare-metal/microcontrollers/pacs.md
#: src/bare-metal/microcontrollers/hals.md
#, fuzzy
msgid "// Set pin 28 low and pin 21 high to turn the LED on.\n"
msgstr ""
"// Seta탵i pinul 28 la nivel sc캒zut 탳i pinul 21 la nivel ridicat pentru a "
"aprinde LED-ul.\n"

#: src/bare-metal/microcontrollers/mmio.md
#, fuzzy
msgid ""
"GPIO 0 pin 21 is connected to the first column of the LED matrix, and pin 28 "
"to the first row."
msgstr ""
"Pinul 21 al GPIO 0 este conectat la prima coloan캒 a matricei de LED-uri, iar "
"pinul 28 la primul r칙nd."

#: src/bare-metal/microcontrollers/mmio.md
#: src/bare-metal/microcontrollers/pacs.md
#: src/bare-metal/microcontrollers/hals.md
#: src/bare-metal/microcontrollers/board-support.md
#, fuzzy
msgid "Run the example with:"
msgstr "Rula탵i exemplul cu:"

#: src/bare-metal/microcontrollers/pacs.md
#, fuzzy
msgid "Peripheral Access Crates"
msgstr "L캒zi de acces periferic"

#: src/bare-metal/microcontrollers/pacs.md
#, fuzzy
msgid ""
"[`svd2rust`](https://crates.io/crates/svd2rust) generates mostly-safe Rust "
"wrappers for memory-mapped peripherals from [CMSIS-SVD](https://www.keil.com/"
"pack/doc/CMSIS/SVD/html/index.html) files."
msgstr ""
"[`svd2rust`](https://crates.io/crates/svd2rust) genereaz캒 칥nveli탳uri Rust 칥n "
"mare parte sigure pentru perifericele cu memorie map캒 din fi탳ierele [CMSIS-"
"SVD](https://www.keil.com/pack/doc/CMSIS/SVD/html/index.html)."

#: src/bare-metal/microcontrollers/pacs.md
#, fuzzy
msgid ""
"SVD (System View Description) files are XML files typically provided by "
"silicon vendors which describe the memory map of the device."
msgstr ""
"Fi탳ierele SVD (System View Description) sunt fi탳iere XML furnizate de obicei "
"de furnizorii de siliciu care descriu harta de memorie a dispozitivului."

#: src/bare-metal/microcontrollers/pacs.md
#, fuzzy
msgid ""
"They are organised by peripheral, register, field and value, with names, "
"descriptions, addresses and so on."
msgstr ""
"Acestea sunt organizate 칥n func탵ie de periferic, registru, c칙mp 탳i valoare, "
"cu nume, descrieri, adrese etc."

#: src/bare-metal/microcontrollers/pacs.md
#, fuzzy
msgid ""
"SVD files are often buggy and incomplete, so there are various projects "
"which patch the mistakes, add missing details, and publish the generated "
"crates."
msgstr ""
"Fi탳ierele SVD sunt deseori eronate 탳i incomplete, a탳a c캒 exist캒 diverse "
"proiecte care corecteaz캒 gre탳elile, adaug캒 detaliile lips캒 탳i public캒 "
"l캒di탵ele generate."

#: src/bare-metal/microcontrollers/pacs.md
#, fuzzy
msgid "`cortex-m-rt` provides the vector table, among other things."
msgstr "`cortex-m-rt` furnizeaz캒, printre altele, tabelul vectorial."

#: src/bare-metal/microcontrollers/pacs.md
#, fuzzy
msgid ""
"If you `cargo install cargo-binutils` then you can run `cargo objdump --bin "
"pac -- -d --no-show-raw-insn` to see the resulting binary."
msgstr ""
"Dac캒 instala탵i `cargo install cargo-binutils` atunci pute탵i rula `cargo "
"objdump --bin pac -- -d --no-show-raw-insn` pentru a vedea binarul rezultat."

#: src/bare-metal/microcontrollers/hals.md
#, fuzzy
msgid "HAL crates"
msgstr "L캒zi (crates) HAL"

#: src/bare-metal/microcontrollers/hals.md
#, fuzzy
msgid ""
"[HAL crates](https://github.com/rust-embedded/awesome-embedded-rust#hal-"
"implementation-crates) for many microcontrollers provide wrappers around "
"various peripherals. These generally implement traits from [`embedded-hal`]"
"(https://crates.io/crates/embedded-hal)."
msgstr ""
"[HAL crates](https://github.com/rust-embedded/awesome-embedded-rust#hal-"
"implementation-crates) pentru multe microcontrolere ofer캒 칥nveli탳uri 칥n "
"jurul diferitelor periferice. Acestea implementeaz캒 칥n general tr캒s캒turi din "
"[`embedded-hal`](https://crates.io/crates/embedded-hal)."

#: src/bare-metal/microcontrollers/hals.md
#, fuzzy
msgid "// Create HAL wrapper for GPIO port 0.\n"
msgstr "// Crea탵i un 칥nveli탳 HAL pentru portul GPIO 0.\n"

#: src/bare-metal/microcontrollers/hals.md
#, fuzzy
msgid ""
"`set_low` and `set_high` are methods on the `embedded_hal` `OutputPin` trait."
msgstr ""
"`set_low` 탳i `set_high` sunt metode ale tr캒s캒turii `OutputPin` "
"`embedded_hal`."

#: src/bare-metal/microcontrollers/hals.md
#, fuzzy
msgid ""
"HAL crates exist for many Cortex-M and RISC-V devices, including various "
"STM32, GD32, nRF, NXP, MSP430, AVR and PIC microcontrollers."
msgstr ""
"HAL crates exist캒 pentru multe dispozitive Cortex-M 탳i RISC-V, inclusiv "
"pentru diverse microcontrolere STM32, GD32, nRF, NXP, MSP430, AVR 탳i PIC."

#: src/bare-metal/microcontrollers/board-support.md
#, fuzzy
msgid "Board support crates"
msgstr "Crates cu suport pentru pl캒ci"

#: src/bare-metal/microcontrollers/board-support.md
#, fuzzy
msgid ""
"Board support crates provide a further level of wrapping for a specific "
"board for convenience."
msgstr ""
"L캒zile de sus탵inere a pl캒cilor ofer캒 un nivel suplimentar de 칥mpachetare "
"pentru o anumit캒 plac캒, pentru mai mult캒 comoditate."

#: src/bare-metal/microcontrollers/board-support.md
#, fuzzy
msgid ""
"In this case the board support crate is just providing more useful names, "
"and a bit of initialisation."
msgstr ""
"칉n acest caz, suportul pentru pl캒ci ofer캒 doar nume mai utile 탳i o mic캒 "
"ini탵ializare."

#: src/bare-metal/microcontrollers/board-support.md
#, fuzzy
msgid ""
"The crate may also include drivers for some on-board devices outside of the "
"microcontroller itself."
msgstr ""
"De asemenea, pachetul poate include drivere pentru unele dispozitive de la "
"bord 칥n afara microcontrolerului propriu-zis."

#: src/bare-metal/microcontrollers/board-support.md
#, fuzzy
msgid "`microbit-v2` includes a simple driver for the LED matrix."
msgstr "`microbit-v2` include un driver simplu pentru matricea de LED-uri."

#: src/bare-metal/microcontrollers/type-state.md
#, fuzzy
msgid "The type state pattern"
msgstr "Modelul de stare de tip"

#: src/bare-metal/microcontrollers/type-state.md
#, fuzzy
msgid "// let gpio0_01_again = gpio0.p0_01; // Error, moved.\n"
msgstr "// let gpio0_01_again = gpio0.p0_01; // Eroare, mutat.\n"

#: src/bare-metal/microcontrollers/type-state.md
#, fuzzy
msgid "// pin_input.is_high(); // Error, moved.\n"
msgstr "// pin_input.is_high(); // Eroare, mutat.\n"

#: src/bare-metal/microcontrollers/type-state.md
#, fuzzy
msgid ""
"Pins don't implement `Copy` or `Clone`, so only one instance of each can "
"exist. Once a pin is moved out of the port struct nobody else can take it."
msgstr ""
"Pinii nu implementeaz캒 `Copy` sau `Clone`, astfel 칥nc칙t poate exista doar o "
"singur캒 instan탵캒 a fiec캒ruia. Odat캒 ce un pin este mutat din structura "
"portului, nimeni altcineva nu 칥l poate lua."

#: src/bare-metal/microcontrollers/type-state.md
#, fuzzy
msgid ""
"Changing the configuration of a pin consumes the old pin instance, so you "
"can't keep use the old instance afterwards."
msgstr ""
"Schimbarea configura탵iei unui pin consum캒 vechea instan탵캒 de pin, astfel "
"칥nc칙t nu mai pute탵i continua s캒 folosi탵i vechea instan탵캒 dup캒 aceea."

#: src/bare-metal/microcontrollers/type-state.md
#, fuzzy
msgid ""
"The type of a value indicates the state that it is in: e.g. in this case, "
"the configuration state of a GPIO pin. This encodes the state machine into "
"the type system, and ensures that you don't try to use a pin in a certain "
"way without properly configuring it first. Illegal state transitions are "
"caught at compile time."
msgstr ""
"Tipul unei valori indic캒 starea 칥n care se afl캒 aceasta: de exemplu, 칥n "
"acest caz, starea de configurare a unui pin GPIO. Acest lucru codific캒 "
"ma탳ina de stare 칥n sistemul de tipuri 탳i garanteaz캒 c캒 nu 칥ncerca탵i s캒 "
"utiliza탵i un pin 칥ntr-un anumit mod f캒r캒 s캒-l configura탵i mai 칥nt칙i 칥n mod "
"corespunz캒tor. Tranzi탵iile de stare ilegale sunt detectate 칥n momentul "
"compil캒rii."

#: src/bare-metal/microcontrollers/type-state.md
#, fuzzy
msgid ""
"You can call `is_high` on an input pin and `set_high` on an output pin, but "
"not vice-versa."
msgstr ""
"Pute탵i apela `is_high` pe un pin de intrare 탳i `set_high` pe un pin de "
"ie탳ire, dar nu 탳i invers."

#: src/bare-metal/microcontrollers/type-state.md
#, fuzzy
msgid "Many HAL crates follow this pattern."
msgstr "Multe l캒zi HAL urmeaz캒 acest model."

#: src/bare-metal/microcontrollers/embedded-hal.md
#, fuzzy
msgid ""
"The [`embedded-hal`](https://crates.io/crates/embedded-hal) crate provides a "
"number of traits covering common microcontroller peripherals:"
msgstr ""
"Cr캒iasa [`embedded-hal`](https://crates.io/crates/embedded-hal) ofer캒 o "
"serie de caracteristici care acoper캒 perifericele comune ale "
"microcontrolerului."

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid "GPIO"
msgstr "GPIO"

#: src/bare-metal/microcontrollers/embedded-hal.md
#, fuzzy
msgid "PWM"
msgstr "PWM"

#: src/bare-metal/microcontrollers/embedded-hal.md
#, fuzzy
msgid "Delay timers"
msgstr "Temporizatoare cu 칥nt칙rziere"

#: src/bare-metal/microcontrollers/embedded-hal.md
#, fuzzy
msgid "I2C and SPI buses and devices"
msgstr "Busuri 탳i dispozitive I2C 탳i SPI"

#: src/bare-metal/microcontrollers/embedded-hal.md
#, fuzzy
msgid ""
"Similar traits for byte streams (e.g. UARTs), CAN buses and RNGs and broken "
"out into [`embedded-io`](https://crates.io/crates/embedded-io), [`embedded-"
"can`](https://crates.io/crates/embedded-can) and [`rand_core`](https://"
"crates.io/crates/rand_core) respectively."
msgstr ""
"Tr캒s캒turi similare pentru fluxurile de octe탵i (de exemplu, UART), "
"magistralele CAN 탳i RNG-uri 탳i 칥mp캒r탵ite 칥n [`embedded-io`](https://crates."
"io/crates/embedded-io), [`embedded-can`](https://crates.io/crates/embedded-"
"can) 탳i, respectiv, [`rand_core`](https://crates.io/crates/rand_core)."

#: src/bare-metal/microcontrollers/embedded-hal.md
#, fuzzy
msgid ""
"Other crates then implement [drivers](https://github.com/rust-embedded/"
"awesome-embedded-rust#driver-crates) in terms of these traits, e.g. an "
"accelerometer driver might need an I2C or SPI device instance."
msgstr ""
"Alte crates implementeaz캒 apoi [drivere](https://github.com/rust-embedded/"
"awesome-embedded-rust#driver-crates) 칥n func탵ie de aceste caracteristici, de "
"exemplu, un driver pentru accelerometru poate avea nevoie de o implementare "
"a bus-ului I2C sau SPI."

#: src/bare-metal/microcontrollers/embedded-hal.md
#, fuzzy
msgid ""
"The traits cover using the peripherals but not initialising or configuring "
"them, as initialisation and configuration is usually highly platform-"
"specific."
msgstr ""
"Tr캒s캒turile se refer캒 la utilizarea perifericelor, dar nu la ini탵ializarea "
"sau configurarea acestora, deoarece ini탵ializarea 탳i configurarea sunt de "
"obicei foarte specifice platformei."

#: src/bare-metal/microcontrollers/embedded-hal.md
#, fuzzy
msgid ""
"There are implementations for many microcontrollers, as well as other "
"platforms such as Linux on Raspberry Pi."
msgstr ""
"Exist캒 implement캒ri pentru multe microcontrolere, precum 탳i pentru alte "
"platforme, cum ar fi Linux pe Raspberry Pi."

#: src/bare-metal/microcontrollers/embedded-hal.md
#, fuzzy
msgid ""
"[`embedded-hal-async`](https://crates.io/crates/embedded-hal-async) provides "
"async versions of the traits."
msgstr ""
"Cr캒iasa [`embedded-hal`](https://crates.io/crates/embedded-hal) ofer캒 o "
"serie de caracteristici care acoper캒 perifericele comune ale "
"microcontrolerului."

#: src/bare-metal/microcontrollers/embedded-hal.md
#, fuzzy
msgid ""
"[`embedded-hal-nb`](https://crates.io/crates/embedded-hal-nb) provides "
"another approach to non-blocking I/O, based on the [`nb`](https://crates.io/"
"crates/nb) crate."
msgstr ""
"Cr캒iasa [`embedded-hal`](https://crates.io/crates/embedded-hal) ofer캒 o "
"serie de caracteristici care acoper캒 perifericele comune ale "
"microcontrolerului."

#: src/bare-metal/microcontrollers/probe-rs.md
#, fuzzy
msgid ""
"[probe-rs](https://probe.rs/) is a handy toolset for embedded debugging, "
"like OpenOCD but better integrated."
msgstr ""
"[probe-rs](https://probe.rs/) este un set de instrumente utile pentru "
"depanarea embedded, precum OpenOCD, dar mai bine integrat."

#: src/bare-metal/microcontrollers/probe-rs.md
#, fuzzy
msgid ""
"SWD (Serial Wire Debug) and JTAG via CMSIS-DAP, ST-Link and J-Link probes"
msgstr ""
"SWD (Serial Wire Debug) 탳i JTAG prin sonde CMSIS-DAP, ST-Link 탳i J-Link"

#: src/bare-metal/microcontrollers/probe-rs.md
#, fuzzy
msgid "GDB stub and Microsoft DAP (Debug Adapter Protocol) server"
msgstr "GDB stub 탳i serverul Microsoft DAP (Debug Adapter Protocol)"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid "Cargo integration"
msgstr "Integrarea Cargo"

#: src/bare-metal/microcontrollers/probe-rs.md
#, fuzzy
msgid ""
"`cargo-embed` is a cargo subcommand to build and flash binaries, log RTT "
"(Real Time Transfers) output and connect GDB. It's configured by an `Embed."
"toml` file in your project directory."
msgstr ""
"`cargo-embed` este o subcomand캒 cargo pentru a construi 탳i afi탳a binare, a "
"칥nregistra ie탳irea RTT (Real Time Transfers) 탳i a conecta GDB. Este "
"configurat캒 de un fi탳ier `Embed.toml` din directorul proiectului "
"dumneavoastr캒."

#: src/bare-metal/microcontrollers/probe-rs.md
#, fuzzy
msgid ""
"[CMSIS-DAP](https://arm-software.github.io/CMSIS_5/DAP/html/index.html) is "
"an Arm standard protocol over USB for an in-circuit debugger to access the "
"CoreSight Debug Access Port of various Arm Cortex processors. It's what the "
"on-board debugger on the BBC micro:bit uses."
msgstr ""
"[CMSIS-DAP](https://arm-software.github.io/CMSIS_5/DAP/html/index.html) este "
"un protocol standard Arm prin USB pentru ca un depanator in-circuit s캒 "
"acceseze portul de acces la depanare CoreSight al diferitelor procesoare Arm "
"Cortex. Este ceea ce folose탳te depanatorul de bord de pe BBC micro:bit."

#: src/bare-metal/microcontrollers/probe-rs.md
#, fuzzy
msgid ""
"ST-Link is a range of in-circuit debuggers from ST Microelectronics, J-Link "
"is a range from SEGGER."
msgstr ""
"ST-Link este o gam캒 de depanatoare 칥n circuit de la ST Microelectronics, iar "
"J-Link este o gam캒 de la SEGGER."

#: src/bare-metal/microcontrollers/probe-rs.md
#, fuzzy
msgid ""
"The Debug Access Port is usually either a 5-pin JTAG interface or 2-pin "
"Serial Wire Debug."
msgstr ""
"Portul de acces pentru depanare este, de obicei, fie o interfa탵캒 JTAG cu 5 "
"pini, fie o interfa탵캒 de depanare prin cablu serial cu 2 pini."

#: src/bare-metal/microcontrollers/probe-rs.md
#, fuzzy
msgid ""
"probe-rs is a library which you can integrate into your own tools if you "
"want to."
msgstr ""
"probe-rs este o bibliotec캒 pe care o pute탵i integra 칥n propriile "
"instrumente, dac캒 dori탵i."

#: src/bare-metal/microcontrollers/probe-rs.md
#, fuzzy
msgid ""
"The [Microsoft Debug Adapter Protocol](https://microsoft.github.io/debug-"
"adapter-protocol/) lets VSCode and other IDEs debug code running on any "
"supported microcontroller."
msgstr ""
"[Microsoft Debug Adapter Protocol](https://microsoft.github.io/debug-adapter-"
"protocol/) permite VSCode 탳i altor IDE-uri s캒 depaneze codul care ruleaz캒 pe "
"orice microcontroler acceptat."

#: src/bare-metal/microcontrollers/probe-rs.md
#, fuzzy
msgid "cargo-embed is a binary built using the probe-rs library."
msgstr "cargo-embed este un binar construit folosind biblioteca probe-rs."

#: src/bare-metal/microcontrollers/probe-rs.md
#, fuzzy
msgid ""
"RTT (Real Time Transfers) is a mechanism to transfer data between the debug "
"host and the target through a number of ringbuffers."
msgstr ""
"RTT (Real Time Transfers) este un mecanism de transfer de date 칥ntre gazda "
"de depanare 탳i 탵int캒 prin intermediul unui num캒r de ringbufferi."

#: src/bare-metal/microcontrollers/debugging.md
#, fuzzy
msgid "_Embed.toml_:"
msgstr "_Embed.toml_:"

#: src/bare-metal/microcontrollers/debugging.md
#, fuzzy
msgid "In one terminal under `src/bare-metal/microcontrollers/examples/`:"
msgstr "칉ntr-un terminal, sub `src/bare-metal/microcontrollers/examples/`:"

#: src/bare-metal/microcontrollers/debugging.md
#, fuzzy
msgid "In another terminal in the same directory:"
msgstr "칉ntr-un alt terminal din acela탳i director:"

#: src/bare-metal/microcontrollers/debugging.md
#, fuzzy
msgid "On gLinux or Debian:"
msgstr "Pe gLinux sau Debian:"

#: src/bare-metal/microcontrollers/debugging.md
#, fuzzy
msgid "In GDB, try running:"
msgstr "칉n GDB, 칥ncerca탵i s캒 rula탵i:"

#: src/bare-metal/microcontrollers/other-projects.md
#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid "Other projects"
msgstr "Alte proiecte"

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid "[RTIC](https://rtic.rs/)"
msgstr "[RTIC](https://rtic.rs/)"

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid "\"Real-Time Interrupt-driven Concurrency\""
msgstr "\"Concurren탵a 칥n timp real bazat캒 pe 칥ntreruperi\""

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid ""
"Shared resource management, message passing, task scheduling, timer queue"
msgstr ""
"Gestionarea resurselor partajate, trecerea mesajelor, programarea "
"sarcinilor, coada de timp"

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid "[Embassy](https://embassy.dev/)"
msgstr "[Ambasada](https://embassy.dev/)"

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid "`async` executors with priorities, timers, networking, USB"
msgstr "executori `async` cu priorit캒탵i, cronometre, re탵ea, USB"

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid "[TockOS](https://www.tockos.org/documentation/getting-started)"
msgstr "[TockOS](https://www.tockos.org/documentation/getting-started)"

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid ""
"Security-focused RTOS with preemptive scheduling and Memory Protection Unit "
"support"
msgstr ""
"RTOS axat pe securitate, cu programare preemptiv캒 탳i suport pentru unitatea "
"de protec탵ie a memoriei"

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid "[Hubris](https://hubris.oxide.computer/)"
msgstr "[Hubris](https://hubris.oxide.computer/)"

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid ""
"Microkernel RTOS from Oxide Computer Company with memory protection, "
"unprivileged drivers, IPC"
msgstr ""
"Microkernel RTOS de la Oxide Computer Company cu protec탵ie de memorie, "
"drivere neprivilegiate, IPC"

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid "[Bindings for FreeRTOS](https://github.com/lobaro/FreeRTOS-rust)"
msgstr "[Leg캒turi pentru FreeRTOS](https://github.com/lobaro/FreeRTOS-rust)"

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid ""
"Some platforms have `std` implementations, e.g. [esp-idf](https://esp-rs."
"github.io/book/overview/using-the-standard-library.html)."
msgstr ""
"Unele platforme au implement캒ri `std`, de exemplu [esp-idf](https://esp-rs."
"github.io/book/overview/using-the-standard-library.html)."

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid "RTIC can be considered either an RTOS or a concurrency framework."
msgstr "RTIC poate fi considerat fie un RTOS, fie un cadru de concuren탵캒."

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid "It doesn't include any HALs."
msgstr "Nu include niciun HAL."

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid ""
"It uses the Cortex-M NVIC (Nested Virtual Interrupt Controller) for "
"scheduling rather than a proper kernel."
msgstr ""
"Acesta utilizeaz캒 Cortex-M NVIC (Nested Virtual Interrupt Controller) pentru "
"programare, 칥n loc de un kernel propriu-zis."

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid "Cortex-M only."
msgstr "Numai Cortex-M."

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid ""
"Google uses TockOS on the Haven microcontroller for Titan security keys."
msgstr ""
"Google folose탳te TockOS pe microcontrolerul Haven pentru cheile de "
"securitate Titan."

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid ""
"FreeRTOS is mostly written in C, but there are Rust bindings for writing "
"applications."
msgstr ""
"FreeRTOS este scris 칥n mare parte 칥n C, dar exist캒 leg캒turi Rust pentru "
"scrierea de aplica탵ii."

#: src/exercises/bare-metal/morning.md
#, fuzzy
msgid ""
"We will read the direction from an I2C compass, and log the readings to a "
"serial port."
msgstr ""
"Vom citi direc탵ia de la o busol캒 I2C 탳i vom 칥nregistra citirile pe un port "
"serial."

#: src/exercises/bare-metal/morning.md
msgid ""
"After looking at the exercises, you can look at the [solutions](solutions-"
"morning.md) provided."
msgstr ""
"Dup캒 ce a탵i studiat exerci탵iile, pute탵i consulta [solu탵ile](solutions-"
"morning.md) furnizate."

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid ""
"We will read the direction from an I2C compass, and log the readings to a "
"serial port. If you have time, try displaying it on the LEDs somehow too, or "
"use the buttons somehow."
msgstr ""
"Vom citi direc탵ia de la o busol캒 I2C 탳i vom 칥nregistra citirile pe un port "
"serial. Dac캒 ave탵i timp, 칥ncerca탵i s캒 o afi탳a탵i cumva 탳i pe LED-uri sau s캒 "
"folosi탵i cumva butoanele."

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid "Hints:"
msgstr "Sugestii:"

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid ""
"Check the documentation for the [`lsm303agr`](https://docs.rs/lsm303agr/"
"latest/lsm303agr/) and [`microbit-v2`](https://docs.rs/microbit-v2/latest/"
"microbit/) crates, as well as the [micro:bit hardware](https://tech.microbit."
"org/hardware/)."
msgstr ""
"Consulta탵i documenta탵ia pentru pachetele [`lsm303agr`](https://docs.rs/"
"lsm303agr/latest/lsm303agr/) 탳i [`microbit-v2`](https://docs.rs/microbit-v2/"
"latest/microbit/), precum 탳i pentru [micro:bit hardware](https://tech."
"microbit.org/hardware/)."

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid ""
"The LSM303AGR Inertial Measurement Unit is connected to the internal I2C bus."
msgstr ""
"Unitatea de m캒surare iner탵ial캒 LSM303AGR este conectat캒 la magistrala "
"intern캒 I2C."

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid ""
"TWI is another name for I2C, so the I2C master peripheral is called TWIM."
msgstr ""
"TWI este un alt nume pentru I2C, astfel 칥nc칙t perifericul master I2C se "
"nume탳te TWIM."

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid ""
"The LSM303AGR driver needs something implementing the `embedded_hal::"
"blocking::i2c::WriteRead` trait. The [`microbit::hal::Twim`](https://docs.rs/"
"microbit-v2/latest/microbit/hal/struct.Twim.html) struct implements this."
msgstr ""
"Driverul LSM303AGR are nevoie de ceva care s캒 implementeze tr캒s캒tura "
"`embedded_hal::blocking::i2c::WriteRead`. Structura [`microbit::hal::Twim`]"
"(https://docs.rs/microbit-v2/latest/microbit/hal/struct.Twim.html) "
"implementeaz캒 acest lucru."

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid ""
"You have a [`microbit::Board`](https://docs.rs/microbit-v2/latest/microbit/"
"struct.Board.html) struct with fields for the various pins and peripherals."
msgstr ""
"Ave탵i o structur캒 [`microbit::Board`](https://docs.rs/microbit-v2/latest/"
"microbit/struct.Board.html) cu c칙mpuri pentru diver탳i pini 탳i periferice."

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid ""
"You can also look at the [nRF52833 datasheet](https://infocenter.nordicsemi."
"com/pdf/nRF52833_PS_v1.5.pdf) if you want, but it shouldn't be necessary for "
"this exercise."
msgstr ""
"Dac캒 dori탵i, pute탵i consulta 탳i [nRF52833 datasheet](https://infocenter."
"nordicsemi.com/pdf/nRF52833_PS_v1.5.pdf), dar nu ar trebui s캒 fie necesar "
"pentru acest exerci탵iu."

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and "
"look in the `compass` directory for the following files."
msgstr ""
"Desc캒rca탵i [탳ablonul de exerci탵ii] (../../comprehensive-rust-exercises.zip) "
"탳i c캒uta탵i 칥n directorul `compass` urm캒toarele fi탳iere."

#: src/exercises/bare-metal/compass.md src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "_src/main.rs_:"
msgstr "src/main.rs_:"

#: src/exercises/bare-metal/compass.md src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "_Cargo.toml_ (you shouldn't need to change this):"
msgstr "_Cargo.toml_ (nu ar trebui s캒 fie nevoie s캒 modifica탵i acest lucru):"

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid "_Embed.toml_ (you shouldn't need to change this):"
msgstr "_Embed.toml_ (nu ar trebui s캒 fie nevoie s캒 modifica탵i acest lucru):"

#: src/exercises/bare-metal/compass.md src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "_.cargo/config.toml_ (you shouldn't need to change this):"
msgstr ""
"_.cargo/config.toml_ (nu ar trebui s캒 fie nevoie s캒 modifica탵i acest lucru):"

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid "See the serial output on Linux with:"
msgstr "Vede탵i ie탳irea serial캒 pe Linux cu:"

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid ""
"Or on Mac OS something like (the device name may be slightly different):"
msgstr ""
"Sau, pe Mac OS, ceva de genul (numele dispozitivului poate fi u탳or diferit):"

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid "Use Ctrl+A Ctrl+Q to quit picocom."
msgstr "Folosi탵i Ctrl+A Ctrl+Q pentru a ie탳i din picocom."

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid "Bare Metal Rust Morning Exercise"
msgstr "Exerci탵iu de diminea탵캒 Bare Metal Rust"

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid "([back to exercise](compass.md))"
msgstr "([back to exercise](compass.md))"

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid "// Configure serial port.\n"
msgstr "// Configura탵i portul serial.\n"

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid "// Use the system timer as a delay provider.\n"
msgstr "// Utiliza탵i temporizatorul sistemului ca furnizor de 칥nt칙rzieri.\n"

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid "// Set up the I2C controller and Inertial Measurement Unit.\n"
msgstr "// Configura탵i controlerul I2C 탳i unitatea de m캒surare iner탵ial캒.\n"

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid "\"Setting up IMU...\""
msgstr "\"Configurarea IMU...\""

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid "// Set up display and timer.\n"
msgstr "// Configura탵i afi탳ajul 탳i cronometrul.\n"

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid "\"Ready.\""
msgstr "\"Gata.\""

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid "// Read compass data and log it to the serial port.\n"
msgstr "// Citi탵i datele busolei 탳i 칥nregistra탵i-le pe portul serial.\n"

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid "\"{},{},{}\\t{},{},{}\""
msgstr "Parti탵ii: `&[T]`"

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid ""
"// If button A is pressed, switch to the next mode and briefly blink all "
"LEDs\n"
"        // on.\n"
msgstr ""
"// Dac캒 este ap캒sat butonul A, se trece la modul urm캒tor 탳i clipesc pentru "
"scurt timp toate LED-urile\n"
"        // pornit.\n"

#: src/bare-metal/aps.md
#, fuzzy
msgid "Application processors"
msgstr "Procesatori de aplica탵ii"

#: src/bare-metal/aps.md
#, fuzzy
msgid ""
"So far we've talked about microcontrollers, such as the Arm Cortex-M series. "
"Now let's try writing something for Cortex-A. For simplicity we'll just work "
"with QEMU's aarch64 ['virt'](https://qemu-project.gitlab.io/qemu/system/arm/"
"virt.html) board."
msgstr ""
"P칙n캒 acum am vorbit despre microcontrolere, cum ar fi seria Arm Cortex-M. "
"Acum s캒 칥ncerc캒m s캒 scriem ceva pentru Cortex-A. Pentru simplitate, vom "
"lucra doar cu placa aarch64 ['virt'](https://qemu-project.gitlab.io/qemu/"
"system/arm/virt.html) a lui QEMU."

#: src/bare-metal/aps.md
#, fuzzy
msgid ""
"Broadly speaking, microcontrollers don't have an MMU or multiple levels of "
"privilege (exception levels on Arm CPUs, rings on x86), while application "
"processors do."
msgstr ""
"칉n linii mari, microcontrolerele nu au un MMU sau mai multe niveluri de "
"privilegii (niveluri de excep탵ie la procesoarele Arm, inele la x86), 칥n timp "
"ce procesoarele de aplica탵ii au."

#: src/bare-metal/aps.md
#, fuzzy
msgid ""
"QEMU supports emulating various different machines or board models for each "
"architecture. The 'virt' board doesn't correspond to any particular real "
"hardware, but is designed purely for virtual machines."
msgstr ""
"QEMU suport캒 emularea mai multor ma탳ini sau modele de pl캒ci diferite pentru "
"fiecare arhitectur캒. Placa \"virt\" nu corespunde unui anumit hardware real, "
"ci este conceput캒 exclusiv pentru ma탳ini virtuale."

#: src/bare-metal/aps/entry-point.md
#, fuzzy
msgid ""
"Before we can start running Rust code, we need to do some initialisation."
msgstr ""
"칉nainte de a 칥ncepe s캒 rul캒m codul Rust, trebuie s캒 facem o anumit캒 "
"ini탵ializare."

#: src/bare-metal/aps/entry-point.md
#, fuzzy
msgid ""
"```armasm\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"    /*\n"
"     * Load and apply the memory management configuration, ready to enable "
"MMU and\n"
"     * caches.\n"
"     */\n"
"    adrp x30, idmap\n"
"    msr ttbr0_el1, x30\n"
"\n"
"    mov_i x30, .Lmairval\n"
"    msr mair_el1, x30\n"
"\n"
"    mov_i x30, .Ltcrval\n"
"    /* Copy the supported PA range into TCR_EL1.IPS. */\n"
"    mrs x29, id_aa64mmfr0_el1\n"
"    bfi x30, x29, #32, #4\n"
"\n"
"    msr tcr_el1, x30\n"
"\n"
"    mov_i x30, .Lsctlrval\n"
"\n"
"    /*\n"
"     * Ensure everything before this point has completed, then invalidate "
"any\n"
"     * potentially stale local TLB entries before they start being used.\n"
"     */\n"
"    isb\n"
"    tlbi vmalle1\n"
"    ic iallu\n"
"    dsb nsh\n"
"    isb\n"
"\n"
"    /*\n"
"     * Configure sctlr_el1 to enable MMU and cache and don't proceed until "
"this\n"
"     * has completed.\n"
"     */\n"
"    msr sctlr_el1, x30\n"
"    isb\n"
"\n"
"    /* Disable trapping floating point access in EL1. */\n"
"    mrs x30, cpacr_el1\n"
"    orr x30, x30, #(0x3 << 20)\n"
"    msr cpacr_el1, x30\n"
"    isb\n"
"\n"
"    /* Zero out the bss section. */\n"
"    adr_l x29, bss_begin\n"
"    adr_l x30, bss_end\n"
"0:  cmp x29, x30\n"
"    b.hs 1f\n"
"    stp xzr, xzr, [x29], #16\n"
"    b 0b\n"
"\n"
"1:  /* Prepare the stack. */\n"
"    adr_l x30, boot_stack_end\n"
"    mov sp, x30\n"
"\n"
"    /* Set up exception vector. */\n"
"    adr x30, vector_table_el1\n"
"    msr vbar_el1, x30\n"
"\n"
"    /* Call into Rust code. */\n"
"    bl main\n"
"\n"
"    /* Loop forever waiting for interrupts. */\n"
"2:  wfi\n"
"    b 2b\n"
"```"
msgstr ""
"```armasm\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"intrare:\n"
"    /*\n"
"     * 칉nc캒rca탵i 탳i aplica탵i configura탵ia de gestionare a memoriei, "
"preg캒tit캒 pentru a activa MMU 탳i\n"
"     * memoria cache.\n"
"     */\n"
"    adrp x30, idmap\n"
"    msr ttbr0_el1, x30\n"
"\n"
"    mov_i x30, .Lmairval\n"
"    msr mair_el1, x30\n"
"\n"
"    mov_i x30, .Ltcrval\n"
"    /* Copiaz캒 intervalul PA acceptat 칥n TCR_EL1.IPS. */\n"
"    mrs x29, id_aa64mmfr0_el1\n"
"    bfi x30, x29, #32, #4\n"
"\n"
"    msr tcr_el1, x30\n"
"\n"
"    mov_i x30, .Lsctlrval\n"
"\n"
"    /*\n"
"     * Asigur캒-te c캒 tot ceea ce a precedat acest punct s-a finalizat, apoi "
"invalideaz캒 orice\n"
"     * toate intr캒rile TLB locale poten탵ial vechi 칥nainte de a 칥ncepe s캒 fie "
"utilizate.\n"
"     */\n"
"    isb\n"
"    tlbi vmalle1\n"
"    ic iallu\n"
"    dsb nsh\n"
"    isb\n"
"\n"
"    /*\n"
"     * Configura탵i sctlr_el1 pentru a activa MMU 탳i memoria cache 탳i nu "
"continua탵i p칙n캒 c칙nd acest lucru\n"
"     * nu este finalizat캒.\n"
"     */\n"
"    msr sctlr_el1, x30\n"
"    isb\n"
"\n"
"    /* Dezactiveaz캒 captarea accesului 칥n virgul캒 mobil캒 칥n EL1. */\n"
"    mrs x30, cpacr_el1\n"
"    orr x30, x30, #(0x3 << 20)\n"
"    msr cpacr_el1, x30\n"
"    isb\n"
"\n"
"    /* Elimin캒 sec탵iunea bss. */\n"
"    adr_l x29, bss_begin\n"
"    adr_l x30, bss_end\n"
"0: cmp x29, x30\n"
"    b.hs 1f\n"
"    stp xzr, xzr, [x29], #16\n"
"    b 0b\n"
"\n"
"1: /* Preg캒te탳te stiva. */\n"
"    adr_l x30, boot_stack_end\n"
"    mov sp, x30\n"
"\n"
"    /* Seteaz캒 vectorul de excep탵ie. */\n"
"    adr x30, vector_table_el1\n"
"    msr vbar_el1, x30\n"
"\n"
"    /* Apel 칥n codul Rust. */\n"
"    bl main\n"
"\n"
"    /* Bucl캒 ve탳nic캒 칥n a탳teptarea 칥ntreruperilor. */\n"
"2: wfi\n"
"    b 2b\n"
"```"

#: src/bare-metal/aps/entry-point.md
#, fuzzy
msgid ""
"This is the same as it would be for C: initialising the processor state, "
"zeroing the BSS, and setting up the stack pointer."
msgstr ""
"Aceasta este aceea탳i ca 탳i 칥n C: ini탵ializarea st캒rii procesorului, anularea "
"BSS 탳i stabilirea pointerului de stiv캒."

#: src/bare-metal/aps/entry-point.md
#, fuzzy
msgid ""
"The BSS (block starting symbol, for historical reasons) is the part of the "
"object file which containing statically allocated variables which are "
"initialised to zero. They are omitted from the image, to avoid wasting space "
"on zeroes. The compiler assumes that the loader will take care of zeroing "
"them."
msgstr ""
"BSS (simbolul de pornire al blocului, din motive istorice) este partea din "
"fi탳ierul obiect care con탵ine variabilele alocate static care sunt "
"ini탵ializate la zero. Acestea sunt omise din imagine, pentru a se evita "
"risipa de spa탵iu cu zerouri. Compilatorul porne탳te de la premisa c캒 "
"칥nc캒rc캒torul se va ocupa de punerea lor la zero."

#: src/bare-metal/aps/entry-point.md
#, fuzzy
msgid ""
"The BSS may already be zeroed, depending on how memory is initialised and "
"the image is loaded, but we zero it to be sure."
msgstr ""
"Este posibil ca BSS s캒 fie deja zero, 칥n func탵ie de modul 칥n care memoria "
"este ini탵ializat캒 탳i imaginea este 칥nc캒rcat캒, dar trebuie s캒 칥l punem la "
"zero pentru a fi siguri."

#: src/bare-metal/aps/entry-point.md
#, fuzzy
msgid ""
"We need to enable the MMU and cache before reading or writing any memory. If "
"we don't:"
msgstr ""
"Trebuie s캒 activ캒m MMU 탳i memoria cache 칥nainte de a citi sau scrie 칥n "
"memorie. Dac캒 nu o facem:"

#: src/bare-metal/aps/entry-point.md
#, fuzzy
msgid ""
"Unaligned accesses will fault. We build the Rust code for the `aarch64-"
"unknown-none` target which sets `+strict-align` to prevent the compiler "
"generating unaligned accesses, so it should be fine in this case, but this "
"is not necessarily the case in general."
msgstr ""
"Acces캒rile nealiniate vor fi defectuoase. Noi construim codul Rust pentru "
"탵inta `aarch64-unknown-none` care seteaz캒 `+strict-align` pentru a preveni "
"compilatorul s캒 genereze accese nealiniate, deci ar trebui s캒 fie 칥n regul캒 "
"칥n acest caz, dar nu este neap캒rat cazul 칥n general."

#: src/bare-metal/aps/entry-point.md
#, fuzzy
msgid ""
"If it were running in a VM, this can lead to cache coherency issues. The "
"problem is that the VM is accessing memory directly with the cache disabled, "
"while the host has cacheable aliases to the same memory. Even if the host "
"doesn't explicitly access the memory, speculative accesses can lead to cache "
"fills, and then changes from one or the other will get lost when the cache "
"is cleaned or the VM enables the cache. (Cache is keyed by physical address, "
"not VA or IPA.)"
msgstr ""
"Dac캒 ar fi rulat 칥ntr-o ma탳in캒 virtual캒, acest lucru poate duce la probleme "
"de coeren탵캒 a memoriei cache. Problema const캒 칥n faptul c캒 ma탳ina virtual캒 "
"acceseaz캒 memoria direct, cu memoria cache dezactivat캒, 칥n timp ce gazda are "
"alias-uri care pot fi stocate 칥n memoria cache pentru aceea탳i memorie. Chiar "
"dac캒 gazda nu acceseaz캒 칥n mod explicit memoria, acces캒rile speculative pot "
"duce la umplerea memoriei cache, iar apoi modific캒rile de la unul sau de la "
"cel캒lalt se vor pierde atunci c칙nd memoria cache este cur캒탵at캒 sau c칙nd VM "
"activeaz캒 memoria cache. (Memoria cache este codificat캒 칥n func탵ie de adresa "
"fizic캒, nu de VA sau IPA)"

#: src/bare-metal/aps/entry-point.md
#, fuzzy
msgid ""
"For simplicity, we just use a hardcoded pagetable (see `idmap.S`) which "
"identity maps the first 1 GiB of address space for devices, the next 1 GiB "
"for DRAM, and another 1 GiB higher up for more devices. This matches the "
"memory layout that QEMU uses."
msgstr ""
"Pentru simplitate, folosim doar o tabel캒 de pagini codificat캒 (a se vedea "
"`idmap.S`) care mapeaz캒 identitar primul 1 GiB de spa탵iu de adrese pentru "
"dispozitive, urm캒torul 1 GiB pentru DRAM 탳i 칥nc캒 1 GiB mai sus pentru mai "
"multe dispozitive. Acest lucru se potrive탳te cu dispunerea memoriei pe care "
"o folose탳te QEMU."

#: src/bare-metal/aps/entry-point.md
#, fuzzy
msgid ""
"We also set up the exception vector (`vbar_el1`), which we'll see more about "
"later."
msgstr ""
"De asemenea, am configurat vectorul de excep탵ii (`vbar_el1`), despre care "
"vom vedea mai multe mai t칙rziu."

#: src/bare-metal/aps/entry-point.md
#, fuzzy
msgid ""
"All examples this afternoon assume we will be running at exception level 1 "
"(EL1). If you need to run at a different exception level you'll need to "
"modify `entry.S` accordingly."
msgstr ""
"Toate exemplele din aceast캒 dup캒-amiaz캒 presupun c캒 vom func탵iona la nivelul "
"de excep탵ie 1 (EL1). Dac캒 ave탵i nevoie s캒 rula탵i la un alt nivel de "
"excep탵ie, va trebui s캒 modifica탵i `entry.S` 칥n consecin탵캒."

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid "Inline assembly"
msgstr "Ansamblare 칥n linie"

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid ""
"Sometimes we need to use assembly to do things that aren't possible with "
"Rust code. For example, to make an HVC (hypervisor call) to tell the "
"firmware to power off the system:"
msgstr ""
"Uneori trebuie s캒 folosim asamblarea pentru a face lucruri care nu sunt "
"posibile cu codul Rust. De exemplu, pentru a face un apel HVC (hypervisor "
"call) pentru a spune firmware-ului s캒 opreasc캒 sistemul:"

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid ""
"// SAFETY: this only uses the declared registers and doesn't do anything\n"
"    // with memory.\n"
msgstr ""
"// Sigur pentru c캒 acest lucru folose탳te doar registrele declarate 탳i nu "
"face\n"
"    // nimic cu memoria.\n"

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid "\"hvc #0\""
msgstr "\"hvc #0\""

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid "\"w0\""
msgstr "\"w0\""

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid "\"w1\""
msgstr "\"w1\""

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid "\"w2\""
msgstr "\"w2\""

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid "\"w3\""
msgstr "\"w3\""

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid "\"w4\""
msgstr "\"w4\""

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid "\"w5\""
msgstr "\"w5\""

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid "\"w6\""
msgstr "\"w6\""

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid "\"w7\""
msgstr "\"w7\""

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid ""
"(If you actually want to do this, use the [`smccc`](https://crates.io/crates/"
"smccc) crate which has wrappers for all these functions.)"
msgstr ""
"(Dac캒 dori탵i s캒 face탵i acest lucru, folosi탵i cr캒iasa [`smccc`](https://"
"crates.io/crates/smccc) care are 칥nveli탳uri pentru toate aceste func탵ii.)"

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid ""
"PSCI is the Arm Power State Coordination Interface, a standard set of "
"functions to manage system and CPU power states, among other things. It is "
"implemented by EL3 firmware and hypervisors on many systems."
msgstr ""
"PSCI este Interfa탵a de coordonare a st캒rii de alimentare a bra탵ului, un set "
"standard de func탵ii pentru gestionarea st캒rii de alimentare a sistemului 탳i "
"a procesorului, printre altele. Este implementat캒 de firmware-ul EL3 탳i de "
"hipervizoarele de pe multe sisteme."

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid ""
"The `0 => _` syntax means initialise the register to 0 before running the "
"inline assembly code, and ignore its contents afterwards. We need to use "
"`inout` rather than `in` because the call could potentially clobber the "
"contents of the registers."
msgstr ""
"Sintaxa `0 => _` 칥nseamn캒 ini탵ializarea registrului la 0 칥nainte de a rula "
"codul de asamblare 칥n linie 탳i ignorarea con탵inutului acestuia dup캒 aceea. "
"Trebuie s캒 folosim mai degrab캒 `inout` dec칙t `in` deoarece apelul ar putea "
"s캒 distrug캒 con탵inutul registrelor."

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid ""
"This `main` function needs to be `#[no_mangle]` and `extern \"C\"` because "
"it is called from our entry point in `entry.S`."
msgstr ""
"Aceast캒 func탵ie `main` trebuie s캒 fie `#[no_mangle]` 탳i `extern \"C\"` "
"deoarece este apelat캒 din punctul nostru de intrare 칥n `entry.S`."

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid ""
"`_x0``_x3` are the values of registers `x0``x3`, which are conventionally "
"used by the bootloader to pass things like a pointer to the device tree. "
"According to the standard aarch64 calling convention (which is what `extern "
"\"C\"` specifies to use), registers `x0``x7` are used for the first 8 "
"arguments passed to a function, so `entry.S` doesn't need to do anything "
"special except make sure it doesn't change these registers."
msgstr ""
"`_x0`-`_x3` sunt valorile registrelor `x0`-`x3`, care sunt utilizate 칥n mod "
"conven탵ional de c캒tre bootloader pentru a transmite lucruri precum un "
"pointer la arborele de dispozitive. 칉n conformitate cu conven탵ia standard de "
"apelare aarch64 (care este cea pe care `extern \"C\"` specific캒 s캒 o "
"foloseasc캒), registrele `x0`-`x7` sunt folosite pentru primele 8 argumente "
"transmise unei func탵ii, astfel 칥nc칙t `entry.S` nu trebuie s캒 fac캒 nimic "
"special, cu excep탵ia faptului c캒 trebuie s캒 se asigure c캒 nu modific캒 aceste "
"registre."

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid ""
"Run the example in QEMU with `make qemu_psci` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"Rula탵i exemplul 칥n QEMU cu `make qemu_psci` 칥n `src/bare-metal/aps/examples`."

#: src/bare-metal/aps/mmio.md
#, fuzzy
msgid "Volatile memory access for MMIO"
msgstr "Acces la memoria volatil캒 pentru MMIO"

#: src/bare-metal/aps/mmio.md
#, fuzzy
msgid "Use `pointer::read_volatile` and `pointer::write_volatile`."
msgstr "Utiliza탵i `pointer::read_volatile` 탳i `pointer::write_volatile`."

#: src/bare-metal/aps/mmio.md
#, fuzzy
msgid "Never hold a reference."
msgstr "Nu 탵ine탵i niciodat캒 o referin탵캒."

#: src/bare-metal/aps/mmio.md
#, fuzzy
msgid ""
"`addr_of!` lets you get fields of structs without creating an intermediate "
"reference."
msgstr ""
"`addr_of!` v캒 permite s캒 ob탵ine탵i c칙mpurile structurilor f캒r캒 a crea o "
"referin탵캒 intermediar캒."

#: src/bare-metal/aps/mmio.md
#, fuzzy
msgid ""
"Volatile access: read or write operations may have side-effects, so prevent "
"the compiler or hardware from reordering, duplicating or eliding them."
msgstr ""
"Acces volatil: Opera탵iunile de citire sau scriere pot avea efecte secundare, "
"deci 칥mpiedica탵i compilatorul sau hardware-ul s캒 le reordoneze, s캒 le "
"dubleze sau s캒 le eludeze."

#: src/bare-metal/aps/mmio.md
#, fuzzy
msgid ""
"Usually if you write and then read, e.g. via a mutable reference, the "
"compiler may assume that the value read is the same as the value just "
"written, and not bother actually reading memory."
msgstr ""
"De obicei, dac캒 scrie탵i 탳i apoi citi탵i, de exemplu, prin intermediul unei "
"referin탵e mutabile, compilatorul poate presupune c캒 valoarea citit캒 este "
"aceea탳i cu cea care tocmai a fost scris캒 탳i nu se mai obose탳te s캒 citeasc캒 "
"efectiv memoria."

#: src/bare-metal/aps/mmio.md
#, fuzzy
msgid ""
"Some existing crates for volatile access to hardware do hold references, but "
"this is unsound. Whenever a reference exist, the compiler may choose to "
"dereference it."
msgstr ""
"Unele cutii existente pentru accesul volatil la hardware con탵in referin탵e, "
"dar acest lucru nu este corect. Ori de c칙te ori exist캒 o referin탵캒, "
"compilatorul poate alege s캒 o deregleze."

#: src/bare-metal/aps/mmio.md
#, fuzzy
msgid ""
"Use the `addr_of!` macro to get struct field pointers from a pointer to the "
"struct."
msgstr ""
"Utiliza탵i macroul `addr_of!` pentru a ob탵ine pointeri de c칙mpuri de "
"structur캒 dintr-un pointer la structur캒."

#: src/bare-metal/aps/uart.md
#, fuzzy
msgid "Let's write a UART driver"
msgstr "S캒 scriem un driver UART"

#: src/bare-metal/aps/uart.md
#, fuzzy
msgid ""
"The QEMU 'virt' machine has a [PL011](https://developer.arm.com/"
"documentation/ddi0183/g) UART, so let's write a driver for that."
msgstr ""
"Ma탳ina QEMU 'virt' are o UART [PL011](https://developer.arm.com/"
"documentation/ddi0183/g), a탳a c캒 haide탵i s캒 scriem un driver pentru aceasta."

#: src/bare-metal/aps/uart.md
#, fuzzy
msgid "/// Minimal driver for a PL011 UART.\n"
msgstr "/// Driver minim pentru o UART PL011.\n"

#: src/bare-metal/aps/uart.md src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid ""
"/// Constructs a new instance of the UART driver for a PL011 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the 8 MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
msgstr ""
"/// Construie탳te o nou캒 instan탵캒 a driverului UART pentru un dispozitiv "
"PL011 la nivelul\n"
"    /// adresa de baz캒 dat캒.\n"
"    ///\n"
"    /// # Siguran탵캒\n"
"    ///\n"
"    /// Adresa de baz캒 dat캒 trebuie s캒 indice cele 8 registre de control "
"MMIO ale unui dispozitiv de tip\n"
"    /// PL011, care trebuie s캒 fie mapate 칥n spa탵iul de adrese al "
"procesului\n"
"    /// ca memorie a dispozitivului 탳i s캒 nu aib캒 alte pseudonime.\n"

#: src/bare-metal/aps/uart.md src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid "/// Writes a single byte to the UART.\n"
msgstr "/// Scrie un singur octet pe UART.\n"

#: src/bare-metal/aps/uart.md src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid "// Wait until there is room in the TX buffer.\n"
msgstr "// A탳tepta탵i p칙n캒 c칙nd exist캒 spa탵iu 칥n bufferul TX.\n"

#: src/bare-metal/aps/uart.md
#, fuzzy
msgid ""
"// SAFETY: We know that the base address points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
msgstr ""
"// Sigur, deoarece 탳tim c캒 adresa de baz캒 indic캒 controlul\n"
"        // registrele de control ale unui dispozitiv PL011 care este mapat "
"corespunz캒tor.\n"

#: src/bare-metal/aps/uart.md src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid "// Write to the TX buffer.\n"
msgstr "// Scrie탵i 칥n bufferul TX.\n"

#: src/bare-metal/aps/uart.md src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid "// Wait until the UART is no longer busy.\n"
msgstr "// A탳tepta탵i p칙n캒 c칙nd UART nu mai este ocupat캒.\n"

#: src/bare-metal/aps/uart.md
#, fuzzy
msgid ""
"Note that `Uart::new` is unsafe while the other methods are safe. This is "
"because as long as the caller of `Uart::new` guarantees that its safety "
"requirements are met (i.e. that there is only ever one instance of the "
"driver for a given UART, and nothing else aliasing its address space), then "
"it is always safe to call `write_byte` later because we can assume the "
"necessary preconditions."
msgstr ""
"Re탵ine탵i c캒 `Uart::new` este nesigur캒, 칥n timp ce celelalte metode sunt "
"sigure. Acest lucru se datoreaz캒 faptului c캒, at칙ta timp c칙t apelantul lui "
"`Uart::new` garanteaz캒 c캒 cerin탵ele sale de siguran탵캒 sunt 칥ndeplinite (de "
"exemplu, c캒 exist캒 doar o singur캒 instan탵캒 a driverului pentru o anumit캒 "
"UART 탳i nimic altceva care s캒 se al캒ture spa탵iului s캒u de adrese), atunci "
"este 칥ntotdeauna sigur s캒 apel캒m mai t칙rziu `write_byte`, deoarece putem "
"presupune condi탵iile prealabile necesare."

#: src/bare-metal/aps/uart.md
#, fuzzy
msgid ""
"We could have done it the other way around (making `new` safe but "
"`write_byte` unsafe), but that would be much less convenient to use as every "
"place that calls `write_byte` would need to reason about the safety"
msgstr ""
"Am fi putut face invers (f캒c칙nd `new` sigur, dar `write_byte` nesigur), dar "
"ar fi fost mult mai pu탵in convenabil de utilizat, deoarece fiecare loc care "
"apeleaz캒 `write_byte` ar trebui s캒 se g칙ndeasc캒 la siguran탵a lui `write_byte`"

#: src/bare-metal/aps/uart.md
#, fuzzy
msgid ""
"This is a common pattern for writing safe wrappers of unsafe code: moving "
"the burden of proof for soundness from a large number of places to a smaller "
"number of places."
msgstr ""
"Acesta este un model comun pentru scrierea de 칥nveli탳uri sigure pentru cod "
"nesigur: mutarea sarcinii de a dovedi soliditatea de la un num캒r mare de "
"locuri la un num캒r mai mic de locuri."

#: src/bare-metal/aps/uart/traits.md
#, fuzzy
msgid "More traits"
msgstr "Mai multe tr캒s캒turi"

#: src/bare-metal/aps/uart/traits.md
#, fuzzy
msgid ""
"We derived the `Debug` trait. It would be useful to implement a few more "
"traits too."
msgstr ""
"Am derivat tr캒s캒tura `Debug`. Ar fi util s캒 implement캒m 탳i alte c칙teva "
"tr캒s캒turi."

#: src/bare-metal/aps/uart/traits.md
#, fuzzy
msgid ""
"// SAFETY: `Uart` just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
msgstr ""
"// Sigur, deoarece con탵ine doar un pointer c캒tre memoria dispozitivului, "
"care poate fi\n"
"// accesat캒 din orice context.\n"

#: src/bare-metal/aps/uart/traits.md
#, fuzzy
msgid ""
"Implementing `Write` lets us use the `write!` and `writeln!` macros with our "
"`Uart` type."
msgstr ""
"Implementarea `Write` ne permite s캒 folosim macrogramele `write!` 탳i "
"`writeln!` cu tipul nostru `Uart`."

#: src/bare-metal/aps/uart/traits.md
#, fuzzy
msgid ""
"Run the example in QEMU with `make qemu_minimal` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"Rula탵i exemplul 칥n QEMU cu `make qemu_minimal` 칥n `src/bare-metal/aps/"
"examples`."

#: src/bare-metal/aps/better-uart.md
#, fuzzy
msgid "A better UART driver"
msgstr "Un driver UART mai bun"

#: src/bare-metal/aps/better-uart.md
#, fuzzy
msgid ""
"The PL011 actually has [a bunch more registers](https://developer.arm.com/"
"documentation/ddi0183/g/programmers-model/summary-of-registers), and adding "
"offsets to construct pointers to access them is error-prone and hard to "
"read. Plus, some of them are bit fields which would be nice to access in a "
"structured way."
msgstr ""
"PL011 are de fapt [o gr캒mad캒 de registre](https://developer.arm.com/"
"documentation/ddi0183/g/programmers-model/summary-of-registers), iar "
"ad캒ugarea de offset-uri pentru a construi pointeri pentru a le accesa este "
"predispus캒 la erori 탳i greu de citit. 칉n plus, unele dintre ele sunt c칙mpuri "
"de bi탵i care ar fi frumos s캒 fie accesate 칥ntr-un mod structurat."

#: src/bare-metal/aps/better-uart.md
msgid "Offset"
msgstr "Decalaj"

#: src/bare-metal/aps/better-uart.md
msgid "Register name"
msgstr "Nume registru"

#: src/bare-metal/aps/better-uart.md
msgid "Width"
msgstr "L캒콖ime"

#: src/bare-metal/aps/better-uart.md
msgid "0x00"
msgstr "0x00"

#: src/bare-metal/aps/better-uart.md
msgid "DR"
msgstr "DR"

#: src/bare-metal/aps/better-uart.md
msgid "12"
msgstr "12"

#: src/bare-metal/aps/better-uart.md
msgid "0x04"
msgstr "0x04"

#: src/bare-metal/aps/better-uart.md
msgid "RSR"
msgstr "RSR"

#: src/bare-metal/aps/better-uart.md
msgid "0x18"
msgstr "0x18"

#: src/bare-metal/aps/better-uart.md
msgid "FR"
msgstr "V"

#: src/bare-metal/aps/better-uart.md
msgid "9"
msgstr "9"

#: src/bare-metal/aps/better-uart.md
msgid "0x20"
msgstr "0x20"

#: src/bare-metal/aps/better-uart.md
msgid "ILPR"
msgstr "ILPR"

#: src/bare-metal/aps/better-uart.md
msgid "0x24"
msgstr "0x24"

#: src/bare-metal/aps/better-uart.md
msgid "IBRD"
msgstr "IBRD"

#: src/bare-metal/aps/better-uart.md
msgid "16"
msgstr "16"

#: src/bare-metal/aps/better-uart.md
msgid "0x28"
msgstr "0x28"

#: src/bare-metal/aps/better-uart.md
msgid "FBRD"
msgstr "FBRD"

#: src/bare-metal/aps/better-uart.md
msgid "0x2c"
msgstr "0x2c"

#: src/bare-metal/aps/better-uart.md
msgid "LCR_H"
msgstr "LCR_H"

#: src/bare-metal/aps/better-uart.md
msgid "0x30"
msgstr "0x30"

#: src/bare-metal/aps/better-uart.md
msgid "CR"
msgstr "GD"

#: src/bare-metal/aps/better-uart.md
msgid "0x34"
msgstr "0x34"

#: src/bare-metal/aps/better-uart.md
msgid "IFLS"
msgstr "IFLS"

#: src/bare-metal/aps/better-uart.md
msgid "0x38"
msgstr "0x38"

#: src/bare-metal/aps/better-uart.md
msgid "IMSC"
msgstr "IMSC"

#: src/bare-metal/aps/better-uart.md
msgid "11"
msgstr "11"

#: src/bare-metal/aps/better-uart.md
msgid "0x3c"
msgstr "0x3c"

#: src/bare-metal/aps/better-uart.md
msgid "RIS"
msgstr "RIS"

#: src/bare-metal/aps/better-uart.md
msgid "0x40"
msgstr "0x40"

#: src/bare-metal/aps/better-uart.md
msgid "MIS"
msgstr "MIS"

#: src/bare-metal/aps/better-uart.md
msgid "0x44"
msgstr "0x44"

#: src/bare-metal/aps/better-uart.md
msgid "ICR"
msgstr "ICR"

#: src/bare-metal/aps/better-uart.md
msgid "0x48"
msgstr "0x48"

#: src/bare-metal/aps/better-uart.md
msgid "DMACR"
msgstr "DMACR"

#: src/bare-metal/aps/better-uart.md
#, fuzzy
msgid "There are also some ID registers which have been omitted for brevity."
msgstr ""
"Exist캒, de asemenea, unele registre de identificare care au fost omise "
"pentru a fi mai scurte."

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid ""
"The [`bitflags`](https://crates.io/crates/bitflags) crate is useful for "
"working with bitflags."
msgstr ""
"Cr캒iasa [`bitflags`](https://crates.io/crates/bitflags) este util캒 pentru a "
"lucra cu bitflags."

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Flags from the UART flag register.\n"
msgstr "/// Semnalizatoare din registrul de semnalizare UART.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Clear to send.\n"
msgstr "/// Liber la trimitere.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Data set ready.\n"
msgstr "/// Set de date preg캒tit.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Data carrier detect.\n"
msgstr "/// Detectarea purt캒torului de date.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// UART busy transmitting data.\n"
msgstr "/// UART ocupat캒 cu transmiterea de date.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Receive FIFO is empty.\n"
msgstr "/// Receive FIFO este gol.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Transmit FIFO is full.\n"
msgstr "/// Transmit FIFO este plin.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Receive FIFO is full.\n"
msgstr "/// Receive FIFO este plin.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Transmit FIFO is empty.\n"
msgstr "/// Transmit FIFO este gol.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Ring indicator.\n"
msgstr "/// Indicator de inel.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid ""
"The `bitflags!` macro creates a newtype something like `Flags(u16)`, along "
"with a bunch of method implementations to get and set flags."
msgstr ""
"Macroul `bitflags!` creeaz캒 un nou tip, ceva de genul `Flags(u16)`, 칥mpreun캒 "
"cu o serie de implement캒ri de metode pentru a ob탵ine 탳i seta steaguri."

#: src/bare-metal/aps/better-uart/registers.md
#, fuzzy
msgid "Multiple registers"
msgstr "Registre multiple"

#: src/bare-metal/aps/better-uart/registers.md
#, fuzzy
msgid ""
"We can use a struct to represent the memory layout of the UART's registers."
msgstr ""
"Putem folosi o structur캒 pentru a reprezenta structura de memorie a "
"registrelor UART."

#: src/bare-metal/aps/better-uart/registers.md
#, fuzzy
msgid ""
"[`#[repr(C)]`](https://doc.rust-lang.org/reference/type-layout.html#the-c-"
"representation) tells the compiler to lay the struct fields out in order, "
"following the same rules as C. This is necessary for our struct to have a "
"predictable layout, as default Rust representation allows the compiler to "
"(among other things) reorder fields however it sees fit."
msgstr ""
"[`#[repr(C)]`](https://doc.rust-lang.org/reference/type-layout.html#the-c-"
"representation) 칥i spune compilatorului s캒 a탳eze c칙mpurile structurii 칥n "
"ordine, urm칙nd acelea탳i reguli ca 탳i 칥n C. Acest lucru este necesar pentru "
"ca structura noastr캒 s캒 aib캒 o dispunere previzibil캒, deoarece reprezentarea "
"implicit캒 Rust permite compilatorului (printre altele) s캒 reordoneze "
"c칙mpurile dup캒 cum crede de cuviin탵캒."

#: src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid "Now let's use the new `Registers` struct in our driver."
msgstr "Acum s캒 folosim noua structur캒 `Registers` 칥n driverul nostru."

#: src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid "/// Driver for a PL011 UART.\n"
msgstr "/// Driver pentru o UART PL011.\n"

#: src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid ""
"// SAFETY: We know that self.registers points to the control registers\n"
"        // of a PL011 device which is appropriately mapped.\n"
msgstr ""
"// Sigur, deoarece 탳tim c캒 self.registers indic캒 controlul\n"
"        // registre ale unui dispozitiv PL011 care este mapat 칥n mod "
"corespunz캒tor.\n"

#: src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid ""
"/// Reads and returns a pending byte, or `None` if nothing has been\n"
"    /// received.\n"
msgstr ""
"/// Cite탳te 탳i returneaz캒 un octet 칥n a탳teptare, sau `None` dac캒 nu a fost "
"nimic\n"
"    /// primit.\n"

#: src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid ""
"// SAFETY: We know that self.registers points to the control\n"
"            // registers of a PL011 device which is appropriately mapped.\n"
msgstr ""
"// Sigur, deoarece 탳tim c캒 self.registers indic캒 controlul\n"
"        // registre ale unui dispozitiv PL011 care este mapat 칥n mod "
"corespunz캒tor.\n"

#: src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid "// TODO: Check for error conditions in bits 8-11.\n"
msgstr "// TODO: Verifica탵i dac캒 exist캒 condi탵ii de eroare 칥n bi탵ii 8-11.\n"

#: src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid ""
"Note the use of `addr_of!` / `addr_of_mut!` to get pointers to individual "
"fields without creating an intermediate reference, which would be unsound."
msgstr ""
"Re탵ine탵i utilizarea lui `addr_of!` / `addr_of_mut!` pentru a ob탵ine pointeri "
"la c칙mpuri individuale f캒r캒 a crea o referin탵캒 intermediar캒, ceea ce ar fi "
"nesigur."

#: src/bare-metal/aps/better-uart/using.md src/bare-metal/aps/logging/using.md
#, fuzzy
msgid "Using it"
msgstr "Folosirea Cargo"

#: src/bare-metal/aps/better-uart/using.md
#, fuzzy
msgid ""
"Let's write a small program using our driver to write to the serial console, "
"and echo incoming bytes."
msgstr ""
"S캒 scriem un mic program care utilizeaz캒 driverul nostru pentru a scrie pe "
"consola serial캒 탳i pentru a reda ecourile octe탵ilor care intr캒."

#: src/bare-metal/aps/better-uart/using.md src/bare-metal/aps/logging/using.md
#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Base address of the primary PL011 UART.\n"
msgstr "/// Adresa de baz캒 a UART PL011 primar캒.\n"

#: src/bare-metal/aps/better-uart/using.md src/bare-metal/aps/logging/using.md
#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"// SAFETY: `PL011_BASE_ADDRESS` is the base address of a PL011 device, and\n"
"    // nothing else accesses that address range.\n"
msgstr ""
"// Sigur, deoarece `PL011_BASE_ADDRESS` este adresa de baz캒 a unui "
"dispozitiv PL011,\n"
"    // 탳i nimic altceva nu acceseaz캒 acest interval de adrese.\n"

#: src/bare-metal/aps/better-uart/using.md src/bare-metal/aps/logging/using.md
#, fuzzy
msgid "\"main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})\""
msgstr "\"main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})\""

#: src/bare-metal/aps/better-uart/using.md
#, fuzzy
msgid "b'\\r'"
msgstr "b'\\r'"

#: src/bare-metal/aps/better-uart/using.md
#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid "b'\\n'"
msgstr "b'\\n'"

#: src/bare-metal/aps/better-uart/using.md
#, fuzzy
msgid "b'q'"
msgstr "b'q'"

#: src/bare-metal/aps/better-uart/using.md
#, fuzzy
msgid "\"Bye!\""
msgstr "\"La revedere!\""

#: src/bare-metal/aps/better-uart/using.md
#, fuzzy
msgid ""
"As in the [inline assembly](../inline-assembly.md) example, this `main` "
"function is called from our entry point code in `entry.S`. See the speaker "
"notes there for details."
msgstr ""
"Ca 탳i 칥n exemplul [inline assembly](../inline-assembly.md), aceast캒 func탵ie "
"`main` este apelat캒 din codul punctului de intrare 칥n `entry.S`. Pentru "
"detalii, consulta탵i notele vorbitorului de acolo."

#: src/bare-metal/aps/better-uart/using.md
#, fuzzy
msgid ""
"Run the example in QEMU with `make qemu` under `src/bare-metal/aps/examples`."
msgstr ""
"Rula탵i exemplul 칥n QEMU cu `make qemu` 칥n `src/bare-metal/aps/examples`."

#: src/bare-metal/aps/logging.md
#, fuzzy
msgid ""
"It would be nice to be able to use the logging macros from the [`log`]"
"(https://crates.io/crates/log) crate. We can do this by implementing the "
"`Log` trait."
msgstr ""
"Ar fi frumos s캒 putem folosi macrogramele de logare de la [`log`](https://"
"crates.io/crates/log) crate. Putem face acest lucru prin implementarea "
"tr캒s캒turii `Log`."

#: src/bare-metal/aps/logging.md
#, fuzzy
msgid "\"[{}] {}\""
msgstr "\"[{}] {}\""

#: src/bare-metal/aps/logging.md
#, fuzzy
msgid "/// Initialises UART logger.\n"
msgstr "/// Ini탵ializeaz캒 loggerul UART.\n"

#: src/bare-metal/aps/logging.md
#, fuzzy
msgid ""
"The unwrap in `log` is safe because we initialise `LOGGER` before calling "
"`set_logger`."
msgstr ""
"Desf캒탳urarea 칥n `log` este sigur캒 deoarece ini탵ializ캒m `LOGGER` 칥nainte de a "
"apela `set_logger`."

#: src/bare-metal/aps/logging/using.md
#, fuzzy
msgid "We need to initialise the logger before we use it."
msgstr "Trebuie s캒 ini탵ializ캒m loggerul 칥nainte de a-l utiliza."

#: src/bare-metal/aps/logging/using.md
#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "\"{info}\""
msgstr "\"{info}\""

#: src/bare-metal/aps/logging/using.md
#, fuzzy
msgid "Note that our panic handler can now log details of panics."
msgstr ""
"Re탵ine탵i c캒 gestionarul nostru de panic캒 poate acum s캒 칥nregistreze "
"detaliile panicii."

#: src/bare-metal/aps/logging/using.md
#, fuzzy
msgid ""
"Run the example in QEMU with `make qemu_logger` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"Rula탵i exemplul 칥n QEMU cu `make qemu_logger` 칥n `src/bare-metal/aps/"
"examples`."

#: src/bare-metal/aps/exceptions.md
#, fuzzy
msgid ""
"AArch64 defines an exception vector table with 16 entries, for 4 types of "
"exceptions (synchronous, IRQ, FIQ, SError) from 4 states (current EL with "
"SP0, current EL with SPx, lower EL using AArch64, lower EL using AArch32). "
"We implement this in assembly to save volatile registers to the stack before "
"calling into Rust code:"
msgstr ""
"AArch64 define탳te un tabel de vectori de excep탵ii cu 16 intr캒ri, pentru 4 "
"tipuri de excep탵ii (sincron캒, IRQ, FIQ, SError) din 4 st캒ri (EL curent cu "
"SP0, EL curent cu SPx, EL inferior utiliz칙nd AArch64, EL inferior utiliz칙nd "
"AArch32). Implement캒m acest lucru 칥n asamblare pentru a salva registrele "
"volatile pe stiv캒 칥nainte de a apela 칥n codul Rust:"

#: src/bare-metal/aps/exceptions.md
#, fuzzy
msgid "EL is exception level; all our examples this afternoon run in EL1."
msgstr ""
"EL reprezint캒 nivelul de excep탵ie; toate exemplele noastre din aceast캒 dup캒-"
"amiaz캒 ruleaz캒 칥n EL1."

#: src/bare-metal/aps/exceptions.md
#, fuzzy
msgid ""
"For simplicity we aren't distinguishing between SP0 and SPx for the current "
"EL exceptions, or between AArch32 and AArch64 for the lower EL exceptions."
msgstr ""
"Pentru simplificare, nu facem distinc탵ie 칥ntre SP0 탳i SPx pentru excep탵iile "
"EL curente, sau 칥ntre AArch32 탳i AArch64 pentru excep탵iile EL inferioare."

#: src/bare-metal/aps/exceptions.md
#, fuzzy
msgid ""
"For this example we just log the exception and power down, as we don't "
"expect any of them to actually happen."
msgstr ""
"Pentru acest exemplu, ne limit캒m la 칥nregistrarea excep탵iei 탳i la oprirea "
"aliment캒rii, deoarece nu ne a탳tept캒m ca vreuna dintre acestea s캒 se 칥nt칙mple."

#: src/bare-metal/aps/exceptions.md
#, fuzzy
msgid ""
"We can think of exception handlers and our main execution context more or "
"less like different threads. [`Send` and `Sync`](../../concurrency/send-sync."
"md) will control what we can share between them, just like with threads. For "
"example, if we want to share some value between exception handlers and the "
"rest of the program, and it's `Send` but not `Sync`, then we'll need to wrap "
"it in something like a `Mutex` and put it in a static."
msgstr ""
"Ne putem g칙ndi la gestionarii de excep탵ii 탳i la contextul nostru principal "
"de execu탵ie mai mult sau mai pu탵in ca la fire diferite. [`Send` 탳i `Sync`]"
"(../../concurrency/send-sync.md) vor controla ceea ce putem partaja 칥ntre "
"ele, la fel ca 칥n cazul firelor de execu탵ie. De exemplu, dac캒 dorim s캒 "
"partaj캒m o anumit캒 valoare 칥ntre gestionarii de excep탵ii 탳i restul "
"programului, iar aceasta este `Send`, dar nu `Sync`, atunci va trebui s캒 o "
"칥nf캒탳ur캒m 칥n ceva de genul `Mutex` 탳i s캒 o punem 칥ntr-o static캒."

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid "[oreboot](https://github.com/oreboot/oreboot)"
msgstr "[oreboot](https://github.com/oreboot/oreboot)"

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid "\"coreboot without the C\""
msgstr "\"coreboot f캒r캒 C\""

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid "Supports x86, aarch64 and RISC-V."
msgstr "Suport캒 x86, aarch64 탳i RISC-V."

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid "Relies on LinuxBoot rather than having many drivers itself."
msgstr "Se bazeaz캒 pe LinuxBoot 칥n loc s캒 aib캒 multe drivere."

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid ""
"[Rust RaspberryPi OS tutorial](https://github.com/rust-embedded/rust-"
"raspberrypi-OS-tutorials)"
msgstr ""
"[Tutorial Rust RaspberryPi OS](https://github.com/rust-embedded/rust-"
"raspberrypi-OS-tutorials)"

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid ""
"Initialisation, UART driver, simple bootloader, JTAG, exception levels, "
"exception handling, page tables"
msgstr ""
"Ini탵ializare, driver UART, bootloader simplu, JTAG, niveluri de excep탵ie, "
"tratarea excep탵iilor, tabele de pagini"

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid ""
"Some dodginess around cache maintenance and initialisation in Rust, not "
"necessarily a good example to copy for production code."
msgstr ""
"Unele dificult캒탵i 칥n ceea ce prive탳te 칥ntre탵inerea 탳i ini탵ializarea cache-"
"ului 칥n Rust, nu neap캒rat un exemplu bun de copiat pentru codul de produc탵ie."

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid "[`cargo-call-stack`](https://crates.io/crates/cargo-call-stack)"
msgstr "[`cargo-call-stack`](https://crates.io/crates/cargo-call-stack)"

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid "Static analysis to determine maximum stack usage."
msgstr "Analiza static캒 pentru a determina utilizarea maxim캒 a stivei."

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid ""
"The RaspberryPi OS tutorial runs Rust code before the MMU and caches are "
"enabled. This will read and write memory (e.g. the stack). However:"
msgstr ""
"Tutorialul RaspberryPi OS ruleaz캒 codul Rust 칥nainte ca MMU 탳i memoria cache "
"s캒 fie activate. Aceasta va citi 탳i va scrie 칥n memorie (de exemplu, stiva). "
"Cu toate acestea:"

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid ""
"Without the MMU and cache, unaligned accesses will fault. It builds with "
"`aarch64-unknown-none` which sets `+strict-align` to prevent the compiler "
"generating unaligned accesses so it should be alright, but this is not "
"necessarily the case in general."
msgstr ""
"F캒r캒 MMU 탳i memoria cache, acces캒rile nealiniate vor e탳ua. Se construie탳te "
"cu `aarch64-unknown-none`, care seteaz캒 `+strict-align` pentru a 칥mpiedica "
"compilatorul s캒 genereze accese nealiniate, deci ar trebui s캒 fie 칥n regul캒, "
"dar acest lucru nu este neap캒rat valabil 칥n general."

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid ""
"If it were running in a VM, this can lead to cache coherency issues. The "
"problem is that the VM is accessing memory directly with the cache disabled, "
"while the host has cacheable aliases to the same memory. Even if the host "
"doesn't explicitly access the memory, speculative accesses can lead to cache "
"fills, and then changes from one or the other will get lost. Again this is "
"alright in this particular case (running directly on the hardware with no "
"hypervisor), but isn't a good pattern in general."
msgstr ""
"Dac캒 ar fi rulat 칥ntr-o ma탳in캒 virtual캒, acest lucru poate duce la probleme "
"de coeren탵캒 a memoriei cache. Problema const캒 칥n faptul c캒 ma탳ina virtual캒 "
"acceseaz캒 memoria direct, cu memoria cache dezactivat캒, 칥n timp ce gazda are "
"alias-uri care pot fi stocate 칥n memoria cache pentru aceea탳i memorie. Chiar "
"dac캒 gazda nu acceseaz캒 칥n mod explicit memoria, acces캒rile speculative pot "
"duce la umplerea cache-ului, iar apoi modific캒rile de la unul sau de la "
"cel캒lalt se vor pierde. Din nou, acest lucru este 칥n regul캒 칥n acest caz "
"particular (care ruleaz캒 direct pe hardware f캒r캒 hipervizor), dar nu este un "
"model bun 칥n general."

#: src/bare-metal/useful-crates.md
msgid "Useful crates"
msgstr "L캒zi (crates) utile"

#: src/bare-metal/useful-crates.md
#, fuzzy
msgid ""
"We'll go over a few crates which solve some common problems in bare-metal "
"programming."
msgstr ""
"Vom trece 칥n revist캒 c칙teva crates care rezolv캒 unele probleme comune 칥n "
"programarea bare-metal."

#: src/bare-metal/useful-crates/zerocopy.md
#, fuzzy
msgid ""
"The [`zerocopy`](https://docs.rs/zerocopy/) crate (from Fuchsia) provides "
"traits and macros for safely converting between byte sequences and other "
"types."
msgstr ""
"Cr캒iasa [`zerocopy`](https://docs.rs/zerocopy/) (din Fuchsia) ofer캒 "
"tr캒s캒turi 탳i macro-uri pentru conversia 칥n siguran탵캒 칥ntre secven탵e de "
"octe탵i 탳i alte tipuri."

#: src/bare-metal/useful-crates/zerocopy.md
#, fuzzy
msgid ""
"This is not suitable for MMIO (as it doesn't use volatile reads and writes), "
"but can be useful for working with structures shared with hardware e.g. by "
"DMA, or sent over some external interface."
msgstr ""
"Acest lucru nu este potrivit pentru MMIO (deoarece nu utilizeaz캒 citiri 탳i "
"scrieri volatile), dar poate fi util pentru lucrul cu structuri partajate cu "
"hardware, de exemplu prin DMA, sau trimise prin intermediul unei interfe탵e "
"externe."

#: src/bare-metal/useful-crates/zerocopy.md
#, fuzzy
msgid ""
"`FromBytes` can be implemented for types for which any byte pattern is "
"valid, and so can safely be converted from an untrusted sequence of bytes."
msgstr ""
"`FromBytes` poate fi implementat pentru tipurile pentru care orice model de "
"octe탵i este valabil 탳i, prin urmare, poate fi convertit 칥n siguran탵캒 dintr-o "
"secven탵캒 de octe탵i nesigur캒."

#: src/bare-metal/useful-crates/zerocopy.md
#, fuzzy
msgid ""
"Attempting to derive `FromBytes` for these types would fail, because "
"`RequestType` doesn't use all possible u32 values as discriminants, so not "
"all byte patterns are valid."
msgstr ""
"칉ncercarea de a deriva `FromBytes` pentru aceste tipuri ar e탳ua, deoarece "
"`RequestType` nu utilizeaz캒 toate valorile u32 posibile ca discriminan탵i, "
"astfel 칥nc칙t nu toate modelele de octe탵i sunt valide."

#: src/bare-metal/useful-crates/zerocopy.md
#, fuzzy
msgid ""
"`zerocopy::byteorder` has types for byte-order aware numeric primitives."
msgstr ""
"`zerocopy::byteorder` are tipuri pentru primitive numerice care cunosc "
"ordinea octe탵ilor."

#: src/bare-metal/useful-crates/zerocopy.md
#, fuzzy
msgid ""
"Run the example with `cargo run` under `src/bare-metal/useful-crates/"
"zerocopy-example/`. (It won't run in the Playground because of the crate "
"dependency.)"
msgstr ""
"Rula탵i exemplul cu `cargo run` 칥n `src/bare-metal/useful-crates/zerocopy-"
"example/`. (Nu va rula 칥n Playground din cauza dependen탵ei de crate)"

#: src/bare-metal/useful-crates/aarch64-paging.md
#, fuzzy
msgid ""
"The [`aarch64-paging`](https://crates.io/crates/aarch64-paging) crate lets "
"you create page tables according to the AArch64 Virtual Memory System "
"Architecture."
msgstr ""
"Cr캒iasa [`aarch64-paging`](https://crates.io/crates/aarch64-paging) v캒 "
"permite s캒 crea탵i tabele de pagini 칥n conformitate cu arhitectura sistemului "
"de memorie virtual캒 AArch64."

#: src/bare-metal/useful-crates/aarch64-paging.md
#, fuzzy
msgid "// Create a new page table with identity mapping.\n"
msgstr "// Crea탵i o nou캒 tabel캒 de pagini cu coresponden탵캒 de identitate.\n"

#: src/bare-metal/useful-crates/aarch64-paging.md
#, fuzzy
msgid "// Map a 2 MiB region of memory as read-only.\n"
msgstr ""
"// Maparea unei regiuni de 2 MiB de memorie ca fiind numai pentru citire.\n"

#: src/bare-metal/useful-crates/aarch64-paging.md
#, fuzzy
msgid "// Set `TTBR0_EL1` to activate the page table.\n"
msgstr "// Seta탵i `TTBR0_EL1` pentru a activa tabelul de pagini.\n"

#: src/bare-metal/useful-crates/aarch64-paging.md
#, fuzzy
msgid ""
"For now it only supports EL1, but support for other exception levels should "
"be straightforward to add."
msgstr ""
"Deocamdat캒, accept캒 doar EL1, dar ar trebui s캒 fie u탳or de ad캒ugat suportul "
"pentru alte niveluri de excep탵ie."

#: src/bare-metal/useful-crates/aarch64-paging.md
#, fuzzy
msgid ""
"This is used in Android for the [Protected VM Firmware](https://cs.android."
"com/android/platform/superproject/+/master:packages/modules/Virtualization/"
"pvmfw/)."
msgstr ""
"Aceasta este utilizat캒 칥n Android pentru [Protected VM Firmware] (https://cs."
"android.com/android/platform/superproject/+/master:packages/modules/"
"Virtualization/pvmfw/)."

#: src/bare-metal/useful-crates/aarch64-paging.md
#, fuzzy
msgid ""
"There's no easy way to run this example, as it needs to run on real hardware "
"or under QEMU."
msgstr ""
"Nu exist캒 o modalitate u탳oar캒 de a rula acest exemplu, deoarece trebuie s캒 "
"ruleze pe hardware real sau 칥n QEMU."

#: src/bare-metal/useful-crates/buddy_system_allocator.md
#, fuzzy
msgid ""
"[`buddy_system_allocator`](https://crates.io/crates/buddy_system_allocator) "
"is a third-party crate implementing a basic buddy system allocator. It can "
"be used both for [`LockedHeap`](https://docs.rs/buddy_system_allocator/0.9.0/"
"buddy_system_allocator/struct.LockedHeap.html) implementing [`GlobalAlloc`]"
"(https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html) so you can use "
"the standard `alloc` crate (as we saw [before](../alloc.md)), or for "
"allocating other address space. For example, we might want to allocate MMIO "
"space for PCI BARs:"
msgstr ""
"[`buddy_system_allocator`](https://crates.io/crates/buddy_system_allocator) "
"este o cr캒ias캒 ter탵캒 parte care implementeaz캒 un alocator de baz캒 pentru "
"sistemul de prieteni. Acesta poate fi utilizat at칙t pentru [`LockedHeap`]"
"(https://docs.rs/buddy_system_allocator/0.9.0/buddy_system_allocator/struct."
"LockedHeap.html) care implementeaz캒 [`GlobalAlloc`](https://doc.rust-lang."
"org/core/alloc/trait.GlobalAlloc.html), astfel 칥nc칙t s캒 pute탵i utiliza crate-"
"ul standard `alloc` (a탳a cum am v캒zut [칥nainte](../alloc.md)), c칙t 탳i pentru "
"alocarea altor spa탵ii de adrese. De exemplu, am putea dori s캒 aloc캒m spa탵iu "
"MMIO pentru BAR-uri PCI:"

#: src/bare-metal/useful-crates/buddy_system_allocator.md
#, fuzzy
msgid "PCI BARs always have alignment equal to their size."
msgstr "BAR-urile PCI au 칥ntotdeauna o aliniere egal캒 cu dimensiunea lor."

#: src/bare-metal/useful-crates/buddy_system_allocator.md
#, fuzzy
msgid ""
"Run the example with `cargo run` under `src/bare-metal/useful-crates/"
"allocator-example/`. (It won't run in the Playground because of the crate "
"dependency.)"
msgstr ""
"Rula탵i exemplul cu `cargo run` 칥n `src/bare-metal/useful-crates/allocator-"
"example/`. (Nu va rula 칥n Playground din cauza dependen탵ei de crate)"

#: src/bare-metal/useful-crates/tinyvec.md
#, fuzzy
msgid ""
"Sometimes you want something which can be resized like a `Vec`, but without "
"heap allocation. [`tinyvec`](https://crates.io/crates/tinyvec) provides "
"this: a vector backed by an array or slice, which could be statically "
"allocated or on the stack, which keeps track of how many elements are used "
"and panics if you try to use more than are allocated."
msgstr ""
"Uneori dori탵i ceva care poate fi redimensionat ca un `Vec`, dar f캒r캒 alocare "
"de heap. [`tinyvec`](https://crates.io/crates/tinyvec) ofer캒 acest lucru: un "
"vector sus탵inut de o matrice sau de o felie, care poate fi alocat static sau "
"pe stiv캒, care 탵ine eviden탵a num캒rului de elemente utilizate 탳i intr캒 칥n "
"panic캒 dac캒 칥ncerca탵i s캒 utiliza탵i mai multe dec칙t sunt alocate."

#: src/bare-metal/useful-crates/tinyvec.md
#, fuzzy
msgid ""
"`tinyvec` requires that the element type implement `Default` for "
"initialisation."
msgstr ""
"`tinyvec` necesit캒 ca tipul de element s캒 implementeze `Default` pentru "
"ini탵ializare."

#: src/bare-metal/useful-crates/tinyvec.md
#, fuzzy
msgid ""
"The Rust Playground includes `tinyvec`, so this example will run fine inline."
msgstr ""
"Rust Playground include `tinyvec`, deci acest exemplu va rula bine 칥n linie."

#: src/bare-metal/useful-crates/spin.md
#, fuzzy
msgid ""
"`std::sync::Mutex` and the other synchronisation primitives from `std::sync` "
"are not available in `core` or `alloc`. How can we manage synchronisation or "
"interior mutability, such as for sharing state between different CPUs?"
msgstr ""
"`std::sync::Mutex` 탳i celelalte primitive de sincronizare din `std::sync` nu "
"sunt disponibile 칥n `core` sau `alloc`. Cum putem gestiona sincronizarea sau "
"mutabilitatea interioar캒, cum ar fi pentru partajarea st캒rii 칥ntre diferite "
"unit캒탵i centrale de procesare?"

#: src/bare-metal/useful-crates/spin.md
#, fuzzy
msgid ""
"The [`spin`](https://crates.io/crates/spin) crate provides spinlock-based "
"equivalents of many of these primitives."
msgstr ""
"Cr캒iasa [`spin`](https://crates.io/crates/spin) ofer캒 echivalente bazate pe "
"spinlock pentru multe dintre aceste primitive."

#: src/bare-metal/useful-crates/spin.md
#, fuzzy
msgid "Be careful to avoid deadlock if you take locks in interrupt handlers."
msgstr ""
"Ave탵i grij캒 s캒 evita탵i blocajul dac캒 lua탵i blocaje 칥n gestionarii de "
"칥ntreruperi."

#: src/bare-metal/useful-crates/spin.md
#, fuzzy
msgid ""
"`spin` also has a ticket lock mutex implementation; equivalents of `RwLock`, "
"`Barrier` and `Once` from `std::sync`; and `Lazy` for lazy initialisation."
msgstr ""
"`spin` are, de asemenea, o implementare a unui mutex de blocare a biletului; "
"echivalen탵i ai lui `RwLock`, `Barrier` 탳i `Once` din `std::sync`; 탳i `Lazy` "
"pentru ini탵ializare lene탳캒."

#: src/bare-metal/useful-crates/spin.md
#, fuzzy
msgid ""
"The [`once_cell`](https://crates.io/crates/once_cell) crate also has some "
"useful types for late initialisation with a slightly different approach to "
"`spin::once::Once`."
msgstr ""
"Cr캒iasa [`once_cell`](https://crates.io/crates/once_cell) are, de asemenea, "
"c칙teva tipuri utile pentru ini탵ializarea t칙rzie cu o abordare u탳or diferit캒 "
"de `spin::once::Once`."

#: src/bare-metal/useful-crates/spin.md
#, fuzzy
msgid ""
"The Rust Playground includes `spin`, so this example will run fine inline."
msgstr ""
"Rust Playground include `spin`, astfel c캒 acest exemplu va rula f캒r캒 "
"probleme 칥n linie."

#: src/bare-metal/android.md
#, fuzzy
msgid ""
"To build a bare-metal Rust binary in AOSP, you need to use a "
"`rust_ffi_static` Soong rule to build your Rust code, then a `cc_binary` "
"with a linker script to produce the binary itself, and then a `raw_binary` "
"to convert the ELF to a raw binary ready to be run."
msgstr ""
"Pentru a construi un binar Rust de tip bare-metal 칥n AOSP, trebuie s캒 "
"utiliza탵i o regul캒 Soong `rust_ffi_static` pentru a construi codul Rust, "
"apoi un `cc_binary` cu un script linker pentru a produce binarul propriu-zis "
"탳i apoi un `raw_binary` pentru a converti ELF-ul 칥ntr-un binar brut gata de "
"a fi rulat."

#: src/bare-metal/android/vmbase.md
msgid "vmbase"
msgstr "vmbase"

#: src/bare-metal/android/vmbase.md
#, fuzzy
msgid ""
"For VMs running under crosvm on aarch64, the [vmbase](https://android."
"googlesource.com/platform/packages/modules/Virtualization/+/refs/heads/"
"master/vmbase/) library provides a linker script and useful defaults for the "
"build rules, along with an entry point, UART console logging and more."
msgstr ""
"Pentru ma탳inile virtuale care ruleaz캒 sub crosvm pe aarch64, biblioteca "
"[vmbase](https://android.googlesource.com/platform/packages/modules/"
"Virtualization/+/refs/heads/master/vmbase/) ofer캒 un script de linker 탳i "
"valori implicite utile pentru regulile de compilare, 칥mpreun캒 cu un punct de "
"intrare, logare a consolei UART 탳i multe altele."

#: src/bare-metal/android/vmbase.md
#, fuzzy
msgid ""
"The `main!` macro marks your main function, to be called from the `vmbase` "
"entry point."
msgstr ""
"Macroul `main!` marcheaz캒 func탵ia principal캒, care va fi apelat캒 din punctul "
"de intrare `vmbase`."

#: src/bare-metal/android/vmbase.md
#, fuzzy
msgid ""
"The `vmbase` entry point handles console initialisation, and issues a "
"PSCI_SYSTEM_OFF to shutdown the VM if your main function returns."
msgstr ""
"Punctul de intrare `vmbase` se ocup캒 de ini탵ializarea consolei 탳i emite un "
"PSCI_SYSTEM_OFF pentru a 칥nchide VM dac캒 func탵ia principal캒 se 칥ntoarce."

#: src/exercises/bare-metal/afternoon.md
#, fuzzy
msgid "We will write a driver for the PL031 real-time clock device."
msgstr "Vom scrie un driver pentru dispozitivul de ceas 칥n timp real PL031."

#: src/exercises/bare-metal/afternoon.md
msgid ""
"After looking at the exercises, you can look at the [solutions](solutions-"
"afternoon.md) provided."
msgstr ""
"Dup캒 ce a탵i studiat exerci탵iile, pute탵i consulta [solu탵iile](solutions-"
"afternoon.md) furnizate."

#: src/exercises/bare-metal/rtc.md
#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "RTC driver"
msgstr "Conductor RTC"

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid ""
"The QEMU aarch64 virt machine has a [PL031](https://developer.arm.com/"
"documentation/ddi0224/c) real-time clock at 0x9010000. For this exercise, "
"you should write a driver for it."
msgstr ""
"Ma탳ina virtual캒 QEMU aarch64 are un ceas 칥n timp real [PL031](https://"
"developer.arm.com/documentation/ddi0224/c) la 0x9010000. Pentru acest "
"exerci탵iu, trebuie s캒 scrie탵i un driver pentru acesta."

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid ""
"Use it to print the current time to the serial console. You can use the "
"[`chrono`](https://crates.io/crates/chrono) crate for date/time formatting."
msgstr ""
"Utiliza탵i-o pentru a imprima ora curent캒 pe consola serial캒. Pute탵i utiliza "
"crate-ul [`chrono`](https://crates.io/crates/chrono) pentru formatarea datei/"
"orei."

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid ""
"Use the match register and raw interrupt status to busy-wait until a given "
"time, e.g. 3 seconds in the future. (Call [`core::hint::spin_loop`](https://"
"doc.rust-lang.org/core/hint/fn.spin_loop.html) inside the loop.)"
msgstr ""
"Utiliza탵i registrul de potrivire 탳i starea brut캒 a 칥ntreruperii pentru a "
"a탳tepta ocupat p칙n캒 la un anumit moment, de exemplu, 3 secunde 칥n viitor. "
"(Chema탵i [`core::hint::spin_loop`](https://doc.rust-lang.org/core/hint/fn."
"spin_loop.html) 칥n interiorul buclei)"

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid ""
"_Extension if you have time:_ Enable and handle the interrupt generated by "
"the RTC match. You can use the driver provided in the [`arm-gic`](https://"
"docs.rs/arm-gic/) crate to configure the Arm Generic Interrupt Controller."
msgstr ""
"extindere dac캒 ave탵i timp:_ Activa탵i 탳i gestiona탵i 칥ntreruperea generat캒 de "
"meciul RTC. Pute탵i utiliza driverul furnizat 칥n cr캒iasa [`arm-gic`](https://"
"docs.rs/arm-gic/) pentru a configura controlerul generic de 칥ntreruperi Arm "
"Generic Interrupt Controller."

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "Use the RTC interrupt, which is wired to the GIC as `IntId::spi(2)`."
msgstr ""
"Utiliza탵i 칥ntreruperea RTC, care este conectat캒 la GIC ca `IntId::spi(2)`."

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid ""
"Once the interrupt is enabled, you can put the core to sleep via `arm_gic::"
"wfi()`, which will cause the core to sleep until it receives an interrupt."
msgstr ""
"Odat캒 ce 칥ntreruperea este activat캒, pute탵i pune nucleul 칥n stare de veghe "
"prin intermediul `arm_gic::wfi()`, ceea ce va face ca nucleul s캒 doarm캒 p칙n캒 "
"c칙nd va primi o 칥ntrerupere."

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and "
"look in the `rtc` directory for the following files."
msgstr ""
"Desc캒rca탵i [탳ablonul de exerci탵ii] (../../comprehensive-rust-exercises.zip) "
"탳i c캒uta탵i 칥n directorul `rtc` urm캒toarele fi탳iere."

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid ""
"_src/exceptions.rs_ (you should only need to change this for the 3rd part of "
"the exercise):"
msgstr ""
"_src/exceptions.rs_ (ar trebui s캒 fie nevoie s캒 modifica탵i acest lucru doar "
"pentru a treia parte a exerci탵iului):"

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "_src/logger.rs_ (you shouldn't need to change this):"
msgstr ""
"_src/logger.rs_ (nu ar trebui s캒 fie nevoie s캒 modifica탵i acest lucru):"

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "_src/pl011.rs_ (you shouldn't need to change this):"
msgstr "_src/pl011.rs_ (nu ar trebui s캒 fie nevoie s캒 modifica탵i acest lucru):"

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "_build.rs_ (you shouldn't need to change this):"
msgstr "_build.rs_ (nu ar trebui s캒 fie nevoie s캒 modifica탵i acest lucru):"

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "_entry.S_ (you shouldn't need to change this):"
msgstr "_entry.S_ (nu ar trebui s캒 fie nevoie s캒 modifica탵i acest lucru):"

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "_exceptions.S_ (you shouldn't need to change this):"
msgstr "_exceptions.S_ (nu ar trebui s캒 fie nevoie s캒 modifica탵i acest lucru):"

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "_idmap.S_ (you shouldn't need to change this):"
msgstr "_idmap.S_ (nu ar trebui s캒 fie nevoie s캒 modifica탵i acest lucru):"

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "_image.ld_ (you shouldn't need to change this):"
msgstr "_image.ld_ (nu ar trebui s캒 fie nevoie s캒 modifica탵i acest lucru):"

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "_Makefile_ (you shouldn't need to change this):"
msgstr "_Makefile_ (nu ar trebui s캒 fie nevoie s캒 modifica탵i acest lucru):"

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "Run the code in QEMU with `make qemu`."
msgstr "Rula탵i codul 칥n QEMU cu `make qemu`."

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "Bare Metal Rust Afternoon"
msgstr "Rust bare metal Dup캒-amiaz캒"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "([back to exercise](rtc.md))"
msgstr "([back to exercise](rtc.md))"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "_main.rs_:"
msgstr "_main.rs_:"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Base addresses of the GICv3.\n"
msgstr "/// Adresele de baz캒 ale GICv3.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Base address of the PL031 RTC.\n"
msgstr "/// Adresa de baz캒 a PL031 RTC.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// The IRQ used by the PL031 RTC.\n"
msgstr "/// IRQ-ul utilizat de PL031 RTC.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "\"main({:#x}, {:#x}, {:#x}, {:#x})\""
msgstr "\"main({:#x}, {:#x}, {:#x}, {:#x})\""

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"// SAFETY: `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base\n"
"    // addresses of a GICv3 distributor and redistributor respectively, and\n"
"    // nothing else accesses those address ranges.\n"
msgstr ""
"// Sigur, deoarece `GICD_BASE_ADDRESS` 탳i `GICR_BASE_ADDRESS` sunt baza\n"
"    // adrese ale unui distribuitor 탳i, respectiv, redistribuitor GICv3, 탳i\n"
"    // nimic altceva nu acceseaz캒 aceste intervale de adrese.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"// SAFETY: `PL031_BASE_ADDRESS` is the base address of a PL031 device, and\n"
"    // nothing else accesses that address range.\n"
msgstr ""
"// Sigur, deoarece `PL031_BASE_ADDRESS` este adresa de baz캒 a unui "
"dispozitiv PL031,\n"
"    // 탳i nimic altceva nu acceseaz캒 acest interval de adrese.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "\"RTC: {time}\""
msgstr "\"RTC: {time}\""

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "// Wait for 3 seconds, without interrupts.\n"
msgstr "// A탳tepta탵i timp de 3 secunde, f캒r캒 칥ntreruperi.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "\"Waiting for {}\""
msgstr "\"칉n a탳teptare pentru {}\""

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "\"matched={}, interrupt_pending={}\""
msgstr "\"matched={}, interrupt_pending={}\""

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "\"Finished waiting\""
msgstr "\"Am terminat de a탳teptat\""

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "// Wait another 3 seconds for an interrupt.\n"
msgstr "// A탳tepta탵i 칥nc캒 3 secunde pentru o 칥ntrerupere.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "_pl031.rs_:"
msgstr "_pl031.rs_:"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Data register\n"
msgstr "/// Registrul de date\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Match register\n"
msgstr "/// Registrul de coresponden탵캒\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Load register\n"
msgstr "/// 칉nc캒rca탵i registrul\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Control register\n"
msgstr "/// Registrul de control\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Interrupt Mask Set or Clear register\n"
msgstr "/// Registru de setare sau 탳tergere a m캒탳tii de 칥ntrerupere\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Raw Interrupt Status\n"
msgstr "/// Starea de 칥ntrerupere brut캒\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Masked Interrupt Status\n"
msgstr "/// Stare de 칥ntrerupere mascat캒\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Interrupt Clear Register\n"
msgstr "/// Registrul de 탳tergere a 칥ntreruperilor\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Driver for a PL031 real-time clock.\n"
msgstr "Vom scrie un driver pentru dispozitivul de ceas 칥n timp real PL031."

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"/// Constructs a new instance of the RTC driver for a PL031 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of "
"a\n"
"    /// PL031 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
msgstr ""
"/// Construie탳te o nou캒 instan탵캒 a driverului RTC pentru un dispozitiv PL031 "
"la nivelul\n"
"    /// adresa de baz캒 dat캒.\n"
"    ///\n"
"    /// # Siguran탵캒\n"
"    ///\n"
"    /// Adresa de baz캒 dat캒 trebuie s캒 indice registrele de control MMIO ale "
"unui dispozitiv de tip\n"
"    /// dispozitiv PL031, care trebuie s캒 fie mapate 칥n spa탵iul de adrese al "
"procesului\n"
"    /// ca memorie a dispozitivului 탳i s캒 nu aib캒 alte pseudonime.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Reads the current RTC value.\n"
msgstr "/// Cite탳te valoarea curent캒 a RTC.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"// SAFETY: We know that self.registers points to the control registers\n"
"        // of a PL031 device which is appropriately mapped.\n"
msgstr ""
"// Sigur, deoarece 탳tim c캒 self.registers indic캒 controlul\n"
"        // registre ale unui dispozitiv PL031 care este cartografiat 칥n mod "
"corespunz캒tor.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"/// Writes a match value. When the RTC value matches this then an interrupt\n"
"    /// will be generated (if it is enabled).\n"
msgstr ""
"/// Scrie o valoare de potrivire. Atunci c칙nd valoarea RTC se potrive탳te cu "
"aceasta, se declan탳eaz캒 o 칥ntrerupere\n"
"    /// va fi generat캒 (dac캒 este activat캒).\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"/// Returns whether the match register matches the RTC value, whether or "
"not\n"
"    /// the interrupt is enabled.\n"
msgstr ""
"/// 칉ntoarce dac캒 registrul de potrivire se potrive탳te cu valoarea RTC, dac캒 "
"este sau nu\n"
"    /// 칥ntreruperea este activat캒.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"/// Returns whether there is currently an interrupt pending.\n"
"    ///\n"
"    /// This should be true if and only if `matched` returns true and the\n"
"    /// interrupt is masked.\n"
msgstr ""
"/// Returneaz캒 dac캒 exist캒 칥n prezent o 칥ntrerupere 칥n a탳teptare.\n"
"    ///\n"
"    /// Acest lucru ar trebui s캒 fie adev캒rat dac캒 탳i numai dac캒 `matched` "
"returneaz캒 true 탳i dac캒\n"
"    /// 칥ntreruperea este mascat캒.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"/// Sets or clears the interrupt mask.\n"
"    ///\n"
"    /// When the mask is true the interrupt is enabled; when it is false "
"the\n"
"    /// interrupt is disabled.\n"
msgstr ""
"/// Seteaz캒 sau 탳terge masca de 칥ntrerupere.\n"
"    ///\n"
"    /// C칙nd masca este adev캒rat캒, 칥ntreruperea este activat캒; c칙nd este "
"fals캒, 칥ntreruperea este activat캒\n"
"    /// 칥ntreruperea este dezactivat캒.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Clears a pending interrupt, if any.\n"
msgstr "/// 탲terge o 칥ntrerupere 칥n a탳teptare, dac캒 exist캒.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"// SAFETY: `Rtc` just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
msgstr ""
"// Sigur, deoarece con탵ine doar un pointer c캒tre memoria dispozitivului, "
"care poate fi\n"
"// accesat캒 din orice context.\n"

#: src/concurrency/welcome.md
#, fuzzy
msgid "Welcome to Concurrency in Rust"
msgstr "Bine a탵i venit la Concurrency 칥n Rust"

#: src/concurrency/welcome.md
#, fuzzy
msgid ""
"Rust has full support for concurrency using OS threads with mutexes and "
"channels."
msgstr ""
"Rust are un suport complet pentru concuren탵캒 folosind fire de execu탵ie OS cu "
"mutexuri 탳i canale."

#: src/concurrency/welcome.md
#, fuzzy
msgid ""
"The Rust type system plays an important role in making many concurrency bugs "
"compile time bugs. This is often referred to as _fearless concurrency_ since "
"you can rely on the compiler to ensure correctness at runtime."
msgstr ""
"Sistemul de tipuri Rust joac캒 un rol important 칥n transformarea multor erori "
"de concuren탵캒 칥n erori de timp de compilare. Acest lucru este deseori "
"denumit _concuren탵캒 f캒r캒 fric캒_, deoarece v캒 pute탵i baza pe compilator "
"pentru a asigura corectitudinea la momentul execu탵iei."

#: src/concurrency/welcome.md
#, fuzzy
msgid "[Threads](./concurrency/threads.md) (30 minutes)"
msgstr "[Referin탵e partajate](./references/shared.md) (10 minute)"

#: src/concurrency/welcome.md
#, fuzzy
msgid "[Channels](./concurrency/channels.md) (20 minutes)"
msgstr "[Referin탵e partajate](./references/shared.md) (10 minute)"

#: src/concurrency/welcome.md
#, fuzzy
msgid "[Send and Sync](./concurrency/send-sync.md) (15 minutes)"
msgstr "[Referin탵e partajate](./references/shared.md) (10 minute)"

#: src/concurrency/welcome.md
#, fuzzy
msgid "[Shared State](./concurrency/shared-state.md) (30 minutes)"
msgstr "[Referin탵e partajate](./references/shared.md) (10 minute)"

#: src/concurrency/welcome.md
#, fuzzy
msgid "[Exercises](./concurrency/sync-exercises.md) (1 hour and 10 minutes)"
msgstr "[Exerci탵iu: Geometrie](./references/exercise.md) (30 minute)"

#: src/concurrency/welcome.md src/concurrency/welcome-async.md
#, fuzzy
msgid ""
"Including 10 minute breaks, this session should take about 3 hours and 20 "
"minutes"
msgstr ""
"Incluz칙nd pauzele de 10 minute, aceast캒 sesiune ar trebui s캒 dureze "
"aproximativ 2 ore 탳i 20 de minute"

#: src/concurrency/welcome.md
#, fuzzy
msgid ""
"Rust lets us access OS concurrency toolkit: threads, sync. primitives, etc."
msgstr ""
"Rust ne permite s캒 acces캒m setul de instrumente de simultaneitate al "
"sistemului de operare: fire, primitive de sincronizare, etc."

#: src/concurrency/welcome.md
#, fuzzy
msgid ""
"The type system gives us safety for concurrency without any special features."
msgstr ""
"Sistemul de tipuri ne ofer캒 siguran탵캒 pentru simultaneitate f캒r캒 "
"caracteristici speciale."

#: src/concurrency/welcome.md
#, fuzzy
msgid ""
"The same tools that help with \"concurrent\" access in a single thread (e."
"g., a called function that might mutate an argument or save references to it "
"to read later) save us from multi-threading issues."
msgstr ""
"Acelea탳i instrumente care ajut캒 la accesul \"concurent\" 칥ntr-un singur fir "
"(de exemplu, o func탵ie apelat캒 care ar putea modifica un argument sau salva "
"referin탵e la acesta pentru a fi citite mai t칙rziu) ne salveaz캒 de problemele "
"legate de mai multe fire de execu탵ie."

#: src/concurrency/threads.md
#, fuzzy
msgid "[Plain Threads](./concurrency/threads/plain.md) (15 minutes)"
msgstr "[impl Trait](./generics/impl-trait.md) (5 minute)"

#: src/concurrency/threads.md
#, fuzzy
msgid "[Scoped Threads](./concurrency/threads/scoped.md) (15 minutes)"
msgstr "[Referin탵e partajate](./references/shared.md) (10 minute)"

#: src/concurrency/threads.md src/concurrency/shared-state.md
#: src/concurrency/async.md
#, fuzzy
msgid "This segment should take about 30 minutes"
msgstr "Acest segment ar trebui s캒 dureze aproximativ 40 de minute"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Rust threads work similarly to threads in other languages:"
msgstr ""
"Firele de execu탵ie din Rust func탵ioneaz캒 칥n mod similar cu cele din alte "
"limbaje:"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "\"Count in thread: {i}!\""
msgstr "\"Num캒r캒toarea 칥n fir: {i}!\""

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "\"Main thread: {i}\""
msgstr "\"Firul principal: {i}\""

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Threads are all daemon threads, the main thread does not wait for them."
msgstr "Firele sunt toate fire de tip daemon, firul principal nu le a탳teapt캒."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Thread panics are independent of each other."
msgstr "Panica firelor este independent캒 una de cealalt캒."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Panics can carry a payload, which can be unpacked with `downcast_ref`."
msgstr ""
"Panicile pot transporta o sarcin캒 util캒, care poate fi despachetat캒 cu "
"`downcast_ref`."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Rust thread APIs look not too different from e.g. C++ ones."
msgstr ""
"API-urile Rust pentru fire de execu탵ie nu par prea diferite de cele din C++."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Run the example."
msgstr "Rula탵i exemplul cu:"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid ""
"5ms timing is loose enough that main and spawned threads stay mostly in "
"lockstep."
msgstr ""
"o sincronizare de 5ms este suficient de liber캒 pentru ca firele principale "
"탳i cele generate s캒 r캒m칙n캒 칥n mare parte 칥n acela탳i timp."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Notice that the program ends before the spawned thread reaches 10!"
msgstr ""
"Observa탵i c캒 programul se termin캒 칥nainte ca firul generat s캒 ajung캒 la 10!"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid ""
"This is because main ends the program and spawned threads do not make it "
"persist."
msgstr ""
"Acest lucru se datoreaz캒 faptului c캒 main 칥ncheie programul, iar firele de "
"execu탵ie generate nu 칥l fac s캒 persiste."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Compare to pthreads/C++ std::thread/boost::thread if desired."
msgstr ""
"Compara탵i cu pthreads/C++ std::thread/boost::thread dac캒 se dore탳te acest "
"lucru."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "How do we wait around for the spawned thread to complete?"
msgstr "Cum putem a탳tepta ca firul generat s캒 se finalizeze?"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid ""
"[`thread::spawn`](https://doc.rust-lang.org/std/thread/fn.spawn.html) "
"returns a `JoinHandle`. Look at the docs."
msgstr ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) "
"utilizat pentru a construi o instan탵캒 implicit캒 a unui tip."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid ""
"`JoinHandle` has a [`.join()`](https://doc.rust-lang.org/std/thread/struct."
"JoinHandle.html#method.join) method that blocks."
msgstr ""
"`JoinHandle` are o metod캒 [`.join()`](https://doc.rust-lang.org/std/thread/"
"struct.JoinHandle.html#method.join) care se blocheaz캒."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid ""
"Use `let handle = thread::spawn(...)` and later `handle.join()` to wait for "
"the thread to finish and have the program count all the way to 10."
msgstr ""
"Utiliza탵i `let handle = thread::spawn(...)` 탳i mai t칙rziu `handle.join()` "
"pentru a a탳tepta ca firul s캒 se termine."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Now what if we want to return a value?"
msgstr "Acum, ce se 칥nt칙mpl캒 dac캒 vrem s캒 return캒m o valoare?"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Look at docs again:"
msgstr "Uit캒-te din nou la documente:"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid ""
"[`thread::spawn`](https://doc.rust-lang.org/std/thread/fn.spawn.html)'s "
"closure returns `T`"
msgstr ""
"Cu toate acestea, pute탵i utiliza un [scoped thread](https://doc.rust-lang."
"org/std/thread/fn.scope.html) pentru acest lucru:"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid ""
"`JoinHandle` [`.join()`](https://doc.rust-lang.org/std/thread/struct."
"JoinHandle.html#method.join) returns `thread::Result<T>`"
msgstr ""
"`JoinHandle` [`.join()`](https://doc.rust-lang.org/std/thread/struct."
"JoinHandle.html#method.join) returneaz캒 `thread::Result<T>`"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid ""
"Use the `Result` return value from `handle.join()` to get access to the "
"returned value."
msgstr ""
"Utiliza탵i valoarea de returnare `Result` din `handle.join()` pentru a ob탵ine "
"acces la sarcina util캒 de panic캒. Acesta este un moment bun pentru a vorbi "
"despre [`Any`](https://doc.rust-lang.org/std/any/index.html)."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Ok, what about the other case?"
msgstr "Bine, dar cel캒lalt caz?"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Trigger a panic in the thread. Note that this doesn't panic `main`."
msgstr ""
"Declan탳eaz캒 o panic캒 칥n firul de discu탵ie, observa탵i cum acest lucru nu "
"afecteaz캒 `main`."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid ""
"Access the panic payload. This is a good time to talk about [`Any`](https://"
"doc.rust-lang.org/std/any/index.html)."
msgstr ""
"Utiliza탵i valoarea de returnare `Result` din `handle.join()` pentru a ob탵ine "
"acces la sarcina util캒 de panic캒. Acesta este un moment bun pentru a vorbi "
"despre [`Any`](https://doc.rust-lang.org/std/any/index.html)."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Now we can return values from threads! What about taking inputs?"
msgstr ""
"Acum putem returna valori de la fire! Dar cum r캒m칙ne cu preluarea intr캒rilor?"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Capture something by reference in the thread closure."
msgstr "Captura탵i ceva prin referin탵캒 칥n 칥nchiderea firului."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "An error message indicates we must move it."
msgstr "Un mesaj de eroare indic캒 faptul c캒 trebuie s캒 o mut캒m."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Move it in, see we can compute and then return a derived value."
msgstr ""
"Muta탵i-l 칥n캒untru, vede탵i c캒 putem calcula 탳i apoi returna o valoare "
"derivat캒."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "If we want to borrow?"
msgstr "Dac캒 vrem s캒 칥mprumut캒m?"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid ""
"Main kills child threads when it returns, but another function would just "
"return and leave them running."
msgstr ""
"Main ucide firele de execu탵ie ale copiilor atunci c칙nd se 칥ntoarce, dar o "
"alt캒 func탵ie s-ar 칥ntoarce 탳i le-ar l캒sa 칥n func탵iune."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "That would be stack use-after-return, which violates memory safety!"
msgstr ""
"Aceasta ar fi o utilizare a stivei dup캒 returnare, ceea ce 칥ncalc캒 siguran탵a "
"memoriei!"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "How do we avoid this? see next slide."
msgstr "Cum putem evita acest lucru? a se vedea slide-ul urm캒tor."

#: src/concurrency/threads/scoped.md
#, fuzzy
msgid "Normal threads cannot borrow from their environment:"
msgstr "Firele normale nu pot 칥mprumuta din mediul lor:"

#: src/concurrency/threads/scoped.md
#, fuzzy
msgid ""
"However, you can use a [scoped thread](https://doc.rust-lang.org/std/thread/"
"fn.scope.html) for this:"
msgstr ""
"Cu toate acestea, pute탵i utiliza un [scoped thread](https://doc.rust-lang."
"org/std/thread/fn.scope.html) pentru acest lucru:"

#: src/concurrency/threads/scoped.md
#, fuzzy
msgid ""
"The reason for that is that when the `thread::scope` function completes, all "
"the threads are guaranteed to be joined, so they can return borrowed data."
msgstr ""
"Motivul este c캒, atunci c칙nd func탵ia `thread::scope` se finalizeaz캒, toate "
"firele sunt garantate a fi unite, astfel 칥nc칙t pot returna date 칥mprumutate."

#: src/concurrency/threads/scoped.md
#, fuzzy
msgid ""
"Normal Rust borrowing rules apply: you can either borrow mutably by one "
"thread, or immutably by any number of threads."
msgstr ""
"Se aplic캒 regulile normale de 칥mprumut Rust: pute탵i 칥mprumuta fie 칥n mod "
"mutabil de c캒tre un singur fir, fie 칥n mod imuabil de c캒tre orice num캒r de "
"fire."

#: src/concurrency/channels.md
#, fuzzy
msgid ""
"[Senders and Receivers](./concurrency/channels/senders-receivers.md) (10 "
"minutes)"
msgstr "[Referin탵e partajate](./references/shared.md) (10 minute)"

#: src/concurrency/channels.md
#, fuzzy
msgid "[Unbounded Channels](./concurrency/channels/unbounded.md) (2 minutes)"
msgstr "[Uniuni](./unsafe-rust/unions.md) (5 minute)"

#: src/concurrency/channels.md
#, fuzzy
msgid "[Bounded Channels](./concurrency/channels/bounded.md) (10 minutes)"
msgstr "[Limite ale tr캒s캒turilor](./generics/trait-bounds.md) (10 minute)"

#: src/concurrency/channels.md src/concurrency/async-control-flow.md
msgid "This segment should take about 20 minutes"
msgstr "Acest segment ar trebui s캒 dureze aproximativ 20 de minute"

#: src/concurrency/channels/senders-receivers.md
#, fuzzy
msgid ""
"Rust channels have two parts: a `Sender<T>` and a `Receiver<T>`. The two "
"parts are connected via the channel, but you only see the end-points."
msgstr ""
"Canalele Rust au dou캒 p캒r탵i: un `Sender<T>` 탳i un `Receiver<T>`. Cele dou캒 "
"p캒r탵i sunt conectate prin intermediul canalului, dar nu se v캒d dec칙t "
"punctele finale."

#: src/concurrency/channels/senders-receivers.md
#, fuzzy
msgid "\"Received: {:?}\""
msgstr "\"Recep탵ionat: {:?}\""

#: src/concurrency/channels/senders-receivers.md
#, fuzzy
msgid ""
"`mpsc` stands for Multi-Producer, Single-Consumer. `Sender` and `SyncSender` "
"implement `Clone` (so you can make multiple producers) but `Receiver` does "
"not."
msgstr ""
"`mpsc` 칥nseamn캒 Multi-Producer, Single-Consumer. `Sender` 탳i `SyncSender` "
"implementeaz캒 `Clone` (astfel 칥nc칙t s캒 pute탵i face mai mul탵i produc캒tori), "
"dar `Receiver` nu o face."

#: src/concurrency/channels/senders-receivers.md
#, fuzzy
msgid ""
"`send()` and `recv()` return `Result`. If they return `Err`, it means the "
"counterpart `Sender` or `Receiver` is dropped and the channel is closed."
msgstr ""
"`send()` 탳i `recv()` returneaz캒 `Result`. Dac캒 acestea returneaz캒 `Err`, "
"칥nseamn캒 c캒 omologul `Sender` sau `Receiver` este abandonat 탳i canalul este "
"칥nchis."

#: src/concurrency/channels/unbounded.md
#, fuzzy
msgid "You get an unbounded and asynchronous channel with `mpsc::channel()`:"
msgstr "Ob탵ine탵i un canal nem캒rginit 탳i asincron cu `mpsc::channel()`:"

#: src/concurrency/channels/unbounded.md src/concurrency/channels/bounded.md
#, fuzzy
msgid "\"Message {i}\""
msgstr "\"Mesaj {i}\""

#: src/concurrency/channels/unbounded.md src/concurrency/channels/bounded.md
#, fuzzy
msgid "\"{thread_id:?}: sent Message {i}\""
msgstr "\"{thread_id:?}: mesaj trimis {i}\""

#: src/concurrency/channels/unbounded.md src/concurrency/channels/bounded.md
#, fuzzy
msgid "\"{thread_id:?}: done\""
msgstr "\"{thread_id:?}: terminat\""

#: src/concurrency/channels/unbounded.md src/concurrency/channels/bounded.md
#, fuzzy
msgid "\"Main: got {msg}\""
msgstr "\"Main: got {msg}\""

#: src/concurrency/channels/bounded.md
#, fuzzy
msgid ""
"With bounded (synchronous) channels, `send` can block the current thread:"
msgstr "Cu canale limitate (sincrone), `send` poate bloca firul curent:"

#: src/concurrency/channels/bounded.md
#, fuzzy
msgid ""
"Calling `send` will block the current thread until there is space in the "
"channel for the new message. The thread can be blocked indefinitely if there "
"is nobody who reads from the channel."
msgstr ""
"Apelul la `send` va bloca firul curent p칙n캒 c칙nd va exista spa탵iu 칥n canal "
"pentru noul mesaj. Firul poate fi blocat la nesf칙r탳it dac캒 nimeni nu cite탳te "
"de pe canal."

#: src/concurrency/channels/bounded.md
#, fuzzy
msgid ""
"A call to `send` will abort with an error (that is why it returns `Result`) "
"if the channel is closed. A channel is closed when the receiver is dropped."
msgstr ""
"Un apel la `send` va e탳ua cu o eroare (de aceea returneaz캒 `Result`) dac캒 "
"canalul este 칥nchis. Un canal este 칥nchis atunci c칙nd receptorul este "
"abandonat."

#: src/concurrency/channels/bounded.md
#, fuzzy
msgid ""
"A bounded channel with a size of zero is called a \"rendezvous channel\". "
"Every send will block the current thread until another thread calls `recv`."
msgstr ""
"Un canal delimitat cu dimensiunea zero se nume탳te \"canal de 칥nt칙lnire\". "
"Fiecare trimitere va bloca firul curent p칙n캒 c칙nd un alt fir va apela `read`."

#: src/concurrency/send-sync.md
#, fuzzy
msgid "[Marker Traits](./concurrency/send-sync/marker-traits.md) (2 minutes)"
msgstr "[Tr캒s캒turi nesigure](./unsafe-rust/unsafe-traits.md) (5 minute)"

#: src/concurrency/send-sync.md
#, fuzzy
msgid "[Send](./concurrency/send-sync/send.md) (2 minutes)"
msgstr "[탲iruri](./types-and-values/strings.md) (10 minute)"

#: src/concurrency/send-sync.md
#, fuzzy
msgid "[Sync](./concurrency/send-sync/sync.md) (2 minutes)"
msgstr "[탲iruri](./types-and-values/strings.md) (10 minute)"

#: src/concurrency/send-sync.md
#, fuzzy
msgid "[Examples](./concurrency/send-sync/examples.md) (10 minutes)"
msgstr ""
"[Tupluri 탳i vectori](./tuples-and-arrays/tuples-and-arrays.md)  (10 minute)"

#: src/concurrency/send-sync/marker-traits.md
#, fuzzy
msgid ""
"How does Rust know to forbid shared access across threads? The answer is in "
"two traits:"
msgstr ""
"Cum 탳tie Rust s캒 interzic캒 accesul partajat 칥ntre fire de execu탵ie? "
"R캒spunsul se afl캒 칥n dou캒 tr캒s캒turi:"

#: src/concurrency/send-sync/marker-traits.md
#, fuzzy
msgid ""
"[`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html): a type `T` "
"is `Send` if it is safe to move a `T` across a thread boundary."
msgstr ""
"[`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html): un tip `T` "
"este `Send` dac캒 este sigur s캒 mu탵i un `T` peste o limit캒 de fir."

#: src/concurrency/send-sync/marker-traits.md
#, fuzzy
msgid ""
"[`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html): a type `T` "
"is `Sync` if it is safe to move a `&T` across a thread boundary."
msgstr ""
"[`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html): un tip `T` "
"este `Sync` dac캒 este sigur s캒 mu탵i un `&T` peste o limit캒 de fir."

#: src/concurrency/send-sync/marker-traits.md
#, fuzzy
msgid ""
"`Send` and `Sync` are [unsafe traits](../../unsafe-rust/unsafe-traits.md). "
"The compiler will automatically derive them for your types as long as they "
"only contain `Send` and `Sync` types. You can also implement them manually "
"when you know it is valid."
msgstr ""
"`Send` 탳i `Sync` sunt [tr캒s캒turi nesigure](../unsafe/unsafe-traits.md). "
"Compilatorul le va deriva 칥n mod automat pentru tipurile dvs. at칙ta timp c칙t "
"acestea con탵in doar tipurile `Send` 탳i `Sync`. De asemenea, le pute탵i "
"implementa manual atunci c칙nd 탳ti탵i c캒 este valabil."

#: src/concurrency/send-sync/marker-traits.md
#, fuzzy
msgid ""
"One can think of these traits as markers that the type has certain thread-"
"safety properties."
msgstr ""
"Aceste tr캒s캒turi pot fi considerate ca fiind indicatoare ale faptului c캒 "
"tipul are anumite propriet캒탵i de siguran탵캒 a firelor."

#: src/concurrency/send-sync/marker-traits.md
#, fuzzy
msgid "They can be used in the generic constraints as normal traits."
msgstr ""
"Acestea pot fi utilizate 칥n cadrul constr칙ngerilor generice ca 탳i tr캒s캒turi "
"normale."

#: src/concurrency/send-sync/send.md
#, fuzzy
msgid ""
"A type `T` is [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html) "
"if it is safe to move a `T` value to another thread."
msgstr ""
"Un tip `T` este [`Send`](https://doc.rust-lang.org/std/marker/trait.Send."
"html) dac캒 este sigur s캒 mu탵i o valoare `T` c캒tre un alt fir."

#: src/concurrency/send-sync/send.md
#, fuzzy
msgid ""
"The effect of moving ownership to another thread is that _destructors_ will "
"run in that thread. So the question is when you can allocate a value in one "
"thread and deallocate it in another."
msgstr ""
"Efectul mut캒rii propriet캒탵ii c캒tre un alt fir este c캒 _destructori_ vor rula "
"칥n acel fir. A탳adar, 칥ntrebarea este c칙nd pute탵i aloca o valoare 칥ntr-un fir "
"탳i o pute탵i dezaloca 칥n alt fir."

#: src/concurrency/send-sync/send.md
#, fuzzy
msgid ""
"As an example, a connection to the SQLite library must only be accessed from "
"a single thread."
msgstr ""
"De exemplu, o conexiune la biblioteca SQLite trebuie s캒 fie accesat캒 numai "
"de pe un singur fir de execu탵ie."

#: src/concurrency/send-sync/sync.md
#, fuzzy
msgid ""
"A type `T` is [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) "
"if it is safe to access a `T` value from multiple threads at the same time."
msgstr ""
"Un tip `T` este [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync."
"html) dac캒 este sigur s캒 accesezi o valoare `T` din mai multe fire de "
"execu탵ie 칥n acela탳i timp."

#: src/concurrency/send-sync/sync.md
#, fuzzy
msgid "More precisely, the definition is:"
msgstr "Mai exact, defini탵ia este:"

#: src/concurrency/send-sync/sync.md
#, fuzzy
msgid "`T` is `Sync` if and only if `&T` is `Send`"
msgstr "`T` este `Sync` dac캒 탳i numai dac캒 `&T` este `Send`"

#: src/concurrency/send-sync/sync.md
#, fuzzy
msgid ""
"This statement is essentially a shorthand way of saying that if a type is "
"thread-safe for shared use, it is also thread-safe to pass references of it "
"across threads."
msgstr ""
"Aceast캒 afirma탵ie este, 칥n esen탵캒, un mod prescurtat de a spune c캒, dac캒 un "
"tip este sigur pentru utilizarea partajat캒, este, de asemenea, sigur pentru "
"a trece referin탵e ale acestuia 칥ntre fire."

#: src/concurrency/send-sync/sync.md
#, fuzzy
msgid ""
"This is because if a type is Sync it means that it can be shared across "
"multiple threads without the risk of data races or other synchronization "
"issues, so it is safe to move it to another thread. A reference to the type "
"is also safe to move to another thread, because the data it references can "
"be accessed from any thread safely."
msgstr ""
"Acest lucru se datoreaz캒 faptului c캒, dac캒 un tip este Sync, 칥nseamn캒 c캒 "
"poate fi partajat 칥ntre mai multe fire de execu탵ie f캒r캒 riscul de curse de "
"date sau alte probleme de sincronizare, astfel 칥nc칙t este sigur s캒 칥l muta탵i "
"pe un alt fir de execu탵ie. O referin탵캒 la tip este, de asemenea, sigur캒 "
"pentru a fi mutat캒 칥n alt fir, deoarece datele la care face referire pot fi "
"accesate 칥n siguran탵캒 din orice fir."

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`Send + Sync`"
msgstr "`Send + Sync`"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "Most types you come across are `Send + Sync`:"
msgstr "Majoritatea tipurilor pe care le 칥nt칙lni탵i sunt de tip `Send + Sync`:"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`i8`, `f32`, `bool`, `char`, `&str`, ..."
msgstr "`i8`, `f32`, `bool`, `char`, `&str`, ..."

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ..."
msgstr "`(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ..."

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`String`, `Option<T>`, `Vec<T>`, `Box<T>`, ..."
msgstr "`String`, `Option<T>`, `Vec<T>`, `Box<T>`, ..."

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`Arc<T>`: Explicitly thread-safe via atomic reference count."
msgstr ""
"`Arc<T>`: 칉n mod explicit, thread-safe prin num캒rul de referin탵e atomice."

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`Mutex<T>`: Explicitly thread-safe via internal locking."
msgstr "`Mutex<T>`: 칉n mod explicit, thread-safe prin blocare intern캒."

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`mpsc::Sender<T>`: As of 1.72.0."
msgstr "`mpsc::Sender<T>`"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`AtomicBool`, `AtomicU8`, ...: Uses special atomic instructions."
msgstr ""
"`AtomicBool`, `AtomicU8`, ....: Utilizeaz캒 instruc탵iuni atomice speciale."

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid ""
"The generic types are typically `Send + Sync` when the type parameters are "
"`Send + Sync`."
msgstr ""
"Tipurile generice sunt de obicei `Send + Sync` atunci c칙nd parametrii de tip "
"sunt `Send + Sync`."

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`Send + !Sync`"
msgstr "`Send + !Sync`"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid ""
"These types can be moved to other threads, but they're not thread-safe. "
"Typically because of interior mutability:"
msgstr ""
"Aceste tipuri pot fi mutate 칥n alte fire de execu탵ie, dar nu sunt sigure "
"pentru fire de execu탵ie. De obicei, din cauza mutabilit캒탵ii interioare:"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`mpsc::Receiver<T>`"
msgstr "`mpsc::Receiver<T>`"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`Cell<T>`"
msgstr "`Celula<T>`"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`RefCell<T>`"
msgstr "`RefCell<T>`"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`!Send + Sync`"
msgstr "`!Send + Sync`"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid ""
"These types are thread-safe, but they cannot be moved to another thread:"
msgstr ""
"Aceste tipuri sunt sigure pentru firul de execu탵ie, dar nu pot fi mutate 칥n "
"alt fir de execu탵ie:"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid ""
"`MutexGuard<T: Sync>`: Uses OS level primitives which must be deallocated on "
"the thread which created them."
msgstr ""
"`MutexGuard<T: Sync>`: Utilizeaz캒 primitive la nivelul sistemului de operare "
"care trebuie s캒 fie dezalocate pe firul care le-a creat."

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`!Send + !Sync`"
msgstr "`!Send +Sync`"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "These types are not thread-safe and cannot be moved to other threads:"
msgstr ""
"Aceste tipuri nu sunt sigure pentru fire de execu탵ie 탳i nu pot fi mutate 칥n "
"alte fire de execu탵ie:"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid ""
"`Rc<T>`: each `Rc<T>` has a reference to an `RcBox<T>`, which contains a non-"
"atomic reference count."
msgstr ""
"`Rc<T>`: fiecare `Rc<T>` are o referin탵캒 la un `RcBox<T>`, care con탵ine un "
"num캒r de referin탵e neatomice."

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid ""
"`*const T`, `*mut T`: Rust assumes raw pointers may have special concurrency "
"considerations."
msgstr ""
"`*const T`, `*mut T`: Rust presupune c캒 indicatoarele brute pot avea "
"considera탵ii speciale privind concuren탵a."

#: src/concurrency/shared-state.md
#, fuzzy
msgid "[Arc](./concurrency/shared-state/arc.md) (5 minutes)"
msgstr "[Rc](./smart-pointers/rc.md) (5 minute)"

#: src/concurrency/shared-state.md
#, fuzzy
msgid "[Mutex](./concurrency/shared-state/mutex.md) (15 minutes)"
msgstr "[Nesigur](./unsafe-rust/unsafe.md) (5 minute)"

#: src/concurrency/shared-state.md
#, fuzzy
msgid "[Example](./concurrency/shared-state/example.md) (10 minutes)"
msgstr "[Nesigur](./unsafe-rust/unsafe.md) (5 minute)"

#: src/concurrency/shared-state/arc.md
#, fuzzy
msgid ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html) allows shared "
"read-only access via `Arc::clone`:"
msgstr ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html) permite "
"accesul partajat numai pentru citire prin intermediul `Arc::clone`:"

#: src/concurrency/shared-state/arc.md
#, fuzzy
msgid "\"{thread_id:?}: {v:?}\""
msgstr "\"{thread_id:?}: {v:?}\""

#: src/concurrency/shared-state/arc.md src/concurrency/shared-state/example.md
#, fuzzy
msgid "\"v: {v:?}\""
msgstr "\"v: {v:?}\""

#: src/concurrency/shared-state/arc.md
#, fuzzy
msgid ""
"`Arc` stands for \"Atomic Reference Counted\", a thread safe version of `Rc` "
"that uses atomic operations."
msgstr ""
"`Arc` este acronimul de la \"Atomic Reference Counted\", o versiune thread "
"safe a `Rc` care utilizeaz캒 opera탵ii atomice."

#: src/concurrency/shared-state/arc.md
#, fuzzy
msgid ""
"`Arc<T>` implements `Clone` whether or not `T` does. It implements `Send` "
"and `Sync` if and only if `T` implements them both."
msgstr ""
"`Arc<T>` implementeaz캒 `Clone` indiferent dac캒 `T` o face sau nu. "
"Implementeaz캒 `Send` 탳i `Sync` dac캒 탳i numai dac캒 `T` le implementeaz캒 pe "
"am칙ndou캒."

#: src/concurrency/shared-state/arc.md
#, fuzzy
msgid ""
"`Arc::clone()` has the cost of atomic operations that get executed, but "
"after that the use of the `T` is free."
msgstr ""
"`Arc::clone()` are costul opera탵iunilor atomice care se execut캒, dar dup캒 "
"aceea utilizarea lui `T` este gratuit캒."

#: src/concurrency/shared-state/arc.md
#, fuzzy
msgid ""
"Beware of reference cycles, `Arc` does not use a garbage collector to detect "
"them."
msgstr ""
"Aten탵ie la ciclurile de referin탵캒, `Arc` nu folose탳te un garbage collector "
"pentru a le detecta."

#: src/concurrency/shared-state/arc.md
#, fuzzy
msgid "`std::sync::Weak` can help."
msgstr "`std::sync::Weak` poate fi de ajutor."

#: src/concurrency/shared-state/mutex.md
#, fuzzy
msgid ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html) ensures "
"mutual exclusion _and_ allows mutable access to `T` behind a read-only "
"interface (another form of [interior mutability](../../borrowing/interior-"
"mutability)):"
msgstr ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html) asigur캒 "
"excluderea reciproc캒 _탳i_ permite accesul mutabil la `T` 칥n spatele unei "
"interfe탵e de numai citire:"

#: src/concurrency/shared-state/mutex.md
#, fuzzy
msgid "\"v: {:?}\""
msgstr "\"Magnitudinea lui {v:?} dup캒 normalizare: {}\""

#: src/concurrency/shared-state/mutex.md
#, fuzzy
msgid ""
"Notice how we have a [`impl<T: Send> Sync for Mutex<T>`](https://doc.rust-"
"lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E) blanket "
"implementation."
msgstr ""
"Observa탵i cum avem o implementare de p캒tur캒 [`impl<T: Send> Sync for "
"Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-Sync-"
"for-Mutex%3CT%3E)."

#: src/concurrency/shared-state/mutex.md
#, fuzzy
msgid ""
"`Mutex` in Rust looks like a collection with just one element --- the "
"protected data."
msgstr ""
"`Mutex` 칥n Rust arat캒 ca o colec탵ie cu un singur element - datele protejate."

#: src/concurrency/shared-state/mutex.md
#, fuzzy
msgid ""
"It is not possible to forget to acquire the mutex before accessing the "
"protected data."
msgstr ""
"Nu este posibil s캒 se uite s캒 se achizi탵ioneze mutexul 칥nainte de a accesa "
"datele protejate."

#: src/concurrency/shared-state/mutex.md
#, fuzzy
msgid ""
"You can get an `&mut T` from an `&Mutex<T>` by taking the lock. The "
"`MutexGuard` ensures that the `&mut T` doesn't outlive the lock being held."
msgstr ""
"Pute탵i ob탵ine un `&amp;mut T` dintr-un `&amp;Mutex<T>` prin luarea unui "
"blocaj. `MutexGuard` se asigur캒 c캒 `&amp;mut T` nu supravie탵uie탳te mai mult "
"dec칙t blocajul de탵inut."

#: src/concurrency/shared-state/mutex.md
#, fuzzy
msgid ""
"`Mutex<T>` implements both `Send` and `Sync` iff (if and only if) `T` "
"implements `Send`."
msgstr ""
"`Mutex<T>` implementeaz캒 at칙t `Send` c칙t 탳i `Sync` dac캒 (dac캒 탳i numai dac캒) "
"`T` implementeaz캒 `Send`."

#: src/concurrency/shared-state/mutex.md
#, fuzzy
msgid "A read-write lock counterpart: `RwLock`."
msgstr "O contraparte de blocare la citire-scriere - `RwLock`."

#: src/concurrency/shared-state/mutex.md
#, fuzzy
msgid "Why does `lock()` return a `Result`?"
msgstr "De ce `lock()` returneaz캒 `Result`? "

#: src/concurrency/shared-state/mutex.md
#, fuzzy
msgid ""
"If the thread that held the `Mutex` panicked, the `Mutex` becomes "
"\"poisoned\" to signal that the data it protected might be in an "
"inconsistent state. Calling `lock()` on a poisoned mutex fails with a "
"[`PoisonError`](https://doc.rust-lang.org/std/sync/struct.PoisonError.html). "
"You can call `into_inner()` on the error to recover the data regardless."
msgstr ""
"칉n cazul 칥n care firul care de탵inea `Mutex` intr캒 칥n panic캒, `Mutex` devine "
"\"otr캒vit\" pentru a semnala c캒 datele pe care le protejeaz캒 ar putea fi "
"칥ntr-o stare inconsistent캒. Apelul la `lock()` pe un mutex otr캒vit e탳ueaz캒 "
"cu un [`PoisonError`](https://doc.rust-lang.org/std/sync/struct.PoisonError."
"html). Pute탵i apela `into_inner()` la eroare pentru a recupera datele "
"indiferent de situa탵ie."

#: src/concurrency/shared-state/example.md
#, fuzzy
msgid "Let us see `Arc` and `Mutex` in action:"
msgstr "S캒 vedem `Arc` 탳i `Mutex` 칥n ac탵iune:"

#: src/concurrency/shared-state/example.md
#, fuzzy
msgid "// use std::sync::{Arc, Mutex};\n"
msgstr "// folosi탵i std::sync::{Arc, Mutex};\n"

#: src/concurrency/shared-state/example.md
msgid "Possible solution:"
msgstr "O posibil캒 solu탵ie:"

#: src/concurrency/shared-state/example.md
msgid "Notable parts:"
msgstr "P캒r탵i notabile:"

#: src/concurrency/shared-state/example.md
#, fuzzy
msgid ""
"`v` is wrapped in both `Arc` and `Mutex`, because their concerns are "
"orthogonal."
msgstr ""
"`v` este 칥nf캒탳urat at칙t 칥n `Arc` c칙t 탳i 칥n `Mutex`, deoarece preocup캒rile "
"lor sunt ortogonale."

#: src/concurrency/shared-state/example.md
#, fuzzy
msgid ""
"Wrapping a `Mutex` in an `Arc` is a common pattern to share mutable state "
"between threads."
msgstr ""
"칉nf캒탳urarea unui `Mutex` 칥ntr-un `Arc` este un model comun de partajare a "
"st캒rii mutabile 칥ntre fire."

#: src/concurrency/shared-state/example.md
#, fuzzy
msgid ""
"`v: Arc<_>` needs to be cloned as `v2` before it can be moved into another "
"thread. Note `move` was added to the lambda signature."
msgstr ""
"`v: Arc<_>` trebuie s캒 fie clonat ca `v2` 칥nainte de a putea fi mutat 칥ntr-"
"un alt fir de execu탵ie. Re탵ine탵i c캒 `move` a fost ad캒ugat la semn캒tura "
"lambda."

#: src/concurrency/shared-state/example.md
#, fuzzy
msgid ""
"Blocks are introduced to narrow the scope of the `LockGuard` as much as "
"possible."
msgstr ""
"Blocurile sunt introduse pentru a restr칙nge c칙t mai mult posibil domeniul de "
"aplicare al `LockGuard`."

#: src/concurrency/sync-exercises.md
#, fuzzy
msgid ""
"[Dining Philosophers](./concurrency/sync-exercises/dining-philosophers.md) "
"(20 minutes)"
msgstr ""
"[Dining Philosophers](./concurrency/sync-exercises/dining-philosophers.md) "
"(20 minute)"

#: src/concurrency/sync-exercises.md
#, fuzzy
msgid ""
"[Multi-threaded Link Checker](./concurrency/sync-exercises/link-checker.md) "
"(20 minutes)"
msgstr ""
"[Verificator de leg캒turi cu mai multe fire](./concurrency/sync-exercises/"
"link-checker.md) (20 minute)"

#: src/concurrency/sync-exercises.md
#, fuzzy
msgid "[Solutions](./concurrency/sync-exercises/solutions.md) (30 minutes)"
msgstr "[탲iruri](./types-and-values/strings.md) (10 minute)"

#: src/concurrency/sync-exercises.md src/concurrency/async-exercises.md
#, fuzzy
msgid "This segment should take about 1 hour and 10 minutes"
msgstr "Acest segment ar trebui s캒 dureze aproximativ 1 or캒 탳i 10 minute"

#: src/concurrency/sync-exercises/dining-philosophers.md
#, fuzzy
msgid "The dining philosophers problem is a classic problem in concurrency:"
msgstr ""
"Problema filozofilor care servesc masa este o problem캒 clasic캒 칥n domeniul "
"concuren탵ei:"

#: src/concurrency/sync-exercises/dining-philosophers.md
#, fuzzy
msgid ""
"Five philosophers dine together at the same table. Each philosopher has "
"their own place at the table. There is a fork between each plate. The dish "
"served is a kind of spaghetti which has to be eaten with two forks. Each "
"philosopher can only alternately think and eat. Moreover, a philosopher can "
"only eat their spaghetti when they have both a left and right fork. Thus two "
"forks will only be available when their two nearest neighbors are thinking, "
"not eating. After an individual philosopher finishes eating, they will put "
"down both forks."
msgstr ""
"Cinci filozofi iau masa 칥mpreun캒 la aceea탳i mas캒. Fiecare filozof are "
"propriul loc la mas캒. 칉ntre fiecare farfurie se afl캒 c칙te o furculi탵캒. Felul "
"de m칙ncare servit este un fel de spaghete care trebuie m칙ncate cu dou캒 "
"furculi탵e. Fiecare filozof nu poate dec칙t s캒 g칙ndeasc캒 탳i s캒 m캒n칙nce "
"alternativ. 칉n plus, un filozof poate m칙nca spaghetele doar dac캒 are at칙t "
"furculi탵a din st칙nga, c칙t 탳i cea din dreapta. Astfel, cele dou캒 furculi탵e "
"vor fi disponibile doar atunci c칙nd cei doi vecini cei mai apropia탵i "
"g칙ndesc, nu m캒n칙nc캒. Dup캒 ce un filozof individual termin캒 de m칙ncat, el va "
"pune jos ambele furculi탵e."

#: src/concurrency/sync-exercises/dining-philosophers.md
#, fuzzy
msgid ""
"You will need a local [Cargo installation](../../cargo/running-locally.md) "
"for this exercise. Copy the code below to a file called `src/main.rs`, fill "
"out the blanks, and test that `cargo run` does not deadlock:"
msgstr ""
"Ve탵i avea nevoie de o [instalare Cargo] local캒 (../../cargo/running-locally."
"md) pentru acest exerci탵iu. Copia탵i codul de mai jos 칥ntr-un fi탳ier numit "
"`src/main.rs`, completa탵i spa탵iile goale 탳i testa탵i dac캒 `cargo run` nu se "
"blocheaz캒:"

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/dining-philosophers.md
#, fuzzy
msgid ""
"// left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
msgstr ""
"// left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/sync-exercises/solutions.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "\"Eureka! {} has a new idea!\""
msgstr "\"Eureka! {} are o idee nou캒!\""

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "// Pick up forks...\n"
msgstr "// Ridica탵i furculi탵ele...\n"

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/sync-exercises/solutions.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "\"{} is eating...\""
msgstr "\"{} m캒n칙nc캒...\""

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/sync-exercises/solutions.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "\"Socrates\""
msgstr "L캒zi HAL"

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/sync-exercises/solutions.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "\"Hypatia\""
msgstr "\"Hypatia\""

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/sync-exercises/solutions.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "\"Plato\""
msgstr "\"Platon\""

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/sync-exercises/solutions.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "\"Aristotle\""
msgstr "\"Aristotel\""

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/sync-exercises/solutions.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "\"Pythagoras\""
msgstr "\"Pythagoras\""

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "// Create forks\n"
msgstr "// Crea탵i furci\n"

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "// Create philosophers\n"
msgstr "// Crea탵i filosofi\n"

#: src/concurrency/sync-exercises/dining-philosophers.md
#, fuzzy
msgid "// Make each of them think and eat 100 times\n"
msgstr ""
"// F캒-i pe fiecare dintre ei s캒 g칙ndeasc캒 탳i s캒 m캒n칙nce de 100 de ori\n"

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "// Output their thoughts\n"
msgstr "// Emite탵i g칙ndurile lor\n"

#: src/concurrency/sync-exercises/dining-philosophers.md
#, fuzzy
msgid "You can use the following `Cargo.toml`:"
msgstr "Pute탵i utiliza urm캒torul `Cargo.toml`:"

#: src/concurrency/sync-exercises/dining-philosophers.md
#, fuzzy
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"```"
msgstr ""
"```toml\n"
"[pachet]\n"
"name = \"dining-philosophers\"\n"
"versiune = \"0.1.0\"\n"
"edition = \"2021\"\n"
"```"

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid ""
"Let us use our new knowledge to create a multi-threaded link checker. It "
"should start at a webpage and check that links on the page are valid. It "
"should recursively check other pages on the same domain and keep doing this "
"until all pages have been validated."
msgstr ""
"S캒 folosim noile noastre cuno탳tin탵e pentru a crea un verificator de leg캒turi "
"cu mai multe fire. Acesta ar trebui s캒 porneasc캒 de la o pagin캒 web 탳i s캒 "
"verifice dac캒 leg캒turile de pe pagin캒 sunt valide. Ar trebui s캒 verifice 칥n "
"mod recursiv alte pagini din acela탳i domeniu 탳i s캒 continue s캒 fac캒 acest "
"lucru p칙n캒 c칙nd toate paginile sunt validate."

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid ""
"For this, you will need an HTTP client such as [`reqwest`](https://docs.rs/"
"reqwest/). You will also need a way to find links, we can use [`scraper`]"
"(https://docs.rs/scraper/). Finally, we'll need some way of handling errors, "
"we will use [`thiserror`](https://docs.rs/thiserror/)."
msgstr ""
"Pentru aceasta, ve탵i avea nevoie de un client HTTP, cum ar fi [`reqwest`]"
"(https://docs.rs/reqwest/). De asemenea, ve탵i avea nevoie de o modalitate de "
"a g캒si link-uri, putem folosi [`scraper`](https://docs.rs/scraper/). 칉n cele "
"din urm캒, vom avea nevoie de o modalitate de gestionare a erorilor, vom "
"folosi [`thiserror`](https://docs.rs/thiserror/)."

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid "Create a new Cargo project and `reqwest` it as a dependency with:"
msgstr "Crea탵i un nou proiect Cargo 탳i ad캒uga탵i urm캒toarele dependen탵e:"

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid ""
"If `cargo add` fails with `error: no such subcommand`, then please edit the "
"`Cargo.toml` file by hand. Add the dependencies listed below."
msgstr ""
"Dac캒 `cargo add` e탳ueaz캒 cu `error: no such subcommand`, atunci v캒 rug캒m s캒 "
"edita탵i manual fi탳ierul `Cargo.toml`. Ad캒uga탵i dependen탵ele enumerate mai "
"jos."

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid ""
"The `cargo add` calls will update the `Cargo.toml` file to look like this:"
msgstr ""
"Apelurile `cargo add` vor actualiza fi탳ierul `Cargo.toml` astfel 칥nc칙t s캒 "
"arate astfel:"

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid ""
"```toml\n"
"[package]\n"
"name = \"link-checker\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-"
"tls\"] }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"
msgstr ""
"```toml\n"
"[pachet]\n"
"name = \"link-checker\"\n"
"versiune = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependen탵e]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-"
"tls\"]] } }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid ""
"You can now download the start page. Try with a small site such as `https://"
"www.google.org/`."
msgstr ""
"Acum pute탵i desc캒rca pagina de start. 칉ncerca탵i cu un site mic, cum ar fi "
"`https://www.google.org/`."

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid "Your `src/main.rs` file should look something like this:"
msgstr "Fi탳ierul dvs. `src/main.rs` ar trebui s캒 arate cam a탳a:"

#: src/concurrency/sync-exercises/link-checker.md
#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "\"request error: {0}\""
msgstr "\"eroare de solicitare: {0}\""

#: src/concurrency/sync-exercises/link-checker.md
#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "\"bad http response: {0}\""
msgstr "\"bad http response: {0}\""

#: src/concurrency/sync-exercises/link-checker.md
#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "\"Checking {:#}\""
msgstr "Verificarea 칥mprumuturilor"

#: src/concurrency/sync-exercises/link-checker.md
#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "\"href\""
msgstr "\"href\""

#: src/concurrency/sync-exercises/link-checker.md
#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "\"On {base_url:#}: ignored unparsable {href:?}: {err}\""
msgstr "\"On {base_url:#}: ignorat neparsabil {href:?}: {err}\""

#: src/concurrency/sync-exercises/link-checker.md
#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "\"https://www.google.org\""
msgstr "\"https://www.google.org\""

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid "\"Links: {links:#?}\""
msgstr "\"Link-uri: {links:#?}\""

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid "\"Could not extract links: {err:#}\""
msgstr "\"Could not extract links: {err:#}\""

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid "Run the code in `src/main.rs` with"
msgstr "Rula탵i codul din `src/main.rs` cu"

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid ""
"Use threads to check the links in parallel: send the URLs to be checked to a "
"channel and let a few threads check the URLs in parallel."
msgstr ""
"Folosi탵i fire de execu탵ie pentru a verifica leg캒turile 칥n paralel: trimite탵i "
"URL-urile care trebuie verificate pe un canal 탳i l캒sa탵i c칙teva fire de "
"execu탵ie s캒 verifice URL-urile 칥n paralel."

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid ""
"Extend this to recursively extract links from all pages on the `www.google."
"org` domain. Put an upper limit of 100 pages or so so that you don't end up "
"being blocked by the site."
msgstr ""
"Extinde탵i acest lucru pentru a extrage 칥n mod recursiv leg캒turile din toate "
"paginile de pe domeniul `www.google.org`. Pune탵i o limit캒 superioar캒 de "
"aproximativ 100 de pagini, astfel 칥nc칙t s캒 nu ajunge탵i s캒 fi탵i blocat de "
"site."

#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "\"{} is trying to eat\""
msgstr "\"{} 칥ncearc캒 s캒 m캒n칙nce\""

#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid ""
"// To avoid a deadlock, we have to break the symmetry\n"
"        // somewhere. This will swap the forks without deinitializing\n"
"        // either of them.\n"
msgstr ""
"// Pentru a evita un blocaj, trebuie s캒 rupem simetria\n"
"            // undeva. Acest lucru va schimba bifurca탵iile de fire de "
"execu탵ie \n"
"           //f캒r캒 a dezinitializa niciuna dintre ele.\n"

#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "\"{thought}\""
msgstr "\"{thought}\""

#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "Link Checker"
msgstr "Verificator de leg캒turi"

#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid ""
"/// Determine whether links within the given page should be extracted.\n"
msgstr "/// Determin캒 dac캒 leg캒turile din pagina dat캒 trebuie extrase.\n"

#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid ""
"/// Mark the given page as visited, returning false if it had already\n"
"    /// been visited.\n"
msgstr ""
"/// Marcheaz캒 pagina dat캒 ca fiind vizitat캒, return칙nd false dac캒 a fost "
"deja vizitat캒\n"
"    /// fost vizitat캒.\n"

#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "// The sender got dropped. No more commands coming in.\n"
msgstr "// Expeditorul a fost abandonat. Nu mai vin comenzi.\n"

#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "\"Got crawling error: {:#}\""
msgstr "\"Am primit o eroare de crawling: {:#}\""

#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "\"Bad URLs: {:#?}\""
msgstr "\"URL-uri proaste: {:#?}\""

#: src/concurrency/welcome-async.md
#, fuzzy
msgid ""
"\"Async\" is a concurrency model where multiple tasks are executed "
"concurrently by executing each task until it would block, then switching to "
"another task that is ready to make progress. The model allows running a "
"larger number of tasks on a limited number of threads. This is because the "
"per-task overhead is typically very low and operating systems provide "
"primitives for efficiently identifying I/O that is able to proceed."
msgstr ""
"\"Async\" este un model de simultaneitate 칥n care mai multe sarcini sunt "
"executate simultan prin executarea fiec캒rei sarcini p칙n캒 c칙nd se blocheaz캒, "
"apoi se trece la o alt캒 sarcin캒 care este gata s캒 progreseze. Acest model "
"permite rularea unui num캒r mai mare de sarcini pe un num캒r limitat de fire "
"de execu탵ie. Acest lucru se datoreaz캒 faptului c캒, de obicei, costurile de "
"operare per sarcin캒 sunt foarte sc캒zute, iar sistemele de operare ofer캒 "
"primitive pentru identificarea eficient캒 a I/O care pot continua."

#: src/concurrency/welcome-async.md
#, fuzzy
msgid ""
"Rust's asynchronous operation is based on \"futures\", which represent work "
"that may be completed in the future. Futures are \"polled\" until they "
"signal that they are complete."
msgstr ""
"Func탵ionarea asincron캒 a Rust se bazeaz캒 pe \"futures\", care reprezint캒 "
"munca ce poate fi finalizat캒 칥n viitor. Futures sunt \"interogate\" p칙n캒 "
"c칙nd semnaleaz캒 c캒 sunt finalizate."

#: src/concurrency/welcome-async.md
#, fuzzy
msgid ""
"Futures are polled by an async runtime, and several different runtimes are "
"available."
msgstr ""
"Futures sunt interogate de un timp de execu탵ie asincron 탳i sunt disponibile "
"mai multe timpuri de execu탵ie diferite."

#: src/concurrency/welcome-async.md
#, fuzzy
msgid ""
"Python has a similar model in its `asyncio`. However, its `Future` type is "
"callback-based, and not polled. Async Python programs require a \"loop\", "
"similar to a runtime in Rust."
msgstr ""
"Python are un model similar 칥n `asyncio`. Cu toate acestea, tipul s캒u "
"`Future` se bazeaz캒 pe callback 탳i nu pe polled. Programele asincrone din "
"Python necesit캒 o \"bucl캒\", similar캒 cu un timp de execu탵ie 칥n Rust."

#: src/concurrency/welcome-async.md
#, fuzzy
msgid ""
"JavaScript's `Promise` is similar, but again callback-based. The language "
"runtime implements the event loop, so many of the details of Promise "
"resolution are hidden."
msgstr ""
"`Promise` din JavaScript este similar, dar se bazeaz캒 din nou pe callback. "
"Timpul de execu탵ie al limbajului implementeaz캒 bucla de evenimente, astfel "
"칥nc칙t multe dintre detaliile rezolv캒rii promisiunilor sunt ascunse."

#: src/concurrency/welcome-async.md
#, fuzzy
msgid "[Async Basics](./concurrency/async.md) (30 minutes)"
msgstr "[Generice](../generics.md) (45 minute)"

#: src/concurrency/welcome-async.md
#, fuzzy
msgid ""
"[Channels and Control Flow](./concurrency/async-control-flow.md) (20 minutes)"
msgstr ""
"[Las캒 controlul s캒 curg캒](./pattern-matching/let-control-flow.md) (10 minute)"

#: src/concurrency/welcome-async.md
#, fuzzy
msgid "[Pitfalls](./concurrency/async-pitfalls.md) (55 minutes)"
msgstr "[Referin탵e](../references.md) (50 minute)"

#: src/concurrency/welcome-async.md
#, fuzzy
msgid "[Exercises](./concurrency/async-exercises.md) (1 hour and 10 minutes)"
msgstr "[Exerci탵iu: Geometrie](./references/exercise.md) (30 minute)"

#: src/concurrency/async.md
#, fuzzy
msgid "[async/await](./concurrency/async/async-await.md) (10 minutes)"
msgstr "[async/await](./concurrency/async/async/async-await.md) (10 minute)"

#: src/concurrency/async.md
#, fuzzy
msgid "[Futures](./concurrency/async/futures.md) (4 minutes)"
msgstr "[탲iruri](./types-and-values/strings.md) (10 minute)"

#: src/concurrency/async.md
#, fuzzy
msgid "[Runtimes](./concurrency/async/runtimes.md) (10 minutes)"
msgstr "[탲iruri](./types-and-values/strings.md) (10 minute)"

#: src/concurrency/async.md
#, fuzzy
msgid "[Tasks](./concurrency/async/tasks.md) (10 minutes)"
msgstr "[탲iruri](./types-and-values/strings.md) (10 minute)"

#: src/concurrency/async/async-await.md
#, fuzzy
msgid ""
"At a high level, async Rust code looks very much like \"normal\" sequential "
"code:"
msgstr ""
"La un nivel 칥nalt, codul Rust asincron seam캒n캒 foarte mult cu codul "
"secven탵ial \"normal\":"

#: src/concurrency/async/async-await.md
#, fuzzy
msgid "\"Count is: {i}!\""
msgstr "\"Contele este: {i}!\""

#: src/concurrency/async/async-await.md
#, fuzzy
msgid ""
"Note that this is a simplified example to show the syntax. There is no long "
"running operation or any real concurrency in it!"
msgstr ""
"Re탵ine탵i c캒 acesta este un exemplu simplificat pentru a ar캒ta sintaxa. Nu "
"exist캒 nicio opera탵iune de lung캒 durat캒 sau vreo concuren탵캒 real캒!"

#: src/concurrency/async/async-await.md
#, fuzzy
msgid "What is the return type of an async call?"
msgstr "Care este tipul de returnare al unui apel asincron?"

#: src/concurrency/async/async-await.md
#, fuzzy
msgid "Use `let future: () = async_main(10);` in `main` to see the type."
msgstr ""
"Utiliza탵i `let future: () = async_main(10);` 칥n `main` pentru a vedea tipul."

#: src/concurrency/async/async-await.md
#, fuzzy
msgid ""
"The \"async\" keyword is syntactic sugar. The compiler replaces the return "
"type with a future."
msgstr ""
"Cuv칙ntul cheie \"async\" este un zah캒r sintactic. Compilatorul 칥nlocuie탳te "
"tipul return cu un future."

#: src/concurrency/async/async-await.md
#, fuzzy
msgid ""
"You cannot make `main` async, without additional instructions to the "
"compiler on how to use the returned future."
msgstr ""
"Nu pute탵i face ca `main` s캒 fie asincron, f캒r캒 instruc탵iuni suplimentare "
"pentru compilator cu privire la modul de utilizare a viitorului returnat."

#: src/concurrency/async/async-await.md
#, fuzzy
msgid ""
"You need an executor to run async code. `block_on` blocks the current thread "
"until the provided future has run to completion."
msgstr ""
"Ave탵i nevoie de un executor pentru a rula cod asincron. `block_on` blocheaz캒 "
"firul curent p칙n캒 c칙nd viitorul furnizat a fost executat p칙n캒 la finalizare."

#: src/concurrency/async/async-await.md
#, fuzzy
msgid ""
"`.await` asynchronously waits for the completion of another operation. "
"Unlike `block_on`, `.await` doesn't block the current thread."
msgstr ""
"`.await` a탳teapt캒 칥n mod asincron finalizarea unei alte opera탵iuni. Spre "
"deosebire de `block_on`, `.await` nu blocheaz캒 firul curent."

#: src/concurrency/async/async-await.md
#, fuzzy
msgid ""
"`.await` can only be used inside an `async` function (or block; these are "
"introduced later)."
msgstr ""
"`.await` poate fi folosit numai 칥n interiorul unei func탵ii `async` (sau "
"bloc; acestea sunt prezentate mai t칙rziu)."

#: src/concurrency/async/futures.md
#, fuzzy
msgid ""
"[`Future`](https://doc.rust-lang.org/std/future/trait.Future.html) is a "
"trait, implemented by objects that represent an operation that may not be "
"complete yet. A future can be polled, and `poll` returns a [`Poll`](https://"
"doc.rust-lang.org/std/task/enum.Poll.html)."
msgstr ""
"[`Future`](https://doc.rust-lang.org/std/future/trait.Future.html) este o "
"tr캒s캒tur캒, implementat캒 de obiecte care reprezint캒 o opera탵iune care poate "
"s캒 nu fie 칥nc캒 finalizat캒. Un viitor poate fi interogat, iar `poll` "
"returneaz캒 un [`Poll`](https://doc.rust-lang.org/std/task/enum.Poll.html)."

#: src/concurrency/async/futures.md
#, fuzzy
msgid ""
"An async function returns an `impl Future`. It's also possible (but "
"uncommon) to implement `Future` for your own types. For example, the "
"`JoinHandle` returned from `tokio::spawn` implements `Future` to allow "
"joining to it."
msgstr ""
"O func탵ie asincron캒 returneaz캒 un `impl Future`. De asemenea, este posibil "
"(dar mai pu탵in obi탳nuit) s캒 implementa탵i `Future` pentru propriile tipuri. "
"De exemplu, `JoinHandle` returnat de `tokio::spawn` implementeaz캒 `Future` "
"pentru a permite 칥mbinarea cu acesta."

#: src/concurrency/async/futures.md
#, fuzzy
msgid ""
"The `.await` keyword, applied to a Future, causes the current async function "
"to pause until that Future is ready, and then evaluates to its output."
msgstr ""
"Cuv칙ntul cheie `.await`, aplicat la un Future, determin캒 func탵ia asincron캒 "
"curent캒 s캒 se opreasc캒 p칙n캒 c칙nd Future-ul este gata 탳i apoi evalueaz캒 la "
"ie탳ire."

#: src/concurrency/async/futures.md
#, fuzzy
msgid ""
"The `Future` and `Poll` types are implemented exactly as shown; click the "
"links to show the implementations in the docs."
msgstr ""
"Tipurile `Future` 탳i `Poll` sunt implementate exact a탳a cum se arat캒; face탵i "
"clic pe linkuri pentru a vedea implement캒rile din documenta탵ie."

#: src/concurrency/async/futures.md
#, fuzzy
msgid ""
"We will not get to `Pin` and `Context`, as we will focus on writing async "
"code, rather than building new async primitives. Briefly:"
msgstr ""
"Nu vom ajunge la `Pin` 탳i `Context`, deoarece ne vom concentra pe scrierea "
"de cod asincron, mai degrab캒 dec칙t pe construirea de noi primitive "
"asincrone. Pe scurt:"

#: src/concurrency/async/futures.md
#, fuzzy
msgid ""
"`Context` allows a Future to schedule itself to be polled again when an "
"event occurs."
msgstr ""
"`Context` permite unui Future s캒 se programeze pentru a fi interogat din nou "
"atunci c칙nd are loc un eveniment."

#: src/concurrency/async/futures.md
#, fuzzy
msgid ""
"`Pin` ensures that the Future isn't moved in memory, so that pointers into "
"that future remain valid. This is required to allow references to remain "
"valid after an `.await`."
msgstr ""
"`Pin` se asigur캒 c캒 viitorul nu este mutat 칥n memorie, astfel 칥nc칙t "
"indicatorii c캒tre acel viitor r캒m칙n valabili. Acest lucru este necesar "
"pentru a permite ca referin탵ele s캒 r캒m칙n캒 valabile dup캒 un `.await`."

#: src/concurrency/async/runtimes.md
#, fuzzy
msgid ""
"A _runtime_ provides support for performing operations asynchronously (a "
"_reactor_) and is responsible for executing futures (an _executor_). Rust "
"does not have a \"built-in\" runtime, but several options are available:"
msgstr ""
"Un _runtime_ ofer캒 suport pentru efectuarea de opera탵ii asincrone (un "
"_reactor_) 탳i este responsabil pentru executarea futures (un _executor_). "
"Rust nu are un timp de execu탵ie \"칥ncorporat\", dar sunt disponibile mai "
"multe op탵iuni:"

#: src/concurrency/async/runtimes.md
#, fuzzy
msgid ""
"[Tokio](https://tokio.rs/): performant, with a well-developed ecosystem of "
"functionality like [Hyper](https://hyper.rs/) for HTTP or [Tonic](https://"
"github.com/hyperium/tonic) for gRPC."
msgstr ""
"[Tokio](https://tokio.rs/): performant, cu un ecosistem bine dezvoltat de "
"func탵ionalit캒탵i precum [Hyper](https://hyper.rs/) pentru HTTP sau [Tonic]"
"(https://github.com/hyperium/tonic) pentru gRPC."

#: src/concurrency/async/runtimes.md
#, fuzzy
msgid ""
"[async-std](https://async.rs/): aims to be a \"std for async\", and includes "
"a basic runtime in `async::task`."
msgstr ""
"[async-std](https://async.rs/): 칥탳i propune s캒 fie un \"std pentru async\" "
"탳i include un timp de execu탵ie de baz캒 칥n `async::task`."

#: src/concurrency/async/runtimes.md
#, fuzzy
msgid "[smol](https://docs.rs/smol/latest/smol/): simple and lightweight"
msgstr "[smol](https://docs.rs/smol/latest/smol/): simplu 탳i u탳or"

#: src/concurrency/async/runtimes.md
#, fuzzy
msgid ""
"Several larger applications have their own runtimes. For example, [Fuchsia]"
"(https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/lib/fuchsia-"
"async/src/lib.rs) already has one."
msgstr ""
"Mai multe aplica탵ii mai mari au propriile lor timpuri de execu탵ie. De "
"exemplu, [Fuchsia](https://fuchsia.googlesource.com/fuchsia/+/refs/heads/"
"main/src/lib/fuchsia-async/src/lib.rs) are deja unul."

#: src/concurrency/async/runtimes.md
#, fuzzy
msgid ""
"Note that of the listed runtimes, only Tokio is supported in the Rust "
"playground. The playground also does not permit any I/O, so most interesting "
"async things can't run in the playground."
msgstr ""
"Re탵ine탵i c캒, dintre timpii de execu탵ie enumera탵i, numai Tokio este acceptat "
"칥n zona de joac캒 Rust. De asemenea, terenul de joac캒 nu permite niciun fel "
"de I/O, astfel 칥nc칙t cele mai multe lucruri asincrone interesante nu pot fi "
"rulate 칥n terenul de joac캒."

#: src/concurrency/async/runtimes.md
#, fuzzy
msgid ""
"Futures are \"inert\" in that they do not do anything (not even start an I/O "
"operation) unless there is an executor polling them. This differs from JS "
"Promises, for example, which will run to completion even if they are never "
"used."
msgstr ""
"Futures sunt \"iner탵i\", 칥n sensul c캒 nu fac nimic (nici m캒car nu 칥ncep o "
"opera탵iune de I/O) dec칙t dac캒 exist캒 un executor care s캒 le interogheze. "
"Acest lucru este diferit de JS Promises, de exemplu, care vor fi executate "
"p칙n캒 la finalizare chiar dac캒 nu sunt folosite niciodat캒."

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid "Tokio provides:"
msgstr "Tokio ofer캒:"

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid "A multi-threaded runtime for executing asynchronous code."
msgstr ""
"Un timp de execu탵ie cu mai multe fire de execu탵ie pentru executarea de cod "
"asincron."

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid "An asynchronous version of the standard library."
msgstr "O versiune asincron캒 a bibliotecii standard."

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid "A large ecosystem of libraries."
msgstr "Un ecosistem mare de biblioteci."

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid "\"Count in task: {i}!\""
msgstr "\"Num캒r캒toarea 칥n sarcin캒: {i}!\""

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid "\"Main task: {i}\""
msgstr "\"Sarcina principal캒: {i}\""

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid "With the `tokio::main` macro we can now make `main` async."
msgstr ""
"Cu ajutorul macroului `tokio::main` putem face acum ca `main` s캒 fie "
"asincronizat."

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid "The `spawn` function creates a new, concurrent \"task\"."
msgstr "Func탵ia `spawn` creeaz캒 o nou캒 \"sarcin캒\" concurent캒."

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid "Note: `spawn` takes a `Future`, you don't call `.await` on `count_to`."
msgstr "Not캒: `spawn` ia un `Future`, nu se apeleaz캒 `.await` pe `count_to`."

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid "**Further exploration:**"
msgstr "**Explorare suplimentar캒:**"

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid ""
"Why does `count_to` not (usually) get to 10? This is an example of async "
"cancellation. `tokio::spawn` returns a handle which can be awaited to wait "
"until it finishes."
msgstr ""
"De ce `count_to` nu ajunge (de obicei) la 10? Acesta este un exemplu de "
"anulare asincron캒. `tokio::spawn` returneaz캒 un handle care poate fi "
"a탳teptat pentru a a탳tepta p칙n캒 c칙nd se termin캒."

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid "Try `count_to(10).await` instead of spawning."
msgstr "칉ncearc캒 `count_to(10).await` 칥n loc de spawning."

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid "Try awaiting the task returned from `tokio::spawn`."
msgstr "칉ncerca탵i s캒 a탳tepta탵i sarcina returnat캒 de `tokio::spawn`."

#: src/concurrency/async/tasks.md
#, fuzzy
msgid "Rust has a task system, which is a form of lightweight threading."
msgstr "Rust are un sistem de sarcini, care este o form캒 de threading u탳or."

#: src/concurrency/async/tasks.md
#, fuzzy
msgid ""
"A task has a single top-level future which the executor polls to make "
"progress. That future may have one or more nested futures that its `poll` "
"method polls, corresponding loosely to a call stack. Concurrency within a "
"task is possible by polling multiple child futures, such as racing a timer "
"and an I/O operation."
msgstr ""
"O sarcin캒 are un singur viitor de nivel superior pe care executorul 칥l "
"sondeaz캒 pentru a progresa. Acel viitor poate avea unul sau mai multe "
"viitoare imbricate pe care metoda sa `poll` le interogheaz캒, ceea ce "
"corespunde, 칥n linii mari, unei stive de apeluri. Concuren탵a 칥n cadrul unei "
"sarcini este posibil캒 prin interogarea mai multor futures mai mici, cum ar "
"fi cursele dintre un cronometru 탳i o opera탵iune I/O."

#: src/concurrency/async/tasks.md
#, fuzzy
msgid "\"127.0.0.1:0\""
msgstr "\"127.0.0.1:0\""

#: src/concurrency/async/tasks.md
#, fuzzy
msgid "\"listening on port {}\""
msgstr "\"ascult칙nd pe portul 2000\""

#: src/concurrency/async/tasks.md
#, fuzzy
msgid "\"connection from {addr:?}\""
msgstr "\"Conexiune nou캒 de la {addr:?}\""

#: src/concurrency/async/tasks.md
#, fuzzy
msgid "b\"Who are you?\\n\""
msgstr "b \"Cine e탳ti tu?\\n\""

#: src/concurrency/async/tasks.md
#, fuzzy
msgid "\"socket error\""
msgstr "\"eroare de socket\""

#: src/concurrency/async/tasks.md
#, fuzzy
msgid "\"Thanks for dialing in, {name}!\\n\""
msgstr "\"Mul탵umesc c캒 a탵i sunat, {name}!\\n\""

#: src/concurrency/async/tasks.md src/concurrency/async-control-flow/join.md
#, fuzzy
msgid ""
"Copy this example into your prepared `src/main.rs` and run it from there."
msgstr ""
"Copia탵i acest exemplu 칥n fi탳ierul preg캒tit `src/main.rs` 탳i rula탵i-l de "
"acolo."

#: src/concurrency/async/tasks.md
#, fuzzy
msgid ""
"Try connecting to it with a TCP connection tool like [nc](https://www.unix."
"com/man-page/linux/1/nc/) or [telnet](https://www.unix.com/man-page/linux/1/"
"telnet/)."
msgstr ""
"칉ncerca탵i s캒 v캒 conecta탵i la acesta cu un instrument de conexiune TCP, cum "
"ar fi [nc](https://www.unix.com/man-page/linux/1/nc/) sau [telnet](https://"
"www.unix.com/man-page/linux/1/telnet/)."

#: src/concurrency/async/tasks.md
#, fuzzy
msgid ""
"Ask students to visualize what the state of the example server would be with "
"a few connected clients. What tasks exist? What are their Futures?"
msgstr ""
"Cere탵i elevilor s캒 vizualizeze care ar fi starea serverului de exemplu cu "
"c칙탵iva clien탵i conecta탵i. Ce sarcini exist캒? Care este viitorul lor?"

#: src/concurrency/async/tasks.md
#, fuzzy
msgid ""
"This is the first time we've seen an `async` block. This is similar to a "
"closure, but does not take any arguments. Its return value is a Future, "
"similar to an `async fn`."
msgstr ""
"Aceasta este prima dat캒 c칙nd vedem un bloc `async`. Acesta este asem캒n캒tor "
"cu o 칥nchidere, dar nu prime탳te niciun argument. Valoarea sa de 칥ntoarcere "
"este un Future, similar cu un `async fn`."

#: src/concurrency/async/tasks.md
#, fuzzy
msgid ""
"Refactor the async block into a function, and improve the error handling "
"using `?`."
msgstr ""
"Reface탵i blocul asincron 칥ntr-o func탵ie 탳i 칥mbun캒t캒탵i탵i gestionarea erorilor "
"folosind `?`."

#: src/concurrency/async-control-flow.md
#, fuzzy
msgid ""
"[Async Channels](./concurrency/async-control-flow/channels.md) (10 minutes)"
msgstr ""
"[Canale asincrone](./concurrency/async-control-flow/channels.md) (10 minute)"

#: src/concurrency/async-control-flow.md
#, fuzzy
msgid "[Join](./concurrency/async-control-flow/join.md) (4 minutes)"
msgstr "[Join](control-flow/join.md)"

#: src/concurrency/async-control-flow.md
#, fuzzy
msgid "[Select](./concurrency/async-control-flow/select.md) (5 minutes)"
msgstr "[Selectare](control-flow/select.md)"

#: src/concurrency/async-control-flow/channels.md
#, fuzzy
msgid ""
"Several crates have support for asynchronous channels. For instance `tokio`:"
msgstr ""
"Mai multe crates au suport pentru canale asincrone. De exemplu, `tokio`:"

#: src/concurrency/async-control-flow/channels.md
#, fuzzy
msgid "\"Received {count} pings so far.\""
msgstr "\"A primit {count} ping-uri p칙n캒 acum.\""

#: src/concurrency/async-control-flow/channels.md
#, fuzzy
msgid "\"ping_handler complete\""
msgstr "\"ping_handler complete\""

#: src/concurrency/async-control-flow/channels.md
#, fuzzy
msgid "\"Failed to send ping.\""
msgstr "\"Nu a reu탳it s캒 trimit캒 ping.\""

#: src/concurrency/async-control-flow/channels.md
#, fuzzy
msgid "\"Sent {} pings so far.\""
msgstr "\"A trimis {} ping-uri p칙n캒 acum.\""

#: src/concurrency/async-control-flow/channels.md
#, fuzzy
msgid "\"Something went wrong in ping handler task.\""
msgstr "\"Ceva a mers prost 칥n sarcina de gestionare a ping-ului.\""

#: src/concurrency/async-control-flow/channels.md
#, fuzzy
msgid "Change the channel size to `3` and see how it affects the execution."
msgstr ""
"Schimba탵i dimensiunea canalului la `3` 탳i vede탵i cum afecteaz캒 execu탵ia."

#: src/concurrency/async-control-flow/channels.md
#, fuzzy
msgid ""
"Overall, the interface is similar to the `sync` channels as seen in the "
"[morning class](concurrency/channels.md)."
msgstr ""
"칉n general, interfa탵a este similar캒 cu cea a canalelor `sync`, a탳a cum se "
"vede 칥n [morning class](concurrency/channels.md)."

#: src/concurrency/async-control-flow/channels.md
#, fuzzy
msgid "Try removing the `std::mem::drop` call. What happens? Why?"
msgstr "칉ncerca탵i s캒 elimina탵i apelul `std::mem::drop`. Ce se 칥nt칙mpl캒? De ce?"

#: src/concurrency/async-control-flow/channels.md
#, fuzzy
msgid ""
"The [Flume](https://docs.rs/flume/latest/flume/) crate has channels that "
"implement both `sync` and `async` `send` and `recv`. This can be convenient "
"for complex applications with both IO and heavy CPU processing tasks."
msgstr ""
"Crate [Flume](https://docs.rs/flume/latest/flume/) are canale care "
"implementeaz캒 at칙t `sync` c칙t 탳i `async` `send` 탳i `recv`. Acest lucru poate "
"fi convenabil pentru aplica탵iile complexe cu sarcini de procesare at칙t IO, "
"c칙t 탳i grele pentru CPU."

#: src/concurrency/async-control-flow/channels.md
#, fuzzy
msgid ""
"What makes working with `async` channels preferable is the ability to "
"combine them with other `future`s to combine them and create complex control "
"flow."
msgstr ""
"Ceea ce face ca lucrul cu canalele `async` s캒 fie preferabil este "
"capacitatea de a le combina cu alte `future` pentru a le combina 탳i a crea "
"un flux de control complex."

#: src/concurrency/async-control-flow/join.md
#, fuzzy
msgid ""
"A join operation waits until all of a set of futures are ready, and returns "
"a collection of their results. This is similar to `Promise.all` in "
"JavaScript or `asyncio.gather` in Python."
msgstr ""
"O opera탵iune de 칥mbinare a탳teapt캒 p칙n캒 c칙nd to탵i viitorii dintr-un set de "
"viitoare sunt gata 탳i returneaz캒 o colec탵ie de rezultate ale acestora. Acest "
"lucru este similar cu `Promise.all` 칥n JavaScript sau `asyncio.gather` 칥n "
"Python."

#: src/concurrency/async-control-flow/join.md
#, fuzzy
msgid "\"https://google.com\""
msgstr "\"https://google.com\""

#: src/concurrency/async-control-flow/join.md
#, fuzzy
msgid "\"https://httpbin.org/ip\""
msgstr "\"https://httpbin.org/ip\""

#: src/concurrency/async-control-flow/join.md
#, fuzzy
msgid "\"https://play.rust-lang.org/\""
msgstr "\"https://play.rust-lang.org/\""

#: src/concurrency/async-control-flow/join.md
#, fuzzy
msgid "\"BAD_URL\""
msgstr "\"BAD_URL\""

#: src/concurrency/async-control-flow/join.md
#, fuzzy
msgid ""
"For multiple futures of disjoint types, you can use `std::future::join!` but "
"you must know how many futures you will have at compile time. This is "
"currently in the `futures` crate, soon to be stabilised in `std::future`."
msgstr ""
"Pentru mai multe futures de tipuri disjuncte, pute탵i utiliza `std::future::"
"join!`, dar trebuie s캒 탳ti탵i c칙te futures ve탵i avea 칥n momentul compil캒rii. "
"Acest lucru se afl캒 칥n prezent 칥n cr캒iasa `futures`, urm칙nd a fi stabilizat "
"칥n cur칙nd 칥n `std::future`."

#: src/concurrency/async-control-flow/join.md
#, fuzzy
msgid ""
"The risk of `join` is that one of the futures may never resolve, this would "
"cause your program to stall."
msgstr ""
"Riscul `join` este ca unul dintre futures s캒 nu se rezolve niciodat캒, ceea "
"ce ar face ca programul dumneavoastr캒 s캒 se blocheze."

#: src/concurrency/async-control-flow/join.md
#, fuzzy
msgid ""
"You can also combine `join_all` with `join!` for instance to join all "
"requests to an http service as well as a database query. Try adding a "
"`tokio::time::sleep` to the future, using `futures::join!`. This is not a "
"timeout (that requires `select!`, explained in the next chapter), but "
"demonstrates `join!`."
msgstr ""
"De asemenea, pute탵i combina `join_all` cu `join!`, de exemplu, pentru a uni "
"toate cererile c캒tre un serviciu http, precum 탳i o interogare a unei baze de "
"date. 칉ncerca탵i s캒 ad캒uga탵i un `tokio::time::sleep` la viitor, folosind "
"`futures::join!`. Acesta nu este un timeout (care necesit캒 `select!`, "
"explicat 칥n capitolul urm캒tor), ci demonstreaz캒 `join!`."

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid ""
"A select operation waits until any of a set of futures is ready, and "
"responds to that future's result. In JavaScript, this is similar to `Promise."
"race`. In Python, it compares to `asyncio.wait(task_set, return_when=asyncio."
"FIRST_COMPLETED)`."
msgstr ""
"O opera탵iune de selectare a탳teapt캒 p칙n캒 c칙nd oricare dintre un set de "
"viitoare este gata 탳i r캒spunde la rezultatul viitorului respectiv. 칉n "
"JavaScript, aceast캒 opera탵iune este similar캒 cu `Promise.race`. 칉n Python, "
"se compar캒 cu `asyncio.wait(task_set, return_when=asyncio.FIRST_COMPLETED)`."

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid ""
"Similar to a match statement, the body of `select!` has a number of arms, "
"each of the form `pattern = future => statement`. When a `future` is ready, "
"its return value is destructured by the `pattern`. The `statement` is then "
"run with the resulting variables. The `statement` result becomes the result "
"of the `select!` macro."
msgstr ""
"La fel ca o instruc탵iune match, corpul instruc탵iunii `select!` are mai multe "
"bra탵e, fiecare de forma `pattern = future => statement`. C칙nd `future` este "
"gata, `statement` este executat cu variabilele din `pattern` legate de "
"rezultatul `future`."

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid "\"Felix\""
msgstr "\"Felix\""

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid "\"Failed to send cat.\""
msgstr "\"Nu a reu탳it s캒 trimit캒 pisica.\""

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid "\"Failed to send dog.\""
msgstr "\"Nu a reu탳it s캒 trimit캒 c칙inele.\""

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid "\"Failed to receive winner\""
msgstr "\"Nu a reu탳it s캒 primeasc캒 c칙탳tig캒torul\""

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid "\"Winner is {winner:?}\""
msgstr "\"C칙탳tig캒torul este {winner:?}\""

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid ""
"In this example, we have a race between a cat and a dog. "
"`first_animal_to_finish_race` listens to both channels and will pick "
"whichever arrives first. Since the dog takes 50ms, it wins against the cat "
"that take 500ms."
msgstr ""
"칉n acest exemplu, avem o curs캒 칥ntre o pisic캒 탳i un c칙ine. "
"`first_animal_to_finish_race` ascult캒 ambele canale 탳i 칥l va alege pe cel "
"care ajunge primul. Deoarece c칙inele are nevoie de 50ms, c칙탳tig캒 칥mpotriva "
"pisicii care are nevoie de 500ms."

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid ""
"You can use `oneshot` channels in this example as the channels are supposed "
"to receive only one `send`."
msgstr ""
"칉n acest exemplu, pute탵i utiliza canale `oneshot`, deoarece canalele trebuie "
"s캒 primeasc캒 doar un singur `send`."

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid ""
"Try adding a deadline to the race, demonstrating selecting different sorts "
"of futures."
msgstr ""
"칉ncerca탵i s캒 ad캒uga탵i un termen limit캒 la curs캒, demonstr칙nd c캒 a탵i selectat "
"diferite tipuri de viitoruri."

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid ""
"Note that `select!` drops unmatched branches, which cancels their futures. "
"It is easiest to use when every execution of `select!` creates new futures."
msgstr ""
"Re탵ine탵i c캒 `select!` renun탵캒 la ramurile nepotrivite, ceea ce anuleaz캒 "
"viitorul acestora. Este cel mai u탳or de utilizat atunci c칙nd fiecare "
"execu탵ie a `select!` creeaz캒 noi futures."

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid ""
"An alternative is to pass `&mut future` instead of the future itself, but "
"this can lead to issues, further discussed in the pinning slide."
msgstr ""
"O alternativ캒 este de a trece `&mut future` 칥n locul viitorului 칥nsu탳i, dar "
"acest lucru poate duce la probleme, discutate 칥n continuare 칥n slide-ul cu "
"privire la fixarea."

#: src/concurrency/async-pitfalls.md
#, fuzzy
msgid ""
"Async / await provides convenient and efficient abstraction for concurrent "
"asynchronous programming. However, the async/await model in Rust also comes "
"with its share of pitfalls and footguns. We illustrate some of them in this "
"chapter."
msgstr ""
"Async / await ofer캒 o abstractizare convenabil캒 탳i eficient캒 pentru "
"programarea asincron캒 concurent캒. Cu toate acestea, modelul async/await din "
"Rust vine 탳i el cu partea sa de capcane 탳i piedici. 칉n acest capitol "
"ilustr캒m c칙teva dintre ele:"

#: src/concurrency/async-pitfalls.md
#, fuzzy
msgid ""
"[Blocking the Executor](./concurrency/async-pitfalls/blocking-executor.md) "
"(10 minutes)"
msgstr "[Blocarea executorului](pitfalls/blocking-executor.md)"

#: src/concurrency/async-pitfalls.md
#, fuzzy
msgid "[Pin](./concurrency/async-pitfalls/pin.md) (20 minutes)"
msgstr "[탲iruri](./types-and-values/strings.md) (10 minute)"

#: src/concurrency/async-pitfalls.md
#, fuzzy
msgid ""
"[Async Traits](./concurrency/async-pitfalls/async-traits.md) (5 minutes)"
msgstr "[Tr캒s캒turi asincrone](pitfalls/async-traits.md)"

#: src/concurrency/async-pitfalls.md
#, fuzzy
msgid ""
"[Cancellation](./concurrency/async-pitfalls/cancellation.md) (20 minutes)"
msgstr "[Anulare](pitfalls/cancellation.md)"

#: src/concurrency/async-pitfalls/blocking-executor.md
#, fuzzy
msgid "Blocking the executor"
msgstr "Blocarea executorului"

#: src/concurrency/async-pitfalls/blocking-executor.md
#, fuzzy
msgid ""
"Most async runtimes only allow IO tasks to run concurrently. This means that "
"CPU blocking tasks will block the executor and prevent other tasks from "
"being executed. An easy workaround is to use async equivalent methods where "
"possible."
msgstr ""
"Majoritatea timpilor de execu탵ie asincron캒 permit doar executarea simultan캒 "
"a sarcinilor IO. Aceasta 칥nseamn캒 c캒 sarcinile care blocheaz캒 CPU vor bloca "
"executorul 탳i vor 칥mpiedica executarea altor sarcini. O solu탵ie u탳oar캒 este "
"utilizarea unor metode echivalente asincrone acolo unde este posibil."

#: src/concurrency/async-pitfalls/blocking-executor.md
#, fuzzy
msgid "\"future {id} slept for {duration_ms}ms, finished after {}ms\""
msgstr ""
"\"viitorul {id} a dormit timp de {duration_ms}ms, a terminat dup캒 {}ms\""

#: src/concurrency/async-pitfalls/blocking-executor.md
#, fuzzy
msgid "\"current_thread\""
msgstr "\"current_thread\""

#: src/concurrency/async-pitfalls/blocking-executor.md
#, fuzzy
msgid ""
"Run the code and see that the sleeps happen consecutively rather than "
"concurrently."
msgstr ""
"Rula탵i codul 탳i vede탵i c캒 somnul se produce consecutiv 탳i nu concomitent."

#: src/concurrency/async-pitfalls/blocking-executor.md
#, fuzzy
msgid ""
"The `\"current_thread\"` flavor puts all tasks on a single thread. This "
"makes the effect more obvious, but the bug is still present in the multi-"
"threaded flavor."
msgstr ""
"Aroma `\"current_thread\"` pune toate sarcinile pe un singur fir. Acest "
"lucru face ca efectul s캒 fie mai evident, dar eroarea este 칥nc캒 prezent캒 칥n "
"varianta cu mai multe fire."

#: src/concurrency/async-pitfalls/blocking-executor.md
#, fuzzy
msgid ""
"Switch the `std::thread::sleep` to `tokio::time::sleep` and await its result."
msgstr ""
"Schimb캒 `std::thread::sleep` cu `tokio::time::sleep` 탳i a탳teapt캒 rezultatul."

#: src/concurrency/async-pitfalls/blocking-executor.md
#, fuzzy
msgid ""
"Another fix would be to `tokio::task::spawn_blocking` which spawns an actual "
"thread and transforms its handle into a future without blocking the executor."
msgstr ""
"O alt캒 solu탵ie ar fi `tokio::task::spawn_blocking` care genereaz캒 un fir "
"real 탳i transform캒 m칙nerul s캒u 칥ntr-un viitor f캒r캒 a bloca executorul."

#: src/concurrency/async-pitfalls/blocking-executor.md
#, fuzzy
msgid ""
"You should not think of tasks as OS threads. They do not map 1 to 1 and most "
"executors will allow many tasks to run on a single OS thread. This is "
"particularly problematic when interacting with other libraries via FFI, "
"where that library might depend on thread-local storage or map to specific "
"OS threads (e.g., CUDA). Prefer `tokio::task::spawn_blocking` in such "
"situations."
msgstr ""
"Nu ar trebui s캒 v캒 g칙ndi탵i la sarcini ca la fire de sistem de operare. "
"Acestea nu se coreleaz캒 1 la 1 탳i majoritatea executorilor vor permite "
"rularea mai multor sarcini pe un singur fir OS. Acest lucru este deosebit de "
"problematic atunci c칙nd interac탵iona탵i cu alte biblioteci prin intermediul "
"FFI, 칥n cazul 칥n care biblioteca respectiv캒 ar putea depinde de stocarea "
"local캒 a firelor de execu탵ie sau ar putea fi mapat캒 pe anumite fire de "
"execu탵ie ale sistemului de operare (de exemplu, CUDA). Prefera탵i `tokio::"
"task::spawn_blocking` 칥n astfel de situa탵ii."

#: src/concurrency/async-pitfalls/blocking-executor.md
#, fuzzy
msgid ""
"Use sync mutexes with care. Holding a mutex over an `.await` may cause "
"another task to block, and that task may be running on the same thread."
msgstr ""
"Utiliza탵i mutexurile de sincronizare cu grij캒. Men탵inerea unui mutex peste "
"un `.await` poate provoca blocarea unei alte sarcini, iar acea sarcin캒 poate "
"fi executat캒 pe acela탳i fir."

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"Async blocks and functions return types implementing the `Future` trait. The "
"type returned is the result of a compiler transformation which turns local "
"variables into data stored inside the future."
msgstr ""
"Blocurile 탳i func탵iile asincrone returneaz캒 tipuri care implementeaz캒 "
"tr캒s캒tura `Future`. Tipul returnat este rezultatul unei transform캒ri a "
"compilatorului care transform캒 variabilele locale 칥n date stocate 칥n "
"interiorul viitorului."

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"Some of those variables can hold pointers to other local variables. Because "
"of that, the future should never be moved to a different memory location, as "
"it would invalidate those pointers."
msgstr ""
"Unele dintre aceste variabile pot con탵ine indicatori c캒tre alte variabile "
"locale. Din acest motiv, viitorul nu ar trebui s캒 fie mutat niciodat캒 칥ntr-o "
"alt캒 loca탵ie de memorie, deoarece aceasta ar invalida ace탳ti indicatori."

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"To prevent moving the future type in memory, it can only be polled through a "
"pinned pointer. `Pin` is a wrapper around a reference that disallows all "
"operations that would move the instance it points to into a different memory "
"location."
msgstr ""
"Pentru a preveni deplasarea tipului de viitor 칥n memorie, acesta poate fi "
"interogat numai prin intermediul unui pointer fixat. `Pin` este un 칥nveli탳 "
"칥n jurul unei referin탵e care interzice toate opera탵iunile care ar putea muta "
"instan탵a la care indic캒 칥ntr-o alt캒 loca탵ie de memorie."

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"// A work item. In this case, just sleep for the given time and respond\n"
"// with a message on the `respond_on` channel.\n"
msgstr ""
"// Un element de lucru. 칉n acest caz, doar dormi탵i pentru timpul dat 탳i "
"r캒spunde탵i\n"
"// cu un mesaj pe canalul `respond_on`.\n"

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid "// A worker which listens for work on a queue and performs it.\n"
msgstr "// Un lucr캒tor care ascult캒 munca 칥ntr-o coad캒 탳i o execut캒.\n"

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid "// Pretend to work.\n"
msgstr "// Pref캒-te c캒 lucrezi.\n"

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid "\"failed to send response\""
msgstr "\"nu a reu탳it s캒 trimit캒 r캒spunsul\""

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid "// TODO: report number of iterations every 100ms\n"
msgstr "// TODO: raporta탵i num캒rul de itera탵ii la fiecare 100ms\n"

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid "// A requester which requests work and waits for it to complete.\n"
msgstr ""
"// Un solicitant care solicit캒 lucr캒ri 탳i a탳teapt캒 ca acestea s캒 fie "
"finalizate.\n"

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid "\"failed to send on work queue\""
msgstr "\"nu a reu탳it s캒 trimit캒 칥n coada de lucru\""

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid "\"failed waiting for response\""
msgstr "\"e탳uat 칥n a탳teptarea r캒spunsului\""

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid "\"work result for iteration {i}: {resp}\""
msgstr "\"rezultatul muncii pentru itera탵ia {i}: {resp}\""

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"You may recognize this as an example of the actor pattern. Actors typically "
"call `select!` in a loop."
msgstr ""
"Este posibil s캒 recunoa탳te탵i acest lucru ca fiind un exemplu de model actor. "
"De obicei, actorii apeleaz캒 `select!` 칥ntr-o bucl캒."

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"This serves as a summation of a few of the previous lessons, so take your "
"time with it."
msgstr ""
"Aceasta este o rezumare a c칙torva dintre lec탵iile anterioare, a탳a c캒 nu v캒 "
"gr캒bi탵i cu ea."

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"Naively add a `_ = sleep(Duration::from_millis(100)) => { println!(..) }` to "
"the `select!`. This will never execute. Why?"
msgstr ""
"Ad캒uga탵i 칥n mod naiv un `_ = sleep(Duration::from_millis(100)) => { println!"
"(..) }` la `select!`. Aceasta nu se va executa niciodat캒. De ce?"

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"Instead, add a `timeout_fut` containing that future outside of the `loop`:"
msgstr ""
"칉n schimb, ad캒uga탵i un `timeout_fut` care s캒 con탵in캒 acel viitor 칥n afara "
"`loop`:"

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"This still doesn't work. Follow the compiler errors, adding `&mut` to the "
"`timeout_fut` in the `select!` to work around the move, then using `Box::"
"pin`:"
msgstr ""
"Acest lucru tot nu func탵ioneaz캒. Urma탵i erorile compilatorului, ad캒ug칙nd "
"`&mut` la `timeout_fut` 칥n `select!` pentru a evita deplasarea, apoi "
"utiliza탵i `Box::pin`:"

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"This compiles, but once the timeout expires it is `Poll::Ready` on every "
"iteration (a fused future would help with this). Update to reset "
"`timeout_fut` every time it expires."
msgstr ""
"Acest lucru se compileaz캒, dar odat캒 ce expir캒 timpul de a탳teptare este "
"`Poll::Ready` la fiecare itera탵ie (un viitor fuzionat ar ajuta cu acest "
"lucru). Actualiza탵i pentru a reseta `timeout_fut` de fiecare dat캒 c칙nd "
"expir캒."

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"Box allocates on the heap. In some cases, `std::pin::pin!` (only recently "
"stabilized, with older code often using `tokio::pin!`) is also an option, "
"but that is difficult to use for a future that is reassigned."
msgstr ""
"Box aloc캒 pe heap. 칉n unele cazuri, `std::pin::pin!` (stabilizat doar "
"recent, codul mai vechi folosind adesea `tokio::pin!`) este, de asemenea, o "
"op탵iune, dar este dificil de utilizat pentru un viitor care este realocat."

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"Another alternative is to not use `pin` at all but spawn another task that "
"will send to a `oneshot` channel every 100ms."
msgstr ""
"O alt캒 alternativ캒 este s캒 nu folosi탵i `pin` deloc, ci s캒 genera탵i o alt캒 "
"sarcin캒 care va trimite la un canal `oneshot` la fiecare 100ms."

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"Data that contains pointers to itself is called self-referential. Normally, "
"the Rust borrow checker would prevent self-referential data from being "
"moved, as the references cannot outlive the data they point to. However, the "
"code transformation for async blocks and functions is not verified by the "
"borrow checker."
msgstr ""
"Datele care con탵in indicatoare c캒tre ele 칥nsele se numesc autoreferen탵iale. "
"칉n mod normal, verificatorul de 칥mprumuturi Rust ar 칥mpiedica mutarea "
"datelor autoreferen탵iale, deoarece referin탵ele nu pot supravie탵ui datelor la "
"care indic캒. Cu toate acestea, transformarea codului pentru blocurile 탳i "
"func탵iile asincrone nu este verificat캒 de verificatorul de 칥mprumuturi."

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"`Pin` is a wrapper around a reference. An object cannot be moved from its "
"place using a pinned pointer. However, it can still be moved through an "
"unpinned pointer."
msgstr ""
"`Pin` este un 칥nveli탳 칥n jurul unei referin탵e. Un obiect nu poate fi mutat "
"de la locul s캒u folosind un pointer fixat. Cu toate acestea, el poate fi "
"mutat printr-un pointer nefixat."

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"The `poll` method of the `Future` trait uses `Pin<&mut Self>` instead of "
"`&mut Self` to refer to the instance. That's why it can only be called on a "
"pinned pointer."
msgstr ""
"Metoda `poll` a tr캒s캒turii `Future` utilizeaz캒 `Pin<&mut Self>` 칥n loc de "
"`&mut Self` pentru a se referi la instan탵캒. De aceea, poate fi apelat캒 numai "
"pe un pointer fixat."

#: src/concurrency/async-pitfalls/async-traits.md
#, fuzzy
msgid ""
"Async methods in traits are were stabilized only recently, in the 1.75 "
"release. This required support for using return-position `impl Trait` (RPIT) "
"in traits, as the desugaring for `async fn` includes `-> impl Future<Output "
"= ...>`."
msgstr ""
"Metodele asincrone din tr캒s캒turi au fost stabilizate doar recent, 칥n "
"versiunea 1.75. Acest lucru a necesitat suport pentru utilizarea pozi탵iei de "
"칥ntoarcere `impl Trait` (RPIT) 칥n traits, deoarece desugr캒virea pentru "
"`async fn` include `-> impl Future<Output = ...>`."

#: src/concurrency/async-pitfalls/async-traits.md
#, fuzzy
msgid ""
"However, even with the native support today there are some pitfalls around "
"`async fn` and RPIT in traits:"
msgstr ""
"Cu toate acestea, chiar 탳i cu suportul nativ de ast캒zi, exist캒 unele capcane "
"칥n jurul `async fn` 탳i RPIT 칥n tr캒s캒turi:"

#: src/concurrency/async-pitfalls/async-traits.md
#, fuzzy
msgid ""
"Return-position impl Trait captures all in-scope lifetimes (so some patterns "
"of borrowing cannot be expressed)"
msgstr ""
"Return-position impl Trait capteaz캒 toate duratele de via탵캒 din domeniul de "
"aplicare (astfel 칥nc칙t unele modele de 칥mprumut nu pot fi exprimate)"

#: src/concurrency/async-pitfalls/async-traits.md
#, fuzzy
msgid ""
"Traits whose methods use return-position `impl trait` or `async` are not "
"`dyn` compatible."
msgstr ""
"Tr캒s캒turile ale c캒ror metode utilizeaz캒 pozi탵ia de returnare `impl trait` "
"sau `async` nu sunt compatibile cu `dyn`."

#: src/concurrency/async-pitfalls/async-traits.md
#, fuzzy
msgid ""
"If we do need `dyn` support, the crate [async_trait](https://docs.rs/async-"
"trait/latest/async_trait/) provides a workaround through a macro, with some "
"caveats:"
msgstr ""
"Crate [async_trait](https://docs.rs/async-trait/latest/async_trait/) ofer캒 o "
"solu탵ie de rezolvare prin intermediul unei macro:"

#: src/concurrency/async-pitfalls/async-traits.md
#, fuzzy
msgid "\"running all sleepers..\""
msgstr "\"alerg칙nd to탵i cei care dorm...\""

#: src/concurrency/async-pitfalls/async-traits.md
#, fuzzy
msgid "\"slept for {}ms\""
msgstr "\"adormit pentru {}ms\""

#: src/concurrency/async-pitfalls/async-traits.md
#, fuzzy
msgid ""
"`async_trait` is easy to use, but note that it's using heap allocations to "
"achieve this. This heap allocation has performance overhead."
msgstr ""
"`async_trait` este u탳or de utilizat, dar re탵ine탵i c캒 utilizeaz캒 aloc캒ri heap "
"pentru a realiza acest lucru. Aceast캒 alocare 칥n heap are costuri "
"suplimentare de performan탵캒."

#: src/concurrency/async-pitfalls/async-traits.md
#, fuzzy
msgid ""
"The challenges in language support for `async trait` are deep Rust and "
"probably not worth describing in-depth. Niko Matsakis did a good job of "
"explaining them in [this post](https://smallcultfollowing.com/babysteps/"
"blog/2019/10/26/async-fn-in-traits-are-hard/) if you are interested in "
"digging deeper."
msgstr ""
"Provoc캒rile 칥n ceea ce prive탳te suportul lingvistic pentru `async trait` "
"sunt ad칙nci Rust 탳i probabil nu merit캒 s캒 fie descrise 칥n profunzime. Niko "
"Matsakis a f캒cut o treab캒 bun캒 explic칙ndu-le 칥n [aceast캒 postare](https://"
"smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-"
"hard/) dac캒 sunte탵i interesat s캒 aprofunda탵i."

#: src/concurrency/async-pitfalls/async-traits.md
#, fuzzy
msgid ""
"Try creating a new sleeper struct that will sleep for a random amount of "
"time and adding it to the Vec."
msgstr ""
"칉ncerca탵i s캒 crea탵i o nou캒 structur캒 de somn care va dormi pentru o perioad캒 "
"de timp aleatorie 탳i ad캒uga탵i-o la Vec."

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid ""
"Dropping a future implies it can never be polled again. This is called "
"_cancellation_ and it can occur at any `await` point. Care is needed to "
"ensure the system works correctly even when futures are cancelled. For "
"example, it shouldn't deadlock or lose data."
msgstr ""
"Renun탵area la un viitor implic캒 faptul c캒 acesta nu mai poate fi interogat "
"niciodat캒. Acest lucru se nume탳te _cancellation_ 탳i poate avea loc 칥n orice "
"punct de a탳teptare (`await`). Este necesar캒 o aten탵ie deosebit캒 pentru a se "
"asigura c캒 sistemul func탵ioneaz캒 corect chiar 탳i atunci c칙nd futures sunt "
"anulate. De exemplu, nu trebuie s캒 se blocheze sau s캒 piard캒 date."

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid "\"not UTF-8\""
msgstr ""
"탲irurile de caractere Rust sunt codificate UTF-8 탳i pot con탵ine orice "
"caracter Unicode."

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid "\"hi\\nthere\\n\""
msgstr "\"hi\\nthere\\n\""

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid "\"tick!\""
msgstr "\"tic!\""

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid ""
"The compiler doesn't help with cancellation-safety. You need to read API "
"documentation and consider what state your `async fn` holds."
msgstr ""
"Compilatorul nu v캒 ajut캒 칥n ceea ce prive탳te siguran탵a la anulare. Trebuie "
"s캒 citi탵i documenta탵ia API 탳i s캒 v캒 g칙ndi탵i la starea pe care o de탵ine "
"`async fn`."

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid ""
"Unlike `panic` and `?`, cancellation is part of normal control flow (vs "
"error-handling)."
msgstr ""
"Spre deosebire de `panic` 탳i `?`, anularea face parte din fluxul normal de "
"control (fa탵캒 de gestionarea erorilor)."

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid "The example loses parts of the string."
msgstr "Exemplul pierde p캒r탵i din 탳ir."

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid ""
"Whenever the `tick()` branch finishes first, `next()` and its `buf` are "
"dropped."
msgstr ""
"Ori de c칙te ori ramura `tick()` se termin캒 prima, se renun탵캒 la `next()` 탳i "
"la `buf` al acestuia."

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid ""
"`LinesReader` can be made cancellation-safe by making `buf` part of the "
"struct:"
msgstr ""
"`LinesReader` poate fi securizat 칥mpotriva anul캒rii prin includerea lui "
"`buf` 칥n structur캒:"

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid "// prefix buf and bytes with self.\n"
msgstr "// prefixeaz캒 buf 탳i bytes cu self.\n"

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid ""
"[`Interval::tick`](https://docs.rs/tokio/latest/tokio/time/struct.Interval."
"html#method.tick) is cancellation-safe because it keeps track of whether a "
"tick has been 'delivered'."
msgstr ""
"[`Interval::tick`](https://docs.rs/tokio/latest/tokio/time/struct.Interval."
"html#method.tick) este sigur 칥n ceea ce prive탳te anularea, deoarece 탵ine "
"eviden탵a dac캒 un tick a fost \"livrat\"."

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid ""
"[`AsyncReadExt::read`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncReadExt.html#method.read) is cancellation-safe because it either "
"returns or doesn't read data."
msgstr ""
"[`AsyncReadExt::read`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncReadExt.html#method.read) este sigur 칥n ceea ce prive탳te anularea, "
"deoarece fie returneaz캒, fie nu cite탳te datele."

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid ""
"[`AsyncBufReadExt::read_line`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncBufReadExt.html#method.read_line) is similar to the example and _isn't_ "
"cancellation-safe. See its documentation for details and alternatives."
msgstr ""
"[`AsyncBufReadExt::read_line`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncBufReadExt.html#method.read_line) este similar cu exemplul 탳i _nu este_ "
"sigur la anulare. Consulta탵i documenta탵ia sa pentru detalii 탳i alternative."

#: src/concurrency/async-exercises.md
#, fuzzy
msgid ""
"[Dining Philosophers](./concurrency/async-exercises/dining-philosophers.md) "
"(20 minutes)"
msgstr ""
"[Dining Philosophers](./concurrency/async-exercises/dining-philosophers.md) "
"(20 minute)"

#: src/concurrency/async-exercises.md
#, fuzzy
msgid ""
"[Broadcast Chat Application](./concurrency/async-exercises/chat-app.md) (30 "
"minutes)"
msgstr ""
"[Aplica탵ie de chat cu difuzare](./concurrency/async-exercises/chat-app.md) "
"(30 minute)"

#: src/concurrency/async-exercises.md
#, fuzzy
msgid "[Solutions](./concurrency/async-exercises/solutions.md) (20 minutes)"
msgstr "[탲iruri](./types-and-values/strings.md) (10 minute)"

#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "Dining Philosophers --- Async"
msgstr "Filozofii care m캒n칙nc캒 - Async"

#: src/concurrency/async-exercises/dining-philosophers.md
#, fuzzy
msgid ""
"See [dining philosophers](dining-philosophers.md) for a description of the "
"problem."
msgstr ""
"Vezi [dining philosophers](dining-philosophers.md) pentru o descriere a "
"problemei."

#: src/concurrency/async-exercises/dining-philosophers.md
#, fuzzy
msgid ""
"As before, you will need a local [Cargo installation](../../cargo/running-"
"locally.md) for this exercise. Copy the code below to a file called `src/"
"main.rs`, fill out the blanks, and test that `cargo run` does not deadlock:"
msgstr ""
"Ca 탳i 칥nainte, ve탵i avea nevoie de o [instalare Cargo] local캒 (../../cargo/"
"running-locally.md) pentru acest exerci탵iu. Copia탵i codul de mai jos 칥ntr-un "
"fi탳ier numit `src/main.rs`, completa탵i spa탵iile goale 탳i testa탵i dac캒 `cargo "
"run` nu se blocheaz캒:"

#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "// Keep trying until we have both forks\n"
msgstr "// Continu캒 s캒 칥ncerci p칙n캒 c칙nd avem ambele furci\n"

#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "// Make them think and eat\n"
msgstr "// F캒-i s캒 g칙ndeasc캒 탳i s캒 m캒n칙nce\n"

#: src/concurrency/async-exercises/dining-philosophers.md
#, fuzzy
msgid ""
"Since this time you are using Async Rust, you'll need a `tokio` dependency. "
"You can use the following `Cargo.toml`:"
msgstr ""
"Deoarece de data aceasta folosi탵i Async Rust, ve탵i avea nevoie de o "
"dependen탵캒 `tokio`. Pute탵i utiliza urm캒torul `Cargo.toml`:"

#: src/concurrency/async-exercises/dining-philosophers.md
#, fuzzy
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers-async-dine\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"tokio = { version = \"1.26.0\", features = [\"sync\", \"time\", \"macros\", "
"\"rt-multi-thread\"] }\n"
"```"
msgstr ""
"```toml\n"
"[pachet]\n"
"name = \"dining-philosophers-async-dine\"\n"
"versiune = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependen탵e]\n"
"tokio = {version = \"1.26.0\", features = [\"sync\", \"time\", \"macros\", "
"\"rt-multi-thread\"]}\n"
"```"

#: src/concurrency/async-exercises/dining-philosophers.md
#, fuzzy
msgid ""
"Also note that this time you have to use the `Mutex` and the `mpsc` module "
"from the `tokio` crate."
msgstr ""
"De asemenea, re탵ine탵i c캒 de data aceasta trebuie s캒 folosi탵i modulele "
"`Mutex` 탳i `mpsc` de la `tokio` crate."

#: src/concurrency/async-exercises/dining-philosophers.md
#, fuzzy
msgid "Can you make your implementation single-threaded?"
msgstr "Po탵i face ca implementarea ta s캒 fie cu un singur fir de execu탵ie?"

#: src/concurrency/async-exercises/chat-app.md
#, fuzzy
msgid ""
"In this exercise, we want to use our new knowledge to implement a broadcast "
"chat application. We have a chat server that the clients connect to and "
"publish their messages. The client reads user messages from the standard "
"input, and sends them to the server. The chat server broadcasts each message "
"that it receives to all the clients."
msgstr ""
"칉n acest exerci탵iu, dorim s캒 folosim noile noastre cuno탳tin탵e pentru a "
"implementa o aplica탵ie de chat cu difuzare. Avem un server de chat la care "
"clien탵ii se conecteaz캒 탳i 칥탳i public캒 mesajele. Clientul cite탳te mesajele "
"utilizatorilor de la intrarea standard 탳i le trimite la server. Serverul de "
"chat difuzeaz캒 fiecare mesaj pe care 칥l prime탳te c캒tre to탵i clien탵ii."

#: src/concurrency/async-exercises/chat-app.md
#, fuzzy
msgid ""
"For this, we use [a broadcast channel](https://docs.rs/tokio/latest/tokio/"
"sync/broadcast/fn.channel.html) on the server, and [`tokio_websockets`]"
"(https://docs.rs/tokio-websockets/) for the communication between the client "
"and the server."
msgstr ""
"Pentru aceasta, folosim [un canal de difuzare](https://docs.rs/tokio/latest/"
"tokio/sync/broadcast/fn.channel.html) pe server 탳i [`tokio_websockets`]"
"(https://docs.rs/tokio-websockets/0.4.0/tokio_websockets/) pentru "
"comunicarea dintre client 탳i server."

#: src/concurrency/async-exercises/chat-app.md
#, fuzzy
msgid "Create a new Cargo project and add the following dependencies:"
msgstr "Crea탵i un nou proiect Cargo 탳i ad캒uga탵i urm캒toarele dependen탵e:"

#: src/concurrency/async-exercises/chat-app.md
msgid "_Cargo.toml_:"
msgstr "_Cargo.toml_:"

#: src/concurrency/async-exercises/chat-app.md
#, fuzzy
msgid ""
"```toml\n"
"[package]\n"
"name = \"chat-async\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"futures-util = { version = \"0.3.30\", features = [\"sink\"] }\n"
"http = \"1.1.0\"\n"
"tokio = { version = \"1.37.0\", features = [\"full\"] }\n"
"tokio-websockets = { version = \"0.8.2\", features = [\"client\", "
"\"fastrand\", \"server\", \"sha1_smol\"] }\n"
"```"
msgstr ""
"```toml\n"
"[pachet]\n"
"name = \"chat-async\"\n"
"versiune = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependen탵e]\n"
"futures-util = { version = \"0.3.28\", features = [\"sink\"]] }\n"
"http = \"0.2.9\"\n"
"tokio = { version = \"1.28.1\", features = [\"full\"]] }\n"
"tokio-websockets = { version = \"0.4.0\", features = [\"client\", "
"\"fastrand\", \"server\", \"sha1_smol\"] } }\n"
"```"

#: src/concurrency/async-exercises/chat-app.md
msgid "The required APIs"
msgstr "API-urile necesare"

#: src/concurrency/async-exercises/chat-app.md
#, fuzzy
msgid ""
"You are going to need the following functions from `tokio` and "
"[`tokio_websockets`](https://docs.rs/tokio-websockets/). Spend a few minutes "
"to familiarize yourself with the API."
msgstr ""
"Ve탵i avea nevoie de urm캒toarele func탵ii din `tokio` 탳i [`tokio_websockets`]"
"(https://docs.rs/tokio-websockets/0.4.0/tokio_websockets/). Petrece탵i c칙teva "
"minute pentru a v캒 familiariza cu API-ul."

#: src/concurrency/async-exercises/chat-app.md
#, fuzzy
msgid ""
"[StreamExt::next()](https://docs.rs/futures-util/0.3.28/futures_util/stream/"
"trait.StreamExt.html#method.next) implemented by `WebSocketStream`: for "
"asynchronously reading messages from a Websocket Stream."
msgstr ""
"[StreamExt::next()](https://docs.rs/futures-util/0.3.28/futures_util/stream/"
"trait.StreamExt.html#method.next) implementat de `WebsocketStream`: pentru "
"citirea asincron캒 a mesajelor dintr-un flux Websocket."

#: src/concurrency/async-exercises/chat-app.md
#, fuzzy
msgid ""
"[SinkExt::send()](https://docs.rs/futures-util/0.3.28/futures_util/sink/"
"trait.SinkExt.html#method.send) implemented by `WebSocketStream`: for "
"asynchronously sending messages on a Websocket Stream."
msgstr ""
"[SinkExt::send()](https://docs.rs/futures-util/0.3.28/futures_util/sink/"
"trait.SinkExt.html#method.send) implementat de `WebsocketStream`: pentru "
"trimiterea asincron캒 de mesaje pe un flux Websocket."

#: src/concurrency/async-exercises/chat-app.md
#, fuzzy
msgid ""
"[Lines::next_line()](https://docs.rs/tokio/latest/tokio/io/struct.Lines."
"html#method.next_line): for asynchronously reading user messages from the "
"standard input."
msgstr ""
"[Lines::next_line()](https://docs.rs/tokio/latest/tokio/io/struct.Lines."
"html#method.next_line): pentru citirea asincron캒 a mesajelor utilizatorului "
"de la intrarea standard."

#: src/concurrency/async-exercises/chat-app.md
#, fuzzy
msgid ""
"[Sender::subscribe()](https://docs.rs/tokio/latest/tokio/sync/broadcast/"
"struct.Sender.html#method.subscribe): for subscribing to a broadcast channel."
msgstr ""
"[Sender::subscribe()](https://docs.rs/tokio/latest/tokio/sync/broadcast/"
"struct.Sender.html#method.subscribe): pentru abonarea la un canal de "
"difuzare."

#: src/concurrency/async-exercises/chat-app.md
msgid "Two binaries"
msgstr "Dou캒 binare"

#: src/concurrency/async-exercises/chat-app.md
msgid ""
"Normally in a Cargo project, you can have only one binary, and one `src/main."
"rs` file. In this project, we need two binaries. One for the client, and one "
"for the server. You could potentially make them two separate Cargo projects, "
"but we are going to put them in a single Cargo project with two binaries. "
"For this to work, the client and the server code should go under `src/bin` "
"(see the [documentation](https://doc.rust-lang.org/cargo/reference/cargo-"
"targets.html#binaries))."
msgstr ""
"칉n mod normal, 칥ntr-un proiect Cargo, pute탵i avea un singur fi탳ier binar 탳i "
"un singur fi탳ier `src/main.rs`. 칉n acest proiect, avem nevoie de dou캒 "
"fi탳iere binare. Unul pentru client 탳i unul pentru server. A탵i putea eventual "
"s캒 le face탵i dou캒 proiecte Cargo separate, dar noi le vom pune 칥ntr-un "
"singur proiect Cargo cu dou캒 binare. Pentru ca acest lucru s캒 func탵ioneze, "
"codul clientului 탳i cel al serverului trebuie s캒 se reg캒seasc캒 칥n `src/bin` "
"(a se vedea [documentation](https://doc.rust-lang.org/cargo/reference/cargo-"
"targets.html#binaries))."

#: src/concurrency/async-exercises/chat-app.md
msgid ""
"Copy the following server and client code into `src/bin/server.rs` and `src/"
"bin/client.rs`, respectively. Your task is to complete these files as "
"described below."
msgstr ""
"Copia탵i urm캒torul cod server 탳i client 칥n `src/bin/server.rs` 탳i, respectiv, "
"`src/bin/client.rs`. Sarcina dumneavoastr캒 este de a completa aceste fi탳iere "
"a탳a cum este descris mai jos."

#: src/concurrency/async-exercises/chat-app.md
#: src/concurrency/async-exercises/solutions.md
msgid "_src/bin/server.rs_:"
msgstr "_src/bin/server.rs_:"

#: src/concurrency/async-exercises/chat-app.md
msgid "// TODO: For a hint, see the description of the task below.\n"
msgstr ""
"// TODO: Pentru un indiciu, consulta탵i descrierea sarcinii de mai jos.\n"

#: src/concurrency/async-exercises/chat-app.md
#: src/concurrency/async-exercises/solutions.md
msgid "\"127.0.0.1:2000\""
msgstr "\"127.0.0.1:2000\""

#: src/concurrency/async-exercises/chat-app.md
#: src/concurrency/async-exercises/solutions.md
msgid "\"listening on port 2000\""
msgstr "\"ascult칙nd pe portul 2000\""

#: src/concurrency/async-exercises/chat-app.md
#: src/concurrency/async-exercises/solutions.md
msgid "\"New connection from {addr:?}\""
msgstr "\"Conexiune nou캒 de la {addr:?}\""

#: src/concurrency/async-exercises/chat-app.md
#: src/concurrency/async-exercises/solutions.md
msgid "// Wrap the raw TCP stream into a websocket.\n"
msgstr "// 칉mpacheta탵i fluxul TCP brut 칥ntr-un websocket.\n"

#: src/concurrency/async-exercises/chat-app.md
#: src/concurrency/async-exercises/solutions.md
msgid "_src/bin/client.rs_:"
msgstr "_src/bin/client.rs_:"

#: src/concurrency/async-exercises/chat-app.md
#: src/concurrency/async-exercises/solutions.md
msgid "\"ws://127.0.0.1:2000\""
msgstr "\"ws://127.0.0.1:2000\""

#: src/concurrency/async-exercises/chat-app.md
msgid "Running the binaries"
msgstr "Rularea fi탳ierelor binare"

#: src/concurrency/async-exercises/chat-app.md
msgid "Run the server with:"
msgstr "Rula탵i serverul cu:"

#: src/concurrency/async-exercises/chat-app.md
msgid "and the client with:"
msgstr "탳i clientul cu:"

#: src/concurrency/async-exercises/chat-app.md
msgid "Implement the `handle_connection` function in `src/bin/server.rs`."
msgstr "Implementa탵i func탵ia `handle_connection` 칥n `src/bin/server.rs`."

#: src/concurrency/async-exercises/chat-app.md
msgid ""
"Hint: Use `tokio::select!` for concurrently performing two tasks in a "
"continuous loop. One task receives messages from the client and broadcasts "
"them. The other sends messages received by the server to the client."
msgstr ""
"Indica탵ie: Folosi탵i `tokio::select!` pentru a efectua concomitent dou캒 "
"sarcini 칥ntr-o bucl캒 continu캒. O sarcin캒 prime탳te mesaje de la client 탳i le "
"difuzeaz캒. Cealalt캒 trimite mesajele primite de server c캒tre client."

#: src/concurrency/async-exercises/chat-app.md
msgid "Complete the main function in `src/bin/client.rs`."
msgstr "Completa탵i func탵ia principal캒 din `src/bin/client.rs`."

#: src/concurrency/async-exercises/chat-app.md
msgid ""
"Hint: As before, use `tokio::select!` in a continuous loop for concurrently "
"performing two tasks: (1) reading user messages from standard input and "
"sending them to the server, and (2) receiving messages from the server, and "
"displaying them for the user."
msgstr ""
"Sugestie: Ca 탳i 칥nainte, utiliza탵i `tokio::select!` 칥ntr-o bucl캒 continu캒 "
"pentru a efectua concomitent dou캒 sarcini: (1) citirea mesajelor "
"utilizatorului de la intrarea standard 탳i trimiterea lor la server 탳i (2) "
"primirea mesajelor de la server 탳i afi탳area lor pentru utilizator."

#: src/concurrency/async-exercises/chat-app.md
msgid ""
"Optional: Once you are done, change the code to broadcast messages to all "
"clients, but the sender of the message."
msgstr ""
"Op탵ional: Dup캒 ce a탵i terminat, modifica탵i codul pentru a difuza mesajele "
"c캒tre to탵i clien탵ii, cu excep탵ia expeditorului mesajului."

#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid ""
"// If we didn't get the left fork, drop the right fork if we\n"
"                // have it and let other tasks make progress.\n"
msgstr ""
"// Dac캒 nu am primit furculi탵a din st칙nga, renun탵캒m la furculi탵a din "
"dreapta, dac캒 avem\n"
"                // o avem 탳i l캒s캒m celelalte sarcini s캒 progreseze.\n"

#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid ""
"// If we didn't get the right fork, drop the left fork and let\n"
"                // other tasks make progress.\n"
msgstr ""
"// Dac캒 nu am primit furculi탵a din dreapta, renun탵캒m la furculi탵a din st칙nga "
"탳i l캒s캒m\n"
"                // alte sarcini s캒 progreseze.\n"

#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "// The locks are dropped here\n"
msgstr "// 칉ncuietorile sunt aruncate aici\n"

#: src/concurrency/async-exercises/solutions.md
msgid "// tx is dropped here, so we don't need to explicitly drop it later\n"
msgstr ""
"// tx este abandonat aici, a탳a c캒 nu este nevoie s캒 칥l abandon캒m explicit "
"mai t칙rziu\n"

#: src/concurrency/async-exercises/solutions.md
msgid "\"Here is a thought: {thought}\""
msgstr "\"Iat캒 un idee: {thought}\""

#: src/concurrency/async-exercises/solutions.md
msgid "\"Welcome to chat! Type a message\""
msgstr "\"Bine a탵i venit pe chat! Scrie탵i un mesaj\""

#: src/concurrency/async-exercises/solutions.md
msgid ""
"// A continuous loop for concurrently performing two tasks: (1) receiving\n"
"    // messages from `ws_stream` and broadcasting them, and (2) receiving\n"
"    // messages on `bcast_rx` and sending them to the client.\n"
msgstr ""
"// O bucl캒 continu캒 care face dou캒 activit캒탵i 칥n acela탳i timp: (1) prime탳te\n"
"    // mesaje de la 'ws_stream' 탳i le transmite, 탳i (2) prime탳te\n"
"    // mesajele la apelul 'bcast_rx' 탳i le trimite clientului.\n"

#: src/concurrency/async-exercises/solutions.md
msgid "\"From client {addr:?} {text:?}\""
msgstr "\"De la client {addr:?} {text:?}\""

#: src/concurrency/async-exercises/solutions.md
msgid "// Continuous loop for concurrently sending and receiving messages.\n"
msgstr "// Bucla continu캒 pentru trimiterea 탳i primirea simultan캒 de mesaje.\n"

#: src/concurrency/async-exercises/solutions.md
msgid "\"From server: {}\""
msgstr "\"De la server: {}\""

#: src/thanks.md
msgid ""
"_Thank you for taking Comprehensive Rust 游!_ We hope you enjoyed it and "
"that it was useful."
msgstr ""
"v캒 mul탵umim c캒 a탵i parcurs Comprehensive Rust 游!_ Sper캒m c캒 v-a pl캒cut 탳i "
"c캒 a fost util."

#: src/thanks.md
msgid ""
"We've had a lot of fun putting the course together. The course is not "
"perfect, so if you spotted any mistakes or have ideas for improvements, "
"please get in [contact with us on GitHub](https://github.com/google/"
"comprehensive-rust/discussions). We would love to hear from you."
msgstr ""
"Cursul nu este perfect, a탳a c캒, dac캒 a탵i observat gre탳eli sau ave탵i idei de "
"칥mbun캒t캒탵ire, v캒 rug캒m s캒 ne [contacta탵i pe GitHub](https://github.com/"
"google/comprehensive-rust/discussions)."

#: src/glossary.md
msgid ""
"The following is a glossary which aims to give a short definition of many "
"Rust terms. For translations, this also serves to connect the term back to "
"the English original."
msgstr ""
"Urm캒torul glosar 칥탳i propune s캒 ofere o scurt캒 defini탵ie a numero탳i termeni "
"Rust. 칉n cazul traducerilor, acesta serve탳te, de asemenea, pentru a face "
"leg캒tura 칥ntre termenul respectiv 탳i originalul 칥n limba englez캒."

#: src/glossary.md
msgid ""
"allocate:  \n"
"Dynamic memory allocation on [the heap](memory-management/stack-vs-heap.md)."
msgstr ""
"alocare:  \n"
"Alocarea dinamic캒 a memoriei pe [heap](memory-management/stack-vs-heap.md)."

#: src/glossary.md
msgid ""
"argument:  \n"
"Information that is passed into a function or method."
msgstr ""
"argument:\n"
"Informa탵ii care sunt transmise 칥ntr-o func탵ie sau metod캒."

#: src/glossary.md
msgid ""
"Bare-metal Rust:  \n"
"Low-level Rust development, often deployed to a system without an operating "
"system. See [Bare-metal Rust](bare-metal.md)."
msgstr ""
"Bare-metal Rust:\n"
"Dezvoltare Rust de nivel sc캒zut, adesea implementat캒 pe un sistem f캒r캒 "
"sistem de operare. A se vedea [Bare-metal Rust](bare-metal.md)."

#: src/glossary.md
msgid ""
"block:  \n"
"See [Blocks](control-flow/blocks.md) and _scope_."
msgstr ""
"bloc:\n"
"A se vedea [Blocuri](control-flow/blocks.md) 탳i _scope_."

#: src/glossary.md
msgid ""
"borrow:  \n"
"See [Borrowing](ownership/borrowing.md)."
msgstr ""
"칥mprumut (borrow):\n"
"A se vedea [칉mprumut](ownership/borrowing.md)."

#: src/glossary.md
msgid ""
"borrow checker:  \n"
"The part of the Rust compiler which checks that all borrows are valid."
msgstr ""
"verificator de 칥mprumuturi (borrow checker):\n"
"Partea din compilatorul Rust care verific캒 dac캒 toate 칥mprumuturile de date "
"sunt valide."

#: src/glossary.md
msgid ""
"brace:  \n"
"`{` and `}`. Also called _curly brace_, they delimit _blocks_."
msgstr ""
"paranteze:\n"
"`{` 탳i `}`. Numite 탳i _acolade_, ele delimiteaz캒 _blocuri_."

#: src/glossary.md
msgid ""
"build:  \n"
"The process of converting source code into executable code or a usable "
"program."
msgstr ""
"construire:  \n"
"Procesul de conversie a codului surs캒 칥n cod executabil sau 칥ntr-un program "
"utilizabil."

#: src/glossary.md
msgid ""
"call:  \n"
"To invoke or execute a function or method."
msgstr ""
"apel (call):  \n"
"Invocarea sau execu탵ia unei func탵ii sau metode."

#: src/glossary.md
msgid ""
"channel:  \n"
"Used to safely pass messages [between threads](concurrency/channels.md)."
msgstr ""
"canal (channel):  \n"
"Folosit pentru a transmite 칥n siguran탵캒 mesaje [칥ntre fire de execu탵ie] "
"(concurrency/channels.md)."

#: src/glossary.md
msgid ""
"Comprehensive Rust 游:  \n"
"The courses here are jointly called Comprehensive Rust 游."
msgstr ""
"Comprehensive Rust 游:\n"
"Cursurile de aici se numesc 칥n comun Fundamentele Rust 游."

#: src/glossary.md
msgid ""
"concurrency:  \n"
"The execution of multiple tasks or processes at the same time."
msgstr ""
"concuren탵a (concurrency):\n"
"Executarea mai multor sarcini sau procese 칥n acela탳i timp."

#: src/glossary.md
msgid ""
"Concurrency in Rust:  \n"
"See [Concurrency in Rust](concurrency.md)."
msgstr ""
"Concuren탵a 칥n Rust:\n"
"A se vedea [Concuren탵a 칥n Rust](concurrency.md)."

#: src/glossary.md
msgid ""
"constant:  \n"
"A value that does not change during the execution of a program."
msgstr ""
"constant캒:\n"
"O valoare care nu se modific캒 칥n timpul execu탵iei unui program."

#: src/glossary.md
msgid ""
"control flow:  \n"
"The order in which the individual statements or instructions are executed in "
"a program."
msgstr ""
"fluxul de control:  \n"
"Ordinea 칥n care sunt executate instruc탵iunile sau declara탵iile individuale "
"칥ntr-un program."

#: src/glossary.md
msgid ""
"crash:  \n"
"An unexpected and unhandled failure or termination of a program."
msgstr ""
"crash:\n"
"Un e탳ec nea탳teptat 탳i netratat sau o terminare a unui program."

#: src/glossary.md
msgid ""
"enumeration:  \n"
"A data type that holds one of several named constants, possibly with an "
"associated tuple or struct."
msgstr ""
"enumerare (enumeration):\n"
"Un tip de date care con탵ine una dintre mai multe constante numite, eventual "
"cu un tupluplu sau o structur캒 asociat캒."

#: src/glossary.md
msgid ""
"error:  \n"
"An unexpected condition or result that deviates from the expected behavior."
msgstr ""
"eroare (error):\n"
"O condi탵ie sau un rezultat nea탳teptat care se abate de la comportamentul "
"a탳teptat."

#: src/glossary.md
msgid ""
"error handling:  \n"
"The process of managing and responding to errors that occur during program "
"execution."
msgstr ""
"gestionarea erorilor:\n"
"Procesul de gestionare 탳i de r캒spuns la erorile care apar 칥n timpul "
"execu탵iei programului."

#: src/glossary.md
msgid ""
"exercise:  \n"
"A task or problem designed to practice and test programming skills."
msgstr ""
"exerci탵iu:\n"
"O sarcin캒 sau o problem캒 conceput캒 pentru a exersa 탳i testa abilit캒탵ile de "
"programare."

#: src/glossary.md
msgid ""
"function:  \n"
"A reusable block of code that performs a specific task."
msgstr ""
"func탵ie:\n"
"Un bloc de cod reutilizabil care 칥ndepline탳te o sarcin캒 specific캒."

#: src/glossary.md
msgid ""
"garbage collector:  \n"
"A mechanism that automatically frees up memory occupied by objects that are "
"no longer in use."
msgstr ""
"colector de gunoi (garbage collector):\n"
"Un mecanism care elibereaz캒 automat memoria ocupat캒 de obiecte care nu mai "
"sunt utilizate."

#: src/glossary.md
msgid ""
"generics:  \n"
"A feature that allows writing code with placeholders for types, enabling "
"code reuse with different data types."
msgstr ""
"generice (generics):  \n"
"O caracteristic캒 care permite scrierea de cod cu caractere de substitu탵ie "
"pentru tipuri, permi탵칙nd reutilizarea codului cu diferite tipuri de date."

#: src/glossary.md
msgid ""
"immutable:  \n"
"Unable to be changed after creation."
msgstr ""
"imuabile (immutable):\n"
"Nu poate fi modificat dup캒 creare."

#: src/glossary.md
msgid ""
"integration test:  \n"
"A type of test that verifies the interactions between different parts or "
"components of a system."
msgstr ""
"testul de integrare:\n"
"Un tip de test care verific캒 interac탵iunile dintre diferitele p캒r탵i sau "
"componente ale unui sistem."

#: src/glossary.md
msgid ""
"keyword:  \n"
"A reserved word in a programming language that has a specific meaning and "
"cannot be used as an identifier."
msgstr ""
"cuv칙nt cheie:\n"
"Un cuv칙nt rezervat 칥ntr-un limbaj de programare care are o semnifica탵ie "
"specific캒 탳i care nu poate fi folosit ca identificator."

#: src/glossary.md
msgid ""
"library:  \n"
"A collection of precompiled routines or code that can be used by programs."
msgstr ""
"bibliotec캒:  \n"
"O colec탵ie de rutine precompilate sau cod care poate fi utilizat de programe."

#: src/glossary.md
msgid ""
"macro:  \n"
"Rust macros can be recognized by a `!` in the name. Macros are used when "
"normal functions are not enough. A typical example is `format!`, which takes "
"a variable number of arguments, which isn't supported by Rust functions."
msgstr ""
"macro:  \n"
"Macro-urile Rust pot fi recunoscute prin introducerea unui `!` 칥n nume. "
"Macrogramele sunt utilizate atunci c칙nd func탵iile normale nu sunt "
"suficiente. Un exemplu tipic este `format!`, care accept캒 un num캒r variabil "
"de argumente, ceea ce nu este acceptat de func탵iile Rust."

#: src/glossary.md
msgid ""
"`main` function:  \n"
"Rust programs start executing with the `main` function."
msgstr ""
"func탵ia `main`:\n"
"Programele Rust 칥ncep s캒 fie executate cu func탵ia `main`."

#: src/glossary.md
msgid ""
"match:  \n"
"A control flow construct in Rust that allows for pattern matching on the "
"value of an expression."
msgstr ""
"potrivire (match):\n"
"O construc탵ie a fluxului de control din Rust care permite potrivirea de "
"tipare pe valoarea unei expresii."

#: src/glossary.md
msgid ""
"memory leak:  \n"
"A situation where a program fails to release memory that is no longer "
"needed, leading to a gradual increase in memory usage."
msgstr ""
"scurgere de memorie (memory leak):\n"
"O situa탵ie 칥n care un program nu reu탳e탳te s캒 elibereze memoria care nu mai "
"este necesar캒, ceea ce duce la o cre탳tere treptat캒 a utiliz캒rii memoriei."

#: src/glossary.md
msgid ""
"method:  \n"
"A function associated with an object or a type in Rust."
msgstr ""
"metoda:\n"
"O func탵ie asociat캒 cu un obiect sau un tip 칥n Rust."

#: src/glossary.md
msgid ""
"module:  \n"
"A namespace that contains definitions, such as functions, types, or traits, "
"to organize code in Rust."
msgstr ""
"modul:  \n"
"Un spa탵iu de nume care con탵ine defini탵ii, cum ar fi func탵ii, tipuri sau "
"tr캒s캒turi, pentru a organiza codul 칥n Rust."

#: src/glossary.md
msgid ""
"move:  \n"
"The transfer of ownership of a value from one variable to another in Rust."
msgstr ""
"mutare (move):\n"
"Transferul propriet캒탵ii unei valori de la o variabil캒 la alta 칥n Rust."

#: src/glossary.md
msgid ""
"mutable:  \n"
"A property in Rust that allows variables to be modified after they have been "
"declared."
msgstr ""
"mutabil:\n"
"O proprietate din Rust care permite variabilelor s캒 fie modificate dup캒 ce "
"au fost declarate."

#: src/glossary.md
msgid ""
"ownership:  \n"
"The concept in Rust that defines which part of the code is responsible for "
"managing the memory associated with a value."
msgstr ""
"posesia (ownership):\n"
"Conceptul din Rust care define탳te ce parte a codului este responsabil캒 "
"pentru gestionarea memoriei asociate cu o valoare."

#: src/glossary.md
msgid ""
"panic:  \n"
"An unrecoverable error condition in Rust that results in the termination of "
"the program."
msgstr ""
"panic캒:\n"
"O stare de eroare irecuperabil캒 칥n Rust care duce la terminarea programului."

#: src/glossary.md
msgid ""
"parameter:  \n"
"A value that is passed into a function or method when it is called."
msgstr ""
"parametru:\n"
"O valoare care este transmis캒 칥ntr-o func탵ie sau metod캒 atunci c칙nd este "
"apelat캒."

#: src/glossary.md
msgid ""
"pattern:  \n"
"A combination of values, literals, or structures that can be matched against "
"an expression in Rust."
msgstr ""
"탳ablon (pattern):\n"
"O combina탵ie de valori, literali sau structuri care pot fi comparate cu o "
"expresie 칥n Rust."

#: src/glossary.md
msgid ""
"payload:  \n"
"The data or information carried by a message, event, or data structure."
msgstr ""
"sarcina util캒:  \n"
"Datele sau informa탵iile transportate de un mesaj, eveniment sau structur캒 de "
"date."

#: src/glossary.md
msgid ""
"program:  \n"
"A set of instructions that a computer can execute to perform a specific task "
"or solve a particular problem."
msgstr ""
"program:  \n"
"Un set de instruc탵iuni pe care un computer le poate executa pentru a "
"칥ndeplini o anumit캒 sarcin캒 sau pentru a rezolva o anumit캒 problem캒."

#: src/glossary.md
msgid ""
"programming language:  \n"
"A formal system used to communicate instructions to a computer, such as Rust."
msgstr ""
"limbaj de programare:  \n"
"Un sistem formal utilizat pentru a comunica instruc탵iuni unui calculator, "
"cum ar fi Rust."

#: src/glossary.md
msgid ""
"receiver:  \n"
"The first parameter in a Rust method that represents the instance on which "
"the method is called."
msgstr ""
"receptor:\n"
"Primul parametru dintr-o metod캒 Rust care reprezint캒 instan탵a asupra c캒reia "
"este apelat캒 metoda."

#: src/glossary.md
msgid ""
"reference counting:  \n"
"A memory management technique in which the number of references to an object "
"is tracked, and the object is deallocated when the count reaches zero."
msgstr ""
"num캒rarea referin탵elor:\n"
"O tehnic캒 de gestionare a memoriei 칥n care se urm캒re탳te num캒rul de referin탵e "
"la un obiect, iar obiectul este dezalocat atunci c칙nd num캒rul ajunge la zero."

#: src/glossary.md
msgid ""
"return:  \n"
"A keyword in Rust used to indicate the value to be returned from a function."
msgstr ""
"return:\n"
"Un cuv칙nt cheie din Rust utilizat pentru a indica valoarea care trebuie "
"returnat캒 de o func탵ie."

#: src/glossary.md
msgid ""
"Rust:  \n"
"A systems programming language that focuses on safety, performance, and "
"concurrency."
msgstr ""
"Rust:\n"
"Un limbaj de programare de sisteme care se concentreaz캒 pe siguran탵캒, "
"performan탵캒 탳i concuren탵캒."

#: src/glossary.md
#, fuzzy
msgid ""
"Rust Fundamentals:  \n"
"Days 1 to 4 of this course."
msgstr ""
"No탵iuni fundamentale ale Rust:\n"
"Zilele 1 - 3 ale acestui curs."

#: src/glossary.md
msgid ""
"Rust in Android:  \n"
"See [Rust in Android](android.md)."
msgstr ""
"Rust 칥n Android:\n"
"A se vedea [Rust in Android](android.md)."

#: src/glossary.md
msgid ""
"Rust in Chromium:  \n"
"See [Rust in Chromium](chromium.md)."
msgstr ""
"Rust 칥n Android:\n"
"A se vedea [Rust in Android](android.md)."

#: src/glossary.md
msgid ""
"safe:  \n"
"Refers to code that adheres to Rust's ownership and borrowing rules, "
"preventing memory-related errors."
msgstr ""
"sigur (safe):  \n"
"Se refer캒 la codul care respect캒 regulile de proprietate 탳i 칥mprumut ale "
"Rust, prevenind erorile legate de memorie."

#: src/glossary.md
msgid ""
"scope:  \n"
"The region of a program where a variable is valid and can be used."
msgstr ""
"domeniul de aplicare:  \n"
"Regiunea unui program 칥n care o variabil캒 este valabil캒 탳i poate fi "
"utilizat캒."

#: src/glossary.md
msgid ""
"standard library:  \n"
"A collection of modules providing essential functionality in Rust."
msgstr ""
"biblioteca standard:  \n"
"O colec탵ie de module care ofer캒 func탵ionalit캒탵i esen탵iale 칥n Rust."

#: src/glossary.md
#, fuzzy
msgid ""
"static:  \n"
"A keyword in Rust used to define static variables or items with a `'static` "
"lifetime."
msgstr ""
"static:\n"
"Un cuv칙nt cheie din Rust folosit pentru a defini variabile statice sau "
"elemente cu o durat캒 de via탵캒 `'static`'."

#: src/glossary.md
#, fuzzy
msgid ""
"string:  \n"
"A data type storing textual data. See [`String` vs `str`](basic-syntax/"
"string-slices.html) for more."
msgstr ""
"탳ir:\n"
"Un tip de date care stocheaz캒 date textuale. Consulta탵i [`String` vs `str`]"
"(basic-syntax/string-slices.html) pentru mai multe informa탵ii."

#: src/glossary.md
#, fuzzy
msgid ""
"struct:  \n"
"A composite data type in Rust that groups together variables of different "
"types under a single name."
msgstr ""
"struct:  \n"
"Un tip de date compozit 칥n Rust care grupeaz캒 variabile de diferite tipuri "
"sub un singur nume."

#: src/glossary.md
msgid ""
"test:  \n"
"A Rust module containing functions that test the correctness of other "
"functions."
msgstr ""
"test:\n"
"Un modul Rust care con탵ine func탵ii care testeaz캒 corectitudinea altor "
"func탵ii."

#: src/glossary.md
msgid ""
"thread:  \n"
"A separate sequence of execution in a program, allowing concurrent execution."
msgstr ""
"fir de execu탵ie:\n"
"O secven탵캒 separat캒 de execu탵ie 칥ntr-un program, permi탵칙nd executarea "
"simultan캒."

#: src/glossary.md
msgid ""
"thread safety:  \n"
"The property of a program that ensures correct behavior in a multithreaded "
"environment."
msgstr ""
"siguran탵a firelor de execu탵ie:\n"
"Proprietatea unui program care asigur캒 un comportament corect 칥ntr-un mediu "
"cu mai multe fire de execu탵ie."

#: src/glossary.md
#, fuzzy
msgid ""
"trait:  \n"
"A collection of methods defined for an unknown type, providing a way to "
"achieve polymorphism in Rust."
msgstr ""
"tr캒s캒tur캒:\n"
"O colec탵ie de metode definite pentru un tip necunoscut, oferind o modalitate "
"de a realiza polimorfismul 칥n Rust."

#: src/glossary.md
msgid ""
"trait bound:  \n"
"An abstraction where you can require types to implement some traits of your "
"interest."
msgstr ""
"tr캒s캒turi obligatorii:\n"
"O abstractizare prin care pute탵i cere tipurilor s캒 implementeze anumite "
"tr캒s캒turi de interes pentru dumneavoastr캒."

#: src/glossary.md
msgid ""
"tuple:  \n"
"A composite data type that contains variables of different types. Tuple "
"fields have no names, and are accessed by their ordinal numbers."
msgstr ""
"tuplu:  \n"
"Un tip de date compozit care con탵ine variabile de diferite tipuri. C칙mpurile "
"tuplu nu au nume 탳i sunt accesate prin numerele lor ordinale."

#: src/glossary.md
msgid ""
"type:  \n"
"A classification that specifies which operations can be performed on values "
"of a particular kind in Rust."
msgstr ""
"tip:  \n"
"O clasificare care specific캒 ce opera탵ii pot fi efectuate asupra valorilor "
"datelor 칥n Rust."

#: src/glossary.md
msgid ""
"type inference:  \n"
"The ability of the Rust compiler to deduce the type of a variable or "
"expression."
msgstr ""
"inferen탵a de tip:  \n"
"Capacitatea compilatorului Rust de a deduce tipul unei variabile sau "
"expresii."

#: src/glossary.md
msgid ""
"undefined behavior:  \n"
"Actions or conditions in Rust that have no specified result, often leading "
"to unpredictable program behavior."
msgstr ""
"comportament nedefinit:\n"
"Ac탵iuni sau condi탵ii din Rust care nu au un rezultat specificat, ceea ce "
"duce adesea la un comportament imprevizibil al programului."

#: src/glossary.md
msgid ""
"union:  \n"
"A data type that can hold values of different types but only one at a time."
msgstr ""
"uniune (union):\n"
"Un tip de date care poate con탵ine valori de tipuri diferite, dar numai una "
"la un moment dat."

#: src/glossary.md
msgid ""
"unit test:  \n"
"Rust comes with built-in support for running small unit tests and larger "
"integration tests. See [Unit Tests](testing/unit-tests.html)."
msgstr ""
"test unitar:\n"
"Rust vine cu un suport 칥ncorporat pentru a rula teste unitare mici 탳i teste "
"de integrare mai mari. Consulta탵i [Teste unitare](testing/unit-tests.html)."

#: src/glossary.md
msgid ""
"unit type:  \n"
"Type that holds no data, written as a tuple with no members."
msgstr ""
"tipul unitate:  \n"
"Tip care nu con탵ine date, scris ca un tuplu f캒r캒 membri."

#: src/glossary.md
msgid ""
"unsafe:  \n"
"The subset of Rust which allows you to trigger _undefined behavior_. See "
"[Unsafe Rust](unsafe.html)."
msgstr ""
"nesigur:  \n"
"Un subansamblul Rust care v캒 permite s캒 declan탳a탵i _comportamentul "
"nedefinit_. A se vedea [Rust nesigur](unsafe.html)."

#: src/glossary.md
msgid ""
"variable:  \n"
"A memory location storing data. Variables are valid in a _scope_."
msgstr ""
"variabil캒:\n"
"O loca탵ie de memorie care stocheaz캒 date. Variabilele sunt valabile 칥ntr-un "
"_scop_."

#: src/other-resources.md
msgid "Other Rust Resources"
msgstr "Alte resurse privind Rust"

#: src/other-resources.md
msgid ""
"The Rust community has created a wealth of high-quality and free resources "
"online."
msgstr ""
"Comunitatea Rust a creat o multitudine de resurse online gratuite 탳i de "
"칥nalt캒 calitate."

#: src/other-resources.md
msgid "Official Documentation"
msgstr "Documenta탵ie oficial캒"

#: src/other-resources.md
msgid "The Rust project hosts many resources. These cover Rust in general:"
msgstr ""
"Proiectul Rust g캒zduie탳te multe resurse. Acestea se refer캒 la Rust 칥n "
"general:"

#: src/other-resources.md
msgid ""
"[The Rust Programming Language](https://doc.rust-lang.org/book/): the "
"canonical free book about Rust. Covers the language in detail and includes a "
"few projects for people to build."
msgstr ""
"[The Rust Programming Language](https://doc.rust-lang.org/book/): cartea "
"canonic캒 gratuit캒 despre Rust. Acoper캒 limbajul 칥n detaliu 탳i include c칙teva "
"proiecte care pot fi construite."

#: src/other-resources.md
msgid ""
"[Rust By Example](https://doc.rust-lang.org/rust-by-example/): covers the "
"Rust syntax via a series of examples which showcase different constructs. "
"Sometimes includes small exercises where you are asked to expand on the code "
"in the examples."
msgstr ""
"[Rust By Example](https://doc.rust-lang.org/rust-by-example/): acoper캒 "
"sintaxa Rust prin intermediul unei serii de exemple care prezint캒 diferite "
"construc탵ii. Uneori include mici exerci탵ii 칥n care vi se cere s캒 dezvolta탵i "
"codul din exemple."

#: src/other-resources.md
msgid ""
"[Rust Standard Library](https://doc.rust-lang.org/std/): full documentation "
"of the standard library for Rust."
msgstr ""
"[Rust Standard Library](https://doc.rust-lang.org/std/): documenta탵ia "
"complet캒 a bibliotecii standard pentru Rust."

#: src/other-resources.md
msgid ""
"[The Rust Reference](https://doc.rust-lang.org/reference/): an incomplete "
"book which describes the Rust grammar and memory model."
msgstr ""
"[The Rust Reference](https://doc.rust-lang.org/reference/): o carte "
"incomplet캒 care descrie gramatica 탳i modelul de memorie Rust."

#: src/other-resources.md
msgid "More specialized guides hosted on the official Rust site:"
msgstr "Ghiduri mai specializate g캒zduite pe site-ul oficial Rust:"

#: src/other-resources.md
msgid ""
"[The Rustonomicon](https://doc.rust-lang.org/nomicon/): covers unsafe Rust, "
"including working with raw pointers and interfacing with other languages "
"(FFI)."
msgstr ""
"[The Rustonomicon](https://doc.rust-lang.org/nomicon/): acoper캒 Rust "
"nesigur, inclusiv lucrul cu pointeri bru탵i 탳i interfa탵a cu alte limbaje "
"(FFI)."

#: src/other-resources.md
msgid ""
"[Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/): "
"covers the new asynchronous programming model which was introduced after the "
"Rust Book was written."
msgstr ""
"[Asynchronous Programming 칥n Rust](https://rust-lang.github.io/async-book/): "
"acoper캒 noul model de programare asincron캒 care a fost introdus dup캒 ce a "
"fost scris캒 cartea Rust."

#: src/other-resources.md
msgid ""
"[The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): "
"an introduction to using Rust on embedded devices without an operating "
"system."
msgstr ""
"[The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): o "
"introducere 칥n utilizarea Rust pe dispozitive 칥ncorporate care nu au un "
"sistem de operare."

#: src/other-resources.md
msgid "Unofficial Learning Material"
msgstr "Material didactic neoficial"

#: src/other-resources.md
msgid "A small selection of other guides and tutorial for Rust:"
msgstr "O mic캒 selec탵ie de alte ghiduri 탳i tutoriale pentru Rust:"

#: src/other-resources.md
msgid ""
"[Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): covers Rust "
"from the perspective of low-level C programmers."
msgstr ""
"[Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): acoper캒 "
"Rust din perspectiva programatorilor C de nivel inferior."

#: src/other-resources.md
msgid ""
"[Rust for Embedded C Programmers](https://docs.opentitan.org/doc/ug/"
"rust_for_c/): covers Rust from the perspective of developers who write "
"firmware in C."
msgstr ""
"[Rust for Embedded C Programmers](https://docs.opentitan.org/doc/ug/"
"rust_for_c/): acoper캒 Rust din perspectiva dezvoltatorilor care scriu "
"firmware 칥n C."

#: src/other-resources.md
msgid ""
"[Rust for professionals](https://overexact.com/rust-for-professionals/): "
"covers the syntax of Rust using side-by-side comparisons with other "
"languages such as C, C++, Java, JavaScript, and Python."
msgstr ""
"[Rust pentru profesioni탳ti](https://overexact.com/rust-for-professionals/): "
"acoper캒 sintaxa Rust folosind compara탵ii cu alte limbaje precum C, C++, "
"Java, JavaScript 탳i Python."

#: src/other-resources.md
msgid ""
"[Rust on Exercism](https://exercism.org/tracks/rust): 100+ exercises to help "
"you learn Rust."
msgstr ""
"[Rust on Exercism](https://exercism.org/tracks/rust): 100+ exerci탵ii pentru "
"a v캒 ajuta s캒 칥nv캒탵a탵i Rust."

#: src/other-resources.md
msgid ""
"[Ferrous Teaching Material](https://ferrous-systems.github.io/teaching-"
"material/index.html): a series of small presentations covering both basic "
"and advanced part of the Rust language. Other topics such as WebAssembly, "
"and async/await are also covered."
msgstr ""
"[Ferrous Teaching Material](https://ferrous-systems.github.io/teaching-"
"material/index.html): o serie de mici prezent캒ri care acoper캒 at칙t partea de "
"baz캒, c칙t 탳i cea avansat캒 a limbajului Rust. Sunt abordate 탳i alte subiecte, "
"cum ar fi WebAssembly 탳i async/await."

#: src/other-resources.md
#, fuzzy
msgid ""
"[Advanced testing for Rust applications](https://github.com/mainmatter/rust-"
"advanced-testing-workshop): a self-paced workshop that goes beyond Rust's "
"built-in testing framework. It covers `googletest`, snapshot testing, "
"mocking as well as how to write your own custom test harness."
msgstr ""
"[Testarea avansat캒 a aplica탵iilor Rust](https://github.com/mainmatter/rust-"
"advanced-testing-workshop): un atelier de lucru care merge mai departe de "
"cadrul de testare 칥ncorporat 칥n Rust. Acesta acoper캒 `googletest`, testarea "
"instantanee, mocking, precum 탳i cum s캒 v캒 scrie탵i propriul harna탳ament de "
"testare personalizat."

#: src/other-resources.md
msgid ""
"[Beginner's Series to Rust](https://docs.microsoft.com/en-us/shows/beginners-"
"series-to-rust/) and [Take your first steps with Rust](https://docs."
"microsoft.com/en-us/learn/paths/rust-first-steps/): two Rust guides aimed at "
"new developers. The first is a set of 35 videos and the second is a set of "
"11 modules which covers Rust syntax and basic constructs."
msgstr ""
"[Beginner's Series to Rust] (https://docs.microsoft.com/en-us/shows/"
"beginners-series-to-rust/) 탳i [Take your first steps with Rust] (https://"
"docs.microsoft.com/en-us/learn/paths/rust-first-steps/): dou캒 ghiduri Rust "
"destinate noilor dezvoltatori. Primul este un set de 35 de videoclipuri, iar "
"al doilea este un set de 11 module care acoper캒 sintaxa Rust 탳i "
"construc탵iile de baz캒."

#: src/other-resources.md
msgid ""
"[Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial."
"github.io/too-many-lists/): in-depth exploration of Rust's memory management "
"rules, through implementing a few different types of list structures."
msgstr ""
"[Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial."
"github.io/too-many-lists/): explorarea 칥n profunzime a regulilor de "
"gestionare a memoriei din Rust, prin implementarea c칙torva tipuri diferite "
"de structuri de liste."

#: src/other-resources.md
msgid ""
"Please see the [Little Book of Rust Books](https://lborb.github.io/book/) "
"for even more Rust books."
msgstr ""
"V캒 rug캒m s캒 consulta탵i [Little Book of Rust Books](https://lborb.github.io/"
"book/) pentru 탳i mai multe c캒r탵i Rust."

#: src/credits.md
msgid ""
"The material here builds on top of the many great sources of Rust "
"documentation. See the page on [other resources](other-resources.md) for a "
"full list of useful resources."
msgstr ""
"Materialul de aici se bazeaz캒 pe numeroasele surse excelente din "
"documenta탵ia Rust. Consulta탵i pagina privind [alte resurse](other-resources."
"md) pentru o list캒 complet캒 de resurse utile."

#: src/credits.md
msgid ""
"The material of Comprehensive Rust is licensed under the terms of the Apache "
"2.0 license, please see [`LICENSE`](https://github.com/google/comprehensive-"
"rust/blob/main/LICENSE) for details."
msgstr ""
"Materialul din `Comprehensive Rust` este licen탵iat 칥n conformitate cu "
"termenii licen탵ei Apache 2.0, v캒 rug캒m s캒 consulta탵i [`LICENSE`](https://"
"github.com/google/comprehensive-rust/blob/main/LICENSE) pentru detalii."

#: src/credits.md
msgid "Rust by Example"
msgstr "Rust 칥n exemple"

#: src/credits.md
msgid ""
"Some examples and exercises have been copied and adapted from [Rust by "
"Example](https://doc.rust-lang.org/rust-by-example/). Please see the "
"`third_party/rust-by-example/` directory for details, including the license "
"terms."
msgstr ""
"Unele exemple 탳i exerci탵ii au fost copiate 탳i adaptate din [Rust by Example]"
"(https://doc.rust-lang.org/rust-by-example/). V캒 rug캒m s캒 consulta탵i "
"directorul `third_party/rust-by-example/` pentru detalii, inclusiv termenii "
"licen탵ei."

#: src/credits.md
#, fuzzy
msgid "Rust on Exercism"
msgstr ""
"[Rust on Exercism](https://exercism.org/tracks/rust): 100+ exerci탵ii pentru "
"a v캒 ajuta s캒 칥nv캒탵a탵i Rust."

#: src/credits.md
msgid ""
"Some exercises have been copied and adapted from [Rust on Exercism](https://"
"exercism.org/tracks/rust). Please see the `third_party/rust-on-exercism/` "
"directory for details, including the license terms."
msgstr ""
"Unele exerci탵ii au fost copiate 탳i adaptate din [Rust on Exercism](https://"
"exercism.org/tracks/rust). V캒 rug캒m s캒 consulta탵i directorul `third_party/"
"rust-on-exercism/` pentru detalii, inclusiv termenii licen탵ei."

#: src/credits.md
msgid "CXX"
msgstr "CXX"

#: src/credits.md
msgid ""
"The [Interoperability with C++](android/interoperability/cpp.md) section "
"uses an image from [CXX](https://cxx.rs/). Please see the `third_party/cxx/` "
"directory for details, including the license terms."
msgstr ""
"Sec탵iunea [Interoperabilitate cu C++](android/interoperabilitate/cpp.md) "
"utilizeaz캒 o imagine din [CXX](https://cxx.rs/). V캒 rug캒m s캒 consulta탵i "
"directorul `third_party/cxx/` pentru detalii, inclusiv termenii licen탵ei."
