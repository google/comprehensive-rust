msgid ""
msgstr ""
"Project-Id-Version: Comprehensive Rust 游\n"
"POT-Creation-Date: 2023-11-07T13:34:38+02:00\n"
"PO-Revision-Date: 2023-11-07 15:51+0200\n"
"Last-Translator: Razvan Stefanescu <rstefanescu@google.com>\n"
"Language-Team: Romanian <translation-team-ro@lists.sourceforge.net>\n"
"Language: ro\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=n==1 ? 0 : (n==0 || (n%100 > 0 && n%100 < "
"20)) ? 1 : 2;\n"
"X-Generator: Poedit 3.4.1\n"

#: src/SUMMARY.md:4 src/index.md:1
msgid "Welcome to Comprehensive Rust 游"
msgstr "Bine a탵i venit la Comprehensive Rust 游 (ghidul complet pentu Rust)"

#: src/SUMMARY.md:5 src/running-the-course.md:1
msgid "Running the Course"
msgstr "Rularea cursului"

#: src/SUMMARY.md:6 src/running-the-course/course-structure.md:1
msgid "Course Structure"
msgstr "Structura cursului"

#: src/SUMMARY.md:7 src/running-the-course/keyboard-shortcuts.md:1
msgid "Keyboard Shortcuts"
msgstr "Scurt캒turi de tastatur캒"

#: src/SUMMARY.md:8 src/running-the-course/translations.md:1
msgid "Translations"
msgstr "Traduceri"

#: src/SUMMARY.md:9 src/cargo.md:1
msgid "Using Cargo"
msgstr "Folosirea Cargo"

#: src/SUMMARY.md:10
msgid "Rust Ecosystem"
msgstr "Ecosistemul Rust"

#: src/SUMMARY.md:11
msgid "Code Samples"
msgstr "Mostre de cod"

#: src/SUMMARY.md:12
msgid "Running Cargo Locally"
msgstr "Rularea Cargo local"

#: src/SUMMARY.md:15
msgid "Day 1: Morning"
msgstr "Ziua 1: Diminea탵a"

#: src/SUMMARY.md:19 src/SUMMARY.md:80 src/SUMMARY.md:135 src/SUMMARY.md:193
#: src/SUMMARY.md:231 src/SUMMARY.md:281
msgid "Welcome"
msgstr "Bine a탵i venit"

#: src/SUMMARY.md:20 src/welcome-day-1/what-is-rust.md:1
msgid "What is Rust?"
msgstr "Ce este Rust?"

#: src/SUMMARY.md:21 src/hello-world.md:1
msgid "Hello World!"
msgstr "Bun캒 lume!"

#: src/SUMMARY.md:22 src/hello-world/small-example.md:1
msgid "Small Example"
msgstr "Un mic exemplu"

#: src/SUMMARY.md:23 src/why-rust.md:1
msgid "Why Rust?"
msgstr "De ce Rust?"

#: src/SUMMARY.md:24 src/why-rust/an-example-in-c.md:1 src/credits.md:32
msgid "An Example in C"
msgstr "Un exemplu 칥n C"

#: src/SUMMARY.md:25 src/why-rust/compile-time.md:1
msgid "Compile Time Guarantees"
msgstr "Garan탵ii 칥n timpul compil캒rii"

#: src/SUMMARY.md:26 src/why-rust/runtime.md:1
msgid "Runtime Guarantees"
msgstr "Garan탵ii 칥n timpul rul캒rii"

#: src/SUMMARY.md:27 src/why-rust/modern.md:1
msgid "Modern Features"
msgstr "Caracteristici moderne"

#: src/SUMMARY.md:28 src/basic-syntax.md:1
msgid "Basic Syntax"
msgstr "Sintaxa de baz캒"

#: src/SUMMARY.md:29 src/basic-syntax/scalar-types.md:1
msgid "Scalar Types"
msgstr "Tipuri scalare"

#: src/SUMMARY.md:30 src/basic-syntax/compound-types.md:1
msgid "Compound Types"
msgstr "Tipuri compuse"

#: src/SUMMARY.md:31 src/basic-syntax/references.md:1
msgid "References"
msgstr "Referin콖e"

#: src/SUMMARY.md:32 src/basic-syntax/references-dangling.md:1
msgid "Dangling References"
msgstr "Referin탵e invalide"

#: src/SUMMARY.md:33 src/basic-syntax/slices.md:1
msgid "Slices"
msgstr "Felii"

#: src/SUMMARY.md:34
msgid "String vs str"
msgstr "String versus str"

#: src/SUMMARY.md:35 src/basic-syntax/functions.md:1
msgid "Functions"
msgstr "Func탵ii"

#: src/SUMMARY.md:36 src/basic-syntax/rustdoc.md:1
msgid "Rustdoc"
msgstr "Rustdoc"

#: src/SUMMARY.md:37 src/SUMMARY.md:103 src/basic-syntax/methods.md:1
#: src/methods.md:1
msgid "Methods"
msgstr "Metode"

#: src/SUMMARY.md:38
msgid "Overloading"
msgstr "Supra칥nc캒rcare"

#: src/SUMMARY.md:39 src/SUMMARY.md:72 src/SUMMARY.md:106 src/SUMMARY.md:126
#: src/SUMMARY.md:155 src/SUMMARY.md:185 src/SUMMARY.md:224 src/SUMMARY.md:245
#: src/SUMMARY.md:273 src/SUMMARY.md:295 src/SUMMARY.md:316
#: src/exercises/android/morning.md:1 src/exercises/bare-metal/morning.md:1
#: src/exercises/bare-metal/afternoon.md:1
#: src/exercises/concurrency/morning.md:1
#: src/exercises/concurrency/afternoon.md:1
msgid "Exercises"
msgstr "Exerci탵ii"

#: src/SUMMARY.md:40 src/exercises/day-1/implicit-conversions.md:1
msgid "Implicit Conversions"
msgstr "Conversii implicite"

#: src/SUMMARY.md:41
msgid "Arrays and for Loops"
msgstr "Array-uri 탳i bucle for"

#: src/SUMMARY.md:43
msgid "Day 1: Afternoon"
msgstr "Ziua 1: Dup캒-amiaza"

#: src/SUMMARY.md:45 src/SUMMARY.md:308 src/control-flow.md:1
msgid "Control Flow"
msgstr "Fluxul de control"

#: src/SUMMARY.md:46 src/control-flow/blocks.md:1
msgid "Blocks"
msgstr "Blocuri"

#: src/SUMMARY.md:47
msgid "if expressions"
msgstr "expresii if"

#: src/SUMMARY.md:48
msgid "for expressions"
msgstr "expresii for"

#: src/SUMMARY.md:49
msgid "while expressions"
msgstr "expresii while"

#: src/SUMMARY.md:50
msgid "break & continue"
msgstr "break 탳i continue"

#: src/SUMMARY.md:51
msgid "loop expressions"
msgstr "expresii cu bucle"

#: src/SUMMARY.md:53 src/basic-syntax/variables.md:1
msgid "Variables"
msgstr "Variabile"

#: src/SUMMARY.md:54 src/basic-syntax/type-inference.md:1
msgid "Type Inference"
msgstr "Inferen탵a de tip"

#: src/SUMMARY.md:55
msgid "static & const"
msgstr "static & const"

#: src/SUMMARY.md:56 src/basic-syntax/scopes-shadowing.md:1
msgid "Scopes and Shadowing"
msgstr "Scopuri 탳i masc캒ri"

#: src/SUMMARY.md:57 src/enums.md:1
msgid "Enums"
msgstr "Enumer캒ri (enums)"

#: src/SUMMARY.md:58 src/enums/variant-payloads.md:1
msgid "Variant Payloads"
msgstr "Con탵inut variabil"

#: src/SUMMARY.md:59 src/enums/sizes.md:1
msgid "Enum Sizes"
msgstr "Dimensiunea enumer캒rilor"

#: src/SUMMARY.md:61 src/control-flow/novel.md:1
msgid "Novel Control Flow"
msgstr "Flux de control nou"

#: src/SUMMARY.md:62
msgid "if let expressions"
msgstr "Expresii if let"

#: src/SUMMARY.md:63
msgid "while let expressions"
msgstr "Expresii while let"

#: src/SUMMARY.md:64
msgid "match expressions"
msgstr "expresii de potrivire"

#: src/SUMMARY.md:66 src/SUMMARY.md:74 src/pattern-matching.md:1
msgid "Pattern Matching"
msgstr "Potrivire de 탳abloane"

#: src/SUMMARY.md:67 src/pattern-matching/destructuring-enums.md:1
msgid "Destructuring Enums"
msgstr "Destructurarea enumer캒rilor"

#: src/SUMMARY.md:68 src/pattern-matching/destructuring-structs.md:1
msgid "Destructuring Structs"
msgstr "Destructurarea structurilor"

#: src/SUMMARY.md:69 src/pattern-matching/destructuring-arrays.md:1
msgid "Destructuring Arrays"
msgstr "Destructurarea array-urilor"

#: src/SUMMARY.md:70 src/pattern-matching/match-guards.md:1
#, fuzzy
msgid "Match Guards"
msgstr "G캒rzi de potrivire"

#: src/SUMMARY.md:73 src/exercises/day-1/luhn.md:1
#: src/exercises/day-1/solutions-afternoon.md:3
msgid "Luhn Algorithm"
msgstr "Algoritmul Luhn"

#: src/SUMMARY.md:76
msgid "Day 2: Morning"
msgstr "Ziua 2: Diminea탵a"

#: src/SUMMARY.md:82 src/memory-management.md:1
msgid "Memory Management"
msgstr "Gestionarea memoriei"

#: src/SUMMARY.md:83
msgid "Stack vs Heap"
msgstr "Stiv캒 vs Heap"

#: src/SUMMARY.md:84
msgid "Stack Memory"
msgstr "Memoria pentru stiv캒"

#: src/SUMMARY.md:85 src/memory-management/manual.md:1
msgid "Manual Memory Management"
msgstr "Gestionarea manual캒 a memoriei"

#: src/SUMMARY.md:86 src/memory-management/scope-based.md:1
msgid "Scope-Based Memory Management"
msgstr "Managementul memoriei bazat pe domeniu"

#: src/SUMMARY.md:87
msgid "Garbage Collection"
msgstr "Colectarea gunoiului"

#: src/SUMMARY.md:88
msgid "Rust Memory Management"
msgstr "Managementul memoriei 칥n Rust"

#: src/SUMMARY.md:89 src/ownership.md:1
msgid "Ownership"
msgstr "Posesia"

#: src/SUMMARY.md:90 src/ownership/move-semantics.md:1
msgid "Move Semantics"
msgstr "Semantica mut캒rilor"

#: src/SUMMARY.md:91 src/ownership/moved-strings-rust.md:1
msgid "Moved Strings in Rust"
msgstr "Mutarea 탳irurlori de caractere 칥n Rust"

#: src/SUMMARY.md:92
msgid "Double Frees in Modern C++"
msgstr "Eliber캒ri dublate 칥n C++ modern"

#: src/SUMMARY.md:93 src/ownership/moves-function-calls.md:1
msgid "Moves in Function Calls"
msgstr "Mut캒ri 칥n apelurile de func탵ii"

#: src/SUMMARY.md:94 src/ownership/copy-clone.md:1
msgid "Copying and Cloning"
msgstr "Copierea 탳i clonarea"

#: src/SUMMARY.md:95 src/ownership/borrowing.md:1
msgid "Borrowing"
msgstr "칉mprumut"

#: src/SUMMARY.md:96 src/ownership/shared-unique-borrows.md:1
msgid "Shared and Unique Borrows"
msgstr "칉mprumuturi comune 탳i unice"

#: src/SUMMARY.md:97 src/ownership/lifetimes.md:1
msgid "Lifetimes"
msgstr "Durata de via탵캒"

#: src/SUMMARY.md:98 src/ownership/lifetimes-function-calls.md:1
msgid "Lifetimes in Function Calls"
msgstr "Duratele de via탵캒 칥n apelurile de func탵ii"

#: src/SUMMARY.md:99 src/ownership/lifetimes-data-structures.md:1
msgid "Lifetimes in Data Structures"
msgstr "Duratele de via탵캒 칥n structurile de date"

#: src/SUMMARY.md:100 src/structs.md:1
msgid "Structs"
msgstr "Structuri"

#: src/SUMMARY.md:101 src/structs/tuple-structs.md:1
msgid "Tuple Structs"
msgstr "Structuri Tupluri"

#: src/SUMMARY.md:102 src/structs/field-shorthand.md:1
msgid "Field Shorthand Syntax"
msgstr "Sintaxa prescurtat캒 a c칙mpurilor"

#: src/SUMMARY.md:104 src/methods/receiver.md:1
msgid "Method Receiver"
msgstr "Metoda Receptor"

#: src/SUMMARY.md:105 src/SUMMARY.md:167 src/SUMMARY.md:294
#: src/methods/example.md:1 src/concurrency/shared_state/example.md:1
msgid "Example"
msgstr "Exemplu"

#: src/SUMMARY.md:107 src/exercises/day-2/book-library.md:1
#, fuzzy
msgid "Storing Books"
msgstr "Depozitarea c캒r탵ilor"

#: src/SUMMARY.md:108 src/exercises/day-2/health-statistics.md:1
#: src/exercises/day-2/solutions-morning.md:151
#, fuzzy
msgid "Health Statistics"
msgstr "Statistici de s캒n캒tate"

#: src/SUMMARY.md:110
msgid "Day 2: Afternoon"
msgstr "Ziua 2: Dup캒-amiaza"

#: src/SUMMARY.md:112 src/std.md:1
msgid "Standard Library"
msgstr "Biblioteca standard"

#: src/SUMMARY.md:113
msgid "Option and Result"
msgstr "Op탵iune 탳i rezultat"

#: src/SUMMARY.md:114 src/std/string.md:1
msgid "String"
msgstr "Sir"

#: src/SUMMARY.md:115
msgid "Vec"
msgstr "Vec"

#: src/SUMMARY.md:116
msgid "HashMap"
msgstr "HashMap"

#: src/SUMMARY.md:117
msgid "Box"
msgstr "Cutie (box)"

#: src/SUMMARY.md:118
msgid "Recursive Data Types"
msgstr "Tipuri de date recursive"

#: src/SUMMARY.md:119 src/std/box-niche.md:1
msgid "Niche Optimization"
msgstr "Optimizari de ni탳캒"

#: src/SUMMARY.md:120
msgid "Rc"
msgstr "Num캒rarea referin탵elor (rc)"

#: src/SUMMARY.md:121
msgid "Cell/RefCell"
msgstr "Celula/RefCell"

#: src/SUMMARY.md:122 src/modules.md:1
msgid "Modules"
msgstr "Module"

#: src/SUMMARY.md:123 src/modules/visibility.md:1
msgid "Visibility"
msgstr "Vizibilitate"

#: src/SUMMARY.md:124 src/modules/paths.md:1
msgid "Paths"
msgstr "Trasee"

#: src/SUMMARY.md:125 src/modules/filesystem.md:1
msgid "Filesystem Hierarchy"
msgstr "Ierarhia sistemului de fi탳iere"

#: src/SUMMARY.md:127 src/exercises/day-2/iterators-and-ownership.md:1
msgid "Iterators and Ownership"
msgstr "Iteratori 탳i posesia"

#: src/SUMMARY.md:128 src/exercises/day-2/strings-iterators.md:1
#: src/exercises/day-2/solutions-afternoon.md:3
msgid "Strings and Iterators"
msgstr "탲iruri 탳i iteratori"

#: src/SUMMARY.md:131
msgid "Day 3: Morning"
msgstr "Ziua 3: Diminea탵a"

#: src/SUMMARY.md:136 src/generics.md:1
msgid "Generics"
msgstr "Produse generice"

#: src/SUMMARY.md:137 src/generics/data-types.md:1
msgid "Generic Data Types"
msgstr "Tipuri de date generice"

#: src/SUMMARY.md:138 src/generics/methods.md:1
msgid "Generic Methods"
msgstr "Metode generice"

#: src/SUMMARY.md:139 src/generics/monomorphization.md:1
msgid "Monomorphization"
msgstr "Monomorfizare"

#: src/SUMMARY.md:140 src/traits.md:1
msgid "Traits"
msgstr "Tr캒s캒turi"

#: src/SUMMARY.md:141 src/traits/trait-objects.md:1
#, fuzzy
msgid "Trait Objects"
msgstr "Obiecte cu tr캒s캒turi"

#: src/SUMMARY.md:142 src/traits/deriving-traits.md:1
msgid "Deriving Traits"
msgstr "Derivarea tr캒s캒turilor"

#: src/SUMMARY.md:143 src/traits/default-methods.md:1
msgid "Default Methods"
msgstr "Metode implicite"

#: src/SUMMARY.md:144 src/traits/trait-bounds.md:1
msgid "Trait Bounds"
msgstr "Limite de tr캒s캒turi"

#: src/SUMMARY.md:145
msgid "impl Trait"
msgstr "impl Trait"

#: src/SUMMARY.md:146 src/traits/important-traits.md:1
msgid "Important Traits"
msgstr "Tr캒s캒turi importante"

#: src/SUMMARY.md:147
msgid "Iterator"
msgstr "Iterator"

#: src/SUMMARY.md:148 src/traits/from-iterator.md:1
msgid "FromIterator"
msgstr "FromIterator"

#: src/SUMMARY.md:149
msgid "From and Into"
msgstr "From 탳i Into"

#: src/SUMMARY.md:150
msgid "Read and Write"
msgstr "Citire 탳i scriere"

#: src/SUMMARY.md:151
msgid "Drop"
msgstr "Pic캒tur캒"

#: src/SUMMARY.md:152
msgid "Default"
msgstr "Implicit"

#: src/SUMMARY.md:153
msgid "Operators: Add, Mul, ..."
msgstr "Operatori: Add (ad캒ugare), Mul, ..."

#: src/SUMMARY.md:154
msgid "Closures: Fn, FnMut, FnOnce"
msgstr "칉nchideri: Fn, FnMut, FnOnce"

#: src/SUMMARY.md:156
msgid "A Simple GUI Library"
msgstr "O bibliotec캒 GUI simpl캒"

#: src/SUMMARY.md:157 src/exercises/day-3/solutions-morning.md:142
msgid "Points and Polygons"
msgstr "Puncte 탳i poligoane"

#: src/SUMMARY.md:159
msgid "Day 3: Afternoon"
msgstr "Ziua 3: Dup캒-amiaza"

#: src/SUMMARY.md:161 src/error-handling.md:1
msgid "Error Handling"
msgstr "Gestionarea erorilor"

#: src/SUMMARY.md:162 src/error-handling/panics.md:1
msgid "Panics"
msgstr "Panic캒"

#: src/SUMMARY.md:163
msgid "Catching Stack Unwinding"
msgstr "Prinderea derul캒rii stivei"

#: src/SUMMARY.md:164
msgid "Structured Error Handling"
msgstr "Gestionarea structurat캒 a erorilor"

#: src/SUMMARY.md:165
msgid "Propagating Errors with ?"
msgstr "Propagarea erorilor cu ?"

#: src/SUMMARY.md:166 src/error-handling/converting-error-types.md:1
#: src/error-handling/converting-error-types-example.md:1
msgid "Converting Error Types"
msgstr "Conversia tipurilor de erori"

#: src/SUMMARY.md:168 src/error-handling/deriving-error-enums.md:1
msgid "Deriving Error Enums"
msgstr "Derivarea enumera탵iilor de eroare"

#: src/SUMMARY.md:169 src/error-handling/dynamic-errors.md:1
msgid "Dynamic Error Types"
msgstr "Tipuri de erori dinamice"

#: src/SUMMARY.md:170 src/error-handling/error-contexts.md:1
msgid "Adding Context to Errors"
msgstr "Ad캒ugarea contextului la erori"

#: src/SUMMARY.md:171 src/testing.md:1
msgid "Testing"
msgstr "Testare"

#: src/SUMMARY.md:172 src/testing/unit-tests.md:1
msgid "Unit Tests"
msgstr "Teste unitare"

#: src/SUMMARY.md:173 src/testing/test-modules.md:1
msgid "Test Modules"
msgstr "Module de testare"

#: src/SUMMARY.md:174 src/testing/doc-tests.md:1
msgid "Documentation Tests"
msgstr "Teste de documentare"

#: src/SUMMARY.md:175 src/testing/integration-tests.md:1
msgid "Integration Tests"
msgstr "Teste de integrare"

#: src/SUMMARY.md:176 src/bare-metal/useful-crates.md:1
msgid "Useful crates"
msgstr "L캒zi (crates) utile"

#: src/SUMMARY.md:177 src/unsafe.md:1
msgid "Unsafe Rust"
msgstr "Rust nesigur"

#: src/SUMMARY.md:178 src/unsafe/raw-pointers.md:1
msgid "Dereferencing Raw Pointers"
msgstr "Dereferen탵ierea pointerilor bru탵i"

#: src/SUMMARY.md:179 src/unsafe/mutable-static-variables.md:1
msgid "Mutable Static Variables"
msgstr "Variabile statice mutabile"

#: src/SUMMARY.md:180 src/unsafe/unions.md:1
msgid "Unions"
msgstr "Sindicate (Unions)"

#: src/SUMMARY.md:181 src/unsafe/calling-unsafe-functions.md:1
msgid "Calling Unsafe Functions"
msgstr "Apelarea func탵iilor nesigure"

#: src/SUMMARY.md:182 src/unsafe/writing-unsafe-functions.md:1
msgid "Writing Unsafe Functions"
msgstr "Scrierea func탵iilor nesigure"

#: src/SUMMARY.md:183
msgid "Extern Functions"
msgstr "Func탵ii externe"

#: src/SUMMARY.md:184 src/unsafe/unsafe-traits.md:1
msgid "Implementing Unsafe Traits"
msgstr "Implementarea tr캒s캒turilor nesigure"

#: src/SUMMARY.md:186 src/exercises/day-3/safe-ffi-wrapper.md:1
#: src/exercises/day-3/solutions-afternoon.md:3
msgid "Safe FFI Wrapper"
msgstr "칉nf캒탳ur캒torul FFI sigur"

#: src/SUMMARY.md:189 src/SUMMARY.md:271 src/bare-metal/android.md:1
msgid "Android"
msgstr "Android"

#: src/SUMMARY.md:194 src/android/setup.md:1
msgid "Setup"
msgstr "Setare"

#: src/SUMMARY.md:195 src/android/build-rules.md:1
msgid "Build Rules"
msgstr "Reguli de construc탵ie"

#: src/SUMMARY.md:196
#, fuzzy
msgid "Binary"
msgstr "Binare"

#: src/SUMMARY.md:197
msgid "Library"
msgstr "Bibliotec캒"

#: src/SUMMARY.md:198 src/android/aidl.md:1
msgid "AIDL"
msgstr "AIDL"

#: src/SUMMARY.md:199
msgid "Interface"
msgstr "Interfa탵캒"

#: src/SUMMARY.md:200
msgid "Implementation"
msgstr "Implementare"

#: src/SUMMARY.md:201
msgid "Server"
msgstr "Server"

#: src/SUMMARY.md:202 src/android/aidl/deploy.md:1
msgid "Deploy"
msgstr "Lanseaza"

#: src/SUMMARY.md:203
msgid "Client"
msgstr "Client"

#: src/SUMMARY.md:204 src/android/aidl/changing.md:1
msgid "Changing API"
msgstr "Schimbarea API-ului"

#: src/SUMMARY.md:205 src/SUMMARY.md:261 src/android/logging.md:1
#: src/bare-metal/aps/logging.md:1
msgid "Logging"
msgstr "Jurnalizare (loguri)"

#: src/SUMMARY.md:206 src/android/interoperability.md:1
msgid "Interoperability"
msgstr "Interoperabilitate"

#: src/SUMMARY.md:207
msgid "With C"
msgstr "Cu C"

#: src/SUMMARY.md:208
msgid "Calling C with Bindgen"
msgstr "Apelarea C cu Bindgen"

#: src/SUMMARY.md:209
msgid "Calling Rust from C"
msgstr "Apelarea Rust din C"

#: src/SUMMARY.md:210 src/android/interoperability/cpp.md:1
msgid "With C++"
msgstr "Cu C++"

#: src/SUMMARY.md:211 src/android/interoperability/cpp/bridge.md:1
#, fuzzy
msgid "The Bridge Module"
msgstr "Module de testare"

#: src/SUMMARY.md:212
#, fuzzy
msgid "Rust Bridge"
msgstr "Binare Rust"

#: src/SUMMARY.md:213 src/android/interoperability/cpp/generated-cpp.md:1
msgid "Generated C++"
msgstr ""

#: src/SUMMARY.md:214
msgid "C++ Bridge"
msgstr ""

#: src/SUMMARY.md:215 src/android/interoperability/cpp/shared-types.md:1
#, fuzzy
msgid "Shared Types"
msgstr "Tipuri scalare"

#: src/SUMMARY.md:216 src/android/interoperability/cpp/shared-enums.md:1
msgid "Shared Enums"
msgstr ""

#: src/SUMMARY.md:217 src/android/interoperability/cpp/rust-result.md:1
#, fuzzy
msgid "Rust Error Handling"
msgstr "Gestionarea erorilor"

#: src/SUMMARY.md:218 src/android/interoperability/cpp/cpp-exception.md:1
#, fuzzy
msgid "C++ Error Handling"
msgstr "Gestionarea erorilor"

#: src/SUMMARY.md:219 src/android/interoperability/cpp/type-mapping.md:1
msgid "Additional Types"
msgstr ""

#: src/SUMMARY.md:220
msgid "Building for Android: C++"
msgstr ""

#: src/SUMMARY.md:221
msgid "Building for Android: Genrules"
msgstr ""

#: src/SUMMARY.md:222
msgid "Building for Android: Rust"
msgstr ""

#: src/SUMMARY.md:223
msgid "With Java"
msgstr "Cu Java"

#: src/SUMMARY.md:227
#, fuzzy
msgid "Bare Metal: Morning"
msgstr "Bare Metal: Diminea탵a"

#: src/SUMMARY.md:232
msgid "no_std"
msgstr "no_std"

#: src/SUMMARY.md:233
msgid "A Minimal Example"
msgstr "Un exemplu minimalist"

#: src/SUMMARY.md:234
#, fuzzy
msgid "alloc"
msgstr "alocare"

#: src/SUMMARY.md:235 src/bare-metal/microcontrollers.md:1
msgid "Microcontrollers"
msgstr "Microcontrolere"

#: src/SUMMARY.md:236 src/bare-metal/microcontrollers/mmio.md:1
msgid "Raw MMIO"
msgstr "MMIO brut"

#: src/SUMMARY.md:237
msgid "PACs"
msgstr "PAC-uri"

#: src/SUMMARY.md:238
msgid "HAL Crates"
msgstr "L캒zi (crates) HAL"

#: src/SUMMARY.md:239
msgid "Board Support Crates"
msgstr "L캒zi de suport pentru pl캒ci"

#: src/SUMMARY.md:240
#, fuzzy
msgid "The Type State Pattern"
msgstr "Modelul de stare de tip"

#: src/SUMMARY.md:241
msgid "embedded-hal"
msgstr "embedded-hal"

#: src/SUMMARY.md:242
msgid "probe-rs, cargo-embed"
msgstr "probe-rs, cargo-embed"

#: src/SUMMARY.md:243 src/bare-metal/microcontrollers/debugging.md:1
msgid "Debugging"
msgstr "Depanare"

#: src/SUMMARY.md:244 src/SUMMARY.md:264
msgid "Other Projects"
msgstr "Alte proiecte"

#: src/SUMMARY.md:246 src/exercises/bare-metal/compass.md:1
#: src/exercises/bare-metal/solutions-morning.md:3
#, fuzzy
msgid "Compass"
msgstr "Busol캒"

#: src/SUMMARY.md:248
msgid "Bare Metal: Afternoon"
msgstr "Bare Metal: Dup캒-amiaz캒"

#: src/SUMMARY.md:250
msgid "Application Processors"
msgstr "Procesatori de aplica탵ii"

#: src/SUMMARY.md:251 src/bare-metal/aps/entry-point.md:1
msgid "Getting Ready to Rust"
msgstr "Preg캒ti탵i pentru Rust"

#: src/SUMMARY.md:252
msgid "Inline Assembly"
msgstr "Ansamblare 칥n linie"

#: src/SUMMARY.md:253
#, fuzzy
msgid "MMIO"
msgstr "MMIO"

#: src/SUMMARY.md:254
msgid "Let's Write a UART Driver"
msgstr "S캒 scriem un driver UART"

#: src/SUMMARY.md:255
msgid "More Traits"
msgstr "Mai multe tr캒s캒turi"

#: src/SUMMARY.md:256
msgid "A Better UART Driver"
msgstr "Un driver UART mai bun"

#: src/SUMMARY.md:257 src/bare-metal/aps/better-uart/bitflags.md:1
#, fuzzy
msgid "Bitflags"
msgstr "Bitflags"

#: src/SUMMARY.md:258
msgid "Multiple Registers"
msgstr "Registre multiple"

#: src/SUMMARY.md:259 src/bare-metal/aps/better-uart/driver.md:1
#, fuzzy
msgid "Driver"
msgstr "Conductor (driver)"

#: src/SUMMARY.md:260 src/SUMMARY.md:262
msgid "Using It"
msgstr "Utilizarea acestuia"

#: src/SUMMARY.md:263 src/bare-metal/aps/exceptions.md:1
msgid "Exceptions"
msgstr "Excep탵ii"

#: src/SUMMARY.md:265
msgid "Useful Crates"
msgstr "L캒zi utile"

#: src/SUMMARY.md:266
msgid "zerocopy"
msgstr "zerocopy"

#: src/SUMMARY.md:267
msgid "aarch64-paging"
msgstr "aarch64-paging"

#: src/SUMMARY.md:268
msgid "buddy_system_allocator"
msgstr "buddy_system_allocator"

#: src/SUMMARY.md:269
msgid "tinyvec"
msgstr "tinyvec"

#: src/SUMMARY.md:270
msgid "spin"
msgstr "rotire"

#: src/SUMMARY.md:272 src/bare-metal/android/vmbase.md:1
msgid "vmbase"
msgstr "vmbase"

#: src/SUMMARY.md:274
msgid "RTC Driver"
msgstr "Conductor RTC"

#: src/SUMMARY.md:277
msgid "Concurrency: Morning"
msgstr "Concuren탵캒: Diminea탵a"

#: src/SUMMARY.md:282 src/concurrency/threads.md:1
msgid "Threads"
msgstr "Conversatii"

#: src/SUMMARY.md:283 src/concurrency/scoped-threads.md:1
#, fuzzy
msgid "Scoped Threads"
msgstr "Filete de acoperire"

#: src/SUMMARY.md:284 src/concurrency/channels.md:1
msgid "Channels"
msgstr "Canale"

#: src/SUMMARY.md:285 src/concurrency/channels/unbounded.md:1
msgid "Unbounded Channels"
msgstr "Canale nerestric탵ionate"

#: src/SUMMARY.md:286 src/concurrency/channels/bounded.md:1
#, fuzzy
msgid "Bounded Channels"
msgstr "Canale delimitate"

#: src/SUMMARY.md:287
msgid "Send and Sync"
msgstr "Trimitere 탳i sincronizare"

#: src/SUMMARY.md:287
msgid "Send"
msgstr "Trimitere (send)"

#: src/SUMMARY.md:287
msgid "Sync"
msgstr "Sincronizare (sync)"

#: src/SUMMARY.md:290 src/concurrency/send-sync/examples.md:1
msgid "Examples"
msgstr "Exemple"

#: src/SUMMARY.md:291 src/concurrency/shared_state.md:1
msgid "Shared State"
msgstr "Statut comun"

#: src/SUMMARY.md:292
msgid "Arc"
msgstr "Arc"

#: src/SUMMARY.md:293
msgid "Mutex"
msgstr "Mutex"

#: src/SUMMARY.md:296 src/SUMMARY.md:317
#: src/exercises/concurrency/dining-philosophers.md:1
#: src/exercises/concurrency/solutions-morning.md:3
msgid "Dining Philosophers"
msgstr "Filozofii la mas캒"

#: src/SUMMARY.md:297 src/exercises/concurrency/link-checker.md:1
msgid "Multi-threaded Link Checker"
msgstr "Verificator de leg캒turi cu mai multe fire de execu탵ie"

#: src/SUMMARY.md:299
msgid "Concurrency: Afternoon"
msgstr "Concuren탵캒: Dup캒-amiaz캒"

#: src/SUMMARY.md:301
msgid "Async Basics"
msgstr "Bazele Async"

#: src/SUMMARY.md:302
msgid "async/await"
msgstr "async/await"

#: src/SUMMARY.md:303 src/async/futures.md:1
msgid "Futures"
msgstr "Futures"

#: src/SUMMARY.md:304 src/async/runtimes.md:1
#, fuzzy
msgid "Runtimes"
msgstr "Timpi de execu탵ie"

#: src/SUMMARY.md:305 src/async/runtimes/tokio.md:1
msgid "Tokio"
msgstr "Tokio"

#: src/SUMMARY.md:306 src/exercises/concurrency/link-checker.md:126
#: src/async/tasks.md:1 src/exercises/concurrency/chat-app.md:143
msgid "Tasks"
msgstr "Task-uri"

#: src/SUMMARY.md:307 src/async/channels.md:1
msgid "Async Channels"
msgstr "Canale asincrone"

#: src/SUMMARY.md:309 src/async/control-flow/join.md:1
msgid "Join"
msgstr "Al캒turare (join)"

#: src/SUMMARY.md:310 src/async/control-flow/select.md:1
msgid "Select"
msgstr "Selec탵ie (select)"

#: src/SUMMARY.md:311
msgid "Pitfalls"
msgstr "Capcane"

#: src/SUMMARY.md:312
msgid "Blocking the Executor"
msgstr "Blocarea executorului"

#: src/SUMMARY.md:313 src/async/pitfalls/pin.md:1
msgid "Pin"
msgstr "Fixa탵i"

#: src/SUMMARY.md:314 src/async/pitfalls/async-traits.md:1
msgid "Async Traits"
msgstr "Tr캒s캒turi asincrone"

#: src/SUMMARY.md:315 src/async/pitfalls/cancellation.md:1
msgid "Cancellation"
msgstr "Anulare"

#: src/SUMMARY.md:318 src/exercises/concurrency/chat-app.md:1
#: src/exercises/concurrency/solutions-afternoon.md:95
msgid "Broadcast Chat Application"
msgstr "Aplica탵ie de chat cu difuzare"

#: src/SUMMARY.md:321
msgid "Final Words"
msgstr "Ultimele cuvinte"

#: src/SUMMARY.md:325 src/thanks.md:1
msgid "Thanks!"
msgstr "Va multumim !"

#: src/SUMMARY.md:326 src/glossary.md:1
msgid "Glossary"
msgstr "Glosar"

#: src/SUMMARY.md:327
msgid "Other Resources"
msgstr "Alte resurse"

#: src/SUMMARY.md:328 src/credits.md:1
msgid "Credits"
msgstr "Credite"

#: src/SUMMARY.md:331 src/exercises/solutions.md:1
msgid "Solutions"
msgstr "Solu탵ii"

#: src/SUMMARY.md:336
msgid "Day 1 Morning"
msgstr "Ziua 1: Diminea탵a"

#: src/SUMMARY.md:337
msgid "Day 1 Afternoon"
msgstr "Ziua 1 Dup캒-amiaza"

#: src/SUMMARY.md:338
msgid "Day 2 Morning"
msgstr "Ziua 2 Diminea탵a"

#: src/SUMMARY.md:339
msgid "Day 2 Afternoon"
msgstr "Ziua 2 Dup캒-amiaza"

#: src/SUMMARY.md:340
msgid "Day 3 Morning"
msgstr "Ziua 3 Diminea탵a"

#: src/SUMMARY.md:341
msgid "Day 3 Afternoon"
msgstr "Ziua 3 Dup캒-amiaza"

#: src/SUMMARY.md:342
msgid "Bare Metal Rust Morning"
msgstr "Rust bare metall Diminea탵a"

#: src/SUMMARY.md:343 src/exercises/bare-metal/solutions-afternoon.md:1
msgid "Bare Metal Rust Afternoon"
msgstr "Rust bare metal Dup캒-amiaz캒"

#: src/SUMMARY.md:344
msgid "Concurrency Morning"
msgstr "Concuren탵a Diminea탵a"

#: src/SUMMARY.md:345
msgid "Concurrency Afternoon"
msgstr "Concuren탵a Dup캒-amiaza"

#: src/index.md:3
msgid ""
"[![Build workflow](https://img.shields.io/github/actions/workflow/status/"
"google/comprehensive-rust/build.yml?style=flat-square)](https://github.com/"
"google/comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain) [!"
"[GitHub contributors](https://img.shields.io/github/contributors/google/"
"comprehensive-rust?style=flat-square)](https://github.com/google/"
"comprehensive-rust/graphs/contributors) [![GitHub stars](https://img.shields."
"io/github/stars/google/comprehensive-rust?style=flat-square)](https://github."
"com/google/comprehensive-rust/stargazers)"
msgstr ""
"[![Fluxul de construc탵ie](https://img.shields.io/github/actions/workflow/"
"status/google/comprehensive-rust/build.yml?style=flat-square)](https://"
"github.com/google/comprehensive-rust/actions/workflows/build.yml?"
"query=branch%3Amain) [![Contribuitori GitHub](https://img.shields.io/github/"
"contributors/google/comprehensive-rust?style=flat-square)](https://github."
"com/google/comprehensive-rust/graphs/contributors) [![Stele GitHub](https://"
"img.shields.io/github/stars/google/comprehensive-rust?style=flat-square)]"
"(https://github.com/google/comprehensive-rust/stargazers)"

#: src/index.md:7
msgid ""
"This is a free Rust course developed by the Android team at Google. The "
"course covers the full spectrum of Rust, from basic syntax to advanced "
"topics like generics and error handling."
msgstr ""
"Acesta este un curs gratuit de Rust dezvoltat de echipa Android de la "
"Google. Cursul acoper캒 칥ntregul spectru Rust, de la sintaxa de baz캒 p칙n캒 la "
"subiecte avansate, cum ar fi genericele 탳i gestionarea erorilor."

#: src/index.md:11
msgid ""
"The latest version of the course can be found at <https://google.github.io/"
"comprehensive-rust/>. If you are reading somewhere else, please check there "
"for updates."
msgstr ""
"Cea mai recent캒 versiune a cursului poate fi g캒sit캒 la adresa <https://"
"google.github.io/comprehensive-rust/>. Dac캒 citi탵i 칥n alt캒 parte, v캒 rug캒m "
"s캒 verifica탵i acolo pentru actualiz캒ri."

#: src/index.md:15
msgid ""
"The goal of the course is to teach you Rust. We assume you don't know "
"anything about Rust and hope to:"
msgstr ""
"Scopul cursului este de a v캒 칥nv캒탵a Rust. Presupunem c캒 nu 탳ti탵i nimic "
"despre Rust 탳i, la sf칙r탳it, sper캒m s캒:"

#: src/index.md:18
msgid "Give you a comprehensive understanding of the Rust syntax and language."
msgstr "Ave탵i o 칥n탵elegere cuprinz캒toare a sintaxei 탳i a limbajului Rust."

#: src/index.md:19
msgid "Enable you to modify existing programs and write new programs in Rust."
msgstr ""
"Pute탵i s캒 modifica탵i programele existente 탳i s캒 scrie탵i programe noi 칥n Rust."

#: src/index.md:20
msgid "Show you common Rust idioms."
msgstr "Cunoa탳te탵i expresii uzuale din Rust."

#: src/index.md:22
msgid "We call the first three course days Rust Fundamentals."
msgstr "Primele trei zile de curs se numesc Rust Fundamentals."

#: src/index.md:24
msgid ""
"Building on this, you're invited to dive into one or more specialized topics:"
msgstr ""
"Pornind de la acestea, sunte탵i invita탵i s캒 aprofunda탵i unul sau mai multe "
"subiecte specializate:"

#: src/index.md:26
msgid ""
"[Android](android.md): a half-day course on using Rust for Android platform "
"development (AOSP). This includes interoperability with C, C++, and Java."
msgstr ""
"[Android](android.md): un curs de o jum캒tate de zi despre utilizarea Rust "
"pentru dezvoltarea platformei Android (AOSP). Acesta include "
"interoperabilitatea cu C, C++ 탳i Java."

#: src/index.md:28
msgid ""
"[Bare-metal](bare-metal.md): a whole-day class on using Rust for bare-metal "
"(embedded) development. Both microcontrollers and application processors are "
"covered."
msgstr ""
"[Bare-metal](bare-metal.md): un curs de o zi 칥ntreag캒 despre utilizarea Rust "
"pentru dezvoltarea bare-metal (칥ncorporat캒). Sunt acoperite at칙t "
"microcontrolerele, c칙t 탳i procesoarele de aplica탵ii."

#: src/index.md:31
msgid ""
"[Concurrency](concurrency.md): a whole-day class on concurrency in Rust. We "
"cover both classical concurrency (preemptively scheduling using threads and "
"mutexes) and async/await concurrency (cooperative multitasking using "
"futures)."
msgstr ""
"[Concurrency](concurrency.md): un curs de o zi 칥ntreag캒 despre concuren탵a 칥n "
"Rust. Acoperim at칙t concuren탵a clasic캒 (programarea preemptiv캒 folosind fire "
"de execu탵ie 탳i mutexuri), c칙t 탳i concuren탵a async/await (multitasking "
"cooperativ folosind futures)."

#: src/index.md:37
msgid "Non-Goals"
msgstr "Alte obiective dec칙t cele de baz캒"

#: src/index.md:39
msgid ""
"Rust is a large language and we won't be able to cover all of it in a few "
"days. Some non-goals of this course are:"
msgstr ""
"Rust este un limbaj mare 탳i nu vom putea acoperi toate aspectele 칥n c칙teva "
"zile. C칙teva dintre non-obiectivele acestui curs sunt:"

#: src/index.md:42
msgid ""
"Learning how to develop macros: please see [Chapter 19.5 in the Rust Book]"
"(https://doc.rust-lang.org/book/ch19-06-macros.html) and [Rust by Example]"
"(https://doc.rust-lang.org/rust-by-example/macros.html) instead."
msgstr ""
"칉nv캒탵area modului de dezvoltare a macrocomenzilor: v캒 rug캒m s캒 consulta탵i 칥n "
"schimb [Capitolul 19.5 din Rust Book](https://doc.rust-lang.org/book/ch19-06-"
"macros.html) 탳i [Rust by Example](https://doc.rust-lang.org/rust-by-example/"
"macros.html)."

#: src/index.md:46
msgid "Assumptions"
msgstr "Ipoteze"

#: src/index.md:48
msgid ""
"The course assumes that you already know how to program. Rust is a "
"statically-typed language and we will sometimes make comparisons with C and "
"C++ to better explain or contrast the Rust approach."
msgstr ""
"Cursul porne탳te de la premisa c캒 탳ti탵i deja s캒 programa탵i. Rust este un "
"limbaj cu tipare static캒 탳i uneori vom face compara탵ii cu C 탳i C++ pentru a "
"explica mai bine sau a contrasta abordarea Rust."

#: src/index.md:52
msgid ""
"If you know how to program in a dynamically-typed language such as Python or "
"JavaScript, then you will be able to follow along just fine too."
msgstr ""
"Dac캒 탳ti탵i s캒 programa탵i 칥ntr-un limbaj cu tipuri dinamice, cum ar fi Python "
"sau JavaScript, atunci ve탵i putea s캒 v캒 descurca탵i foarte bine."

#: src/index.md:57
msgid ""
"This is an example of a _speaker note_. We will use these to add additional "
"information to the slides. This could be key points which the instructor "
"should cover as well as answers to typical questions which come up in class."
msgstr ""
"Acesta este un exemplu de _noti탵e pentru prezentator_. Le vom folosi pentru "
"a ad캒uga informa탵ii suplimentare la diapozitive. Acestea pot fi puncte cheie "
"pe care instructorul ar trebui s캒 le abordeze, precum 탳i r캒spunsuri la "
"칥ntreb캒ri tipice care apar 칥n clas캒."

#: src/running-the-course.md:3 src/running-the-course/course-structure.md:3
msgid "This page is for the course instructor."
msgstr "Aceast캒 pagin캒 este destinat캒 instructorului de curs."

#: src/running-the-course.md:5
msgid ""
"Here is a bit of background information about how we've been running the "
"course internally at Google."
msgstr ""
"Iat캒 c칙teva informa탵ii de fond despre modul 칥n care am desf캒탳urat cursul 칥n "
"cadrul Google."

#: src/running-the-course.md:8
msgid ""
"We typically run classes from 10:00 am to 4:00 pm, with a 1 hour lunch break "
"in the middle. This leaves 2.5 hours for the morning class and 2.5 hours for "
"the afternoon class. Note that this is just a recommendation: you can also "
"spend 3 hour on the morning session to give people more time for exercises. "
"The downside of longer session is that people can become very tired after 6 "
"full hours of class in the afternoon."
msgstr ""
"De obicei, cursurile se desf캒탳oar캒 칥ntre orele 10:00 탳i 16:00, cu o pauz캒 de "
"mas캒 de o or캒 la mijloc. Astfel, r캒m칙n 2,5 ore pentru cursul de diminea탵캒 탳i "
"2,5 ore pentru cursul de dup캒-amiaz캒. Re탵ine탵i c캒 aceasta este doar o "
"recomandare: pute탵i, de asemenea, s캒 petrece탵i 3 ore la sesiunea de "
"diminea탵캒 pentru a le oferi oamenilor mai mult timp pentru exerci탵ii. "
"Dezavantajul unei sesiuni mai lungi este c캒 participan탵ii pot deveni foarte "
"obosi탵i dup캒 6 ore 칥ntregi de curs dup캒-amiaza."

#: src/running-the-course.md:16
msgid "Before you run the course, you will want to:"
msgstr "칉nainte de a parcurge cursul, ve탵i dori s캒:"

#: src/running-the-course.md:18
msgid ""
"Make yourself familiar with the course material. We've included speaker "
"notes to help highlight the key points (please help us by contributing more "
"speaker notes!). When presenting, you should make sure to open the speaker "
"notes in a popup (click the link with a little arrow next to \"Speaker "
"Notes\"). This way you have a clean screen to present to the class."
msgstr ""
"V캒 familiariza탵i cu materialul de curs. Am inclus note ale vorbitorului "
"pentru a eviden탵ia punctele cheie (v캒 rug캒m s캒 ne ajuta탵i contribuind cu mai "
"multe note pentru prezentare!). Atunci c칙nd prezenta탵i, asigura탵i-v캒 c캒 "
"deschide탵i notele prezentatorului 칥ntr-o fereastr캒 pop-up (face탵i clic pe "
"link-ul cu o s캒geat캒 mic캒 de l칙ng캒 \"Speaker Notes\"). 칉n acest fel, ve탵i "
"avea un ecran curat pentru a prezenta 칥n fa탵a clasei."

#: src/running-the-course.md:24
msgid ""
"Decide on the dates. Since the course takes at least three full days, we "
"recommend that you schedule the days over two weeks. Course participants "
"have said that they find it helpful to have a gap in the course since it "
"helps them process all the information we give them."
msgstr ""
"Decide탵i datele. Deoarece cursul dureaz캒 cel pu탵in trei zile 칥ntregi, v캒 "
"recomand캒m s캒 programa탵i zilele pe parcursul a dou캒 s캒pt캒m칙ni. Participan탵ii "
"la curs au spus c캒 li se pare util s캒 existe un interval 칥n timpul cursului, "
"deoarece 칥i ajut캒 s캒 proceseze toate informa탵iile pe care le oferim."

#: src/running-the-course.md:29
msgid ""
"Find a room large enough for your in-person participants. We recommend a "
"class size of 15-25 people. That's small enough that people are comfortable "
"asking questions --- it's also small enough that one instructor will have "
"time to answer the questions. Make sure the room has _desks_ for yourself "
"and for the students: you will all need to be able to sit and work with your "
"laptops. In particular, you will be doing a lot of live-coding as an "
"instructor, so a lectern won't be very helpful for you."
msgstr ""
"G캒si탵i o sal캒 suficient de mare pentru participan탵ii prezen탵i. V캒 recomand캒m "
"o clas캒 de 15-25 de persoane. Este suficient de mic캒 pentru ca oamenii s캒 se "
"simt캒 confortabil s캒 pun캒 칥ntreb캒ri --- este, de asemenea, suficient de mic캒 "
"pentru ca un instructor s캒 aib캒 timp s캒 r캒spund캒 la 칥ntreb캒ri. Asigura탵i-v캒 "
"c캒 sala are _locuri/birouri pentru dumneavoastr캒 탳i pentru studen탵i: cu "
"to탵ii ve탵i avea nevoie s캒 pute탵i sta jos 탳i s캒 lucra탵i cu laptopurile. 칉n "
"special, 칥n calitate de instructor, ve탵i face o mul탵ime de live-coding, a탳a "
"c캒 un pupitru nu v캒 va fi de mare ajutor."

#: src/running-the-course.md:37
msgid ""
"On the day of your course, show up to the room a little early to set things "
"up. We recommend presenting directly using `mdbook serve` running on your "
"laptop (see the [installation instructions](https://github.com/google/"
"comprehensive-rust#building)). This ensures optimal performance with no lag "
"as you change pages. Using your laptop will also allow you to fix typos as "
"you or the course participants spot them."
msgstr ""
"Ajunge탵i 칥n sal캒 cu suficient timp 칥nainte pentru a preg캒ti totul. V캒 "
"recomand캒m s캒 prezenta탵i direct folosind `mdbook serve` care ruleaz캒 pe "
"laptopul dumneavoastr캒 (consulta탵i [instruc탵iuni de instalare](https://"
"github.com/google/comprehensive-rust#building)). Acest lucru asigur캒 o "
"performan탵캒 optim캒, f캒r캒 칥nt칙rzieri 칥n timp ce schimba탵i paginile. Folosirea "
"laptopului v캒 va permite, de asemenea, s캒 corecta탵i gre탳elile de tipar pe "
"m캒sur캒 ce dumneavoastr캒 sau participan탵ii la curs le descoperi탵i."

#: src/running-the-course.md:43
msgid ""
"Let people solve the exercises by themselves or in small groups. We "
"typically spend 30-45 minutes on exercises in the morning and in the "
"afternoon (including time to review the solutions). Make sure to ask people "
"if they're stuck or if there is anything you can help with. When you see "
"that several people have the same problem, call it out to the class and "
"offer a solution, e.g., by showing people where to find the relevant "
"information in the standard library."
msgstr ""
"L캒sa탵i participan탵ii s캒 rezolve exerci탵iile singuri sau 칥n grupuri mici. 칉n "
"mod obi탳nuit, dedic캒m 30-45 de minute exerci탵iilor diminea탵a 탳i dup캒-amiaza "
"(inclusiv timpul necesar pentru revizuirea solu탵iilor). Asigura탵i-v캒 c캒 칥i "
"칥ntreba탵i pe cursan탵i dac캒 s-au blocat sau dac캒 exist캒 ceva cu care 칥i "
"pute탵i ajuta. C칙nd vede탵i c캒 mai multe persoane au aceea탳i problem캒, "
"anun탵a탵i clasa 탳i oferi탵i o solu탵ie, de exemplu, ar캒t칙nd unde se pot g캒si "
"informa탵iile relevante 칥n biblioteca standard."

#: src/running-the-course.md:51
msgid ""
"That is all, good luck running the course! We hope it will be as much fun "
"for you as it has been for us!"
msgstr ""
"Asta e tot, mult succes 칥n prezentarea cursului! Sper캒m c캒 va fi la fel de "
"distractiv pentru voi cum a fost pentru noi!"

#: src/running-the-course.md:54
#, fuzzy
msgid ""
"Please [provide feedback](https://github.com/google/comprehensive-rust/"
"discussions/86) afterwards so that we can keep improving the course. We "
"would love to hear what worked well for you and what can be made better. "
"Your students are also very welcome to [send us feedback](https://github.com/"
"google/comprehensive-rust/discussions/100)!"
msgstr ""
"V캒 rug캒m s캒 [oferi탵i sugestii](https://github.com/google/comprehensive-rust/"
"discussions/86) dup캒 aceea, astfel 칥nc칙t s캒 putem 칥mbun캒t캒탵i cursul. Ne-ar "
"pl캒cea s캒 afl캒m ce a func탵ionat bine pentru dvs. 탳i ce poate fi 칥mbun캒t캒탵it. "
"Studen탵ii dumneavoastr캒 sunt, de asemenea, foarte bineveni탵i s캒 [ne trimit캒 "
"feedback](https://github.com/google/comprehensive-rust/discussions/100)!"

#: src/running-the-course/course-structure.md:5
msgid "Rust Fundamentals"
msgstr "Fundamentele Rust"

#: src/running-the-course/course-structure.md:7
msgid ""
"The first three days make up [Rust Fundaments](../welcome-day-1.md). The "
"days are fast paced and we cover a lot of ground:"
msgstr ""
"Primele trei zile alc캒tuiesc [Fundamentele Rust](../welcome-day-1.md). "
"Zilele se desf캒탳oar캒 칥ntr-un ritm rapid 탳i acoperim o mul탵ime de subiecte:"

#: src/running-the-course/course-structure.md:10
msgid "Day 1: Basic Rust, syntax, control flow, creating and consuming values."
msgstr ""
"Ziua 1: Baza Rust, sintaxa, fluxul de control, crearea 탳i consumarea "
"valorilor."

#: src/running-the-course/course-structure.md:11
msgid ""
"Day 2: Memory management, ownership, compound data types, and the standard "
"library."
msgstr ""
"Ziua 2: Gestionarea memoriei, posesia, tipurile de date compuse 탳i "
"biblioteca standard."

#: src/running-the-course/course-structure.md:12
msgid "Day 3: Generics, traits, error handling, testing, and unsafe Rust."
msgstr ""
"Ziua 3: Generice, tr캒s캒turi, gestionarea erorilor, testare 탳i Rust nesigur."

#: src/running-the-course/course-structure.md:14
msgid "Deep Dives"
msgstr "Subiecte  aprofundate"

#: src/running-the-course/course-structure.md:16
msgid ""
"In addition to the 3-day class on Rust Fundamentals, we cover some more "
"specialized topics:"
msgstr ""
"칉n plus fa탵캒 de cursul de 3 zile despre fundamentele Rust, abord캒m c칙teva "
"subiecte mai specializate:"

#: src/running-the-course/course-structure.md:19
msgid "Rust in Android"
msgstr "Rust 칥n Android"

#: src/running-the-course/course-structure.md:21
msgid ""
"The [Rust in Android](../android.md) deep dive is a half-day course on using "
"Rust for Android platform development. This includes interoperability with "
"C, C++, and Java."
msgstr ""
"[Rust 칥n Android](../android.md) este un curs de o jum캒tate de zi despre "
"utilizarea Rust pentru dezvoltarea platformei Android. Acesta include "
"interoperabilitatea cu C, C++ 탳i Java."

#: src/running-the-course/course-structure.md:25
msgid ""
"You will need an [AOSP checkout](https://source.android.com/docs/setup/"
"download/downloading). Make a checkout of the [course repository](https://"
"github.com/google/comprehensive-rust) on the same machine and move the `src/"
"android/` directory into the root of your AOSP checkout. This will ensure "
"that the Android build system sees the `Android.bp` files in `src/android/`."
msgstr ""
"Ve탵i avea nevoie de un [sursele AOSP](https://source.android.com/docs/setup/"
"download/downloading). Efectua탵i o desc캒rcare a [resurselor cursului]"
"(https://github.com/google/comprehensive-rust) pe aceea탳i ma탳in캒 탳i muta탵i "
"directorul `src/android/` 칥n r캒d캒cina surselor AOSP. Acest lucru va asigura "
"c캒 sistemul de compilare Android vede fi탳ierele `Android.bp` din `src/"
"android/`."

#: src/running-the-course/course-structure.md:30
msgid ""
"Ensure that `adb sync` works with your emulator or real device and pre-build "
"all Android examples using `src/android/build_all.sh`. Read the script to "
"see the commands it runs and make sure they work when you run them by hand."
msgstr ""
"Asigura탵i-v캒 c캒 `adb sync` func탵ioneaz캒 cu emulatorul sau cu dispozitivul "
"real 탳i precompila탵i toate exemplele Android folosind `src/android/build_all."
"sh`. Citi탵i scriptul pentru a vedea comenzile pe care le execut캒 탳i "
"asigura탵i-v캒 c캒 acestea func탵ioneaz캒 atunci c칙nd le executa탵i manual."

#: src/running-the-course/course-structure.md:37
msgid "Bare-Metal Rust"
msgstr "Rust direct pe plac캒"

#: src/running-the-course/course-structure.md:39
msgid ""
"The [Bare-Metal Rust](../bare-metal.md) deep dive is a full day class on "
"using Rust for bare-metal (embedded) development. Both microcontrollers and "
"application processors are covered."
msgstr ""
"[Rust direct pe plac캒](../bare-metal.md) este un curs de o zi 칥ntreag캒 "
"despre utilizarea Rust pentru dezvoltarea bare-metal (embedded). Sunt "
"acoperite at칙t microcontrolerele, c칙t 탳i procesoarele de aplica탵ii."

#: src/running-the-course/course-structure.md:43
msgid ""
"For the microcontroller part, you will need to buy the [BBC micro:bit]"
"(https://microbit.org/) v2 development board ahead of time. Everybody will "
"need to install a number of packages as described on the [welcome page](../"
"bare-metal.md)."
msgstr ""
"Pentru partea de microcontroler, va trebui s캒 cump캒ra탵i din timp placa de "
"dezvoltare [BBC micro:bit](https://microbit.org/) v2. Toat캒 lumea va trebui "
"s캒 instaleze o serie de pachete, a탳a cum este descris pe [pagina de bun "
"venit](../bare-metal.md)."

#: src/running-the-course/course-structure.md:48
msgid "Concurrency in Rust"
msgstr "Concuren탵캒 칥n Rust"

#: src/running-the-course/course-structure.md:50
msgid ""
"The [Concurrency in Rust](../concurrency.md) deep dive is a full day class "
"on classical as well as `async`/`await` concurrency."
msgstr ""
"[Concuren탵a 칥n Rust] (../concurrency.md) este un curs de o zi 칥ntreag캒 "
"despre concuren탵a clasic캒, precum 탳i despre concuren탵a `async`/`await`."

#: src/running-the-course/course-structure.md:53
msgid ""
"You will need a fresh crate set up and the dependencies downloaded and ready "
"to go. You can then copy/paste the examples into `src/main.rs` to experiment "
"with them:"
msgstr ""
"Ve탵i avea nevoie de un nou crate configurat 탳i de dependen탵ele desc캒rcate 탳i "
"preg캒tite. Pute탵i apoi s캒 copia탵i exemplele 칥n `src/main.rs` pentru a "
"experimenta cu ele:"

#: src/running-the-course/course-structure.md:64
msgid "Format"
msgstr "Format"

#: src/running-the-course/course-structure.md:66
msgid ""
"The course is meant to be very interactive and we recommend letting the "
"questions drive the exploration of Rust!"
msgstr ""
"Cursul se dore탳te a fi foarte interactiv 탳i v캒 recomand캒m s캒 l캒sa탵i "
"칥ntreb캒rile s캒 conduc캒 explorarea Rust!"

#: src/running-the-course/keyboard-shortcuts.md:3
msgid "There are several useful keyboard shortcuts in mdBook:"
msgstr "칉n mdBook exist캒 mai multe comenzi rapide utile de la tastatur캒:"

#: src/running-the-course/keyboard-shortcuts.md:5
msgid "Arrow-Left"
msgstr "S캒geat캒-st칙nga"

#: src/running-the-course/keyboard-shortcuts.md:5
msgid ": Navigate to the previous page."
msgstr ": Naviga탵i la pagina anterioar캒."

#: src/running-the-course/keyboard-shortcuts.md:6
msgid "Arrow-Right"
msgstr "S캒geat캒-dreapta"

#: src/running-the-course/keyboard-shortcuts.md:6
msgid ": Navigate to the next page."
msgstr ": Naviga탵i la pagina urm캒toare."

#: src/running-the-course/keyboard-shortcuts.md:7 src/cargo/code-samples.md:19
msgid "Ctrl + Enter"
msgstr "Ctrl + Enter"

#: src/running-the-course/keyboard-shortcuts.md:7
msgid ": Execute the code sample that has focus."
msgstr ": Executa탵i mostra de cod care are focusul."

#: src/running-the-course/keyboard-shortcuts.md:8
msgid "s"
msgstr "S"

#: src/running-the-course/keyboard-shortcuts.md:8
msgid ": Activate the search bar."
msgstr ": Activa탵i bara de c캒utare."

#: src/running-the-course/translations.md:3
msgid ""
"The course has been translated into other languages by a set of wonderful "
"volunteers:"
msgstr ""
"Cursul a fost tradus 칥n alte limbi de c캒tre o serie de voluntari minuna탵i:"

#: src/running-the-course/translations.md:6
msgid ""
"[Brazilian Portuguese](https://google.github.io/comprehensive-rust/pt-BR/) "
"by [@rastringer](https://github.com/rastringer), [@hugojacob](https://github."
"com/hugojacob), [@joaovicmendes](https://github.com/joaovicmendes), and "
"[@henrif75](https://github.com/henrif75)."
msgstr ""
"[Brazilian캒 portughez캒](https://google.github.io/comprehensive-rust/pt-BR/) "
"de [@rastringer](https://github.com/rastringer), [@hugojacob](https://github."
"com/hugojacob), [@joaovicmendes](https://github.com/joaovicmendes) 탳i "
"[@henrif75](https://github.com/henrif75)."

#: src/running-the-course/translations.md:7
msgid ""
"[Chinese (Simplified)](https://google.github.io/comprehensive-rust/zh-CN/) "
"by [@suetfei](https://github.com/suetfei), [@wnghl](https://github.com/"
"wnghl), [@anlunx](https://github.com/anlunx), [@kongy](https://github.com/"
"kongy), [@noahdragon](https://github.com/noahdragon), [@superwhd](https://"
"github.com/superwhd), [@SketchK](https://github.com/SketchK), and [@nodmp]"
"(https://github.com/nodmp)."
msgstr ""
"[Chinez캒 (simplificat캒)](https://google.github.io/comprehensive-rust/zh-CN/) "
"de [@suetfei](https://github.com/suetfei), [@wnghl](https://github.com/"
"wnghl), [@anlunx](https://github.com/anlunx), [@kongy](https://github.com/"
"kongy), [@noahdragon](https://github.com/noahdragon), [@superwhd](https://"
"github.com/superwhd), [@SketchK](https://github.com/SketchK), 탳i [@nodmp]"
"(https://github.com/nodmp)."

#: src/running-the-course/translations.md:8
msgid ""
"[Chinese (Traditional)](https://google.github.io/comprehensive-rust/zh-TW/) "
"by [@hueich](https://github.com/hueich), [@victorhsieh](https://github.com/"
"victorhsieh), [@mingyc](https://github.com/mingyc), [@kuanhungchen](https://"
"github.com/kuanhungchen), and [@johnathan79717](https://github.com/"
"johnathan79717)."
msgstr ""
"[Chinez캒 (tradi탵ional캒)](https://google.github.io/comprehensive-rust/zh-TW/) "
"de [@hueich](https://github.com/hueich), [@victorhsieh](https://github.com/"
"victorhsieh), [@mingyc](https://github.com/mingyc), [@kuanhungchen](https://"
"github.com/kuanhungchen), 탳i [@johnathan79717](https://github.com/"
"johnathan79717)."

#: src/running-the-course/translations.md:9
msgid ""
"[Korean](https://google.github.io/comprehensive-rust/ko/) by [@keispace]"
"(https://github.com/keispace), [@jiyongp](https://github.com/jiyongp), and "
"[@jooyunghan](https://github.com/jooyunghan)."
msgstr ""
"[Corean캒](https://google.github.io/comprehensive-rust/ko/) de [@keispace]"
"(https://github.com/keispace), [@jiyongp](https://github.com/jiyongp) 탳i "
"[@jooyunghan](https://github.com/jooyunghan)."

#: src/running-the-course/translations.md:10
msgid ""
"[Spanish](https://google.github.io/comprehensive-rust/es/) by [@deavid]"
"(https://github.com/deavid)."
msgstr ""
"[Spaniol캒](https://google.github.io/comprehensive-rust/es/) de [@deavid]"
"(https://github.com/deavid)."

#: src/running-the-course/translations.md:12
msgid ""
"Use the language picker in the top-right corner to switch between languages."
msgstr ""
"Utiliza탵i selectorul de limb캒 din col탵ul din dreapta sus pentru a comuta "
"칥ntre limbi."

#: src/running-the-course/translations.md:14
msgid "Incomplete Translations"
msgstr "Traduceri incomplete"

#: src/running-the-course/translations.md:16
msgid ""
"There is a large number of in-progress translations. We link to the most "
"recently updated translations:"
msgstr ""
"Exist캒 un num캒r mare de traduceri 칥n curs de realizare. Iat캒 cele mai "
"recente traduceri actualizate:"

#: src/running-the-course/translations.md:19
msgid ""
"[Bengali](https://google.github.io/comprehensive-rust/bn/) by [@raselmandol]"
"(https://github.com/raselmandol)."
msgstr ""
"[Bengalez캒](https://google.github.io/comprehensive-rust/bn/) de "
"[@raselmandol](https://github.com/raselmandol)."

#: src/running-the-course/translations.md:20
msgid ""
"[French](https://google.github.io/comprehensive-rust/fr/) by [@KookaS]"
"(https://github.com/KookaS) and [@vcaen](https://github.com/vcaen)."
msgstr ""
"[Francez캒](https://google.github.io/comprehensive-rust/fr/) de [@KookaS]"
"(https://github.com/KookaS) 탳i [@vcaen](https://github.com/vcaen)."

#: src/running-the-course/translations.md:21
msgid ""
"[German](https://google.github.io/comprehensive-rust/de/) by [@Throvn]"
"(https://github.com/Throvn) and [@ronaldfw](https://github.com/ronaldfw)."
msgstr ""
"[German캒](https://google.github.io/comprehensive-rust/de/) de [@Throvn]"
"(https://github.com/Throvn) 탳i [@ronaldfw](https://github.com/ronaldfw)."

#: src/running-the-course/translations.md:22
msgid ""
"[Japanese](https://google.github.io/comprehensive-rust/ja/) by [@CoinEZ-JPN]"
"(https://github.com/CoinEZ) and [@momotaro1105](https://github.com/"
"momotaro1105)."
msgstr ""
"[Japonez캒](https://google.github.io/comprehensive-rust/ja/) de [@CoinEZ-JPN]"
"(https://github.com/CoinEZ) 탳i [@momotaro1105](https://github.com/"
"momotaro1105)."

#: src/running-the-course/translations.md:24
msgid ""
"If you want to help with this effort, please see [our instructions](https://"
"github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md) for how to "
"get going. Translations are coordinated on the [issue tracker](https://"
"github.com/google/comprehensive-rust/issues/282)."
msgstr ""
"Dac캒 dori탵i s캒 contribui탵i la acest efort, v캒 rug캒m s캒 consulta탵i "
"[instruc탵iunile noastre](https://github.com/google/comprehensive-rust/blob/"
"main/TRANSLATIONS.md) pentru a afla cum s캒 칥ncepe탵i. Traducerile sunt "
"coordonate pe [issue tracker](https://github.com/google/comprehensive-rust/"
"issues/282)."

#: src/cargo.md:3
msgid ""
"When you start reading about Rust, you will soon meet [Cargo](https://doc."
"rust-lang.org/cargo/), the standard tool used in the Rust ecosystem to build "
"and run Rust applications. Here we want to give a brief overview of what "
"Cargo is and how it fits into the wider ecosystem and how it fits into this "
"training."
msgstr ""
"C칙nd 칥ncepe탵i s캒 citi탵i despre Rust, ve탵i face cuno탳tin탵캒 cu [Cargo](https://"
"doc.rust-lang.org/cargo/), instrumentul standard utilizat 칥n ecosistemul "
"Rust pentru a construi 탳i rula aplica탵ii Rust. Aici dorim s캒 oferim o scurt캒 "
"prezentare general캒 a ceea ce este Cargo 탳i a modului 칥n care se integreaz캒 "
"칥n ecosistemul mai larg 탳i cum se 칥ncadreaz캒 칥n acest curs de formare."

#: src/cargo.md:8
msgid "Installation"
msgstr "Instalare"

#: src/cargo.md:10
msgid "**Please follow the instructions on <https://rustup.rs/>.**"
msgstr "**V캒 rug캒m s캒 urma탵i instruc탵iunile de pe <https://rustup.rs/>.**"

#: src/cargo.md:12
msgid ""
"This will give you the Cargo build tool (`cargo`) and the Rust compiler "
"(`rustc`). You will also get `rustup`, a command line utility that you can "
"use to install to different compiler versions."
msgstr ""
"Astfel ve탵i avea acces la instrumentul de compilare Cargo (`cargo`) 탳i "
"compilatorul Rust (`rustc`). De asemenea, ve탵i ob탵ine `rustup`, un utilitar "
"de linie de comand캒 pe care 칥l pute탵i utiliza pentru a instala la diferite "
"versiuni de compilator."

#: src/cargo.md:14
msgid ""
"After installing Rust, you should configure your editor or IDE to work with "
"Rust. Most editors do this by talking to [rust-analyzer](https://rust-"
"analyzer.github.io/), which provides auto-completion and jump-to-definition "
"functionality for [VS Code](https://code.visualstudio.com/), [Emacs](https://"
"rust-analyzer.github.io/manual.html#emacs), [Vim/Neovim](https://rust-"
"analyzer.github.io/manual.html#vimneovim), and many others. There is also a "
"different IDE available called [RustRover](https://www.jetbrains.com/rust/)."
msgstr ""
"Dup캒 instalarea Rust, trebuie s캒 v캒 configura탵i editorul sau IDE-ul pentru a "
"lucra cu Rust. Majoritatea editorilor fac acest lucru comunic칙nd cu [rust-"
"analyzer](https://rust-analyzer.github.io/), care ofer캒 func탵ionalitate de "
"autocompletare 탳i de salt la defini탵ie pentru [VS Code](https://code."
"visualstudio.com/), [Emacs](https://rust-analyzer.github.io/manual."
"html#emacs), [Vim/Neovim](https://rust-analyzer.github.io/manual."
"html#vimneovim) 탳i multe altele. Exist캒, de asemenea, un alt IDE disponibil, "
"numit [RustRover](https://www.jetbrains.com/rust/)."

#: src/cargo.md:18
msgid ""
"On Debian/Ubuntu, you can also install Cargo, the Rust source and the [Rust "
"formatter](https://github.com/rust-lang/rustfmt) via `apt`. However, this "
"gets you an outdated rust version and may lead to unexpected behavior. The "
"command would be:"
msgstr ""
"Pe Debian/Ubuntu, pute탵i instala, de asemenea, Cargo, sursele Rust 탳i "
"[instrumentul de formatare Rust](https://github.com/rust-lang/rustfmt) prin "
"`apt`. Dar ve탵i avea acces la o versiune Rust 칥nvechit캒 care poate duce la "
"un comportament nea탳teptat. Comanda ar fi:"

#: src/cargo/rust-ecosystem.md:1
msgid "The Rust Ecosystem"
msgstr "Ecosistemul Rust"

#: src/cargo/rust-ecosystem.md:3
msgid ""
"The Rust ecosystem consists of a number of tools, of which the main ones are:"
msgstr ""
"Ecosistemul Rust este format dintr-un num캒r de instrumente, dintre care "
"principalele sunt:"

#: src/cargo/rust-ecosystem.md:5
msgid ""
"`rustc`: the Rust compiler which turns `.rs` files into binaries and other "
"intermediate formats."
msgstr ""
"`rustc`: compilatorul Rust care transform캒 fi탳ierele `.rs` 칥n fi탳iere binare "
"탳i alte formate intermediare."

#: src/cargo/rust-ecosystem.md:8
msgid ""
"`cargo`: the Rust dependency manager and build tool. Cargo knows how to "
"download dependencies, usually hosted on <https://crates.io>, and it will "
"pass them to `rustc` when building your project. Cargo also comes with a "
"built-in test runner which is used to execute unit tests."
msgstr ""
"`cargo`: managerul de dependen탵e Rust 탳i instrumentul de construc탵ie. Cargo "
"탳tie cum s캒 descarce dependen탵ele, de obicei g캒zduite pe <https://crates."
"io>, 탳i le va transmite la `rustc` atunci c칙nd v캒 construi탵i proiectul. "
"Cargo vine, de asemenea, cu un instrument de rulat testele 칥ncorporat care "
"este folosit pentru a executa testele unitare."

#: src/cargo/rust-ecosystem.md:13
msgid ""
"`rustup`: the Rust toolchain installer and updater. This tool is used to "
"install and update `rustc` and `cargo` when new versions of Rust is "
"released. In addition, `rustup` can also download documentation for the "
"standard library. You can have multiple versions of Rust installed at once "
"and `rustup` will let you switch between them as needed."
msgstr ""
"`rustup`: programul de instalare 탳i actualizare a lan탵ului de instrumente "
"Rust. Acest instrument este utilizat pentru a instala 탳i actualiza `rustc` "
"탳i `cargo` atunci c칙nd sunt lansate noi versiuni de Rust. 칉n plus, `rustup` "
"poate desc캒rca 탳i documenta탵ia pentru biblioteca standard. Pute탵i avea mai "
"multe versiuni de Rust instalate 칥n acela탳i timp, iar `rustup` v캒 va permite "
"s캒 trece탵i de la una la alta 칥n func탵ie de necesit캒탵i."

#: src/cargo/rust-ecosystem.md:21 src/hello-world.md:25
#: src/hello-world/small-example.md:27 src/why-rust/runtime.md:10
#: src/why-rust/modern.md:21 src/basic-syntax/compound-types.md:32
#: src/basic-syntax/references.md:24
#: src/pattern-matching/destructuring-enums.md:35
#: src/ownership/double-free-modern-cpp.md:55
#: src/error-handling/try-operator.md:48
#: src/error-handling/converting-error-types-example.md:50
#: src/concurrency/threads.md:30 src/async/async-await.md:25
msgid "Key points:"
msgstr "Puncte-cheie:"

#: src/cargo/rust-ecosystem.md:23
msgid ""
"Rust has a rapid release schedule with a new release coming out every six "
"weeks. New releases maintain backwards compatibility with old releases --- "
"plus they enable new functionality."
msgstr ""
"Rust are un program de actualizare rapid캒, cu o nou캒 versiune la fiecare "
"탳ase s캒pt캒m칙ni. Noile versiuni men탵in compatibilitatea cu versiunile vechi "
"탳i adaug캒 noi func탵ionalit캒탵i."

#: src/cargo/rust-ecosystem.md:27
msgid ""
"There are three release channels: \"stable\", \"beta\", and \"nightly\"."
msgstr ""
"Exist캒 trei canale de actualizare: \"stable\", \"beta\" 탳i \"nightly\"."

#: src/cargo/rust-ecosystem.md:29
msgid ""
"New features are being tested on \"nightly\", \"beta\" is what becomes "
"\"stable\" every six weeks."
msgstr ""
"Noile caracteristici sunt testate pe \"nightly\", \"beta\" este ceea ce "
"devine \"stabil\" la fiecare 탳ase s캒pt캒m칙ni."

#: src/cargo/rust-ecosystem.md:32
msgid ""
"Dependencies can also be resolved from alternative [registries](https://doc."
"rust-lang.org/cargo/reference/registries.html), git, folders, and more."
msgstr ""
"De asemenea, dependen탵ele pot fi rezolvate din [registre](https://doc.rust-"
"lang.org/cargo/reference/registries.html) alternative, git, dosare 탳i altele."

#: src/cargo/rust-ecosystem.md:34
msgid ""
"Rust also has [editions](https://doc.rust-lang.org/edition-guide/): the "
"current edition is Rust 2021. Previous editions were Rust 2015 and Rust 2018."
msgstr ""
"Rust are, de asemenea, [edi탵ii](https://doc.rust-lang.org/edition-guide/): "
"edi탵ia curent캒 este Rust 2021. Edi탵iile anterioare au fost Rust 2015 탳i Rust "
"2018."

#: src/cargo/rust-ecosystem.md:37
msgid ""
"The editions are allowed to make backwards incompatible changes to the "
"language."
msgstr ""
"Noile edi탵iile au dreptul de a face modific캒ri ale limbajului incompatibile "
"cu versiuni mai vechi."

#: src/cargo/rust-ecosystem.md:40
msgid ""
"To prevent breaking code, editions are opt-in: you select the edition for "
"your crate via the `Cargo.toml` file."
msgstr ""
"Pentru a preveni stricarea codului, edi탵iile sunt op탵ionale: selecta탵i "
"edi탵ia pentru crate-ul dumneavoastr캒 prin intermediul fi탳ierului `Cargo."
"toml`."

#: src/cargo/rust-ecosystem.md:43
msgid ""
"To avoid splitting the ecosystem, Rust compilers can mix code written for "
"different editions."
msgstr ""
"Pentru a evita divizarea ecosistemului, compilatoarele Rust pot amesteca "
"coduri scrise pentru edi탵ii diferite."

#: src/cargo/rust-ecosystem.md:46
msgid ""
"Mention that it is quite rare to ever use the compiler directly not through "
"`cargo` (most users never do)."
msgstr ""
"Men탵ion캒m c캒 este destul de rar s캒 folosi탵i compilatorul direct 탳i nu prin "
"`cargo` (majoritatea utilizatorilor nu o fac niciodat캒)."

#: src/cargo/rust-ecosystem.md:48
msgid ""
"It might be worth alluding that Cargo itself is an extremely powerful and "
"comprehensive tool.  It is capable of many advanced features including but "
"not limited to: "
msgstr ""
"Este util s캒 men탵ion캒m c캒 Cargo 칥n sine este un instrument extrem de "
"puternic 탳i cuprinz캒tor.  Acesta are multe caracteristici avansate, "
"incluz칙nd: "

#: src/cargo/rust-ecosystem.md:49
msgid "Project/package structure"
msgstr "Structura proiectului/pachetului"

#: src/cargo/rust-ecosystem.md:50
msgid "[workspaces](https://doc.rust-lang.org/cargo/reference/workspaces.html)"
msgstr ""
"[spa탵ii de lucru](https://doc.rust-lang.org/cargo/reference/workspaces.html)"

#: src/cargo/rust-ecosystem.md:51
msgid "Dev Dependencies and Runtime Dependency management/caching"
msgstr ""
"Gestionarea/arhivarea dependen탵elor de dezvoltare 탳i a dependen탵elor de timp "
"de execu탵ie"

#: src/cargo/rust-ecosystem.md:52
msgid ""
"[build scripting](https://doc.rust-lang.org/cargo/reference/build-scripts."
"html)"
msgstr ""
"[scripturile de build](https://doc.rust-lang.org/cargo/reference/build-"
"scripts.html)"

#: src/cargo/rust-ecosystem.md:53
msgid ""
"[global installation](https://doc.rust-lang.org/cargo/commands/cargo-install."
"html)"
msgstr ""
"[instalarea global캒](https://doc.rust-lang.org/cargo/commands/cargo-install."
"html)"

#: src/cargo/rust-ecosystem.md:54
msgid ""
"It is also extensible with sub command plugins as well (such as [cargo "
"clippy](https://github.com/rust-lang/rust-clippy))."
msgstr ""
"Este, de asemenea, extensibil cu pluginuri de subcomand캒 (cum ar fi [cargo "
"clippy](https://github.com/rust-lang/rust-clippy))."

#: src/cargo/rust-ecosystem.md:55
msgid ""
"Read more from the [official Cargo Book](https://doc.rust-lang.org/cargo/)"
msgstr ""
"Citi탵i mai multe din [cartea oficial캒 Cargo](https://doc.rust-lang.org/"
"cargo/)"

#: src/cargo/code-samples.md:1
msgid "Code Samples in This Training"
msgstr "Exemple de cod 칥n aceast curs"

#: src/cargo/code-samples.md:3
msgid ""
"For this training, we will mostly explore the Rust language through examples "
"which can be executed through your browser. This makes the setup much easier "
"and ensures a consistent experience for everyone."
msgstr ""
"칉n cadrul acestui curs, vom explora limbajul Rust 칥n principal prin exemple "
"care pot fi executate prin intermediul browserului dumneavoastr캒. Acest "
"lucru face configurarea mult mai u탳oar캒 탳i asigur캒 o experien탵캒 coerent캒 "
"pentru toat캒 lumea."

#: src/cargo/code-samples.md:7
msgid ""
"Installing Cargo is still encouraged: it will make it easier for you to do "
"the exercises. On the last day, we will do a larger exercise which shows you "
"how to work with dependencies and for that you need Cargo."
msgstr ""
"Instalarea Cargo este 칥n continuare 칥ncurajat캒: v캒 va fi mai u탳or s캒 face탵i "
"exerci탵iile. 칉n ultima zi, vom face un exerci탵iu mai amplu care v캒 va ar캒ta "
"cum s캒 lucra탵i cu dependen탵ele 탳i pentru care ave탵i nevoie de Cargo."

#: src/cargo/code-samples.md:11
msgid "The code blocks in this course are fully interactive:"
msgstr "Blocurile de cod din acest curs sunt complet interactive:"

#: src/cargo/code-samples.md:13
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"Edit me!\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    println!(\"Editeaz캒-m캒!\");\n"
"}\n"
"```"

#: src/cargo/code-samples.md:19
msgid "You can use "
msgstr "Pute탵i utiliza "

#: src/cargo/code-samples.md:19
msgid " to execute the code when focus is in the text box."
msgstr " pentru a executa codul atunci c칙nd focusul se afl캒 칥n caseta de text."

#: src/cargo/code-samples.md:24
msgid ""
"Most code samples are editable like shown above. A few code samples are not "
"editable for various reasons:"
msgstr ""
"Majoritatea mostrelor de cod sunt editabile, a탳a cum se arat캒 mai sus. "
"C칙teva mostre de cod nu sunt editabile din diverse motive:"

#: src/cargo/code-samples.md:27
msgid ""
"The embedded playgrounds cannot execute unit tests. Copy-paste the code and "
"open it in the real Playground to demonstrate unit tests."
msgstr ""
"Zonele de 칥ncercare 칥ncorporate nu pot executa teste unitare. Copia탵i 탳i "
"lipi탵i codul 탳i deschide탵i-l 칥n locul de zona de lucru local캒 pentru a "
"demonstra testele unitare."

#: src/cargo/code-samples.md:30
msgid ""
"The embedded playgrounds lose their state the moment you navigate away from "
"the page! This is the reason that the students should solve the exercises "
"using a local Rust installation or via the Playground."
msgstr ""
"Zonele de 칥ncercare 칥ncorporate 칥탳i pierd starea 칥n momentul 칥n care "
"naviga탵i 칥n afara paginii! Acesta este motivul pentru care elevii trebuie s캒 "
"rezolve exerci탵iile folosind o instalare local캒 de Rust sau prin intermediul "
"zonei de 칥ncercare."

#: src/cargo/running-locally.md:1
msgid "Running Code Locally with Cargo"
msgstr "Rularea codului la nivel local cu Cargo"

#: src/cargo/running-locally.md:3
msgid ""
"If you want to experiment with the code on your own system, then you will "
"need to first install Rust. Do this by following the [instructions in the "
"Rust Book](https://doc.rust-lang.org/book/ch01-01-installation.html). This "
"should give you a working `rustc` and `cargo`. At the time of writing, the "
"latest stable Rust release has these version numbers:"
msgstr ""
"Dac캒 dori탵i s캒 experimenta탵i cu codul pe propriul sistem, va trebui s캒 "
"instala탵i mai 칥nt칙i Rust. Face탵i acest lucru urm칙nd [instruc탵iunile din "
"Cartea Rust](https://doc.rust-lang.org/book/ch01-01-installation.html). Ve탵i "
"avea astfel un `rustc` 탳i un `cargo` func탵ional. La momentul scrierii "
"acestui articol, cea mai recent캒 versiune stabil캒 Rust are versiunea:"

#: src/cargo/running-locally.md:15
msgid ""
"You can use any later version too since Rust maintains backwards "
"compatibility."
msgstr ""
"Pute탵i utiliza 탳i orice versiune ulterioar캒, deoarece Rust p캒streaz캒 "
"compatibilitatea cu versiunile anterioare."

#: src/cargo/running-locally.md:17
msgid ""
"With this in place, follow these steps to build a Rust binary from one of "
"the examples in this training:"
msgstr ""
"Ulterior urma탵i ace탳ti pa탳i pentru a construi un binar Rust din unul dintre "
"exemplele din acest curs de instruire:"

#: src/cargo/running-locally.md:20
msgid "Click the \"Copy to clipboard\" button on the example you want to copy."
msgstr ""
"Ap캒sa탵i pe butonul \"Copy to clipboard\" (Copiere 칥n clipboard) al "
"exemplului pe care dori탵i s캒 칥l copia탵i."

#: src/cargo/running-locally.md:22
msgid ""
"Use `cargo new exercise` to create a new `exercise/` directory for your code:"
msgstr ""
"Utiliza탵i `cargo new exercise` pentru a crea un nou director `exercise/` "
"pentru codul dumneavoastr캒:"

#: src/cargo/running-locally.md:29
msgid ""
"Navigate into `exercise/` and use `cargo run` to build and run your binary:"
msgstr ""
"Naviga탵i 칥n `exercise/` 탳i folosi탵i `cargo run` pentru a construi 탳i rula "
"binarul dumneavoastr캒:"

#: src/cargo/running-locally.md:40
msgid ""
"Replace the boiler-plate code in `src/main.rs` with your own code. For "
"example, using the example on the previous page, make `src/main.rs` look like"
msgstr ""
"칉nlocui탵i codul generic din `src/main.rs` cu propriul cod. De exemplu, "
"folosind exemplul de pe pagina anterioar캒, face탵i`src/main.rs` s캒 arate "
"astfel"

#: src/cargo/running-locally.md:43
msgid ""
"```rust\n"
"fn main() {\n"
"    println!(\"Edit me!\");\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    println!(\"Editeaz캒-m캒!\");\n"
"}\n"
"```"

#: src/cargo/running-locally.md:49
msgid "Use `cargo run` to build and run your updated binary:"
msgstr "Utiliza탵i `cargo run` pentru a construi 탳i rula binarul actualizat:"

#: src/cargo/running-locally.md:59
msgid ""
"Use `cargo check` to quickly check your project for errors, use `cargo "
"build` to compile it without running it. You will find the output in `target/"
"debug/` for a normal debug build. Use `cargo build --release` to produce an "
"optimized release build in `target/release/`."
msgstr ""
"Folosi탵i `cargo check` pentru a verifica rapid dac캒 proiectul dumneavoastr캒 "
"are erori, folosi탵i `cargo build` pentru a-l compila f캒r캒 a-l rula. Ve탵i "
"g캒si rezultatul 칥n `target/debug/` pentru o compilare normal캒 de depanare. "
"Folosi탵i `cargo build --release` pentru a produce o compilare optimizat캒 de "
"lansare 칥n `target/release/`."

#: src/cargo/running-locally.md:64
msgid ""
"You can add dependencies for your project by editing `Cargo.toml`. When you "
"run `cargo` commands, it will automatically download and compile missing "
"dependencies for you."
msgstr ""
"Pute탵i ad캒uga dependen탵e pentru proiectul dumneavoastr캒 prin editarea `Cargo."
"toml`. C칙nd executa탵i comenzile `cargo`, acesta va desc캒rca 탳i compila "
"automat dependen탵ele lips캒 pentru dumneavoastr캒."

#: src/cargo/running-locally.md:72
msgid ""
"Try to encourage the class participants to install Cargo and use a local "
"editor. It will make their life easier since they will have a normal "
"development environment."
msgstr ""
"칉ncerca탵i s캒 칥ncuraja탵i participan탵ii la curs s캒 instaleze Cargo 탳i s캒 "
"utilizeze un editor local. Acest lucru le va face via탵a mai u탳oar캒, deoarece "
"vor avea un mediu de dezvoltare normal."

#: src/welcome-day-1.md:1
msgid "Welcome to Day 1"
msgstr "Bine a탵i venit la Ziua 1"

#: src/welcome-day-1.md:3
msgid ""
"This is the first day of Rust Fundamentals. We will cover a lot of ground "
"today:"
msgstr ""
"Aceasta este prima zi a cursului Rust Fundamentals. Vom acoperi o mul탵ime de "
"subiecte ast캒zi:"

#: src/welcome-day-1.md:6
msgid ""
"Basic Rust syntax: variables, scalar and compound types, enums, structs, "
"references, functions, and methods."
msgstr ""
"Sintaxa de baz캒 Rust: variabile, tipuri scalare 탳i compuse, enumera탵ii, "
"structuri, referin탵e, func탵ii 탳i metode."

#: src/welcome-day-1.md:9
msgid ""
"Control flow constructs: `if`, `if let`, `while`, `while let`, `break`, and "
"`continue`."
msgstr ""
"Construc탵ii ale fluxului de control: `if`, `if let`, `while`, `while let`, "
"`break` 탳i `continue`."

#: src/welcome-day-1.md:12
msgid "Pattern matching: destructuring enums, structs, and arrays."
msgstr ""
"G캒sirea de tipare: destructurarea enumera탵iilor, structurilor 탳i a "
"tablourilor."

#: src/welcome-day-1.md:16
msgid "Please remind the students that:"
msgstr "V캒 rug캒m s캒 le reaminti탵i cursan탵ilor c캒:"

#: src/welcome-day-1.md:18
msgid ""
"They should ask questions when they get them, don't save them to the end."
msgstr ""
"Ar trebui s캒 pun캒 칥ntreb캒ri atunci c칙nd le primesc, nu s캒 le lase pentru "
"final."

#: src/welcome-day-1.md:19
msgid ""
"The class is meant to be interactive and discussions are very much "
"encouraged!"
msgstr ""
"Clasa se dore탳te a fi interactiv캒, iar discu탵iile sunt foarte 칥ncurajate!"

#: src/welcome-day-1.md:20
msgid ""
"As an instructor, you should try to keep the discussions relevant, i.e., "
"keep the discussions related to how Rust does things vs some other "
"language.  It can be hard to find the right balance, but err on the side of "
"allowing  discussions since they engage people much more than one-way "
"communication."
msgstr ""
"칉n calitate de instructor, ar trebui s캒 칥ncerca탵i s캒 p캒stra탵i discu탵iile "
"relevante, adic캒 s캒 p캒stra탵i discu탵iile legate de modul 칥n care Rust face "
"lucrurile 칥n compara탵ie cu un alt limbaj.  Poate fi greu s캒 g캒si탵i "
"echilibrul potrivit, dar e de preferat s캒 permite탵i discu탵iile, deoarece "
"acestea antreneaz캒 oamenii mult mai mult dec칙t comunicarea unidirec탵ional캒."

#: src/welcome-day-1.md:24
msgid ""
"The questions will likely mean that we talk about things ahead of the slides."
msgstr ""
"칉ntreb캒rile vor 칥nsemna probabil c캒 vom vorbi despre lucruri 칥nainte de "
"prezentarea slide-urilor."

#: src/welcome-day-1.md:25
msgid ""
"This is perfectly okay! Repetition is an important part of learning. "
"Remember that the slides are just a support and you are free to skip them as "
"you like."
msgstr ""
"Acest lucru este perfect 칥n regul캒! Repeti탵ia este o parte important캒 a "
"칥nv캒탵캒rii. Nu uita탵i c캒 diapozitivele sunt doar un suport 탳i c캒 sunte탵i "
"liberi s캒 le s캒ri탵i dup캒 cum dori탵i."

#: src/welcome-day-1.md:29
msgid ""
"The idea for the first day is to show _just enough_ of Rust to be able to "
"speak about the famous borrow checker. The way Rust handles memory is a "
"major feature and we should show students this right away."
msgstr ""
"Ideea pentru prima zi este de a ar캒ta _suficient_ din Rust pentru a putea "
"vorbi despre celebrul verificator de 칥mprumuturi (borrow checker). Modul 칥n "
"care Rust gestioneaz캒 memoria este o caracteristic캒 major캒 탳i ar trebui s캒 "
"le ar캒t캒m studen탵ilor acest lucru imediat."

#: src/welcome-day-1.md:33
msgid ""
"If you're teaching this in a classroom, this is a good place to go over the "
"schedule. We suggest splitting the day into two parts (following the slides):"
msgstr ""
"Dac캒 preda탵i acest curs 칥n clas캒, acum este un moment bun pentru a trece 칥n "
"revist캒 programul. V캒 suger캒m s캒 칥mp캒r탵i탵i ziua astfel (urm칙nd slide-urile):"

#: src/welcome-day-1.md:36
msgid "Morning: 9:00 to 12:00,"
msgstr "Diminea탵a: de la 9:00 la 12:00,"

#: src/welcome-day-1.md:37
msgid "Afternoon: 13:00 to 16:00."
msgstr "Dup캒-amiaz캒: de la 13:00 la 16:00."

#: src/welcome-day-1.md:39
msgid ""
"You can of course adjust this as necessary. Please make sure to include "
"breaks, we recommend a break every hour!"
msgstr ""
"Desigur, pute탵i ajusta acest lucru dup캒 cum este necesar. V캒 rug캒m s캒 v캒 "
"asigura탵i c캒 include탵i pauze, recomand캒m o pauz캒 la fiecare or캒!"

#: src/welcome-day-1/what-is-rust.md:3
msgid ""
"Rust is a new programming language which had its [1.0 release in 2015]"
"(https://blog.rust-lang.org/2015/05/15/Rust-1.0.html):"
msgstr ""
"Rust este un nou limbaj de programare care a avut [versiunea 1.0 칥n 2015]"
"(https://blog.rust-lang.org/2015/05/15/Rust-1.0.html):"

#: src/welcome-day-1/what-is-rust.md:5
msgid "Rust is a statically compiled language in a similar role as C++"
msgstr "Rust este un limbaj compilat static, cu un rol similar cu C++"

#: src/welcome-day-1/what-is-rust.md:6
msgid "`rustc` uses LLVM as its backend."
msgstr "`rustc` folose탳te LLVM ca backend."

#: src/welcome-day-1/what-is-rust.md:7
msgid ""
"Rust supports many [platforms and architectures](https://doc.rust-lang.org/"
"nightly/rustc/platform-support.html):"
msgstr ""
"Rust suport캒 multe [platforme 탳i arhitecturi](https://doc.rust-lang.org/"
"nightly/rustc/platform-support.html):"

#: src/welcome-day-1/what-is-rust.md:9
msgid "x86, ARM, WebAssembly, ..."
msgstr "x86, ARM, WebAssembly, ..."

#: src/welcome-day-1/what-is-rust.md:10
msgid "Linux, Mac, Windows, ..."
msgstr "Linux, Mac, Windows, ..."

#: src/welcome-day-1/what-is-rust.md:11
msgid "Rust is used for a wide range of devices:"
msgstr "Rust este utilizat pentru o gam캒 larg캒 de dispozitive:"

#: src/welcome-day-1/what-is-rust.md:12
msgid "firmware and boot loaders,"
msgstr "firmware 탳i boot leaders,"

#: src/welcome-day-1/what-is-rust.md:13
msgid "smart displays,"
msgstr "ecrane inteligente,"

#: src/welcome-day-1/what-is-rust.md:14
msgid "mobile phones,"
msgstr "telefoane mobile,"

#: src/welcome-day-1/what-is-rust.md:15
msgid "desktops,"
msgstr "desktop-uri,"

#: src/welcome-day-1/what-is-rust.md:16
msgid "servers."
msgstr "servere."

#: src/welcome-day-1/what-is-rust.md:21
msgid "Rust fits in the same area as C++:"
msgstr "Rust se 칥ncadreaz캒 칥n aceea탳i zon캒 ca 탳i C++:"

#: src/welcome-day-1/what-is-rust.md:23
msgid "High flexibility."
msgstr "Flexibilitate ridicat캒."

#: src/welcome-day-1/what-is-rust.md:24
msgid "High level of control."
msgstr "Nivel ridicat de control."

#: src/welcome-day-1/what-is-rust.md:25
msgid ""
"Can be scaled down to very constrained devices such as microcontrollers."
msgstr ""
"Poate fi redus pentru a rula pe dispozitive foarte limitate, cum ar fi "
"microcontrolerele."

#: src/welcome-day-1/what-is-rust.md:26
msgid "Has no runtime or garbage collection."
msgstr "Nu are nevoie de mediu de execu탵ie 탳i nici de colectare de gunoi."

#: src/welcome-day-1/what-is-rust.md:27
msgid "Focuses on reliability and safety without sacrificing performance."
msgstr ""
"Se concentreaz캒 pe fiabilitate 탳i siguran탵캒 f캒r캒 a sacrifica performan탵a."

#: src/hello-world.md:3
msgid ""
"Let us jump into the simplest possible Rust program, a classic Hello World "
"program:"
msgstr ""
"S캒 trecem la cel mai simplu program Rust posibil, un program clasic Bun캒 "
"Lume:"

#: src/hello-world.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"Hello 游깴!\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    println!(\"Bun캒 游깴!\");\n"
"}\n"
"```"

#: src/hello-world.md:12
msgid "What you see:"
msgstr "Ce vede탵i:"

#: src/hello-world.md:14
msgid "Functions are introduced with `fn`."
msgstr "Func탵iile sunt introduse cu `fn`."

#: src/hello-world.md:15
msgid "Blocks are delimited by curly braces like in C and C++."
msgstr "Blocurile sunt delimitate prin paranteze curbe, ca 칥n C 탳i C++."

#: src/hello-world.md:16
msgid "The `main` function is the entry point of the program."
msgstr "Func탵ia `main` este punctul de intrare al programului."

#: src/hello-world.md:17
msgid "Rust has hygienic macros, `println!` is an example of this."
msgstr "Rust are macro-uri igienice, `println!` este un exemplu 칥n acest sens."

#: src/hello-world.md:18
msgid "Rust strings are UTF-8 encoded and can contain any Unicode character."
msgstr ""
"탲irurile de caractere Rust sunt codificate UTF-8 탳i pot con탵ine orice "
"caracter Unicode."

#: src/hello-world.md:22
msgid ""
"This slide tries to make the students comfortable with Rust code. They will "
"see a ton of it over the next three days so we start small with something "
"familiar."
msgstr ""
"Acest diapozitiv 칥ncearc캒 s캒 칥i fac캒 pe cursan탵i s캒 se simt캒 confortabil cu "
"codul Rust. Ei vor vedea o mul탵ime de astfel de fi탳iere 칥n urm캒toarele trei "
"zile, a탳a c캒 vom 칥ncepe cu ceva familiar."

#: src/hello-world.md:27
msgid ""
"Rust is very much like other languages in the C/C++/Java tradition. It is "
"imperative and it doesn't try to reinvent things unless absolutely necessary."
msgstr ""
"Rust se aseam캒n캒 foarte mult cu alte limbaje de genul C/C++/Java. Este "
"imperativ 탳i nu 칥ncearc캒 s캒 reinventeze lucrurile dec칙t dac캒 este absolut "
"necesar."

#: src/hello-world.md:31
msgid "Rust is modern with full support for things like Unicode."
msgstr "Rust este modern, cu suport complet pentru lucruri precum Unicode."

#: src/hello-world.md:33
msgid ""
"Rust uses macros for situations where you want to have a variable number of "
"arguments (no function [overloading](basic-syntax/functions-interlude.md))."
msgstr ""
"Rust folose탳te macrocomenzi pentru situa탵iile 칥n care dori탵i s캒 ave탵i un "
"num캒r variabil de argumente (f캒r캒 [supra칥nc캒rcare](basic-syntax/functions-"
"interlude.md) de func탵ii )."

#: src/hello-world.md:36
msgid ""
"Macros being 'hygienic' means they don't accidentally capture identifiers "
"from the scope they are used in. Rust macros are actually only [partially "
"hygienic](https://veykril.github.io/tlborm/decl-macros/minutiae/hygiene."
"html)."
msgstr ""
"Fiind \"igienice\", macrourile 칥nseamn캒 c캒 nu capteaz캒 accidental "
"identificatori din domeniul de aplicare 칥n care sunt utilizate. Macro-urile "
"Rust sunt de fapt doar [par탵ial igienice](https://veykril.github.io/tlborm/"
"decl-macros/minutiae/hygiene.html)."

#: src/hello-world.md:40
msgid ""
"Rust is multi-paradigm. For example, it has powerful [object-oriented "
"programming features](https://doc.rust-lang.org/book/ch17-00-oop.html), and, "
"while it is not a functional language, it includes a range of [functional "
"concepts](https://doc.rust-lang.org/book/ch13-00-functional-features.html)."
msgstr ""
"Rust este multi-paradigm캒. De exemplu, are [caracteristici puternice de "
"programare orientat캒 pe obiecte](https://doc.rust-lang.org/book/ch17-00-oop."
"html) 탳i, de탳i nu este un limbaj func탵ional, include o serie de [concepte "
"func탵ionale](https://doc.rust-lang.org/book/ch13-00-functional-features."
"html)."

#: src/hello-world/small-example.md:3
msgid "Here is a small example program in Rust:"
msgstr "Iat캒 un mic exemplu de program 칥n Rust:"

#: src/hello-world/small-example.md:5
msgid ""
"```rust,editable\n"
"fn main() {              // Program entry point\n"
"    let mut x: i32 = 6;  // Mutable variable binding\n"
"    print!(\"{x}\");       // Macro for printing, like printf\n"
"    while x != 1 {       // No parenthesis around expression\n"
"        if x % 2 == 0 {  // Math like in other languages\n"
"            x = x / 2;\n"
"        } else {\n"
"            x = 3 * x + 1;\n"
"        }\n"
"        print!(\" -> {x}\");\n"
"    }\n"
"    println!();\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() { // Punct de intrare 칥n program\n"
"    let mut x: i32 = 6; // Declararea variabilelor mutabile\n"
"    print!(\"{x}\"); // Macro pentru imprimare, ca printf\n"
"    while x != 1 { // F캒r캒 paranteze 칥n jurul expresiei\n"
"        if x % 2 == 0 { // Matematic캒 ca 칥n alte limbaje\n"
"            x = x / 2;\n"
"        } else {\n"
"            x = 3 * x + 1;\n"
"        }\n"
"        print!(\" -> {x}\");\n"
"    }\n"
"    println!();\n"
"}\n"
"```"

#: src/hello-world/small-example.md:23
msgid ""
"The code implements the Collatz conjecture: it is believed that the loop "
"will always end, but this is not yet proved. Edit the code and play with "
"different inputs."
msgstr ""
"Codul implementeaz캒 conjectura lui Collatz: se crede c캒 bucla se va termina "
"칥ntotdeauna, dar acest lucru nu este 칥nc캒 dovedit. Modifica탵i codul 탳i "
"juca탵i-v캒 cu diferite intr캒ri."

#: src/hello-world/small-example.md:29
msgid ""
"Explain that all variables are statically typed. Try removing `i32` to "
"trigger type inference. Try with `i8` instead and trigger a runtime integer "
"overflow."
msgstr ""
"Explica탵i c캒 toate variabilele sunt tipizate static. 칉ncerca탵i s캒 elimina탵i "
"`i32` pentru a declan탳a inferen탵a de tip. 칉ncerca탵i cu `i8` 탳i declan탳a탵i o "
"dep캒탳ire de num캒r 칥ntreg 칥n timpul execu탵iei."

#: src/hello-world/small-example.md:32
msgid "Change `let mut x` to `let x`, discuss the compiler error."
msgstr ""
"Schimba탵i `let mut x` 칥n `let x`, discuta탵i despre eroarea de compilare."

#: src/hello-world/small-example.md:34
msgid ""
"Show how `print!` gives a compilation error if the arguments don't match the "
"format string."
msgstr ""
"Ar캒ta탵i cum `print!` d캒 o eroare de compilare dac캒 argumentele nu se "
"potrivesc cu 탳irul de format."

#: src/hello-world/small-example.md:37
msgid ""
"Show how you need to use `{}` as a placeholder if you want to print an "
"expression which is more complex than just a single variable."
msgstr ""
"Ar캒ta탵i cum trebuie s캒 folosi탵i `{}` ca un spa탵iu liber dac캒 dori탵i s캒 "
"imprima탵i o expresie care este mai complex캒 dec칙t o singur캒 variabil캒."

#: src/hello-world/small-example.md:40
msgid ""
"Show the students the standard library, show them how to search for `std::"
"fmt` which has the rules of the formatting mini-language. It's important "
"that the students become familiar with searching in the standard library."
msgstr ""
"Ar캒ta탵i-le studen탵ilor biblioteca standard, ar캒ta탵i-le cum s캒 caute `std::"
"fmt`, care con탵ine regulile mini-limbaje de formatare. Este important ca "
"elevii s캒 se familiarizeze cu c캒utarea 칥n biblioteca standard."

#: src/hello-world/small-example.md:44
msgid ""
"In a shell `rustup doc std::fmt` will open a browser on the local std::fmt "
"documentation"
msgstr ""
"칉ntr-un terminal `rustup doc std::fmt` va deschide un browser pentru "
"documenta탵ia local캒 std::fmt"

#: src/why-rust.md:3
msgid "Some unique selling points of Rust:"
msgstr "C칙teva caracteristici ale Rust:"

#: src/why-rust.md:5
msgid "Compile time memory safety."
msgstr "Ofer캒 siguran탵a memoriei 칥n timpul de compilare."

#: src/why-rust.md:6
msgid "Lack of undefined runtime behavior."
msgstr "Nu exist캒 comportament nedefinit 칥n timpul execu탵iei."

#: src/why-rust.md:7
msgid "Modern language features."
msgstr "Are caracteristici de limbaj moderne."

#: src/why-rust.md:11
msgid ""
"Make sure to ask the class which languages they have experience with. "
"Depending on the answer you can highlight different features of Rust:"
msgstr ""
"Nu uita탵i s캒 칥ntreba탵i elevii din clas캒 cu ce limbaje au experien탵캒. 칉n "
"func탵ie de r캒spuns, pute탵i eviden탵ia diferite caracteristici ale Rust:"

#: src/why-rust.md:14
msgid ""
"Experience with C or C++: Rust eliminates a whole class of _runtime errors_ "
"via the borrow checker. You get performance like in C and C++, but you don't "
"have the memory unsafety issues. In addition, you get a modern language with "
"constructs like pattern matching and built-in dependency management."
msgstr ""
"Experien탵캒 cu C sau C++: Rust elimin캒 o 칥ntreag캒 clas캒 de erori de execu탵ie "
"prin intermediul verificatorului de 칥mprumuturi. Ob탵ine탵i performan탵e ca 칥n "
"C 탳i C++, dar nu ave탵i probleme de nesiguran탵캒 a memoriei. 칉n plus, ob탵ine탵i "
"un limbaj modern, cu construc탵ii precum 탳abloane de potrivire 탳i gestionarea "
"integrat캒 a dependen탵elor."

#: src/why-rust.md:19
msgid ""
"Experience with Java, Go, Python, JavaScript...: You get the same memory "
"safety as in those languages, plus a similar high-level language feeling. In "
"addition you get fast and predictable performance like C and C++ (no garbage "
"collector) as well as access to low-level hardware (should you need it)"
msgstr ""
"Experien탵캒 cu Java, Go, Python, JavaScript...: Ob탵ine탵i aceea탳i siguran탵캒 a "
"memoriei ca 칥n aceste limbaje, plus o senza탵ie similar캒 de limbaj de nivel "
"칥nalt. 칉n plus, ob탵ine탵i performan탵e rapide 탳i previzibile ca 칥n C 탳i C++ "
"(f캒r캒 colector de memorie), precum 탳i acces la hardware de nivel sc캒zut "
"(dac캒 ave탵i nevoie)"

#: src/why-rust/an-example-in-c.md:4
msgid "Let's consider the following \"minimum wrong example\" program in C:"
msgstr ""
"S캒 lu캒m 칥n considerare urm캒torul exemplu de 랋rogram minimal gre탳it 칥n C:"

#: src/why-rust/an-example-in-c.md:6
#, fuzzy
msgid ""
"```c,editable\n"
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <sys/stat.h>\n"
"\n"
"int main(int argc, char* argv[]) {\n"
"\tchar *buf, *filename;\n"
"\tFILE *fp;\n"
"\tsize_t bytes, len;\n"
"\tstruct stat st;\n"
"\n"
"\tswitch (argc) {\n"
"\t\tcase 1:\n"
"\t\t\tprintf(\"Too few arguments!\\n\");\n"
"\t\t\treturn 1;\n"
"\n"
"\t\tcase 2:\n"
"\t\t\tfilename = argv[argc];\n"
"\t\t\tstat(filename, &st);\n"
"\t\t\tlen = st.st_size;\n"
"\t\t\t\n"
"\t\t\tbuf = (char*)malloc(len);\n"
"\t\t\tif (!buf)\n"
"\t\t\t\tprintf(\"malloc failed!\\n\", len);\n"
"\t\t\t\treturn 1;\n"
"\n"
"\t\t\tfp = fopen(filename, \"rb\");\n"
"\t\t\tbytes = fread(buf, 1, len, fp);\n"
"\t\t\tif (bytes = st.st_size)\n"
"\t\t\t\tprintf(\"%s\", buf);\n"
"\t\t\telse\n"
"\t\t\t\tprintf(\"fread failed!\\n\");\n"
"\n"
"\t\tcase 3:\n"
"\t\t\tprintf(\"Too many arguments!\\n\");\n"
"\t\t\treturn 1;\n"
"\t}\n"
"\n"
"\treturn 0;\n"
"}\n"
"```"
msgstr ""
"```c,editabil\n"
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <sys/stat.h>\n"
"\n"
"int main(int argc, char* argv[]) {\n"
"\tchar *buf, *filename;\n"
"\tFILE *fp;\n"
"\tsize_t bytes, len;\n"
"\tstruct stat st;\n"
"\n"
"\tswitch (argc) {\n"
"\t\tcase 1:\n"
"\t\t\tprintf(\"Prea pu탵ine argumente!\\n\");\n"
"\t\t\treturn 1;\n"
"\n"
"\t\tcase 2:\n"
"\t\t\tfilename = argv[argc];\n"
"\t\t\tstat(filename, &st);\n"
"\t\t\tlen = st.st_size;\n"
"\t\t\t\n"
"\t\t\tbuf = (char*)malloc(len);\n"
"\t\t\tif (!buf)\n"
"\t\t\t\tprintf(랈alloc a e탳uat!\\n len);\n"
"\t\t\t\treturn 1;\n"
"\n"
"\t\t\tfp = fopen(filename, \"rb\");\n"
"\t\t\tbytes = fread(buf, 1, len, fp);\n"
"\t\t\tif (bytes = st.st_size)\n"
"\t\t\t\tprintf(\"%s\", buf);\n"
"\t\t\telse\n"
"\t\t\t\tprintf(랁read a e탳uat!\\n);\n"
"\n"
"\t\tcase 3:\n"
"\t\t\tprintf(\"Prea multe argumente!\\n\");\n"
"\t\t\treturn 1;\n"
"\t}\n"
"\n"
"\treturn 0;\n"
"}\n"
"```"

#: src/why-rust/an-example-in-c.md:48
msgid "How many bugs do you spot?"
msgstr "C칙te defecte g캒se탳ti?"

#: src/why-rust/an-example-in-c.md:52
msgid ""
"Despite just 29 lines of code, this C example contains serious bugs in at "
"least 11:"
msgstr ""
"칉n ciuda celor doar 29 de linii de cod, acest exemplu C con탵ine erori grave "
"칥n cel pu탵in 11 dintre ele:"

#: src/why-rust/an-example-in-c.md:54
msgid "Assignment `=` instead of equality comparison `==` (line 28)"
msgstr "Atribuirea `=` 칥n locul compara탵iei de egalitate `==` (linia 28)"

#: src/why-rust/an-example-in-c.md:55
msgid "Excess argument to `printf` (line 23)"
msgstr "Argument 칥n exces pentru `printf` (linia 23)"

#: src/why-rust/an-example-in-c.md:56
msgid "File descriptor leak (after line 26)"
msgstr "Scurgere de descriptor de fi탳ier (dup캒 linia 26)"

#: src/why-rust/an-example-in-c.md:57
msgid "Forgotten braces in multi-line `if` (line 22)"
msgstr "Paranteze uitate 칥n `if` pe mai multe linii (linia 22)"

#: src/why-rust/an-example-in-c.md:58
msgid "Forgotten `break` in a `switch` statement (line 32)"
msgstr "`break` uitat 칥ntr-o instruc탵iune `switch` (linia 32)"

#: src/why-rust/an-example-in-c.md:59
msgid ""
"Forgotten NUL-termination of the `buf` string, leading to a buffer overflow "
"(line 29)"
msgstr ""
"Terminatorul de NUL uitat a 탳irului `buf`, ceea ce duce la o dep캒탳ire de "
"buffer (linia 29)"

#: src/why-rust/an-example-in-c.md:60
msgid "Memory leak by not freeing the `malloc`\\-allocated buffer (line 21)"
msgstr ""
"Scurgere de memorie prin neeliberarea bufferului `malloc` alocat (linia 21)"

#: src/why-rust/an-example-in-c.md:61
msgid "Out-of-bounds access (line 17)"
msgstr "Acces 칥n afara limitelor (linia 17)"

#: src/why-rust/an-example-in-c.md:62
msgid "Unchecked cases in the `switch` statement (line 11)"
msgstr "Cazuri necontrolate 칥n instruc탵iunea `switch` (linia 11)"

#: src/why-rust/an-example-in-c.md:63
msgid "Unchecked return values of `stat` and `fopen` (lines 18 and 26)"
msgstr ""
"Valori de returnare necontrolate ale `stat` 탳i `fopen` (liniile 18 탳i 26)"

#: src/why-rust/an-example-in-c.md:65
msgid ""
"_Shouldn't these bugs be obvious even for a C compiler?_  \n"
"No, surprisingly this code compiles warning-free at the default warning "
"level, even in the latest GCC version (13.2 as of writing)."
msgstr ""
"Ar trebui ca aceste erori s캒 fie evidente chiar 탳i pentru un compilator C, "
"nu?\n"
"칉n mod surprinz캒tor, acest cod se compileaz캒 f캒r캒 avertismente la nivelul de "
"avertizare implicit, chiar 탳i 칥n cea mai recent캒 versiune GCC (13.2 칥n "
"momentul scrierii acestui articol)."

#: src/why-rust/an-example-in-c.md:68
msgid ""
"_Isn't this a highly unrealistic example?_  \n"
"Absolutely not, these kind of bugs have lead to serious security "
"vulnerabilities in the past. Some examples:"
msgstr ""
"Este acesta un exemplu deosebit de nerealist?\n"
"Categoric nu, acest tip de erori au condus 칥n trecut la vulnerabilit캒탵i "
"grave de securitate. Iat캒 c칙teva exemple:"

#: src/why-rust/an-example-in-c.md:71
msgid ""
"Assignment `=` instead of equality comparison `==`: [The Linux Backdoor "
"Attempt of 2003](https://freedom-to-tinker.com/2013/10/09/the-linux-backdoor-"
"attempt-of-2003)"
msgstr ""
"Atribuirea `=` 칥n locul compara탵iei de egalitate `==`: [Tentativa Linux "
"Backdoor din 2003](https://freedom-to-tinker.com/2013/10/09/the-linux-"
"backdoor-attempt-of-2003)"

#: src/why-rust/an-example-in-c.md:72
msgid ""
"Forgotten braces in multi-line `if`: [The Apple goto fail vulnerability]"
"(https://dwheeler.com/essays/apple-goto-fail.html)"
msgstr ""
"Paranteze uitate 칥n `if` pe mai multe linii: [Vulnerabilitatea Apple goto "
"fail](https://dwheeler.com/essays/apple-goto-fail.html)"

#: src/why-rust/an-example-in-c.md:73
msgid ""
"Forgotten `break` in a `switch` statement: [The break that broke sudo]"
"(https://nakedsecurity.sophos.com/2012/05/21/anatomy-of-a-security-hole-the-"
"break-that-broke-sudo)"
msgstr ""
"`break` uitat 칥ntr-o declara탵ie `switch`: [Break care a stricat sudo]"
"(https://nakedsecurity.sophos.com/2012/05/21/anatomy-of-a-security-hole-the-"
"break-that-broke-sudo)"

#: src/why-rust/an-example-in-c.md:75
msgid ""
"_How is Rust any better here?_  \n"
"Safe Rust makes all of these bugs impossible:"
msgstr ""
"De ce este mai bun Rust 칥n acest caz?\n"
"Siguran탵a Rust face ca toate aceste erori s캒 fie imposibile:"

#: src/why-rust/an-example-in-c.md:78
msgid "Assignments inside an `if` clause are not supported."
msgstr "Atribuirile din interiorul unei clauze `if` nu sunt acceptate."

#: src/why-rust/an-example-in-c.md:79
msgid "Format strings are checked at compile-time."
msgstr "탲irurile de caractere de format sunt verificate la compilare."

#: src/why-rust/an-example-in-c.md:80
msgid "Resources are freed at the end of scope via the `Drop` trait."
msgstr ""
"Resursele sunt eliberate la sf칙r탳itul domeniului de aplicare prin "
"intermediul tr캒s캒turii `Drop`."

#: src/why-rust/an-example-in-c.md:81
msgid "All `if` clauses require braces."
msgstr "Toate clauzele `if` necesit캒 paranteze."

#: src/why-rust/an-example-in-c.md:82
msgid ""
"`match` (as the Rust equivalent to `switch`) does not fall-through, hence "
"you can't accidentally forget a `break`."
msgstr ""
"`match` (echivalentul 칥n Rust al lui `switch`) nu cascadeaz캒, prin urmare nu "
"pute탵i uita accidental un `break`."

#: src/why-rust/an-example-in-c.md:83
msgid "Buffer slices carry their size and don't rely on a NUL terminator."
msgstr ""
"Buc캒탵ile de memorii tampon 칥탳i p캒streaz캒 dimensiunea 탳i nu se bazeaz캒 pe un "
"terminator NUL."

#: src/why-rust/an-example-in-c.md:84
msgid ""
"Heap-allocated memory is freed via the `Drop` trait when the corresponding "
"`Box` leaves the scope."
msgstr ""
"Memoria alocat캒 칥n heap este eliberat캒 prin intermediul tr캒s캒turii `Drop` "
"atunci c칙nd `Box` corespunz캒tor p캒r캒se탳te domeniul de aplicare."

#: src/why-rust/an-example-in-c.md:85
msgid ""
"Out-of-bounds accesses cause a panic or can be checked via the `get` method "
"of a slice."
msgstr ""
"Acces캒rile 칥n afara limitelor provoac캒 o panic캒 sau pot fi verificate prin "
"metoda `get` a unei felii."

#: src/why-rust/an-example-in-c.md:86
msgid "`match` mandates that all cases are handled."
msgstr "`match` impune ca toate cazurile s캒 fie tratate."

#: src/why-rust/an-example-in-c.md:87
msgid ""
"Fallible Rust functions return `Result` values that need to be unwrapped and "
"thereby checked for success. Additionally, the compiler emits a warning if "
"you miss to check the return value of a function marked with `#[must_use]`."
msgstr ""
"Func탵iile Rust fragile returneaz캒 valori `Result` care trebuie desf캒cute 탳i, "
"prin urmare, verificate pentru succes. 칉n plus, compilatorul emite un "
"avertisment dac캒 nu verifica탵i valoarea de returnare a unei func탵ii marcate "
"cu `#[must_use]`."

#: src/why-rust/compile-time.md:3
msgid "Static memory management at compile time:"
msgstr "Gestionarea static캒 a memoriei 칥n momentul compil캒rii:"

#: src/why-rust/compile-time.md:5
msgid "No uninitialized variables."
msgstr "Nu exist캒 variabile neini탵ializate."

#: src/why-rust/compile-time.md:6
msgid "No memory leaks (_mostly_, see notes)."
msgstr ""
"Nu exist캒 scurgeri de memorie (_칥n cea mai mare parte_, a se vedea notele de "
"subsol)."

#: src/why-rust/compile-time.md:7
msgid "No double-frees."
msgstr "Nu exist캒 eliber캒ri duble de memorie."

#: src/why-rust/compile-time.md:8
msgid "No use-after-free."
msgstr "Nu se utilizeaz캒 dup캒 eliberare."

#: src/why-rust/compile-time.md:9
msgid "No `NULL` pointers."
msgstr "Nu exist캒 pointeri `NULL`."

#: src/why-rust/compile-time.md:10
msgid "No forgotten locked mutexes."
msgstr "Nu s-au uitat mutexuri blocate."

#: src/why-rust/compile-time.md:11
msgid "No data races between threads."
msgstr "Nu exist캒 concuren탵캒 la date 칥ntre firele de execu탵ie."

#: src/why-rust/compile-time.md:12
msgid "No iterator invalidation."
msgstr "Nu sunt invalid캒ri ale iteratorilor."

#: src/why-rust/compile-time.md:16
msgid ""
"It is possible to produce memory leaks in (safe) Rust. Some examples are:"
msgstr ""
"Sunt posibile scurgeri de memorie 칥n Rust (sigur). C칙teva exemple sunt:"

#: src/why-rust/compile-time.md:19
#, fuzzy
msgid ""
"You can use [`Box::leak`](https://doc.rust-lang.org/std/boxed/struct.Box."
"html#method.leak) to leak a pointer. A use of this could be to get runtime-"
"initialized and runtime-sized static variables"
msgstr ""
"Pute탵i utiliza [`Box::leak`](https://doc.rust-lang.org/std/boxed/struct.Box."
"html#method.leak) pentru a scurge un pointer. O utilizare a acestui lucru ar "
"putea fi ob탵inerea variabilelor statice ini탵ializate 탳i dimensionate 칥n timp "
"de execu탵ie"

#: src/why-rust/compile-time.md:21
msgid ""
"You can use [`std::mem::forget`](https://doc.rust-lang.org/std/mem/fn.forget."
"html) to make the compiler \"forget\" about a value (meaning the destructor "
"is never run)."
msgstr ""
"Pute탵i utiliza [`std::mem::forget`](https://doc.rust-lang.org/std/mem/fn."
"forget.html) pentru a face compilatorul s캒 \"uite\" de o valoare (ceea ce "
"칥nseamn캒 c캒 destructorul nu este executat niciodat캒)."

#: src/why-rust/compile-time.md:23
msgid ""
"You can also accidentally create a [reference cycle](https://doc.rust-lang."
"org/book/ch15-06-reference-cycles.html) with `Rc` or `Arc`."
msgstr ""
"De asemenea, pute탵i crea din gre탳eal캒 un [ciclu de referin탵캒](https://doc."
"rust-lang.org/book/ch15-06-reference-cycles.html) cu `Rc` sau `Arc`."

#: src/why-rust/compile-time.md:25
msgid ""
"In fact, some will consider infinitely populating a collection a memory leak "
"and Rust does not protect from those."
msgstr ""
"De fapt, unii vor considera c캒 popularea la infinit a unei colec탵ii "
"reprezint캒 o scurgere de memorie, iar Rust nu ofer캒 protec탵ie 칥n acest sens."

#: src/why-rust/compile-time.md:28
msgid ""
"For the purpose of this course, \"No memory leaks\" should be understood as "
"\"Pretty much no _accidental_ memory leaks\"."
msgstr ""
"칉n scopul acestui curs, \"F캒r캒 scurgeri de memorie\" ar trebui s캒 fie "
"칥n탵eles ca fiind \"Aproape f캒r캒 scurgeri de memorie _accidentale_\"."

#: src/why-rust/runtime.md:3
msgid "No undefined behavior at runtime:"
msgstr "Nici un comportament nedefinit 칥n timpul execu탵iei:"

#: src/why-rust/runtime.md:5
msgid "Array access is bounds checked."
msgstr "Accesul la matrice este verificat 칥n func탵ie de limite."

#: src/why-rust/runtime.md:6
#, fuzzy
msgid "Integer overflow is defined (panic or wrap-around)."
msgstr "Este definit캒 dep캒탳irea num캒rului 칥ntreg (panic캒 sau wrap-around)."

#: src/why-rust/runtime.md:12
#, fuzzy
msgid ""
"Integer overflow is defined via the [`overflow-checks`](https://doc.rust-"
"lang.org/rustc/codegen-options/index.html#overflow-checks) compile-time "
"flag. If enabled, the program will panic (a controlled crash of the "
"program), otherwise you get wrap-around semantics. By default, you get "
"panics in debug mode (`cargo build`) and wrap-around in release mode (`cargo "
"build --release`)."
msgstr ""
"Dep캒탳irea de numere 칥ntregi este definit캒 prin intermediul indicatorului "
"[`overflow-checks`](https://doc.rust-lang.org/rustc/codegen-options/index."
"html#overflow-checks) din timpul compil캒rii. Dac캒 este activat, programul va "
"intra 칥n panic캒 (o pr캒bu탳ire controlat캒 a programului), 칥n caz contrar ve탵i "
"ob탵ine o semantic캒 de tip wrap-around. 칉n mod implicit, ve탵i ob탵ine panic캒 "
"칥n modul de depanare (`cargo build`) 탳i wrap-around 칥n modul de lansare "
"(`cargo build --release`)."

#: src/why-rust/runtime.md:18
#, fuzzy
msgid ""
"Bounds checking cannot be disabled with a compiler flag. It can also not be "
"disabled directly with the `unsafe` keyword. However, `unsafe` allows you to "
"call functions such as `slice::get_unchecked` which does not do bounds "
"checking."
msgstr ""
"Verificarea limitelor nu poate fi dezactivat캒 cu un indicator de compilare. "
"De asemenea, nu poate fi dezactivat캒 direct cu ajutorul cuv칙ntului cheie "
"`unsafe`. Cu toate acestea, `unsafe` v캒 permite s캒 apela탵i func탵ii cum ar fi "
"`slice::get_unchecked`, care nu efectueaz캒 verificarea limitelor."

#: src/why-rust/modern.md:3
msgid "Rust is built with all the experience gained in the last decades."
msgstr "Rust este construit cu toat캒 experien탵a acumulat캒 칥n ultimele decenii."

#: src/why-rust/modern.md:5
msgid "Language Features"
msgstr "Caracteristici ale limbajului"

#: src/why-rust/modern.md:7
msgid "Enums and pattern matching."
msgstr "Enums 탳i g캒sirea de modele."

#: src/why-rust/modern.md:8
#, fuzzy
msgid "Generics."
msgstr "Generice."

#: src/why-rust/modern.md:9
#, fuzzy
msgid "No overhead FFI."
msgstr "F캒r캒 costuri suplimentare FFI."

#: src/why-rust/modern.md:10
msgid "Zero-cost abstractions."
msgstr "Abstrac탵ii f캒r캒 costuri."

#: src/why-rust/modern.md:12
msgid "Tooling"
msgstr "Unelte"

#: src/why-rust/modern.md:14
msgid "Great compiler errors."
msgstr "Erorile de compilare importante."

#: src/why-rust/modern.md:15
msgid "Built-in dependency manager."
msgstr "Manager de dependen탵e 칥ncorporat."

#: src/why-rust/modern.md:16
msgid "Built-in support for testing."
msgstr "Suport pentru testare 칥ncorporat."

#: src/why-rust/modern.md:17
#, fuzzy
msgid "Excellent Language Server Protocol support."
msgstr "Suport excelent pentru protocolul serverului de limb캒."

#: src/why-rust/modern.md:23
msgid ""
"Zero-cost abstractions, similar to C++, means that you don't have to 'pay' "
"for higher-level programming constructs with memory or CPU. For example, "
"writing a loop using `for` should result in roughly the same low level "
"instructions as using the `.iter().fold()` construct."
msgstr ""
"Abstrac탵iile cu costuri zero, similare cu C++, 칥nseamn캒 c캒 nu trebuie s캒 "
"\"pl캒ti탵i\" pentru construc탵iile de programare de nivel superior cu memorie "
"sau putere de procesare. De exemplu, scrierea unei bucle folosind `for` ar "
"trebui s캒 rezulte 칥n aproximativ acelea탳i instruc탵iuni de nivel sc캒zut ca 탳i "
"cum ai folosi construc탵ia `.iter().fold()`."

#: src/why-rust/modern.md:28
msgid ""
"It may be worth mentioning that Rust enums are 'Algebraic Data Types', also "
"known as 'sum types', which allow the type system to express things like "
"`Option<T>` and `Result<T, E>`."
msgstr ""
"Poate c캒 merit캒 men탵ionat faptul c캒 enumera탵iile Rust sunt \"Tipuri de date "
"algebrice\", cunoscute 탳i sub numele de \"tipuri sumabile\", care permit "
"sistemului de tipuri s캒 exprime lucruri cum ar fi `Op탵iune<T>` 탳i "
"`Rezultat<T, E>`."

#: src/why-rust/modern.md:32
msgid ""
"Remind people to read the errors --- many developers have gotten used to "
"ignore lengthy compiler output. The Rust compiler is significantly more "
"talkative than other compilers. It will often provide you with _actionable_ "
"feedback, ready to copy-paste into your code."
msgstr ""
"Reaminti탵i-le cursan탵ilor s캒 citeasc캒 erorile --- mul탵i dezvoltatori s-au "
"obi탳nuit s캒 ignore ie탳irile lungi ale compilatorului. Compilatorul Rust este "
"semnificativ mai vorb캒re탵 dec칙t alte compilatoare. Acesta v캒 va oferi adesea "
"un feedback _ac탵ionabil_, gata de a fi folosit 칥n codul dumneavoastr캒."

#: src/why-rust/modern.md:37
msgid ""
"The Rust standard library is small compared to languages like Java, Python, "
"and Go. Rust does not come with several things you might consider standard "
"and essential:"
msgstr ""
"Biblioteca standard Rust este mic캒 칥n compara탵ie cu limbaje precum Java, "
"Python 탳i Go. Rust nu include mai multe lucruri pe care le-a탵i putea "
"considera standard 탳i esen탵iale:"

#: src/why-rust/modern.md:41
msgid "a random number generator, but see [rand](https://docs.rs/rand/)."
msgstr ""
"un generator de numere aleatoare, dar a se vedea [rand](https://docs.rs/"
"rand/)."

#: src/why-rust/modern.md:42
msgid "support for SSL or TLS, but see [rusttls](https://docs.rs/rustls/)."
msgstr ""
"suport pentru SSL sau TLS, dar consulta탵i [rusttls](https://docs.rs/rustls/)."

#: src/why-rust/modern.md:43
msgid "support for JSON, but see [serde_json](https://docs.rs/serde_json/)."
msgstr ""
"suport pentru JSON, dar a se vedea [serde_json](https://docs.rs/serde_json/)."

#: src/why-rust/modern.md:45
msgid ""
"The reasoning behind this is that functionality in the standard library "
"cannot go away, so it has to be very stable. For the examples above, the "
"Rust community is still working on finding the best solution --- and perhaps "
"there isn't a single \"best solution\" for some of these things."
msgstr ""
"Ra탵ionamentul din spatele acestui lucru este c캒 func탵ionalitatea din "
"biblioteca standard nu poate disp캒rea, a탳a c캒 trebuie s캒 fie foarte stabil캒. "
"Pentru exemplele de mai sus, comunitatea Rust 칥nc캒 lucreaz캒 pentru a g캒si "
"cea mai bun캒 solu탵ie --- 탳i poate c캒 nu exist캒 o singur캒 \"solu탵ie optim캒\" "
"pentru unele dintre aceste lucruri."

#: src/why-rust/modern.md:50
msgid ""
"Rust comes with a built-in package manager in the form of Cargo and this "
"makes it trivial to download and compile third-party crates. A consequence "
"of this is that the standard library can be smaller."
msgstr ""
"Rust vine cu un manager de pachete 칥ncorporat sub forma Cargo, ceea ce face "
"ca desc캒rcarea 탳i compilarea de crates de la ter탵i s캒 fie banal캒. O "
"consecin탵캒 a acestui fapt este c캒 biblioteca standard poate fi mai mic캒."

#: src/why-rust/modern.md:54
#, fuzzy
msgid ""
"Discovering good third-party crates can be a problem. Sites like <https://"
"lib.rs/> help with this by letting you compare health metrics for crates to "
"find a good and trusted one."
msgstr ""
"Descoperirea unor crates bune de la ter탵i poate fi o problem캒. Site-uri "
"precum <https://lib.rs/> v캒 ajut캒 칥n acest sens, permi탵칙ndu-v캒 s캒 compara탵i "
"parametrii pentru crater pentru a g캒si una bun캒 탳i de 칥ncredere."

#: src/why-rust/modern.md:58
msgid ""
"[rust-analyzer](https://rust-analyzer.github.io/) is a well supported LSP "
"implementation used in major IDEs and text editors."
msgstr ""
"[rust-analyzer](https://rust-analyzer.github.io/) este o implementare LSP cu "
"suport bun, folosit캒 칥n principalele IDE-uri 탳i editoare de text."

#: src/basic-syntax.md:3
msgid "Much of the Rust syntax will be familiar to you from C, C++ or Java:"
msgstr "Mare parte din sintaxa Rust v캒 va fi familiar캒 din C, C++ sau Java:"

#: src/basic-syntax.md:5
msgid "Blocks and scopes are delimited by curly braces."
msgstr ""
"Blocurile 탳i domeniile de aplicare sunt delimitate prin paranteze curbe."

#: src/basic-syntax.md:6
msgid ""
"Line comments are started with `//`, block comments are delimited by `/* ... "
"*/`."
msgstr ""
"Comentariile de o linie 칥ncep cu `//`, iar blocurile de comentarii sunt "
"delimitate de `/* ... */`."

#: src/basic-syntax.md:8
msgid "Keywords like `if` and `while` work the same."
msgstr "Cuvinte cheie precum `if` 탳i `while` func탵ioneaz캒 la fel."

#: src/basic-syntax.md:9
msgid "Variable assignment is done with `=`, comparison is done with `==`."
msgstr ""
"Atribuirea variabilelor se face cu `=`, iar compararea se face cu `==`."

#: src/basic-syntax/scalar-types.md:3 src/basic-syntax/compound-types.md:3
#: src/exercises/day-3/safe-ffi-wrapper.md:16
msgid "Types"
msgstr "Tipuri"

#: src/basic-syntax/scalar-types.md:3 src/basic-syntax/compound-types.md:3
#, fuzzy
msgid "Literals"
msgstr "Literale"

#: src/basic-syntax/scalar-types.md:5
msgid "Signed integers"
msgstr "Numere 칥ntregi cu semn"

#: src/basic-syntax/scalar-types.md:5
msgid "`i8`, `i16`, `i32`, `i64`, `i128`, `isize`"
msgstr "`i8`, `i16`, `i32`, `i64`, `i128`, `isize`"

#: src/basic-syntax/scalar-types.md:5
msgid "`-10`, `0`, `1_000`, `123_i64`"
msgstr "`-10`, `0`, `1_000`, `123_i64`"

#: src/basic-syntax/scalar-types.md:6
msgid "Unsigned integers"
msgstr "칉ntregi f캒r캒 semn"

#: src/basic-syntax/scalar-types.md:6
msgid "`u8`, `u16`, `u32`, `u64`, `u128`, `usize`"
msgstr "`u8`, `u16`, `u32`, `u64`, `u128`, `usize`"

#: src/basic-syntax/scalar-types.md:6
msgid "`0`, `123`, `10_u16`"
msgstr "`0`, `123`, `10_u16`"

#: src/basic-syntax/scalar-types.md:7
msgid "Floating point numbers"
msgstr "Numere 칥n virgul캒 mobil캒"

#: src/basic-syntax/scalar-types.md:7
msgid "`f32`, `f64`"
msgstr "`f32`, `f64`"

#: src/basic-syntax/scalar-types.md:7
msgid "`3.14`, `-10.0e20`, `2_f32`"
msgstr "`3.14`, `-10.0e20`, `2_f32`"

#: src/basic-syntax/scalar-types.md:8
msgid "Strings"
msgstr "탲iruri de caractere"

#: src/basic-syntax/scalar-types.md:8
#: src/android/interoperability/cpp/type-mapping.md:6
msgid "`&str`"
msgstr "`&str`"

#: src/basic-syntax/scalar-types.md:8
msgid "`\"foo\"`, `\"two\\nlines\"`"
msgstr "`\"foo\"`, `렧ou캒\\nlinii`"

#: src/basic-syntax/scalar-types.md:9
msgid "Unicode scalar values"
msgstr "Valori scalare Unicode"

#: src/basic-syntax/scalar-types.md:9
msgid "`char`"
msgstr "`char`"

#: src/basic-syntax/scalar-types.md:9
msgid "`'a'`, `'풤'`, `''`"
msgstr "`'a'`, `'풤'`, `''`"

#: src/basic-syntax/scalar-types.md:10
#, fuzzy
msgid "Booleans"
msgstr "Booleeni"

#: src/basic-syntax/scalar-types.md:10
msgid "`bool`"
msgstr "`bool`"

#: src/basic-syntax/scalar-types.md:10
msgid "`true`, `false`"
msgstr "`true`, `false`"

#: src/basic-syntax/scalar-types.md:12
msgid "The types have widths as follows:"
msgstr "Tipurile au lungimi dup캒 cum urmeaz캒:"

#: src/basic-syntax/scalar-types.md:14
msgid "`iN`, `uN`, and `fN` are _N_ bits wide,"
msgstr "`iN`, `uN`, 탳i `fN` au o lungime de _N_ bi탵i,"

#: src/basic-syntax/scalar-types.md:15
msgid "`isize` and `usize` are the width of a pointer,"
msgstr "`isize` 탳i `usize` reprezint캒 lungimea unui pointer,"

#: src/basic-syntax/scalar-types.md:16
msgid "`char` is 32 bits wide,"
msgstr "`char` are o lungime de 32 de bi탵i,"

#: src/basic-syntax/scalar-types.md:17
msgid "`bool` is 8 bits wide."
msgstr "`bool` are o lungime de 8 bi탵i."

#: src/basic-syntax/scalar-types.md:21
msgid "There are a few syntaxes which are not shown above:"
msgstr "Exist캒 c칙teva elemente de sintax캒 care nu sunt prezentate mai sus:"

#: src/basic-syntax/scalar-types.md:23
#, fuzzy
msgid ""
"Raw strings allow you to create a `&str` value with escapes disabled: "
"`r\"\\n\" == \"\\\\n\"`. You can embed double-quotes by using an equal "
"amount of `#` on either side of the quotes:"
msgstr ""
"탲irurile brute de caractere v캒 permit s캒 crea탵i o valoare `&str` cu "
"sc캒p캒rile dezactivate: `r\"\\n\" == \"\\n\"`. Pute탵i 칥ncorpora ghilimele "
"duble folosind o cantitate egal캒 de `#` de o parte 탳i de alta a ghilimelelor:"

#: src/basic-syntax/scalar-types.md:35
msgid "Byte strings allow you to create a `&[u8]` value directly:"
msgstr "탲irurile de octe탵i v캒 permit s캒 crea탵i direct o valoare `&[u8]`:"

#: src/basic-syntax/scalar-types.md:45
#, fuzzy
msgid ""
"All underscores in numbers can be left out, they are for legibility only. So "
"`1_000` can be written as `1000` (or `10_00`), and `123_i64` can be written "
"as `123i64`."
msgstr ""
"Toate sublinierile din numere pot fi omise, ele sunt doar pentru "
"lizibilitate. Astfel, `1_000` poate fi scris ca `1000` (sau `10_00`), iar "
"`123_i64` poate fi scris ca `123i64`."

#: src/basic-syntax/compound-types.md:5
msgid "Arrays"
msgstr "Array-uri"

#: src/basic-syntax/compound-types.md:5
msgid "`[T; N]`"
msgstr "`[T; N]`"

#: src/basic-syntax/compound-types.md:5
msgid "`[20, 30, 40]`, `[0; 3]`"
msgstr "`[20, 30, 40]`, `[0; 3]`"

#: src/basic-syntax/compound-types.md:6
msgid "Tuples"
msgstr "Tupluri"

#: src/basic-syntax/compound-types.md:6
msgid "`()`, `(T,)`, `(T1, T2)`, ..."
msgstr "`()`, `(T,)`, `(T1, T2)`, ..."

#: src/basic-syntax/compound-types.md:6
msgid "`()`, `('x',)`, `('x', 1.2)`, ..."
msgstr "`()`, `('x',)`, `('x', 1.2)`, ..."

#: src/basic-syntax/compound-types.md:8
msgid "Array assignment and access:"
msgstr "Atribuirea 탳i accesul pentru vectori:"

#: src/basic-syntax/compound-types.md:19
msgid "Tuple assignment and access:"
msgstr "Atribuirea 탳i accesul pentru tupluri:"

#: src/basic-syntax/compound-types.md:34
msgid "Arrays:"
msgstr "Vectori:"

#: src/basic-syntax/compound-types.md:36
msgid ""
"A value of the array type `[T; N]` holds `N` (a compile-time constant) "
"elements of the same type `T`. Note that the length of the array is _part of "
"its type_, which means that `[u8; 3]` and `[u8; 4]` are considered two "
"different types."
msgstr ""
"O valoare de tip matrice `[T; N]` con탵ine `N` (o constant캒 de timp de "
"compilare) elemente de acela탳i tip `T`. Re탵ine탵i c캒 lungimea tabloului este "
"_parte a tipului s캒u_, ceea ce 칥nseamn캒 c캒 `[u8; 3]` 탳i `[u8; 4]` sunt "
"considerate dou캒 tipuri diferite."

#: src/basic-syntax/compound-types.md:40
#, fuzzy
msgid "We can use literals to assign values to arrays."
msgstr "Putem utiliza literali pentru a atribui valori la array-uri."

#: src/basic-syntax/compound-types.md:42
#, fuzzy
msgid ""
"The `println!` macro asks for the debug implementation with the `?` format "
"parameter: `{}` gives the default output, `{:?}` gives the debug output. "
"Types such as integers and strings implement the default output, but arrays "
"only implement the debug output. This means that we must use debug output "
"here."
msgstr ""
"Macroul `println!` solicit캒 implementarea de depanare cu parametrul de "
"format `?`: `{}` ofer캒 ie탳irea implicit캒, `{:?}` ofer캒 ie탳irea de depanare. "
"Tipuri precum 칥ntregi 탳i 탳iruri de caractere implementeaz캒 ie탳irea "
"implicit캒, dar array-urile implementeaz캒 doar ie탳irea de depanare. Aceasta "
"칥nseamn캒 c캒 trebuie s캒 folosim aici ie탳irea de depanare."

#: src/basic-syntax/compound-types.md:47
#, fuzzy
msgid ""
"Adding `#`, eg `{a:#?}`, invokes a \"pretty printing\" format, which can be "
"easier to read."
msgstr ""
"Ad캒ug칙nd `#`, de exemplu `{a:#?}`, se invoc캒 un format de tip캒rire "
"\"frumos\", care poate fi mai u탳or de citit."

#: src/basic-syntax/compound-types.md:49
msgid "Tuples:"
msgstr "Tupluri:"

#: src/basic-syntax/compound-types.md:51
msgid "Like arrays, tuples have a fixed length."
msgstr "Tuplurile au o lungime fix캒, 칥ntocmai vectorilor."

#: src/basic-syntax/compound-types.md:53
#, fuzzy
msgid "Tuples group together values of different types into a compound type."
msgstr "Tuplurile grupeaz캒 valori de tipuri diferite 칥ntr-un tip compus."

#: src/basic-syntax/compound-types.md:55
msgid ""
"Fields of a tuple can be accessed by the period and the index of the value, "
"e.g. `t.0`, `t.1`."
msgstr ""
"C칙mpurile unui tuplu pot fi accesate prin punct 탳i indicele valorii, de "
"exemplu `t.0`, `t.1`."

#: src/basic-syntax/compound-types.md:57
#, fuzzy
msgid ""
"The empty tuple `()` is also known as the \"unit type\". It is both a type, "
"and the only valid value of that type - that is to say both the type and its "
"value are expressed as `()`. It is used to indicate, for example, that a "
"function or expression has no return value, as we'll see in a future slide. "
msgstr ""
"Tuplul goal `()` este cunoscut캒 탳i sub numele de \"tip unitate\". Este at칙t "
"un tip, c칙t 탳i singura valoare valid캒 a acelui tip - adic캒 at칙t tipul, c칙t "
"탳i valoarea sa sunt exprimate sub forma `()`. Este utilizat pentru a indica, "
"de exemplu, c캒 o func탵ie sau o expresie nu are valoare de returnare, dup캒 "
"cum vom vedea 칥ntr-un slide viitor."

#: src/basic-syntax/compound-types.md:61
msgid ""
"You can think of it as `void` that can be familiar to you from other  "
"programming languages."
msgstr ""
"V캒 pute탵i g칙ndi la el ca la un `void` care v캒 este familiar din alte limbaje "
"de programare."

#: src/basic-syntax/references.md:3
msgid "Like C++, Rust has references:"
msgstr "La fel ca 칥n C++, Rust are referin탵e:"

#: src/basic-syntax/references.md:15
msgid "Some notes:"
msgstr "C칙teva note:"

#: src/basic-syntax/references.md:17
msgid ""
"We must dereference `ref_x` when assigning to it, similar to C and C++ "
"pointers."
msgstr ""
"Trebuie s캒 dereferen탵iem `ref_x` atunci c칙nd 칥l atribuim, similar "
"pointerilor din C 탳i C++."

#: src/basic-syntax/references.md:18
msgid ""
"Rust will auto-dereference in some cases, in particular when invoking "
"methods (try `ref_x.count_ones()`)."
msgstr ""
"Rust va face auto-dereferen탵iere 칥n unele cazuri, 칥n special atunci c칙nd "
"invoc캒 metode (칥ncerca탵i `ref_x.count_ones()`)."

#: src/basic-syntax/references.md:20
msgid ""
"References that are declared as `mut` can be bound to different values over "
"their lifetime."
msgstr ""
"Referin탵ele care sunt declarate ca `mut` pot face referire la valori "
"diferite pe parcursul duratei lor de via탵캒."

#: src/basic-syntax/references.md:26
#, fuzzy
msgid ""
"Be sure to note the difference between `let mut ref_x: &i32` and `let ref_x: "
"&mut i32`. The first one represents a mutable reference which can be bound "
"to different values, while the second represents a reference to a mutable "
"value."
msgstr ""
"Nu uita탵i s캒 observa탵i diferen탵a dintre `let mut ref_x: &i32` 탳i `let ref_x: "
"&mut i32`. Primul reprezint캒 o referin탵캒 mutabil캒 care poate fi legat캒 la "
"diferite valori, 칥n timp ce al doilea reprezint캒 o referin탵캒 la o valoare "
"mutabil캒."

#: src/basic-syntax/references-dangling.md:3
#, fuzzy
msgid "Rust will statically forbid dangling references:"
msgstr "Rust va interzice 칥n mod static referin탵ele care at칙rn캒:"

#: src/basic-syntax/references-dangling.md:17
#, fuzzy
msgid "A reference is said to \"borrow\" the value it refers to."
msgstr "Se spune c캒 o referin탵캒 \"칥mprumut캒\" valoarea la care se refer캒."

#: src/basic-syntax/references-dangling.md:18
#, fuzzy
msgid ""
"Rust is tracking the lifetimes of all references to ensure they live long "
"enough."
msgstr ""
"Rust urm캒re탳te durata de via탵캒 a tuturor referin탵elor pentru a se asigura c캒 "
"acestea tr캒iesc suficient de mult."

#: src/basic-syntax/references-dangling.md:20
#, fuzzy
msgid "We will talk more about borrowing when we get to ownership."
msgstr ""
"Vom vorbi mai multe despre 칥mprumuturi atunci c칙nd vom ajunge la proprietate."

#: src/basic-syntax/slices.md:3
#, fuzzy
msgid "A slice gives you a view into a larger collection:"
msgstr "O felie v캒 ofer캒 o imagine a unei colec탵ii mai mari:"

#: src/basic-syntax/slices.md:17
#, fuzzy
msgid "Slices borrow data from the sliced type."
msgstr "Felii 칥mprumut캒 date din tipul feliat."

#: src/basic-syntax/slices.md:18
#, fuzzy
msgid "Question: What happens if you modify `a[3]` right before printing `s`?"
msgstr ""
"칉ntrebare: Ce se 칥nt칙mpl캒 dac캒 modifica탵i `a[3]` chiar 칥nainte de a imprima "
"`s`?"

#: src/basic-syntax/slices.md:22
#, fuzzy
msgid ""
"We create a slice by borrowing `a` and specifying the starting and ending "
"indexes in brackets."
msgstr ""
"Cre캒m o felie prin 칥mprumutarea lui `a` 탳i specificarea indicilor de 칥nceput "
"탳i de sf칙r탳it 칥ntre paranteze."

#: src/basic-syntax/slices.md:24
#, fuzzy
msgid ""
"If the slice starts at index 0, Rust뗩 range syntax allows us to drop the "
"starting index, meaning that `&a[0..a.len()]` and `&a[..a.len()]` are "
"identical."
msgstr ""
"Dac캒 felia 칥ncepe la indexul 0, sintaxa intervalului din Rust ne permite s캒 "
"renun탵캒m la indexul de pornire, ceea ce 칥nseamn캒 c캒 `&a[0..a.len()]` 탳i "
"`&a[..a.len()]` sunt identice."

#: src/basic-syntax/slices.md:26
#, fuzzy
msgid ""
"The same is true for the last index, so `&a[2..a.len()]` and `&a[2..]` are "
"identical."
msgstr ""
"Acela탳i lucru este valabil 탳i pentru ultimul indice, astfel 칥nc칙t `&a[2..a."
"len()]` 탳i `&a[2..]` sunt identice."

#: src/basic-syntax/slices.md:28
#, fuzzy
msgid ""
"To easily create a slice of the full array, we can therefore use `&a[..]`."
msgstr ""
"Pentru a crea cu u탳urin탵캒 o por탵iune din 칥ntregul tablou, putem folosi "
"`&a[...]`."

#: src/basic-syntax/slices.md:30
#, fuzzy
msgid ""
"`s` is a reference to a slice of `i32`s. Notice that the type of `s` "
"(`&[i32]`) no longer mentions the array length. This allows us to perform "
"computation on slices of different sizes."
msgstr ""
"`s` este o referin탵캒 la o felie de `i32`s. Observa탵i c캒 tipul lui `s` "
"(`&[i32]`) nu mai men탵ioneaz캒 lungimea matricei. Acest lucru ne permite s캒 "
"efectu캒m calcule pe felii de dimensiuni diferite."

#: src/basic-syntax/slices.md:32
#, fuzzy
msgid ""
"Slices always borrow from another object. In this example, `a` has to remain "
"'alive' (in scope) for at least as long as our slice. "
msgstr ""
"Feliile 칥mprumut캒 칥ntotdeauna de la un alt obiect. 칉n acest exemplu, `a` "
"trebuie s캒 r캒m칙n캒 \"칥n via탵캒\" (칥n domeniul de aplicare) cel pu탵in at칙ta "
"timp c칙t slice-ul nostru."

#: src/basic-syntax/slices.md:34
#, fuzzy
msgid ""
"The question about modifying `a[3]` can spark an interesting discussion, but "
"the answer is that for memory safety reasons you cannot do it through `a` at "
"this point in the execution, but you can read the data from both `a` and `s` "
"safely. It works before you created the slice, and again after the "
"`println`, when the slice is no longer used. More details will be explained "
"in the borrow checker section."
msgstr ""
"칉ntrebarea despre modificarea lui `a[3]` poate st칙rni o discu탵ie "
"interesant캒, dar r캒spunsul este c캒, din motive de siguran탵캒 a memoriei, nu "
"se poate face acest lucru prin `a` 칥n acest moment al execu탵iei, dar se pot "
"citi datele at칙t din `a`, c칙t 탳i din `s` 칥n siguran탵캒. Func탵ioneaz캒 칥nainte "
"de a crea slice-ul 탳i din nou dup캒 `println`, c칙nd slice-ul nu mai este "
"utilizat. Mai multe detalii vor fi explicate 칥n sec탵iunea de verificare a "
"칥mprumuturilor."

#: src/basic-syntax/string-slices.md:1
#, fuzzy
msgid "`String` vs `str`"
msgstr "String versus str"

#: src/basic-syntax/string-slices.md:3
#, fuzzy
msgid "We can now understand the two string types in Rust:"
msgstr "Acum putem 칥n탵elege cele dou캒 tipuri de 탳iruri de caractere 칥n Rust:"

#: src/basic-syntax/string-slices.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: &str = \"World\";\n"
"    println!(\"s1: {s1}\");\n"
"\n"
"    let mut s2: String = String::from(\"Hello \");\n"
"    println!(\"s2: {s2}\");\n"
"    s2.push_str(s1);\n"
"    println!(\"s2: {s2}\");\n"
"    \n"
"    let s3: &str = &s2[6..];\n"
"    println!(\"s3: {s3}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    let s1: &str = \"World\";\n"
"    println!(\"s1: {s1}\");\n"
"\n"
"    let mut s2: String = String::from(\"Hello \");\n"
"    println!(\"s2: {s2}\");\n"
"    s2.push_str(s1);\n"
"    println!(\"s2: {s2}\");\n"
"    \n"
"    let s3: &str = &s2[6..];\n"
"    println!(\"s3: {s3}\");\n"
"}\n"
"```"

#: src/basic-syntax/string-slices.md:20
#, fuzzy
msgid "Rust terminology:"
msgstr "Terminologia ruginii:"

#: src/basic-syntax/string-slices.md:22
#, fuzzy
msgid "`&str` an immutable reference to a string slice."
msgstr "`&str` o referin탵캒 imuabil캒 la o felie de 탳ir de caractere."

#: src/basic-syntax/string-slices.md:23
#, fuzzy
msgid "`String` a mutable string buffer."
msgstr "`String` un buffer de 탳ir de caractere mutabil."

#: src/basic-syntax/string-slices.md:27
#, fuzzy
msgid ""
"`&str` introduces a string slice, which is an immutable reference to UTF-8 "
"encoded string data  stored in a block of memory. String literals "
"(`렏ello`), are stored in the program뗩 binary."
msgstr ""
"`&str` introduce o felie de 탳ir de caractere, care este o referin탵캒 imuabil캒 "
"la date de 탳ir de caractere codificate UTF-8 stocate 칥ntr-un bloc de "
"memorie. 탲irurile literale (`\"Hello\"`), sunt stocate 칥n binarul "
"programului."

#: src/basic-syntax/string-slices.md:30
#, fuzzy
msgid ""
"Rust뗩 `String` type is a wrapper around a vector of bytes. As with a "
"`Vec<T>`, it is owned."
msgstr ""
"Tipul `String` din Rust este un 칥nveli탳 칥n jurul unui vector de octe탵i. La "
"fel ca 탳i 칥n cazul unui `Vec<T>`, acesta este de탵inut."

#: src/basic-syntax/string-slices.md:32
#, fuzzy
msgid ""
"As with many other types `String::from()` creates a string from a string "
"literal; `String::new()`  creates a new empty string, to which string data "
"can be added using the `push()` and `push_str()` methods."
msgstr ""
"Ca 탳i 칥n cazul multor alte tipuri, `String::from()` creeaz캒 un 탳ir de "
"caractere dintr-un literal de 탳ir; `String::new()` creeaz캒 un nou 탳ir de "
"caractere gol, la care se pot ad캒uga date de 탳iruri de caractere folosind "
"metodele `push()` 탳i `push_str()`."

#: src/basic-syntax/string-slices.md:35
#, fuzzy
msgid ""
"The `format!()` macro is a convenient way to generate an owned string from "
"dynamic values. It  accepts the same format specification as `println!()`."
msgstr ""
"Macroul `format!()` este o modalitate convenabil캒 de a genera un 탳ir de "
"caractere proprii din valori dinamice. Accept캒 aceea탳i specifica탵ie de "
"format ca 탳i `println!()`."

#: src/basic-syntax/string-slices.md:38
#, fuzzy
msgid ""
"You can borrow `&str` slices from `String` via `&` and optionally range "
"selection."
msgstr ""
"Pute탵i 칥mprumuta felii `&str` de la `String` prin `&` 탳i, op탵ional, prin "
"selectarea intervalului."

#: src/basic-syntax/string-slices.md:40
#, fuzzy
msgid ""
"For C++ programmers: think of `&str` as `const char*` from C++, but the one "
"that always points  to a valid string in memory. Rust `String` is a rough "
"equivalent of `std::string` from C++  (main difference: it can only contain "
"UTF-8 encoded bytes and will never use a small-string optimization)."
msgstr ""
"Pentru programatorii din C++: g칙ndi탵i-v캒 la `&str` ca la `const char*` din C+"
"+, dar cel care indic캒 칥ntotdeauna un 탳ir de caractere valid 칥n memorie. "
"Rust `String` este un echivalent aproximativ al lui `std::string` din C++ "
"(principala diferen탵캒: poate con탵ine numai octe탵i codifica탵i UTF-8 탳i nu va "
"folosi niciodat캒 o optimizare pentru 탳iruri mici)."

#: src/basic-syntax/functions.md:3
#, fuzzy
msgid ""
"A Rust version of the famous [FizzBuzz](https://en.wikipedia.org/wiki/"
"Fizz_buzz) interview question:"
msgstr ""
"O versiune Rust a faimoasei 칥ntreb캒ri de interviu [FizzBuzz](https://en."
"wikipedia.org/wiki/Fizz_buzz):"

#: src/basic-syntax/functions.md:36
#, fuzzy
msgid ""
"We refer in `main` to a function written below. Neither forward declarations "
"nor headers are necessary. "
msgstr ""
"Ne referim 칥n `main` la o func탵ie scris캒 mai jos. Nu sunt necesare nici "
"declara탵iile forward 탳i nici anteturile."

#: src/basic-syntax/functions.md:37
#, fuzzy
msgid ""
"Declaration parameters are followed by a type (the reverse of some "
"programming languages), then a return type."
msgstr ""
"Parametrii de declara탵ie sunt urma탵i de un tip (invers dec칙t 칥n unele "
"limbaje de programare), apoi de un tip de returnare."

#: src/basic-syntax/functions.md:38
#, fuzzy
msgid ""
"The last expression in a function body (or any block) becomes the return "
"value. Simply omit the `;` at the end of the expression."
msgstr ""
"Ultima expresie din corpul unei func탵ii (sau din orice bloc) devine valoarea "
"de returnare. Pur 탳i simplu omite탵i `;` de la sf칙r탳itul expresiei."

#: src/basic-syntax/functions.md:39
#, fuzzy
msgid ""
"Some functions have no return value, and return the 'unit type', `()`. The "
"compiler will infer this if the `-> ()` return type is omitted."
msgstr ""
"Unele func탵ii nu au nicio valoare de retur 탳i returneaz캒 \"tipul de "
"unitate\", `()`. Compilatorul va deduce acest lucru 칥n cazul 칥n care tipul "
"de returnare `-> ()` este omis."

#: src/basic-syntax/functions.md:40
#, fuzzy
msgid ""
"The range expression in the `for` loop in `print_fizzbuzz_to()` contains "
"`=n`, which causes it to include the upper bound."
msgstr ""
"Expresia intervalului din bucla `for` din `print_fizzbuzz_to()` con탵ine "
"`=n`, ceea ce face ca aceasta s캒 includ캒 limita superioar캒."

#: src/basic-syntax/rustdoc.md:3
#, fuzzy
msgid ""
"All language items in Rust can be documented using special `///` syntax."
msgstr ""
"Toate elementele de limbaj din Rust pot fi documentate folosind sintaxa "
"special캒 `////`."

#: src/basic-syntax/rustdoc.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"/// Determine whether the first argument is divisible by the second "
"argument.\n"
"///\n"
"/// If the second argument is zero, the result is false.\n"
"///\n"
"/// # Example\n"
"/// ```\n"
"/// assert!(is_divisible_by(42, 2));\n"
"/// ```\n"
"fn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n"
"    if rhs == 0 {\n"
"        return false;  // Corner case, early return\n"
"    }\n"
"    lhs % rhs == 0     // The last expression in a block is the return "
"value\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"/// Determin캒 dac캒 primul argument este divizibil cu al doilea argument.\n"
"///\n"
"/// Dac캒 al doilea argument este zero, rezultatul este fals.\n"
"///\n"
"/// # Exemplu\n"
"/// ```\n"
"/// assert!(is_divisible_by(42, 2));\n"
"/// ```\n"
"fn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n"
"    if rhs == 0 {\n"
"        return false; // Cazul de col탵, 칥ntoarcere timpurie\n"
"    }\n"
"    lhs % rhs == 0 // Ultima expresie dintr-un bloc este valoarea de "
"returnare\n"
"}\n"
"```"

#: src/basic-syntax/rustdoc.md:22
#, fuzzy
msgid ""
"The contents are treated as Markdown. All published Rust library crates are "
"automatically documented at [`docs.rs`](https://docs.rs) using the [rustdoc]"
"(https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html) tool. It is "
"idiomatic to document all public items in an API using this pattern. Code "
"snippets can document usage and will be used as unit tests."
msgstr ""
"Con탵inutul este tratat ca Markdown. Toate cr캒i탵ele de bibliotec캒 Rust "
"publicate sunt documentate automat la [`docs.rs`](https://docs.rs) folosind "
"instrumentul [rustdoc](https://doc.rust-lang.org/rustdoc/what-is-rustdoc."
"html). Este idiomatic s캒 se documenteze toate elementele publice dintr-o API "
"folosind acest model. Fragmentele de cod pot documenta utilizarea 탳i vor fi "
"utilizate ca teste unitare."

#: src/basic-syntax/rustdoc.md:30
#, fuzzy
msgid ""
"Show students the generated docs for the `rand` crate at [`docs.rs/rand`]"
"(https://docs.rs/rand)."
msgstr ""
"Ar캒ta탵i studen탵ilor documenta탵ia generat캒 pentru cr캒iasa `rand` la [`docs.rs/"
"rand`](https://docs.rs/rand)."

#: src/basic-syntax/rustdoc.md:33
#, fuzzy
msgid ""
"This course does not include rustdoc on slides, just to save space, but in "
"real code they should be present."
msgstr ""
"Acest curs nu include rustdoc pe slide-uri, doar pentru a economisi spa탵iu, "
"dar 칥n codul real ar trebui s캒 fie prezente."

#: src/basic-syntax/rustdoc.md:36
#, fuzzy
msgid ""
"Inner doc comments are discussed later (in the page on modules) and need not "
"be addressed here."
msgstr ""
"Comentariile din interiorul documentului sunt discutate mai t칙rziu (칥n "
"pagina privind modulele) 탳i nu este necesar s캒 fie abordate aici."

#: src/basic-syntax/rustdoc.md:39
#, fuzzy
msgid ""
"Rustdoc comments can contain code snippets that we can run and test using "
"`cargo test`. We will discuss these tests in the [Testing section](../"
"testing/doc-tests.html)."
msgstr ""
"Comentariile Rustdoc pot con탵ine fragmente de cod pe care le putem rula 탳i "
"testa folosind `cargo test`. Vom discuta despre aceste teste 칥n sec탵iunea "
"[Testing](../testing/doc-tests.html)."

#: src/basic-syntax/methods.md:3
#, fuzzy
msgid ""
"Methods are functions associated with a type. The `self` argument of a "
"method is an instance of the type it is associated with:"
msgstr ""
"Metodele sunt func탵ii asociate cu un tip. Argumentul `self` al unei metode "
"este o instan탵캒 a tipului cu care este asociat캒:"

#: src/basic-syntax/methods.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"struct Rectangle {\n"
"    width: u32,\n"
"    height: u32,\n"
"}\n"
"\n"
"impl Rectangle {\n"
"    fn area(&self) -> u32 {\n"
"        self.width * self.height\n"
"    }\n"
"\n"
"    fn inc_width(&mut self, delta: u32) {\n"
"        self.width += delta;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut rect = Rectangle { width: 10, height: 5 };\n"
"    println!(\"old area: {}\", rect.area());\n"
"    rect.inc_width(5);\n"
"    println!(\"new area: {}\", rect.area());\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"struct Rectangle {\n"
"    width: u32,\n"
"    height: u32,\n"
"}\n"
"\n"
"impl Rectangle {\n"
"    fn area(&self) -> u32 {\n"
"        self.width * self.height\n"
"    }\n"
"\n"
"    fn inc_width(&mut self, delta: u32) {\n"
"        self.width += delta;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut rect = Rectangle { width: 10, height: 5 };\n"
"    println!(\"old area: {}\", rect.area()));\n"
"    rect.inc_width(5);\n"
"    println!(\"new area: {}\", rect.area());\n"
"}\n"
"```"

#: src/basic-syntax/methods.md:30
#, fuzzy
msgid ""
"We will look much more at methods in today's exercise and in tomorrow's "
"class."
msgstr ""
"Vom analiza mult mai multe metode 칥n exerci탵iul de ast캒zi 탳i 칥n cursul de "
"m칙ine."

#: src/basic-syntax/methods.md:34
#, fuzzy
msgid "Add a static method called `Rectangle::new` and call this from `main`:"
msgstr ""
"Ad캒uga탵i o metod캒 static캒 numit캒 `Rectangle::new` 탳i apela탵i-o din `main`:"

#: src/basic-syntax/methods.md:42
#, fuzzy
msgid ""
"While _technically_, Rust does not have custom constructors, static methods "
"are commonly used to initialize structs (but don't have to). The actual "
"constructor, `Rectangle { width, height }`, could be called directly. See "
"the [Rustnomicon](https://doc.rust-lang.org/nomicon/constructors.html)."
msgstr ""
"De탳i, din punct de vedere tehnic, Rust nu are constructori personaliza탵i, "
"metodele statice sunt utilizate 칥n mod obi탳nuit pentru a ini탵ializa "
"structurile (dar nu trebuie s캒 o fac캒). Constructorul propriu-zis, "
"`Rectangle { width, height }`, ar putea fi apelat direct. A se vedea "
"[Rustnomicon](https://doc.rust-lang.org/nomicon/constructors.html)."

#: src/basic-syntax/methods.md:45
#, fuzzy
msgid ""
"Add a `Rectangle::square(width: u32)` constructor to illustrate that such "
"static methods can take arbitrary parameters."
msgstr ""
"Ad캒uga탵i un constructor `Rectangle::square(width: u32)` pentru a ilustra "
"faptul c캒 astfel de metode statice pot lua parametri arbitrari."

#: src/basic-syntax/functions-interlude.md:1
#, fuzzy
msgid "Function Overloading"
msgstr "Supra칥nc캒rcarea func탵iilor"

#: src/basic-syntax/functions-interlude.md:3
#, fuzzy
msgid "Overloading is not supported:"
msgstr "Supra칥nc캒rcarea nu este acceptat캒:"

#: src/basic-syntax/functions-interlude.md:5
#, fuzzy
msgid "Each function has a single implementation:"
msgstr "Fiecare func탵ie are o singur캒 implementare:"

#: src/basic-syntax/functions-interlude.md:6
#, fuzzy
msgid "Always takes a fixed number of parameters."
msgstr "Accept캒 칥ntotdeauna un num캒r fix de parametri."

#: src/basic-syntax/functions-interlude.md:7
#, fuzzy
msgid "Always takes a single set of parameter types."
msgstr "Accept캒 칥ntotdeauna un singur set de tipuri de parametri."

#: src/basic-syntax/functions-interlude.md:8
#, fuzzy
msgid "Default values are not supported:"
msgstr "Valorile implicite nu sunt acceptate:"

#: src/basic-syntax/functions-interlude.md:9
#, fuzzy
msgid "All call sites have the same number of arguments."
msgstr "Toate site-urile de apelare au acela탳i num캒r de argumente."

#: src/basic-syntax/functions-interlude.md:10
#, fuzzy
msgid "Macros are sometimes used as an alternative."
msgstr "Macros sunt uneori folosite ca alternativ캒."

#: src/basic-syntax/functions-interlude.md:12
#, fuzzy
msgid "However, function parameters can be generic:"
msgstr "Cu toate acestea, parametrii func탵iilor pot fi generici:"

#: src/basic-syntax/functions-interlude.md:14
#, fuzzy
msgid ""
"```rust,editable\n"
"fn pick_one<T>(a: T, b: T) -> T {\n"
"    if std::process::id() % 2 == 0 { a } else { b }\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"coin toss: {}\", pick_one(\"heads\", \"tails\"));\n"
"    println!(\"cash prize: {}\", pick_one(500, 1000));\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn pick_one<T>(a: T, b: T) -&gt; T {\n"
"    if std::process::id() % 2 == 0 { a } else { b }\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"aruncarea monedei: {}\", pick_one(\"heads\", \"tails\"));\n"
"    println!(\"premiu 칥n bani: {}\", pick_one(500, 1000));\n"
"}\n"
"```"

#: src/basic-syntax/functions-interlude.md:27
#, fuzzy
msgid ""
"When using generics, the standard library's `Into<T>` can provide a kind of "
"limited polymorphism on argument types. We will see more details in a later "
"section."
msgstr ""
"Atunci c칙nd se utilizeaz캒 generice, `Into<T>` din biblioteca standard poate "
"oferi un fel de polimorfism limitat pentru tipurile de argumente. Vom vedea "
"mai multe detalii 칥ntr-o sec탵iune ulterioar캒."

#: src/exercises/day-1/morning.md:1
#, fuzzy
msgid "Day 1: Morning Exercises"
msgstr "Ziua 1: Exerci탵ii de diminea탵캒"

#: src/exercises/day-1/morning.md:3
#, fuzzy
msgid "In these exercises, we will explore two parts of Rust:"
msgstr "칉n aceste exerci탵ii, vom explora dou캒 p캒r탵i din Rust:"

#: src/exercises/day-1/morning.md:5
#, fuzzy
msgid "Implicit conversions between types."
msgstr "Conversii implicite 칥ntre tipuri."

#: src/exercises/day-1/morning.md:7
#, fuzzy
msgid "Arrays and `for` loops."
msgstr "Array-uri 탳i bucle `for`."

#: src/exercises/day-1/morning.md:11
#, fuzzy
msgid "A few things to consider while solving the exercises:"
msgstr ""
"C칙teva lucruri de care trebuie s캒 탵ine탵i cont 칥n timpul rezolv캒rii "
"exerci탵iilor:"

#: src/exercises/day-1/morning.md:13
#, fuzzy
msgid ""
"Use a local Rust installation, if possible. This way you can get auto-"
"completion in your editor. See the page about [Using Cargo](../../cargo.md) "
"for details on installing Rust."
msgstr ""
"Utiliza탵i o instala탵ie Rust local캒, dac캒 este posibil. 칉n acest fel, pute탵i "
"ob탵ine autocompletare 칥n editorul dumneavoastr캒. Consulta탵i pagina despre "
"[Using Cargo](../../cargo.md) pentru detalii despre instalarea Rust."

#: src/exercises/day-1/morning.md:17
#, fuzzy
msgid "Alternatively, use the Rust Playground."
msgstr "Alternativ, pute탵i utiliza Rust Playground."

#: src/exercises/day-1/morning.md:19
#, fuzzy
msgid ""
"The code snippets are not editable on purpose: the inline code snippets lose "
"their state if you navigate away from the page."
msgstr ""
"Fragmentele de cod nu sunt editabile 칥n mod inten탵ionat: fragmentele de cod "
"칥n linie 칥탳i pierd starea dac캒 naviga탵i 칥n afara paginii."

#: src/exercises/day-1/morning.md:22 src/exercises/day-2/morning.md:11
#: src/exercises/day-3/morning.md:9 src/exercises/bare-metal/morning.md:7
#: src/exercises/concurrency/morning.md:12
#, fuzzy
msgid ""
"After looking at the exercises, you can look at the [solutions](solutions-"
"morning.md) provided."
msgstr ""
"Dup캒 ce a탵i studiat exerci탵iile, pute탵i consulta [solu탵ii](solutions-morning."
"md) furnizate."

#: src/exercises/day-1/implicit-conversions.md:3
#, fuzzy
msgid ""
"Rust will not automatically apply _implicit conversions_ between types "
"([unlike C++](https://en.cppreference.com/w/cpp/language/"
"implicit_conversion)). You can see this in a program like this:"
msgstr ""
"Rust nu va aplica 칥n mod automat conversii _implicite_ 칥ntre tipuri ([spre "
"deosebire de C++](https://en.cppreference.com/w/cpp/language/"
"implicit_conversion)). Pute탵i vedea acest lucru 칥ntr-un program ca acesta:"

#: src/exercises/day-1/implicit-conversions.md:20
#, fuzzy
msgid ""
"The Rust integer types all implement the [`From<T>`](https://doc.rust-lang."
"org/std/convert/trait.From.html) and [`Into<T>`](https://doc.rust-lang.org/"
"std/convert/trait.Into.html) traits to let us convert between them. The "
"`From<T>` trait has a single `from()` method and similarly, the `Into<T>` "
"trait has a single `into()` method. Implementing these traits is how a type "
"expresses that it can be converted into another type."
msgstr ""
"Toate tipurile de numere 칥ntregi Rust implementeaz캒 tr캒s캒turile [`From<T>`]"
"(https://doc.rust-lang.org/std/convert/trait.From.html) 탳i [`Into<T>`]"
"(https://doc.rust-lang.org/std/convert/trait.Into.html) pentru a ne permite "
"s캒 facem conversia 칥ntre ele. Caracteristica `From<T>` are o singur캒 metod캒 "
"`from()` 탳i, 칥n mod similar, caracteristica `Into<T>` are o singur캒 metod캒 "
"`into()`. Implementarea acestor tr캒s캒turi reprezint캒 modul 칥n care un tip "
"exprim캒 faptul c캒 poate fi convertit 칥ntr-un alt tip."

#: src/exercises/day-1/implicit-conversions.md:26
#, fuzzy
msgid ""
"The standard library has an implementation of `From<i8> for i16`, which "
"means that we can convert a variable `x` of type `i8` to an `i16` by "
"calling  `i16::from(x)`. Or, simpler, with `x.into()`, because `From<i8> for "
"i16` implementation automatically create an implementation of `Into<i16> for "
"i8`."
msgstr ""
"Biblioteca standard are o implementare a `From<i8> pentru i16`, ceea ce "
"칥nseamn캒 c캒 putem converti o variabil캒 `x` de tip `i8` 칥n `i16` prin "
"apelarea `i16::from(x)`. Sau, mai simplu, cu `x.into()`, deoarece "
"implementarea `From<i8> for i16` creeaz캒 automat o implementare a `Into<i16> "
"for i8`."

#: src/exercises/day-1/implicit-conversions.md:31
#, fuzzy
msgid ""
"The same applies for your own `From` implementations for your own types, so "
"it is sufficient to only implement `From` to get a respective `Into` "
"implementation automatically."
msgstr ""
"Acela탳i lucru este valabil 탳i pentru propriile implement캒ri `From` pentru "
"propriile tipuri, astfel 칥nc칙t este suficient s캒 implementa탵i doar `From` "
"pentru a ob탵ine automat o implementare `Into` corespunz캒toare."

#: src/exercises/day-1/implicit-conversions.md:34
#, fuzzy
msgid "Execute the above program and look at the compiler error."
msgstr "Executa탵i programul de mai sus 탳i observa탵i eroarea de compilare."

#: src/exercises/day-1/implicit-conversions.md:36
#, fuzzy
msgid "Update the code above to use `into()` to do the conversion."
msgstr ""
"Actualiza탵i codul de mai sus pentru a utiliza `into()` pentru a face "
"conversia."

#: src/exercises/day-1/implicit-conversions.md:38
#, fuzzy
msgid ""
"Change the types of `x` and `y` to other things (such as `f32`, `bool`, "
"`i128`) to see which types you can convert to which other types. Try "
"converting small types to big types and the other way around. Check the "
"[standard library documentation](https://doc.rust-lang.org/std/convert/trait."
"From.html) to see if `From<T>` is implemented for the pairs you check."
msgstr ""
"Schimba탵i tipurile de `x` 탳i `y` 칥n alte tipuri (cum ar fi `f32`, `bool`, "
"`i128`) pentru a vedea ce tipuri pute탵i converti 칥n ce alte tipuri. "
"칉ncerca탵i s캒 converti탵i tipurile mici 칥n tipuri mari 탳i invers. Verifica탵i "
"칥n [documenta탵ia bibliotecii standard](https://doc.rust-lang.org/std/convert/"
"trait.From.html) pentru a vedea dac캒 `From<T>` este implementat pentru "
"perechile pe care le verifica탵i."

#: src/exercises/day-1/for-loops.md:1
#: src/exercises/day-1/solutions-morning.md:3
#, fuzzy
msgid "Arrays and `for` Loops"
msgstr "Array-uri 탳i bucle `for`"

#: src/exercises/day-1/for-loops.md:3
#, fuzzy
msgid "We saw that an array can be declared like this:"
msgstr "Am v캒zut c캒 un array poate fi declarat astfel:"

#: src/exercises/day-1/for-loops.md:9
#, fuzzy
msgid ""
"You can print such an array by asking for its debug representation with `{:?}"
"`:"
msgstr ""
"Pute탵i imprima un astfel de tablou cer칙nd reprezentarea sa de depanare cu "
"`{:?}`:"

#: src/exercises/day-1/for-loops.md:19
#, fuzzy
msgid ""
"Rust lets you iterate over things like arrays and ranges using the `for` "
"keyword:"
msgstr ""
"Rust v캒 permite s캒 itera탵i peste lucruri precum array-uri 탳i intervale "
"folosind cuv칙ntul cheie `for`:"

#: src/exercises/day-1/for-loops.md:22
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    print!(\"Iterating over array:\");\n"
"    for n in &array {\n"
"        print!(\" {n}\");\n"
"    }\n"
"    println!();\n"
"\n"
"    print!(\"Iterating over range:\");\n"
"    for i in 0..3 {\n"
"        print!(\" {}\", array[i]);\n"
"    }\n"
"    println!();\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    print!(\"Iter칙nd peste array:\");\n"
"    for n in &array {\n"
"        print!(\" {n}\");\n"
"    }\n"
"    println!();\n"
"\n"
"    print!(\"Iterare pe interval:\");\n"
"    for i in 0..3 {\n"
"        print!(\" {}\", array[i]);\n"
"    }\n"
"    println!();\n"
"}\n"
"```"

#: src/exercises/day-1/for-loops.md:39
#, fuzzy
msgid ""
"Use the above to write a function `pretty_print` which pretty-print a matrix "
"and a function `transpose` which will transpose a matrix (turn rows into "
"columns):"
msgstr ""
"Folosi탵i cele de mai sus pentru a scrie o func탵ie `pretty_print` care "
"tip캒re탳te o matrice 탳i o func탵ie `transpose` care va transpune o matrice "
"(transform캒 r칙ndurile 칥n coloane):"

#: src/exercises/day-1/for-loops.md:49
#, fuzzy
msgid "Hard-code both functions to operate on 3 칑 3 matrices."
msgstr "Codifica탵i ambele func탵ii pentru a opera pe matrici 3 칑 3."

#: src/exercises/day-1/for-loops.md:51
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and implement the "
"functions:"
msgstr ""
"Copia탵i codul de mai jos 칥n <https://play.rust-lang.org/> 탳i implementa탵i "
"func탵iile:"

#: src/exercises/day-1/for-loops.md:54
#, fuzzy
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"\n"
"    println!(\"matrix:\");\n"
"    pretty_print(&matrix);\n"
"\n"
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```"
msgstr ""
"```rust,should_panic\n"
"// TODO: elimina탵i acest lucru atunci c칙nd a탵i terminat cu implementarea.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3]; 3] {\n"
"    neimplementat!()\n"
"}\n"
"\n"
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    neimplementat!()\n"
"}\n"
"\n"
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- comentariul face ca rustfmt s캒 adauge o "
"linie nou캒\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"\n"
"    println!(\"matrice:\");\n"
"    pretty_print(&matrix);\n"
"\n"
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```"

#: src/exercises/day-1/for-loops.md:82
#, fuzzy
msgid "Bonus Question"
msgstr "칉ntrebare bonus"

#: src/exercises/day-1/for-loops.md:84
#, fuzzy
msgid ""
"Could you use `&[i32]` slices instead of hard-coded 3 칑 3 matrices for your "
"argument and return types? Something like `&[&[i32]]` for a two-dimensional "
"slice-of-slices. Why or why not?"
msgstr ""
"A탵i putea folosi felii `&[i32]` 칥n loc de matrici 3 칑 3 codificate pentru "
"tipurile de argument 탳i de returnare? Ceva de genul `&[&[i32]]` pentru o "
"felie de felii bidimensional캒. De ce sau de ce nu?"

#: src/exercises/day-1/for-loops.md:89
#, fuzzy
msgid ""
"See the [`ndarray` crate](https://docs.rs/ndarray/) for a production quality "
"implementation."
msgstr ""
"A se vedea [`ndarray` crate](https://docs.rs/ndarray/) pentru o implementare "
"de calitate de produc탵ie."

#: src/exercises/day-1/for-loops.md:94
#, fuzzy
msgid ""
"The solution and the answer to the bonus section are available in the  "
"[Solution](solutions-morning.md#arrays-and-for-loops) section."
msgstr ""
"Solu탵ia 탳i r캒spunsul la sec탵iunea bonus sunt disponibile 칥n sec탵iunea "
"[Solution](solutions-morning.md#arrays-and-for-loops)."

#: src/exercises/day-1/for-loops.md:97
#, fuzzy
msgid ""
"The use of the reference `&array` within `for n in &array` is a subtle "
"preview of issues of ownership that will come later in the afternoon."
msgstr ""
"Folosirea referin탵ei `&array` 칥n `for n in &array` este o previzualizare "
"subtil캒 a problemelor de proprietate care vor ap캒rea mai t칙rziu 칥n cursul "
"dup캒-amiezii."

#: src/exercises/day-1/for-loops.md:100
#, fuzzy
msgid "Without the `&`..."
msgstr "F캒r캒 `&`..."

#: src/exercises/day-1/for-loops.md:101
#, fuzzy
msgid ""
"The loop would have been one that consumes the array.  This is a change "
"[introduced in the 2021 Edition](https://doc.rust-lang.org/edition-guide/"
"rust-2021/IntoIterator-for-arrays.html)."
msgstr ""
"Bucla ar fi trebuit s캒 fie una care consum캒 matricea.  Aceasta este o "
"modificare [introdus캒 칥n edi탵ia din 2021](https://doc.rust-lang.org/edition-"
"guide/rust-2021/IntoIterator-for-arrays.html)."

#: src/exercises/day-1/for-loops.md:104
#, fuzzy
msgid ""
"An implicit array copy would have occurred.  Since `i32` is a copy type, "
"then `[i32; 3]` is also a copy type."
msgstr ""
"Ar fi avut loc o copiere implicit캒 a matricei.  Din moment ce `i32` este un "
"tip de copiere, atunci `[i32; 3]` este, de asemenea, un tip de copiere."

#: src/control-flow.md:3
#, fuzzy
msgid ""
"As we have seen, `if` is an expression in Rust. It is used to conditionally "
"evaluate one of two blocks, but the blocks can have a value which then "
"becomes the value of the `if` expression. Other control flow expressions "
"work similarly in Rust."
msgstr ""
"Dup캒 cum am v캒zut, `if` este o expresie 칥n Rust. Este utilizat캒 pentru a "
"evalua condi탵ionat unul dintre dou캒 blocuri, dar blocurile pot avea o "
"valoare care devine apoi valoarea expresiei `if`. Alte expresii de flux de "
"control func탵ioneaz캒 칥n mod similar 칥n Rust."

#: src/control-flow/blocks.md:3
#, fuzzy
msgid ""
"A block in Rust contains a sequence of expressions. Each block has a value "
"and a type, which are those of the last expression of the block:"
msgstr ""
"Un bloc 칥n Rust con탵ine o secven탵캒 de expresii. Fiecare bloc are o valoare "
"탳i un tip, care sunt cele ale ultimei expresii din bloc:"

#: src/control-flow/blocks.md:27
#, fuzzy
msgid ""
"If the last expression ends with `;`, then the resulting value and type is "
"`()`."
msgstr ""
"Dac캒 ultima expresie se termin캒 cu `;`, atunci valoarea 탳i tipul rezultat "
"este `()`."

#: src/control-flow/blocks.md:29
#, fuzzy
msgid ""
"The same rule is used for functions: the value of the function body is the "
"return value:"
msgstr ""
"Aceea탳i regul캒 este utilizat캒 pentru func탵ii: valoarea corpului func탵iei "
"este valoarea de returnare:"

#: src/control-flow/blocks.md:45 src/enums.md:34 src/enums/sizes.md:28
#: src/pattern-matching.md:25 src/pattern-matching/match-guards.md:22
#: src/structs.md:31 src/methods.md:30 src/methods/example.md:46
#, fuzzy
msgid "Key Points:"
msgstr "Puncte cheie:"

#: src/control-flow/blocks.md:46
#, fuzzy
msgid ""
"The point of this slide is to show that blocks have a type and value in "
"Rust. "
msgstr ""
"Scopul acestui diapozitiv este de a ar캒ta c캒 blocurile au un tip 탳i o "
"valoare 칥n Rust."

#: src/control-flow/blocks.md:47
#, fuzzy
msgid ""
"You can show how the value of the block changes by changing the last line in "
"the block. For instance, adding/removing a semicolon or using a `return`."
msgstr ""
"Pute탵i ar캒ta cum se modific캒 valoarea blocului modific칙nd ultima linie din "
"bloc. De exemplu, ad캒ug칙nd/elimin칙nd un punct 탳i virgul캒 sau folosind un "
"`return`."

#: src/control-flow/if-expressions.md:1
#, fuzzy
msgid "`if` expressions"
msgstr "expresii for"

#: src/control-flow/if-expressions.md:3
#, fuzzy
msgid ""
"You use [`if` expressions](https://doc.rust-lang.org/reference/expressions/"
"if-expr.html#if-expressions) exactly like `if` statements in other languages:"
msgstr ""
"Utiliza탵i [expresii `if`](https://doc.rust-lang.org/reference/expressions/if-"
"expr.html#if-expressions) exact ca 탳i instruc탵iunile `if` din alte limbaje:"

#: src/control-flow/if-expressions.md:18
#, fuzzy
msgid ""
"In addition, you can use `if` as an expression. The last expression of each "
"block becomes the value of the `if` expression:"
msgstr ""
"칉n plus, pute탵i utiliza `if` ca expresie. Ultima expresie din fiecare bloc "
"devine valoarea expresiei `if`:"

#: src/control-flow/if-expressions.md:35
#, fuzzy
msgid ""
"Because `if` is an expression and must have a particular type, both of its "
"branch blocks must have the same type. Consider showing what happens if you "
"add `;` after `x / 2` in the second example."
msgstr ""
"Deoarece `if` este o expresie 탳i trebuie s캒 aib캒 un anumit tip, ambele "
"blocuri de ramificare trebuie s캒 aib캒 acela탳i tip. S캒 vedem ce se 칥nt칙mpl캒 "
"dac캒 ad캒uga탵i `;` dup캒 `x / 2` 칥n al doilea exemplu."

#: src/control-flow/for-expressions.md:1
#, fuzzy
msgid "`for` loops"
msgstr "bucle `for`"

#: src/control-flow/for-expressions.md:3
#, fuzzy
msgid ""
"The [`for` loop](https://doc.rust-lang.org/std/keyword.for.html) is closely "
"related to the [`while let` loop](while-let-expressions.md). It will "
"automatically call `into_iter()` on the expression and then iterate over it:"
msgstr ""
"Bucla [`for`](https://doc.rust-lang.org/std/keyword.for.html) este str칙ns "
"legat캒 de bucla [`while let`](while-let-expressions.md). Aceasta va apela "
"automat `into_iter()` pe expresie 탳i apoi va itera peste ea:"

#: src/control-flow/for-expressions.md:22
#, fuzzy
msgid "You can use `break` and `continue` here as usual."
msgstr "Pute탵i folosi `break` 탳i `continue` aici ca de obicei."

#: src/control-flow/for-expressions.md:26
#, fuzzy
msgid "Index iteration is not a special syntax in Rust for just that case."
msgstr ""
"Itera탵ia indexului nu este o sintax캒 special캒 칥n Rust doar pentru acest caz."

#: src/control-flow/for-expressions.md:27
#, fuzzy
msgid "`(0..10)` is a range that implements an `Iterator` trait. "
msgstr "`(0..10)` este un interval care implementeaz캒 o tr캒s캒tur캒 `Iterator`."

#: src/control-flow/for-expressions.md:28
#, fuzzy
msgid ""
"`step_by` is a method that returns another `Iterator` that skips every other "
"element. "
msgstr ""
"`step_by` este o metod캒 care returneaz캒 un alt `Iterator` care sare peste "
"fiecare alt element."

#: src/control-flow/for-expressions.md:29
#, fuzzy
msgid ""
"Modify the elements in the vector and explain the compiler errors. Change "
"vector `v` to be mutable and the for loop to `for x in v.iter_mut()`."
msgstr ""
"Modifica탵i elementele din vector 탳i explica탵i erorile compilatorului. "
"Modifica탵i vectorul `v` pentru a fi mutabil, iar bucla for 칥n `for x in v."
"iter_mut()`."

#: src/control-flow/while-expressions.md:1
#, fuzzy
msgid "`while` loops"
msgstr "bucle `while`"

#: src/control-flow/while-expressions.md:3
#, fuzzy
msgid ""
"The [`while` keyword](https://doc.rust-lang.org/reference/expressions/loop-"
"expr.html#predicate-loops) works very similar to other languages:"
msgstr ""
"Cuv칙ntul cheie [`while`](https://doc.rust-lang.org/reference/expressions/"
"loop-expr.html#predicate-loops) func탵ioneaz캒 foarte asem캒n캒tor cu alte "
"limbaje:"

#: src/control-flow/break-continue.md:1
#, fuzzy
msgid "`break` and `continue`"
msgstr "`break` 탳i `continue`"

#: src/control-flow/break-continue.md:3
#, fuzzy
msgid ""
"If you want to exit a loop early, use [`break`](https://doc.rust-lang.org/"
"reference/expressions/loop-expr.html#break-expressions),"
msgstr ""
"Dac캒 dori탵i s캒 ie탳i탵i mai devreme dintr-o bucl캒, utiliza탵i [`break`](https://"
"doc.rust-lang.org/reference/expressions/loop-expr.html#break-expressions),"

#: src/control-flow/break-continue.md:4
#, fuzzy
msgid ""
"If you want to immediately start the next iteration use [`continue`](https://"
"doc.rust-lang.org/reference/expressions/loop-expr.html#continue-expressions)."
msgstr ""
"Dac캒 dori탵i s캒 칥ncepe탵i imediat urm캒toarea itera탵ie, utiliza탵i [`continue`]"
"(https://doc.rust-lang.org/reference/expressions/loop-expr.html#continue-"
"expressions)."

#: src/control-flow/break-continue.md:7
#, fuzzy
msgid ""
"Both `continue` and `break` can optionally take a label argument which is "
"used to break out of nested loops:"
msgstr ""
"At칙t `continue`, c칙t 탳i `break` pot primi op탵ional un argument de tip label, "
"care este utilizat pentru a ie탳i din buclele imbricate:"

#: src/control-flow/break-continue.md:29
#, fuzzy
msgid ""
"In this case we break the outer loop after 3 iterations of the inner loop."
msgstr ""
"칉n acest caz, 칥ntrerupem bucla exterioar캒 dup캒 3 itera탵ii ale buclei "
"interioare."

#: src/control-flow/loop-expressions.md:1
#, fuzzy
msgid "`loop` expressions"
msgstr "expresii cu bucle"

#: src/control-flow/loop-expressions.md:3
#, fuzzy
msgid ""
"Finally, there is a [`loop` keyword](https://doc.rust-lang.org/reference/"
"expressions/loop-expr.html#infinite-loops) which creates an endless loop."
msgstr ""
"칉n cele din urm캒, exist캒 un cuv칙nt cheie [`loop`](https://doc.rust-lang.org/"
"reference/expressions/loop-expr.html#infinite-loops) care creeaz캒 o bucl캒 "
"nesf칙r탳it캒."

#: src/control-flow/loop-expressions.md:6
#, fuzzy
msgid "Here you must either `break` or `return` to stop the loop:"
msgstr ""
"Aici trebuie s캒 folosi탵i fie `break`, fie `return` pentru a opri bucla:"

#: src/control-flow/loop-expressions.md:28
#, fuzzy
msgid "Break the `loop` with a value (e.g. `break 8`) and print it out."
msgstr "칉ntrerupe탵i `loop` cu o valoare (de exemplu, `break 8`) 탳i tip캒ri탵i-o."

#: src/control-flow/loop-expressions.md:29
#, fuzzy
msgid ""
"Note that `loop` is the only looping construct which returns a non-trivial "
"value. This is because it's guaranteed to be entered at least once (unlike "
"`while` and `for` loops)."
msgstr ""
"Re탵ine탵i c캒 `loop` este singura construc탵ie de bucl캒 care returneaz캒 o "
"valoare non-trivial캒. Acest lucru se datoreaz캒 faptului c캒 este garantat s캒 "
"fie introdus cel pu탵in o dat캒 (spre deosebire de buclele `while` 탳i `for`)."

#: src/basic-syntax/variables.md:3
#, fuzzy
msgid ""
"Rust provides type safety via static typing. Variable bindings are immutable "
"by default:"
msgstr ""
"Rust ofer캒 siguran탵캒 de tip prin intermediul tipiz캒rii statice. Leg캒turile "
"variabilelor sunt imuabile 칥n mod implicit:"

#: src/basic-syntax/variables.md:18
#, fuzzy
msgid ""
"Due to type inference the `i32` is optional. We will gradually show the "
"types less and less as the course progresses."
msgstr ""
"Datorit캒 inferen탵ei de tip, `i32` este op탵ional. Vom ar캒ta treptat tipurile "
"din ce 칥n ce mai pu탵in pe m캒sur캒 ce cursul avanseaz캒."

#: src/basic-syntax/type-inference.md:3
#, fuzzy
msgid "Rust will look at how the variable is _used_ to determine the type:"
msgstr ""
"Rust se va uita la modul 칥n care variabila este _utilizat캒_ pentru a "
"determina tipul:"

#: src/basic-syntax/type-inference.md:27
#, fuzzy
msgid ""
"This slide demonstrates how the Rust compiler infers types based on "
"constraints given by variable declarations and usages."
msgstr ""
"Acest diapozitiv demonstreaz캒 modul 칥n care compilatorul Rust deduce "
"tipurile pe baza constr칙ngerilor date de declara탵iile 탳i utiliz캒rile "
"variabilelor."

#: src/basic-syntax/type-inference.md:29
#, fuzzy
msgid ""
"It is very important to emphasize that variables declared like this are not "
"of some sort of dynamic \"any type\" that can hold any data. The machine "
"code generated by such declaration is identical to the explicit declaration "
"of a type. The compiler does the job for us and helps us write more concise "
"code."
msgstr ""
"Este foarte important s캒 subliniem c캒 variabilele declarate astfel nu sunt "
"de un fel de \"orice tip\" dinamic care poate con탵ine orice date. Codul "
"ma탳in캒 generat de o astfel de declara탵ie este identic cu declara탵ia "
"explicit캒 a unui tip. Compilatorul 칥탳i face treaba 칥n locul nostru 탳i ne "
"ajut캒 s캒 scriem un cod mai concis."

#: src/basic-syntax/type-inference.md:33
#, fuzzy
msgid ""
"The following code tells the compiler to copy into a certain generic "
"container without the code ever explicitly specifying the contained type, "
"using `_` as a placeholder:"
msgstr ""
"Urm캒torul cod 칥i spune compilatorului s캒 copieze 칥ntr-un anumit container "
"generic f캒r캒 ca codul s캒 specifice vreodat캒 칥n mod explicit tipul con탵inut, "
"folosind `_` ca un spa탵iu rezervat:"

#: src/basic-syntax/type-inference.md:48
#, fuzzy
msgid ""
"[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator."
"html#method.collect) relies on [`FromIterator`](https://doc.rust-lang.org/"
"std/iter/trait.FromIterator.html), which [`HashSet`](https://doc.rust-lang."
"org/std/collections/struct.HashSet.html#impl-FromIterator%3CT%3E-for-"
"HashSet%3CT,+S%3E) implements."
msgstr ""
"[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator."
"html#method.collect) se bazeaz캒 pe [`FromIterator`](https://doc.rust-lang."
"org/std/iter/trait.FromIterator.html), pe care 칥l implementeaz캒 [`HashSet`]"
"(https://doc.rust-lang.org/std/collections/struct.HashSet.html#impl-"
"FromIterator%3CT%3E-for-HashSet%3CT,+S%3E)."

#: src/basic-syntax/static-and-const.md:1
#, fuzzy
msgid "Static and Constant Variables"
msgstr "Variabile statice 탳i constante"

#: src/basic-syntax/static-and-const.md:3
#, fuzzy
msgid ""
"Static and constant variables are two different ways to create globally-"
"scoped values that cannot be moved or reallocated during the execution of "
"the program. "
msgstr ""
"Variabilele statice 탳i variabilele constante sunt dou캒 modalit캒탵i diferite "
"de a crea valori cu acoperire global캒 care nu pot fi mutate sau realocate 칥n "
"timpul execu탵iei programului."

#: src/basic-syntax/static-and-const.md:6
#, fuzzy
msgid "`const`"
msgstr "`const`"

#: src/basic-syntax/static-and-const.md:8
#, fuzzy
msgid ""
"Constant variables are evaluated at compile time and their values are "
"inlined wherever they are used:"
msgstr ""
"Variabilele constante sunt evaluate la compilare, iar valorile lor sunt "
"subliniate ori de c칙te ori sunt utilizate:"

#: src/basic-syntax/static-and-const.md:30
#, fuzzy
msgid ""
"According to the [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-"
"vs-static.html) these are inlined upon use."
msgstr ""
"칉n conformitate cu [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-"
"const-vs-static.html), acestea sunt subliniate la utilizare."

#: src/basic-syntax/static-and-const.md:32
#, fuzzy
msgid ""
"Only functions marked `const` can be called at compile time to generate "
"`const` values. `const` functions can however be called at runtime."
msgstr ""
"Numai func탵iile marcate `const` pot fi apelate la compilare pentru a genera "
"valori `const`. totu탳i, func탵iile `const` pot fi apelate 칥n timpul execu탵iei."

#: src/basic-syntax/static-and-const.md:34
#, fuzzy
msgid "`static`"
msgstr "`static`"

#: src/basic-syntax/static-and-const.md:36
#, fuzzy
msgid ""
"Static variables will live during the whole execution of the program, and "
"therefore will not move:"
msgstr ""
"Variabilele statice vor fi valabile pe toat캒 durata execu탵iei programului "
"탳i, prin urmare, nu se vor deplasa:"

#: src/basic-syntax/static-and-const.md:38
#, fuzzy
msgid ""
"```rust,editable\n"
"static BANNER: &str = \"Welcome to RustOS 3.14\";\n"
"\n"
"fn main() {\n"
"    println!(\"{BANNER}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"static BANNER: &str = \"Bine a탵i venit la RustOS 3.14\";\n"
"\n"
"fn main() {\n"
"    println!(\"{BANNER}\");\n"
"}\n"
"```"

#: src/basic-syntax/static-and-const.md:46
#, fuzzy
msgid ""
"As noted in the [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-"
"vs-static.html), these are not inlined upon use and have an actual "
"associated memory location.  This is useful for unsafe and  embedded code, "
"and the variable lives through the entirety of the program execution. When a "
"globally-scoped value does not have a reason to need object identity, "
"`const` is generally preferred."
msgstr ""
"Dup캒 cum se men탵ioneaz캒 칥n [Rust RFC Book](https://rust-lang.github.io/"
"rfcs/0246-const-vs-static.html), acestea nu sunt subliniate la utilizare 탳i "
"au o loca탵ie de memorie real캒 asociat캒.  Acest lucru este util pentru codul "
"nesigur 탳i 칥ncorporat, iar variabila tr캒ie탳te pe toat캒 durata execu탵iei "
"programului. Atunci c칙nd o valoare cu acoperire global캒 nu are un motiv "
"pentru a avea nevoie de identitatea obiectului, `const` este 칥n general "
"preferat캒."

#: src/basic-syntax/static-and-const.md:50
#, fuzzy
msgid ""
"Because `static` variables are accessible from any thread, they must be "
"`Sync`. Interior mutability is possible through a [`Mutex`](https://doc.rust-"
"lang.org/std/sync/struct.Mutex.html), atomic or similar. It is also possible "
"to have mutable statics, but they require manual synchronisation so any "
"access to them requires `unsafe` code. We will look at [mutable statics](../"
"unsafe/mutable-static-variables.md) in the chapter on Unsafe Rust."
msgstr ""
"Deoarece variabilele `statice` sunt accesibile din orice fir de execu탵ie, "
"ele trebuie s캒 fie `Sync`. Mutabilitatea interioar캒 este posibil캒 prin "
"intermediul unui [`Mutex`](https://doc.rust-lang.org/std/sync/struct.Mutex."
"html), atomic sau similar. De asemenea, este posibil s캒 ave탵i variabile "
"statice mutabile, dar acestea necesit캒 sincronizare manual캒, astfel 칥nc칙t "
"orice acces la ele necesit캒 cod `unsafe`. Ne vom uita la [mutable statics]"
"(../unsafe/mutable-static-variables.md) 칥n capitolul despre Unsafe Rust."

#: src/basic-syntax/static-and-const.md:58
#, fuzzy
msgid "Mention that `const` behaves semantically similar to C++'s `constexpr`."
msgstr ""
"Men탵iona탵i c캒 `const` are un comportament semantic similar cu `constexpr` "
"din C++."

#: src/basic-syntax/static-and-const.md:59
#, fuzzy
msgid ""
"`static`, on the other hand, is much more similar to a `const` or mutable "
"global variable in C++."
msgstr ""
"`static`, pe de alt캒 parte, este mult mai asem캒n캒toare cu o variabil캒 "
"global캒 `const` sau mutabil캒 칥n C++."

#: src/basic-syntax/static-and-const.md:60
#, fuzzy
msgid ""
"`static` provides object identity: an address in memory and state as "
"required by types with interior mutability such as `Mutex<T>`."
msgstr ""
"`static` asigur캒 identitatea obiectului: o adres캒 칥n memorie 탳i starea "
"necesar캒 pentru tipurile cu mutabilitate interioar캒, cum ar fi `Mutex<T>`."

#: src/basic-syntax/static-and-const.md:61
#, fuzzy
msgid ""
"It isn't super common that one would need a runtime evaluated constant, but "
"it is helpful and safer than using a static."
msgstr ""
"Nu este foarte des 칥nt칙lnit cazul 칥n care cineva ar avea nevoie de o "
"constant캒 evaluat캒 칥n timp de execu탵ie, dar este util캒 탳i mai sigur캒 dec칙t "
"utilizarea unei constante statice."

#: src/basic-syntax/static-and-const.md:62
#, fuzzy
msgid "`thread_local` data can be created with the macro `std::thread_local`."
msgstr ""
"datele `thread_local` pot fi create cu ajutorul macroului `std::"
"thread_local`."

#: src/basic-syntax/static-and-const.md:64
msgid "Properties table:"
msgstr "Tabelul cu propriet캒탵i:"

#: src/basic-syntax/static-and-const.md:66
msgid "Property"
msgstr "Proprietate"

#: src/basic-syntax/static-and-const.md:66
msgid "Static"
msgstr "Static"

#: src/basic-syntax/static-and-const.md:66
msgid "Constant"
msgstr "Constant"

#: src/basic-syntax/static-and-const.md:68
msgid "Has an address in memory"
msgstr "Are o adres캒 칥n memorie"

#: src/basic-syntax/static-and-const.md:68
#: src/basic-syntax/static-and-const.md:69
#: src/basic-syntax/static-and-const.md:71
#: src/basic-syntax/static-and-const.md:72
msgid "Yes"
msgstr "Da"

#: src/basic-syntax/static-and-const.md:68
#, fuzzy
msgid "No (inlined)"
msgstr "Nu (subliniat)"

#: src/basic-syntax/static-and-const.md:69
#, fuzzy
msgid "Lives for the entire duration of the program"
msgstr "Tr캒ie탳te pe 칥ntreaga durat캒 a programului"

#: src/basic-syntax/static-and-const.md:69
#: src/basic-syntax/static-and-const.md:70
#: src/basic-syntax/static-and-const.md:72
msgid "No"
msgstr "Nu"

#: src/basic-syntax/static-and-const.md:70
msgid "Can be mutable"
msgstr "Poate fi mutabil"

#: src/basic-syntax/static-and-const.md:70
msgid "Yes (unsafe)"
msgstr "Da (nesigur)"

#: src/basic-syntax/static-and-const.md:71
msgid "Evaluated at compile time"
msgstr "Evaluat la compilare"

#: src/basic-syntax/static-and-const.md:71
msgid "Yes (initialised at compile time)"
msgstr "Da (ini탵ializat la compilare)"

#: src/basic-syntax/static-and-const.md:72
#, fuzzy
msgid "Inlined wherever it is used"
msgstr "칉nc캒rcat oriunde este utilizat"

#: src/basic-syntax/scopes-shadowing.md:3
#, fuzzy
msgid ""
"You can shadow variables, both those from outer scopes and variables from "
"the same scope:"
msgstr ""
"Pute탵i umbri variabilele, at칙t cele din domenii de aplicare exterioare, c칙t "
"탳i variabilele din acela탳i domeniu de aplicare:"

#: src/basic-syntax/scopes-shadowing.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 10;\n"
"    println!(\"before: {a}\");\n"
"\n"
"    {\n"
"        let a = \"hello\";\n"
"        println!(\"inner scope: {a}\");\n"
"\n"
"        let a = true;\n"
"        println!(\"shadowed in inner scope: {a}\");\n"
"    }\n"
"\n"
"    println!(\"after: {a}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    let a = 10;\n"
"    println!(\"칥nainte: {a}\");\n"
"\n"
"    {\n"
"        let a = \"bun캒 ziua\";\n"
"        printlnn!(\"domeniul interior: {a}\");\n"
"\n"
"        let a = true;\n"
"        println!(\"umbrit캒 칥n domeniul interior: {a}\");\n"
"    }\n"
"\n"
"    println!(\"dup캒: {a}\");\n"
"}\n"
"```"

#: src/basic-syntax/scopes-shadowing.md:25
#, fuzzy
msgid ""
"Definition: Shadowing is different from mutation, because after shadowing "
"both variable's memory locations exist at the same time. Both are available "
"under the same name, depending where you use it in the code. "
msgstr ""
"Defini탵ie: Shadowing este diferit de muta탵ie, deoarece dup캒 shadowing ambele "
"loca탵ii de memorie ale variabilei exist캒 칥n acela탳i timp. Ambele sunt "
"disponibile sub acela탳i nume, 칥n func탵ie de locul 칥n care se utilizeaz캒 칥n "
"cod."

#: src/basic-syntax/scopes-shadowing.md:26
#, fuzzy
msgid "A shadowing variable can have a different type. "
msgstr "O variabil캒 de umbrire poate avea un tip diferit."

#: src/basic-syntax/scopes-shadowing.md:27
#, fuzzy
msgid ""
"Shadowing looks obscure at first, but is convenient for holding on to values "
"after `.unwrap()`."
msgstr ""
"Umbrirea pare obscur캒 la 칥nceput, dar este convenabil캒 pentru a p캒stra "
"valorile dup캒 `.unwrap()`."

#: src/basic-syntax/scopes-shadowing.md:28
#, fuzzy
msgid ""
"The following code demonstrates why the compiler can't simply reuse memory "
"locations when shadowing an immutable variable in a scope, even if the type "
"does not change."
msgstr ""
"Urm캒torul cod demonstreaz캒 de ce compilatorul nu poate reutiliza pur 탳i "
"simplu loca탵iile de memorie atunci c칙nd umbre탳te o variabil캒 imuabil캒 칥ntr-"
"un domeniu de aplicare, chiar dac캒 tipul nu se schimb캒."

#: src/enums.md:3
#, fuzzy
msgid ""
"The `enum` keyword allows the creation of a type which has a few different "
"variants:"
msgstr ""
"Cuv칙ntul cheie `enum` permite crearea unui tip care are c칙teva variante "
"diferite:"

#: src/enums.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn generate_random_number() -> i32 {\n"
"    // Implementation based on https://xkcd.com/221/\n"
"    4  // Chosen by fair dice roll. Guaranteed to be random.\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"enum CoinFlip {\n"
"    Heads,\n"
"    Tails,\n"
"}\n"
"\n"
"fn flip_coin() -> CoinFlip {\n"
"    let random_number = generate_random_number();\n"
"    if random_number % 2 == 0 {\n"
"        return CoinFlip::Heads;\n"
"    } else {\n"
"        return CoinFlip::Tails;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"You got: {:?}\", flip_coin());\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn generate_random_number() -> i32 {\n"
"    // Implementare bazat캒 pe https://xkcd.com/221/\n"
"    4 // Ales prin aruncarea corect캒 a zarurilor. Garantat a fi aleatoriu.\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"enum CoinFlip {\n"
"    Cap,\n"
"    Pajur캒,\n"
"}\n"
"\n"
"fn flip_coin() -> CoinFlip {\n"
"    let random_number = generate_random_number();\n"
"    if random_number % 2 == 0 {\n"
"        return CoinFlip::Heads;\n"
"    } else {\n"
"        return CoinFlip::Tails;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"Ai ob탵inut: {:?}\", flip_coin());\n"
"}\n"
"```"

#: src/enums.md:36
#, fuzzy
msgid "Enumerations allow you to collect a set of values under one type"
msgstr "Enumer캒rile v캒 permit s캒 colecta탵i un set de valori sub un singur tip"

#: src/enums.md:37
#, fuzzy
msgid ""
"This page offers an enum type `CoinFlip` with two variants `Heads` and "
"`Tails`. You might note the namespace when using variants."
msgstr ""
"Aceast캒 pagin캒 ofer캒 un tip enum `CoinFlip` cu dou캒 variante `Heads` 탳i "
"`Tails`. Trebuie s캒 탵ine탵i cont de spa탵iul de nume atunci c칙nd folosi탵i "
"variante."

#: src/enums.md:38
#, fuzzy
msgid "This might be a good time to compare Structs and Enums:"
msgstr ""
"Acesta ar putea fi un moment bun pentru a compara structurile 탳i "
"enumera탵iile:"

#: src/enums.md:39
#, fuzzy
msgid ""
"In both, you can have a simple version without fields (unit struct) or one "
"with different types of fields (variant payloads). "
msgstr ""
"칉n ambele, pute탵i avea o versiune simpl캒 f캒r캒 c칙mpuri (unit struct) sau una "
"cu diferite tipuri de c칙mpuri (varianta payloads)."

#: src/enums.md:40
#, fuzzy
msgid "In both, associated functions are defined within an `impl` block."
msgstr ""
"칉n ambele, func탵iile asociate sunt definite 칥n cadrul unui bloc `impl`."

#: src/enums.md:41
#, fuzzy
msgid ""
"You could even implement the different variants of an enum with separate "
"structs but then they wouldn뗪 be the same type as they would if they were "
"all defined in an enum. "
msgstr ""
"A탵i putea chiar s캒 implementa탵i diferitele variante ale unui enum cu "
"structuri separate, dar atunci acestea nu ar fi de acela탳i tip ca 칥n cazul "
"칥n care ar fi definite toate 칥ntr-un enum."

#: src/enums/variant-payloads.md:3
#, fuzzy
msgid ""
"You can define richer enums where the variants carry data. You can then use "
"the `match` statement to extract the data from each variant:"
msgstr ""
"Pute탵i defini enume mai bogate 칥n care variantele con탵in date. Apoi pute탵i "
"utiliza instruc탵iunea `match` pentru a extrage datele din fiecare variant캒:"

#: src/enums/variant-payloads.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"enum WebEvent {\n"
"    PageLoad,                 // Variant without payload\n"
"    KeyPress(char),           // Tuple struct variant\n"
"    Click { x: i64, y: i64 }, // Full struct variant\n"
"}\n"
"\n"
"#[rustfmt::skip]\n"
"fn inspect(event: WebEvent) {\n"
"    match event {\n"
"        WebEvent::PageLoad       => println!(\"page loaded\"),\n"
"        WebEvent::KeyPress(c)    => println!(\"pressed '{c}'\"),\n"
"        WebEvent::Click { x, y } => println!(\"clicked at x={x}, y={y}\"),\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let load = WebEvent::PageLoad;\n"
"    let press = WebEvent::KeyPress('x');\n"
"    let click = WebEvent::Click { x: 20, y: 80 };\n"
"\n"
"    inspect(load);\n"
"    inspect(press);\n"
"    inspect(click);\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"enum WebEvent {\n"
"    PageLoad, // Variant캒 f캒r캒 sarcin캒 util캒\n"
"    KeyPress(char), // Variant캒 cu structur캒 de tuple\n"
"    Click { x: i64, y: i64 }, // Variant캒 structural캒 complet캒\n"
"}\n"
"\n"
"#[rustfmt::skip]\n"
"fn inspect(event: WebEvent) {\n"
"    se potrive탳te cu evenimentul {\n"
"        WebEvent::PageLoad => println!(\"pagina 칥nc캒rcat캒\"),\n"
"        WebEvent::KeyPress(c) => println!(\"ap캒sat '{c}]'\"),\n"
"        WebEvent::Click { x, y } => println!(\"ap캒sat la x={x}, y={y}\"),\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let load = WebEvent::PageLoad;\n"
"    let press = WebEvent::KeyPress('x');\n"
"    let click = WebEvent::Click { x: 20, y: 80 };\n"
"\n"
"    inspect(load);\n"
"    inspect(press);\n"
"    inspect(click);\n"
"}\n"
"```"

#: src/enums/variant-payloads.md:35
#, fuzzy
msgid ""
"The values in the enum variants can only be accessed after being pattern "
"matched. The pattern binds references to the fields in the \"match arm\" "
"after the `=>`."
msgstr ""
"Valorile din variantele enum pot fi accesate numai dup캒 ce au fost comparate "
"cu un model. Modelul leag캒 referin탵ele la c칙mpurile din \"bra탵ul de "
"potrivire\" dup캒 `=>`."

#: src/enums/variant-payloads.md:36
#, fuzzy
msgid ""
"The expression is matched against the patterns from top to bottom. There is "
"no fall-through like in C or C++."
msgstr ""
"Expresia este comparat캒 cu modelele de sus 칥n jos. Nu exist캒 nicio c캒dere ca "
"칥n C sau C++."

#: src/enums/variant-payloads.md:37
#, fuzzy
msgid ""
"The match expression has a value. The value is the last expression in the "
"match arm which was executed."
msgstr ""
"Expresia de potrivire are o valoare. Valoarea este ultima expresie din "
"bra탵ul de potrivire care a fost executat캒."

#: src/enums/variant-payloads.md:38
#, fuzzy
msgid ""
"Starting from the top we look for what pattern matches the value then run "
"the code following the arrow. Once we find a match, we stop. "
msgstr ""
"칉ncep칙nd de sus, c캒ut캒m ce model se potrive탳te cu valoarea, apoi execut캒m "
"codul care urmeaz캒 s캒geata. Odat캒 ce g캒sim o potrivire, ne oprim."

#: src/enums/variant-payloads.md:39
#, fuzzy
msgid ""
"Demonstrate what happens when the search is inexhaustive. Note the advantage "
"the Rust compiler provides by confirming when all cases are handled. "
msgstr ""
"Demonstra탵i ce se 칥nt칙mpl캒 atunci c칙nd c캒utarea este neexhaustiv캒. Observa탵i "
"avantajul pe care 칥l ofer캒 compilatorul Rust prin confirmarea momentului 칥n "
"care sunt tratate toate cazurile."

#: src/enums/variant-payloads.md:40
#, fuzzy
msgid "`match` inspects a hidden discriminant field in the `enum`."
msgstr "`match` inspecteaz캒 un c칙mp discriminant ascuns 칥n `enum`."

#: src/enums/variant-payloads.md:41
#, fuzzy
msgid ""
"It is possible to retrieve the discriminant by calling `std::mem::"
"discriminant()`"
msgstr ""
"Este posibil s캒 se recupereze discriminantul prin apelarea `std::mem::"
"discriminant()`"

#: src/enums/variant-payloads.md:42
#, fuzzy
msgid ""
"This is useful, for example, if implementing `PartialEq` for structs where "
"comparing field values doesn't affect equality."
msgstr ""
"Acest lucru este util, de exemplu, dac캒 se implementeaz캒 `PartialEq` pentru "
"structurile 칥n care compararea valorilor c칙mpurilor nu afecteaz캒 egalitatea."

#: src/enums/variant-payloads.md:43
#, fuzzy
msgid ""
"`WebEvent::Click { ... }` is not exactly the same as `WebEvent::"
"Click(Click)` with a top level `struct Click { ... }`. The inlined version "
"cannot implement traits, for example."
msgstr ""
"`WebEvent::Click { ... }` nu este exact acela탳i lucru cu `WebEvent::"
"Click(Click)` cu un nivel superior `struct Click { ... }`. De exemplu, "
"versiunea simplificat캒 nu poate implementa tr캒s캒turi."

#: src/enums/sizes.md:3
#, fuzzy
msgid ""
"Rust enums are packed tightly, taking constraints due to alignment into "
"account:"
msgstr ""
"Enumera탵iile Rust sunt 칥mpachetate str칙ns, lu칙nd 칥n considerare "
"constr칙ngerile datorate alinierii:"

#: src/enums/sizes.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::any::type_name;\n"
"use std::mem::{align_of, size_of};\n"
"\n"
"fn dbg_size<T>() {\n"
"    println!(\"{}: size {} bytes, align: {} bytes\",\n"
"        type_name::<T>(), size_of::<T>(), align_of::<T>());\n"
"}\n"
"\n"
"enum Foo {\n"
"    A,\n"
"    B,\n"
"}\n"
"\n"
"fn main() {\n"
"    dbg_size::<Foo>();\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"use std::any::nume_tip;\n"
"use std::mem::{align_of, size_of};\n"
"\n"
"fn dbg_size<T>() {\n"
"    println!(\"{}: size {} bytes, align: {} bytes\",\n"
"        type_name:::<T>(), size_of::<T>(), align_of::<T>()));\n"
"}\n"
"\n"
"enum Foo {\n"
"    A,\n"
"    B,\n"
"}\n"
"\n"
"fn main() {\n"
"    dbg_size:::<Foo>();\n"
"}\n"
"```"

#: src/enums/sizes.md:24
#, fuzzy
msgid ""
"See the [Rust Reference](https://doc.rust-lang.org/reference/type-layout."
"html)."
msgstr ""
"A se vedea [Rust Reference](https://doc.rust-lang.org/reference/type-layout."
"html)."

#: src/enums/sizes.md:30
#, fuzzy
msgid ""
"Internally Rust is using a field (discriminant) to keep track of the enum "
"variant."
msgstr ""
"La nivel intern, Rust utilizeaz캒 un c칙mp (discriminant) pentru a 탵ine "
"eviden탵a variantei enum."

#: src/enums/sizes.md:32
#, fuzzy
msgid ""
"You can control the discriminant if needed (e.g., for compatibility with C):"
msgstr ""
"Pute탵i controla discriminantul dac캒 este necesar (de exemplu, pentru "
"compatibilitate cu C):"

#: src/enums/sizes.md:50
#, fuzzy
msgid ""
"Without `repr`, the discriminant type takes 2 bytes, because 10001 fits 2 "
"bytes."
msgstr ""
"F캒r캒 `repr`, tipul de discriminant are nevoie de 2 octe탵i, deoarece 10001 se "
"potrive탳te cu 2 octe탵i."

#: src/enums/sizes.md:54
#, fuzzy
msgid "Try out other types such as"
msgstr "칉ncerca탵i 탳i alte tipuri, cum ar fi"

#: src/enums/sizes.md:56
#, fuzzy
msgid "`dbg_size!(bool)`: size 1 bytes, align: 1 bytes,"
msgstr "`dbg_size!(bool)`: dimensiune 1 octet, aliniere: 1 octet,"

#: src/enums/sizes.md:57
#, fuzzy
msgid ""
"`dbg_size!(Option<bool>)`: size 1 bytes, align: 1 bytes (niche optimization, "
"see below),"
msgstr ""
"`dbg_size!(Option<bool>)`: size 1 bytes, align: 1 bytes (optimizare de ni탳캒, "
"a se vedea mai jos),"

#: src/enums/sizes.md:58
#, fuzzy
msgid "`dbg_size!(&i32)`: size 8 bytes, align: 8 bytes (on a 64-bit machine),"
msgstr ""
"`dbg_size!(&i32)`: dimensiune 8 octe탵i, aliniere: 8 octe탵i (pe o ma탳in캒 pe "
"64 de bi탵i),"

#: src/enums/sizes.md:59
#, fuzzy
msgid ""
"`dbg_size!(Option<&i32>)`: size 8 bytes, align: 8 bytes (null pointer "
"optimization, see below)."
msgstr ""
"`dbg_size!(Option<&i32>)`: dimensiune 8 octe탵i, aliniere: 8 octe탵i "
"(optimizare pointer nul, a se vedea mai jos)."

#: src/enums/sizes.md:61 src/memory-management/stack.md:32
#, fuzzy
msgid "More to Explore"
msgstr "Mai multe de explorat"

#: src/enums/sizes.md:63
#, fuzzy
msgid ""
"Rust has several optimizations it can employ to make enums take up less "
"space."
msgstr ""
"Rust are mai multe optimiz캒ri pe care le poate folosi pentru ca enumera탵iile "
"s캒 ocupe mai pu탵in spa탵iu."

#: src/enums/sizes.md:65
#, fuzzy
msgid ""
"Niche optimization: Rust will merge unused bit patterns for the enum "
"discriminant."
msgstr ""
"Optimizarea ni탳ei: Rust va unifica modelele de bi탵i neutilizate pentru "
"discriminantul enum."

#: src/enums/sizes.md:68
#, fuzzy
msgid ""
"Null pointer optimization: For [some types](https://doc.rust-lang.org/std/"
"option/#representation), Rust guarantees that `size_of::<T>()` equals "
"`size_of::<Option<T>>()`."
msgstr ""
"Optimizarea pointerului nul: Pentru [unele tipuri](https://doc.rust-lang.org/"
"std/option/#representation), Rust garanteaz캒 c캒 `size_of::<T>()` este egal "
"cu `size_of::&lt;Op탵iune<T>&gt;()`."

#: src/enums/sizes.md:72
#, fuzzy
msgid ""
"Example code if you want to show how the bitwise representation _may_ look "
"like in practice. It's important to note that the compiler provides no "
"guarantees regarding this representation, therefore this is totally unsafe."
msgstr ""
"Exemplu de cod dac캒 dori탵i s캒 ar캒ta탵i cum ar putea ar캒ta 칥n practic캒 "
"reprezentarea pe bi탵i. Este important de re탵inut c캒 compilatorul nu ofer캒 "
"nicio garan탵ie 칥n ceea ce prive탳te aceast캒 reprezentare, prin urmare este "
"total nesigur캒."

#: src/enums/sizes.md:109
#, fuzzy
msgid ""
"More complex example if you want to discuss what happens when we chain more "
"than 256 `Option`s together."
msgstr ""
"Exemplu mai complex dac캒 dori탵i s캒 discuta탵i ce se 칥nt칙mpl캒 atunci c칙nd "
"칥nl캒n탵uim mai mult de 256 de `Op탵iuni`."

#: src/control-flow/novel.md:3
#, fuzzy
msgid ""
"Rust has a few control flow constructs which differ from other languages. "
"They are used for pattern matching:"
msgstr ""
"Rust are c칙teva construc탵ii de flux de control care difer캒 de alte limbaje. "
"Acestea sunt utilizate pentru potrivirea modelelor:"

#: src/control-flow/novel.md:6 src/control-flow/if-let-expressions.md:1
#, fuzzy
msgid "`if let` expressions"
msgstr "Expresii if let"

#: src/control-flow/novel.md:7
#, fuzzy
msgid "`while let` expressions"
msgstr "Expresii while let"

#: src/control-flow/novel.md:8 src/control-flow/match-expressions.md:1
#, fuzzy
msgid "`match` expressions"
msgstr "expresii `match`"

#: src/control-flow/if-let-expressions.md:3
#, fuzzy
msgid ""
"The [`if let` expression](https://doc.rust-lang.org/reference/expressions/if-"
"expr.html#if-let-expressions) lets you execute different code depending on "
"whether a value matches a pattern:"
msgstr ""
"Expresia [`if let`](https://doc.rust-lang.org/reference/expressions/if-expr."
"html#if-let-expressions) v캒 permite s캒 executa탵i un cod diferit 칥n func탵ie "
"de potrivirea unei valori cu un model:"

#: src/control-flow/if-let-expressions.md:7
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let arg = std::env::args().next();\n"
"    if let Some(value) = arg {\n"
"        println!(\"Program name: {value}\");\n"
"    } else {\n"
"        println!(\"Missing name?\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    let arg = std::env::args().next();\n"
"    if let Some(value) = arg {\n"
"        println!(\"Numele programului: {value}\");\n"
"    } else {\n"
"        println!(\"Nume lips캒?\");\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/if-let-expressions.md:18
#: src/control-flow/while-let-expressions.md:22
#: src/control-flow/match-expressions.md:23
#, fuzzy
msgid ""
"See [pattern matching](../pattern-matching.md) for more details on patterns "
"in Rust."
msgstr ""
"Consulta탵i [pattern matching](../pattern-matching.md) pentru mai multe "
"detalii despre tipare 칥n Rust."

#: src/control-flow/if-let-expressions.md:23
#, fuzzy
msgid ""
"Unlike `match`, `if let` does not have to cover all branches. This can make "
"it more concise than `match`."
msgstr ""
"Spre deosebire de `match`, `if let` nu trebuie s캒 acopere toate ramurile. "
"Acest lucru 칥l poate face mai concis dec칙t `match`."

#: src/control-flow/if-let-expressions.md:24
#, fuzzy
msgid "A common usage is handling `Some` values when working with `Option`."
msgstr ""
"O utilizare obi탳nuit캒 este manipularea valorilor `Some` atunci c칙nd se "
"lucreaz캒 cu `Option`."

#: src/control-flow/if-let-expressions.md:25
#, fuzzy
msgid ""
"Unlike `match`, `if let` does not support guard clauses for pattern matching."
msgstr ""
"Spre deosebire de `match`, `if let` nu accept캒 clauze de protec탵ie pentru "
"potrivirea de tipare."

#: src/control-flow/if-let-expressions.md:26
#, fuzzy
msgid ""
"Since 1.65, a similar [let-else](https://doc.rust-lang.org/rust-by-example/"
"flow_control/let_else.html) construct allows to do a destructuring "
"assignment, or if it fails, execute a block which is required to abort "
"normal control flow (with `panic`/`return`/`break`/`continue`):"
msgstr ""
"칉ncep칙nd cu versiunea 1.65, o construc탵ie similar캒 [let-else](https://doc."
"rust-lang.org/rust-by-example/flow_control/let_else.html) permite efectuarea "
"unei atribuiri destructurante sau, dac캒 aceasta e탳ueaz캒, executarea unui "
"bloc care este necesar pentru a 칥ntrerupe fluxul normal de control (cu "
"`panic`/`return`/`break`/`continue`):"

#: src/control-flow/while-let-expressions.md:1
#, fuzzy
msgid "`while let` loops"
msgstr "bucle `while let`"

#: src/control-flow/while-let-expressions.md:3
#, fuzzy
msgid ""
"Like with `if let`, there is a [`while let`](https://doc.rust-lang.org/"
"reference/expressions/loop-expr.html#predicate-pattern-loops) variant which "
"repeatedly tests a value against a pattern:"
msgstr ""
"Ca 탳i 칥n cazul lui `if let`, exist캒 o variant캒 [`while let`](https://doc."
"rust-lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops) "
"care testeaz캒 칥n mod repetat o valoare 칥n raport cu un model:"

#: src/control-flow/while-let-expressions.md:18
#, fuzzy
msgid ""
"Here the iterator returned by `v.into_iter()` will return a `Option<i32>` on "
"every call to `next()`. It returns `Some(x)` until it is done, after which "
"it will return `None`. The `while let` lets us keep iterating through all "
"items."
msgstr ""
"Aici, iteratorul returnat de `v.into_iter()` va returna un `Option<i32>` la "
"fiecare apel la `next()`. Acesta returneaz캒 `Some(x)` p칙n캒 c칙nd termin캒, "
"dup캒 care va returna `None`. Metoda `while let` ne permite s캒 continu캒m "
"itera탵ia prin toate elementele."

#: src/control-flow/while-let-expressions.md:27
#, fuzzy
msgid ""
"Point out that the `while let` loop will keep going as long as the value "
"matches the pattern."
msgstr ""
"Preciza탵i c캒 bucla `while let` va continua at칙ta timp c칙t valoarea se "
"potrive탳te cu modelul."

#: src/control-flow/while-let-expressions.md:28
#, fuzzy
msgid ""
"You could rewrite the `while let` loop as an infinite loop with an if "
"statement that breaks when there is no value to unwrap for `iter.next()`. "
"The `while let` provides syntactic sugar for the above scenario."
msgstr ""
"A탵i putea rescrie bucla `while let` ca o bucl캒 infinit캒 cu o instruc탵iune if "
"care se 칥ntrerupe atunci c칙nd nu mai exist캒 nicio valoare de desf캒cut pentru "
"`iter.next()`. `while let` ofer캒 zah캒r sintactic pentru scenariul de mai sus."

#: src/control-flow/match-expressions.md:3
#, fuzzy
msgid ""
"The [`match` keyword](https://doc.rust-lang.org/reference/expressions/match-"
"expr.html) is used to match a value against one or more patterns. In that "
"sense, it works like a series of `if let` expressions:"
msgstr ""
"Cuv칙ntul cheie [`match`](https://doc.rust-lang.org/reference/expressions/"
"match-expr.html) este utilizat pentru a compara o valoare cu unul sau mai "
"multe modele. 칉n acest sens, func탵ioneaz캒 ca o serie de expresii `if let`:"

#: src/control-flow/match-expressions.md:7
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    match std::env::args().next().as_deref() {\n"
"        Some(\"cat\") => println!(\"Will do cat things\"),\n"
"        Some(\"ls\")  => println!(\"Will ls some files\"),\n"
"        Some(\"mv\")  => println!(\"Let's move some files\"),\n"
"        Some(\"rm\")  => println!(\"Uh, dangerous!\"),\n"
"        None        => println!(\"Hmm, no program name?\"),\n"
"        _           => println!(\"Unknown program name!\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    match std::env::args().next().as_deref() {\n"
"        Some(\"cat\") => println!(\"Va face lucruri de pisic캒\"),\n"
"        Some(\"ls\") => println!(\"Va face ls unor fi탳iere\"),\n"
"        Some(\"mv\") => println!(\"Va muta ni탳te fi탳iere\"),\n"
"        Some(\"rm\") => println!(\"Uh, periculos!\"),\n"
"        None => println!(\"Hmm, niciun nume de program?\"),\n"
"        _ => println!(\"Nume de program necunoscut!\"),\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/match-expressions.md:20
#, fuzzy
msgid ""
"Like `if let`, each match arm must have the same type. The type is the last "
"expression of the block, if any. In the example above, the type is `()`."
msgstr ""
"La fel ca `if let`, fiecare bra탵 de potrivire trebuie s캒 aib캒 acela탳i tip. "
"Tipul este ultima expresie a blocului, dac캒 exist캒. 칉n exemplul de mai sus, "
"tipul este `()`."

#: src/control-flow/match-expressions.md:28
#, fuzzy
msgid "Save the match expression to a variable and print it out."
msgstr "Salva탵i expresia de potrivire 칥ntr-o variabil캒 탳i imprima탵i-o."

#: src/control-flow/match-expressions.md:29
#, fuzzy
msgid "Remove `.as_deref()` and explain the error."
msgstr "Elimina탵i `.as_deref()` 탳i explica탵i eroarea."

#: src/control-flow/match-expressions.md:30
#, fuzzy
msgid ""
"`std::env::args().next()` returns an `Option<String>`, but we cannot match "
"against `String`."
msgstr ""
"`std::env::args().next()` returneaz캒 o `Op탵iune<String>`, dar nu putem "
"compara cu `String`."

#: src/control-flow/match-expressions.md:31
#, fuzzy
msgid ""
"`as_deref()` transforms an `Option<T>` to `Option<&T::Target>`. In our case, "
"this turns `Option<String>` into `Option<&str>`."
msgstr ""
"`as_deref()` transform캒 o `Op탵iune<T>` 칥n `Op탵iune<&T::Target>`. 칉n cazul "
"nostru, aceasta transform캒 `Op탵iunea<String>` 칥n `Op탵iunea<&str>`."

#: src/control-flow/match-expressions.md:32
#, fuzzy
msgid ""
"We can now use pattern matching to match against the `&str` inside `Option`."
msgstr ""
"Acum putem folosi potrivirea de tipare pentru a ne potrivi cu `&str` din "
"`Option`."

#: src/pattern-matching.md:3
#, fuzzy
msgid ""
"The `match` keyword lets you match a value against one or more _patterns_. "
"The comparisons are done from top to bottom and the first match wins."
msgstr ""
"Cuv칙ntul cheie `match` v캒 permite s캒 compara탵i o valoare cu unul sau mai "
"multe _patterns_. Compara탵iile se fac de sus 칥n jos, iar prima potrivire "
"c칙탳tig캒."

#: src/pattern-matching.md:6
#, fuzzy
msgid "The patterns can be simple values, similarly to `switch` in C and C++:"
msgstr "Modelele pot fi valori simple, la fel ca `switch` 칥n C 탳i C++:"

#: src/pattern-matching.md:8
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let input = 'x';\n"
"\n"
"    match input {\n"
"        'q'                   => println!(\"Quitting\"),\n"
"        'a' | 's' | 'w' | 'd' => println!(\"Moving around\"),\n"
"        '0'..='9'             => println!(\"Number input\"),\n"
"        _                     => println!(\"Something else\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    let input = 'x';\n"
"\n"
"    match input {\n"
"        'q' => println!(\"Renun탵are\"),\n"
"        'a' | 's' | 's' | 'w' | 'd' => println!(\"Moving around\"),\n"
"        '0'..='9' => println!(\"Number input\"),\n"
"        _ => println!(\"Altceva\"),\n"
"    }\n"
"}\n"
"```"

#: src/pattern-matching.md:21
#, fuzzy
msgid "The `_` pattern is a wildcard pattern which matches any value."
msgstr ""
"Modelul `_` este un model wildcard care se potrive탳te cu orice valoare."

#: src/pattern-matching.md:26
#, fuzzy
msgid ""
"You might point out how some specific characters are being used when in a "
"pattern"
msgstr ""
"A탵i putea sublinia modul 칥n care sunt folosite anumite caractere specifice "
"atunci c칙nd se afl캒 칥ntr-un model"

#: src/pattern-matching.md:27
#, fuzzy
msgid "`|` as an `or`"
msgstr "`|` ca un `or`"

#: src/pattern-matching.md:28
#, fuzzy
msgid "`..` can expand as much as it needs to be"
msgstr "`...` se poate extinde at칙t c칙t este nevoie"

#: src/pattern-matching.md:29
#, fuzzy
msgid "`1..=5` represents an inclusive range"
msgstr "`1..=5` reprezint캒 un interval inclusiv"

#: src/pattern-matching.md:30
#, fuzzy
msgid "`_` is a wild card"
msgstr "`_` este un wild card"

#: src/pattern-matching.md:31
#, fuzzy
msgid ""
"It can be useful to show how binding works, by for instance replacing a "
"wildcard character with a variable, or removing the quotes around `q`."
msgstr ""
"Poate fi util s캒 se arate cum func탵ioneaz캒 legarea, de exemplu, prin "
"칥nlocuirea unui caracter wildcard cu o variabil캒 sau prin eliminarea "
"ghilimelelor din jurul lui `q`."

#: src/pattern-matching.md:32
#, fuzzy
msgid "You can demonstrate matching on a reference."
msgstr "Pute탵i demonstra potrivirea pe o referin탵캒."

#: src/pattern-matching.md:33
#, fuzzy
msgid ""
"This might be a good time to bring up the concept of irrefutable patterns, "
"as the term can show up in error messages."
msgstr ""
"Acesta ar putea fi un moment bun pentru a aduce 칥n discu탵ie conceptul de "
"modele irefutabile, deoarece acest termen poate ap캒rea 칥n mesajele de eroare."

#: src/pattern-matching/destructuring-enums.md:3
#, fuzzy
msgid ""
"Patterns can also be used to bind variables to parts of your values. This is "
"how you inspect the structure of your types. Let us start with a simple "
"`enum` type:"
msgstr ""
"Modelele pot fi, de asemenea, utilizate pentru a lega variabilele de p캒r탵i "
"ale valorilor dumneavoastr캒. 칉n acest fel pute탵i inspecta structura "
"tipurilor dumneavoastr캒. S캒 칥ncepem cu un tip simplu `enum`:"

#: src/pattern-matching/destructuring-enums.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"enum Result {\n"
"    Ok(i32),\n"
"    Err(String),\n"
"}\n"
"\n"
"fn divide_in_two(n: i32) -> Result {\n"
"    if n % 2 == 0 {\n"
"        Result::Ok(n / 2)\n"
"    } else {\n"
"        Result::Err(format!(\"cannot divide {n} into two equal parts\"))\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let n = 100;\n"
"    match divide_in_two(n) {\n"
"        Result::Ok(half) => println!(\"{n} divided in two is {half}\"),\n"
"        Result::Err(msg) => println!(\"sorry, an error happened: {msg}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"enum Result {\n"
"    Ok(i32),\n"
"    Err(String),\n"
"}\n"
"\n"
"fn divide_in_two(n: i32) -> Result {\n"
"    if n % 2 == 0 {\n"
"        Result::Ok(n / 2)\n"
"    } else {\n"
"        Result::Err(format!(\"nu se poate 칥mp캒r탵i {n} 칥n dou캒 p캒r탵i "
"egale\"))\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let n = 100;\n"
"    match divide_in_two(n) {\n"
"        Result::Ok(half) => println!(\"{n} 칥mp캒r탵it la doi este {half}\"),\n"
"        Result::Err(msg) => println!(\"scuze, s-a produs o eroare: "
"{msg}\"),\n"
"    }\n"
"}\n"
"```"

#: src/pattern-matching/destructuring-enums.md:29
#, fuzzy
msgid ""
"Here we have used the arms to _destructure_ the `Result` value. In the first "
"arm, `half` is bound to the value inside the `Ok` variant. In the second "
"arm, `msg` is bound to the error message."
msgstr ""
"Aici am folosit bra탵ele pentru a _destructura_ valoarea `Result`. 칉n primul "
"bra탵, `half` este legat de valoarea din interiorul variantei `Ok`. 칉n al "
"doilea bra탵, `msg` este legat de mesajul de eroare."

#: src/pattern-matching/destructuring-enums.md:36
#, fuzzy
msgid ""
"The `if`/`else` expression is returning an enum that is later unpacked with "
"a `match`."
msgstr ""
"Expresia `if`/`else` returneaz캒 o enumera탵ie care este ulterior "
"descompactat캒 cu un `match`."

#: src/pattern-matching/destructuring-enums.md:37
#, fuzzy
msgid ""
"You can try adding a third variant to the enum definition and displaying the "
"errors when running the code. Point out the places where your code is now "
"inexhaustive and how the compiler tries to give you hints."
msgstr ""
"Pute탵i 칥ncerca s캒 ad캒uga탵i o a treia variant캒 la defini탵ia enumului 탳i s캒 "
"afi탳a탵i erorile atunci c칙nd executa탵i codul. Eviden탵ia탵i locurile 칥n care "
"codul dvs. este acum neexhaustiv 탳i modul 칥n care compilatorul 칥ncearc캒 s캒 "
"v캒 ofere indicii."

#: src/pattern-matching/destructuring-structs.md:3
#, fuzzy
msgid "You can also destructure `structs`:"
msgstr "Pute탵i, de asemenea, s캒 destructura탵i `structuri`:"

#: src/pattern-matching/destructuring-structs.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"struct Foo {\n"
"    x: (u32, u32),\n"
"    y: u32,\n"
"}\n"
"\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let foo = Foo { x: (1, 2), y: 3 };\n"
"    match foo {\n"
"        Foo { x: (1, b), y } => println!(\"x.0 = 1, b = {b}, y = {y}\"),\n"
"        Foo { y: 2, x: i }   => println!(\"y = 2, x = {i:?}\"),\n"
"        Foo { y, .. }        => println!(\"y = {y}, other fields were "
"ignored\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"struct Foo {\n"
"    x: (u32, u32),\n"
"    y: u32,\n"
"}\n"
"\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let foo = Foo { x: (1, 2), y: 3 };\n"
"    match foo {\n"
"        Foo { x: (1, b), y } => println!(\"x.0 = 1, b = {b}, y = {y}\"),\n"
"        Foo { y: 2, x: i }   => println!(\"y = 2, x = {i:?}\"),\n"
"        Foo { y, ... }        => println!(\"y = {y}, celelalte c칙mpuri au "
"fost ignorate\"),\n"
"    }\n"
"}\n"
"```"

#: src/pattern-matching/destructuring-structs.md:23
#, fuzzy
msgid "Change the literal values in `foo` to match with the other patterns."
msgstr ""
"Modifica탵i valorile literale din `foo` pentru a se potrivi cu celelalte "
"modele."

#: src/pattern-matching/destructuring-structs.md:24
#, fuzzy
msgid "Add a new field to `Foo` and make changes to the pattern as needed."
msgstr ""
"Ad캒uga탵i un nou c칙mp la `Foo` 탳i modifica탵i modelul dup캒 cum este necesar."

#: src/pattern-matching/destructuring-structs.md:25
#, fuzzy
msgid ""
"The distinction between a capture and a constant expression can be hard to "
"spot. Try changing the `2` in the second arm to a variable, and see that it "
"subtly doesn't work. Change it to a `const` and see it working again."
msgstr ""
"Distinc탵ia dintre o captur캒 탳i o expresie constant캒 poate fi greu de "
"observat. 칉ncerca탵i s캒 schimba탵i `2` din al doilea bra탵 cu o variabil캒 탳i "
"vede탵i c캒, 칥n mod subtil, nu mai func탵ioneaz캒. Schimba탵i-o 칥ntr-o `const` 탳i "
"vede탵i c캒 func탵ioneaz캒 din nou."

#: src/pattern-matching/destructuring-arrays.md:3
#, fuzzy
msgid ""
"You can destructure arrays, tuples, and slices by matching on their elements:"
msgstr ""
"Pute탵i destructura array-uri, tuple 탳i felii prin potrivirea elementelor "
"acestora:"

#: src/pattern-matching/destructuring-arrays.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let triple = [0, -2, 3];\n"
"    println!(\"Tell me about {triple:?}\");\n"
"    match triple {\n"
"        [0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"        [1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
"        _         => println!(\"All elements were ignored\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let triple = [0, -2, 3];\n"
"    println!(\"Spune-mi despre {triple:?}\");\n"
"    match triple {\n"
"        [0, y, z] => println!(\"Primul este 0, y = {y}, iar z = {z}\"),\n"
"        [1, ...] => println!(\"Primul este 1, iar restul au fost "
"ignorate\"),\n"
"        _ => println!(\"Toate elementele au fost ignorate\"),\n"
"    }\n"
"}\n"
"```"

#: src/pattern-matching/destructuring-arrays.md:21
#, fuzzy
msgid ""
"Destructuring of slices of unknown length also works with patterns of fixed "
"length."
msgstr ""
"Destructurarea feliilor de lungime necunoscut캒 func탵ioneaz캒, de asemenea, cu "
"modele de lungime fix캒."

#: src/pattern-matching/destructuring-arrays.md:24
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    inspect(&[0, -2, 3]);\n"
"    inspect(&[0, -2, 3, 4]);\n"
"}\n"
"\n"
"#[rustfmt::skip]\n"
"fn inspect(slice: &[i32]) {\n"
"    println!(\"Tell me about {slice:?}\");\n"
"    match slice {\n"
"        &[0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"        &[1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
"        _          => println!(\"All elements were ignored\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    inspect(&[0, -2, 3]);\n"
"    inspect(&[0, -2, 3, 4]);\n"
"}\n"
"\n"
"#[rustfmt::skip]\n"
"fn inspect(slice: &[i32]) {\n"
"    println!(\"Spune-mi despre {slice:?}\");\n"
"    se potrive탳te cu slice {\n"
"        &[0, y, z] => println!(\"Primul este 0, y = {y}, 탳i z = {z}\"),\n"
"        &[1, ..] => println!(\"Primul este 1, iar restul au fost "
"ignorate\"),\n"
"        _ => println!(\"Toate elementele au fost ignorate\"),\n"
"    }\n"
"}\n"
"```"

#: src/pattern-matching/destructuring-arrays.md:41
#, fuzzy
msgid "Create a new pattern using `_` to represent an element. "
msgstr "Crea탵i un nou model folosind `_` pentru a reprezenta un element."

#: src/pattern-matching/destructuring-arrays.md:42
#, fuzzy
msgid "Add more values to the array."
msgstr "Ad캒uga탵i mai multe valori la matrice."

#: src/pattern-matching/destructuring-arrays.md:43
#, fuzzy
msgid ""
"Point out that how `..` will expand to account for different number of "
"elements."
msgstr ""
"Ar캒ta탵i cum `...` se va extinde pentru a lua 칥n considerare un num캒r diferit "
"de elemente."

#: src/pattern-matching/destructuring-arrays.md:44
#, fuzzy
msgid "Show matching against the tail with patterns `[.., b]` and `[a@..,b]`"
msgstr "Afi탳eaz캒 potrivirea cu coada cu modelele `[.., b]` 탳i `[a@..,b]`"

#: src/pattern-matching/match-guards.md:3
#, fuzzy
msgid ""
"When matching, you can add a _guard_ to a pattern. This is an arbitrary "
"Boolean expression which will be executed if the pattern matches:"
msgstr ""
"La potrivire, pute탵i ad캒uga un _guard_ la un model. Aceasta este o expresie "
"boolean캒 arbitrar캒 care va fi executat캒 칥n cazul 칥n care modelul se "
"potrive탳te:"

#: src/pattern-matching/match-guards.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let pair = (2, -2);\n"
"    println!(\"Tell me about {pair:?}\");\n"
"    match pair {\n"
"        (x, y) if x == y     => println!(\"These are twins\"),\n"
"        (x, y) if x + y == 0 => println!(\"Antimatter, kaboom!\"),\n"
"        (x, _) if x % 2 == 1 => println!(\"The first one is odd\"),\n"
"        _                    => println!(\"No correlation...\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let pair = (2, -2);\n"
"    println!(\"Spune-mi despre {pair:?}\");\n"
"    match pair {\n"
"        (x, y) if x == y => println!(\"Ace탳tia sunt gemeni\"),\n"
"        (x, y) if x + y == 0 => println!(\"Antimaterie, kaboom!\"),\n"
"        (x, _) dac캒 x % 2 == 1 => println!(\"Primul este impar\"),\n"
"        _ => println!(\"Nici o corela탵ie...\"),\n"
"    }\n"
"}\n"
"```"

#: src/pattern-matching/match-guards.md:23
#, fuzzy
msgid ""
"Match guards as a separate syntax feature are important and necessary when "
"we wish to concisely express more complex ideas than patterns alone would "
"allow."
msgstr ""
"G캒rzile de potrivire, ca o caracteristic캒 sintactic캒 separat캒, sunt "
"importante 탳i necesare atunci c칙nd dorim s캒 exprim캒m 칥n mod concis idei mai "
"complexe dec칙t ne-ar permite doar modelele."

#: src/pattern-matching/match-guards.md:24
#, fuzzy
msgid ""
"They are not the same as separate `if` expression inside of the match arm. "
"An `if` expression inside of the branch block (after `=>`) happens after the "
"match arm is selected. Failing the `if` condition inside of that block won't "
"result in other arms of the original `match` expression being considered."
msgstr ""
"Acestea nu sunt acela탳i lucru cu expresia `if` separat캒 칥n interiorul "
"bra탵ului de potrivire. O expresie `if` 칥n interiorul blocului de ramificare "
"(dup캒 `=>`) apare dup캒 ce este selectat bra탵ul de potrivire. 칉n cazul 칥n "
"care nu se 칥ndepline탳te condi탵ia `if` din interiorul blocului respectiv, nu "
"vor fi luate 칥n considerare alte ramuri ale expresiei `match` originale."

#: src/pattern-matching/match-guards.md:26
#, fuzzy
msgid "You can use the variables defined in the pattern in your if expression."
msgstr "Pute탵i utiliza variabilele definite 칥n model 칥n expresia if."

#: src/pattern-matching/match-guards.md:27
#, fuzzy
msgid ""
"The condition defined in the guard applies to every expression in a pattern "
"with an `|`."
msgstr ""
"Condi탵ia definit캒 칥n gard캒 se aplic캒 fiec캒rei expresii dintr-un model cu `|`."

#: src/exercises/day-1/afternoon.md:1
#, fuzzy
msgid "Day 1: Afternoon Exercises"
msgstr "Ziua 1: Exerci탵ii dup캒-amiaza"

#: src/exercises/day-1/afternoon.md:3
#, fuzzy
msgid "We will look at two things:"
msgstr "Ne vom uita la dou캒 lucruri:"

#: src/exercises/day-1/afternoon.md:5
#, fuzzy
msgid "The Luhn algorithm,"
msgstr "Algoritmul Luhn,"

#: src/exercises/day-1/afternoon.md:7
#, fuzzy
msgid "An exercise on pattern matching."
msgstr "Un exerci탵iu de potrivire a modelelor."

#: src/exercises/day-1/afternoon.md:11 src/exercises/day-2/afternoon.md:7
#: src/exercises/bare-metal/afternoon.md:7
#: src/exercises/concurrency/afternoon.md:13
#, fuzzy
msgid ""
"After looking at the exercises, you can look at the [solutions](solutions-"
"afternoon.md) provided."
msgstr ""
"Dup캒 ce a탵i studiat exerci탵iile, pute탵i consulta [solu탵ii](solutions-"
"afternoon.md) furnizate."

#: src/exercises/day-1/luhn.md:3
#, fuzzy
msgid ""
"The [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm) is used "
"to validate credit card numbers. The algorithm takes a string as input and "
"does the following to validate the credit card number:"
msgstr ""
"[Algoritmul Luhn](https://en.wikipedia.org/wiki/Luhn_algorithm) este "
"utilizat pentru a valida numerele de carduri de credit. Algoritmul prime탳te "
"un 탳ir de caractere ca intrare 탳i face urm캒toarele pentru a valida num캒rul "
"cardului de credit:"

#: src/exercises/day-1/luhn.md:7
#, fuzzy
msgid "Ignore all spaces. Reject number with less than two digits."
msgstr "Ignora탵i toate spa탵iile. Respinge num캒rul cu mai pu탵in de dou캒 cifre."

#: src/exercises/day-1/luhn.md:9
#, fuzzy
msgid ""
"Moving from **right to left**, double every second digit: for the number "
"`1234`, we double `3` and `1`. For the number `98765`, we double `6` and `8`."
msgstr ""
"Merg칙nd de la **dreapta la st칙nga**, dubl캒m fiecare a doua cifr캒: pentru "
"num캒rul `1234`, dubl캒m `3` 탳i `1`. Pentru num캒rul `98765`, dubl캒m `6` 탳i `8`."

#: src/exercises/day-1/luhn.md:12
#, fuzzy
msgid ""
"After doubling a digit, sum the digits if the result is greater than 9. So "
"doubling `7` becomes `14` which becomes `1 + 4 = 5`."
msgstr ""
"Dup캒 ce a탵i dublat o cifr캒, aduna탵i cifrele dac캒 rezultatul este mai mare de "
"9. Astfel, dubl칙nd `7` devine `14` care devine `1 + 4 = 5`."

#: src/exercises/day-1/luhn.md:15
#, fuzzy
msgid "Sum all the undoubled and doubled digits."
msgstr "Aduna탵i toate cifrele nedublate 탳i dublate."

#: src/exercises/day-1/luhn.md:17
#, fuzzy
msgid "The credit card number is valid if the sum ends with `0`."
msgstr "Num캒rul cardului de credit este valabil dac캒 suma se termin캒 cu `0`."

#: src/exercises/day-1/luhn.md:19
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and implement the "
"function."
msgstr ""
"Copia탵i codul de mai jos 칥n <https://play.rust-lang.org/> 탳i implementa탵i "
"func탵ia."

#: src/exercises/day-1/luhn.md:21
#, fuzzy
msgid ""
"Try to solve the problem the \"simple\" way first, using `for` loops and "
"integers. Then, revisit the solution and try to implement it with iterators."
msgstr ""
"칉ncerca탵i s캒 rezolva탵i mai 칥nt칙i problema 칥n mod \"simplu\", folosind "
"buclele `for` 탳i numere 칥ntregi. Apoi, revede탵i solu탵ia 탳i 칥ncerca탵i s캒 o "
"implementa탵i cu iteratori."

#: src/exercises/day-1/luhn.md:25
#, fuzzy
msgid ""
"```rust\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub fn luhn(cc_number: &str) -> bool {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\"));\n"
"    assert!(!luhn(\"foo 0 0\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_empty_cc_number() {\n"
"    assert!(!luhn(\"\"));\n"
"    assert!(!luhn(\" \"));\n"
"    assert!(!luhn(\"  \"));\n"
"    assert!(!luhn(\"    \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_single_digit_cc_number() {\n"
"    assert!(!luhn(\"0\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_two_digit_cc_number() {\n"
"    assert!(luhn(\" 0 0 \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_valid_cc_number() {\n"
"    assert!(luhn(\"4263 9826 4026 9299\"));\n"
"    assert!(luhn(\"4539 3195 0343 6467\"));\n"
"    assert!(luhn(\"7992 7398 713\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_invalid_cc_number() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}\n"
"\n"
"#[allow(dead_code)]\n"
"fn main() {}\n"
"```"
msgstr ""
"```rust\n"
"// TODO: elimina탵i acest lucru atunci c칙nd a탵i terminat cu implementarea.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub fn luhn(cc_number: &str) -> bool {\n"
"    neimplementat!()\n"
"}\n"
"\n"
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\")));\n"
"    assert!(!luhn(\"foo 0 0\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_vid_num캒r_cc_vid() {\n"
"    assert!(!luhn(\"\")));\n"
"    assert!(!luhn(\" \")));\n"
"    assert!(!luhn(\" \")));\n"
"    assert!(!luhn(\" \")));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_single_digit_cc_number() {\n"
"    assert!(!luhn(\"0\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_two_digit_cc_number() {\n"
"    assert!(luhn(\" 0 0 0 \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_valid_cc_number() {\n"
"    assert!(luhn(\"4263 9826 4026 9299\")));\n"
"    assert!(luhn(\"4539 3195 0343 6467\")));\n"
"    assert!(luhn(\"7992 7398 713\")));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_invalid_cc_number() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\")));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\")));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\")));\n"
"}\n"
"\n"
"#[allow(dead_code)]\n"
"fn main() {}\n"
"```"

#: src/exercises/day-1/pattern-matching.md:1
#, fuzzy
msgid "Exercise: Expression Evaluation"
msgstr "Exerci탵iu: Evaluarea expresiilor"

#: src/exercises/day-1/pattern-matching.md:3
#, fuzzy
msgid "Let's write a simple recursive evaluator for arithmetic expressions. "
msgstr "S캒 scriem un evaluator recursiv simplu pentru expresii aritmetice."

#: src/exercises/day-1/pattern-matching.md:5
#, fuzzy
msgid ""
"```rust\n"
"/// An operation to perform on two subexpressions.\n"
"#[derive(Debug)]\n"
"enum Operation {\n"
"    Add,\n"
"    Sub,\n"
"    Mul,\n"
"    Div,\n"
"}\n"
"\n"
"/// An expression, in tree form.\n"
"#[derive(Debug)]\n"
"enum Expression {\n"
"    /// An operation on two subexpressions.\n"
"    Op {\n"
"        op: Operation,\n"
"        left: Box<Expression>,\n"
"        right: Box<Expression>,\n"
"    },\n"
"\n"
"    /// A literal value\n"
"    Value(i64),\n"
"}\n"
"\n"
"/// The result of evaluating an expression.\n"
"#[derive(Debug, PartialEq, Eq)]\n"
"enum Res {\n"
"    /// Evaluation was successful, with the given result.\n"
"    Ok(i64),\n"
"    /// Evaluation failed, with the given error message.\n"
"    Err(String),\n"
"}\n"
"// Allow `Ok` and `Err` as shorthands for `Res::Ok` and `Res::Err`.\n"
"use Res::{Err, Ok};\n"
"\n"
"fn eval(e: Expression) -> Res {\n"
"    todo!()\n"
"}\n"
"\n"
"#[test]\n"
"fn test_value() {\n"
"    assert_eq!(eval(Expression::Value(19)), Ok(19));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_sum() {\n"
"    assert_eq!(\n"
"        eval(Expression::Op {\n"
"            op: Operation::Add,\n"
"            left: Box::new(Expression::Value(10)),\n"
"            right: Box::new(Expression::Value(20)),\n"
"        }),\n"
"        Ok(30)\n"
"    );\n"
"}\n"
"\n"
"#[test]\n"
"fn test_recursion() {\n"
"    let term1 = Expression::Op {\n"
"        op: Operation::Mul,\n"
"        left: Box::new(Expression::Value(10)),\n"
"        right: Box::new(Expression::Value(9)),\n"
"    };\n"
"    let term2 = Expression::Op {\n"
"        op: Operation::Mul,\n"
"        left: Box::new(Expression::Op {\n"
"            op: Operation::Sub,\n"
"            left: Box::new(Expression::Value(3)),\n"
"            right: Box::new(Expression::Value(4)),\n"
"        }),\n"
"        right: Box::new(Expression::Value(5)),\n"
"    };\n"
"    assert_eq!(\n"
"        eval(Expression::Op {\n"
"            op: Operation::Add,\n"
"            left: Box::new(term1),\n"
"            right: Box::new(term2),\n"
"        }),\n"
"        Ok(85)\n"
"    );\n"
"}\n"
"\n"
"#[test]\n"
"fn test_error() {\n"
"    assert_eq!(\n"
"        eval(Expression::Op {\n"
"            op: Operation::Div,\n"
"            left: Box::new(Expression::Value(99)),\n"
"            right: Box::new(Expression::Value(0)),\n"
"        }),\n"
"        Err(String::from(\"division by zero\"))\n"
"    );\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"/// O opera탵ie care trebuie efectuat캒 asupra a dou캒 subexpresii.\n"
"#[derive(Debug)]\n"
"enum Operation {\n"
"    Add,\n"
"    Sub,\n"
"    Mul,\n"
"    Div,\n"
"}\n"
"\n"
"/// O expresie, 칥n form캒 de arbore.\n"
"#[derive(Debug)]\n"
"enum Expression {\n"
"    /// O opera탵ie asupra a dou캒 subexpresii.\n"
"    Op {\n"
"        op: Opera탵ie,\n"
"        left: Box<Expression>,\n"
"        dreapta: Caseta<Expression>,\n"
"    },\n"
"\n"
"    /// O valoare literal캒\n"
"    Valoare(i64),\n"
"}\n"
"\n"
"/// Rezultatul evalu캒rii unei expresii.\n"
"#[derive(Debug, PartialEq, Eq)]\n"
"enum Res {\n"
"    /// Evaluarea a avut succes, cu rezultatul dat.\n"
"    Ok(i64),\n"
"    /// Evaluarea a e탳uat, cu mesajul de eroare dat.\n"
"    Err(String),\n"
"}\n"
"// Permite탵i `Ok` 탳i `Err` ca prescurt캒ri pentru `Res::Ok` 탳i `Res::Err`.\n"
"use Res::{Err, Ok};\n"
"\n"
"fn eval(e: Expression) -&gt; Res {\n"
"    todo!()\n"
"}\n"
"\n"
"#[test]\n"
"fn test_value() {\n"
"    assert_eq!(eval(Expression::Value(19)), Ok(19));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_sum() {\n"
"    assert_eq!(\n"
"        eval(Expression::Op {\n"
"            op: Operation::Add,\n"
"            left: Box::new(Expression::Value(10)),\n"
"            right: Box::new(Expression::Value(20)),\n"
"        }),\n"
"        Ok(30)\n"
"    );\n"
"}\n"
"\n"
"#[test]\n"
"fn test_recursiune_test() {\n"
"    let term1 = Expression::Op {\n"
"        op: Operation::Mul,\n"
"        left: Box::new(Expression::Value(10)),\n"
"        right: Box::new(Expression::Value(9)),\n"
"    };\n"
"    let term2 = Expression::Op {\n"
"        op: Operation::Mul,\n"
"        left: Box::new(Expression::Op {\n"
"            op: Operation::Sub,\n"
"            left: Box::new(Expression::Value(3)),\n"
"            right: Box::new(Expresie::Valoare(4)),\n"
"        }),\n"
"        dreapta: Box::new(Expression::Value(5)),\n"
"    };\n"
"    assert_eq!(\n"
"        eval(Expression::Op {\n"
"            op: Operation::Add,\n"
"            left: Box::new(term1),\n"
"            right: Box::new(term2),\n"
"        }),\n"
"        Ok(85)\n"
"    );\n"
"}\n"
"\n"
"#[test]\n"
"fn test_error() {\n"
"    assert_eq!(\n"
"        eval(Expression::Op {\n"
"            op: Operation::Div,\n"
"            left: Box::new(Expression::Value(99)),\n"
"            right: Box::new(Expresie::Valoare(0)),\n"
"        }),\n"
"        Err(String::from(\"칥mp캒r탵ire la zero\"))\n"
"    );\n"
"}\n"
"```"

#: src/exercises/day-1/pattern-matching.md:100
#, fuzzy
msgid ""
"The `Box` type here is a smart pointer, and will be covered in detail later "
"in the course. An expression can be \"boxed\" with `Box::new` as seen in the "
"tests. To evaluate a boxed expression, use the deref operator to \"unbox\" "
"it: `eval(*boxed_expr)`."
msgstr ""
"Tipul `Box` de aici este un pointer inteligent 탳i va fi tratat 칥n detaliu "
"mai t칙rziu 칥n curs. O expresie poate fi \"boxat캒\" cu `Box::new`, a탳a cum se "
"vede 칥n teste. Pentru a evalua o expresie boxat캒, utiliza탵i operatorul deref "
"pentru a o \"desface\": `eval(*boxed_expr)`."

#: src/exercises/day-1/pattern-matching.md:105
#, fuzzy
msgid ""
"Some expressions cannot be evaluated and will return an error. The `Res` "
"type represents either a successful value or an error with a message. This "
"is very similar to the standard-library `Result` which we will see later."
msgstr ""
"Unele expresii nu pot fi evaluate 탳i vor returna o eroare. Tipul `Res` "
"reprezint캒 fie o valoare de succes, fie o eroare cu un mesaj. Acest tip este "
"foarte asem캒n캒tor cu `Result` din biblioteca standard, pe care 칥l vom vedea "
"mai t칙rziu."

#: src/exercises/day-1/pattern-matching.md:109
#, fuzzy
msgid ""
"Copy and paste the code into the Rust playground, and begin implementing "
"`eval`. The final product should pass the tests. It may be helpful to use "
"`todo!()` and get the tests to pass one-by-one."
msgstr ""
"Copia탵i 탳i lipi탵i codul 칥n locul de joac캒 Rust 탳i 칥ncepe탵i s캒 implementa탵i "
"`eval`. Produsul final ar trebui s캒 treac캒 testele. Poate fi util s캒 "
"folosi탵i `todo!()` 탳i s캒 ob탵ine탵i testele s캒 treac캒 unul c칙te unul."

#: src/exercises/day-1/pattern-matching.md:113
#, fuzzy
msgid ""
"If you finish early, try writing a test that results in an integer overflow. "
"How could you handle this with `Res::Err` instead of a panic?"
msgstr ""
"Dac캒 termina탵i mai devreme, 칥ncerca탵i s캒 scrie탵i un test care are ca "
"rezultat o dep캒탳ire de num캒r 칥ntreg. Cum a탵i putea gestiona acest lucru cu "
"`Res::Err` 칥n loc de o panic캒?"

#: src/welcome-day-2.md:1
#, fuzzy
msgid "Welcome to Day 2"
msgstr "Bine a탵i venit 칥n ziua 2"

#: src/welcome-day-2.md:3
#, fuzzy
msgid "Now that we have seen a fair amount of Rust, we will continue with:"
msgstr ""
"Acum, c캒 am v캒zut o cantitate destul de mare de rugin캒, vom continua cu:"

#: src/welcome-day-2.md:5
#, fuzzy
msgid ""
"Memory management: stack vs heap, manual memory management, scope-based "
"memory management, and garbage collection."
msgstr ""
"Gestionarea memoriei: stiv캒 vs. heap, gestionarea manual캒 a memoriei, "
"gestionarea memoriei pe baza domeniului de aplicare 탳i colectarea gunoiului."

#: src/welcome-day-2.md:8
#, fuzzy
msgid ""
"Ownership: move semantics, copying and cloning, borrowing, and lifetimes."
msgstr ""
"Proprietatea: semantica mut캒rii, copierea 탳i clonarea, 칥mprumutul 탳i durata "
"de via탵캒."

#: src/welcome-day-2.md:10
#, fuzzy
msgid "Structs and methods."
msgstr "Structuri 탳i metode."

#: src/welcome-day-2.md:12
#, fuzzy
msgid ""
"The Standard Library: `String`, `Option` and `Result`, `Vec`, `HashMap`, "
"`Rc` and `Arc`."
msgstr ""
"Biblioteca standard: `String`, `Option` 탳i `Result`, `Vec`, `HashMap`, `Rc` "
"탳i `Arc`."

#: src/welcome-day-2.md:15
#, fuzzy
msgid "Modules: visibility, paths, and filesystem hierarchy."
msgstr "Module: vizibilitate, c캒i de acces 탳i ierarhia sistemului de fi탳iere."

#: src/memory-management.md:3
#, fuzzy
msgid "Traditionally, languages have fallen into two broad categories:"
msgstr "칉n mod tradi탵ional, limbile se 칥mpart 칥n dou캒 mari categorii:"

#: src/memory-management.md:5
#, fuzzy
msgid "Full control via manual memory management: C, C++, Pascal, ..."
msgstr "Control total prin gestionarea manual캒 a memoriei: C, C++, Pascal, ..."

#: src/memory-management.md:6
#, fuzzy
msgid ""
"Full safety via automatic memory management at runtime: Java, Python, Go, "
"Haskell, ..."
msgstr ""
"Siguran탵캒 total캒 prin gestionarea automat캒 a memoriei 칥n timpul execu탵iei: "
"Java, Python, Go, Haskell, ..."

#: src/memory-management.md:8
#, fuzzy
msgid "Rust offers a new mix:"
msgstr "Rust ofer캒 un nou amestec:"

#: src/memory-management.md:10
#, fuzzy
msgid ""
"Full control _and_ safety via compile time enforcement of correct memory "
"management."
msgstr ""
"Control total _탳i_ siguran탵캒 prin aplicarea 칥n timp de compilare a "
"gestion캒rii corecte a memoriei."

#: src/memory-management.md:13
#, fuzzy
msgid "It does this with an explicit ownership concept."
msgstr ""
"Acest lucru se realizeaz캒 cu ajutorul unui concept explicit de proprietate."

#: src/memory-management.md:15
#, fuzzy
msgid "First, let's refresh how memory management works."
msgstr ""
"칉n primul r칙nd, s캒 re칥mprosp캒t캒m modul 칥n care func탵ioneaz캒 gestionarea "
"memoriei."

#: src/memory-management/stack-vs-heap.md:1
#, fuzzy
msgid "The Stack vs The Heap"
msgstr "Stiva vs gr캒mada"

#: src/memory-management/stack-vs-heap.md:3
#, fuzzy
msgid "Stack: Continuous area of memory for local variables."
msgstr "Stack: Zona continu캒 de memorie pentru variabilele locale."

#: src/memory-management/stack-vs-heap.md:4
#, fuzzy
msgid "Values have fixed sizes known at compile time."
msgstr "Valorile au dimensiuni fixe cunoscute 칥n momentul compil캒rii."

#: src/memory-management/stack-vs-heap.md:5
#, fuzzy
msgid "Extremely fast: just move a stack pointer."
msgstr "Extrem de rapid: este suficient s캒 muta탵i un pointer de stiv캒."

#: src/memory-management/stack-vs-heap.md:6
#, fuzzy
msgid "Easy to manage: follows function calls."
msgstr "U탳or de gestionat: urm캒re탳te apelurile de func탵ii."

#: src/memory-management/stack-vs-heap.md:7
#, fuzzy
msgid "Great memory locality."
msgstr "Localitate de mare memorie."

#: src/memory-management/stack-vs-heap.md:9
#, fuzzy
msgid "Heap: Storage of values outside of function calls."
msgstr "Gr캒mad캒: Stocarea valorilor 칥n afara apelurilor de func탵ii."

#: src/memory-management/stack-vs-heap.md:10
#, fuzzy
msgid "Values have dynamic sizes determined at runtime."
msgstr "Valorile au dimensiuni dinamice determinate la momentul execu탵iei."

#: src/memory-management/stack-vs-heap.md:11
#, fuzzy
msgid "Slightly slower than the stack: some book-keeping needed."
msgstr "Pu탵in mai lent dec칙t stiva: este nevoie de o anumit캒 contabilitate."

#: src/memory-management/stack-vs-heap.md:12
#, fuzzy
msgid "No guarantee of memory locality."
msgstr "Nu exist캒 nicio garan탵ie a localit캒탵ii de memorie."

#: src/memory-management/stack.md:1
#, fuzzy
msgid "Stack and Heap Example"
msgstr "Exemplu de stiv캒 탳i heap"

#: src/memory-management/stack.md:3
#, fuzzy
msgid ""
"Creating a `String` puts fixed-sized metadata on the stack and dynamically "
"sized data, the actual string, on the heap:"
msgstr ""
"Crearea unui `String` plaseaz캒 metadatele de dimensiuni fixe pe stiv캒 탳i "
"datele de dimensiuni dinamice, 탳irul propriu-zis, pe heap:"

#: src/memory-management/stack.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1 = String::from(\"Hello\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    let s1 = String::from(\"Hello\");\n"
"}\n"
"```"

#: src/memory-management/stack.md:28
#, fuzzy
msgid ""
"Mention that a `String` is backed by a `Vec`, so it has a capacity and "
"length and can grow if mutable via reallocation on the heap."
msgstr ""
"Men탵iona탵i c캒 un `String` este sus탵inut de un `Vec`, deci are o capacitate "
"탳i o lungime 탳i poate cre탳te dac캒 este mutabil prin realocare pe heap."

#: src/memory-management/stack.md:30
#, fuzzy
msgid ""
"If students ask about it, you can mention that the underlying memory is heap "
"allocated using the [System Allocator](https://doc.rust-lang.org/std/alloc/"
"struct.System.html) and custom allocators can be implemented using the "
"[Allocator API](https://doc.rust-lang.org/std/alloc/index.html)"
msgstr ""
"Dac캒 elevii v캒 칥ntreab캒 despre acest lucru, pute탵i men탵iona c캒 memoria de "
"baz캒 este alocat캒 칥n heap cu ajutorul [System Allocator](https://doc.rust-"
"lang.org/std/alloc/struct.System.html) 탳i c캒 alocatorii personaliza탵i pot fi "
"implementa탵i cu ajutorul [Allocator API](https://doc.rust-lang.org/std/alloc/"
"index.html)"

#: src/memory-management/stack.md:34
#, fuzzy
msgid ""
"We can inspect the memory layout with `unsafe` Rust. However, you should "
"point out that this is rightfully unsafe!"
msgstr ""
"Putem inspecta dispunerea memoriei cu `unsafe` Rust. Cu toate acestea, ar "
"trebui s캒 preciza탵i c캒 acest lucru este, pe bun캒 dreptate, nesigur!"

#: src/memory-management/stack.md:37
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::from(\"Hello\");\n"
"    s1.push(' ');\n"
"    s1.push_str(\"world\");\n"
"    // DON'T DO THIS AT HOME! For educational purposes only.\n"
"    // String provides no guarantees about its layout, so this could lead "
"to\n"
"    // undefined behavior.\n"
"    unsafe {\n"
"        let (ptr, capacity, len): (usize, usize, usize) = std::mem::"
"transmute(s1);\n"
"        println!(\"ptr = {ptr:#x}, len = {len}, capacity = {capacity}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    let mut s1 = String::from(\"Hello\");\n"
"    s1.push(' ');\n"
"    s1.push_str(\"lume\");\n"
"    // NU FACE탴I ASTA ACAS캑! Doar 칥n scopuri educa탵ionale.\n"
"    // String nu ofer캒 nicio garan탵ie cu privire la aspectul s캒u, astfel "
"칥nc칙t acest lucru ar putea duce la\n"
"    // un comportament nedefinit.\n"
"    unsafe {\n"
"        let (ptr, capacity, len): (usize, usize, usize, usize) = std::mem::"
"transmute(s1);\n"
"        println!(\"ptr = {ptr:#x}, len = {len}, capacity = {capacity}\");\n"
"    }\n"
"}\n"
"```"

#: src/memory-management/manual.md:3
#, fuzzy
msgid "You allocate and deallocate heap memory yourself."
msgstr "Aloca탵i 탳i dezaloca탵i singur memoria heap."

#: src/memory-management/manual.md:5
#, fuzzy
msgid ""
"If not done with care, this can lead to crashes, bugs, security "
"vulnerabilities, and memory leaks."
msgstr ""
"Dac캒 nu se face cu aten탵ie, acest lucru poate duce la bloc캒ri, erori, "
"vulnerabilit캒탵i de securitate 탳i pierderi de memorie."

#: src/memory-management/manual.md:7
#, fuzzy
msgid "C Example"
msgstr "C Exemplu"

#: src/memory-management/manual.md:9
#, fuzzy
msgid "You must call `free` on every pointer you allocate with `malloc`:"
msgstr ""
"Trebuie s캒 apela탵i `free` pentru fiecare pointer pe care 칥l aloca탵i cu "
"`malloc`:"

#: src/memory-management/manual.md:11
#, fuzzy
msgid ""
"```c\n"
"void foo(size_t n) {\n"
"    int* int_array = malloc(n * sizeof(int));\n"
"    //\n"
"    // ... lots of code\n"
"    //\n"
"    free(int_array);\n"
"}\n"
"```"
msgstr ""
"```c\n"
"void foo(size_t n) {\n"
"    int* int_array = malloc(n * sizeof(int));\n"
"    //\n"
"    // ... o mul탵ime de cod\n"
"    //\n"
"    free(int_array);\n"
"}\n"
"```"

#: src/memory-management/manual.md:21
#, fuzzy
msgid ""
"Memory is leaked if the function returns early between `malloc` and `free`: "
"the pointer is lost and we cannot deallocate the memory. Worse, freeing the "
"pointer twice, or accessing a freed pointer can lead to exploitable security "
"vulnerabilities."
msgstr ""
"Memoria este pierdut캒 dac캒 func탵ia se 칥ntoarce mai devreme 칥ntre `malloc` 탳i "
"`free`: pointerul este pierdut 탳i nu putem dezaloca memoria. Mai r캒u, "
"eliberarea de dou캒 ori a pointerului sau accesarea unui pointer eliberat "
"poate duce la vulnerabilit캒탵i de securitate exploatabile."

#: src/memory-management/scope-based.md:3
#, fuzzy
msgid ""
"Constructors and destructors let you hook into the lifetime of an object."
msgstr ""
"Constructori 탳i destructori v캒 permit s캒 v캒 conecta탵i la durata de via탵캒 a "
"unui obiect."

#: src/memory-management/scope-based.md:5
#, fuzzy
msgid ""
"By wrapping a pointer in an object, you can free memory when the object is "
"destroyed. The compiler guarantees that this happens, even if an exception "
"is raised."
msgstr ""
"Prin includerea unui pointer 칥ntr-un obiect, pute탵i elibera memoria atunci "
"c칙nd obiectul este distrus. Compilatorul garanteaz캒 c캒 acest lucru se va "
"칥nt칙mpla, chiar dac캒 este ridicat캒 o excep탵ie."

#: src/memory-management/scope-based.md:9
#, fuzzy
msgid ""
"This is often called _resource acquisition is initialization_ (RAII) and "
"gives you smart pointers."
msgstr ""
"Acest lucru se nume탳te adesea _achizi탵ionarea resurselor este ini탵ializare_ "
"(RAII) 탳i v캒 ofer캒 pointeri inteligen탵i."

#: src/memory-management/scope-based.md:12
#, fuzzy
msgid "C++ Example"
msgstr "Exemplu C++"

#: src/memory-management/scope-based.md:14
#, fuzzy
msgid ""
"```c++\n"
"void say_hello(std::unique_ptr<Person> person) {\n"
"  std::cout << \"Hello \" << person->name << std::endl;\n"
"}\n"
"```"
msgstr ""
"```c++\n"
"void say_hello(std::unique_ptr<Person> person) {\n"
"  std::cout &lt;&lt; \"Bun캒 ziua \" &lt;< person->nume &lt;&lt; std::endl;\n"
"}\n"
"```"

#: src/memory-management/scope-based.md:20
#, fuzzy
msgid ""
"The `std::unique_ptr` object is allocated on the stack, and points to memory "
"allocated on the heap."
msgstr ""
"Obiectul `std::unique_ptr` este alocat pe stiv캒 탳i indic캒 memoria alocat캒 pe "
"heap."

#: src/memory-management/scope-based.md:22
#, fuzzy
msgid "At the end of `say_hello`, the `std::unique_ptr` destructor will run."
msgstr ""
"La sf칙r탳itul lui `say_hello`, se va executa destructorul `std::unique_ptr`."

#: src/memory-management/scope-based.md:23
#, fuzzy
msgid "The destructor frees the `Person` object it points to."
msgstr "Distrug캒torul elibereaz캒 obiectul `Person` pe care 칥l indic캒."

#: src/memory-management/scope-based.md:25
#, fuzzy
msgid ""
"Special move constructors are used when passing ownership to a function:"
msgstr ""
"Constructorii de mi탳care special캒 sunt utiliza탵i atunci c칙nd se transmite "
"proprietatea unei func탵ii:"

#: src/memory-management/garbage-collection.md:1
#, fuzzy
msgid "Automatic Memory Management"
msgstr "Gestionarea automat캒 a memoriei"

#: src/memory-management/garbage-collection.md:3
#, fuzzy
msgid ""
"An alternative to manual and scope-based memory management is automatic "
"memory management:"
msgstr ""
"O alternativ캒 la gestionarea manual캒 a memoriei 탳i la cea bazat캒 pe domeniul "
"de aplicare este gestionarea automat캒 a memoriei:"

#: src/memory-management/garbage-collection.md:6
#, fuzzy
msgid "The programmer never allocates or deallocates memory explicitly."
msgstr ""
"Programatorul nu aloc캒 탳i nu dezaloc캒 niciodat캒 memoria 칥n mod explicit."

#: src/memory-management/garbage-collection.md:7
#, fuzzy
msgid ""
"A garbage collector finds unused memory and deallocates it for the "
"programmer."
msgstr ""
"Un colector de gunoi g캒se탳te memoria neutilizat캒 탳i o dezaloc캒 pentru "
"programator."

#: src/memory-management/garbage-collection.md:9
#, fuzzy
msgid "Java Example"
msgstr "Exemplu Java"

#: src/memory-management/garbage-collection.md:11
#, fuzzy
msgid "The `person` object is not deallocated after `sayHello` returns:"
msgstr "Obiectul `person` nu este dezalocat dup캒 ce `sayHello` se 칥ntoarce:"

#: src/memory-management/garbage-collection.md:13
#, fuzzy
msgid ""
"```java\n"
"void sayHello(Person person) {\n"
"  System.out.println(\"Hello \" + person.getName());\n"
"}\n"
"```"
msgstr ""
"```java\n"
"void sayHello(Person person person) {\n"
"  System.out.println(\"Hello \" + person.getName());\n"
"}\n"
"```"

#: src/memory-management/rust.md:1
#, fuzzy
msgid "Memory Management in Rust"
msgstr "Gestionarea memoriei 칥n Rust"

#: src/memory-management/rust.md:3
#, fuzzy
msgid "Memory management in Rust is a mix:"
msgstr "Gestionarea memoriei 칥n Rust este un amestec:"

#: src/memory-management/rust.md:5
#, fuzzy
msgid "Safe and correct like Java, but without a garbage collector."
msgstr "Sigur 탳i corect ca Java, dar f캒r캒 un colector de gunoi."

#: src/memory-management/rust.md:6
#, fuzzy
msgid "Scope-based like C++, but the compiler enforces full adherence."
msgstr ""
"Bazat pe domeniul de aplicare, ca 탳i 칥n cazul C++, dar compilatorul impune o "
"aderen탵캒 total캒."

#: src/memory-management/rust.md:7
#, fuzzy
msgid ""
"A Rust user can choose the right abstraction for the situation, some even "
"have no cost at runtime like C."
msgstr ""
"Un utilizator Rust poate alege abstractizarea potrivit캒 pentru situa탵ia "
"respectiv캒, unele chiar nu au niciun cost la execu탵ie, precum C."

#: src/memory-management/rust.md:9
#, fuzzy
msgid "Rust achieves this by modeling _ownership_ explicitly."
msgstr "Rust realizeaz캒 acest lucru prin modelarea explicit캒 a _propriet캒탵ii_."

#: src/memory-management/rust.md:13
#, fuzzy
msgid ""
"If asked how at this point, you can mention that in Rust this is usually "
"handled by RAII wrapper types such as [Box](https://doc.rust-lang.org/std/"
"boxed/struct.Box.html), [Vec](https://doc.rust-lang.org/std/vec/struct.Vec."
"html), [Rc](https://doc.rust-lang.org/std/rc/struct.Rc.html), or [Arc]"
"(https://doc.rust-lang.org/std/sync/struct.Arc.html). These encapsulate "
"ownership and memory allocation via various means, and prevent the potential "
"errors in C."
msgstr ""
"Dac캒 sunte탵i 칥ntrebat cum 칥n acest moment, pute탵i men탵iona c캒 칥n Rust acest "
"lucru este de obicei gestionat de tipurile de 칥nveli탳 RAII, cum ar fi [Box]"
"(https://doc.rust-lang.org/std/boxed/struct.Box.html), [Vec](https://doc."
"rust-lang.org/std/vec/struct.Vec.html), [Rc](https://doc.rust-lang.org/std/"
"rc/struct.Rc.html) sau [Arc](https://doc.rust-lang.org/std/sync/struct.Arc."
"html). Acestea 칥ncapsuleaz캒 proprietatea 탳i alocarea memoriei prin diverse "
"mijloace 탳i previn poten탵ialele erori din C."

#: src/memory-management/rust.md:15
#, fuzzy
msgid ""
"You may be asked about destructors here, the [Drop](https://doc.rust-lang."
"org/std/ops/trait.Drop.html) trait is the Rust equivalent."
msgstr ""
"S-ar putea s캒 fi탵i 칥ntrebat despre destructori aici, tr캒s캒tura [Drop]"
"(https://doc.rust-lang.org/std/ops/trait.Drop.html) este echivalentul Rust."

#: src/ownership.md:3
#, fuzzy
msgid ""
"All variable bindings have a _scope_ where they are valid and it is an error "
"to use a variable outside its scope:"
msgstr ""
"Toate leg캒turile de variabile au un _scop_ 칥n care sunt valabile 탳i este o "
"eroare s캒 folose탳ti o variabil캒 칥n afara domeniului s캒u de aplicare:"

#: src/ownership.md:19
#, fuzzy
msgid ""
"At the end of the scope, the variable is _dropped_ and the data is freed."
msgstr ""
"La sf칙r탳itul domeniului de aplicare, variabila este \"eliminat캒\", iar "
"datele sunt eliberate."

#: src/ownership.md:20
#, fuzzy
msgid "A destructor can run here to free up resources."
msgstr "Un destructor poate fi executat aici pentru a elibera resurse."

#: src/ownership.md:21
#, fuzzy
msgid "We say that the variable _owns_ the value."
msgstr "Spunem c캒 variabila _de탵ine_ valoarea."

#: src/ownership/move-semantics.md:3
#, fuzzy
msgid "An assignment will transfer _ownership_ between variables:"
msgstr "O atribuire va transfera _proprietatea_ 칥ntre variabile:"

#: src/ownership/move-semantics.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Hello!\");\n"
"    let s2: String = s1;\n"
"    println!(\"s2: {s2}\");\n"
"    // println!(\"s1: {s1}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    let s1: String = String::from(\"Hello!\");\n"
"    let s2: String = s1;\n"
"    println!(\"s2: {s2}\");\n"
"    // println!(\"s1: {s1}\");\n"
"}\n"
"```"

#: src/ownership/move-semantics.md:14
#, fuzzy
msgid "The assignment of `s1` to `s2` transfers ownership."
msgstr "Atribuirea lui `s1` la `s2` transfer캒 proprietatea."

#: src/ownership/move-semantics.md:15
#, fuzzy
msgid "When `s1` goes out of scope, nothing happens: it does not own anything."
msgstr ""
"C칙nd `s1` iese din domeniul de aplicare, nu se 칥nt칙mpl캒 nimic: nu de탵ine "
"nimic."

#: src/ownership/move-semantics.md:16
#, fuzzy
msgid "When `s2` goes out of scope, the string data is freed."
msgstr ""
"Atunci c칙nd `s2` iese din domeniul de aplicare, datele 탳irului de caractere "
"sunt eliberate."

#: src/ownership/move-semantics.md:17
#, fuzzy
msgid "There is always _exactly_ one variable binding which owns a value."
msgstr ""
"Exist캒 칥ntotdeauna _exact_ o singur캒 leg캒tur캒 de variabil캒 care de탵ine o "
"valoare."

#: src/ownership/move-semantics.md:21
#, fuzzy
msgid ""
"Mention that this is the opposite of the defaults in C++, which copies by "
"value unless you use `std::move` (and the move constructor is defined!)."
msgstr ""
"Men탵iona탵i c캒 acest lucru este opusul valorilor implicite din C++, care "
"copiaz캒 prin valoare, cu excep탵ia cazului 칥n care folosi탵i `std::move` (탳i "
"constructorul move este definit!)."

#: src/ownership/move-semantics.md:23
#, fuzzy
msgid ""
"It is only the ownership that moves. Whether any machine code is generated "
"to manipulate the data itself is a matter of optimization, and such copies "
"are aggressively optimized away."
msgstr ""
"Doar proprietatea este cea care se mi탳c캒. Dac캒 este generat vreun cod ma탳in캒 "
"pentru a manipula datele 칥n sine este o chestiune de optimizare, iar astfel "
"de copii sunt optimizate 칥n mod agresiv."

#: src/ownership/move-semantics.md:25
#, fuzzy
msgid ""
"Simple values (such as integers) can be marked `Copy` (see later slides)."
msgstr ""
"Valorile simple (cum ar fi numerele 칥ntregi) pot fi marcate cu `Copy` (a se "
"vedea slide-urile ulterioare)."

#: src/ownership/move-semantics.md:27
#, fuzzy
msgid "In Rust, clones are explicit (by using `clone`)."
msgstr "칉n Rust, clonele sunt explicite (prin utilizarea lui `clone`)."

#: src/ownership/moved-strings-rust.md:11
#, fuzzy
msgid "The heap data from `s1` is reused for `s2`."
msgstr "Datele heap din `s1` sunt reutilizate pentru `s2`."

#: src/ownership/moved-strings-rust.md:12
#, fuzzy
msgid "When `s1` goes out of scope, nothing happens (it has been moved from)."
msgstr ""
"C칙nd `s1` iese din domeniul de aplicare, nu se 칥nt칙mpl캒 nimic (a fost mutat "
"din)."

#: src/ownership/moved-strings-rust.md:14
#, fuzzy
msgid "Before move to `s2`:"
msgstr "칉nainte de mutarea 칥n `s2`:"

#: src/ownership/moved-strings-rust.md:31
#, fuzzy
msgid "After move to `s2`:"
msgstr "Dup캒 mutarea 칥n `s2`:"

#: src/ownership/moved-strings-rust.md:33
#, fuzzy
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"(inaccessible)\"    :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :  |  :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :  |  :                           :\n"
":   +-----------+-------+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     4 |   :\n"
":   | capacity  |     4 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stiva Heap\n"
".- - - - - - - - - - - - - -. .- - - - - - - - - - - - - -.\n"
": : : :\n"
": s1 \"(inaccesibil)\" : : :\n"
":   +-----------+-------+ : : +----+----+----+----+ :\n"
":   | ptr | o---+-+---+--+--+-->| R | u | s | t | :\n"
":   | len | 4 | :  | : +----+----+----+----+ :\n"
":   | capacitate | 4 | :  | : :\n"
":   +-----------+-------+ :  | : :\n"
": :  | `- - - - - - - - - - - - - -'\n"
": s2 :  |\n"
":   +-----------+-------+ :  |\n"
":   | ptr | o---+-+-+-+---''\n"
":   | len | 4 | :\n"
":   | capacitate | 4 | :\n"
":   +-----------+-------+ :\n"
": :\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/ownership/double-free-modern-cpp.md:1
#, fuzzy
msgid "Defensive Copies in Modern C++"
msgstr "Copii defensive 칥n C++ modern"

#: src/ownership/double-free-modern-cpp.md:3
#, fuzzy
msgid "Modern C++ solves this differently:"
msgstr "C++ modern rezolv캒 acest lucru 칥n mod diferit:"

#: src/ownership/double-free-modern-cpp.md:5
#, fuzzy
msgid ""
"```c++\n"
"std::string s1 = \"Cpp\";\n"
"std::string s2 = s1;  // Duplicate the data in s1.\n"
"```"
msgstr ""
"```c++\n"
"std::string s1 = \"Cpp\";\n"
"std::string s2 = s1; // Duplic캒 datele din s1.\n"
"```"

#: src/ownership/double-free-modern-cpp.md:10
#, fuzzy
msgid ""
"The heap data from `s1` is duplicated and `s2` gets its own independent copy."
msgstr ""
"Datele din heap de la `s1` sunt duplicate, iar `s2` prime탳te propria copie "
"independent캒."

#: src/ownership/double-free-modern-cpp.md:11
#, fuzzy
msgid "When `s1` and `s2` go out of scope, they each free their own memory."
msgstr ""
"Atunci c칙nd `s1` 탳i `s2` ies din domeniul de aplicare, fiecare 칥탳i "
"elibereaz캒 propria memorie."

#: src/ownership/double-free-modern-cpp.md:13
#, fuzzy
msgid "Before copy-assignment:"
msgstr "칉nainte de atribuirea de copii:"

#: src/ownership/double-free-modern-cpp.md:30
#, fuzzy
msgid "After copy-assignment:"
msgstr "Dup캒 atribuirea de copii:"

#: src/ownership/double-free-modern-cpp.md:57
#, fuzzy
msgid ""
"C++ has made a slightly different choice than Rust. Because `=` copies data, "
"the string data has to be cloned. Otherwise we would get a double-free when "
"either string goes out of scope."
msgstr ""
"C++ a f캒cut o alegere u탳or diferit캒 fa탵캒 de Rust. Deoarece `=` copiaz캒 date, "
"datele 탳irului de caractere trebuie clonate. 칉n caz contrar, am ob탵ine un "
"dublu liber atunci c칙nd oricare dintre 탳iruri iese din domeniu."

#: src/ownership/double-free-modern-cpp.md:61
#, fuzzy
msgid ""
"C++ also has [`std::move`](https://en.cppreference.com/w/cpp/utility/move), "
"which is used to indicate when a value may be moved from. If the example had "
"been `s2 = std::move(s1)`, no heap allocation would take place. After the "
"move, `s1` would be in a valid but unspecified state. Unlike Rust, the "
"programmer is allowed to keep using `s1`."
msgstr ""
"C++ are, de asemenea, [`std::move`](https://en.cppreference.com/w/cpp/"
"utility/move), care este utilizat pentru a indica c칙nd o valoare poate fi "
"mutat캒. Dac캒 exemplul ar fi fost `s2 = std::move(s1)`, nu ar fi avut loc "
"nicio alocare de heap. Dup캒 mutare, `s1` ar fi 칥ntr-o stare valid캒, dar "
"nespecificat캒. Spre deosebire de Rust, programatorului i se permite s캒 "
"continue s캒 foloseasc캒 `s1`."

#: src/ownership/double-free-modern-cpp.md:66
#, fuzzy
msgid ""
"Unlike Rust, `=` in C++ can run arbitrary code as determined by the type "
"which is being copied or moved."
msgstr ""
"Spre deosebire de Rust, `=` 칥n C++ poate rula cod arbitrar 칥n func탵ie de "
"tipul care este copiat sau mutat."

#: src/ownership/moves-function-calls.md:3
#, fuzzy
msgid ""
"When you pass a value to a function, the value is assigned to the function "
"parameter. This transfers ownership:"
msgstr ""
"Atunci c칙nd transmite탵i o valoare unei func탵ii, valoarea este atribuit캒 "
"parametrului func탵iei. Acest lucru transfer캒 proprietatea:"

#: src/ownership/moves-function-calls.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn say_hello(name: String) {\n"
"    println!(\"Hello {name}\")\n"
"}\n"
"\n"
"fn main() {\n"
"    let name = String::from(\"Alice\");\n"
"    say_hello(name);\n"
"    // say_hello(name);\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn say_hello(name: String) {\n"
"    println!(\"Bun캒 ziua {name}\")\n"
"}\n"
"\n"
"fn main() {\n"
"    let name = String::from(\"Alice\");\n"
"    say_hello(name);\n"
"    // say_hello(name);\n"
"}\n"
"```"

#: src/ownership/moves-function-calls.md:20
#, fuzzy
msgid ""
"With the first call to `say_hello`, `main` gives up ownership of `name`. "
"Afterwards, `name` cannot be used anymore within `main`."
msgstr ""
"Odat캒 cu primul apel la `say_hello`, `main` renun탵캒 la proprietatea asupra "
"lui `name`. Ulterior, `name` nu mai poate fi utilizat 칥n `main`."

#: src/ownership/moves-function-calls.md:21
#, fuzzy
msgid ""
"The heap memory allocated for `name` will be freed at the end of the "
"`say_hello` function."
msgstr ""
"Memoria heap alocat캒 pentru `name` va fi eliberat캒 la sf칙r탳itul func탵iei "
"`say_hello`."

#: src/ownership/moves-function-calls.md:22
#, fuzzy
msgid ""
"`main` can retain ownership if it passes `name` as a reference (`&name`) and "
"if `say_hello` accepts a reference as a parameter."
msgstr ""
"`main` poate p캒stra proprietatea dac캒 transmite `name` ca referin탵캒 "
"(`&name`) 탳i dac캒 `say_hello` accept캒 o referin탵캒 ca parametru."

#: src/ownership/moves-function-calls.md:23
#, fuzzy
msgid ""
"Alternatively, `main` can pass a clone of `name` in the first call (`name."
"clone()`)."
msgstr ""
"Alternativ, `main` poate transmite o clon캒 a lui `name` la primul apel "
"(`name.clone()`)."

#: src/ownership/moves-function-calls.md:24
#, fuzzy
msgid ""
"Rust makes it harder than C++ to inadvertently create copies by making move "
"semantics the default, and by forcing programmers to make clones explicit."
msgstr ""
"Rust face mai dificil캒 dec칙t C++ crearea de copii din gre탳eal캒, f캒c칙nd ca "
"semantica de mutare s캒 fie cea implicit캒 탳i oblig칙nd programatorii s캒 fac캒 "
"clonele explicite."

#: src/ownership/copy-clone.md:3
#, fuzzy
msgid ""
"While move semantics are the default, certain types are copied by default:"
msgstr ""
"칉n timp ce semantica de mutare este cea implicit캒, anumite tipuri sunt "
"copiate 칥n mod implicit:"

#: src/ownership/copy-clone.md:15
#, fuzzy
msgid "These types implement the `Copy` trait."
msgstr "Aceste tipuri implementeaz캒 tr캒s캒tura `Copy`."

#: src/ownership/copy-clone.md:17
#, fuzzy
msgid "You can opt-in your own types to use copy semantics:"
msgstr ""
"Pute탵i opta pentru ca propriile tipuri s캒 utilizeze semantica de copiere:"

#: src/ownership/copy-clone.md:32
#, fuzzy
msgid "After the assignment, both `p1` and `p2` own their own data."
msgstr "Dup캒 atribuire, at칙t `p1` c칙t 탳i `p2` de탵in propriile date."

#: src/ownership/copy-clone.md:33
#, fuzzy
msgid "We can also use `p1.clone()` to explicitly copy the data."
msgstr "De asemenea, putem folosi `p1.clone()` pentru a copia explicit datele."

#: src/ownership/copy-clone.md:37
#, fuzzy
msgid "Copying and cloning are not the same thing:"
msgstr "Copierea 탳i clonarea nu sunt acela탳i lucru:"

#: src/ownership/copy-clone.md:39
#, fuzzy
msgid ""
"Copying refers to bitwise copies of memory regions and does not work on "
"arbitrary objects."
msgstr ""
"Copierea se refer캒 la copiile pe bi탵i ale regiunilor de memorie 탳i nu "
"func탵ioneaz캒 pe obiecte arbitrare."

#: src/ownership/copy-clone.md:40
#, fuzzy
msgid ""
"Copying does not allow for custom logic (unlike copy constructors in C++)."
msgstr ""
"Copierea nu permite o logic캒 personalizat캒 (spre deosebire de constructorii "
"de copiere din C++)."

#: src/ownership/copy-clone.md:41
#, fuzzy
msgid ""
"Cloning is a more general operation and also allows for custom behavior by "
"implementing the `Clone` trait."
msgstr ""
"Clonarea este o opera탵iune mai general캒 탳i permite, de asemenea, un "
"comportament personalizat prin implementarea tr캒s캒turii `Clone`."

#: src/ownership/copy-clone.md:42
#, fuzzy
msgid "Copying does not work on types that implement the `Drop` trait."
msgstr ""
"Copierea nu func탵ioneaz캒 pe tipurile care implementeaz캒 tr캒s캒tura `Drop`."

#: src/ownership/copy-clone.md:44 src/ownership/lifetimes-function-calls.md:30
#, fuzzy
msgid "In the above example, try the following:"
msgstr "칉n exemplul de mai sus, 칥ncerca탵i urm캒toarele:"

#: src/ownership/copy-clone.md:46
#, fuzzy
msgid ""
"Add a `String` field to `struct Point`. It will not compile because `String` "
"is not a `Copy` type."
msgstr ""
"Ad캒uga탵i un c칙mp `String` la `struct Point`. Nu se va compila deoarece "
"`String` nu este un tip `Copy`."

#: src/ownership/copy-clone.md:47
#, fuzzy
msgid ""
"Remove `Copy` from the `derive` attribute. The compiler error is now in the "
"`println!` for  `p1`."
msgstr ""
"Elimin캒 `Copy` din atributul `derive`. Eroarea de compilare se afl캒 acum 칥n "
"`println!` pentru `p1`."

#: src/ownership/copy-clone.md:48
#, fuzzy
msgid "Show that it works if you clone `p1` instead."
msgstr "Ar캒ta탵i c캒 func탵ioneaz캒 dac캒 clona탵i `p1` 칥n locul lui."

#: src/ownership/copy-clone.md:50
#, fuzzy
msgid ""
"If students ask about `derive`, it is sufficient to say that this is a way "
"to generate code in Rust at compile time. In this case the default "
"implementations of `Copy` and `Clone` traits are generated."
msgstr ""
"Dac캒 elevii 칥ntreab캒 despre `derive`, este suficient s캒 spunem c캒 este o "
"modalitate de a genera cod 칥n Rust la compilare. 칉n acest caz sunt generate "
"implement캒rile implicite ale tr캒s캒turilor `Copy` 탳i `Clone`."

#: src/ownership/borrowing.md:3
#, fuzzy
msgid ""
"Instead of transferring ownership when calling a function, you can let a "
"function _borrow_ the value:"
msgstr ""
"칉n loc s캒 transfera탵i proprietatea atunci c칙nd apela탵i o func탵ie, pute탵i "
"l캒sa o func탵ie s캒 _칥mprumute_ valoarea:"

#: src/ownership/borrowing.md:23
#, fuzzy
msgid "The `add` function _borrows_ two points and returns a new point."
msgstr "Func탵ia `add` adun캒 dou캒 puncte 탳i returneaz캒 un nou punct."

#: src/ownership/borrowing.md:24
#, fuzzy
msgid "The caller retains ownership of the inputs."
msgstr "Apelantul p캒streaz캒 dreptul de proprietate asupra intr캒rilor."

#: src/ownership/borrowing.md:28
#, fuzzy
msgid "Notes on stack returns:"
msgstr "Note privind return캒rile de stiv캒:"

#: src/ownership/borrowing.md:29
#, fuzzy
msgid ""
"Demonstrate that the return from `add` is cheap because the compiler can "
"eliminate the copy operation. Change the above code to print stack addresses "
"and run it on the [Playground](https://play.rust-lang.org/) or look at the "
"assembly in [Godbolt](https://rust.godbolt.org/). In the \"DEBUG\" "
"optimization level, the addresses should change, while they stay the same "
"when changing to the \"RELEASE\" setting:"
msgstr ""
"Demonstra탵i c캒 칥ntoarcerea din `add` este ieftin캒 deoarece compilatorul "
"poate elimina opera탵ia de copiere. Modifica탵i codul de mai sus pentru a "
"imprima adresele stivei 탳i rula탵i-l pe [Playground](https://play.rust-lang."
"org/) sau examina탵i ansamblul 칥n [Godbolt](https://rust.godbolt.org/). 칉n "
"nivelul de optimizare \"DEBUG\", adresele ar trebui s캒 se schimbe, 칥n timp "
"ce ele r캒m칙n acelea탳i atunci c칙nd trece탵i la setarea \"RELEASE\":"

#: src/ownership/borrowing.md:50
#, fuzzy
msgid "The Rust compiler can do return value optimization (RVO)."
msgstr "Compilatorul Rust poate face optimizarea valorii de returnare (RVO)."

#: src/ownership/borrowing.md:51
#, fuzzy
msgid ""
"In C++, copy elision has to be defined in the language specification because "
"constructors can have side effects. In Rust, this is not an issue at all. If "
"RVO did not happen, Rust will always perform a simple and efficient `memcpy` "
"copy."
msgstr ""
"칉n C++, eliziunea de copiere trebuie definit캒 칥n specifica탵iile limbajului, "
"deoarece constructorii pot avea efecte secundare. 칉n Rust, acest lucru nu "
"reprezint캒 deloc o problem캒. Dac캒 RVO nu a avut loc, Rust va efectua "
"칥ntotdeauna o copie `memcpy` simpl캒 탳i eficient캒."

#: src/ownership/shared-unique-borrows.md:3
#, fuzzy
msgid "Rust puts constraints on the ways you can borrow values:"
msgstr ""
"Rust impune constr칙ngeri asupra modalit캒탵ilor 칥n care pute탵i 칥mprumuta "
"valori:"

#: src/ownership/shared-unique-borrows.md:5
#, fuzzy
msgid "You can have one or more `&T` values at any given time, _or_"
msgstr "Pute탵i avea una sau mai multe valori `&T` la un moment dat, _sau_"

#: src/ownership/shared-unique-borrows.md:6
#, fuzzy
msgid "You can have exactly one `&mut T` value."
msgstr "Pute탵i avea exact o singur캒 valoare `&mut T`."

#: src/ownership/shared-unique-borrows.md:26
#, fuzzy
msgid ""
"The above code does not compile because `a` is borrowed as mutable (through "
"`c`) and as immutable (through `b`) at the same time."
msgstr ""
"Codul de mai sus nu se compileaz캒 pentru c캒 `a` este 칥mprumutat ca mutabil "
"(prin `c`) 탳i ca imuabil (prin `b`) 칥n acela탳i timp."

#: src/ownership/shared-unique-borrows.md:27
#, fuzzy
msgid ""
"Move the `println!` statement for `b` before the scope that introduces `c` "
"to make the code compile."
msgstr ""
"Muta탵i instruc탵iunea `println!` pentru `b` 칥nainte de domeniul de aplicare "
"care introduce `c` pentru a face codul s캒 fie compilat."

#: src/ownership/shared-unique-borrows.md:28
#, fuzzy
msgid ""
"After that change, the compiler realizes that `b` is only ever used before "
"the new mutable borrow of `a` through `c`. This is a feature of the borrow "
"checker called \"non-lexical lifetimes\"."
msgstr ""
"Dup캒 aceast캒 modificare, compilatorul 칥탳i d캒 seama c캒 `b` este folosit doar "
"칥nainte de noul 칥mprumut mutabil de la `a` la `c`. Aceasta este o "
"caracteristic캒 a verificatorului de 칥mprumuturi numit캒 \"durate de via탵캒 non-"
"lexicale\"."

#: src/ownership/lifetimes.md:3
#, fuzzy
msgid "A borrowed value has a _lifetime_:"
msgstr "O valoare 칥mprumutat캒 are o _durat캒 de via탵캒_:"

#: src/ownership/lifetimes.md:5
#, fuzzy
msgid "The lifetime can be implicit: `add(p1: &Point, p2: &Point) -> Point`."
msgstr ""
"Durata de via탵캒 poate fi implicit캒: `add(p1: &Point, p2: &Point) -> Point`."

#: src/ownership/lifetimes.md:6
#, fuzzy
msgid "Lifetimes can also be explicit: `&'a Point`, `&'document str`."
msgstr ""
"Duratele de via탵캒 pot fi, de asemenea, explicite: `&'a Point`, `&'document "
"str`."

#: src/ownership/lifetimes.md:7 src/ownership/lifetimes-function-calls.md:24
#, fuzzy
msgid ""
"Read `&'a Point` as \"a borrowed `Point` which is valid for at least the "
"lifetime `a`\"."
msgstr ""
"Citi탵i `&'a Point` ca fiind \"un `Point` 칥mprumutat care este valabil cel "
"pu탵in pentru durata de via탵캒 `a`\"."

#: src/ownership/lifetimes.md:9
#, fuzzy
msgid ""
"Lifetimes are always inferred by the compiler: you cannot assign a lifetime "
"yourself."
msgstr ""
"Duratele de via탵캒 sunt 칥ntotdeauna deduse de compilator: nu pute탵i atribui o "
"durat캒 de via탵캒 dumneavoastr캒."

#: src/ownership/lifetimes.md:11
#, fuzzy
msgid ""
"Lifetime annotations create constraints; the compiler verifies that there is "
"a valid solution."
msgstr ""
"Adnot캒rile privind durata de via탵캒 creeaz캒 constr칙ngeri; compilatorul "
"verific캒 dac캒 exist캒 o solu탵ie valid캒."

#: src/ownership/lifetimes.md:13
#, fuzzy
msgid ""
"Lifetimes for function arguments and return values must be fully specified, "
"but Rust allows lifetimes to be elided in most cases with [a few simple "
"rules](https://doc.rust-lang.org/nomicon/lifetime-elision.html)."
msgstr ""
"Duratele de via탵캒 pentru argumentele func탵iilor 탳i valorile de retur trebuie "
"s캒 fie specificate 칥n 칥ntregime, dar Rust permite ca duratele de via탵캒 s캒 "
"fie eludate 칥n majoritatea cazurilor cu [c칙teva reguli simple](https://doc."
"rust-lang.org/nomicon/lifetime-elision.html)."

#: src/ownership/lifetimes-function-calls.md:3
#, fuzzy
msgid ""
"In addition to borrowing its arguments, a function can return a borrowed "
"value:"
msgstr ""
"Pe l칙ng캒 칥mprumutul argumentelor sale, o func탵ie poate returna o valoare "
"칥mprumutat캒:"

#: src/ownership/lifetimes-function-calls.md:22
#, fuzzy
msgid "`'a` is a generic parameter, it is inferred by the compiler."
msgstr "`'a` este un parametru generic, acesta este dedus de compilator."

#: src/ownership/lifetimes-function-calls.md:23
#, fuzzy
msgid "Lifetimes start with `'` and `'a` is a typical default name."
msgstr "Durata de via탵캒 칥ncepe cu `'`, iar `'a` este un nume implicit tipic."

#: src/ownership/lifetimes-function-calls.md:26
#, fuzzy
msgid ""
"The _at least_ part is important when parameters are in different scopes."
msgstr ""
"Partea \"cel pu탵in\" este important캒 atunci c칙nd parametrii se afl캒 칥n "
"domenii de aplicare diferite."

#: src/ownership/lifetimes-function-calls.md:32
#, fuzzy
msgid ""
"Move the declaration of `p2` and `p3` into a new scope (`{ ... }`), "
"resulting in the following code:"
msgstr ""
"Muta탵i declara탵iile lui `p2` 탳i `p3` 칥ntr-un nou domeniu (`{ ... }`), "
"rezult칙nd urm캒torul cod:"

#: src/ownership/lifetimes-function-calls.md:52
#, fuzzy
msgid "Note how this does not compile since `p3` outlives `p2`."
msgstr ""
"Observa탵i cum acest lucru nu se compileaz캒 deoarece `p3` este mai mare dec칙t "
"`p2`."

#: src/ownership/lifetimes-function-calls.md:54
#, fuzzy
msgid ""
"Reset the workspace and change the function signature to `fn left_most<'a, "
"'b>(p1: &'a Point, p2: &'a Point) -> &'b Point`. This will not compile "
"because the relationship between the lifetimes `'a` and `'b` is unclear."
msgstr ""
"Reseta탵i spa탵iul de lucru 탳i modifica탵i semn캒tura func탵iei 칥n `fn "
"left_most<'a, 'b>(p1: &'a Point, p2: &'a Point) -> &'b Point`. Acest lucru "
"nu se va compila deoarece rela탵ia dintre duratele de via탵캒 `'a` 탳i `'b` nu "
"este clar캒."

#: src/ownership/lifetimes-function-calls.md:55
#, fuzzy
msgid "Another way to explain it:"
msgstr "Un alt mod de a explica acest lucru:"

#: src/ownership/lifetimes-function-calls.md:56
#, fuzzy
msgid ""
"Two references to two values are borrowed by a function and the function "
"returns another reference."
msgstr ""
"Dou캒 referin탵e la dou캒 valori sunt 칥mprumutate de o func탵ie, iar func탵ia "
"returneaz캒 o alt캒 referin탵캒."

#: src/ownership/lifetimes-function-calls.md:58
#, fuzzy
msgid ""
"It must have come from one of those two inputs (or from a global variable)."
msgstr ""
"Trebuie s캒 fi provenit de la una dintre aceste dou캒 intr캒ri (sau de la o "
"variabil캒 global캒)."

#: src/ownership/lifetimes-function-calls.md:59
#, fuzzy
msgid ""
"Which one is it? The compiler needs to know, so at the call site the "
"returned reference is not used for longer than a variable from where the "
"reference came from."
msgstr ""
"Care dintre ele este? Compilatorul trebuie s캒 탳tie, astfel 칥nc칙t, la locul "
"de apel, referin탵a returnat캒 s캒 nu fie utilizat캒 mai mult timp dec칙t o "
"variabil캒 din care provine referin탵a."

#: src/ownership/lifetimes-data-structures.md:3
#, fuzzy
msgid ""
"If a data type stores borrowed data, it must be annotated with a lifetime:"
msgstr ""
"칉n cazul 칥n care un tip de date stocheaz캒 date 칥mprumutate, acesta trebuie "
"s캒 fie adnotat cu o durat캒 de via탵캒:"

#: src/ownership/lifetimes-data-structures.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Highlight<'doc>(&'doc str);\n"
"\n"
"fn erase(text: String) {\n"
"    println!(\"Bye {text}!\");\n"
"}\n"
"\n"
"fn main() {\n"
"    let text = String::from(\"The quick brown fox jumps over the lazy dog."
"\");\n"
"    let fox = Highlight(&text[4..19]);\n"
"    let dog = Highlight(&text[35..43]);\n"
"    // erase(text);\n"
"    println!(\"{fox:?}\");\n"
"    println!(\"{dog:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"#[derive(Debug)]\n"
"struct Highlight<'doc>(&'doc str);\n"
"\n"
"fn erase(text: String) {\n"
"    println!(\"La revedere {text}!\");\n"
"}\n"
"\n"
"fn main() {\n"
"    let text = String::from(\"Vulpea cea iute 탳i brun캒 sare peste c칙inele "
"lene탳.\");\n"
"    let fox = Highlight(&text[4..19]);\n"
"    let dog = Highlight(&text[35..43]);\n"
"    // erase(text);\n"
"    println!(\"{fox:?}\");\n"
"    println!(\"{dog:?}\");\n"
"}\n"
"```"

#: src/ownership/lifetimes-data-structures.md:25
#, fuzzy
msgid ""
"In the above example, the annotation on `Highlight` enforces that the data "
"underlying the contained `&str` lives at least as long as any instance of "
"`Highlight` that uses that data."
msgstr ""
"칉n exemplul de mai sus, adnotarea pentru `Highlight` impune ca datele care "
"stau la baza `&str` con탵inute s캒 aib캒 o durat캒 de via탵캒 cel pu탵in egal캒 cu "
"cea a oric캒rei instan탵e de `Highlight` care utilizeaz캒 aceste date."

#: src/ownership/lifetimes-data-structures.md:26
#, fuzzy
msgid ""
"If `text` is consumed before the end of the lifetime of `fox` (or `dog`), "
"the borrow checker throws an error."
msgstr ""
"Dac캒 `text` este consumat 칥nainte de sf칙r탳itul duratei de via탵캒 a lui `fox` "
"(sau `dog`), verificatorul de 칥mprumuturi arunc캒 o eroare."

#: src/ownership/lifetimes-data-structures.md:27
#, fuzzy
msgid ""
"Types with borrowed data force users to hold on to the original data. This "
"can be useful for creating lightweight views, but it generally makes them "
"somewhat harder to use."
msgstr ""
"Tipurile cu date 칥mprumutate 칥i oblig캒 pe utilizatori s캒 p캒streze datele "
"originale. Acest lucru poate fi util pentru a crea vizualiz캒ri u탳oare, dar, "
"칥n general, le face ceva mai greu de utilizat."

#: src/ownership/lifetimes-data-structures.md:28
#, fuzzy
msgid "When possible, make data structures own their data directly."
msgstr ""
"Atunci c칙nd este posibil, face탵i ca structurile de date s캒 de탵in캒 direct "
"datele lor."

#: src/ownership/lifetimes-data-structures.md:29
#, fuzzy
msgid ""
"Some structs with multiple references inside can have more than one lifetime "
"annotation. This can be necessary if there is a need to describe lifetime "
"relationships between the references themselves, in addition to the lifetime "
"of the struct itself. Those are very advanced use cases."
msgstr ""
"Unele structuri cu referin탵e multiple 칥n interior pot avea mai multe "
"adnot캒ri de durat캒 de via탵캒. Acest lucru poate fi necesar 칥n cazul 칥n care "
"este necesar s캒 se descrie rela탵iile de durat캒 de via탵캒 칥ntre referin탵e, pe "
"l칙ng캒 durata de via탵캒 a structurii 칥n sine. Acestea sunt cazuri de utilizare "
"foarte avansate."

#: src/structs.md:3
#, fuzzy
msgid "Like C and C++, Rust has support for custom structs:"
msgstr "La fel ca 칥n C 탳i C++, Rust are suport pentru structuri personalizate:"

#: src/structs.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        age: 27,\n"
"    };\n"
"    println!(\"{} is {} years old\", peter.name, peter.age);\n"
"    \n"
"    peter.age = 28;\n"
"    println!(\"{} is {} years old\", peter.name, peter.age);\n"
"    \n"
"    let jackie = Person {\n"
"        name: String::from(\"Jackie\"),\n"
"        ..peter\n"
"    };\n"
"    println!(\"{} is {} years old\", jackie.name, jackie.age);\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        v칙rst캒: 27,\n"
"    };\n"
"    println!(\"{} are {} ani\", peter.name, peter.age);\n"
"    \n"
"    peter.age = 28;\n"
"    println!(\"{} are {} ani\", peter.name, peter.age);\n"
"    \n"
"    let jackie = Person {\n"
"        name: String::from(\"Jackie\"),\n"
"        ..peter\n"
"    };\n"
"    println!(\"{} are {} ani\", jackie.name, jackie.age);\n"
"}\n"
"```"

#: src/structs.md:33
#, fuzzy
msgid "Structs work like in C or C++."
msgstr "Structurile func탵ioneaz캒 ca 칥n C sau C++."

#: src/structs.md:34
#, fuzzy
msgid "Like in C++, and unlike in C, no typedef is needed to define a type."
msgstr ""
"La fel ca 칥n C++ 탳i spre deosebire de C, nu este nevoie de un typedef pentru "
"a defini un tip."

#: src/structs.md:35
#, fuzzy
msgid "Unlike in C++, there is no inheritance between structs."
msgstr "Spre deosebire de C++, nu exist캒 mo탳tenire 칥ntre structuri."

#: src/structs.md:36
#, fuzzy
msgid ""
"Methods are defined in an `impl` block, which we will see in following "
"slides."
msgstr ""
"Metodele sunt definite 칥ntr-un bloc `impl`, pe care 칥l vom vedea 칥n slide-"
"urile urm캒toare."

#: src/structs.md:37
#, fuzzy
msgid ""
"This may be a good time to let people know there are different types of "
"structs. "
msgstr ""
"Acesta ar putea fi un moment bun pentru a informa oamenii c캒 exist캒 diferite "
"tipuri de structuri."

#: src/structs.md:38
#, fuzzy
msgid ""
"Zero-sized structs (e.g. `struct Foo;`) might be used when implementing a "
"trait on some type but don뗪 have any data that you want to store in the "
"value itself. "
msgstr ""
"Structurile de dimensiune zero (de exemplu, `struct Foo;`) pot fi utilizate "
"atunci c칙nd se implementeaz캒 o tr캒s캒tur캒 pe un anumit tip, dar nu ave탵i date "
"pe care dori탵i s캒 le stoca탵i 칥n valoarea 칥n sine."

#: src/structs.md:39
#, fuzzy
msgid ""
"The next slide will introduce Tuple structs, used when the field names are "
"not important."
msgstr ""
"Urm캒torul diapozitiv va prezenta structurile Tuple, utilizate atunci c칙nd "
"numele c칙mpurilor nu sunt importante."

#: src/structs.md:40
#, fuzzy
msgid ""
"The syntax `..peter` allows us to copy the majority of the fields from the "
"old struct without having to explicitly type it all out. It must always be "
"the last element."
msgstr ""
"Sintaxa `..peter` ne permite s캒 copiem majoritatea c칙mpurilor din vechea "
"structur캒 f캒r캒 a fi nevoie s캒 le scriem 칥n mod explicit pe toate. Acesta "
"trebuie s캒 fie 칥ntotdeauna ultimul element."

#: src/structs/tuple-structs.md:3
#, fuzzy
msgid "If the field names are unimportant, you can use a tuple struct:"
msgstr ""
"칉n cazul 칥n care numele c칙mpurilor nu sunt importante, pute탵i utiliza o "
"structur캒 de tip tuple:"

#: src/structs/tuple-structs.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"struct Point(i32, i32);\n"
"\n"
"fn main() {\n"
"    let p = Point(17, 23);\n"
"    println!(\"({}, {})\", p.0, p.1);\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"struct Point(i32, i32);\n"
"\n"
"fn main() {\n"
"    let p = Point(17, 23);\n"
"    println!\"(\"({}, {})\", p.0, p.1);\n"
"}\n"
"```"

#: src/structs/tuple-structs.md:14
#, fuzzy
msgid "This is often used for single-field wrappers (called newtypes):"
msgstr ""
"Acest lucru este adesea utilizat pentru 칥nveli탳urile cu un singur c칙mp "
"(denumite newtypes):"

#: src/structs/tuple-structs.md:16
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"struct PoundsOfForce(f64);\n"
"struct Newtons(f64);\n"
"\n"
"fn compute_thruster_force() -> PoundsOfForce {\n"
"    todo!(\"Ask a rocket scientist at NASA\")\n"
"}\n"
"\n"
"fn set_thruster_force(force: Newtons) {\n"
"    // ...\n"
"}\n"
"\n"
"fn main() {\n"
"    let force = compute_thruster_force();\n"
"    set_thruster_force(force);\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"struct PoundsOfForce(f64);\n"
"struct Newtons(f64);\n"
"\n"
"fn compute_thruster_force() -> PoundsOfForce {\n"
"    todo!(\"칉ntreba탵i un specialist 칥n rachete de la NASA\")\n"
"}\n"
"\n"
"fn set_thruster_force(force: Newtons) {\n"
"    // ...\n"
"}\n"
"\n"
"fn main() {\n"
"    let force = compute_thruster_force();\n"
"    set_thruster_force(force);\n"
"}\n"
"\n"
"```"

#: src/structs/tuple-structs.md:37
#, fuzzy
msgid ""
"Newtypes are a great way to encode additional information about the value in "
"a primitive type, for example:"
msgstr ""
"Newtypes reprezint캒 o modalitate excelent캒 de a codifica informa탵ii "
"suplimentare despre valoarea unui tip primitiv, de exemplu:"

#: src/structs/tuple-structs.md:38
#, fuzzy
msgid "The number is measured in some units: `Newtons` in the example above."
msgstr ""
"Num캒rul este m캒surat 칥n anumite unit캒탵i: `Newtons` 칥n exemplul de mai sus."

#: src/structs/tuple-structs.md:39
#, fuzzy
msgid ""
"The value passed some validation when it was created, so you no longer have "
"to validate it again at every use: `PhoneNumber(String)` or `OddNumber(u32)`."
msgstr ""
"Valoarea a trecut printr-o validare atunci c칙nd a fost creat캒, astfel 칥nc칙t "
"nu mai trebuie s캒 o valida탵i din nou la fiecare utilizare: "
"`PhoneNumber(String)` sau `OddNumber(u32)`."

#: src/structs/tuple-structs.md:40
#, fuzzy
msgid ""
"Demonstrate how to add a `f64` value to a `Newtons` type by accessing the "
"single field in the newtype."
msgstr ""
"Demonstra탵i cum s캒 ad캒uga탵i o valoare `f64` la un tip `Newtons` prin "
"accesarea unui singur c칙mp din noul tip."

#: src/structs/tuple-structs.md:41
#, fuzzy
msgid ""
"Rust generally doesn뗪 like inexplicit things, like automatic unwrapping or "
"for instance using booleans as integers."
msgstr ""
"칉n general, Rust nu agreeaz캒 lucrurile inexplicabile, cum ar fi desfacerea "
"automat캒 sau, de exemplu, utilizarea booleenilor ca numere 칥ntregi."

#: src/structs/tuple-structs.md:42
#, fuzzy
msgid "Operator overloading is discussed on Day 3 (generics)."
msgstr "Supra칥nc캒rcarea operatorilor este discutat캒 칥n ziua 3 (generice)."

#: src/structs/tuple-structs.md:43
#, fuzzy
msgid ""
"The example is a subtle reference to the [Mars Climate Orbiter](https://en."
"wikipedia.org/wiki/Mars_Climate_Orbiter) failure."
msgstr ""
"Exemplul este o referire subtil캒 la e탳ecul [Mars Climate Orbiter] (https://"
"en.wikipedia.org/wiki/Mars_Climate_Orbiter)."

#: src/structs/field-shorthand.md:3
#, fuzzy
msgid ""
"If you already have variables with the right names, then you can create the "
"struct using a shorthand:"
msgstr ""
"Dac캒 ave탵i deja variabile cu numele corecte, pute탵i crea structura folosind "
"o prescurtare:"

#: src/structs/field-shorthand.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"\n"
"impl Person {\n"
"    fn new(name: String, age: u8) -> Person {\n"
"        Person { name, age }\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let peter = Person::new(String::from(\"Peter\"), 27);\n"
"    println!(\"{peter:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"\n"
"impl Person {\n"
"    fn new(name: String, age: u8) -> Person {\n"
"        Persoan캒 { nume, v칙rst캒 }\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let peter = Person::new(String::from(\"Peter\"), 27);\n"
"    println!(\"{peter:?}\");\n"
"}\n"
"```"

#: src/structs/field-shorthand.md:27
#, fuzzy
msgid ""
"The `new` function could be written using `Self` as a type, as it is "
"interchangeable with the struct type name"
msgstr ""
"Func탵ia `new` ar putea fi scris캒 folosind `Self` ca tip, deoarece este "
"interschimbabil캒 cu numele de tip struct"

#: src/structs/field-shorthand.md:41
#, fuzzy
msgid ""
"Implement the `Default` trait for the struct. Define some fields and use the "
"default values for the other fields."
msgstr ""
"Implementeaz캒 tr캒s캒tura `Default` pentru structura. Defini탵i unele c칙mpuri "
"탳i utiliza탵i valorile implicite pentru celelalte c칙mpuri."

#: src/structs/field-shorthand.md:43
#, fuzzy
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"impl Default for Person {\n"
"    fn default() -> Person {\n"
"        Person {\n"
"            name: \"Bot\".to_string(),\n"
"            age: 0,\n"
"        }\n"
"    }\n"
"}\n"
"fn create_default() {\n"
"    let tmp = Person {\n"
"        ..Person::default()\n"
"    };\n"
"    let tmp = Person {\n"
"        name: \"Sam\".to_string(),\n"
"        ..Person::default()\n"
"    };\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"impl Default for Person {\n"
"    fn default() -> Person {\n"
"        Persoan캒 {\n"
"            name: \"Bot\".to_string(),\n"
"            age: 0,\n"
"        }\n"
"    }\n"
"}\n"
"fn create_default() {\n"
"    let tmp = Person {\n"
"        ..Person::default()\n"
"    };\n"
"    let tmp = Person {\n"
"        name: \"Sam\".to_string(),\n"
"        ..Person::default()\n"
"    };\n"
"}\n"
"```"

#: src/structs/field-shorthand.md:68
#, fuzzy
msgid "Methods are defined in the `impl` block."
msgstr "Metodele sunt definite 칥n blocul `impl`."

#: src/structs/field-shorthand.md:69
#, fuzzy
msgid ""
"Use struct update syntax to define a new structure using `peter`. Note that "
"the variable `peter` will no longer be accessible afterwards."
msgstr ""
"Utiliza탵i sintaxa de actualizare a structurii pentru a defini o nou캒 "
"structur캒 folosind `peter`. Re탵ine탵i c캒 variabila `peter` nu va mai fi "
"accesibil캒 ulterior."

#: src/structs/field-shorthand.md:70
#, fuzzy
msgid ""
"Use `{:#?}` when printing structs to request the `Debug` representation."
msgstr ""
"Utiliza탵i `{:#?}` la imprimarea structurilor pentru a solicita reprezentarea "
"`Debug`."

#: src/methods.md:3
#, fuzzy
msgid ""
"Rust allows you to associate functions with your new types. You do this with "
"an `impl` block:"
msgstr ""
"Rust v캒 permite s캒 asocia탵i func탵ii cu noile dvs. tipuri. Acest lucru se "
"face cu ajutorul unui bloc `impl`:"

#: src/methods.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"\n"
"impl Person {\n"
"    fn say_hello(&self) {\n"
"        println!(\"Hello, my name is {}\", self.name);\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        age: 27,\n"
"    };\n"
"    peter.say_hello();\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"\n"
"impl Person {\n"
"    fn say_hello(&self) {\n"
"        println!(\"Bun캒 ziua, numele meu este {}\", self.name);\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        v칙rst캒: 27,\n"
"    };\n"
"    peter.say_hello();\n"
"}\n"
"```"

#: src/methods.md:31
#, fuzzy
msgid "It can be helpful to introduce methods by comparing them to functions."
msgstr ""
"Poate fi util캒 introducerea metodelor prin compararea lor cu func탵iile."

#: src/methods.md:32
#, fuzzy
msgid ""
"Methods are called on an instance of a type (such as a struct or enum), the "
"first parameter represents the instance as `self`."
msgstr ""
"Metodele sunt apelate pe o instan탵캒 a unui tip (cum ar fi un struct sau "
"enum), primul parametru reprezint캒 instan탵a ca `self`."

#: src/methods.md:33
#, fuzzy
msgid ""
"Developers may choose to use methods to take advantage of method receiver "
"syntax and to help keep them more organized. By using methods we can keep "
"all the implementation code in one predictable place."
msgstr ""
"Dezvoltatorii pot alege s캒 foloseasc캒 metode pentru a profita de sintaxa "
"receptorului de metode 탳i pentru a le men탵ine mai bine organizate. Prin "
"utilizarea metodelor putem p캒stra tot codul de implementare 칥ntr-un singur "
"loc previzibil."

#: src/methods.md:34
#, fuzzy
msgid "Point out the use of the keyword `self`, a method receiver."
msgstr "Indica탵i utilizarea cuv칙ntului cheie `self`, un receptor de metod캒."

#: src/methods.md:35
#, fuzzy
msgid ""
"Show that it is an abbreviated term for `self: Self` and perhaps show how "
"the struct name could also be used."
msgstr ""
"Ar캒ta탵i c캒 este un termen prescurtat pentru \"sine\": Self` 탳i, eventual, "
"ar캒ta탵i cum ar putea fi folosit 탳i numele structurii."

#: src/methods.md:36
#, fuzzy
msgid ""
"Explain that `Self` is a type alias for the type the `impl` block is in and "
"can be used elsewhere in the block."
msgstr ""
"Explica탵i c캒 `Self` este un alias de tip pentru tipul 칥n care se afl캒 blocul "
"`impl` 탳i poate fi utilizat 칥n alt캒 parte a blocului."

#: src/methods.md:37
#, fuzzy
msgid ""
"Note how `self` is used like other structs and dot notation can be used to "
"refer to individual fields."
msgstr ""
"Observa탵i cum `self` este utilizat ca 탳i alte structuri 탳i cum nota탵ia cu "
"puncte poate fi utilizat캒 pentru a se referi la c칙mpuri individuale."

#: src/methods.md:38
#, fuzzy
msgid ""
"This might be a good time to demonstrate how the `&self` differs from `self` "
"by modifying the code and trying to run say_hello twice."
msgstr ""
"Acesta ar putea fi un moment bun pentru a demonstra cum difer캒 `&self` de "
"`self` prin modificarea codului 탳i 칥ncercarea de a rula say_hello de dou캒 "
"ori."

#: src/methods.md:39
#, fuzzy
msgid "We describe the distinction between method receivers next."
msgstr "칉n continuare, vom descrie distinc탵ia dintre receptorii de metode."

#: src/methods/receiver.md:3
#, fuzzy
msgid ""
"The `&self` above indicates that the method borrows the object immutably. "
"There are other possible receivers for a method:"
msgstr ""
"Simbolul `&self` de mai sus indic캒 faptul c캒 metoda 칥mprumut캒 obiectul 칥n "
"mod imuabil. Exist캒 탳i al탵i receptori posibili pentru o metod캒:"

#: src/methods/receiver.md:6
#, fuzzy
msgid ""
"`&self`: borrows the object from the caller using a shared and immutable "
"reference. The object can be used again afterwards."
msgstr ""
"`&self`: 칥mprumut캒 obiectul de la apelant folosind o referin탵캒 partajat캒 탳i "
"imuabil캒. Obiectul poate fi utilizat din nou ulterior."

#: src/methods/receiver.md:8
#, fuzzy
msgid ""
"`&mut self`: borrows the object from the caller using a unique and mutable "
"reference. The object can be used again afterwards."
msgstr ""
"`&mut self`: 칥mprumut캒 obiectul de la apelant folosind o referin탵캒 unic캒 탳i "
"mutabil캒. Obiectul poate fi utilizat din nou ulterior."

#: src/methods/receiver.md:10
#, fuzzy
msgid ""
"`self`: takes ownership of the object and moves it away from the caller. The "
"method becomes the owner of the object. The object will be dropped "
"(deallocated) when the method returns, unless its ownership is explicitly "
"transmitted. Complete ownership does not automatically mean mutability."
msgstr ""
"`self`: preia proprietatea asupra obiectului 탳i 칥l 칥ndep캒rteaz캒 de la "
"apelant. Metoda devine proprietarul obiectului. Obiectul va fi abandonat "
"(dezalocat) la 칥ntoarcerea metodei, cu excep탵ia cazului 칥n care proprietatea "
"sa este transmis캒 칥n mod explicit. Proprietatea complet캒 nu 칥nseamn캒 automat "
"mutabilitate."

#: src/methods/receiver.md:14
#, fuzzy
msgid "`mut self`: same as above, but the method can mutate the object. "
msgstr "`mut self`: la fel ca mai sus, dar metoda poate muta obiectul."

#: src/methods/receiver.md:15
#, fuzzy
msgid ""
"No receiver: this becomes a static method on the struct. Typically used to "
"create constructors which are called `new` by convention."
msgstr ""
"F캒r캒 receptor: aceasta devine o metod캒 static캒 pe structura. Se utilizeaz캒 "
"de obicei pentru a crea constructori care sunt numi탵i `new` prin conven탵ie."

#: src/methods/receiver.md:18
#, fuzzy
msgid ""
"Beyond variants on `self`, there are also [special wrapper types](https://"
"doc.rust-lang.org/reference/special-types-and-traits.html) allowed to be "
"receiver types, such as `Box<Self>`."
msgstr ""
"칉n afar캒 de variantele lui `self`, exist캒 탳i [tipuri speciale de 칥nveli탳]"
"(https://doc.rust-lang.org/reference/special-types-and-traits.html) care pot "
"fi tipuri de receptor, cum ar fi `Box<Self>`."

#: src/methods/receiver.md:24
#, fuzzy
msgid ""
"Consider emphasizing \"shared and immutable\" and \"unique and mutable\". "
"These constraints always come together in Rust due to borrow checker rules, "
"and `self` is no exception. It isn't possible to reference a struct from "
"multiple locations and call a mutating (`&mut self`) method on it."
msgstr ""
"Lua탵i 칥n considerare posibilitatea de a pune accentul pe \"partajat 탳i "
"imuabil\" 탳i \"unic 탳i mutabil\". Aceste constr칙ngeri se 칥nt칙lnesc "
"칥ntotdeauna 칥n Rust datorit캒 regulilor de verificare a 칥mprumuturilor, iar "
"`self` nu face excep탵ie. Nu este posibil s캒 se fac캒 referire la o structur캒 "
"din mai multe loca탵ii 탳i s캒 se apeleze o metod캒 mutant캒 (`&mut self`) asupra "
"acesteia."

#: src/methods/example.md:3
#, fuzzy
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Race {\n"
"    name: String,\n"
"    laps: Vec<i32>,\n"
"}\n"
"\n"
"impl Race {\n"
"    fn new(name: &str) -> Race {  // No receiver, a static method\n"
"        Race { name: String::from(name), laps: Vec::new() }\n"
"    }\n"
"\n"
"    fn add_lap(&mut self, lap: i32) {  // Exclusive borrowed read-write "
"access to self\n"
"        self.laps.push(lap);\n"
"    }\n"
"\n"
"    fn print_laps(&self) {  // Shared and read-only borrowed access to self\n"
"        println!(\"Recorded {} laps for {}:\", self.laps.len(), self.name);\n"
"        for (idx, lap) in self.laps.iter().enumerate() {\n"
"            println!(\"Lap {idx}: {lap} sec\");\n"
"        }\n"
"    }\n"
"\n"
"    fn finish(self) {  // Exclusive ownership of self\n"
"        let total = self.laps.iter().sum::<i32>();\n"
"        println!(\"Race {} is finished, total lap time: {}\", self.name, "
"total);\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut race = Race::new(\"Monaco Grand Prix\");\n"
"    race.add_lap(70);\n"
"    race.add_lap(68);\n"
"    race.print_laps();\n"
"    race.add_lap(71);\n"
"    race.print_laps();\n"
"    race.finish();\n"
"    // race.add_lap(42);\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"#[derive(Debug)]\n"
"struct Race {\n"
"    name: String,\n"
"    laps: Vec<i32>,\n"
"}\n"
"\n"
"impl Race {\n"
"    fn new(name: &amp;str) -&gt; Race { // F캒r캒 receptor, o metod캒 static캒\n"
"        Race { name: String::from(name), laps: Vec::new() }\n"
"    }\n"
"\n"
"    fn add_lap(&amp;mut self, lap: i32) { // Acces exclusiv 칥mprumutat de "
"citire-scriere la self\n"
"        self.laps.push(lap);\n"
"    }\n"
"\n"
"    fn print_laps(&amp;self) { // Acces 칥mprumutat partajat 탳i numai pentru "
"citire la self\n"
"        println!(\"칉nregistrat {} laps pentru {}:\", self.laps.len(), self."
"name);\n"
"        for (idx, lap) in self.laps.iter().enumerate() {\n"
"            println!(\"Tur {idx}: {lap} sec\");\n"
"        }\n"
"    }\n"
"\n"
"    fn finish(self) { // Proprietatea exclusiv캒 a lui self\n"
"        let total = self.laps.iter().sum::<i32>();\n"
"        println!(\"Cursa {} s-a terminat, timpul total pe tur: {}\", self."
"name, total);\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut race = Race::new(\"Monaco Grand Prix\");\n"
"    race.add_lap(70);\n"
"    race.add_lap(68);\n"
"    race.print_laps();\n"
"    race.add_lap(71);\n"
"    race.print_laps();\n"
"    race.finish();\n"
"    // race.add_lap(42);\n"
"}\n"
"```"

#: src/methods/example.md:47
#, fuzzy
msgid "All four methods here use a different method receiver."
msgstr ""
"Toate cele patru metode de aici utilizeaz캒 un receptor de metod캒 diferit."

#: src/methods/example.md:48
#, fuzzy
msgid ""
"You can point out how that changes what the function can do with the "
"variable values and if/how it can be used again in `main`."
msgstr ""
"Pute탵i sublinia modul 칥n care acest lucru schimb캒 ceea ce poate face func탵ia "
"cu valorile variabilelor 탳i dac캒/cum poate fi utilizat캒 din nou 칥n `main`."

#: src/methods/example.md:49
#, fuzzy
msgid ""
"You can showcase the error that appears when trying to call `finish` twice."
msgstr ""
"Pute탵i prezenta eroarea care apare atunci c칙nd 칥ncerca탵i s캒 apela탵i `finish` "
"de dou캒 ori."

#: src/methods/example.md:50
#, fuzzy
msgid ""
"Note that although the method receivers are different, the non-static "
"functions are called the same way in the main body. Rust enables automatic "
"referencing and dereferencing when calling methods. Rust automatically adds "
"in the `&`, `*`, `muts` so that that object matches the method signature."
msgstr ""
"Re탵ine탵i c캒, de탳i destinatarii metodelor sunt diferi탵i, func탵iile non-"
"statice sunt apelate 칥n acela탳i mod 칥n corpul principal. Rust permite "
"referen탵ierea 탳i de-referen탵ierea automat캒 la apelarea metodelor. Rust "
"adaug캒 automat 칥n `&`, `*`, `muts` astfel 칥nc칙t obiectul respectiv s캒 "
"corespund캒 semn캒turii metodei."

#: src/methods/example.md:51
#, fuzzy
msgid ""
"You might point out that `print_laps` is using a vector that is iterated "
"over. We describe vectors in more detail in the afternoon. "
msgstr ""
"A탵i putea sublinia c캒 `print_laps` folose탳te un vector care este iterat. Vom "
"descrie vectorii mai 칥n detaliu 칥n cursul dup캒-amiezii."

#: src/exercises/day-2/morning.md:1
#, fuzzy
msgid "Day 2: Morning Exercises"
msgstr "Ziua 2: Exerci탵ii de diminea탵캒"

#: src/exercises/day-2/morning.md:3
#, fuzzy
msgid "We will look at implementing methods in two contexts:"
msgstr "Vom analiza implementarea metodelor 칥n dou캒 contexte:"

#: src/exercises/day-2/morning.md:5
#, fuzzy
msgid "Storing books and querying the collection"
msgstr "Stocarea c캒r탵ilor 탳i interogarea colec탵iei"

#: src/exercises/day-2/morning.md:7
#, fuzzy
msgid "Keeping track of health statistics for patients"
msgstr "Urm캒rirea statisticilor de s캒n캒tate pentru pacien탵i"

#: src/exercises/day-2/book-library.md:3
#, fuzzy
msgid ""
"We will learn much more about structs and the `Vec<T>` type tomorrow. For "
"now, you just need to know part of its API:"
msgstr ""
"M칙ine vom 칥nv캒탵a mult mai multe despre structuri 탳i tipul `Vec<T>`. "
"Deocamdat캒, trebuie doar s캒 cunoa탳te탵i o parte din API-ul s캒u:"

#: src/exercises/day-2/book-library.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut vec = vec![10, 20];\n"
"    vec.push(30);\n"
"    let midpoint = vec.len() / 2;\n"
"    println!(\"middle value: {}\", vec[midpoint]);\n"
"    for item in &vec {\n"
"        println!(\"item: {item}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    let mut vec = vec![10, 20];\n"
"    vec.push(30);\n"
"    let midpoint = vec.len() / 2;\n"
"    println!(\"valoarea de mijloc: {}\", vec[midpoint]);\n"
"    for item in &vec {\n"
"        println!(\"item: {item}\");\n"
"    }\n"
"}\n"
"```"

#: src/exercises/day-2/book-library.md:18
#, fuzzy
msgid ""
"Use this to model a library's book collection. Copy the code below to "
"<https://play.rust-lang.org/> and update the types to make it compile:"
msgstr ""
"Folosi탵i acest lucru pentru a modela colec탵ia de c캒r탵i a unei biblioteci. "
"Copia탵i codul de mai jos 칥n <https://play.rust-lang.org/> 탳i actualiza탵i "
"tipurile pentru a-l compila:"

#: src/exercises/day-2/book-library.md:21
#, fuzzy
msgid ""
"```rust,should_panic\n"
"struct Library {\n"
"    books: Vec<Book>,\n"
"}\n"
"\n"
"struct Book {\n"
"    title: String,\n"
"    year: u16,\n"
"}\n"
"\n"
"impl Book {\n"
"    // This is a constructor, used below.\n"
"    fn new(title: &str, year: u16) -> Book {\n"
"        Book {\n"
"            title: String::from(title),\n"
"            year,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Implement the methods below. Notice how the `self` parameter\n"
"// changes type to indicate the method's required level of ownership\n"
"// over the object:\n"
"//\n"
"// - `&self` for shared read-only access,\n"
"// - `&mut self` for unique and mutable access,\n"
"// - `self` for unique access by value.\n"
"impl Library {\n"
"    fn new() -> Library {\n"
"        todo!(\"Initialize and return a `Library` value\")\n"
"    }\n"
"\n"
"    fn len(&self) -> usize {\n"
"        todo!(\"Return the length of `self.books`\")\n"
"    }\n"
"\n"
"    fn is_empty(&self) -> bool {\n"
"        todo!(\"Return `true` if `self.books` is empty\")\n"
"    }\n"
"\n"
"    fn add_book(&mut self, book: Book) {\n"
"        todo!(\"Add a new book to `self.books`\")\n"
"    }\n"
"\n"
"    fn print_books(&self) {\n"
"        todo!(\"Iterate over `self.books` and print each book's title and "
"year\")\n"
"    }\n"
"\n"
"    fn oldest_book(&self) -> Option<&Book> {\n"
"        todo!(\"Return a reference to the oldest book (if any)\")\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut library = Library::new();\n"
"\n"
"    println!(\n"
"        \"The library is empty: library.is_empty() -> {}\",\n"
"        library.is_empty()\n"
"    );\n"
"\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"\n"
"    println!(\n"
"        \"The library is no longer empty: library.is_empty() -> {}\",\n"
"        library.is_empty()\n"
"    );\n"
"\n"
"    library.print_books();\n"
"\n"
"    match library.oldest_book() {\n"
"        Some(book) => println!(\"The oldest book is {}\", book.title),\n"
"        None => println!(\"The library is empty!\"),\n"
"    }\n"
"\n"
"    println!(\"The library has {} books\", library.len());\n"
"    library.print_books();\n"
"}\n"
"```"
msgstr ""
"```rust,should_panic\n"
"struct Biblioteca {\n"
"    books: Vec<Book>,\n"
"}\n"
"\n"
"struct Book {\n"
"    titlu: String,\n"
"    year: u16,\n"
"}\n"
"\n"
"impl Book {\n"
"    // Acesta este un constructor, utilizat mai jos.\n"
"    fn new(title: &amp;str, year: u16) -&gt; Book {\n"
"        Carte {\n"
"            title: String::from(title),\n"
"            year,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Implementa탵i metodele de mai jos. Observa탵i modul 칥n care parametrul "
"`self`\n"
"// 칥탳i schimb캒 tipul pentru a indica nivelul necesar de proprietate al "
"metodei\n"
"// asupra obiectului:\n"
"//\n"
"// - `&amp;self` pentru acces partajat numai pentru citire,\n"
"// - `&amp;mut self` pentru acces unic 탳i mutabil,\n"
"// - `self` pentru acces unic prin valoare.\n"
"impl Library {\n"
"    fn new() -&gt; Library {\n"
"        todo!(\"Ini탵ializeaz캒 탳i returneaz캒 o valoare `Library`\")\n"
"    }\n"
"\n"
"    fn len(&amp;self) -&gt; usize {\n"
"        todo!(\"Returneaz캒 lungimea lui `self.books`\")\n"
"    }\n"
"\n"
"    fn is_empty(&amp;self) -&gt; bool {\n"
"        todo!(\"Returneaz캒 `true` dac캒 `self.books` este gol\")\n"
"    }\n"
"\n"
"    fn add_book(&amp;mut self, book: Book) {\n"
"        todo!(\"Adaug캒 o nou캒 carte 칥n `self.books`\")\n"
"    }\n"
"\n"
"    fn print_books(&amp;self) {\n"
"        todo!(\"Itera탵i peste `self.books` 탳i imprima탵i titlul 탳i anul "
"fiec캒rei c캒r탵i\")\n"
"    }\n"
"\n"
"    fn oldest_book(&amp;self) -&gt; Option<&Book> {\n"
"        todo!(\"Returneaz캒 o referin탵캒 la cea mai veche carte (dac캒 "
"exist캒)\")\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut library = Library::new();\n"
"\n"
"    println!(\n"
"        \"Biblioteca este goal캒: library.is_empty() -&gt; {}\",\n"
"        library.is_empty()\n"
"    );\n"
"\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Aventurile lui Alice 칥n 탴ara Minunilor\", "
"1865));\n"
"\n"
"    println!(\n"
"        \"Biblioteca nu mai este goal캒: library.is_empty() -&gt; {}\",\n"
"        library.is_empty()\n"
"    );\n"
"\n"
"    library.print_books();\n"
"\n"
"    se potrive탳te library.oldest_book() {\n"
"        Some(book) =&gt; println!(\"Cea mai veche carte este {}\", book."
"title),\n"
"        None =&gt; println!(\"Biblioteca este goal캒!\"),\n"
"    }\n"
"\n"
"    printlnn!(\"Biblioteca are {} c캒r탵i\", library.len());\n"
"    library.print_books();\n"
"}\n"
"```"

#: src/exercises/day-2/health-statistics.md:3
#, fuzzy
msgid ""
"You're working on implementing a health-monitoring system. As part of that, "
"you need to keep track of users' health statistics."
msgstr ""
"Lucra탵i la implementarea unui sistem de monitorizare a s캒n캒t캒탵ii. 칉n cadrul "
"acestuia, trebuie s캒 탵ine탵i eviden탵a statisticilor de s캒n캒tate ale "
"utilizatorilor."

#: src/exercises/day-2/health-statistics.md:6
#, fuzzy
msgid ""
"You'll start with some stubbed functions in an `impl` block as well as a "
"`User` struct definition. Your goal is to implement the stubbed out methods "
"on the `User` `struct` defined in the `impl` block."
msgstr ""
"Ve탵i 칥ncepe cu ni탳te func탵ii stubbed 칥ntr-un bloc `impl`, precum 탳i cu o "
"defini탵ie a structurii `User`. Scopul dumneavoastr캒 este de a implementa "
"metodele stubbed out pe `struct` `User` definit캒 칥n blocul `impl`."

#: src/exercises/day-2/health-statistics.md:10
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing "
"methods:"
msgstr ""
"Copia탵i codul de mai jos 칥n <https://play.rust-lang.org/> 탳i completa탵i "
"metodele lips캒:"

#: src/exercises/day-2/health-statistics.md:13
#, fuzzy
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub struct User {\n"
"    name: String,\n"
"    age: u32,\n"
"    height: f32,\n"
"    visit_count: usize,\n"
"    last_blood_pressure: Option<(u32, u32)>,\n"
"}\n"
"\n"
"pub struct Measurements {\n"
"    height: f32,\n"
"    blood_pressure: (u32, u32),\n"
"}\n"
"\n"
"pub struct HealthReport<'a> {\n"
"    patient_name: &'a str,\n"
"    visit_count: u32,\n"
"    height_change: f32,\n"
"    blood_pressure_change: Option<(i32, i32)>,\n"
"}\n"
"\n"
"impl User {\n"
"    pub fn new(name: String, age: u32, height: f32) -> Self {\n"
"        todo!(\"Create a new User instance\")\n"
"    }\n"
"\n"
"    pub fn name(&self) -> &str {\n"
"        todo!(\"Return the user's name\")\n"
"    }\n"
"\n"
"    pub fn age(&self) -> u32 {\n"
"        todo!(\"Return the user's age\")\n"
"    }\n"
"\n"
"    pub fn height(&self) -> f32 {\n"
"        todo!(\"Return the user's height\")\n"
"    }\n"
"\n"
"    pub fn doctor_visits(&self) -> u32 {\n"
"        todo!(\"Return the number of time the user has visited the "
"doctor\")\n"
"    }\n"
"\n"
"    pub fn set_age(&mut self, new_age: u32) {\n"
"        todo!(\"Set the user's age\")\n"
"    }\n"
"\n"
"    pub fn set_height(&mut self, new_height: f32) {\n"
"        todo!(\"Set the user's height\")\n"
"    }\n"
"\n"
"    pub fn visit_doctor(&mut self, measurements: Measurements) -> "
"HealthReport {\n"
"        todo!(\"Update a user's statistics based on measurements from a "
"visit to the doctor\")\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    println!(\"I'm {} and my age is {}\", bob.name(), bob.age());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_height() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.height(), 155.2);\n"
"}\n"
"\n"
"#[test]\n"
"fn test_set_age() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.age(), 32);\n"
"    bob.set_age(33);\n"
"    assert_eq!(bob.age(), 33);\n"
"}\n"
"\n"
"#[test]\n"
"fn test_visit() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.doctor_visits(), 0);\n"
"    let report = bob.visit_doctor(Measurements {\n"
"        height: 156.1,\n"
"        blood_pressure: (120, 80),\n"
"    });\n"
"    assert_eq!(report.patient_name, \"Bob\");\n"
"    assert_eq!(report.visit_count, 1);\n"
"    assert_eq!(report.blood_pressure_change, None);\n"
"\n"
"    let report = bob.visit_doctor(Measurements {\n"
"        height: 156.1,\n"
"        blood_pressure: (115, 76),\n"
"    });\n"
"\n"
"    assert_eq!(report.visit_count, 2);\n"
"    assert_eq!(report.blood_pressure_change, Some((-5, -4)));\n"
"}\n"
"```"
msgstr ""
"```rust,should_panic\n"
"// TODO: elimina탵i acest lucru atunci c칙nd a탵i terminat cu implementarea.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub struct User {\n"
"    name: String,\n"
"    age: u32,\n"
"    칥n캒l탵ime: f32,\n"
"    visit_count: usize,\n"
"    last_blood_pressure: Option<(u32, u32)>,\n"
"}\n"
"\n"
"pub struct struct Measurements {\n"
"    height: f32,\n"
"    blood_pressure: (u32, u32),\n"
"}\n"
"\n"
"pub struct struct HealthReport<'a> {\n"
"    patient_name: &'a str,\n"
"    visit_count: u32,\n"
"    height_change: f32,\n"
"    blood_pressure_change: Option<(i32, i32)>,\n"
"}\n"
"\n"
"impl User {\n"
"    pub fn new(name: String, age: u32, height: f32) -> Self {\n"
"        todo!(\"Creeaz캒 o nou캒 instan탵캒 de utilizator\")\n"
"    }\n"
"\n"
"    pub fn name(&self) -> &str {\n"
"        todo!(\"Returneaz캒 numele utilizatorului\")\n"
"    }\n"
"\n"
"    pub fn age(&self) -> u32 {\n"
"        todo!(\"Returneaz캒 v칙rsta utilizatorului\")\n"
"    }\n"
"\n"
"    pub fn height(&self) -> f32 {\n"
"        todo!(\"칉ntoarce 칥n캒l탵imea utilizatorului\")\n"
"    }\n"
"\n"
"    pub fn fn doctor_visite(&self) -> u32 {\n"
"        todo!(\"칉ntoarce num캒rul de vizite ale utilizatorului la doctor\")\n"
"    }\n"
"\n"
"    pub fn set_age(&mut self, new_age: u32) {\n"
"        todo!(\"Seteaz캒 v칙rsta utilizatorului\")\n"
"    }\n"
"\n"
"    pub fn set_height(&mut self, new_height: f32) {\n"
"        todo!(\"Stabile탳te 칥n캒l탵imea utilizatorului\")\n"
"    }\n"
"\n"
"    pub fn visit_doctor(&mut self, measurements: Measurements) -> "
"HealthReport {\n"
"        todo!(\"Actualizeaz캒 statisticile unui utilizator pe baza "
"m캒sur캒torilor de la o vizit캒 la medic\")\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    println!(\"Sunt {} 탳i v칙rsta mea este {}\", bob.name(), bob.age()), bob."
"age());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_칥n캒l탵ime() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.height(), 155.2);\n"
"}\n"
"\n"
"#[test]\n"
"fn test_set_age() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.age(), 32);\n"
"    bob.set_age(33);\n"
"    assert_eq!(bob.age(), 33);\n"
"}\n"
"\n"
"#[test]\n"
"fn test_vizita_test() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.doctor_visiteaz캒(), 0);\n"
"    let report = bob.visit_doctor(Measurements {\n"
"        칥n캒l탵ime: 156,1,\n"
"        blood_pressure: (120, 80),\n"
"    });\n"
"    assert_eq!(report.patient_name, \"Bob\");\n"
"    assert_eq!(report.visit_count, 1);\n"
"    assert_eq!(report.blood_pressure_change, None);\n"
"\n"
"    let report = bob.visit_doctor(Measurements {\n"
"        칥n캒l탵ime: 156,1,\n"
"        blood_pressure: (115, 76),\n"
"    });\n"
"\n"
"    assert_eq!(report.visit_count, 2);\n"
"    assert_eq!(report.blood_pressure_change, Some((-5, -4)));\n"
"}\n"
"```"

#: src/std.md:3
#, fuzzy
msgid ""
"Rust comes with a standard library which helps establish a set of common "
"types used by Rust libraries and programs. This way, two libraries can work "
"together smoothly because they both use the same `String` type."
msgstr ""
"Rust vine cu o bibliotec캒 standard care ajut캒 la stabilirea unui set de "
"tipuri comune utilizate de bibliotecile 탳i programele Rust. 칉n acest fel, "
"dou캒 biblioteci pot lucra 칥mpreun캒 f캒r캒 probleme, deoarece ambele utilizeaz캒 "
"acela탳i tip `String`."

#: src/std.md:7
#, fuzzy
msgid "The common vocabulary types include:"
msgstr "Tipurile comune de vocabular includ:"

#: src/std.md:9
#, fuzzy
msgid ""
"[`Option` and `Result`](std/option-result.md) types: used for optional "
"values and [error handling](error-handling.md)."
msgstr ""
"tipurile [`Option` 탳i `Result`](std/option-result.md): utilizate pentru "
"valorile op탵ionale 탳i [error handling](error-handling.md)."

#: src/std.md:12
#, fuzzy
msgid "[`String`](std/string.md): the default string type used for owned data."
msgstr ""
"[`String`](std/string.md): tipul de 탳ir de caractere implicit utilizat "
"pentru datele de탵inute."

#: src/std.md:14
#, fuzzy
msgid "[`Vec`](std/vec.md): a standard extensible vector."
msgstr "[`Vec`](std/vec.md): un vector extensibil standard."

#: src/std.md:16
#, fuzzy
msgid ""
"[`HashMap`](std/hashmap.md): a hash map type with a configurable hashing "
"algorithm."
msgstr ""
"[`HashMap`](std/hashmap.md): un tip de hart캒 hash cu un algoritm de hashing "
"configurabil."

#: src/std.md:19
#, fuzzy
msgid "[`Box`](std/box.md): an owned pointer for heap-allocated data."
msgstr "[`Box`](std/box.md): un pointer de탵inut pentru datele alocate 칥n heap."

#: src/std.md:21
#, fuzzy
msgid ""
"[`Rc`](std/rc.md): a shared reference-counted pointer for heap-allocated "
"data."
msgstr ""
"[`Rc`](std/rc.md): un pointer partajat cu referin탵e pentru date alocate 칥n "
"heap."

#: src/std.md:25
#, fuzzy
msgid ""
"In fact, Rust contains several layers of the Standard Library: `core`, "
"`alloc` and `std`. "
msgstr ""
"De fapt, Rust con탵ine mai multe straturi ale bibliotecii standard: `core`, "
"`alloc` 탳i `std`."

#: src/std.md:26
#, fuzzy
msgid ""
"`core` includes the most basic types and functions that don't depend on "
"`libc`, allocator or even the presence of an operating system. "
msgstr ""
"`core` include cele mai de baz캒 tipuri 탳i func탵ii care nu depind de `libc`, "
"de alocator sau chiar de prezen탵a unui sistem de operare."

#: src/std.md:28
#, fuzzy
msgid ""
"`alloc` includes types which require a global heap allocator, such as `Vec`, "
"`Box` and `Arc`."
msgstr ""
"`alloc` include tipuri care necesit캒 un alocator global de heap, cum ar fi "
"`Vec`, `Box` 탳i `Arc`."

#: src/std.md:29
#, fuzzy
msgid ""
"Embedded Rust applications often only use `core`, and sometimes `alloc`."
msgstr ""
"Aplica탵iile Rust 칥ncorporate folosesc adesea doar `core` 탳i uneori `alloc`."

#: src/std/option-result.md:1
#, fuzzy
msgid "`Option` and `Result`"
msgstr "`Op탵iune` 탳i `Rezultat`"

#: src/std/option-result.md:3
#, fuzzy
msgid "The types represent optional data:"
msgstr "Tipurile reprezint캒 date op탵ionale:"

#: src/std/option-result.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let numbers = vec![10, 20, 30];\n"
"    let first: Option<&i8> = numbers.first();\n"
"    println!(\"first: {first:?}\");\n"
"\n"
"    let arr: Result<[i8; 3], Vec<i8>> = numbers.try_into();\n"
"    println!(\"arr: {arr:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    let numbers = vec![10, 20, 30];\n"
"    let first: Option<&i8> = numbers.first();\n"
"    println!(\"first: {first:?}\");\n"
"\n"
"    let arr: Result&lt;[i8; 3], Vec<i8>&gt; = numbers.try_into();\n"
"    println!(\"arr: {arr:?}\");\n"
"}\n"
"```"

#: src/std/option-result.md:18
#, fuzzy
msgid "`Option` and `Result` are widely used not just in the standard library."
msgstr ""
"`Option` 탳i `Result` sunt utilizate pe scar캒 larg캒, nu doar 칥n biblioteca "
"standard."

#: src/std/option-result.md:19
#, fuzzy
msgid "`Option<&T>` has zero space overhead compared to `&T`."
msgstr "`Option<&T>`` are un spa탵iu de lucru zero 칥n compara탵ie cu `&T`."

#: src/std/option-result.md:20
#, fuzzy
msgid ""
"`Result` is the standard type to implement error handling as we will see on "
"Day 3."
msgstr ""
"`Result` este tipul standard pentru a implementa gestionarea erorilor, dup캒 "
"cum vom vedea 칥n ziua 3."

#: src/std/option-result.md:21
#, fuzzy
msgid ""
"`try_into` attempts to convert the vector into a fixed-sized array. This can "
"fail:"
msgstr ""
"`try_into` 칥ncearc캒 s캒 converteasc캒 vectorul 칥ntr-o matrice de dimensiune "
"fix캒. Acest lucru poate e탳ua:"

#: src/std/option-result.md:22
#, fuzzy
msgid ""
"If the vector has the right size, `Result::Ok` is returned with the array."
msgstr ""
"Dac캒 vectorul are dimensiunea corect캒, se returneaz캒 `Result::Ok` 칥mpreun캒 "
"cu matricea."

#: src/std/option-result.md:23
#, fuzzy
msgid "Otherwise, `Result::Err` is returned with the original vector."
msgstr ""
"칉n caz contrar, se returneaz캒 `Result::Err` 칥mpreun캒 cu vectorul original."

#: src/std/string.md:3
#, fuzzy
msgid ""
"[`String`](https://doc.rust-lang.org/std/string/struct.String.html) is the "
"standard heap-allocated growable UTF-8 string buffer:"
msgstr ""
"[`String`](https://doc.rust-lang.org/std/string/struct.String.html) este "
"bufferul standard de 탳iruri UTF-8, cu alocare 칥n heap, care poate cre탳te:"

#: src/std/string.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::new();\n"
"    s1.push_str(\"Hello\");\n"
"    println!(\"s1: len = {}, capacity = {}\", s1.len(), s1.capacity());\n"
"\n"
"    let mut s2 = String::with_capacity(s1.len() + 1);\n"
"    s2.push_str(&s1);\n"
"    s2.push('!');\n"
"    println!(\"s2: len = {}, capacity = {}\", s2.len(), s2.capacity());\n"
"\n"
"    let s3 = String::from(\"游뻟릖셒");\n"
"    println!(\"s3: len = {}, number of chars = {}\", s3.len(),\n"
"             s3.chars().count());\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    let mut s1 = String::new();\n"
"    s1.push_str(\"Hello\");\n"
"    println!(\"s1: len = {}, capacity = {}\", s1.len(), s1.capacity()));\n"
"\n"
"    let mut s2 = String::with_capacity(s1.len() + 1);\n"
"    s2.push_str(&s1);\n"
"    s2.push('!');\n"
"    println!(\"s2: len = {}, capacity = {}\", s2.len(), s2.capacity());\n"
"\n"
"    let s3 = String::from(\"游뻟릖셒");\n"
"    printlnn!(\"s3: len = {}, number of chars = {}\", s3.len(),\n"
"             s3.chars().count()));\n"
"}\n"
"```"

#: src/std/string.md:22
#, fuzzy
msgid ""
"`String` implements [`Deref<Target = str>`](https://doc.rust-lang.org/std/"
"string/struct.String.html#deref-methods-str), which means that you can call "
"all `str` methods on a `String`."
msgstr ""
"`String` implementeaz캒 [`Deref<Target = str>`](https://doc.rust-lang.org/std/"
"string/struct.String.html#deref-methods-str), ceea ce 칥nseamn캒 c캒 pute탵i "
"apela toate metodele `str` pe un `String`."

#: src/std/string.md:30
#, fuzzy
msgid ""
"`String::new` returns a new empty string, use `String::with_capacity` when "
"you know how much data you want to push to the string."
msgstr ""
"`String::new` returneaz캒 un nou 탳ir de caractere gol, utiliza탵i `String::"
"with_capacity` atunci c칙nd 탳ti탵i c칙te date dori탵i s캒 introduce탵i 칥n 탳ir."

#: src/std/string.md:31
#, fuzzy
msgid ""
"`String::len` returns the size of the `String` in bytes (which can be "
"different from its length in characters)."
msgstr ""
"`String::len` returneaz캒 dimensiunea 탳irului `String` 칥n octe탵i (care poate "
"fi diferit캒 de lungimea sa 칥n caractere)."

#: src/std/string.md:32
#, fuzzy
msgid ""
"`String::chars` returns an iterator over the actual characters. Note that a "
"`char` can be different from what a human will consider a \"character\" due "
"to [grapheme clusters](https://docs.rs/unicode-segmentation/latest/"
"unicode_segmentation/struct.Graphemes.html)."
msgstr ""
"`String::chars` returneaz캒 un iterator peste caracterele actuale. Re탵ine탵i "
"c캒 un `char` poate fi diferit de ceea ce un om va considera un \"caracter\" "
"din cauza [grapheme clusters](https://docs.rs/unicode-segmentation/latest/"
"unicode_segmentation/struct.Graphemes.html)."

#: src/std/string.md:33
#, fuzzy
msgid ""
"When people refer to strings they could either be talking about `&str` or "
"`String`."
msgstr ""
"Atunci c칙nd oamenii se refer캒 la 탳iruri de caractere, ei pot vorbi fie "
"despre `&str`, fie despre `String`."

#: src/std/string.md:34
#, fuzzy
msgid ""
"When a type implements `Deref<Target = T>`, the compiler will let you "
"transparently call methods from `T`."
msgstr ""
"Atunci c칙nd un tip implementeaz캒 `Deref<Target = T>`, compilatorul v캒 va "
"permite s캒 apela탵i 칥n mod transparent metodele din `T`."

#: src/std/string.md:35
#, fuzzy
msgid ""
"`String` implements `Deref<Target = str>` which transparently gives it "
"access to `str`'s methods."
msgstr ""
"`String` implementeaz캒 `Deref<Target = str>`, ceea ce 칥i ofer캒 칥n mod "
"transparent acces la metodele lui `str`."

#: src/std/string.md:36
#, fuzzy
msgid "Write and compare `let s3 = s1.deref();` and  `let s3 = &*s1;`."
msgstr "Scrie탵i 탳i compara탵i `let s3 = s1.deref();` 탳i `let s3 = &*s1;`."

#: src/std/string.md:37
#, fuzzy
msgid ""
"`String` is implemented as a wrapper around a vector of bytes, many of the "
"operations you see supported on vectors are also supported on `String`, but "
"with some extra guarantees."
msgstr ""
"`String` este implementat ca un 칥nveli탳 칥n jurul unui vector de octe탵i, "
"multe dintre opera탵iile pe care le vede탵i acceptate pentru vectori sunt "
"acceptate 탳i pentru `String`, dar cu unele garan탵ii suplimentare."

#: src/std/string.md:38
#, fuzzy
msgid "Compare the different ways to index a `String`:"
msgstr "Compara탵i diferitele moduri de a indexa un `String`:"

#: src/std/string.md:39
#, fuzzy
msgid ""
"To a character by using `s3.chars().nth(i).unwrap()` where `i` is in-bound, "
"out-of-bounds."
msgstr ""
"La un caracter prin utilizarea `s3.chars().nth(i).unwrap()` unde `i` este 칥n "
"interiorul limitelor, 칥n afara limitelor."

#: src/std/string.md:40
#, fuzzy
msgid ""
"To a substring by using `s3[0..4]`, where that slice is on character "
"boundaries or not."
msgstr ""
"La o sub탳ir캒 folosind `s3[0..4]`, unde acea felie se afl캒 sau nu la limitele "
"caracterelor."

#: src/std/vec.md:1
#, fuzzy
msgid "`Vec`"
msgstr "`Vec`"

#: src/std/vec.md:3
#, fuzzy
msgid ""
"[`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html) is the standard "
"resizable heap-allocated buffer:"
msgstr ""
"[`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html) este un buffer "
"standard redimensionabil alocat pe heap:"

#: src/std/vec.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v1 = Vec::new();\n"
"    v1.push(42);\n"
"    println!(\"v1: len = {}, capacity = {}\", v1.len(), v1.capacity());\n"
"\n"
"    let mut v2 = Vec::with_capacity(v1.len() + 1);\n"
"    v2.extend(v1.iter());\n"
"    v2.push(9999);\n"
"    println!(\"v2: len = {}, capacity = {}\", v2.len(), v2.capacity());\n"
"\n"
"    // Canonical macro to initialize a vector with elements.\n"
"    let mut v3 = vec![0, 0, 1, 2, 3, 4];\n"
"\n"
"    // Retain only the even elements.\n"
"    v3.retain(|x| x % 2 == 0);\n"
"    println!(\"{v3:?}\");\n"
"\n"
"    // Remove consecutive duplicates.\n"
"    v3.dedup();\n"
"    println!(\"{v3:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    let mut v1 = Vec::new();\n"
"    v1.push(42);\n"
"    println!(\"v1: len = {}, capacity = {}\", v1.len(), v1.capacity()));\n"
"\n"
"    let mut v2 = Vec::with_capacity(v1.len() + 1);\n"
"    v2.extend(v1.iter());\n"
"    v2.push(9999);\n"
"    println!(\"v2: len = {}, capacity = {}\", v2.len(), v2.len(), v2."
"capacity());\n"
"\n"
"    // Macro canonic캒 pentru ini탵ializarea unui vector cu elemente.\n"
"    let mut v3 = vec![0, 0, 1, 1, 2, 2, 3, 4];\n"
"\n"
"    // Re탵ine doar elementele pare.\n"
"    v3.retain(|x| x| x % 2 == 0);\n"
"    println!(\"{v3:?}\");\n"
"\n"
"    // Elimin캒 duplicatele consecutive.\n"
"    v3.dedup();\n"
"    println!(\"{v3:?}\");\n"
"}\n"
"```"

#: src/std/vec.md:29
#, fuzzy
msgid ""
"`Vec` implements [`Deref<Target = [T]>`](https://doc.rust-lang.org/std/vec/"
"struct.Vec.html#deref-methods-%5BT%5D), which means that you can call slice "
"methods on a `Vec`."
msgstr ""
"`Vec` implementeaz캒 [`Deref<Target = [T]>`]](https://doc.rust-lang.org/std/"
"vec/struct.Vec.html#deref-methods-%5BT%5D), ceea ce 칥nseamn캒 c캒 pute탵i apela "
"metode de feliere pe un `Vec`."

#: src/std/vec.md:37
#, fuzzy
msgid ""
"`Vec` is a type of collection, along with `String` and `HashMap`. The data "
"it contains is stored on the heap. This means the amount of data doesn't "
"need to be  known at compile time. It can grow or shrink at runtime."
msgstr ""
"`Vec` este un tip de colec탵ie, al캒turi de `String` 탳i `HashMap`. Datele pe "
"care le con탵ine sunt stocate 칥n heap. Acest lucru 칥nseamn캒 c캒 nu este "
"necesar s캒 se cunoasc캒 cantitatea de date 칥n momentul compil캒rii. Aceasta "
"poate cre탳te sau se poate mic탳ora 칥n timpul execu탵iei."

#: src/std/vec.md:40
#, fuzzy
msgid ""
"Notice how `Vec<T>` is a generic type too, but you don't have to specify `T` "
"explicitly. As always with Rust type inference, the `T` was established "
"during the first `push` call."
msgstr ""
"Observa탵i cum `Vec<T>` este 탳i el un tip generic, dar nu trebuie s캒 "
"specifica탵i `T` 칥n mod explicit. Ca 칥ntotdeauna 칥n cazul inferen탵ei de tip "
"Rust, `T` a fost stabilit 칥n timpul primului apel `push`."

#: src/std/vec.md:42
#, fuzzy
msgid ""
"`vec![...]` is a canonical macro to use instead of `Vec::new()` and it "
"supports adding initial elements to the vector."
msgstr ""
"`vec![...]` este o macro canonic캒 care poate fi utilizat캒 칥n locul lui `Vec::"
"new()` 탳i permite ad캒ugarea de elemente ini탵iale 칥n vector."

#: src/std/vec.md:44
#, fuzzy
msgid ""
"To index the vector you use `[` `]`, but they will panic if out of bounds. "
"Alternatively, using `get` will return an `Option`. The `pop` function will "
"remove the last element."
msgstr ""
"Pentru a indexa vectorul se folose탳te `[` ` `]` `, dar se va crea panic캒 "
"dac캒 este 칥n afara limitelor. Alternativ, folosind `get` se va returna un "
"`Option`. Func탵ia `pop` va elimina ultimul element."

#: src/std/vec.md:46
#, fuzzy
msgid ""
"Show iterating over a vector and mutating the value: `for e in &mut v { *e "
"+= 50; }`"
msgstr ""
"Se arat캒 iterarea peste un vector 탳i mutarea valorii: `for e in &mut v { *e "
"+= 50; }`"

#: src/std/hashmap.md:1 src/bare-metal/no_std.md:46
#, fuzzy
msgid "`HashMap`"
msgstr "`HashMap`"

#: src/std/hashmap.md:3
#, fuzzy
msgid "Standard hash map with protection against HashDoS attacks:"
msgstr "Hart캒 hash standard cu protec탵ie 칥mpotriva atacurilor HashDoS:"

#: src/std/hashmap.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::collections::HashMap;\n"
"\n"
"fn main() {\n"
"    let mut page_counts = HashMap::new();\n"
"    page_counts.insert(\"Adventures of Huckleberry Finn\".to_string(), "
"207);\n"
"    page_counts.insert(\"Grimms' Fairy Tales\".to_string(), 751);\n"
"    page_counts.insert(\"Pride and Prejudice\".to_string(), 303);\n"
"\n"
"    if !page_counts.contains_key(\"Les Mis칠rables\") {\n"
"        println!(\"We know about {} books, but not Les Mis칠rables.\",\n"
"                 page_counts.len());\n"
"    }\n"
"\n"
"    for book in [\"Pride and Prejudice\", \"Alice's Adventure in "
"Wonderland\"] {\n"
"        match page_counts.get(book) {\n"
"            Some(count) => println!(\"{book}: {count} pages\"),\n"
"            None => println!(\"{book} is unknown.\")\n"
"        }\n"
"    }\n"
"\n"
"    // Use the .entry() method to insert a value if nothing is found.\n"
"    for book in [\"Pride and Prejudice\", \"Alice's Adventure in "
"Wonderland\"] {\n"
"        let page_count: &mut i32 = page_counts.entry(book.to_string())."
"or_insert(0);\n"
"        *page_count += 1;\n"
"    }\n"
"\n"
"    println!(\"{page_counts:#?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"folosi탵i std::collections::HashMap;\n"
"\n"
"fn main() {\n"
"    let mut page_counts = HashMap::new();\n"
"    page_counts.insert(\"Aventurile lui Huckleberry Finn\".to_string(), "
"207);\n"
"    page_counts.insert(\"Grimms' Fairy Tales\".to_string(), 751);\n"
"    page_counts.insert(\"Pride and Prejudice\".to_string(), 303);\n"
"\n"
"    if !page_counts.contains_key(\"Les Mis칠rables\") {\n"
"        println!(\"탲tim despre {} c캒r탵i, dar nu 탳i despre Les Mis칠rables."
"\",\n"
"                 page_counts.len());\n"
"    }\n"
"\n"
"    for book in [\"M칙ndrie 탳i prejudecat캒\", \"Aventura lui Alice 칥n 탴ara "
"Minunilor\"] {\n"
"        match page_counts.get(book) {\n"
"            Some(count) => println!(\"{book}: {count} pagini\"),\n"
"            None => println!(\"{book} este necunoscut.\")\n"
"        }\n"
"    }\n"
"\n"
"    // Utiliza탵i metoda .entry() pentru a introduce o valoare dac캒 nu se "
"g캒se탳te nimic.\n"
"    for book in [\"Pride and Prejudice\", \"Alice's Adventure in "
"Wonderland\"] {\n"
"        let page_count: &mut i32 = page_counts.entry(book.to_string())."
"or_insert(0);\n"
"        *page_count += 1;\n"
"    }\n"
"\n"
"    println!(\"{page_counts:#?}\");\n"
"}\n"
"```"

#: src/std/hashmap.md:38
#, fuzzy
msgid ""
"`HashMap` is not defined in the prelude and needs to be brought into scope."
msgstr ""
"`HashMap` nu este definit 칥n preludiu 탳i trebuie s캒 fie adus 칥n domeniul de "
"aplicare."

#: src/std/hashmap.md:39
#, fuzzy
msgid ""
"Try the following lines of code. The first line will see if a book is in the "
"hashmap and if not return an alternative value. The second line will insert "
"the alternative value in the hashmap if the book is not found."
msgstr ""
"칉ncerca탵i urm캒toarele linii de cod. Prima linie va verifica dac캒 o carte se "
"afl캒 칥n hashmap 탳i, 칥n caz contrar, va returna o valoare alternativ캒. A doua "
"linie va introduce valoarea alternativ캒 칥n hashmap dac캒 nu se g캒se탳te cartea."

#: src/std/hashmap.md:41
#, fuzzy
msgid ""
"```rust,ignore\n"
"  let pc1 = page_counts\n"
"      .get(\"Harry Potter and the Sorcerer's Stone\")\n"
"      .unwrap_or(&336);\n"
"  let pc2 = page_counts\n"
"      .entry(\"The Hunger Games\".to_string())\n"
"      .or_insert(374);\n"
"```"
msgstr ""
"```rust,ignore\n"
"  let pc1 = page_counts\n"
"      .get(\"Harry Potter 탳i piatra vr캒jitoarelor\")\n"
"      .unwrap_or(&336);\n"
"  let pc2 = page_counts\n"
"      .entry(\"The Hunger Games\".to_string())\n"
"      .or_insert(374);\n"
"```"

#: src/std/hashmap.md:49
#, fuzzy
msgid "Unlike `vec!`, there is unfortunately no standard `hashmap!` macro."
msgstr ""
"Spre deosebire de `vec!`, din p캒cate nu exist캒 o macro standard `hashmap!`."

#: src/std/hashmap.md:50
#, fuzzy
msgid ""
"Although, since Rust 1.56, HashMap implements [`From<[(K, V); N]>`](https://"
"doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#impl-"
"From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E), which allows "
"us to easily initialize a hash map from a literal array:"
msgstr ""
"Cu toate c캒, 칥ncep칙nd cu Rust 1.56, HashMap implementeaz캒 [`From<[(K, V); "
"N]>`]](https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap."
"html#impl-From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E), "
"ceea ce ne permite s캒 ini탵ializ캒m cu u탳urin탵캒 o hart캒 hash dintr-o matrice "
"literal캒:"

#: src/std/hashmap.md:52
#, fuzzy
msgid ""
"```rust,ignore\n"
"  let page_counts = HashMap::from([\n"
"    (\"Harry Potter and the Sorcerer's Stone\".to_string(), 336),\n"
"    (\"The Hunger Games\".to_string(), 374),\n"
"  ]);\n"
"```"
msgstr ""
"```칥ncredere,ignora\n"
"  let page_counts = HashMap::from([\n"
"    (\"Harry Potter 탳i Piatra Vr캒jitoarelor\".to_string(), 336),\n"
"    (\"Jocurile foamei\".to_string(), 374),\n"
"  ]);\n"
"```"

#: src/std/hashmap.md:59
#, fuzzy
msgid ""
"Alternatively HashMap can be built from any `Iterator` which yields key-"
"value tuples."
msgstr ""
"Alternativ, HashMap poate fi construit din orice `Iterator` care produce "
"tupluri cheie-valoare."

#: src/std/hashmap.md:60
#, fuzzy
msgid ""
"We are showing `HashMap<String, i32>`, and avoid using `&str` as key to make "
"examples easier. Using references in collections can, of course, be done, "
"but it can lead into complications with the borrow checker."
msgstr ""
"Prezent캒m `HashMap<String, i32>` 탳i evit캒m s캒 folosim `&str` ca cheie pentru "
"a face exemplele mai u탳oare. Folosirea referin탵elor 칥n colec탵ii se poate "
"face, desigur, dar poate duce la complica탵ii cu verificatorul de 칥mprumuturi."

#: src/std/hashmap.md:62
#, fuzzy
msgid ""
"Try removing `to_string()` from the example above and see if it still "
"compiles. Where do you think we might run into issues?"
msgstr ""
"칉ncerca탵i s캒 elimina탵i `to_string()` din exemplul de mai sus 탳i vede탵i dac캒 "
"se compileaz캒 칥n continuare. Unde crede탵i c캒 am putea 칥nt칙mpina probleme?"

#: src/std/hashmap.md:64
#, fuzzy
msgid ""
"This type has several \"method-specific\" return types, such as `std::"
"collections::hash_map::Keys`. These types often appear in searches of the "
"Rust docs. Show students the docs for this type, and the helpful link back "
"to the `keys` method."
msgstr ""
"Acest tip are mai multe tipuri de returnare \"specifice metodei\", cum ar fi "
"`std::collections::hash_map::Keys`. Aceste tipuri apar adesea 칥n c캒ut캒rile "
"din documentele Rust. Ar캒ta탵i studen탵ilor documenta탵ia pentru acest tip 탳i "
"leg캒tura util캒 c캒tre metoda `keys`."

#: src/std/box.md:1
#, fuzzy
msgid "`Box`"
msgstr "`Box`"

#: src/std/box.md:3
#, fuzzy
msgid ""
"[`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) is an owned "
"pointer to data on the heap:"
msgstr ""
"[`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) este un pointer "
"de탵inut c캒tre datele de pe heap:"

#: src/std/box.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let five = Box::new(5);\n"
"    println!(\"five: {}\", *five);\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    let five = Box::new(5);\n"
"    println!(\"cinci: {}\", *cinci);\n"
"}\n"
"```"

#: src/std/box.md:26
#, fuzzy
msgid ""
"`Box<T>` implements `Deref<Target = T>`, which means that you can [call "
"methods from `T` directly on a `Box<T>`](https://doc.rust-lang.org/std/ops/"
"trait.Deref.html#more-on-deref-coercion)."
msgstr ""
"`Box<T>` implementeaz캒 `Deref<Target = T>`, ceea ce 칥nseamn캒 c캒 pute탵i "
"[apela metode din `T` direct pe un `Box<T>`](https://doc.rust-lang.org/std/"
"ops/trait.Deref.html#more-on-deref-coercion)."

#: src/std/box.md:34
#, fuzzy
msgid ""
"`Box` is like `std::unique_ptr` in C++, except that it's guaranteed to be "
"not null. "
msgstr ""
"`Box` este ca 탳i `std::unique_ptr` 칥n C++, cu excep탵ia faptului c캒 este "
"garantat a nu fi nul."

#: src/std/box.md:35
#, fuzzy
msgid ""
"In the above example, you can even leave out the `*` in the `println!` "
"statement thanks to `Deref`. "
msgstr ""
"칉n exemplul de mai sus, pute탵i chiar s캒 omite탵i `*` 칥n instruc탵iunea "
"`println!` datorit캒 lui `Deref`."

#: src/std/box.md:36
#, fuzzy
msgid "A `Box` can be useful when you:"
msgstr "Un `Box` poate fi util atunci c칙nd:"

#: src/std/box.md:37
#, fuzzy
msgid ""
"have a type whose size that can't be known at compile time, but the Rust "
"compiler wants to know an exact size."
msgstr ""
"au un tip a c캒rui dimensiune nu poate fi cunoscut캒 la compilare, dar "
"compilatorul Rust dore탳te s캒 탳tie o dimensiune exact캒."

#: src/std/box.md:38
#, fuzzy
msgid ""
"want to transfer ownership of a large amount of data. To avoid copying large "
"amounts of data on the stack, instead store the data on the heap in a `Box` "
"so only the pointer is moved."
msgstr ""
"dori탵i s캒 transfera탵i proprietatea asupra unei cantit캒탵i mari de date. "
"Pentru a evita copierea unor cantit캒탵i mari de date pe stiv캒, stoca탵i 칥n "
"schimb datele pe heap 칥ntr-un `Box`, astfel 칥nc칙t s캒 fie mutat doar "
"pointerul."

#: src/std/box-recursive.md:1
#, fuzzy
msgid "Box with Recursive Data Structures"
msgstr "Caseta cu structuri de date recursive"

#: src/std/box-recursive.md:3
#, fuzzy
msgid ""
"Recursive data types or data types with dynamic sizes need to use a `Box`:"
msgstr ""
"Tipurile de date recursive sau tipurile de date cu dimensiuni dinamice "
"trebuie s캒 utilizeze un `Box`:"

#: src/std/box-recursive.md:5 src/std/box-niche.md:3
#, fuzzy
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"enum List<T> {\n"
"    Cons(T, Box<List<T>>),\n"
"    Nil,\n"
"}\n"
"\n"
"fn main() {\n"
"    let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::"
"new(List::Nil))));\n"
"    println!(\"{list:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"#[derive(Debug)]\n"
"enum List<T> {\n"
"    Cons(T, Box&lt;List<T>&gt;),\n"
"    Nil,\n"
"}\n"
"\n"
"fn main() {\n"
"    let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::"
"new(List::Nil))));\n"
"    println!(\"{list:?}\");\n"
"}\n"
"```"

#: src/std/box-recursive.md:18
#, fuzzy
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                         :     :                                               :\n"
":    "
"list                 :     :                                               :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----"
"+   :\n"
":   | Cons | 1  | o--+----+-----+--->| Cons | 2  | o--+--->| Nil  | // | // "
"|   :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----"
"+   :\n"
":                         :     :                                               :\n"
":                         :     :                                               :\n"
"'- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"
msgstr ""
"```bob\n"
" Stiva Heap\n"
".- - - - - - - - - - - - -. .- - - - - - - - - - - - - - - - - - - - - - - "
"-.\n"
": : : :\n"
": list캒 : : : :\n"
":   +------+----+----+ : : +------+----+----+ +------+----+----+ :\n"
":   | Cons | 1 | o--+----+-----+--->| Cons | 2 | o--++--->| Nil | // | // // "
"| :\n"
":   +------+----+----+ : : +------+----+----+ +------+----+----+ :\n"
": : : :\n"
": : : :\n"
"'- - - - - - - - - - - - -' '- - - - - - - - - - - - - - - - - - - - - - - "
"-'\n"
"```"

#: src/std/box-recursive.md:33
#, fuzzy
msgid ""
"If `Box` was not used and we attempted to embed a `List` directly into the "
"`List`, the compiler would not compute a fixed size of the struct in memory "
"(`List` would be of infinite size)."
msgstr ""
"Dac캒 nu se folosea `Box` 탳i 칥ncercam s캒 칥ncorpor캒m o `List` direct 칥n "
"`List`, compilatorul nu ar fi calculat o dimensiune fix캒 a structurii 칥n "
"memorie (`List` ar fi avut o dimensiune infinit캒)."

#: src/std/box-recursive.md:36
#, fuzzy
msgid ""
"`Box` solves this problem as it has the same size as a regular pointer and "
"just points at the next element of the `List` in the heap."
msgstr ""
"`Box` rezolv캒 aceast캒 problem캒, deoarece are aceea탳i dimensiune ca un "
"pointer obi탳nuit 탳i indic캒 doar urm캒torul element din `List` 칥n heap."

#: src/std/box-recursive.md:39
#, fuzzy
msgid ""
"Remove the `Box` in the List definition and show the compiler error. "
"\"Recursive with indirection\" is a hint you might want to use a Box or "
"reference of some kind, instead of storing a value directly."
msgstr ""
"Elimina탵i `Box` din defini탵ia Listei 탳i afi탳a탵i eroarea de compilare. "
"\"Recursiv cu indirec탵ie\" este un indiciu c캒 poate dori탵i s캒 folosi탵i un "
"Box sau o referin탵캒 de un anumit tip, 칥n loc s캒 stoca탵i direct o valoare."

#: src/std/box-niche.md:16
#, fuzzy
msgid ""
"A `Box` cannot be empty, so the pointer is always valid and non-`null`. This "
"allows the compiler to optimize the memory layout:"
msgstr ""
"Un `Box` nu poate fi gol, astfel 칥nc칙t pointerul este 칥ntotdeauna valid 탳i "
"non-`null`. Acest lucru permite compilatorului s캒 optimizeze dispunerea "
"memoriei:"

#: src/std/box-niche.md:19
#, fuzzy
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - "
"-.\n"
":                         :     :                                             :\n"
":    "
"list                 :     :                                             :\n"
":   +----+----+           :     :    +----+----+    +----+------"
"+             :\n"
":   | 1  | o--+-----------+-----+--->| 2  | o--+--->| // | null "
"|             :\n"
":   +----+----+           :     :    +----+----+    +----+------"
"+             :\n"
":                         :     :                                             :\n"
":                         :     :                                             :\n"
"`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - "
"-'\n"
"```"
msgstr ""
"```bob\n"
" Stiva Heap\n"
".- - - - - - - - - - - - -. .- - - - - - - - - - - - - - - - - - - - - - -.\n"
": : : :\n"
": list캒 : : : :\n"
":   +----+----+ : : +----+----+ +----+------+ :\n"
":   | 1 | o--+-----------+-----+--->| 2 | o--++--->| // | null | :\n"
":   +----+----+ : : +----+----+ +----+------+ :\n"
": : : :\n"
": : : :\n"
"`- - - - - - - - - - - - -' '- - - - - - - - - - - - - - - - - - - - - - -'\n"
"```"

#: src/std/rc.md:1
#, fuzzy
msgid "`Rc`"
msgstr "`Rc`"

#: src/std/rc.md:3
#, fuzzy
msgid ""
"[`Rc`](https://doc.rust-lang.org/std/rc/struct.Rc.html) is a reference-"
"counted shared pointer. Use this when you need to refer to the same data "
"from multiple places:"
msgstr ""
"[`Rc`](https://doc.rust-lang.org/std/rc/struct.Rc.html) este un pointer "
"partajat cu num캒r캒toare de referin탵e. Folosi탵i-l atunci c칙nd trebuie s캒 "
"face탵i referire la acelea탳i date din mai multe locuri:"

#: src/std/rc.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::rc::Rc;\n"
"\n"
"fn main() {\n"
"    let mut a = Rc::new(10);\n"
"    let mut b = Rc::clone(&a);\n"
"\n"
"    println!(\"a: {a}\");\n"
"    println!(\"b: {b}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"use std::rc::Rc;\n"
"\n"
"fn main() {\n"
"    let mut a = Rc::new(10);\n"
"    let mut b = Rc::clone(&a);\n"
"\n"
"    println!(\"a: {a}\");\n"
"    println!(\"b: {b}\");\n"
"}\n"
"```"

#: src/std/rc.md:18
#, fuzzy
msgid ""
"See [`Arc`](../concurrency/shared_state/arc.md) and [`Mutex`](https://doc."
"rust-lang.org/std/sync/struct.Mutex.html) if you are in a multi-threaded "
"context."
msgstr ""
"Consulta탵i [`Arc`](../concurrency/shared_state/arc.md) 탳i [`Mutex`](https://"
"doc.rust-lang.org/std/sync/struct.Mutex.html) dac캒 v캒 afla탵i 칥ntr-un context "
"cu mai multe fire."

#: src/std/rc.md:19
#, fuzzy
msgid ""
"You can _downgrade_ a shared pointer into a [`Weak`](https://doc.rust-lang."
"org/std/rc/struct.Weak.html) pointer to create cycles that will get dropped."
msgstr ""
"Pute탵i transforma un pointer partajat 칥ntr-un pointer [`Weak`](https://doc."
"rust-lang.org/std/rc/struct.Weak.html) pentru a crea cicluri care vor fi "
"abandonate."

#: src/std/rc.md:29
#, fuzzy
msgid ""
"`Rc`'s count ensures that its contained value is valid for as long as there "
"are references."
msgstr ""
"num캒r캒toarea lui `Rc` asigur캒 c캒 valoarea sa con탵inut캒 este valabil캒 at칙ta "
"timp c칙t exist캒 referin탵e."

#: src/std/rc.md:30
#, fuzzy
msgid "`Rc` in Rust is like `std::shared_ptr` in C++."
msgstr "`Rc` 칥n Rust este ca `std::shared_ptr` 칥n C++."

#: src/std/rc.md:31
#, fuzzy
msgid ""
"`Rc::clone` is cheap: it creates a pointer to the same allocation and "
"increases the reference count. Does not make a deep clone and can generally "
"be ignored when looking for performance issues in code."
msgstr ""
"`Rc::clone` este ieftin: creeaz캒 un pointer la aceea탳i alocare 탳i cre탳te "
"num캒rul de referin탵e. Nu realizeaz캒 o clon캒 profund캒 탳i poate fi 칥n general "
"ignorat캒 atunci c칙nd se caut캒 probleme de performan탵캒 칥n cod."

#: src/std/rc.md:32
#, fuzzy
msgid ""
"`make_mut` actually clones the inner value if necessary (\"clone-on-write\") "
"and returns a mutable reference."
msgstr ""
"`make_mut` cloneaz캒 de fapt valoarea interioar캒 dac캒 este necesar (\"clone-"
"on-write\") 탳i returneaz캒 o referin탵캒 mutabil캒."

#: src/std/rc.md:33
#, fuzzy
msgid "Use `Rc::strong_count` to check the reference count."
msgstr "Utiliza탵i `Rc::strong_count` pentru a verifica num캒rul de referin탵e."

#: src/std/rc.md:34
#, fuzzy
msgid ""
"`Rc::downgrade` gives you a _weakly reference-counted_ object to create "
"cycles that will be dropped properly (likely in combination with `RefCell`, "
"on the next slide)."
msgstr ""
"`Rc::downgrade` v캒 ofer캒 un obiect cu un num캒r slab de referin탵e pentru a "
"crea cicluri care vor fi abandonate 칥n mod corespunz캒tor (probabil 칥n "
"combina탵ie cu `RefCell`, pe slide-ul urm캒tor)."

#: src/std/cell.md:1
#, fuzzy
msgid "`Cell` and `RefCell`"
msgstr "`Cell` 탳i `RefCell`"

#: src/std/cell.md:3
#, fuzzy
msgid ""
"[`Cell`](https://doc.rust-lang.org/std/cell/struct.Cell.html) and [`RefCell`]"
"(https://doc.rust-lang.org/std/cell/struct.RefCell.html) implement what Rust "
"calls _interior mutability:_ mutation of values in an immutable context."
msgstr ""
"[`Cell`](https://doc.rust-lang.org/std/cell/struct.Cell.html) 탳i [`RefCell`]"
"(https://doc.rust-lang.org/std/cell/struct.RefCell.html) implementeaz캒 ceea "
"ce Rust nume탳te _mutabilitatea interioar캒:_ muta탵ia valorilor 칥ntr-un "
"context imuabil."

#: src/std/cell.md:8
#, fuzzy
msgid ""
"`Cell` is typically used for simple types, as it requires copying or moving "
"values. More complex interior types typically use `RefCell`, which tracks "
"shared and exclusive references at runtime and panics if they are misused."
msgstr ""
"`Cell` este utilizat de obicei pentru tipuri simple, deoarece necesit캒 "
"copierea sau mutarea valorilor. Tipurile interioare mai complexe folosesc de "
"obicei `RefCell`, care urm캒re탳te referin탵ele partajate 탳i exclusive 칥n "
"timpul execu탵iei 탳i intr캒 칥n panic캒 dac캒 acestea sunt folosite 칥n mod abuziv."

#: src/std/cell.md:12
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::cell::RefCell;\n"
"use std::rc::Rc;\n"
"\n"
"#[derive(Debug, Default)]\n"
"struct Node {\n"
"    value: i64,\n"
"    children: Vec<Rc<RefCell<Node>>>,\n"
"}\n"
"\n"
"impl Node {\n"
"    fn new(value: i64) -> Rc<RefCell<Node>> {\n"
"        Rc::new(RefCell::new(Node { value, ..Node::default() }))\n"
"    }\n"
"\n"
"    fn sum(&self) -> i64 {\n"
"        self.value + self.children.iter().map(|c| c.borrow().sum()).sum::"
"<i64>()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let root = Node::new(1);\n"
"    root.borrow_mut().children.push(Node::new(5));\n"
"    let subtree = Node::new(10);\n"
"    subtree.borrow_mut().children.push(Node::new(11));\n"
"    subtree.borrow_mut().children.push(Node::new(12));\n"
"    root.borrow_mut().children.push(subtree);\n"
"\n"
"    println!(\"graph: {root:#?}\");\n"
"    println!(\"graph sum: {}\", root.borrow().sum());\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"folosi탵i std::cell::RefCell;\n"
"use std::rc::Rc;\n"
"\n"
"#[derive(Debug, Default)]\n"
"struct Node {\n"
"    value: i64,\n"
"    children: Vec&lt;Rc&lt;RefCell<Node>&gt;&gt;,\n"
"}\n"
"\n"
"impl Node {\n"
"    fn new(value: i64) -&gt; Rc&lt;RefCell<Node>&gt; {\n"
"        Rc::new(RefCell::new(Node { value, ..Node::default() })))\n"
"    }\n"
"\n"
"    fn sum(&amp;self) -&gt; i64 {\n"
"        self.value + self.children.iter().map(|c| c.borrow().sum()).sum::"
"<i64>()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let root = Node::new(1);\n"
"    root.borrow_mut().children.push(Node::new(5));\n"
"    let subtree = Node::new(10);\n"
"    subtree.borrow_mut().children.push(Node::new(11));\n"
"    subtree.borrow_mut().children.push(Node::new(12));\n"
"    root.borrow_mut().children.push(subtree);\n"
"\n"
"    println!(\"graph: {root:#?}\");\n"
"    printlnn!(\"graph sum: {}\", root.borrow().sum()));\n"
"}\n"
"```"

#: src/std/cell.md:47
#, fuzzy
msgid ""
"If we were using `Cell` instead of `RefCell` in this example, we would have "
"to move the `Node` out of the `Rc` to push children, then move it back in. "
"This is safe because there's always one, un-referenced value in the cell, "
"but it's not ergonomic."
msgstr ""
"Dac캒 am fi folosit `Cell` 칥n loc de `RefCell` 칥n acest exemplu, ar fi "
"trebuit s캒 mut캒m `Node` 칥n afara `Rc` pentru a 칥mpinge copiii, apoi s캒 칥l "
"mut캒m 칥napoi. Acest lucru este sigur, deoarece 칥n celul캒 exist캒 칥ntotdeauna "
"o singur캒 valoare nereferen탵iat캒, dar nu este ergonomic."

#: src/std/cell.md:48
#, fuzzy
msgid ""
"To do anything with a Node, you must call a `RefCell` method, usually "
"`borrow` or `borrow_mut`."
msgstr ""
"Pentru a face ceva cu un nod, trebuie s캒 apela탵i o metod캒 `RefCell`, de "
"obicei `borrow` sau `borrow_mut`."

#: src/std/cell.md:49
#, fuzzy
msgid ""
"Demonstrate that reference loops can be created by adding `root` to `subtree."
"children` (don't try to print it!)."
msgstr ""
"Demonstra탵i c캒 buclele de referin탵캒 pot fi create prin ad캒ugarea lui `root` "
"la `subtree.children` (nu 칥ncerca탵i s캒 le imprima탵i!)."

#: src/std/cell.md:50
#, fuzzy
msgid ""
"To demonstrate a runtime panic, add a `fn inc(&mut self)` that increments "
"`self.value` and calls the same method on its children. This will panic in "
"the presence of the reference loop, with `thread 'main' panicked at 'already "
"borrowed: BorrowMutError'`."
msgstr ""
"Pentru a demonstra o panic캒 칥n timpul execu탵iei, ad캒uga탵i un `fn inc(&mut "
"self)` care m캒re탳te `self.value` 탳i apeleaz캒 aceea탳i metod캒 asupra copiilor "
"s캒i. Aceasta va intra 칥n panic캒 칥n prezen탵a buclei de referin탵캒, cu `thread-"
"ul `main` panicat la `ready loaned: BorrowMutError'`."

#: src/modules.md:3
#, fuzzy
msgid "We have seen how `impl` blocks let us namespace functions to a type."
msgstr ""
"Am v캒zut cum blocurile `impl` ne permit s캒 atribuim func탵ii de namespace la "
"un tip."

#: src/modules.md:5
#, fuzzy
msgid "Similarly, `mod` lets us namespace types and functions:"
msgstr ""
"칉n mod similar, `mod` ne permite s캒 folosim tipuri 탳i func탵ii de spa탵iu de "
"nume:"

#: src/modules.md:7
#, fuzzy
msgid ""
"```rust,editable\n"
"mod foo {\n"
"    pub fn do_something() {\n"
"        println!(\"In the foo module\");\n"
"    }\n"
"}\n"
"\n"
"mod bar {\n"
"    pub fn do_something() {\n"
"        println!(\"In the bar module\");\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    foo::do_something();\n"
"    bar::do_something();\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"mod foo {\n"
"    pub fn do_something() {\n"
"        println!(\"칉n modulul foo\");\n"
"    }\n"
"}\n"
"\n"
"mod bar {\n"
"    pub fn do_something() {\n"
"        println!(\"칉n modulul bar\");\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    foo::do_something();\n"
"    bar::do_something();\n"
"}\n"
"```"

#: src/modules.md:28
#, fuzzy
msgid ""
"Packages provide functionality and include a `Cargo.toml` file that "
"describes how to build a bundle of 1+ crates."
msgstr ""
"Pachetele ofer캒 func탵ionalitate 탳i includ un fi탳ier `Cargo.toml` care "
"descrie cum se construie탳te un pachet de 1+ crates."

#: src/modules.md:29
#, fuzzy
msgid ""
"Crates are a tree of modules, where a binary crate creates an executable and "
"a library crate compiles to a library."
msgstr ""
"Crates reprezint캒 un arbore de module, 칥n care un crate binar creeaz캒 un "
"executabil, iar un crate de bibliotec캒 compileaz캒 o bibliotec캒."

#: src/modules.md:30
#, fuzzy
msgid "Modules define organization, scope, and are the focus of this section."
msgstr ""
"Modulele definesc organizarea, domeniul de aplicare 탳i reprezint캒 punctul "
"central al acestei sec탵iuni."

#: src/modules/visibility.md:3
#, fuzzy
msgid "Modules are a privacy boundary:"
msgstr "Modulele reprezint캒 o limit캒 de confiden탵ialitate:"

#: src/modules/visibility.md:5
#, fuzzy
msgid "Module items are private by default (hides implementation details)."
msgstr ""
"Elementele modulului sunt private 칥n mod implicit (ascunde detaliile de "
"implementare)."

#: src/modules/visibility.md:6
#, fuzzy
msgid "Parent and sibling items are always visible."
msgstr "Elementele p캒rin탵ilor 탳i ale fra탵ilor sunt 칥ntotdeauna vizibile."

#: src/modules/visibility.md:7
#, fuzzy
msgid ""
"In other words, if an item is visible in module `foo`, it's visible in all "
"the descendants of `foo`."
msgstr ""
"Cu alte cuvinte, dac캒 un element este vizibil 칥n modulul `foo`, el este "
"vizibil 칥n to탵i descenden탵ii lui `foo`."

#: src/modules/visibility.md:10
#, fuzzy
msgid ""
"```rust,editable\n"
"mod outer {\n"
"    fn private() {\n"
"        println!(\"outer::private\");\n"
"    }\n"
"\n"
"    pub fn public() {\n"
"        println!(\"outer::public\");\n"
"    }\n"
"\n"
"    mod inner {\n"
"        fn private() {\n"
"            println!(\"outer::inner::private\");\n"
"        }\n"
"\n"
"        pub fn public() {\n"
"            println!(\"outer::inner::public\");\n"
"            super::private();\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    outer::public();\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"mod outer {\n"
"    fn private() {\n"
"        println!(\"outer::private\");\n"
"    }\n"
"\n"
"    pub fn public() {\n"
"        println!(\"outer::public\");\n"
"    }\n"
"\n"
"    mod inner {\n"
"        fn private() {\n"
"            println!(\"outer::inner::private\");\n"
"        }\n"
"\n"
"        pub fn public() {\n"
"            println!(\"outer::inner::public\");\n"
"            super::private();\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    outer::public();\n"
"}\n"
"```"

#: src/modules/visibility.md:39
#, fuzzy
msgid "Use the `pub` keyword to make modules public."
msgstr "Utiliza탵i cuv칙ntul cheie `pub` pentru a face modulele publice."

#: src/modules/visibility.md:41
#, fuzzy
msgid ""
"Additionally, there are advanced `pub(...)` specifiers to restrict the scope "
"of public visibility."
msgstr ""
"칉n plus, exist캒 specificatori avansa탵i `pub(...)` pentru a restric탵iona "
"domeniul de aplicare al vizibilit캒탵ii publice."

#: src/modules/visibility.md:43
#, fuzzy
msgid ""
"See the [Rust Reference](https://doc.rust-lang.org/reference/visibility-and-"
"privacy.html#pubin-path-pubcrate-pubsuper-and-pubself)."
msgstr ""
"A se vedea [Rust Reference](https://doc.rust-lang.org/reference/visibility-"
"and-privacy.html#pubin-path-pubcrate-pubsuper-and-pubself)."

#: src/modules/visibility.md:44
#, fuzzy
msgid "Configuring `pub(crate)` visibility is a common pattern."
msgstr "Configurarea vizibilit캒탵ii `pub(crate)` este un model comun."

#: src/modules/visibility.md:45
#, fuzzy
msgid "Less commonly, you can give visibility to a specific path."
msgstr "Mai rar, pute탵i oferi vizibilitate unei anumite c캒i de acces."

#: src/modules/visibility.md:46
#, fuzzy
msgid ""
"In any case, visibility must be granted to an ancestor module (and all of "
"its descendants)."
msgstr ""
"칉n orice caz, vizibilitatea trebuie s캒 fie acordat캒 unui modul str캒mo탳 (탳i "
"tuturor descenden탵ilor s캒i)."

#: src/modules/paths.md:3
#, fuzzy
msgid "Paths are resolved as follows:"
msgstr "C캒ile de acces se rezolv캒 dup캒 cum urmeaz캒:"

#: src/modules/paths.md:5
#, fuzzy
msgid "As a relative path:"
msgstr "Ca o cale relativ캒:"

#: src/modules/paths.md:6
#, fuzzy
msgid "`foo` or `self::foo` refers to `foo` in the current module,"
msgstr "`foo` sau `self::foo` se refer캒 la `foo` din modulul curent,"

#: src/modules/paths.md:7
#, fuzzy
msgid "`super::foo` refers to `foo` in the parent module."
msgstr "`super::foo` se refer캒 la `foo` din modulul p캒rinte."

#: src/modules/paths.md:9
#, fuzzy
msgid "As an absolute path:"
msgstr "Ca o cale absolut캒:"

#: src/modules/paths.md:10
#, fuzzy
msgid "`crate::foo` refers to `foo` in the root of the current crate,"
msgstr "`crate::foo` se refer캒 la `foo` din r캒d캒cina cratei curente,"

#: src/modules/paths.md:11
#, fuzzy
msgid "`bar::foo` refers to `foo` in the `bar` crate."
msgstr "`bar::foo` se refer캒 la `foo` din cadrul `bar` crate."

#: src/modules/paths.md:13
#, fuzzy
msgid ""
"A module can bring symbols from another module into scope with `use`. You "
"will typically see something like this at the top of each module:"
msgstr ""
"Un modul poate aduce simboluri dintr-un alt modul 칥n domeniul de aplicare cu "
"`use`. De obicei, ve탵i vedea ceva de genul acesta 칥n partea de sus a "
"fiec캒rui modul:"

#: src/modules/filesystem.md:3
#, fuzzy
msgid ""
"Omitting the module content will tell Rust to look for it in another file:"
msgstr ""
"Omiterea con탵inutului modulului 칥i va spune lui Rust s캒 칥l caute 칥ntr-un alt "
"fi탳ier:"

#: src/modules/filesystem.md:9
#, fuzzy
msgid ""
"This tells rust that the `garden` module content is found at `src/garden."
"rs`. Similarly, a `garden::vegetables` module can be found at `src/garden/"
"vegetables.rs`."
msgstr ""
"Acest lucru 칥i spune lui Rust c캒 con탵inutul modulului `garden` se g캒se탳te la "
"`src/garden.rs`. 칉n mod similar, un modul `garden::vegetables` se g캒se탳te la "
"`src/garden/vegetables.rs`."

#: src/modules/filesystem.md:12
#, fuzzy
msgid "The `crate` root is in:"
msgstr "R캒d캒cina `crate` este 칥n:"

#: src/modules/filesystem.md:14
#, fuzzy
msgid "`src/lib.rs` (for a library crate)"
msgstr "`src/lib.rs` (pentru o bibliotec캒)"

#: src/modules/filesystem.md:15
#, fuzzy
msgid "`src/main.rs` (for a binary crate)"
msgstr "`src/main.rs` (pentru un crate binar)"

#: src/modules/filesystem.md:17
#, fuzzy
msgid ""
"Modules defined in files can be documented, too, using \"inner doc "
"comments\". These document the item that contains them -- in this case, a "
"module."
msgstr ""
"Modulele definite 칥n fi탳iere pot fi, de asemenea, documentate, folosind "
"\"inner doc comments\". Acestea documenteaz캒 elementul care le con탵ine - 칥n "
"acest caz, un modul."

#: src/modules/filesystem.md:20
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"//! This module implements the garden, including a highly performant "
"germination\n"
"//! implementation.\n"
"\n"
"// Re-export types from this module.\n"
"pub use seeds::SeedPacket;\n"
"pub use garden::Garden;\n"
"\n"
"/// Sow the given seed packets.\n"
"pub fn sow(seeds: Vec<SeedPacket>) { todo!() }\n"
"\n"
"/// Harvest the produce in the garden that is ready.\n"
"pub fn harvest(garden: &mut Garden) { todo!() }\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"//! Acest modul implementeaz캒 gr캒dina, inclusiv o germina탵ie foarte "
"performant캒\n"
"//! performant캒.\n"
"\n"
"// Reexporta탵i tipurile din acest modul.\n"
"pub use seeds::SeedPacket;\n"
"pub use garden::Garden;\n"
"\n"
"/// Sem캒na탵i pachetele de semin탵e date.\n"
"pub fn sow(seeds: Vec<SeedPacket>) { todo!() } }\n"
"\n"
"/// Recolteaz캒 produsele din gr캒din캒 care sunt gata.\n"
"pub fn harvest(garden: &amp;mut Garden) { todo!() } }\n"
"```"

#: src/modules/filesystem.md:37
#, fuzzy
msgid ""
"Before Rust 2018, modules needed to be located at `module/mod.rs` instead of "
"`module.rs`, and this is still a working alternative for editions after 2018."
msgstr ""
"칉nainte de Rust 2018, modulele trebuiau s캒 fie localizate la `module/mod.rs` "
"칥n loc de `module.rs`, iar aceasta este 칥nc캒 o alternativ캒 func탵ional캒 "
"pentru edi탵iile dup캒 2018."

#: src/modules/filesystem.md:39
#, fuzzy
msgid ""
"The main reason to introduce `filename.rs` as alternative to `filename/mod."
"rs` was because many files named `mod.rs` can be hard to distinguish in IDEs."
msgstr ""
"Motivul principal pentru care s-a introdus `filename.rs` ca alternativ캒 la "
"`filename/mod.rs` a fost acela c캒 multe fi탳iere numite `mod.rs` pot fi greu "
"de distins 칥n IDE-uri."

#: src/modules/filesystem.md:42
#, fuzzy
msgid "Deeper nesting can use folders, even if the main module is a file:"
msgstr ""
"칉n cazul 칥n care este vorba de o 칥nglobare mai profund캒, se pot utiliza "
"dosare, chiar dac캒 modulul principal este un fi탳ier:"

#: src/modules/filesystem.md:52
#, fuzzy
msgid ""
"The place rust will look for modules can be changed with a compiler "
"directive:"
msgstr ""
"Locul 칥n care rust va c캒uta modulele poate fi schimbat cu o directiv캒 de "
"compilare:"

#: src/modules/filesystem.md:54
#, fuzzy
msgid ""
"```rust,ignore\n"
"#[path = \"some/path.rs\"]\n"
"mod some_module;\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[path = \"some/path.rs\"]\n"
"mod some_module;\n"
"```"

#: src/modules/filesystem.md:59
#, fuzzy
msgid ""
"This is useful, for example, if you would like to place tests for a module "
"in a file named `some_module_test.rs`, similar to the convention in Go."
msgstr ""
"Acest lucru este util, de exemplu, dac캒 dori탵i s캒 plasa탵i testele pentru un "
"modul 칥ntr-un fi탳ier numit `some_module_test.rs`, similar conven탵iei din Go."

#: src/exercises/day-2/afternoon.md:1
#, fuzzy
msgid "Day 2: Afternoon Exercises"
msgstr "Ziua 2: Exerci탵ii dup캒-amiaza"

#: src/exercises/day-2/afternoon.md:3
#, fuzzy
msgid "The exercises for this afternoon will focus on strings and iterators."
msgstr ""
"Exerci탵iile din aceast캒 dup캒-amiaz캒 se vor axa pe 탳iruri de caractere 탳i "
"iteratori."

#: src/exercises/day-2/iterators-and-ownership.md:3
#, fuzzy
msgid ""
"The ownership model of Rust affects many APIs. An example of this is the "
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) and "
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html) "
"traits."
msgstr ""
"Modelul de proprietate din Rust afecteaz캒 multe API-uri. Un exemplu 칥n acest "
"sens este reprezentat de tr캒s캒turile [`Iterator`](https://doc.rust-lang.org/"
"std/iter/trait.Iterator.html) 탳i [`IntoIterator`](https://doc.rust-lang.org/"
"std/iter/trait.IntoIterator.html)."

#: src/exercises/day-2/iterators-and-ownership.md:8 src/bare-metal/no_std.md:28
#, fuzzy
msgid "`Iterator`"
msgstr "`Iterator`"

#: src/exercises/day-2/iterators-and-ownership.md:10
#, fuzzy
msgid ""
"Traits are like interfaces: they describe behavior (methods) for a type. The "
"`Iterator` trait simply says that you can call `next` until you get `None` "
"back:"
msgstr ""
"Tr캒s캒turile sunt ca interfe탵ele: ele descriu comportamentul (metodele) unui "
"tip. Tr캒s캒tura `Iterator` spune pur 탳i simplu c캒 pute탵i apela `next` p칙n캒 "
"c칙nd primi탵i 칥napoi `None`:"

#: src/exercises/day-2/iterators-and-ownership.md:20
#, fuzzy
msgid "You use this trait like this:"
msgstr "Folosi탵i aceast캒 tr캒s캒tur캒 astfel:"

#: src/exercises/day-2/iterators-and-ownership.md:22
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();\n"
"\n"
"    println!(\"v[0]: {:?}\", iter.next());\n"
"    println!(\"v[1]: {:?}\", iter.next());\n"
"    println!(\"v[2]: {:?}\", iter.next());\n"
"    println!(\"No more items: {:?}\", iter.next());\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();\n"
"\n"
"    println!(\"v[0]: {:?}\", iter.next());\n"
"    println!(\"v[1]: {:?}\", iter.next());\n"
"    println!(\"v[2]: {:?}\", iter.next());\n"
"    println!(\"Nu mai exist캒 elemente: {:?}\", iter.next());\n"
"}\n"
"```"

#: src/exercises/day-2/iterators-and-ownership.md:34
#, fuzzy
msgid "What is the type returned by the iterator? Test your answer here:"
msgstr "Care este tipul returnat de iterator? Testa탵i-v캒 r캒spunsul aici:"

#: src/exercises/day-2/iterators-and-ownership.md:36
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();\n"
"\n"
"    let v0: Option<..> = iter.next();\n"
"    println!(\"v0: {v0:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();\n"
"\n"
"    let v0: Option<..> = iter.next();\n"
"    println!(\"v0: {v0:?}\");\n"
"}\n"
"```"

#: src/exercises/day-2/iterators-and-ownership.md:46
#, fuzzy
msgid "Why is this type used?"
msgstr "De ce se folose탳te acest tip?"

#: src/exercises/day-2/iterators-and-ownership.md:48
#, fuzzy
msgid "`IntoIterator`"
msgstr "`IntoIterator`"

#: src/exercises/day-2/iterators-and-ownership.md:50
#, fuzzy
msgid ""
"The `Iterator` trait tells you how to _iterate_ once you have created an "
"iterator. The related trait `IntoIterator` tells you how to create the "
"iterator:"
msgstr ""
"Tr캒s캒tura `Iterator` v캒 spune cum s캒 _itera탵i_ dup캒 ce a탵i creat un "
"iterator. Tr캒s캒tura conex캒 `IntoIterator` v캒 spune cum s캒 crea탵i iteratorul:"

#: src/exercises/day-2/iterators-and-ownership.md:62
#, fuzzy
msgid ""
"The syntax here means that every implementation of `IntoIterator` must "
"declare two types:"
msgstr ""
"Sintaxa de aici 칥nseamn캒 c캒 fiecare implementare a lui `IntoIterator` "
"trebuie s캒 declare dou캒 tipuri:"

#: src/exercises/day-2/iterators-and-ownership.md:65
#, fuzzy
msgid "`Item`: the type we iterate over, such as `i8`,"
msgstr "`Item`: tipul peste care iter캒m, cum ar fi `i8`,"

#: src/exercises/day-2/iterators-and-ownership.md:66
#, fuzzy
msgid "`IntoIter`: the `Iterator` type returned by the `into_iter` method."
msgstr "`IntoIter`: tipul `Iterator` returnat de metoda `into_iter`."

#: src/exercises/day-2/iterators-and-ownership.md:68
#, fuzzy
msgid ""
"Note that `IntoIter` and `Item` are linked: the iterator must have the same "
"`Item` type, which means that it returns `Option<Item>`"
msgstr ""
"Re탵ine탵i c캒 `IntoIter` 탳i `Item` sunt legate: iteratorul trebuie s캒 aib캒 "
"acela탳i tip `Item`, ceea ce 칥nseamn캒 c캒 returneaz캒 `Op탵iune`<Item>`"

#: src/exercises/day-2/iterators-and-ownership.md:71
#, fuzzy
msgid "Like before, what  is the type returned by the iterator?"
msgstr "La fel ca 칥nainte, care este tipul returnat de iterator?"

#: src/exercises/day-2/iterators-and-ownership.md:73
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::"
"from(\"bar\")];\n"
"    let mut iter = v.into_iter();\n"
"\n"
"    let v0: Option<..> = iter.next();\n"
"    println!(\"v0: {v0:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::"
"from(\"bar\")];\n"
"    let mut iter = v.into_iter();\n"
"\n"
"    let v0: Option<..> = iter.next();\n"
"    println!(\"v0: {v0:?}\");\n"
"}\n"
"```"

#: src/exercises/day-2/iterators-and-ownership.md:83
#, fuzzy
msgid "`for` Loops"
msgstr "bucle `for`"

#: src/exercises/day-2/iterators-and-ownership.md:85
#, fuzzy
msgid ""
"Now that we know both `Iterator` and `IntoIterator`, we can build `for` "
"loops. They call `into_iter()` on an expression and iterates over the "
"resulting iterator:"
msgstr ""
"Acum c캒 탳tim at칙t `Iterator` c칙t 탳i `IntoIterator`, putem construi buclele "
"`for`. Acestea apeleaz캒 `into_iter()` pe o expresie 탳i iter캒 peste "
"iteratorul rezultat:"

#: src/exercises/day-2/iterators-and-ownership.md:89
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::"
"from(\"bar\")];\n"
"\n"
"    for word in &v {\n"
"        println!(\"word: {word}\");\n"
"    }\n"
"\n"
"    for word in v {\n"
"        println!(\"word: {word}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::"
"from(\"bar\")];\n"
"\n"
"    for word in &amp;v {\n"
"        println!(\"word: {word}\");\n"
"    }\n"
"\n"
"    for word in v {\n"
"        println!(\"cuv칙nt: {word}\");\n"
"    }\n"
"}\n"
"```"

#: src/exercises/day-2/iterators-and-ownership.md:103
#, fuzzy
msgid "What is the type of `word` in each loop?"
msgstr "Care este tipul de `word` 칥n fiecare bucl캒?"

#: src/exercises/day-2/iterators-and-ownership.md:105
#, fuzzy
msgid ""
"Experiment with the code above and then consult the documentation for [`impl "
"IntoIterator for &Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec."
"html#impl-IntoIterator-for-%26'a+Vec%3CT,+A%3E) and [`impl IntoIterator for "
"Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-"
"for-Vec%3CT,+A%3E) to check your answers."
msgstr ""
"Experimenta탵i cu codul de mai sus 탳i apoi consulta탵i documenta탵ia pentru "
"[`impl IntoIterator for &amp;Vec<T>`](https://doc.rust-lang.org/std/vec/"
"struct.Vec.html#impl-IntoIterator-for-%26'a+Vec%3CT,+A%3E) 탳i [`impl "
"IntoIterator for Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec."
"html#impl-IntoIterator-for-Vec%3CT,+A%3E) pentru a v캒 verifica r캒spunsurile."

#: src/exercises/day-2/strings-iterators.md:3
#, fuzzy
msgid ""
"In this exercise, you are implementing a routing component of a web server. "
"The server is configured with a number of _path prefixes_ which are matched "
"against _request paths_. The path prefixes can contain a wildcard character "
"which matches a full segment. See the unit tests below."
msgstr ""
"칉n acest exerci탵iu, implementa탵i o component캒 de rutare a unui server web. "
"Serverul este configurat cu un num캒r de _prefixe de drumuri_ care sunt "
"comparate cu _c캒ile de c캒utare_. Prefixele c캒ilor pot con탵ine un caracter "
"wildcard care se potrive탳te cu un segment complet. A se vedea testele "
"unitare de mai jos."

#: src/exercises/day-2/strings-iterators.md:8
#, fuzzy
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and make the tests "
"pass. Try avoiding allocating a `Vec` for your intermediate results:"
msgstr ""
"Copia탵i urm캒torul cod 칥n <https://play.rust-lang.org/> 탳i face탵i ca testele "
"s캒 treac캒. 칉ncerca탵i s캒 evita탵i s캒 aloca탵i un `Vec` pentru rezultatele "
"intermediare:"

#: src/exercises/day-2/strings-iterators.md:12
#, fuzzy
msgid ""
"```rust\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/"
"abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/"
"books\"));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/publishersBooks\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/parent/"
"publishers\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_matches_with_wildcard() {\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/bar/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books/book1\"\n"
"    ));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/"
"publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"// TODO: elimina탵i acest lucru atunci c칙nd a탵i terminat cu implementarea.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    neimplementat!()\n"
"}\n"
"\n"
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/"
"abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/"
"books\")));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/publishersBooks\")));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/p캒rin탵i/editori\")));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_matches_with_wildcard() {\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/bar/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books/book1\"\n"
"    ));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/"
"publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"```"

#: src/welcome-day-3.md:1
#, fuzzy
msgid "Welcome to Day 3"
msgstr "Bine a탵i venit 칥n ziua 3"

#: src/welcome-day-3.md:3
#, fuzzy
msgid "Today, we will cover some more advanced topics of Rust:"
msgstr "Ast캒zi, vom aborda c칙teva subiecte mai avansate din Rust:"

#: src/welcome-day-3.md:5
#, fuzzy
msgid ""
"Traits: deriving traits, default methods, and important standard library "
"traits."
msgstr ""
"Tr캒s캒turi: derivarea tr캒s캒turilor, metode implicite 탳i tr캒s캒turi importante "
"ale bibliotecii standard."

#: src/welcome-day-3.md:8
#, fuzzy
msgid ""
"Generics: generic data types, generic methods, monomorphization, and trait "
"objects."
msgstr ""
"Generice: tipuri de date generice, metode generice, monomorfizare 탳i obiecte "
"cu tr캒s캒turi."

#: src/welcome-day-3.md:11
#, fuzzy
msgid "Error handling: panics, `Result`, and the try operator `?`."
msgstr "Gestionarea erorilor: panici, `Result` 탳i operatorul try `?`."

#: src/welcome-day-3.md:13
#, fuzzy
msgid "Testing: unit tests, documentation tests, and integration tests."
msgstr "Testare: teste unitare, teste de documentare 탳i teste de integrare."

#: src/welcome-day-3.md:15
#, fuzzy
msgid ""
"Unsafe Rust: raw pointers, static variables, unsafe functions, and extern "
"functions."
msgstr ""
"Unsafe Rust: pointeri brute, variabile statice, func탵ii nesigure 탳i func탵ii "
"externe."

#: src/generics.md:3
#, fuzzy
msgid ""
"Rust support generics, which lets you abstract algorithms or data structures "
"(such as sorting or a binary tree) over the types used or stored."
msgstr ""
"Rust suport캒 generice, ceea ce v캒 permite s캒 abstractiza탵i algoritmi sau "
"structuri de date (cum ar fi sortarea sau un arbore binar) peste tipurile "
"utilizate sau stocate."

#: src/generics/data-types.md:3
#, fuzzy
msgid "You can use generics to abstract over the concrete field type:"
msgstr ""
"Pute탵i utiliza elementele generice pentru a face abstrac탵ie de tipul de c칙mp "
"concret:"

#: src/generics/data-types.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point<T> {\n"
"    x: T,\n"
"    y: T,\n"
"}\n"
"\n"
"fn main() {\n"
"    let integer = Point { x: 5, y: 10 };\n"
"    let float = Point { x: 1.0, y: 4.0 };\n"
"    println!(\"{integer:?} and {float:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"#[derive(Debug)]\n"
"struct Point<T> {\n"
"    x: T,\n"
"    y: T,\n"
"}\n"
"\n"
"fn main() {\n"
"    let integer = Point { x: 5, y: 10 };\n"
"    let float = Point { x: 1.0, y: 4.0 };\n"
"    println!(\"{integer:?} 탳i {float:?}\");\n"
"}\n"
"```"

#: src/generics/data-types.md:21
#, fuzzy
msgid "Try declaring a new variable `let p = Point { x: 5, y: 10.0 };`."
msgstr ""
"칉ncerca탵i s캒 declara탵i o nou캒 variabil캒 `let p = Point { x: 5, y: 10.0 };`."

#: src/generics/data-types.md:23
#, fuzzy
msgid "Fix the code to allow points that have elements of different types."
msgstr ""
"Corectarea codului pentru a permite puncte care au elemente de tipuri "
"diferite."

#: src/generics/methods.md:3
#, fuzzy
msgid "You can declare a generic type on your `impl` block:"
msgstr "Pute탵i declara un tip generic 칥n blocul `impl`:"

#: src/generics/methods.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point<T>(T, T);\n"
"\n"
"impl<T> Point<T> {\n"
"    fn x(&self) -> &T {\n"
"        &self.0  // + 10\n"
"    }\n"
"\n"
"    // fn set_x(&mut self, x: T)\n"
"}\n"
"\n"
"fn main() {\n"
"    let p = Point(5, 10);\n"
"    println!(\"p.x = {}\", p.x());\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"#[derive(Debug)]\n"
"struct Point<T>(T, T);\n"
"\n"
"impl<T> Point<T> {\n"
"    fn x(&amp;self) -&gt; &amp;T {\n"
"        &amp;self.0 // + 10\n"
"    }\n"
"\n"
"    // fn set_x(&amp;mut self, x: T)\n"
"}\n"
"\n"
"fn main() {\n"
"    let p = Point(5, 10);\n"
"    println!(\"p.x = {}\", p.x());\n"
"}\n"
"```"

#: src/generics/methods.md:25
#, fuzzy
msgid ""
"_Q:_ Why `T` is specified twice in `impl<T> Point<T> {}`? Isn't that "
"redundant?"
msgstr ""
"칥ntrebare: De ce `T` este specificat de dou캒 ori 칥n `impl<T> Point<T> {}`? "
"Nu este redundant?"

#: src/generics/methods.md:26
#, fuzzy
msgid ""
"This is because it is a generic implementation section for generic type. "
"They are independently generic."
msgstr ""
"Acest lucru se datoreaz캒 faptului c캒 este o sec탵iune de implementare "
"generic캒 pentru un tip generic. Acestea sunt generice 칥n mod independent."

#: src/generics/methods.md:27
#, fuzzy
msgid "It means these methods are defined for any `T`."
msgstr "Aceasta 칥nseamn캒 c캒 aceste metode sunt definite pentru orice `T`."

#: src/generics/methods.md:28
#, fuzzy
msgid "It is possible to write `impl Point<u32> { .. }`. "
msgstr "Este posibil s캒 se scrie `impl Point<u32> { .. }`. "

#: src/generics/methods.md:29
#, fuzzy
msgid ""
"`Point` is still generic and you can use `Point<f64>`, but methods in this "
"block will only be available for `Point<u32>`."
msgstr ""
"`Point` este 칥n continuare generic 탳i pute탵i utiliza `Point<f64>`, dar "
"metodele din acest bloc vor fi disponibile numai pentru `Point<u32>`."

#: src/generics/monomorphization.md:3
#, fuzzy
msgid "Generic code is turned into non-generic code based on the call sites:"
msgstr ""
"Codul generic este transformat 칥n cod ne-generic 칥n func탵ie de locurile de "
"apelare:"

#: src/generics/monomorphization.md:12
#, fuzzy
msgid "behaves as if you wrote"
msgstr "se comport캒 ca 탳i cum a탵i fi scris"

#: src/generics/monomorphization.md:31
#, fuzzy
msgid ""
"This is a zero-cost abstraction: you get exactly the same result as if you "
"had hand-coded the data structures without the abstraction."
msgstr ""
"Aceasta este o abstractizare cu costuri zero: ob탵ine탵i exact acela탳i "
"rezultat ca 탳i cum a탵i fi codat manual structurile de date f캒r캒 "
"abstractizare."

#: src/traits.md:3
#, fuzzy
msgid ""
"Rust lets you abstract over types with traits. They're similar to interfaces:"
msgstr ""
"Rust v캒 permite s캒 abstractiza탵i tipurile cu ajutorul tr캒s캒turilor. Acestea "
"sunt similare cu interfe탵ele:"

#: src/traits.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"struct Dog { name: String, age: i8 }\n"
"struct Cat { lives: i8 } // No name needed, cats won't respond anyway.\n"
"\n"
"trait Pet {\n"
"    fn talk(&self) -> String;\n"
"}\n"
"\n"
"impl Pet for Dog {\n"
"    fn talk(&self) -> String { format!(\"Woof, my name is {}!\", self."
"name) }\n"
"}\n"
"\n"
"impl Pet for Cat {\n"
"    fn talk(&self) -> String { String::from(\"Miau!\") }\n"
"}\n"
"\n"
"fn greet<P: Pet>(pet: &P) {\n"
"    println!(\"Oh you're a cutie! What's your name? {}\", pet.talk());\n"
"}\n"
"\n"
"fn main() {\n"
"    let captain_floof = Cat { lives: 9 };\n"
"    let fido = Dog { name: String::from(\"Fido\"), age: 5 };\n"
"\n"
"    greet(&captain_floof);\n"
"    greet(&fido);\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"struct Dog { name: String, age: i8 }\n"
"struct Cat { lives: i8 } // Nu este nevoie de nume, pisicile oricum nu vor "
"r캒spunde.\n"
"\n"
"trait Pet {\n"
"    fn talk(&amp;self) -&gt; String;\n"
"}\n"
"\n"
"impl Pet pentru Dog {\n"
"    fn talk(&amp;self) -&gt; String { format!(\"Woof, numele meu este {}!\", "
"self.name) } }\n"
"}\n"
"\n"
"impl Pet for Cat {\n"
"    fn talk(&amp;self) -&gt; String { String::from(\"Miau!\") }\n"
"}\n"
"\n"
"fn greet<P: Pet>(pet: &amp;P) {\n"
"    println!(\"Oh, e탳ti un dr캒gu탵! Cum te cheam캒? {}\", pet.talk());\n"
"}\n"
"\n"
"fn main() {\n"
"    let captain_floof = Cat { lives: 9 };\n"
"    let fido = Dog { name: String::from(\"Fido\"), age: 5 };\n"
"\n"
"    greet(&amp;captain_floof);\n"
"    greet(&amp;fido);\n"
"}\n"
"```"

#: src/traits/trait-objects.md:3
#, fuzzy
msgid ""
"Trait objects allow for values of different types, for instance in a "
"collection:"
msgstr ""
"Obiectele de tr캒s캒turi permit valori de diferite tipuri, de exemplu 칥ntr-o "
"colec탵ie:"

#: src/traits/trait-objects.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"struct Dog { name: String, age: i8 }\n"
"struct Cat { lives: i8 } // No name needed, cats won't respond anyway.\n"
"\n"
"trait Pet {\n"
"    fn talk(&self) -> String;\n"
"}\n"
"\n"
"impl Pet for Dog {\n"
"    fn talk(&self) -> String { format!(\"Woof, my name is {}!\", self."
"name) }\n"
"}\n"
"\n"
"impl Pet for Cat {\n"
"    fn talk(&self) -> String { String::from(\"Miau!\") }\n"
"}\n"
"\n"
"fn main() {\n"
"    let pets: Vec<Box<dyn Pet>> = vec![\n"
"        Box::new(Cat { lives: 9 }),\n"
"        Box::new(Dog { name: String::from(\"Fido\"), age: 5 }),\n"
"    ];\n"
"    for pet in pets {\n"
"        println!(\"Hello, who are you? {}\", pet.talk());\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"struct Dog { name: String, age: i8 }\n"
"struct Cat { lives: i8 } // Nu este nevoie de nume, pisicile oricum nu vor "
"r캒spunde.\n"
"\n"
"trait Pet {\n"
"    fn talk(&amp;self) -&gt; String;\n"
"}\n"
"\n"
"impl Pet pentru Dog {\n"
"    fn talk(&amp;self) -&gt; String { format!(\"Woof, numele meu este {}!\", "
"self.name) } }\n"
"}\n"
"\n"
"impl Pet for Cat {\n"
"    fn talk(&amp;self) -&gt; String { String::from(\"Miau!\") }\n"
"}\n"
"\n"
"fn main() {\n"
"    let pets: Vec&lt;Box<dyn Pet>&gt; = vec!\n"
"        Box::new(Cat { lives: 9 }),\n"
"        Box::new(Dog { name: String::from(\"Fido\"), age: 5 }),\n"
"    ];\n"
"    for pet in pets {\n"
"        println!(\"Salut, cine e탳ti? {}\", pet.talk());\n"
"    }\n"
"}\n"
"```"

#: src/traits/trait-objects.md:32
#, fuzzy
msgid "Memory layout after allocating `pets`:"
msgstr "Dispunerea memoriei dup캒 alocarea `pets`:"

#: src/traits/trait-objects.md:34
#, fuzzy
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                           :     :                                             :\n"
":    pets                   :     :                     +----+----+----+----"
"+   :\n"
":   +-----------+-------+   :     :   +-----+-----+  .->| F  | i  | d  | o  "
"|   :\n"
":   | ptr       |   o---+---+-----+-->| o o | o o |  |  +----+----+----+----"
"+   :\n"
":   | len       |     2 |   :     :   +-|-|-+-|-|-+  "
"`---------.                :\n"
":   | capacity  |     2 |   :     :     | |   | |    data      "
"|                :\n"
":   +-----------+-------+   :     :     | |   | |   +-------+--|-------"
"+        :\n"
":                           :     :     | |   | '-->| name  |  o, 4, 4 "
"|        :\n"
":                           :     :     | |   |     | age   |        5 "
"|        :\n"
"`- - - - - - - - - - - - - -'     :     | |   |     +-------+----------"
"+        :\n"
"                                  :     | |   "
"|                                 :\n"
"                                  :     | |   |      "
"vtable                     :\n"
"                                  :     | |   |     +----------------------"
"+    :\n"
"                                  :     | |   '---->| \"<Dog as Pet>::talk\" "
"|    :\n"
"                                  :     | |         +----------------------"
"+    :\n"
"                                  :     | "
"|                                     :\n"
"                                  :     | |    "
"data                             :\n"
"                                  :     | |   +-------+-------"
"+                 :\n"
"                                  :     | '-->| lives |     9 "
"|                 :\n"
"                                  :     |     +-------+-------"
"+                 :\n"
"                                  :     "
"|                                       :\n"
"                                  :     |      "
"vtable                           :\n"
"                                  :     |     +----------------------"
"+          :\n"
"                                  :     '---->| \"<Cat as Pet>::talk\" "
"|          :\n"
"                                  :           +----------------------"
"+          :\n"
"                                  :                                             :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"
msgstr ""
"```bob\n"
" Stiva Heap\n"
".- - - - - - - - - - - - - -. .- - - - - - - - - - - - - - - - - - - - - - "
"-.\n"
": : : :\n"
": animale de companie : : : +----+----+----+----+----+ :\n"
":   +-----------+-------+ : : : +-----+-----+ .-&gt;| F | i | d | o | :\n"
":   | ptr | o---++-+-+-----+--&gt;| o o | o o | o o | | | +----+----+----"
"+----+----+ :\n"
":   | len | 2 | : : : +-|-|-|-+-|-|-|-+ `---------. :\n"
":   | capacitate | 2 | : :     | | | | | | date | :\n"
":   +-----------+-------+ : :     | | | | +-------+--|-------+ :\n"
": : :     | | | | '--&gt;|| nume | o, 4, 4 | :\n"
": : :     | | | | | v칙rst캒 | 5 | :\n"
"`- - - - - - - - - - - - - -' :     | | | +-------+----------+ :\n"
"                                  :     | | | :\n"
"                                  :     | | | | vtable :\n"
"                                  :     | | | +----------------------+ :\n"
"                                  :     | | '----&gt;| \"<Dog as Pet>::"
"talk\" | :\n"
"                                  :     | | +----------------------+ :\n"
"                                  :     | | :\n"
"                                  :     | | date :\n"
"                                  :     | | +-------+-------+ :\n"
"                                  :     | '--&gt;| vie탵i | 9 | :\n"
"                                  :     | +-------+-------+ :\n"
"                                  :     | :\n"
"                                  :     | vtable :\n"
"                                  :     | +----------------------+ :\n"
"                                  : '----&gt;|| \"<Cat as Pet>::talk\" | :\n"
"                                  : +----------------------+ :\n"
"                                  : :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"

#: src/traits/trait-objects.md:68
#, fuzzy
msgid ""
"Types that implement a given trait may be of different sizes. This makes it "
"impossible to have things like `Vec<dyn Pet>` in the example above."
msgstr ""
"Tipurile care implementeaz캒 o anumit캒 tr캒s캒tur캒 pot avea dimensiuni "
"diferite. Acest lucru face imposibil캒 existen탵a unor lucruri precum `Vec<dyn "
"Pet>` 칥n exemplul de mai sus."

#: src/traits/trait-objects.md:70
#, fuzzy
msgid ""
"`dyn Pet` is a way to tell the compiler about a dynamically sized type that "
"implements `Pet`."
msgstr ""
"`dyn Pet` este o modalitate de a indica compilatorului un tip dimensionat "
"dinamic care implementeaz캒 `Pet`."

#: src/traits/trait-objects.md:72
#, fuzzy
msgid ""
"In the example, `pets` is allocated on the stack and the vector data is on "
"the heap. The two vector elements are _fat pointers_:"
msgstr ""
"칉n acest exemplu, `pets` este alocat pe stiv캒, iar datele vectorului se afl캒 "
"pe heap. Cele dou캒 elemente ale vectorului sunt _fat pointeri_:"

#: src/traits/trait-objects.md:74
#, fuzzy
msgid ""
"A fat pointer is a double-width pointer. It has two components: a pointer to "
"the actual object and a pointer to the [virtual method table](https://en."
"wikipedia.org/wiki/Virtual_method_table) (vtable) for the `Pet` "
"implementation of that particular object."
msgstr ""
"Un pointer gras este un pointer cu l캒탵ime dubl캒. Acesta are dou캒 componente: "
"un pointer la obiectul real 탳i un pointer la [virtual method table](https://"
"en.wikipedia.org/wiki/Virtual_method_table) (vtable) pentru implementarea "
"`Pet` a obiectului respectiv."

#: src/traits/trait-objects.md:77
#, fuzzy
msgid ""
"The data for the `Dog` named Fido is the `name` and `age` fields. The `Cat` "
"has a `lives` field."
msgstr ""
"Datele pentru `Dog` numit Fido sunt c칙mpurile `name` 탳i `age`. Pentru `Cat` "
"exist캒 un c칙mp `lives`."

#: src/traits/trait-objects.md:79
#, fuzzy
msgid "Compare these outputs in the above example:"
msgstr "Compara탵i aceste ie탳iri 칥n exemplul de mai sus:"

#: src/traits/trait-objects.md:80
#, fuzzy
msgid ""
"```rust,ignore\n"
"    println!(\"{} {}\", std::mem::size_of::<Dog>(), std::mem::size_of::"
"<Cat>());\n"
"    println!(\"{} {}\", std::mem::size_of::<&Dog>(), std::mem::size_of::"
"<&Cat>());\n"
"    println!(\"{}\", std::mem::size_of::<&dyn Pet>());\n"
"    println!(\"{}\", std::mem::size_of::<Box<dyn Pet>>());\n"
"```"
msgstr ""
"```칥ncredere,ignora\n"
"    println!(\"{} {}\", std::mem::size_of:::<Dog>(), std::mem::size_of::"
"<Cat>());\n"
"    println!(\"{} {}\", std::mem::size_of::<&Dog>(), std::mem::size_of::"
"<&Cat>());\n"
"    println!(\"{}\", std::mem::size_of::<&dyn Pet>());\n"
"    printlnn!(\"{}\", std::mem::size_of::&lt;Box<dyn Pet>&gt;());\n"
"```"

#: src/traits/deriving-traits.md:3
#, fuzzy
msgid ""
"Rust derive macros work by automatically generating code that implements the "
"specified traits for a data structure."
msgstr ""
"Macrogramele de derivare Rust func탵ioneaz캒 prin generarea automat캒 a codului "
"care implementeaz캒 tr캒s캒turile specificate pentru o structur캒 de date."

#: src/traits/deriving-traits.md:5
#, fuzzy
msgid "You can let the compiler derive a number of traits as follows:"
msgstr ""
"Pute탵i l캒sa compilatorul s캒 deduc캒 o serie de tr캒s캒turi dup캒 cum urmeaz캒:"

#: src/traits/deriving-traits.md:7
#, fuzzy
msgid ""
"```rust,editable\n"
"#[derive(Debug, Clone, PartialEq, Eq, Default)]\n"
"struct Player {\n"
"    name: String,\n"
"    strength: u8,\n"
"    hit_points: u8,\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Player::default();\n"
"    let p2 = p1.clone();\n"
"    println!(\"Is {:?}\\nequal to {:?}?\\nThe answer is {}!\", &p1, &p2,\n"
"             if p1 == p2 { \"yes\" } else { \"no\" });\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"#[derive(Debug, Clone, PartialEq, Eq, Default)]]\n"
"struct Player {\n"
"    name: String,\n"
"    strength: u8,\n"
"    hit_points: u8,\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Player::default();\n"
"    let p2 = p1.clone();\n"
"    println!(\"Este {:?}\\negal cu {:?}?\\nR캒spunsul este {}!\", &p1, &p2,\n"
"             if p1 == p2 { \"yes\" } else { \"no\" });\n"
"}\n"
"```"

#: src/traits/default-methods.md:3
#, fuzzy
msgid "Traits can implement behavior in terms of other trait methods:"
msgstr ""
"Tr캒s캒turile pot pune 칥n aplicare comportamentul 칥n termeni de metode ale "
"altor tr캒s캒turi:"

#: src/traits/default-methods.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"trait Equals {\n"
"    fn equals(&self, other: &Self) -> bool;\n"
"    fn not_equals(&self, other: &Self) -> bool {\n"
"        !self.equals(other)\n"
"    }\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"struct Centimeter(i16);\n"
"\n"
"impl Equals for Centimeter {\n"
"    fn equals(&self, other: &Centimeter) -> bool {\n"
"        self.0 == other.0\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let a = Centimeter(10);\n"
"    let b = Centimeter(20);\n"
"    println!(\"{a:?} equals {b:?}: {}\", a.equals(&b));\n"
"    println!(\"{a:?} not_equals {b:?}: {}\", a.not_equals(&b));\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"tr캒s캒tur캒 Equals {\n"
"    fn equals(&self, other: &Self) -> bool;\n"
"    fn not_equals(&self, other: &Self) -> bool {\n"
"        !self.equals(other)\n"
"    }\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"struct Centimetru(i16);\n"
"\n"
"impl Equals pentru Centimetru {\n"
"    fn equals(&self, other: &Centimeter) -> bool {\n"
"        self.0 == other.0\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let a = Centimetru(10);\n"
"    let b = Centimetru(20);\n"
"    println!(\"{a:?} este egal cu {b:?}: {}\", a.equals(&b));\n"
"    printlnn!(\"{a:?} not_equals {b:?}: {}\", a.not_equals(&b));\n"
"}\n"
"```"

#: src/traits/default-methods.md:32
#, fuzzy
msgid ""
"Traits may specify pre-implemented (default) methods and methods that users "
"are required to implement themselves. Methods with default implementations "
"can rely on required methods."
msgstr ""
"Tr캒s캒turile pot specifica metode preimplementate (implicite) 탳i metode pe "
"care utilizatorii trebuie s캒 le implementeze ei 칥n탳i탳i. Metodele cu "
"implement캒ri implicite se pot baza pe metodele obligatorii."

#: src/traits/default-methods.md:35
#, fuzzy
msgid "Move method `not_equals` to a new trait `NotEquals`."
msgstr "Mutarea metodei `not_equals` la o nou캒 tr캒s캒tur캒 `NotEquals`."

#: src/traits/default-methods.md:37
#, fuzzy
msgid "Make `Equals` a super trait for `NotEquals`."
msgstr "Face탵i din `Equals` o super tr캒s캒tur캒 pentru `NotEquals`."

#: src/traits/default-methods.md:46
#, fuzzy
msgid "Provide a blanket implementation of `NotEquals` for `Equals`."
msgstr ""
"Furnizarea unei implement캒ri generale a func탵iei `NotEquals` pentru `Equals`."

#: src/traits/default-methods.md:58
#, fuzzy
msgid ""
"With the blanket implementation, you no longer need `Equals` as a super "
"trait for `NotEqual`."
msgstr ""
"Odat캒 cu implementarea p캒turii, nu mai ave탵i nevoie de `Equals` ca o super "
"tr캒s캒tur캒 pentru `NotEqual`."

#: src/traits/trait-bounds.md:3
#, fuzzy
msgid ""
"When working with generics, you often want to require the types to implement "
"some trait, so that you can call this trait's methods."
msgstr ""
"Atunci c칙nd lucra탵i cu generice, deseori dori탵i s캒 solicita탵i ca tipurile s캒 "
"implementeze o anumit캒 tr캒s캒tur캒, astfel 칥nc칙t s캒 pute탵i apela metodele "
"acestei tr캒s캒turi."

#: src/traits/trait-bounds.md:6
#, fuzzy
msgid "You can do this with `T: Trait` or `impl Trait`:"
msgstr "Pute탵i face acest lucru cu `T: Trait` sau `impl Trait`:"

#: src/traits/trait-bounds.md:8
#, fuzzy
msgid ""
"```rust,editable\n"
"fn duplicate<T: Clone>(a: T) -> (T, T) {\n"
"    (a.clone(), a.clone())\n"
"}\n"
"\n"
"// Syntactic sugar for:\n"
"//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"
"fn add_42_millions(x: impl Into<i32>) -> i32 {\n"
"    x.into() + 42_000_000\n"
"}\n"
"\n"
"// struct NotClonable;\n"
"\n"
"fn main() {\n"
"    let foo = String::from(\"foo\");\n"
"    let pair = duplicate(foo);\n"
"    println!(\"{pair:?}\");\n"
"\n"
"    let many = add_42_millions(42_i8);\n"
"    println!(\"{many}\");\n"
"    let many_more = add_42_millions(10_000_000);\n"
"    println!(\"{many_more}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn duplicate<T: Clone>(a: T) -&gt; (T, T) {\n"
"    (a.clone(), a.clone())\n"
"}\n"
"\n"
"// Zah캒r sintactic pentru:\n"
"// fn add_42_millions&lt;T: Into<i32>&gt;(x: T) -&gt; i32 {\n"
"fn add_42_millions(x: impl Into<i32>) -&gt; i32 {\n"
"    x.into() + 42_000_000\n"
"}\n"
"\n"
"// struct NotClonable;\n"
"\n"
"fn main() {\n"
"    let foo = String::from(\"foo\");\n"
"    let pair = duplicate(foo);\n"
"    println!(\"{pair:?}\");\n"
"\n"
"    let many = add_42_millions(42_i8);\n"
"    println!(\"{many}\");\n"
"    let many_more = add_42_millions(10_000_000);\n"
"    println!(\"{many_more}\");\n"
"}\n"
"```"

#: src/traits/trait-bounds.md:35
#, fuzzy
msgid "Show a `where` clause, students will encounter it when reading code."
msgstr ""
"Ar캒ta탵i o clauz캒 `where`, elevii o vor 칥nt칙lni atunci c칙nd vor citi codul."

#: src/traits/trait-bounds.md:46
#, fuzzy
msgid "It declutters the function signature if you have many parameters."
msgstr "Declutineaz캒 semn캒tura func탵iei dac캒 ave탵i mul탵i parametri."

#: src/traits/trait-bounds.md:47
#, fuzzy
msgid "It has additional features making it more powerful."
msgstr "Are caracteristici suplimentare care 칥l fac mai puternic."

#: src/traits/trait-bounds.md:48
#, fuzzy
msgid ""
"If someone asks, the extra feature is that the type on the left of \":\" can "
"be arbitrary, like `Option<T>`."
msgstr ""
"Dac캒 cineva 칥ntreab캒, caracteristica suplimentar캒 este c캒 tipul din st칙nga "
"lui \":\" poate fi arbitrar, cum ar fi `Option<T>`."

#: src/traits/impl-trait.md:1
#, fuzzy
msgid "`impl Trait`"
msgstr "`impl Trait`"

#: src/traits/impl-trait.md:3
#, fuzzy
msgid ""
"Similar to trait bounds, an `impl Trait` syntax can be used in function "
"arguments and return values:"
msgstr ""
"La fel ca 칥n cazul limitelor tr캒s캒turilor, o sintax캒 `impl Trait` poate fi "
"utilizat캒 칥n argumentele func탵iilor 탳i 칥n valorile de returnare:"

#: src/traits/impl-trait.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::fmt::Display;\n"
"\n"
"fn get_x(name: impl Display) -> impl Display {\n"
"    format!(\"Hello {name}\")\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = get_x(\"foo\");\n"
"    println!(\"{x}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"folose탳te std::fmt::Display;\n"
"\n"
"fn get_x(name: impl Display) -> impl Display {\n"
"    format!(\"Hello {name}\")\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = get_x(\"foo\");\n"
"    println!(\"{x}\");\n"
"}\n"
"```"

#: src/traits/impl-trait.md:19
#, fuzzy
msgid "`impl Trait` allows you to work with types which you cannot name."
msgstr ""
"`impl Trait` v캒 permite s캒 lucra탵i cu tipuri pe care nu le pute탵i numi."

#: src/traits/impl-trait.md:23
#, fuzzy
msgid ""
"The meaning of `impl Trait` is a bit different in the different positions."
msgstr ""
"Semnifica탵ia lui `impl Trait` este pu탵in diferit캒 칥n diferitele pozi탵ii."

#: src/traits/impl-trait.md:25
#, fuzzy
msgid ""
"For a parameter, `impl Trait` is like an anonymous generic parameter with a "
"trait bound."
msgstr ""
"Pentru un parametru, `impl Trait` este ca un parametru generic anonim cu o "
"tr캒s캒tur캒 legat캒."

#: src/traits/impl-trait.md:27
#, fuzzy
msgid ""
"For a return type, it means that the return type is some concrete type that "
"implements the trait, without naming the type. This can be useful when you "
"don't want to expose the concrete type in a public API."
msgstr ""
"Pentru un tip de returnare, 칥nseamn캒 c캒 tipul de returnare este un tip "
"concret care implementeaz캒 tr캒s캒tura, f캒r캒 a numi tipul. Acest lucru poate "
"fi util atunci c칙nd nu dori탵i s캒 expune탵i tipul concret 칥ntr-o API public캒."

#: src/traits/impl-trait.md:31
#, fuzzy
msgid ""
"Inference is hard in return position. A function returning `impl Foo` picks "
"the concrete type it returns, without writing it out in the source. A "
"function returning a generic type like `collect<B>() -> B` can return any "
"type satisfying `B`, and the caller may need to choose one, such as with "
"`let x: Vec<_> = foo.collect()` or with the turbofish, `foo.collect::"
"<Vec<_>>()`."
msgstr ""
"Inferen탵a este dificil캒 칥n pozi탵ia de retur. O func탵ie care returneaz캒 `impl "
"Foo` alege tipul concret pe care 칥l returneaz캒, f캒r캒 a scrie acest lucru 칥n "
"surs캒. O func탵ie care returneaz캒 un tip generic, cum ar fi `collect<B>() -"
"&gt; B`, poate returna orice tip care satisface `B`, iar apelantul poate fi "
"nevoit s캒 aleag캒 unul, ca 칥n cazul lui `let x: Vec<_> = foo.collect()` sau "
"cu turbofishul, `foo.collect::&lt;Vec<_>&gt;()`."

#: src/traits/impl-trait.md:37
#, fuzzy
msgid ""
"This example is great, because it uses `impl Display` twice. It helps to "
"explain that nothing here enforces that it is _the same_ `impl Display` "
"type. If we used a single  `T: Display`, it would enforce the constraint "
"that input `T` and return `T` type are the same type. It would not work for "
"this particular function, as the type we expect as input is likely not what "
"`format!` returns. If we wanted to do the same via `: Display` syntax, we'd "
"need two independent generic parameters."
msgstr ""
"Acest exemplu este grozav, pentru c캒 folose탳te `impl Display` de dou캒 ori. "
"Ajut캒 la explicarea faptului c캒 nimic aici nu impune c캒 este vorba de "
"acela탳i tip `impl Display`. Dac캒 am folosi un singur `T: Display`, am impune "
"constr칙ngerea c캒 tipul `T` de intrare 탳i tipul `T` de retur sunt de acela탳i "
"tip. Acest lucru nu ar func탵iona pentru aceast캒 func탵ie particular캒, "
"deoarece tipul pe care 칥l a탳tept캒m ca intrare nu este probabil cel pe care "
"`format!` 칥l returneaz캒. Dac캒 am dori s캒 facem acela탳i lucru prin `: "
"Display`, am avea nevoie de doi parametri generici independen탵i."

#: src/traits/important-traits.md:3
#, fuzzy
msgid ""
"We will now look at some of the most common traits of the Rust standard "
"library:"
msgstr ""
"Vom examina acum unele dintre cele mai comune tr캒s캒turi ale bibliotecii "
"standard Rust:"

#: src/traits/important-traits.md:5
#, fuzzy
msgid ""
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) and "
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html) "
"used in `for` loops,"
msgstr ""
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) 탳i "
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html) "
"utilizate 칥n buclele `for`,"

#: src/traits/important-traits.md:6
#, fuzzy
msgid ""
"[`From`](https://doc.rust-lang.org/std/convert/trait.From.html) and [`Into`]"
"(https://doc.rust-lang.org/std/convert/trait.Into.html) used to convert "
"values,"
msgstr ""
"[`From`](https://doc.rust-lang.org/std/convert/trait.From.html) 탳i [`Into`]"
"(https://doc.rust-lang.org/std/convert/trait.Into.html) utilizate pentru a "
"converti valorile,"

#: src/traits/important-traits.md:7
#, fuzzy
msgid ""
"[`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) and [`Write`]"
"(https://doc.rust-lang.org/std/io/trait.Write.html) used for IO,"
msgstr ""
"[`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) 탳i [`Write`]"
"(https://doc.rust-lang.org/std/io/trait.Write.html) utilizate pentru IO,"

#: src/traits/important-traits.md:8
#, fuzzy
msgid ""
"[`Add`](https://doc.rust-lang.org/std/ops/trait.Add.html), [`Mul`](https://"
"doc.rust-lang.org/std/ops/trait.Mul.html), ... used for operator "
"overloading, and"
msgstr ""
"[`Add`](https://doc.rust-lang.org/std/ops/trait.Add.html), [`Mul`](https://"
"doc.rust-lang.org/std/ops/trait.Mul.html), ... utilizate pentru "
"supra칥nc캒rcarea operatorilor, 탳i"

#: src/traits/important-traits.md:9
#, fuzzy
msgid ""
"[`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) used for "
"defining destructors."
msgstr ""
"[`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) utilizat pentru "
"definirea destructoriilor."

#: src/traits/important-traits.md:10
#, fuzzy
msgid ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) used "
"to construct a default instance of a type."
msgstr ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) "
"utilizat pentru a construi o instan탵캒 implicit캒 a unui tip."

#: src/traits/iterator.md:1
#, fuzzy
msgid "Iterators"
msgstr "Iteratori"

#: src/traits/iterator.md:3
#, fuzzy
msgid ""
"You can implement the [`Iterator`](https://doc.rust-lang.org/std/iter/trait."
"Iterator.html) trait on your own types:"
msgstr ""
"Pute탵i implementa tr캒s캒tura [`Iterator`](https://doc.rust-lang.org/std/iter/"
"trait.Iterator.html) pe propriile tipuri:"

#: src/traits/iterator.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"struct Fibonacci {\n"
"    curr: u32,\n"
"    next: u32,\n"
"}\n"
"\n"
"impl Iterator for Fibonacci {\n"
"    type Item = u32;\n"
"\n"
"    fn next(&mut self) -> Option<Self::Item> {\n"
"        let new_next = self.curr + self.next;\n"
"        self.curr = self.next;\n"
"        self.next = new_next;\n"
"        Some(self.curr)\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = Fibonacci { curr: 0, next: 1 };\n"
"    for (i, n) in fib.enumerate().take(5) {\n"
"        println!(\"fib({i}): {n}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"struct Fibonacci {\n"
"    curr: u32,\n"
"    next: u32,\n"
"}\n"
"\n"
"impl Iterator pentru Fibonacci {\n"
"    type Item = u32;\n"
"\n"
"    fn next(&amp;mut self) -&gt; Option<Self::Item> {\n"
"        let new_next = self.curr + self.next;\n"
"        self.curr = self.next;\n"
"        self.next = new_next;\n"
"        Some(self.curr)\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = Fibonacci { curr: 0, next: 1 };\n"
"    for (i, n) in fib.enumerate().take(5) {\n"
"        println!(\"fib({i}): {n}\");\n"
"    }\n"
"}\n"
"```"

#: src/traits/iterator.md:32
#, fuzzy
msgid ""
"The `Iterator` trait implements many common functional programming "
"operations over collections  (e.g. `map`, `filter`, `reduce`, etc). This is "
"the trait where you can find all the documentation about them. In Rust these "
"functions should produce the code as efficient as equivalent imperative "
"implementations."
msgstr ""
"Caracteristica `Iterator` implementeaz캒 multe opera탵ii comune de programare "
"func탵ional캒 asupra colec탵iilor (de exemplu, `map`, `filter`, `reduce` etc.). "
"Aceasta este tr캒s캒tura 칥n care pute탵i g캒si toat캒 documenta탵ia referitoare la "
"acestea. 칉n Rust, aceste func탵ii ar trebui s캒 produc캒 cod la fel de eficient "
"ca 탳i implement캒rile imperative echivalente."

#: src/traits/iterator.md:37
#, fuzzy
msgid ""
"`IntoIterator` is the trait that makes for loops work. It is implemented by "
"collection types such as `Vec<T>` and references to them such as `&Vec<T>` "
"and `&[T]`. Ranges also implement it. This is why you can iterate over a "
"vector with `for i in some_vec { .. }` but `some_vec.next()` doesn't exist."
msgstr ""
"`IntoIterator` este tr캒s캒tura care face ca buclele for s캒 func탵ioneze. Este "
"implementat캒 prin tipuri de colec탵ii, cum ar fi `Vec<T>` 탳i referin탵e la "
"acestea, cum ar fi `&amp;Vec<T>` 탳i `&amp;[T]`. De asemenea, este "
"implementat캒 탳i 칥n cazul intervalelor. Acesta este motivul pentru care "
"pute탵i itera un vector cu `for i in some_vec { ... }`, dar `some_vec.next()` "
"nu exist캒."

#: src/traits/from-iterator.md:3
#, fuzzy
msgid ""
"[`FromIterator`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html) "
"lets you build a collection from an [`Iterator`](https://doc.rust-lang.org/"
"std/iter/trait.Iterator.html)."
msgstr ""
"[`FromIterator`]](https://doc.rust-lang.org/std/iter/trait.FromIterator."
"html) v캒 permite s캒 construi탵i o colec탵ie dintr-un [`Iterator`](https://doc."
"rust-lang.org/std/iter/trait.Iterator.html)."

#: src/traits/from-iterator.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let primes = vec![2, 3, 5, 7];\n"
"    let prime_squares = primes\n"
"        .into_iter()\n"
"        .map(|prime| prime * prime)\n"
"        .collect::<Vec<_>>();\n"
"    println!(\"prime_squares: {prime_squares:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    let prime = vec![2, 3, 5, 7];\n"
"    let prime_squares = prime\n"
"        .into_iter()\n"
"        .map(|prime| prime| prime * prime)\n"
"        .collect::<Vec<_>>>();\n"
"    println!(\"prime_squares: {prime_squares:?}\");\n"
"}\n"
"```"

#: src/traits/from-iterator.md:18
#, fuzzy
msgid ""
"`Iterator` implements `fn collect<B>(self) -> B where B: FromIterator<Self::"
"Item>, Self: Sized`"
msgstr ""
"`Iterator` implementeaz캒 `fn collect<B>(self) -&gt; B unde B: "
"FromIterator<Self::Item>, Self: Sized`"

#: src/traits/from-iterator.md:24
#, fuzzy
msgid ""
"There are also implementations which let you do cool things like convert an "
"`Iterator<Item = Result<V, E>>` into a `Result<Vec<V>, E>`."
msgstr ""
"Exist캒, de asemenea, implement캒ri care v캒 permit s캒 face탵i lucruri "
"interesante, cum ar fi convertirea unui `Iterator&lt;Item = Rezultat<V, "
"E>&gt;` 칥ntr-un `Resultat&lt;Vec<V>, E&gt;`."

#: src/traits/from-into.md:1
#, fuzzy
msgid "`From` and `Into`"
msgstr "`De` 탳i `칉ntru`"

#: src/traits/from-into.md:3
#, fuzzy
msgid ""
"Types implement [`From`](https://doc.rust-lang.org/std/convert/trait.From."
"html) and [`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) to "
"facilitate type conversions:"
msgstr ""
"Tipurile implementeaz캒 [`From`](https://doc.rust-lang.org/std/convert/trait."
"From.html) 탳i [`Into`](https://doc.rust-lang.org/std/convert/trait.Into."
"html) pentru a facilita conversiile de tip:"

#: src/traits/from-into.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s = String::from(\"hello\");\n"
"    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);\n"
"    let one = i16::from(true);\n"
"    let bigger = i32::from(123i16);\n"
"    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    let s = String::from(\"hello\");\n"
"    let addr = std::net::Ipv4Addr::from([127, 0, 0, 0, 1]);\n"
"    let one = i16::from(true);\n"
"    let bigger = i32::from(123i16);\n"
"    println!(\"{s}, {s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"

#: src/traits/from-into.md:15
#, fuzzy
msgid ""
"[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) is "
"automatically implemented when [`From`](https://doc.rust-lang.org/std/"
"convert/trait.From.html) is implemented:"
msgstr ""
"[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) este "
"implementat automat atunci c칙nd este implementat [`From`](https://doc.rust-"
"lang.org/std/convert/trait.From.html):"

#: src/traits/from-into.md:17
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s: String = \"hello\".into();\n"
"    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();\n"
"    let one: i16 = true.into();\n"
"    let bigger: i32 = 123i16.into();\n"
"    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    let s: String = \"hello\".into();\n"
"    let addr: std::net::Ipv4Addr = [127, 0, 0, 0, 1].into();\n"
"    let one: i16 = true.into();\n"
"    let bigger: i32 = 123i16.into();\n"
"    println!(\"{s}, {s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"

#: src/traits/from-into.md:29
#, fuzzy
msgid ""
"That's why it is common to only implement `From`, as your type will get "
"`Into` implementation too."
msgstr ""
"De aceea, este obi탳nuit s캒 se implementeze doar `From`, deoarece tipul t캒u "
"va primi 탳i implementarea `Into`."

#: src/traits/from-into.md:30
#, fuzzy
msgid ""
"When declaring a function argument input type like \"anything that can be "
"converted into a `String`\", the rule is opposite, you should use `Into`. "
"Your function will accept types that implement `From` and those that _only_ "
"implement `Into`."
msgstr ""
"Atunci c칙nd declara탵i un tip de intrare de argument de func탵ie de tipul "
"\"orice poate fi convertit 칥ntr-un `String`\", regula este opus캒, trebuie s캒 "
"utiliza탵i `Into`. Func탵ia dvs. va accepta tipurile care implementeaz캒 `From` "
"탳i cele care implementeaz캒 _doar_ `Into`."

#: src/traits/read-write.md:1
#, fuzzy
msgid "`Read` and `Write`"
msgstr "`Read` 탳i `Write`"

#: src/traits/read-write.md:3
#, fuzzy
msgid ""
"Using [`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) and "
"[`BufRead`](https://doc.rust-lang.org/std/io/trait.BufRead.html), you can "
"abstract over `u8` sources:"
msgstr ""
"Folosind [`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) 탳i "
"[`BufRead`](https://doc.rust-lang.org/std/io/trait.BufRead.html), pute탵i "
"face abstrac탵ie de sursele `u8`:"

#: src/traits/read-write.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::io::{BufRead, BufReader, Read, Result};\n"
"\n"
"fn count_lines<R: Read>(reader: R) -> usize {\n"
"    let buf_reader = BufReader::new(reader);\n"
"    buf_reader.lines().count()\n"
"}\n"
"\n"
"fn main() -> Result<()> {\n"
"    let slice: &[u8] = b\"foo\\nbar\\nbaz\\n\";\n"
"    println!(\"lines in slice: {}\", count_lines(slice));\n"
"\n"
"    let file = std::fs::File::open(std::env::current_exe()?)?;\n"
"    println!(\"lines in file: {}\", count_lines(file));\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"use std::io::{BufRead, BufReader, Read, Result};\n"
"\n"
"fn count_lines<R: Read>(reader: R) -&gt; usize {\n"
"    let buf_reader = BufReader::new(reader);\n"
"    buf_reader.lines().count()\n"
"}\n"
"\n"
"fn main() -&gt; Result<()> {\n"
"    let slice: &amp;[u8] = b \"foo\\nbarn\\nbaz\\n\";\n"
"    println!(\"lines in slice: {}\", count_lines(slice));\n"
"\n"
"    let file = std::fs::File::open(std::env::current_exe()?)?)?;\n"
"    println!(\"lines in file: {}\", count_lines(file));\n"
"    Ok((())\n"
"}\n"
"```"

#: src/traits/read-write.md:23
#, fuzzy
msgid ""
"Similarly, [`Write`](https://doc.rust-lang.org/std/io/trait.Write.html) lets "
"you abstract over `u8` sinks:"
msgstr ""
"칉n mod similar, [`Write`](https://doc.rust-lang.org/std/io/trait.Write.html) "
"v캒 permite s캒 face탵i abstrac탵ie de `u8` sink-uri:"

#: src/traits/read-write.md:25
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::io::{Result, Write};\n"
"\n"
"fn log<W: Write>(writer: &mut W, msg: &str) -> Result<()> {\n"
"    writer.write_all(msg.as_bytes())?;\n"
"    writer.write_all(\"\\n\".as_bytes())\n"
"}\n"
"\n"
"fn main() -> Result<()> {\n"
"    let mut buffer = Vec::new();\n"
"    log(&mut buffer, \"Hello\")?;\n"
"    log(&mut buffer, \"World\")?;\n"
"    println!(\"Logged: {:?}\", buffer);\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"use std::io::{Result, Write};\n"
"\n"
"fn log<W: Write>(writer: &amp;mut W, msg: &amp;str) -&gt; Result<()> {\n"
"    writer.write_all(msg.as_bytes())?;\n"
"    writer.write_all(\"\\n\".as_bytes())\n"
"}\n"
"\n"
"fn main() -&gt; Rezultat<()> {\n"
"    let mut buffer = Vec::new();\n"
"    log(&amp;mut buffer, \"Hello\")?;\n"
"    log(&amp;mut buffer, \"World\")?;\n"
"    println!(\"Logged: {:?}\", buffer);\n"
"    Ok((())\n"
"}\n"
"```"

#: src/traits/drop.md:1
#, fuzzy
msgid "The `Drop` Trait"
msgstr "Tr캒s캒tura `Drop` (c캒dere)"

#: src/traits/drop.md:3
#, fuzzy
msgid ""
"Values which implement [`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop."
"html) can specify code to run when they go out of scope:"
msgstr ""
"Valorile care implementeaz캒 [`Drop`](https://doc.rust-lang.org/std/ops/trait."
"Drop.html) pot specifica codul care trebuie executat atunci c칙nd ies din "
"domeniul de aplicare:"

#: src/traits/drop.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"struct Droppable {\n"
"    name: &'static str,\n"
"}\n"
"\n"
"impl Drop for Droppable {\n"
"    fn drop(&mut self) {\n"
"        println!(\"Dropping {}\", self.name);\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let a = Droppable { name: \"a\" };\n"
"    {\n"
"        let b = Droppable { name: \"b\" };\n"
"        {\n"
"            let c = Droppable { name: \"c\" };\n"
"            let d = Droppable { name: \"d\" };\n"
"            println!(\"Exiting block B\");\n"
"        }\n"
"        println!(\"Exiting block A\");\n"
"    }\n"
"    drop(a);\n"
"    println!(\"Exiting main\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"struct Droppable {\n"
"    name: &'static str,\n"
"}\n"
"\n"
"impl Drop pentru Droppable {\n"
"    fn drop(&mut self) {\n"
"        println!(\"Dropping {}\", self.name);\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let a = Droppable { name: \"a\" };\n"
"    {\n"
"        let b = Droppable { name: \"b\" };\n"
"        {\n"
"            let c = Droppable { name: \"c\" };\n"
"            let d = Droppable { name: \"d\" };\n"
"            println!(\"Ie탳ire din blocul B\");\n"
"        }\n"
"        println!(\"Ie탳ire din blocul A\");\n"
"    }\n"
"    drop(a);\n"
"    println!(\"Ie탳ire din main\");\n"
"}\n"
"```"

#: src/traits/drop.md:34
#, fuzzy
msgid "Note that `std::mem::drop` is not the same as `std::ops::Drop::drop`."
msgstr ""
"Re탵ine탵i c캒 `std::mem::drop` nu este acela탳i lucru cu `std::ops::Drop::drop`."

#: src/traits/drop.md:35
#, fuzzy
msgid "Values are automatically dropped when they go out of scope."
msgstr ""
"Valorile sunt eliminate automat atunci c칙nd ies din domeniul de aplicare."

#: src/traits/drop.md:36
#, fuzzy
msgid ""
"When a value is dropped, if it implements `std::ops::Drop` then its `Drop::"
"drop` implementation will be called."
msgstr ""
"Atunci c칙nd o valoare este eliminat캒, dac캒 implementeaz캒 `std::ops::Drop`, "
"atunci va fi apelat캒 implementarea `Drop::drop` a acesteia."

#: src/traits/drop.md:38
#, fuzzy
msgid ""
"All its fields will then be dropped too, whether or not it implements `Drop`."
msgstr ""
"Toate c칙mpurile sale vor fi apoi eliminate, indiferent dac캒 implementeaz캒 "
"sau nu `Drop`."

#: src/traits/drop.md:39
#, fuzzy
msgid ""
"`std::mem::drop` is just an empty function that takes any value. The "
"significance is that it takes ownership of the value, so at the end of its "
"scope it gets dropped. This makes it a convenient way to explicitly drop "
"values earlier than they would otherwise go out of scope."
msgstr ""
"`std::mem::drop` este doar o func탵ie goal캒 care accept캒 orice valoare. "
"Semnifica탵ia este c캒 preia proprietatea asupra valorii, astfel 칥nc칙t la "
"sf칙r탳itul domeniului s캒u de aplicare aceasta este eliminat캒. Acest lucru o "
"face o modalitate convenabil캒 de a renun탵a 칥n mod explicit la valori mai "
"devreme dec칙t ar fi ie탳it altfel din domeniul de aplicare."

#: src/traits/drop.md:42
#, fuzzy
msgid ""
"This can be useful for objects that do some work on `drop`: releasing locks, "
"closing files, etc."
msgstr ""
"Acest lucru poate fi util pentru obiectele care efectueaz캒 anumite "
"activit캒탵i la `drop`: eliberarea de blocaje, 칥nchiderea fi탳ierelor etc."

#: src/traits/drop.md:45 src/traits/operators.md:26
#, fuzzy
msgid "Discussion points:"
msgstr "Puncte de discu탵ie:"

#: src/traits/drop.md:47
#, fuzzy
msgid "Why doesn't `Drop::drop` take `self`?"
msgstr "De ce `Drop::drop` nu ia `self`?"

#: src/traits/drop.md:48
#, fuzzy
msgid ""
"Short-answer: If it did, `std::mem::drop` would be called at the end of the "
"block, resulting in another call to `Drop::drop`, and a stack overflow!"
msgstr ""
"R캒spuns scurt: Dac캒 ar fi f캒cut-o, `std::mem::drop` ar fi fost apelat la "
"sf칙r탳itul blocului, rezult칙nd un alt apel la `Drop::drop` 탳i o dep캒탳ire a "
"stivei!"

#: src/traits/drop.md:51
#, fuzzy
msgid "Try replacing `drop(a)` with `a.drop()`."
msgstr "칉ncerca탵i s캒 칥nlocui탵i `drop(a)` cu `a.drop()`."

#: src/traits/default.md:1
#, fuzzy
msgid "The `Default` Trait"
msgstr "Tr캒s캒tura `Default` (implicit)"

#: src/traits/default.md:3
#, fuzzy
msgid ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) trait "
"produces a default value for a type."
msgstr ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) "
"caracteristica produce o valoare implicit캒 pentru un tip."

#: src/traits/default.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"#[derive(Debug, Default)]\n"
"struct Derived {\n"
"    x: u32,\n"
"    y: String,\n"
"    z: Implemented,\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"struct Implemented(String);\n"
"\n"
"impl Default for Implemented {\n"
"    fn default() -> Self {\n"
"        Self(\"John Smith\".into())\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let default_struct = Derived::default();\n"
"    println!(\"{default_struct:#?}\");\n"
"\n"
"    let almost_default_struct = Derived {\n"
"        y: \"Y is set!\".into(),\n"
"        ..Derived::default()\n"
"    };\n"
"    println!(\"{almost_default_struct:#?}\");\n"
"\n"
"    let nothing: Option<Derived> = None;\n"
"    println!(\"{:#?}\", nothing.unwrap_or_default());\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust,editabil\n"
"#[derive(Debug, Default)]\n"
"struct Derived {\n"
"    x: u32,\n"
"    y: String,\n"
"    z: implementat,\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"struct Implemented(String);\n"
"\n"
"impl Default pentru Implemented {\n"
"    fn default() -&gt; Self {\n"
"        Self(\"John Smith\".into())\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let default_struct = Derived::default();\n"
"    println!(\"{default_struct:#?}\");\n"
"\n"
"    let almost_default_struct = Derived {\n"
"        y: \"Y este setat!\".into(),\n"
"        ..Derived::default()\n"
"    };\n"
"    println!(\"{almost_default_struct:#?}\");\n"
"\n"
"    let nothing: Option<Derived> = None;\n"
"    println!(\"{:#?}\", nothing.unwrap_or_default());\n"
"}\n"
"\n"
"```"

#: src/traits/default.md:40
#, fuzzy
msgid ""
"It can be implemented directly or it can be derived via `#[derive(Default)]`."
msgstr ""
"Poate fi implementat direct sau poate fi derivat prin `#[derive(Default)]`."

#: src/traits/default.md:41
#, fuzzy
msgid ""
"A derived implementation will produce a value where all fields are set to "
"their default values."
msgstr ""
"O implementare derivat캒 va produce o valoare 칥n care toate c칙mpurile sunt "
"setate la valorile lor implicite."

#: src/traits/default.md:42
#, fuzzy
msgid "This means all types in the struct must implement `Default` too."
msgstr ""
"Aceasta 칥nseamn캒 c캒 toate tipurile din structura trebuie s캒 implementeze 탳i "
"`Default`."

#: src/traits/default.md:43
#, fuzzy
msgid ""
"Standard Rust types often implement `Default` with reasonable values (e.g. "
"`0`, `\"\"`, etc)."
msgstr ""
"Tipurile standard Rust implementeaz캒 adesea `Default` cu valori rezonabile "
"(de exemplu, `0`, `\"\"`, etc.)."

#: src/traits/default.md:44
#, fuzzy
msgid "The partial struct copy works nicely with default."
msgstr "Copierea par탵ial캒 a structurii func탵ioneaz캒 bine 칥n mod implicit."

#: src/traits/default.md:45
#, fuzzy
msgid ""
"Rust standard library is aware that types can implement `Default` and "
"provides convenience methods that use it."
msgstr ""
"Biblioteca standard Rust este con탳tient캒 de faptul c캒 tipurile pot "
"implementa `Default` 탳i ofer캒 metode de convenien탵캒 care 칥l utilizeaz캒."

#: src/traits/default.md:46
#, fuzzy
msgid ""
"the `..` syntax is called [struct update syntax](https://doc.rust-lang.org/"
"book/ch05-01-defining-structs.html#creating-instances-from-other-instances-"
"with-struct-update-syntax)"
msgstr ""
"sintaxa `..` se nume탳te [struct update syntax](https://doc.rust-lang.org/"
"book/ch05-01-defining-structs.html#creating-instances-from-other-instances-"
"with-struct-update-syntax)"

#: src/traits/operators.md:1
#, fuzzy
msgid "`Add`, `Mul`, ..."
msgstr "`Add`, `Mul`, ..."

#: src/traits/operators.md:3
#, fuzzy
msgid ""
"Operator overloading is implemented via traits in [`std::ops`](https://doc."
"rust-lang.org/std/ops/index.html):"
msgstr ""
"Supra칥nc캒rcarea operatorilor este implementat캒 prin intermediul tr캒s캒turilor "
"칥n [`std::ops`](https://doc.rust-lang.org/std/ops/index.html):"

#: src/traits/operators.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"#[derive(Debug, Copy, Clone)]\n"
"struct Point { x: i32, y: i32 }\n"
"\n"
"impl std::ops::Add for Point {\n"
"    type Output = Self;\n"
"\n"
"    fn add(self, other: Self) -> Self {\n"
"        Self {x: self.x + other.x, y: self.y + other.y}\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Point { x: 10, y: 20 };\n"
"    let p2 = Point { x: 100, y: 200 };\n"
"    println!(\"{:?} + {:?} = {:?}\", p1, p2, p1 + p2);\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"#[derive(Debug, Copy, Clone)]]\n"
"struct Point { x: i32, y: i32 }\n"
"\n"
"impl std::ops::Add for Point {\n"
"    type Output = Self;\n"
"\n"
"    fn add(self, other: Self) -> Self {\n"
"        Self {x: self.x + other.x, y: self.y + other.y}\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Point { x: 10, y: 20 };\n"
"    let p2 = Point { x: 100, y: 200 };\n"
"    println!(\"{:?} + {:?} = {:?}\", p1, p2, p1 + p2);\n"
"}\n"
"```"

#: src/traits/operators.md:28
#, fuzzy
msgid ""
"You could implement `Add` for `&Point`. In which situations is that useful? "
msgstr "A탵i putea implementa `Add` pentru `&Point`. 칉n ce situa탵ii este util캒?"

#: src/traits/operators.md:29
#, fuzzy
msgid ""
"Answer: `Add:add` consumes `self`. If type `T` for which you are overloading "
"the operator is not `Copy`, you should consider overloading the operator for "
"`&T` as well. This avoids unnecessary cloning on the call site."
msgstr ""
"R캒spuns: `Add:add` consum캒 `self`. Dac캒 tipul `T` pentru care supra칥nc캒rca탵i "
"operatorul nu este `Copy`, ar trebui s캒 lua탵i 칥n considerare supra칥nc캒rcarea "
"operatorului 탳i pentru `&T`. Astfel se evit캒 clonarea inutil캒 pe locul de "
"apel."

#: src/traits/operators.md:33
#, fuzzy
msgid ""
"Why is `Output` an associated type? Could it be made a type parameter of the "
"method?"
msgstr ""
"De ce este `Output` un tip asociat? Ar putea fi transformat 칥ntr-un "
"parametru de tip al metodei?"

#: src/traits/operators.md:34
#, fuzzy
msgid ""
"Short answer: Function type parameters are controlled by the caller, but "
"associated types (like `Output`) are controlled by the implementor of a "
"trait."
msgstr ""
"R캒spuns scurt: Parametrii de tip func탵ie sunt controla탵i de c캒tre apelant, "
"dar tipurile asociate (cum ar fi `Output`) sunt controlate de c캒tre "
"implementatorul unei tr캒s캒turi."

#: src/traits/operators.md:37
#, fuzzy
msgid ""
"You could implement `Add` for two different types, e.g. `impl Add<(i32, "
"i32)> for Point` would add a tuple to a `Point`."
msgstr ""
"A탵i putea implementa `Add` pentru dou캒 tipuri diferite, de exemplu, `impl "
"Add<(i32, i32)> pentru Point` ar ad캒uga un tuple la un `Point`."

#: src/traits/closures.md:1
#, fuzzy
msgid "Closures"
msgstr "칉nchideri"

#: src/traits/closures.md:3
#, fuzzy
msgid ""
"Closures or lambda expressions have types which cannot be named. However, "
"they implement special [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn."
"html), [`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), and "
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) traits:"
msgstr ""
"칉nchiderile sau expresiile lambda au tipuri care nu pot fi numite. Cu toate "
"acestea, ele implementeaz캒 tr캒s캒turile speciale [`Fn`](https://doc.rust-lang."
"org/std/ops/trait.Fn.html), [`FnMut`](https://doc.rust-lang.org/std/ops/"
"trait.FnMut.html) 탳i [`FnOnce`](https://doc.rust-lang.org/std/ops/trait."
"FnOnce.html):"

#: src/traits/closures.md:8
#, fuzzy
msgid ""
"```rust,editable\n"
"fn apply_with_log(func: impl FnOnce(i32) -> i32, input: i32) -> i32 {\n"
"    println!(\"Calling function on {input}\");\n"
"    func(input)\n"
"}\n"
"\n"
"fn main() {\n"
"    let add_3 = |x| x + 3;\n"
"    println!(\"add_3: {}\", apply_with_log(add_3, 10));\n"
"    println!(\"add_3: {}\", apply_with_log(add_3, 20));\n"
"\n"
"    let mut v = Vec::new();\n"
"    let mut accumulate = |x: i32| {\n"
"        v.push(x);\n"
"        v.iter().sum::<i32>()\n"
"    };\n"
"    println!(\"accumulate: {}\", apply_with_log(&mut accumulate, 4));\n"
"    println!(\"accumulate: {}\", apply_with_log(&mut accumulate, 5));\n"
"\n"
"    let multiply_sum = |x| x * v.into_iter().sum::<i32>();\n"
"    println!(\"multiply_sum: {}\", apply_with_log(multiply_sum, 3));\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn apply_with_log(func: impl FnOnce(i32) -&gt; i32, input: i32) -&gt; i32 {\n"
"    println!(\"Apelarea func탵iei pe {input}\");\n"
"    func(input)\n"
"}\n"
"\n"
"fn main() {\n"
"    let add_3 = |x| x + 3;\n"
"    println!(\"add_3: {}\", apply_with_log(add_3, 10));\n"
"    println!(\"add_3: {}\", apply_with_log(add_3, 20));\n"
"\n"
"    let mut v = Vec::new();\n"
"    let mut accumulate = |x: i32| {\n"
"        v.push(x);\n"
"        v.iter().sum::<i32>()\n"
"    };\n"
"    println!(\"accumulate: {}\", apply_with_log(&amp;mut accumulate, 4));\n"
"    println!(\"accumulate: {}\", apply_with_log(&amp;mut accumulate, 5));\n"
"\n"
"    let multiply_sum = |x| x * v.into_iter().sum:::<i32>();\n"
"    println!(\"multiply_sum: {}\", apply_with_log(multiply_sum, 3));\n"
"}\n"
"```"

#: src/traits/closures.md:34
#, fuzzy
msgid ""
"An `Fn` (e.g. `add_3`) neither consumes nor mutates captured values, or "
"perhaps captures nothing at all. It can be called multiple times "
"concurrently."
msgstr ""
"Un `Fn` (de exemplu, `add_3`) nu consum캒 탳i nici nu modific캒 valorile "
"capturate, sau poate nu capteaz캒 nimic. Acesta poate fi apelat de mai multe "
"ori simultan."

#: src/traits/closures.md:37
#, fuzzy
msgid ""
"An `FnMut` (e.g. `accumulate`) might mutate captured values. You can call it "
"multiple times, but not concurrently."
msgstr ""
"Un `FnMut` (de exemplu, `accumulate`) poate modifica valorile capturate. Se "
"poate apela de mai multe ori, dar nu concomitent."

#: src/traits/closures.md:40
#, fuzzy
msgid ""
"If you have an `FnOnce` (e.g. `multiply_sum`), you may only call it once. It "
"might consume captured values."
msgstr ""
"Dac캒 ave탵i un `FnOnce` (de exemplu, `multiply_sum`), 칥l pute탵i apela doar o "
"singur캒 dat캒. Acesta ar putea consuma valori capturate."

#: src/traits/closures.md:43
#, fuzzy
msgid ""
"`FnMut` is a subtype of `FnOnce`. `Fn` is a subtype of `FnMut` and `FnOnce`. "
"I.e. you can use an `FnMut` wherever an `FnOnce` is called for, and you can "
"use an `Fn` wherever an `FnMut` or `FnOnce` is called for."
msgstr ""
"`FnMut` este un subtip al `FnOnce`. `Fn` este un subtip al lui `FnMut` 탳i "
"`FnOnce`. Adic캒, pute탵i utiliza un `FnMut` oriunde se solicit캒 un `FnOnce` "
"탳i pute탵i utiliza un `Fn` oriunde se solicit캒 un `FnMut` sau un `FnOnce`."

#: src/traits/closures.md:47
#, fuzzy
msgid ""
"The compiler also infers `Copy` (e.g. for `add_3`) and `Clone` (e.g. "
"`multiply_sum`), depending on what the closure captures."
msgstr ""
"Compilatorul deduce, de asemenea, `Copy` (de exemplu, pentru `add_3`) 탳i "
"`Clone` (de exemplu, `multiply_sum`), 칥n func탵ie de ceea ce capteaz캒 "
"칥nchiderea."

#: src/traits/closures.md:50
#, fuzzy
msgid ""
"By default, closures will capture by reference if they can. The `move` "
"keyword makes them capture by value."
msgstr ""
"칉n mod implicit, 칥nchiderile vor captura prin referin탵캒 dac캒 pot. Cuv칙ntul "
"cheie `move` le face s캒 captureze prin valoare."

#: src/traits/closures.md:52
#, fuzzy
msgid ""
"```rust,editable\n"
"fn make_greeter(prefix: String) -> impl Fn(&str) {\n"
"    return move |name| println!(\"{} {}\", prefix, name)\n"
"}\n"
"\n"
"fn main() {\n"
"    let hi = make_greeter(\"Hi\".to_string());\n"
"    hi(\"there\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn make_greeter(prefix: String) -> impl Fn(&str) {\n"
"    return move |name| println!(\"{} {}\", prefix, name)\n"
"}\n"
"\n"
"fn main() {\n"
"    let hi = make_greeter(\"Hi\".to_string());\n"
"    hi(\"acolo\");\n"
"}\n"
"```"

#: src/exercises/day-3/morning.md:1
#, fuzzy
msgid "Day 3: Morning Exercises"
msgstr "Ziua 3: Exerci탵ii de diminea탵캒"

#: src/exercises/day-3/morning.md:3
#, fuzzy
msgid "We will design a classical GUI library using traits and trait objects."
msgstr ""
"Vom proiecta o bibliotec캒 GUI clasic캒 folosind tr캒s캒turi 탳i obiecte de "
"tr캒s캒turi."

#: src/exercises/day-3/morning.md:5
#, fuzzy
msgid ""
"We will also look at enum dispatch with an exercise involving points and "
"polygons."
msgstr ""
"De asemenea, vom examina dispecerizarea enum cu un exerci탵iu care implic캒 "
"puncte 탳i poligoane."

#: src/exercises/day-3/simple-gui.md:1
#: src/exercises/day-3/solutions-morning.md:3
#, fuzzy
msgid "Drawing A Simple GUI"
msgstr "Desenarea unei interfe탵e grafice simple"

#: src/exercises/day-3/simple-gui.md:3
#, fuzzy
msgid ""
"Let us design a classical GUI library using our new knowledge of traits and "
"trait objects. We'll only implement the drawing of it (as text) for "
"simplicity."
msgstr ""
"S캒 proiect캒m o bibliotec캒 GUI clasic캒 folosind noile noastre cuno탳tin탵e "
"despre tr캒s캒turi 탳i obiecte de tr캒s캒turi. Pentru simplificare, vom "
"implementa doar desenul (sub form캒 de text)."

#: src/exercises/day-3/simple-gui.md:6
#, fuzzy
msgid "We will have a number of widgets in our library:"
msgstr "Vom avea un num캒r de widget-uri 칥n biblioteca noastr캒:"

#: src/exercises/day-3/simple-gui.md:8
#, fuzzy
msgid "`Window`: has a `title` and contains other widgets."
msgstr "`Window`: are un `titlu` 탳i con탵ine alte widget-uri."

#: src/exercises/day-3/simple-gui.md:9
#, fuzzy
msgid ""
"`Button`: has a `label`. In reality, it would also take a callback function "
"to allow the program to do something when the button is clicked but we won't "
"include that since we're only drawing the GUI."
msgstr ""
"`Button`: are o `label`. 칉n realitate, ar trebui s캒 aib캒 탳i o func탵ie de "
"apelare pentru a permite programului s캒 fac캒 ceva atunci c칙nd butonul este "
"ap캒sat, dar nu o vom include, deoarece desen캒m doar interfa탵a grafic캒."

#: src/exercises/day-3/simple-gui.md:12
#, fuzzy
msgid "`Label`: has a `label`."
msgstr "`Label`: are un `label`."

#: src/exercises/day-3/simple-gui.md:14
#, fuzzy
msgid "The widgets will implement a `Widget` trait, see below."
msgstr "Widget-urile vor implementa o tr캒s캒tur캒 `Widget`, a se vedea mai jos."

#: src/exercises/day-3/simple-gui.md:16
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/>, fill in the missing "
"`draw_into` methods so that you implement the `Widget` trait:"
msgstr ""
"Copia탵i codul de mai jos 칥n <https://play.rust-lang.org/>, completa탵i "
"metodele `draw_into` care lipsesc, astfel 칥nc칙t s캒 implementa탵i tr캒s캒tura "
"`Widget`:"

#: src/exercises/day-3/simple-gui.md:19
#, fuzzy
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_imports, unused_variables, dead_code)]\n"
"\n"
"pub trait Widget {\n"
"    /// Natural width of `self`.\n"
"    fn width(&self) -> usize;\n"
"\n"
"    /// Draw the widget into a buffer.\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);\n"
"\n"
"    /// Draw the widget on standard output.\n"
"    fn draw(&self) {\n"
"        let mut buffer = String::new();\n"
"        self.draw_into(&mut buffer);\n"
"        println!(\"{buffer}\");\n"
"    }\n"
"}\n"
"\n"
"pub struct Label {\n"
"    label: String,\n"
"}\n"
"\n"
"impl Label {\n"
"    fn new(label: &str) -> Label {\n"
"        Label {\n"
"            label: label.to_owned(),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Button {\n"
"    label: Label,\n"
"}\n"
"\n"
"impl Button {\n"
"    fn new(label: &str) -> Button {\n"
"        Button {\n"
"            label: Label::new(label),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Window {\n"
"    title: String,\n"
"    widgets: Vec<Box<dyn Widget>>,\n"
"}\n"
"\n"
"impl Window {\n"
"    fn new(title: &str) -> Window {\n"
"        Window {\n"
"            title: title.to_owned(),\n"
"            widgets: Vec::new(),\n"
"        }\n"
"    }\n"
"\n"
"    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
"        self.widgets.push(widget);\n"
"    }\n"
"\n"
"    fn inner_width(&self) -> usize {\n"
"        std::cmp::max(\n"
"            self.title.chars().count(),\n"
"            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
"        )\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"This is a small text GUI demo."
"\")));\n"
"    window.add_widget(Box::new(Button::new(\n"
"        \"Click me!\"\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"```"
msgstr ""
"```rust,should_panic\n"
"// TODO: elimina탵i acest lucru atunci c칙nd a탵i terminat cu implementarea.\n"
"#![allow(unused_imports, unused_variables, dead_code)]]\n"
"\n"
"pub trait Widget {\n"
"    /// L캒탵imea natural캒 a lui `self`.\n"
"    fn width(&amp;self) -&gt; usize;\n"
"\n"
"    /// Deseneaz캒 widget-ul 칥ntr-un buffer.\n"
"    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write);\n"
"\n"
"    /// Deseneaz캒 widget-ul pe ie탳irea standard.\n"
"    fn draw(&amp;self) {\n"
"        let mut buffer = String::new();\n"
"        self.draw_into(&amp;mut buffer);\n"
"        println!(\"{buffer}\");\n"
"    }\n"
"}\n"
"\n"
"pub struct Label {\n"
"    label: String,\n"
"}\n"
"\n"
"impl Label {\n"
"    fn new(label: &amp;str) -&gt; Label {\n"
"        Etichet캒 {\n"
"            label: label.to_owned(),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Button {\n"
"    label: Label,\n"
"}\n"
"\n"
"impl Button {\n"
"    fn new(label: &amp;str) -&gt; Button {\n"
"        Button {\n"
"            label: Label::new(label),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Window {\n"
"    title: String,\n"
"    widgets: Vec&lt;Box<dyn Widget>&gt;,\n"
"}\n"
"\n"
"impl Window {\n"
"    fn new(title: &amp;str) -&gt; Window {\n"
"        Window {\n"
"            title: title.to_owned(),\n"
"            widgets: Vec::new(),\n"
"        }\n"
"    }\n"
"\n"
"    fn add_widget(&amp;mut self, widget: Box<dyn Widget>) {\n"
"        self.widgets.push(widget);\n"
"    }\n"
"\n"
"    fn inner_width(&amp;self) -&gt; usize {\n"
"        std::cmp::max(\n"
"            self.title.chars().count(),\n"
"            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
"        )\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl Widget pentru etichet캒 {\n"
"    fn width(&amp;self) -&gt; usize {\n"
"        neimplementat!()\n"
"    }\n"
"\n"
"    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {\n"
"        neimplementat!()\n"
"    }\n"
"}\n"
"\n"
"impl Widget pentru Button {\n"
"    fn width(&amp;self) -&gt; usize {\n"
"        neimplementat!()\n"
"    }\n"
"\n"
"    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {\n"
"        neimplementat!()\n"
"    }\n"
"}\n"
"\n"
"impl Widget pentru Window {\n"
"    fn width(&amp;self) -&gt; usize {\n"
"        neimplementat!()\n"
"    }\n"
"\n"
"    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {\n"
"        neimplementat!()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"Aceasta este o mic캒 demonstra탵ie "
"GUI de text.\")));\n"
"    window.add_widget(Box::new(Button::new(:new(\n"
"        \"Face탵i clic pe mine!\"\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"```"

#: src/exercises/day-3/simple-gui.md:128
#, fuzzy
msgid "The output of the above program can be something simple like this:"
msgstr "Rezultatul programului de mai sus poate fi ceva simplu, cum ar fi:"

#: src/exercises/day-3/simple-gui.md:140
#, fuzzy
msgid ""
"If you want to draw aligned text, you can use the [fill/alignment](https://"
"doc.rust-lang.org/std/fmt/index.html#fillalignment) formatting operators. In "
"particular, notice how you can pad with different characters (here a `'/'`) "
"and how you can control alignment:"
msgstr ""
"Dac캒 dori탵i s캒 desena탵i text aliniat, pute탵i utiliza operatorii de formatare "
"[fill/alignment](https://doc.rust-lang.org/std/fmt/index."
"html#fillalignment). 칉n special, observa탵i cum pute탵i umple cu diferite "
"caractere (aici un `'/'`) 탳i cum pute탵i controla alinierea:"

#: src/exercises/day-3/simple-gui.md:145
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let width = 10;\n"
"    println!(\"left aligned:  |{:/<width$}|\", \"foo\");\n"
"    println!(\"centered:      |{:/^width$}|\", \"foo\");\n"
"    println!(\"right aligned: |{:/>width$}|\", \"foo\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    let width = 10;\n"
"    println!(\"aliniat la st칙nga: |{:/<width$}|\", \"foo\");\n"
"    println!(\"centrat: |{:/^width$}|\", \"foo\");\n"
"    println!(\"aliniat la dreapta: |{:/>width$}|\", \"foo\");\n"
"}\n"
"```"

#: src/exercises/day-3/simple-gui.md:154
#, fuzzy
msgid ""
"Using such alignment tricks, you can for example produce output like this:"
msgstr ""
"Folosind astfel de trucuri de aliniere, pute탵i, de exemplu, s캒 produce탵i "
"rezultate de genul acesta:"

#: src/exercises/day-3/points-polygons.md:1
#, fuzzy
msgid "Polygon Struct"
msgstr "Structur캒 poligonal캒"

#: src/exercises/day-3/points-polygons.md:3
#, fuzzy
msgid ""
"We will create a `Polygon` struct which contain some points. Copy the code "
"below to <https://play.rust-lang.org/> and fill in the missing methods to "
"make the tests pass:"
msgstr ""
"Vom crea o structur캒 `Polygon` care con탵ine c칙teva puncte. Copia탵i codul de "
"mai jos 칥n <https://play.rust-lang.org/> 탳i completa탵i metodele care lipsesc "
"pentru a face testele s캒 treac캒:"

#: src/exercises/day-3/points-polygons.md:7
#, fuzzy
msgid ""
"```rust\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub struct Point {\n"
"    // add fields\n"
"}\n"
"\n"
"impl Point {\n"
"    // add methods\n"
"}\n"
"\n"
"pub struct Polygon {\n"
"    // add fields\n"
"}\n"
"\n"
"impl Polygon {\n"
"    // add methods\n"
"}\n"
"\n"
"pub struct Circle {\n"
"    // add fields\n"
"}\n"
"\n"
"impl Circle {\n"
"    // add methods\n"
"}\n"
"\n"
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    fn round_two_digits(x: f64) -> f64 {\n"
"        (x * 100.0).round() / 100.0\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_magnitude() {\n"
"        let p1 = Point::new(12, 13);\n"
"        assert_eq!(round_two_digits(p1.magnitude()), 17.69);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_dist() {\n"
"        let p1 = Point::new(10, 10);\n"
"        let p2 = Point::new(14, 13);\n"
"        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_add() {\n"
"        let p1 = Point::new(16, 16);\n"
"        let p2 = p1 + Point::new(-4, 3);\n"
"        assert_eq!(p2, Point::new(12, 19));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_left_most_point() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"        assert_eq!(poly.left_most_point(), Some(p1));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_iter() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"\n"
"        let points = poly.iter().cloned().collect::<Vec<_>>();\n"
"        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimeter)\n"
"            .map(round_two_digits)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}\n"
"\n"
"#[allow(dead_code)]\n"
"fn main() {}\n"
"```"
msgstr ""
"```rust\n"
"// TODO: elimina탵i acest lucru atunci c칙nd a탵i terminat cu implementarea.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub struct Struct Point {\n"
"    // adaug캒 c칙mpuri\n"
"}\n"
"\n"
"impl Point {\n"
"    // adaug캒 metode\n"
"}\n"
"\n"
"pub struct struct Polygon {\n"
"    // adaug캒 c칙mpuri\n"
"}\n"
"\n"
"impl Polygon {\n"
"    // adaug캒 metode\n"
"}\n"
"\n"
"pub struct Circle {\n"
"    // adaug캒 c칙mpuri\n"
"}\n"
"\n"
"impl Circle {\n"
"    // adaug캒 metode\n"
"}\n"
"\n"
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    fn round_two_digits(x: f64) -> f64 {\n"
"        (x * 100.0).round() / 100.0\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_punct_magnitude() {\n"
"        let p1 = Point::new(12, 13);\n"
"        assert_eq!(round_two_digits(p1.magnitude())), 17.69);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_punct_dist() {\n"
"        let p1 = Point::new(10, 10);\n"
"        let p2 = Point::new(14, 13);\n"
"        assert_eq!(round_two_digits(p1.dist(p2))), 5.00);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_punct_add() {\n"
"        let p1 = Point::new(16, 16);\n"
"        let p2 = p1 + Point::new(-4, 3);\n"
"        assert_eq!(p2, Point::new(12, 19));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_poligon_poligon_punctul_cel_mai_st칙nga() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"        assert_eq!(poly.left_most_point(), Some(p1));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_iter() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"\n"
"        let points = poly.iter().cloned().collect::<Vec<_>>>();\n"
"        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimetru)\n"
"            .map(round_two_digits)\n"
"            .collect::<Vec<_>>>();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}\n"
"\n"
"#[allow(dead_code)]\n"
"fn main() {}\n"
"```"

#: src/exercises/day-3/points-polygons.md:117
#, fuzzy
msgid ""
"Since the method signatures are missing from the problem statements, the key "
"part of the exercise is to specify those correctly. You don't have to modify "
"the tests."
msgstr ""
"Deoarece semn캒turile metodelor lipsesc din enun탵urile problemei, partea "
"esen탵ial캒 a exerci탵iului este de a le specifica corect. Nu trebuie s캒 "
"modifica탵i testele."

#: src/exercises/day-3/points-polygons.md:120
#, fuzzy
msgid "Other interesting parts of the exercise:"
msgstr "Alte p캒r탵i interesante ale exerci탵iului:"

#: src/exercises/day-3/points-polygons.md:122
#, fuzzy
msgid ""
"Derive a `Copy` trait for some structs, as in tests the methods sometimes "
"don't borrow their arguments."
msgstr ""
"Deriva탵i o tr캒s캒tur캒 `Copy` pentru unele structuri, deoarece 칥n teste "
"metodele uneori nu-탳i 칥mprumut캒 argumentele."

#: src/exercises/day-3/points-polygons.md:123
#, fuzzy
msgid ""
"Discover that `Add` trait must be implemented for two objects to be addable "
"via \"+\". Note that we do not discuss generics until Day 3."
msgstr ""
"Descoperi탵i c캒 tr캒s캒tura `Add` trebuie s캒 fie implementat캒 pentru ca dou캒 "
"obiecte s캒 poat캒 fi ad캒ugate prin \"+\". Re탵ine탵i c캒 nu vom discuta despre "
"generice p칙n캒 칥n ziua 3."

#: src/error-handling.md:3
#, fuzzy
msgid "Error handling in Rust is done using explicit control flow:"
msgstr ""
"Gestionarea erorilor 칥n Rust se face folosind un flux de control explicit:"

#: src/error-handling.md:5
#, fuzzy
msgid "Functions that can have errors list this in their return type,"
msgstr ""
"Func탵iile care pot avea erori indic캒 acest lucru 칥n tipul lor de returnare,"

#: src/error-handling.md:6
#, fuzzy
msgid "There are no exceptions."
msgstr "Nu exist캒 excep탵ii."

#: src/error-handling/panics.md:3
#, fuzzy
msgid "Rust will trigger a panic if a fatal error happens at runtime:"
msgstr ""
"Rust va declan탳a o panic캒 칥n cazul 칥n care se produce o eroare fatal캒 칥n "
"timpul execu탵iei:"

#: src/error-handling/panics.md:5
#, fuzzy
msgid ""
"```rust,editable,should_panic\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    println!(\"v[100]: {}\", v[100]);\n"
"}\n"
"```"
msgstr ""
"```rust,editabil,should_panic\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    println!(\"v[100]: {}\", v[100]);\n"
"}\n"
"```"

#: src/error-handling/panics.md:12
#, fuzzy
msgid "Panics are for unrecoverable and unexpected errors."
msgstr "Panica este pentru erori irecuperabile 탳i nea탳teptate."

#: src/error-handling/panics.md:13
#, fuzzy
msgid "Panics are symptoms of bugs in the program."
msgstr "Panicile sunt simptome ale unor erori 칥n program."

#: src/error-handling/panics.md:14
#, fuzzy
msgid ""
"Use non-panicking APIs (such as `Vec::get`) if crashing is not acceptable."
msgstr ""
"Folosi탵i API-uri care nu se blocheaz캒 (cum ar fi `Vec::get`) dac캒 nu este "
"acceptabil캒 blocarea."

#: src/error-handling/panic-unwind.md:1
#, fuzzy
msgid "Catching the Stack Unwinding"
msgstr "Prinderea derul캒rii stivei"

#: src/error-handling/panic-unwind.md:3
#, fuzzy
msgid ""
"By default, a panic will cause the stack to unwind. The unwinding can be "
"caught:"
msgstr ""
"칉n mod implicit, o panic캒 va determina derularea stivei. Desf캒탳urarea poate "
"fi prins캒:"

#: src/error-handling/panic-unwind.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::panic;\n"
"\n"
"fn main() {\n"
"    let result = panic::catch_unwind(|| {\n"
"        \"No problem here!\"\n"
"    });\n"
"    println!(\"{result:?}\");\n"
"\n"
"    let result = panic::catch_unwind(|| {\n"
"        panic!(\"oh no!\");\n"
"    });\n"
"    println!(\"{result:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"folosi탵i std::panic;\n"
"\n"
"fn main() {\n"
"    let result = panic::catch_unwind(|| {| {\n"
"        \"Nicio problem캒 aici!\"\n"
"    });\n"
"    println!(\"{result:?}\");\n"
"\n"
"    let result = panic::catch_unwind(|| {| {\n"
"        panic!(\"oh nu!\");\n"
"    });\n"
"    println!(\"{result:?}\");\n"
"}\n"
"```"

#: src/error-handling/panic-unwind.md:21
#, fuzzy
msgid ""
"This can be useful in servers which should keep running even if a single "
"request crashes."
msgstr ""
"Acest lucru poate fi util 칥n cazul serverelor care trebuie s캒 continue s캒 "
"func탵ioneze chiar dac캒 o singur캒 cerere se blocheaz캒."

#: src/error-handling/panic-unwind.md:23
#, fuzzy
msgid "This does not work if `panic = 'abort'` is set in your `Cargo.toml`."
msgstr ""
"Acest lucru nu func탵ioneaz캒 dac캒 `panic = 'abort'` este setat 칥n `Cargo."
"toml`."

#: src/error-handling/result.md:1
#, fuzzy
msgid "Structured Error Handling with `Result`"
msgstr "Gestionarea structurat캒 a erorilor cu `Result`"

#: src/error-handling/result.md:3
#, fuzzy
msgid ""
"We have already seen the `Result` enum. This is used pervasively when errors "
"are expected as part of normal operation:"
msgstr ""
"Am v캒zut deja enum-ul `Result`. Acesta este utilizat 칥n mod omniprezent "
"atunci c칙nd se a탳teapt캒 erori ca parte a func탵ion캒rii normale:"

#: src/error-handling/result.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::fs;\n"
"use std::io::Read;\n"
"\n"
"fn main() {\n"
"    let file = fs::File::open(\"diary.txt\");\n"
"    match file {\n"
"        Ok(mut file) => {\n"
"            let mut contents = String::new();\n"
"            file.read_to_string(&mut contents);\n"
"            println!(\"Dear diary: {contents}\");\n"
"        },\n"
"        Err(err) => {\n"
"            println!(\"The diary could not be opened: {err}\");\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"folosi탵i std::fs;\n"
"use std::io::Read;\n"
"\n"
"fn main() {\n"
"    let file = fs::File::open(\"jurnal.txt\");\n"
"    match file {\n"
"        Ok(mut file) => {\n"
"            let mut contents = String::new();\n"
"            file.read_to_string(&mut contents);\n"
"            println!(\"Drag캒 jurnal: {contents}\");\n"
"        },\n"
"        Err(err) => {\n"
"            printlnn!(\"Jurnalul nu a putut fi deschis: {err}\");\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/error-handling/result.md:27
#, fuzzy
msgid ""
"As with `Option`, the successful value sits inside of `Result`, forcing the "
"developer to explicitly extract it. This encourages error checking. In the "
"case where an error should never happen, `unwrap()` or `expect()` can be "
"called, and this is a signal of the developer intent too."
msgstr ""
"Ca 탳i 칥n cazul lui `Option`, valoarea de succes se afl캒 칥n interiorul lui "
"`Result`, oblig칙nd dezvoltatorul s캒 o extrag캒 칥n mod explicit. Acest lucru "
"칥ncurajeaz캒 verificarea erorilor. 칉n cazul 칥n care o eroare nu ar trebui s캒 "
"apar캒 niciodat캒, se poate apela la `unwrap()` sau `expect()`, iar acesta "
"este 탳i el un semnal al inten탵iei dezvoltatorului."

#: src/error-handling/result.md:30
#, fuzzy
msgid ""
"`Result` documentation is a recommended read. Not during the course, but it "
"is worth mentioning.  It contains a lot of convenience methods and functions "
"that help functional-style programming. "
msgstr ""
"documenta탵ia `Result` este o lectur캒 recomandat캒. Nu 칥n timpul cursului, dar "
"merit캒 s캒 fie men탵ionat캒.  Con탵ine o mul탵ime de metode 탳i func탵ii "
"convenabile care ajut캒 la programarea 칥n stil func탵ional."

#: src/error-handling/try-operator.md:1
#, fuzzy
msgid "Propagating Errors with `?`"
msgstr "Propagarea erorilor cu `?`"

#: src/error-handling/try-operator.md:3
#, fuzzy
msgid ""
"The try-operator `?` is used to return errors to the caller. It lets you "
"turn the common"
msgstr ""
"Operatorul \"try\" `?` este utilizat pentru a returna erorile c캒tre apelant. "
"Acesta v캒 permite s캒 transforma탵i op탵iunea comun캒"

#: src/error-handling/try-operator.md:13
#, fuzzy
msgid "into the much simpler"
msgstr "칥n mult mai simplu"

#: src/error-handling/try-operator.md:19
#, fuzzy
msgid "We can use this to simplify our error handling code:"
msgstr ""
"Putem folosi acest lucru pentru a simplifica codul de tratare a erorilor:"

#: src/error-handling/try-operator.md:21
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"\n"
"fn read_username(path: &str) -> Result<String, io::Error> {\n"
"    let username_file_result = fs::File::open(path);\n"
"    let mut username_file = match username_file_result {\n"
"        Ok(file) => file,\n"
"        Err(err) => return Err(err),\n"
"    };\n"
"\n"
"    let mut username = String::new();\n"
"    match username_file.read_to_string(&mut username) {\n"
"        Ok(_) => Ok(username),\n"
"        Err(err) => Err(err),\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"alice\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"username or error: {username:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"folose탳te std::{fs, io};\n"
"use std::io::Read;\n"
"\n"
"fn read_username(path: &str) -> Result<String, io::Error> {\n"
"    let nume_utilizator_fi탳ier_rezultat = fs::File::open(path);\n"
"    let mut username_file = match username_file_result {\n"
"        Ok(file) => file,\n"
"        Err(err) => return Err(err),\n"
"    };\n"
"\n"
"    let mut mut username = String::new();\n"
"    match nume_utilizator_fi탳ier.read_to_string(&mut nume_utilizator) {\n"
"        Ok(_) => Ok(nume utilizator),\n"
"        Err(err) => Err(err),\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"alice\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"username sau eroare: {username:?}\");\n"
"}\n"
"```"

#: src/error-handling/try-operator.md:50
#: src/error-handling/converting-error-types-example.md:52
#, fuzzy
msgid "The `username` variable can be either `Ok(string)` or `Err(error)`."
msgstr "Variabila `username` poate fi fie `Ok(string)`, fie `Err(error)`."

#: src/error-handling/try-operator.md:51
#: src/error-handling/converting-error-types-example.md:53
#, fuzzy
msgid ""
"Use the `fs::write` call to test out the different scenarios: no file, empty "
"file, file with username."
msgstr ""
"Utiliza탵i apelul `fs::write` pentru a testa diferite scenarii: niciun "
"fi탳ier, fi탳ier gol, fi탳ier cu nume de utilizator."

#: src/error-handling/try-operator.md:52
#, fuzzy
msgid ""
"The return type of the function has to be compatible with the nested "
"functions it calls. For instance, a function returning a `Result<T, Err>` "
"can only apply the `?` operator on a function returning a  `Result<AnyT, "
"Err>`. It cannot apply the `?` operator on a function returning an "
"`Option<AnyT>` or `Result<T, OtherErr>` unless `OtherErr` implements "
"`From<Err>`. Reciprocally, a function returning an `Option<T>` can only "
"apply the `?` operator  on a function returning an `Option<AnyT>`."
msgstr ""
"Tipul de retur al func탵iei trebuie s캒 fie compatibil cu func탵iile imbricate "
"pe care le apeleaz캒. De exemplu, o func탵ie care returneaz캒 un `Result<T, "
"Err>` poate aplica operatorul `?` numai unei func탵ii care returneaz캒 un "
"`Result<AnyT, Err>`. Nu poate aplica operatorul `?` unei func탵ii care "
"returneaz캒 o `Op탵iune<AnyT>` sau un `Rezultat<T, OtherErr>`, cu excep탵ia "
"cazului 칥n care `OtherErr` implementeaz캒 `From<Err>`. 칉n mod reciproc, o "
"func탵ie care returneaz캒 o `Option<T>` poate aplica operatorul `?` doar unei "
"func탵ii care returneaz캒 o `Option<AnyT>`."

#: src/error-handling/try-operator.md:57
#, fuzzy
msgid ""
"You can convert incompatible types into one another with the different "
"`Option` and `Result` methods  such as `Option::ok_or`, `Result::ok`, "
"`Result::err`."
msgstr ""
"Pute탵i converti tipuri incompatibile 칥ntre ele cu ajutorul diferitelor "
"metode `Option` 탳i `Result`, cum ar fi `Option::ok_or`, `Result::ok`, "
"`Result::err`."

#: src/error-handling/converting-error-types.md:3
#, fuzzy
msgid ""
"The effective expansion of `?` is a little more complicated than previously "
"indicated:"
msgstr ""
"Extinderea efectiv캒 a lui `?` este pu탵in mai complicat캒 dec칙t s-a ar캒tat "
"anterior:"

#: src/error-handling/converting-error-types.md:9
#, fuzzy
msgid "works the same as"
msgstr "func탵ioneaz캒 la fel ca"

#: src/error-handling/converting-error-types.md:18
#, fuzzy
msgid ""
"The `From::from` call here means we attempt to convert the error type to the "
"type returned by the function."
msgstr ""
"Apelul `From::from` de aici 칥nseamn캒 c캒 칥ncerc캒m s캒 convertim tipul de "
"eroare 칥n tipul returnat de func탵ie."

#: src/error-handling/converting-error-types-example.md:3
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::error::Error;\n"
"use std::fmt::{self, Display, Formatter};\n"
"use std::fs::{self, File};\n"
"use std::io::{self, Read};\n"
"\n"
"#[derive(Debug)]\n"
"enum ReadUsernameError {\n"
"    IoError(io::Error),\n"
"    EmptyUsername(String),\n"
"}\n"
"\n"
"impl Error for ReadUsernameError {}\n"
"\n"
"impl Display for ReadUsernameError {\n"
"    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n"
"        match self {\n"
"            Self::IoError(e) => write!(f, \"IO error: {e}\"),\n"
"            Self::EmptyUsername(filename) => write!(f, \"Found no username "
"in {filename}\"),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl From<io::Error> for ReadUsernameError {\n"
"    fn from(err: io::Error) -> ReadUsernameError {\n"
"        ReadUsernameError::IoError(err)\n"
"    }\n"
"}\n"
"\n"
"fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
"    let mut username = String::with_capacity(100);\n"
"    File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(ReadUsernameError::EmptyUsername(String::from(path)));\n"
"    }\n"
"    Ok(username)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"username or error: {username:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"use std::error::Error;\n"
"use std::fmt::{self, Display, Formatter};\n"
"use std::fs::{self, File};\n"
"use std::io::{self, Read};\n"
"\n"
"#[derive(Debug)]\n"
"enum ReadUsernameError {\n"
"    IoError(io::Error),\n"
"    EmptyUsername(String),\n"
"}\n"
"\n"
"impl Error pentru ReadUsernameError {}\n"
"\n"
"impl Display pentru ReadUsernameError {\n"
"    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {\n"
"        match self {\n"
"            Self::IoError(e) =&gt; write!(f, \"IO error: {e}\"),\n"
"            Self::EmptyUsername(filename) =&gt; write!(f, \"Nu am g캒sit "
"niciun nume de utilizator 칥n {filename}\"),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl De la<io::Error> pentru ReadUsernameError {\n"
"    fn from(err: io::Error) -&gt; ReadUsernameError {\n"
"        ReadUsernameError::IoError(err)\n"
"    }\n"
"}\n"
"\n"
"fn read_username(path: &amp;str) -&gt; Result<String, ReadUsernameError> {\n"
"    let mut username = String::with_capacity(100);\n"
"    File::open(path)?.read_to_string(&amp;mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(ReadUsernameError::EmptyUsername(String::from(path))));\n"
"    }\n"
"    Ok(nume utilizator)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"username sau eroare: {username:?}\");\n"
"}\n"
"```"

#: src/error-handling/converting-error-types-example.md:55
#, fuzzy
msgid ""
"It is good practice for all error types that don't need to be `no_std` to "
"implement `std::error::Error`, which requires `Debug` and `Display`. The "
"`Error` crate for `core` is only available in [nightly](https://github.com/"
"rust-lang/rust/issues/103765), so not fully `no_std` compatible yet."
msgstr ""
"Este o bun캒 practic캒 pentru toate tipurile de erori care nu trebuie s캒 fie "
"`no_std` s캒 implementeze `std::error::Error`, care necesit캒 `Debug` 탳i "
"`Display`. Cr캒iasa `Error` pentru `core` este disponibil캒 doar 칥n [nightly]"
"(https://github.com/rust-lang/rust/issues/103765), deci nu este 칥nc캒 pe "
"deplin compatibil캒 cu `no_std`."

#: src/error-handling/converting-error-types-example.md:57
#, fuzzy
msgid ""
"It's generally helpful for them to implement `Clone` and `Eq` too where "
"possible, to make life easier for tests and consumers of your library. In "
"this case we can't easily do so, because `io::Error` doesn't implement them."
msgstr ""
"칉n general, este util ca acestea s캒 implementeze 탳i `Clone` 탳i `Eq`, acolo "
"unde este posibil, pentru a face via탵a mai u탳oar캒 pentru testele 탳i "
"consumatorii bibliotecii dumneavoastr캒. 칉n acest caz, nu putem face acest "
"lucru cu u탳urin탵캒, deoarece `io::Error` nu le implementeaz캒."

#: src/error-handling/deriving-error-enums.md:3
#, fuzzy
msgid ""
"The [thiserror](https://docs.rs/thiserror/) crate is a popular way to create "
"an error enum like we did on the previous page:"
msgstr ""
"Cr캒iasa [thiserror](https://docs.rs/thiserror/) este o modalitate popular캒 "
"de a crea o enumera탵ie a erorilor, a탳a cum am f캒cut pe pagina anterioar캒:"

#: src/error-handling/deriving-error-enums.md:6
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use thiserror::Error;\n"
"\n"
"#[derive(Debug, Error)]\n"
"enum ReadUsernameError {\n"
"    #[error(\"Could not read: {0}\")]\n"
"    IoError(#[from] io::Error),\n"
"    #[error(\"Found no username in {0}\")]\n"
"    EmptyUsername(String),\n"
"}\n"
"\n"
"fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
"    let mut username = String::new();\n"
"    fs::File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(ReadUsernameError::EmptyUsername(String::from(path)));\n"
"    }\n"
"    Ok(username)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use thiserror::Error;\n"
"\n"
"#[derive(Debug, Error)]\n"
"enum ReadUsernameError {\n"
"    #[error(\"Nu s-a putut citi: {0}\")]\n"
"    IoError(#[din] io::Error),\n"
"    #[error(\"Nu s-a g캒sit niciun nume de utilizator 칥n {0}\")]]\n"
"    EmptyUsername(String),\n"
"}\n"
"\n"
"fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
"    let mut username = String::new();\n"
"    fs::File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(ReadUsernameError::EmptyUsername(String::from(path))));\n"
"    }\n"
"    Ok(nume utilizator)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(nume utilizator) => println!(\"Nume utilizator: {username}\"),\n"
"        Err(err) => println!(\"Eroare: {err}\"),\n"
"    }\n"
"}\n"
"```"

#: src/error-handling/deriving-error-enums.md:39
#, fuzzy
msgid ""
"`thiserror`'s derive macro automatically implements `std::error::Error`, and "
"optionally `Display` (if the `#[error(...)]` attributes are provided) and "
"`From` (if the `#[from]` attribute is added). It also works for structs."
msgstr ""
"macroul derive al lui `thiserror` implementeaz캒 automat `std::error::Error` "
"탳i, op탵ional, `Display` (dac캒 sunt furnizate atributele `#[error(...)]`) 탳i "
"`From` (dac캒 este ad캒ugat atributul `#[from]`). Func탵ioneaz캒, de asemenea, "
"pentru structuri."

#: src/error-handling/deriving-error-enums.md:43
#, fuzzy
msgid "It doesn't affect your public API, which makes it good for libraries."
msgstr "Nu v캒 afecteaz캒 API-ul public, ceea ce 칥l face bun pentru biblioteci."

#: src/error-handling/dynamic-errors.md:3
#, fuzzy
msgid ""
"Sometimes we want to allow any type of error to be returned without writing "
"our own enum covering all the different possibilities. `std::error::Error` "
"makes this easy."
msgstr ""
"Uneori dorim s캒 permitem returnarea oric캒rui tip de eroare f캒r캒 a scrie "
"propriul nostru enum care s캒 acopere toate posibilit캒탵ile diferite. `std::"
"error::Error` faciliteaz캒 acest lucru."

#: src/error-handling/dynamic-errors.md:6
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"use std::fs;\n"
"use std::io::Read;\n"
"use thiserror::Error;\n"
"use std::error::Error;\n"
"\n"
"#[derive(Clone, Debug, Eq, Error, PartialEq)]\n"
"#[error(\"Found no username in {0}\")]\n"
"struct EmptyUsernameError(String);\n"
"\n"
"fn read_username(path: &str) -> Result<String, Box<dyn Error>> {\n"
"    let mut username = String::new();\n"
"    fs::File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(EmptyUsernameError(String::from(path)).into());\n"
"    }\n"
"    Ok(username)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"folosi탵i std::fs;\n"
"use std::io::Read;\n"
"use thiserror::Error;\n"
"use std::error::Error;\n"
"\n"
"#[derive(Clone, Debug, Eq, Error, PartialEq)]]\n"
"#[error(\"Nu am g캒sit niciun nume de utilizator 칥n {0}\")]\n"
"struct EmptyUsernameError(String);\n"
"\n"
"fn read_username(path: &amp;str) -&gt; Result&lt;String, Box<dyn Error>&gt; "
"{\n"
"    let mut username = String::new();\n"
"    fs::File::open(path)?.read_to_string(&amp;mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(EmptyUsernameError(String::from(path)).into()));\n"
"    }\n"
"    Ok(nume utilizator)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(nume utilizator) =&gt; println!(\"Nume utilizator: "
"{username}\"),\n"
"        Err(err) =&gt; println!(\"Eroare: {err}\"),\n"
"    }\n"
"}\n"
"```"

#: src/error-handling/dynamic-errors.md:36
#, fuzzy
msgid ""
"This saves on code, but gives up the ability to cleanly handle different "
"error cases differently in the program. As such it's generally not a good "
"idea to use `Box<dyn Error>` in the public API of a library, but it can be a "
"good option in a program where you just want to display the error message "
"somewhere."
msgstr ""
"Acest lucru economise탳te cod, dar renun탵캒 la capacitatea de a trata 칥n mod "
"curat diferite cazuri de eroare 칥n mod diferit 칥n program. Ca atare, 칥n "
"general nu este o idee bun캒 s캒 folosi탵i `Box<dyn Error>` 칥n API-ul public al "
"unei biblioteci, dar poate fi o op탵iune bun캒 칥ntr-un program 칥n care dori탵i "
"doar s캒 afi탳a탵i mesajul de eroare undeva."

#: src/error-handling/error-contexts.md:3
#, fuzzy
msgid ""
"The widely used [anyhow](https://docs.rs/anyhow/) crate can help you add "
"contextual information to your errors and allows you to have fewer custom "
"error types:"
msgstr ""
"Cr캒iasa [anyhow](https://docs.rs/anyhow/), utilizat캒 pe scar캒 larg캒, v캒 "
"poate ajuta s캒 ad캒uga탵i informa탵ii contextuale la erori 탳i v캒 permite s캒 "
"ave탵i mai pu탵ine tipuri de erori personalizate:"

#: src/error-handling/error-contexts.md:7
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use anyhow::{Context, Result, bail};\n"
"\n"
"fn read_username(path: &str) -> Result<String> {\n"
"    let mut username = String::with_capacity(100);\n"
"    fs::File::open(path)\n"
"        .with_context(|| format!(\"Failed to open {path}\"))?\n"
"        .read_to_string(&mut username)\n"
"        .context(\"Failed to read\")?;\n"
"    if username.is_empty() {\n"
"        bail!(\"Found no username in {path}\");\n"
"    }\n"
"    Ok(username)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err:?}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use anyhow::{Context, Result, bail};\n"
"\n"
"fn read_username(path: &amp;str) -&gt; Result<String> {\n"
"    let mut username = String::with_capacity(100);\n"
"    fs::File::open(path)\n"
"        .with_context(|| format!(\"Failed to open {path}\")))??\n"
"        .read_to_string(&amp;mut username)\n"
"        .context(\"Nu s-a reu탳it citirea\")?;\n"
"    if username.is_empty() {\n"
"        bail!(\"Nu s-a g캒sit niciun nume de utilizator 칥n {path}\");\n"
"    }\n"
"    Ok(username)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(nume utilizator) =&gt; println!(\"Nume utilizator: "
"{username}\"),\n"
"        Err(err) =&gt; println!(\"Eroare: {err:?}\"),\n"
"    }\n"
"}\n"
"```"

#: src/error-handling/error-contexts.md:35
#, fuzzy
msgid "`anyhow::Result<V>` is a type alias for `Result<V, anyhow::Error>`."
msgstr ""
"`anyhow::Result<V>` este un alias de tip pentru `Result<V, anyhow::Error>`."

#: src/error-handling/error-contexts.md:36
#, fuzzy
msgid ""
"`anyhow::Error` is essentially a wrapper around `Box<dyn Error>`. As such "
"it's again generally not a good choice for the public API of a library, but "
"is widely used in applications."
msgstr ""
"`anyhow::Error` este 칥n esen탵캒 un 칥nveli탳 칥n jurul lui `Box<dyn Error>`. Ca "
"atare, 칥n general, nu este o alegere bun캒 pentru API-ul public al unei "
"biblioteci, dar este utilizat pe scar캒 larg캒 칥n aplica탵ii."

#: src/error-handling/error-contexts.md:38
#, fuzzy
msgid ""
"Actual error type inside of it can be extracted for examination if necessary."
msgstr ""
"Tipul real de eroare din interiorul acestuia poate fi extras pentru "
"examinare, dac캒 este necesar."

#: src/error-handling/error-contexts.md:39
#, fuzzy
msgid ""
"Functionality provided by `anyhow::Result<T>` may be familiar to Go "
"developers, as it provides similar usage patterns and ergonomics to `(T, "
"error)` from Go."
msgstr ""
"Func탵ionalitatea oferit캒 de `anyhow::Result<T>` poate fi cunoscut캒 "
"dezvoltatorilor Go, deoarece ofer캒 modele de utilizare 탳i ergonomie similare "
"cu `(T, error)` din Go."

#: src/testing.md:3
#, fuzzy
msgid "Rust and Cargo come with a simple unit test framework:"
msgstr "Rust 탳i Cargo vin cu un cadru simplu de testare a unit캒탵ilor:"

#: src/testing.md:5
#, fuzzy
msgid "Unit tests are supported throughout your code."
msgstr "Testele unitare sunt acceptate 칥n tot codul dumneavoastr캒."

#: src/testing.md:7
#, fuzzy
msgid "Integration tests are supported via the `tests/` directory."
msgstr ""
"Testele de integrare sunt suportate prin intermediul directorului `tests/`."

#: src/testing/unit-tests.md:3
#, fuzzy
msgid "Mark unit tests with `#[test]`:"
msgstr "Marca탵i testele unitare cu `#[test]`:"

#: src/testing/unit-tests.md:5
#, fuzzy
msgid ""
"```rust,editable,ignore\n"
"fn first_word(text: &str) -> &str {\n"
"    match text.find(' ') {\n"
"        Some(idx) => &text[..idx],\n"
"        None => &text,\n"
"    }\n"
"}\n"
"\n"
"#[test]\n"
"fn test_empty() {\n"
"    assert_eq!(first_word(\"\"), \"\");\n"
"}\n"
"\n"
"#[test]\n"
"fn test_single_word() {\n"
"    assert_eq!(first_word(\"Hello\"), \"Hello\");\n"
"}\n"
"\n"
"#[test]\n"
"fn test_multiple_words() {\n"
"    assert_eq!(first_word(\"Hello World\"), \"Hello\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable,ignore\n"
"fn first_word(text: &str) -> &str {\n"
"    match text.find(' ' ') {\n"
"        Some(idx) => &text[..idx],\n"
"        None => &text,\n"
"    }\n"
"}\n"
"\n"
"#[test]\n"
"fn test_empty() {\n"
"    assert_eq!(first_word(\"\"), \"\");\n"
"}\n"
"\n"
"#[test]\n"
"fn test_single_word() {\n"
"    assert_eq!(first_word(\"Hello\"), \"Hello\");\n"
"}\n"
"\n"
"#[test]\n"
"fn test_multiple_words() {\n"
"    assert_eq!(first_word(\"Hello World\"), \"Hello\");\n"
"}\n"
"```"

#: src/testing/unit-tests.md:29
#, fuzzy
msgid "Use `cargo test` to find and run the unit tests."
msgstr "Utiliza탵i `cargo test` pentru a g캒si 탳i a rula testele unitare."

#: src/testing/test-modules.md:3
#, fuzzy
msgid ""
"Unit tests are often put in a nested module (run tests on the [Playground]"
"(https://play.rust-lang.org/)):"
msgstr ""
"Testele unitare sunt adesea plasate 칥ntr-un modul imbricate (executa탵i "
"testele pe [Playground](https://play.rust-lang.org/)):"

#: src/testing/test-modules.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn helper(a: &str, b: &str) -> String {\n"
"    format!(\"{a} {b}\")\n"
"}\n"
"\n"
"pub fn main() {\n"
"    println!(\"{}\", helper(\"Hello\", \"World\"));\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    #[test]\n"
"    fn test_helper() {\n"
"        assert_eq!(helper(\"foo\", \"bar\"), \"foo bar\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn helper(a: &str, b: &str) -> String {\n"
"    format!(\"{a} {b}\")\n"
"}\n"
"\n"
"pub fn main() {\n"
"    println!(\"{}\", helper(\"Hello\", \"World\"));\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    #[test]\n"
"    fn test_helper() {\n"
"        assert_eq!(helper(\"foo\", \"bar\"), \"foo bar\");\n"
"    }\n"
"}\n"
"```"

#: src/testing/test-modules.md:26
#, fuzzy
msgid "This lets you unit test private helpers."
msgstr "Acest lucru v캒 permite s캒 testa탵i unitar ajutoarele private."

#: src/testing/test-modules.md:27
#, fuzzy
msgid "The `#[cfg(test)]` attribute is only active when you run `cargo test`."
msgstr ""
"Atributul `#[cfg(test)]` este activ numai atunci c칙nd executa탵i `cargo test`."

#: src/testing/doc-tests.md:3
#, fuzzy
msgid "Rust has built-in support for documentation tests:"
msgstr "Rust are un suport 칥ncorporat pentru testele de documentare:"

#: src/testing/doc-tests.md:5
#, fuzzy
msgid ""
"```rust\n"
"/// Shortens a string to the given length.\n"
"///\n"
"/// ```\n"
"/// # use playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"
"pub fn shorten_string(s: &str, length: usize) -> &str {\n"
"    &s[..std::cmp::min(length, s.len())]\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"/// Scurteaz캒 un 탳ir de caractere la lungimea dat캒.\n"
"///\n"
"/// ```\n"
"/// # folose탳te playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"
"pub fn shorten_string(s: &str, length: usize) -> &str {\n"
"    &s[..std::cmp::min(length, s.len())]]\n"
"}\n"
"```"

#: src/testing/doc-tests.md:18
#, fuzzy
msgid "Code blocks in `///` comments are automatically seen as Rust code."
msgstr ""
"Blocurile de cod din comentariile `///` sunt considerate automat ca fiind "
"cod Rust."

#: src/testing/doc-tests.md:19
#, fuzzy
msgid "The code will be compiled and executed as part of `cargo test`."
msgstr "Codul va fi compilat 탳i executat ca parte din `cargo test`."

#: src/testing/doc-tests.md:20
#, fuzzy
msgid ""
"Adding `# ` in the code will hide it from the docs, but will still compile/"
"run it."
msgstr ""
"Ad캒ugarea lui `# ` 칥n cod 칥l va ascunde din documenta탵ie, dar 칥l va compila/"
"executa 칥n continuare."

#: src/testing/doc-tests.md:21
#, fuzzy
msgid ""
"Test the above code on the [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."
msgstr ""
"Testa탵i codul de mai sus pe [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."

#: src/testing/integration-tests.md:3
#, fuzzy
msgid "If you want to test your library as a client, use an integration test."
msgstr ""
"Dac캒 dori탵i s캒 v캒 testa탵i biblioteca ca 탳i client, utiliza탵i un test de "
"integrare."

#: src/testing/integration-tests.md:5
#, fuzzy
msgid "Create a `.rs` file under `tests/`:"
msgstr "Crea탵i un fi탳ier `.rs` 칥n `tests/`:"

#: src/testing/integration-tests.md:16
#, fuzzy
msgid "These tests only have access to the public API of your crate."
msgstr "Aceste teste au acces numai la API-ul public al seriei dumneavoastr캒."

#: src/testing/useful-crates.md:1
#, fuzzy
msgid "Useful crates for writing tests"
msgstr "Crates utile pentru scrierea de teste"

#: src/testing/useful-crates.md:3
#, fuzzy
msgid "Rust comes with only basic support for writing tests."
msgstr "Rust vine doar cu un suport de baz캒 pentru scrierea de teste."

#: src/testing/useful-crates.md:5
#, fuzzy
msgid "Here are some additional crates which we recommend for writing tests:"
msgstr ""
"Iat캒 c칙teva crates suplimentare pe care le recomand캒m pentru scrierea de "
"teste:"

#: src/testing/useful-crates.md:7
#, fuzzy
msgid ""
"[googletest](https://docs.rs/googletest): Comprehensive test assertion "
"library in the tradition of GoogleTest for C++."
msgstr ""
"[googletest](https://docs.rs/googletest): Bibliotec캒 cuprinz캒toare de "
"testare a afirma탵iilor de testare 칥n tradi탵ia GoogleTest pentru C++."

#: src/testing/useful-crates.md:8
#, fuzzy
msgid "[proptest](https://docs.rs/proptest): Property-based testing for Rust."
msgstr ""
"[proptest](https://docs.rs/proptest): Testarea bazat캒 pe propriet캒탵i pentru "
"Rust."

#: src/testing/useful-crates.md:9
#, fuzzy
msgid ""
"[rstest](https://docs.rs/rstest): Support for fixtures and parameterised "
"tests."
msgstr ""
"[rstest](https://docs.rs/rstest): Suport pentru testele de tip fixtures 탳i "
"teste parametrizate."

#: src/unsafe.md:3
#, fuzzy
msgid "The Rust language has two parts:"
msgstr "Limbajul Rust are dou캒 p캒r탵i:"

#: src/unsafe.md:5
#, fuzzy
msgid "**Safe Rust:** memory safe, no undefined behavior possible."
msgstr "**Safe Rust:** sigur 칥n memorie, f캒r캒 comportament nedefinit posibil."

#: src/unsafe.md:6
#, fuzzy
msgid ""
"**Unsafe Rust:** can trigger undefined behavior if preconditions are "
"violated."
msgstr ""
"**Unsafe Rust:** poate declan탳a un comportament nedefinit dac캒 sunt "
"칥nc캒lcate condi탵iile prealabile."

#: src/unsafe.md:8
#, fuzzy
msgid ""
"We will be seeing mostly safe Rust in this course, but it's important to "
"know what Unsafe Rust is."
msgstr ""
"칉n acest curs vom vedea mai ales Rust sigur, dar este important s캒 탳tim ce "
"este Rust nesigur."

#: src/unsafe.md:11
#, fuzzy
msgid ""
"Unsafe code is usually small and isolated, and its correctness should be "
"carefully documented. It is usually wrapped in a safe abstraction layer."
msgstr ""
"Codul nesigur este, de obicei, mic 탳i izolat, iar corectitudinea sa trebuie "
"documentat캒 cu aten탵ie. Acesta este de obicei acoperit de un strat de "
"abstractizare sigur."

#: src/unsafe.md:14
#, fuzzy
msgid "Unsafe Rust gives you access to five new capabilities:"
msgstr "Unsafe Rust v캒 ofer캒 acces la cinci noi capacit캒탵i:"

#: src/unsafe.md:16
#, fuzzy
msgid "Dereference raw pointers."
msgstr "Dereferen탵ierea indicatoarelor brute."

#: src/unsafe.md:17
#, fuzzy
msgid "Access or modify mutable static variables."
msgstr "Accesarea sau modificarea variabilelor statice mutabile."

#: src/unsafe.md:18
#, fuzzy
msgid "Access `union` fields."
msgstr "Accesa탵i c칙mpurile `union`."

#: src/unsafe.md:19
#, fuzzy
msgid "Call `unsafe` functions, including `extern` functions."
msgstr "Apelarea func탵iilor `unsafe`, inclusiv a func탵iilor `extern`."

#: src/unsafe.md:20
#, fuzzy
msgid "Implement `unsafe` traits."
msgstr "Implementarea tr캒s캒turilor `unsafe`."

#: src/unsafe.md:22
#, fuzzy
msgid ""
"We will briefly cover unsafe capabilities next. For full details, please see "
"[Chapter 19.1 in the Rust Book](https://doc.rust-lang.org/book/ch19-01-"
"unsafe-rust.html) and the [Rustonomicon](https://doc.rust-lang.org/nomicon/)."
msgstr ""
"칉n continuare vom aborda pe scurt capacit캒탵ile nesigure. Pentru detalii "
"complete, v캒 rug캒m s캒 consulta탵i [Capitolul 19.1 din Rust Book](https://doc."
"rust-lang.org/book/ch19-01-unsafe-rust.html) 탳i [Rustonomicon](https://doc."
"rust-lang.org/nomicon/)."

#: src/unsafe.md:28
#, fuzzy
msgid ""
"Unsafe Rust does not mean the code is incorrect. It means that developers "
"have turned off the compiler safety features and have to write correct code "
"by themselves. It means the compiler no longer enforces Rust's memory-safety "
"rules."
msgstr ""
"Unsafe Rust nu 칥nseamn캒 c캒 codul este incorect. 칉nseamn캒 c캒 dezvoltatorii au "
"dezactivat caracteristicile de siguran탵캒 ale compilatorului 탳i trebuie s캒 "
"scrie singuri codul corect. 칉nseamn캒 c캒 compilatorul nu mai aplic캒 regulile "
"de siguran탵캒 a memoriei din Rust."

#: src/unsafe/raw-pointers.md:3
#, fuzzy
msgid "Creating pointers is safe, but dereferencing them requires `unsafe`:"
msgstr ""
"Crearea de pointeri este sigur캒, dar dereferen탵ierea lor necesit캒 `unsafe`:"

#: src/unsafe/raw-pointers.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut num = 5;\n"
"\n"
"    let r1 = &mut num as *mut i32;\n"
"    let r2 = r1 as *const i32;\n"
"\n"
"    // Safe because r1 and r2 were obtained from references and so are\n"
"    // guaranteed to be non-null and properly aligned, the objects "
"underlying\n"
"    // the references from which they were obtained are live throughout the\n"
"    // whole unsafe block, and they are not accessed either through the\n"
"    // references or concurrently through any other pointers.\n"
"    unsafe {\n"
"        println!(\"r1 is: {}\", *r1);\n"
"        *r1 = 10;\n"
"        println!(\"r2 is: {}\", *r2);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    let mut num = 5;\n"
"\n"
"    let r1 = &mut num as *mut i32;\n"
"    let r2 = r1 as *const i32;\n"
"\n"
"    // Sigur, deoarece r1 탳i r2 au fost ob탵inute din referin탵e 탳i deci sunt\n"
"    // garantate ca fiind non-null 탳i aliniate corespunz캒tor, obiectele care "
"stau la baza lor\n"
"    // referin탵ele din care au fost ob탵inute sunt vii pe tot parcursul\n"
"    // 칥ntregul bloc nesigur, 탳i nu sunt accesate nici prin intermediul "
"blocului\n"
"    // referin탵e, nici 칥n acela탳i timp prin intermediul altor pointeri.\n"
"    unsafe {\n"
"        println!(\"r1 este: {}\", *r1);\n"
"        *r1 = 10;\n"
"        println!(\"r2 este: {}\", *r2);\n"
"    }\n"
"}\n"
"```"

#: src/unsafe/raw-pointers.md:27
#, fuzzy
msgid ""
"It is good practice (and required by the Android Rust style guide) to write "
"a comment for each `unsafe` block explaining how the code inside it "
"satisfies the safety requirements of the unsafe operations it is doing."
msgstr ""
"Este o bun캒 practic캒 (탳i este cerut캒 de ghidul de stil Android Rust) s캒 "
"scrie탵i un comentariu pentru fiecare bloc `unsafe`, explic칙nd modul 칥n care "
"codul din interiorul acestuia 칥ndepline탳te cerin탵ele de siguran탵캒 ale "
"opera탵iilor nesigure pe care le efectueaz캒."

#: src/unsafe/raw-pointers.md:31
#, fuzzy
msgid ""
"In the case of pointer dereferences, this means that the pointers must be "
"[_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), i.e.:"
msgstr ""
"칉n cazul dereferen탵ierii pointerilor, aceasta 칥nseamn캒 c캒 pointerii trebuie "
"s캒 fie [_valabili_](https://doc.rust-lang.org/std/ptr/index.html#safety), "
"adic캒:"

#: src/unsafe/raw-pointers.md:34
#, fuzzy
msgid "The pointer must be non-null."
msgstr "Pointerul trebuie s캒 nu fie nul."

#: src/unsafe/raw-pointers.md:35
#, fuzzy
msgid ""
"The pointer must be _dereferenceable_ (within the bounds of a single "
"allocated object)."
msgstr ""
"Pointerul trebuie s캒 fie _dereferen탵iabil_ (칥n limitele unui singur obiect "
"alocat)."

#: src/unsafe/raw-pointers.md:36
#, fuzzy
msgid "The object must not have been deallocated."
msgstr "Obiectul nu trebuie s캒 fi fost dezalocat."

#: src/unsafe/raw-pointers.md:37
#, fuzzy
msgid "There must not be concurrent accesses to the same location."
msgstr "Nu trebuie s캒 existe accese simultane la aceea탳i loca탵ie."

#: src/unsafe/raw-pointers.md:38
#, fuzzy
msgid ""
"If the pointer was obtained by casting a reference, the underlying object "
"must be live and no reference may be used to access the memory."
msgstr ""
"칉n cazul 칥n care pointerul a fost ob탵inut prin turnarea unei referin탵e, "
"obiectul subiacent trebuie s캒 fie viu 탳i nu se poate utiliza nicio referin탵캒 "
"pentru a accesa memoria."

#: src/unsafe/raw-pointers.md:41
#, fuzzy
msgid "In most cases the pointer must also be properly aligned."
msgstr ""
"칉n cele mai multe cazuri, indicatorul trebuie, de asemenea, s캒 fie bine "
"aliniat."

#: src/unsafe/mutable-static-variables.md:3
#, fuzzy
msgid "It is safe to read an immutable static variable:"
msgstr "Este sigur s캒 citi탵i o variabil캒 static캒 imuabil캒:"

#: src/unsafe/mutable-static-variables.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"static HELLO_WORLD: &str = \"Hello, world!\";\n"
"\n"
"fn main() {\n"
"    println!(\"HELLO_WORLD: {HELLO_WORLD}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"static HELLO_WORLD: &str = \"Hello, world!\";\n"
"\n"
"fn main() {\n"
"    println!(\"HELLO_WORLD: {HELLO_WORLD}\");\n"
"}\n"
"```"

#: src/unsafe/mutable-static-variables.md:13
#, fuzzy
msgid ""
"However, since data races can occur, it is unsafe to read and write mutable "
"static variables:"
msgstr ""
"Cu toate acestea, deoarece pot ap캒rea curse de date, nu este sigur s캒 se "
"citeasc캒 탳i s캒 se scrie variabilele statice mutabile:"

#: src/unsafe/mutable-static-variables.md:16
#, fuzzy
msgid ""
"```rust,editable\n"
"static mut COUNTER: u32 = 0;\n"
"\n"
"fn add_to_counter(inc: u32) {\n"
"    unsafe { COUNTER += inc; }  // Potential data race!\n"
"}\n"
"\n"
"fn main() {\n"
"    add_to_counter(42);\n"
"\n"
"    unsafe { println!(\"COUNTER: {COUNTER}\"); }  // Potential data race!\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"static mut COUNTER: u32 = 0;\n"
"\n"
"fn add_to_counter(inc: u32) {\n"
"    unsafe { COUNTER += inc; }  // Poten탵ial캒 curs캒 de date!\n"
"}\n"
"\n"
"fn main() {\n"
"    add_to_counter(42);\n"
"\n"
"    unsafe { println!(\"COUNTER: {COUNTER}\"); }  // Poten탵ial캒 curs캒 de "
"date!\n"
"}\n"
"```"

#: src/unsafe/mutable-static-variables.md:32
#, fuzzy
msgid ""
"The program here is safe because it is single-threaded. However, the Rust "
"compiler is conservative and will assume the worst. Try removing the "
"`unsafe` and see how the compiler explains that it is undefined behavior to "
"mutate a static from multiple threads."
msgstr ""
"Programul de aici este sigur, deoarece are un singur fir de execu탵ie. Cu "
"toate acestea, compilatorul Rust este conservator 탳i va presupune ce este "
"mai r캒u. 칉ncerca탵i s캒 elimina탵i `unsafe` 탳i s캒 vede탵i cum compilatorul "
"explic캒 faptul c캒 este un comportament nedefinit s캒 muta탵i o static캒 din mai "
"multe fire de execu탵ie."

#: src/unsafe/mutable-static-variables.md:36
#, fuzzy
msgid ""
"Using a mutable static is generally a bad idea, but there are some cases "
"where it might make sense in low-level `no_std` code, such as implementing a "
"heap allocator or working with some C APIs."
msgstr ""
"Utilizarea unui static mutabil este, 칥n general, o idee proast캒, dar exist캒 "
"unele cazuri 칥n care ar putea avea sens 칥n codul `no_std` de nivel sc캒zut, "
"cum ar fi implementarea unui alocator de heap sau lucrul cu unele API-uri C."

#: src/unsafe/unions.md:3
#, fuzzy
msgid "Unions are like enums, but you need to track the active field yourself:"
msgstr ""
"Uniunile sunt ca 탳i enumera탵iile, dar trebuie s캒 urm캒ri탵i singur c칙mpul "
"activ:"

#: src/unsafe/unions.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"#[repr(C)]\n"
"union MyUnion {\n"
"    i: u8,\n"
"    b: bool,\n"
"}\n"
"\n"
"fn main() {\n"
"    let u = MyUnion { i: 42 };\n"
"    println!(\"int: {}\", unsafe { u.i });\n"
"    println!(\"bool: {}\", unsafe { u.b });  // Undefined behavior!\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"#[repr(C)]\n"
"union MyUnion {\n"
"    i: u8,\n"
"    b: bool,\n"
"}\n"
"\n"
"fn main() {\n"
"    let u = MyUnion { i: 42 };\n"
"    println!(\"int: {}\", unsafe { u.i });\n"
"    printlnn!(\"bool: {}\", unsafe { u.b }); // Comportament nedefinit!\n"
"}\n"
"```"

#: src/unsafe/unions.md:21
#, fuzzy
msgid ""
"Unions are very rarely needed in Rust as you can usually use an enum. They "
"are occasionally needed for interacting with C library APIs."
msgstr ""
"Uniunile sunt foarte rar necesare 칥n Rust, deoarece pute탵i utiliza de obicei "
"un enum. Ele sunt ocazional necesare pentru a interac탵iona cu API-urile "
"bibliotecilor C."

#: src/unsafe/unions.md:24
#, fuzzy
msgid ""
"If you just want to reinterpret bytes as a different type, you probably want "
"[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn."
"transmute.html) or a safe wrapper such as the [`zerocopy`](https://crates.io/"
"crates/zerocopy) crate."
msgstr ""
"Dac캒 dori탵i doar s캒 reinterpreta탵i octe탵ii ca fiind de un tip diferit, "
"probabil c캒 dori탵i [`std::mem::transmute`](https://doc.rust-lang.org/stable/"
"std/mem/fn.transmute.html) sau un 칥nveli탳 sigur, cum ar fi [`zerocopy`]"
"(https://crates.io/crates/zerocopy)."

#: src/unsafe/calling-unsafe-functions.md:3
#, fuzzy
msgid ""
"A function or method can be marked `unsafe` if it has extra preconditions "
"you must uphold to avoid undefined behaviour:"
msgstr ""
"O func탵ie sau o metod캒 poate fi marcat캒 `unsafe` dac캒 are condi탵ii "
"prealabile suplimentare pe care trebuie s캒 le respecta탵i pentru a evita un "
"comportament nedefinit:"

#: src/unsafe/calling-unsafe-functions.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let emojis = \"游딭갣游깶\";\n"
"\n"
"    // Safe because the indices are in the correct order, within the bounds "
"of\n"
"    // the string slice, and lie on UTF-8 sequence boundaries.\n"
"    unsafe {\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(0..4));\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(4..7));\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(7..11));\n"
"    }\n"
"\n"
"    println!(\"char count: {}\", count_chars(unsafe { emojis."
"get_unchecked(0..7) }));\n"
"\n"
"    // Not upholding the UTF-8 encoding requirement breaks memory safety!\n"
"    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
"    // println!(\"char count: {}\", count_chars(unsafe { emojis."
"get_unchecked(0..3) }));\n"
"}\n"
"\n"
"fn count_chars(s: &str) -> usize {\n"
"    s.chars().count()\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    let emojis = \"游딭갣游깶\";\n"
"\n"
"    // Sigur, deoarece indicii sunt 칥n ordinea corect캒, 칥n limitele lui\n"
"    // feliei de 탳ir 탳i se afl캒 pe limitele secven탵ei UTF-8.\n"
"    unsafe {\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(0..4));\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(4..7));\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(7..11));\n"
"    }\n"
"\n"
"    printlnn!(\"char count: {}\", count_chars(unsafe { emojis."
"get_unchecked(0..7) }));\n"
"\n"
"    // Nerespectarea cerin탵ei de codificare UTF-8 칥ncalc캒 siguran탵a "
"memoriei!\n"
"    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
"    // println!(\"char count: {}\", count_chars(unsafe { emojis."
"get_unchecked(0..3) }));\n"
"}\n"
"\n"
"fn count_chars(s: &str) -> usize {\n"
"    s.chars().count()\n"
"}\n"
"```"

#: src/unsafe/writing-unsafe-functions.md:3
#, fuzzy
msgid ""
"You can mark your own functions as `unsafe` if they require particular "
"conditions to avoid undefined behaviour."
msgstr ""
"Pute탵i marca propriile func탵ii ca fiind \"nesigure\" dac캒 acestea necesit캒 "
"anumite condi탵ii pentru a evita un comportament nedefinit."

#: src/unsafe/writing-unsafe-functions.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"/// Swaps the values pointed to by the given pointers.\n"
"///\n"
"/// # Safety\n"
"///\n"
"/// The pointers must be valid and properly aligned.\n"
"unsafe fn swap(a: *mut u8, b: *mut u8) {\n"
"    let temp = *a;\n"
"    *a = *b;\n"
"    *b = temp;\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut a = 42;\n"
"    let mut b = 66;\n"
"\n"
"    // Safe because ...\n"
"    unsafe {\n"
"        swap(&mut a, &mut b);\n"
"    }\n"
"\n"
"    println!(\"a = {}, b = {}\", a, b);\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"/// Schimb캒 valorile indicate de indicatoarele date.\n"
"///\n"
"/// # Siguran탵캒\n"
"///\n"
"/// Punctele trebuie s캒 fie valide 탳i aliniate corespunz캒tor.\n"
"unsafe fn swap(a: *mut u8, b: *mut u8) {\n"
"    let temp = *a;\n"
"    *a = *b;\n"
"    *b = temp;\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut a = 42;\n"
"    let mut b = 66;\n"
"\n"
"    // Sigur, deoarece ...\n"
"    unsafe {\n"
"        swap(&mut a, &mut b);\n"
"    }\n"
"\n"
"    println!(\"a = {}, b = {}\", a, b);\n"
"}\n"
"```"

#: src/unsafe/writing-unsafe-functions.md:33
#, fuzzy
msgid ""
"We wouldn't actually use pointers for this because it can be done safely "
"with references."
msgstr ""
"De fapt, nu vom folosi pointeri pentru acest lucru, deoarece acest lucru "
"poate fi realizat 칥n siguran탵캒 cu referin탵e."

#: src/unsafe/writing-unsafe-functions.md:35
#, fuzzy
msgid ""
"Note that unsafe code is allowed within an unsafe function without an "
"`unsafe` block. We can prohibit this with `#[deny(unsafe_op_in_unsafe_fn)]`. "
"Try adding it and see what happens."
msgstr ""
"Re탵ine탵i c캒 codul nesigur este permis 칥n cadrul unei func탵ii nesigure f캒r캒 "
"un bloc `unsafe`. Putem interzice acest lucru cu "
"`#[deny(unsafe_op_in_unsafe_fn)]`. 칉ncerca탵i s캒-l ad캒uga탵i 탳i vede탵i ce se "
"칥nt칙mpl캒."

#: src/unsafe/extern-functions.md:1
#, fuzzy
msgid "Calling External Code"
msgstr "Apelarea codului extern"

#: src/unsafe/extern-functions.md:3
#, fuzzy
msgid ""
"Functions from other languages might violate the guarantees of Rust. Calling "
"them is thus unsafe:"
msgstr ""
"Func탵iile din alte limbaje ar putea 칥nc캒lca garan탵iile Rust. Prin urmare, "
"apelarea acestora nu este sigur캒:"

#: src/unsafe/extern-functions.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"extern \"C\" {\n"
"    fn abs(input: i32) -> i32;\n"
"}\n"
"\n"
"fn main() {\n"
"    unsafe {\n"
"        // Undefined behavior if abs misbehaves.\n"
"        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"extern \"C\" {\n"
"    fn abs(input: i32) -> i32;\n"
"}\n"
"\n"
"fn main() {\n"
"    unsafe {\n"
"        // Comportament nedefinit dac캒 abs se comport캒 gre탳it.\n"
"        println!(\"Valoarea absolut캒 a lui -3 conform C: {}\", abs(-3));\n"
"    }\n"
"}\n"
"```"

#: src/unsafe/extern-functions.md:21
#, fuzzy
msgid ""
"This is usually only a problem for extern functions which do things with "
"pointers which might violate Rust's memory model, but in general any C "
"function might have undefined behaviour under any arbitrary circumstances."
msgstr ""
"Aceasta este de obicei o problem캒 doar pentru func탵iile externe care fac "
"lucruri cu pointeri care ar putea 칥nc캒lca modelul de memorie Rust, dar 칥n "
"general orice func탵ie C poate avea un comportament nedefinit 칥n orice "
"circumstan탵e arbitrare."

#: src/unsafe/extern-functions.md:25
#, fuzzy
msgid ""
"The `\"C\"` in this example is the ABI; [other ABIs are available too]"
"(https://doc.rust-lang.org/reference/items/external-blocks.html)."
msgstr ""
"칉n acest exemplu, `\"C\"` este ABI; [sunt disponibile 탳i alte ABI-uri]"
"(https://doc.rust-lang.org/reference/items/external-blocks.html)."

#: src/unsafe/unsafe-traits.md:3
#, fuzzy
msgid ""
"Like with functions, you can mark a trait as `unsafe` if the implementation "
"must guarantee particular conditions to avoid undefined behaviour."
msgstr ""
"Ca 탳i 칥n cazul func탵iilor, pute탵i marca o tr캒s캒tur캒 ca fiind \"nesigur캒\" "
"dac캒 implementarea trebuie s캒 garanteze anumite condi탵ii pentru a evita un "
"comportament nedefinit."

#: src/unsafe/unsafe-traits.md:6
#, fuzzy
msgid ""
"For example, the `zerocopy` crate has an unsafe trait that looks [something "
"like this](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html):"
msgstr ""
"De exemplu, categoria `zerocopy` are o tr캒s캒tur캒 nesigur캒 care arat캒 [ceva "
"de genul acesta](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes."
"html):"

#: src/unsafe/unsafe-traits.md:9
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::mem::size_of_val;\n"
"use std::slice;\n"
"\n"
"/// ...\n"
"/// # Safety\n"
"/// The type must have a defined representation and no padding.\n"
"pub unsafe trait AsBytes {\n"
"    fn as_bytes(&self) -> &[u8] {\n"
"        unsafe {\n"
"            slice::from_raw_parts(self as *const Self as *const u8, "
"size_of_val(self))\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Safe because u32 has a defined representation and no padding.\n"
"unsafe impl AsBytes for u32 {}\n"
"```"
msgstr ""
"```rust,editabil\n"
"use std::mem::size_of_val;\n"
"use std::slice;\n"
"\n"
"/// ...\n"
"/// # Siguran탵캒\n"
"/// Tipul trebuie s캒 aib캒 o reprezentare definit캒 탳i s캒 nu aib캒 umplutur캒.\n"
"pub unsafe trait AsBytes {\n"
"    fn as_bytes(&self) -> &[u8] {\n"
"        unsafe {\n"
"            slice::from_raw_parts(self as *const Self as *const u8, "
"size_of_val(self))\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Sigur, deoarece u32 are o reprezentare definit캒 탳i nu are umplutur캒.\n"
"unsafe impl AsBytes pentru u32 {}\n"
"```"

#: src/unsafe/unsafe-traits.md:30
#, fuzzy
msgid ""
"There should be a `# Safety` section on the Rustdoc for the trait explaining "
"the requirements for the trait to be safely implemented."
msgstr ""
"Ar trebui s캒 existe o sec탵iune `# Siguran탵캒` 칥n Rustdoc pentru tr캒s캒tura "
"care s캒 explice cerin탵ele pentru ca tr캒s캒tura s캒 fie implementat캒 칥n "
"siguran탵캒."

#: src/unsafe/unsafe-traits.md:33
#, fuzzy
msgid ""
"The actual safety section for `AsBytes` is rather longer and more "
"complicated."
msgstr ""
"Sec탵iunea de siguran탵캒 efectiv캒 pentru `AsBytes` este mai lung캒 탳i mai "
"complicat캒."

#: src/unsafe/unsafe-traits.md:35
#, fuzzy
msgid "The built-in `Send` and `Sync` traits are unsafe."
msgstr "Tr캒s캒turile 칥ncorporate `Send` 탳i `Sync` sunt nesigure."

#: src/exercises/day-3/afternoon.md:1
#, fuzzy
msgid "Day 3: Afternoon Exercises"
msgstr "Ziua 3: Exerci탵ii dup캒-amiaza"

#: src/exercises/day-3/afternoon.md:3
#, fuzzy
msgid "Let us build a safe wrapper for reading directory content!"
msgstr ""
"Haide탵i s캒 construim un 칥nveli탳 sigur pentru citirea con탵inutului "
"directoarelor!"

#: src/exercises/day-3/afternoon.md:5
#, fuzzy
msgid ""
"For this exercise, we suggest using a local dev environment instead of the "
"Playground. This will allow you to run your binary on your own machine."
msgstr ""
"Pentru acest exerci탵iu, v캒 suger캒m s캒 folosi탵i un mediu de dezvoltare local "
"칥n loc de Playground. Acest lucru v캒 va permite s캒 rula탵i binarul pe propria "
"ma탳in캒."

#: src/exercises/day-3/afternoon.md:8
#, fuzzy
msgid ""
"To get started, follow the [running locally](../../cargo/running-locally.md) "
"instructions."
msgstr ""
"Pentru a 칥ncepe, urma탵i instruc탵iunile [running locally](../../cargo/running-"
"locally.md)."

#: src/exercises/day-3/afternoon.md:14
#, fuzzy
msgid ""
"After looking at the exercise, you can look at the [solution](solutions-"
"afternoon.md) provided."
msgstr ""
"Dup캒 ce a탵i studiat exerci탵iul, v캒 pute탵i uita la [solu탵ie](solutions-"
"afternoon.md) oferit캒."

#: src/exercises/day-3/safe-ffi-wrapper.md:3
#, fuzzy
msgid ""
"Rust has great support for calling functions through a _foreign function "
"interface_ (FFI). We will use this to build a safe wrapper for the `libc` "
"functions you would use from C to read the names of files in a directory."
msgstr ""
"Rust are un suport excelent pentru apelarea func탵iilor prin intermediul unei "
"interfe탵e de func탵ii str캒ine (FFI). Vom folosi acest lucru pentru a construi "
"un 칥nveli탳 sigur pentru func탵iile `libc` pe care le-a탵i folosi din C pentru "
"a citi numele fi탳ierelor dintr-un director."

#: src/exercises/day-3/safe-ffi-wrapper.md:7
#, fuzzy
msgid "You will want to consult the manual pages:"
msgstr "Va trebui s캒 consulta탵i paginile din manual:"

#: src/exercises/day-3/safe-ffi-wrapper.md:9
#, fuzzy
msgid "[`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)"
msgstr "[`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)"

#: src/exercises/day-3/safe-ffi-wrapper.md:10
#, fuzzy
msgid "[`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)"
msgstr "[`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)"

#: src/exercises/day-3/safe-ffi-wrapper.md:11
#, fuzzy
msgid "[`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"
msgstr "[`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"

#: src/exercises/day-3/safe-ffi-wrapper.md:13
#, fuzzy
msgid ""
"You will also want to browse the [`std::ffi`](https://doc.rust-lang.org/std/"
"ffi/) module. There you find a number of string types which you need for the "
"exercise:"
msgstr ""
"De asemenea, ve탵i dori s캒 naviga탵i 칥n modulul [`std::ffi`](https://doc.rust-"
"lang.org/std/ffi/). Acolo ve탵i g캒si o serie de tipuri de 탳iruri de caractere "
"de care ave탵i nevoie pentru exerci탵iu:"

#: src/exercises/day-3/safe-ffi-wrapper.md:16
#, fuzzy
msgid "Encoding"
msgstr "Codificare"

#: src/exercises/day-3/safe-ffi-wrapper.md:16
msgid "Use"
msgstr "Folose탳te"

#: src/exercises/day-3/safe-ffi-wrapper.md:18
#, fuzzy
msgid ""
"[`str`](https://doc.rust-lang.org/std/primitive.str.html) and [`String`]"
"(https://doc.rust-lang.org/std/string/struct.String.html)"
msgstr ""
"[`str`](https://doc.rust-lang.org/std/primitive.str.html) 탳i [`String`]"
"(https://doc.rust-lang.org/std/string/struct.String.html)"

#: src/exercises/day-3/safe-ffi-wrapper.md:18
#, fuzzy
msgid "UTF-8"
msgstr "UTF-8"

#: src/exercises/day-3/safe-ffi-wrapper.md:18
#, fuzzy
msgid "Text processing in Rust"
msgstr "Prelucrarea textului 칥n Rust"

#: src/exercises/day-3/safe-ffi-wrapper.md:19
#, fuzzy
msgid ""
"[`CStr`](https://doc.rust-lang.org/std/ffi/struct.CStr.html) and [`CString`]"
"(https://doc.rust-lang.org/std/ffi/struct.CString.html)"
msgstr ""
"[`CStr`](https://doc.rust-lang.org/std/ffi/struct.CStr.html) 탳i [`CString`]"
"(https://doc.rust-lang.org/std/ffi/struct.CString.html)"

#: src/exercises/day-3/safe-ffi-wrapper.md:19
#, fuzzy
msgid "NUL-terminated"
msgstr "Terminat cu NUL"

#: src/exercises/day-3/safe-ffi-wrapper.md:19
#, fuzzy
msgid "Communicating with C functions"
msgstr "Comunicarea cu func탵iile C"

#: src/exercises/day-3/safe-ffi-wrapper.md:20
#, fuzzy
msgid ""
"[`OsStr`](https://doc.rust-lang.org/std/ffi/struct.OsStr.html) and "
"[`OsString`](https://doc.rust-lang.org/std/ffi/struct.OsString.html)"
msgstr ""
"[`OsStr`](https://doc.rust-lang.org/std/ffi/struct.OsStr.html) 탳i "
"[`OsString`](https://doc.rust-lang.org/std/ffi/struct.OsString.html)"

#: src/exercises/day-3/safe-ffi-wrapper.md:20
#, fuzzy
msgid "OS-specific"
msgstr "Specific sistemului de operare"

#: src/exercises/day-3/safe-ffi-wrapper.md:20
#, fuzzy
msgid "Communicating with the OS"
msgstr "Comunicarea cu sistemul de operare"

#: src/exercises/day-3/safe-ffi-wrapper.md:22
#, fuzzy
msgid "You will convert between all these types:"
msgstr "Ve탵i face conversia 칥ntre toate aceste tipuri:"

#: src/exercises/day-3/safe-ffi-wrapper.md:24
#, fuzzy
msgid ""
"`&str` to `CString`: you need to allocate space for a trailing `\\0` "
"character,"
msgstr ""
"`&str` 칥n `CString`: trebuie s캒 aloca탵i spa탵iu pentru un caracter `\\0` la "
"sf칙r탳it,"

#: src/exercises/day-3/safe-ffi-wrapper.md:25
#, fuzzy
msgid "`CString` to `*const i8`: you need a pointer to call C functions,"
msgstr ""
"`CString` la `*const i8`: ave탵i nevoie de un pointer pentru a apela "
"func탵iile C,"

#: src/exercises/day-3/safe-ffi-wrapper.md:26
#, fuzzy
msgid ""
"`*const i8` to `&CStr`: you need something which can find the trailing `\\0` "
"character,"
msgstr ""
"`*const i8` la `&CStr`: ave탵i nevoie de ceva care s캒 poat캒 g캒si caracterul "
"`\\0` din urm캒,"

#: src/exercises/day-3/safe-ffi-wrapper.md:27
#, fuzzy
msgid ""
"`&CStr` to `&[u8]`: a slice of bytes is the universal interface for \"some "
"unknown data\","
msgstr ""
"`&CStr` la `&[u8]`: o por탵iune de octe탵i este interfa탵a universal캒 pentru "
"\"unele date necunoscute\","

#: src/exercises/day-3/safe-ffi-wrapper.md:28
#, fuzzy
msgid ""
"`&[u8]` to `&OsStr`: `&OsStr` is a step towards `OsString`, use [`OsStrExt`]"
"(https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html) to create it,"
msgstr ""
"`&&[u8]` la `&OsStr`: `&OsStr` este un pas spre `OsString`, utiliza탵i "
"[`OsStrExt`](https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html) "
"pentru a-l crea,"

#: src/exercises/day-3/safe-ffi-wrapper.md:31
#, fuzzy
msgid ""
"`&OsStr` to `OsString`: you need to clone the data in `&OsStr` to be able to "
"return it and call `readdir` again."
msgstr ""
"`&OsStr` 칥n `OsString`: trebuie s캒 clona탵i datele din `&OsStr` pentru a le "
"putea returna 탳i a apela din nou `readdir`."

#: src/exercises/day-3/safe-ffi-wrapper.md:34
#, fuzzy
msgid ""
"The [Nomicon](https://doc.rust-lang.org/nomicon/ffi.html) also has a very "
"useful chapter about FFI."
msgstr ""
"[Nomicon](https://doc.rust-lang.org/nomicon/ffi.html) are, de asemenea, un "
"capitol foarte util despre FFI."

#: src/exercises/day-3/safe-ffi-wrapper.md:45
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing "
"functions and methods:"
msgstr ""
"Copia탵i codul de mai jos 칥n <https://play.rust-lang.org/> 탳i completa탵i "
"func탵iile 탳i metodele care lipsesc:"

#: src/exercises/day-3/safe-ffi-wrapper.md:48
#, fuzzy
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_imports, unused_variables, dead_code)]\n"
"\n"
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int};\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    use std::os::raw::{c_long, c_ulong, c_ushort, c_uchar};\n"
"\n"
"    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
"    #[repr(C)]\n"
"    pub struct DIR {\n"
"        _data: [u8; 0],\n"
"        _marker: core::marker::PhantomData<(*mut u8, core::marker::"
"PhantomPinned)>,\n"
"    }\n"
"\n"
"    // Layout according to the Linux man page for readdir(3), where ino_t "
"and\n"
"    // off_t are resolved according to the definitions in\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_ino: c_ulong,\n"
"        pub d_off: c_long,\n"
"        pub d_reclen: c_ushort,\n"
"        pub d_type: c_uchar,\n"
"        pub d_name: [c_char; 256],\n"
"    }\n"
"\n"
"    // Layout according to the macOS man page for dir(5).\n"
"    #[cfg(all(target_os = \"macos\"))]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_fileno: u64,\n"
"        pub d_seekoff: u64,\n"
"        pub d_reclen: u16,\n"
"        pub d_namlen: u16,\n"
"        pub d_type: u8,\n"
"        pub d_name: [c_char; 1024],\n"
"    }\n"
"\n"
"    extern \"C\" {\n"
"        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
"\n"
"        #[cfg(not(all(target_os = \"macos\", target_arch = \"x86_64\")))]\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"\n"
"        // See https://github.com/rust-lang/libc/issues/414 and the section "
"on\n"
"        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).\n"
"        //\n"
"        // \"Platforms that existed before these updates were available\" "
"refers\n"
"        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and "
"PowerPC.\n"
"        #[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n"
"        #[link_name = \"readdir$INODE64\"]\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"\n"
"        pub fn closedir(s: *mut DIR) -> c_int;\n"
"    }\n"
"}\n"
"\n"
"use std::ffi::{CStr, CString, OsStr, OsString};\n"
"use std::os::unix::ffi::OsStrExt;\n"
"\n"
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}\n"
"\n"
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Keep calling readdir until we get a NULL pointer back.\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Drop for DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Call closedir as needed.\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""
"```rust,should_panic\n"
"// TODO: elimina탵i acest lucru atunci c칙nd a탵i terminat cu implementarea.\n"
"#![allow(unused_imports, unused_variables, dead_code)]]\n"
"\n"
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int};\n"
"    #[cfg(not(target_os = \"macos\"))]]\n"
"    use std::os::raw::{c_long, c_ulong, c_ushort, c_uchar};\n"
"\n"
"    // Tip opac. A se vedea https://doc.rust-lang.org/nomicon/ffi.html.\n"
"    #[repr(C)]\n"
"    pub struct struct DIR {\n"
"        _data: [u8; 0],\n"
"        _marker: core::marker::PhantomData<(*mut u8, core::marker::"
"PhantomPinned)>,\n"
"    }\n"
"\n"
"    // Dispunere 칥n conformitate cu pagina de manual Linux pentru "
"readdir(3), unde ino_t 탳i\n"
"    // off_t sunt rezolvate 칥n conformitate cu defini탵iile din\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"
"    #[cfg(not(target_os = \"macos\"))]]\n"
"    #[repr(C)]\n"
"    pub struct struct dirent {\n"
"        pub d_ino: c_ulong,\n"
"        pub d_off: c_long,\n"
"        pub d_reclen: c_ushort,\n"
"        pub d_type: c_uchar,\n"
"        pub d_name: [c_char; 256],\n"
"    }\n"
"\n"
"    // Dispunere 칥n conformitate cu pagina de manual macOS pentru dir(5).\n"
"    #[cfg(all(target_os = \"macos\"))]]\n"
"    #[repr(C)]\n"
"    pub struct struct dirent {\n"
"        pub d_fileno: u64,\n"
"        pub d_seekoff: u64,\n"
"        pub d_reclen: u16,\n"
"        pub d_namlen: u16,\n"
"        pub d_type: u8,\n"
"        pub d_name: [c_char; 1024],\n"
"    }\n"
"\n"
"    extern \"C\" {\n"
"        pub fn opendir(s: *const c_char) -&gt; *mut DIR;\n"
"\n"
"        #[cfg(not(all(target_os = \"macos\", target_arch = "
"\"x86_64\")))])]]\n"
"        pub fn readdir(s: *mut DIR) -&gt; *const dirent;\n"
"\n"
"        // A se vedea https://github.com/rust-lang/libc/issues/414 탳i "
"sec탵iunea privind\n"
"        // _DARWIN_FEATURE_64_BIT_INODE 칥n pagina de manual macOS pentru "
"stat(2).\n"
"        //\n"
"        // \"Platformele care existau 칥nainte ca aceste actualiz캒ri s캒 fie "
"disponibile\" se refer캒 la\n"
"        // la macOS (spre deosebire de iOS / wearOS / etc.) pe Intel 탳i "
"PowerPC.\n"
"        #[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]]\n"
"        #[link_name = \"readdir$INODE64\"]\n"
"        pub fn readdir(s: *mut DIR) -&gt; *const dirent;\n"
"\n"
"        pub fn closedir(s: *mut DIR) -&gt; c_int;\n"
"    }\n"
"}\n"
"\n"
"use std::ffi::{CStr, CString, OsStr, OsString};\n"
"use std::os::unix::ffi::OsStrExt;\n"
"\n"
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}\n"
"\n"
"impl DirectoryIterator {\n"
"    fn new(path: &amp;str) -&gt; Result<DirectoryIterator, String> {\n"
"        // Apela탵i opendir 탳i returna탵i o valoare Ok dac캒 a func탵ionat,\n"
"        // 칥n caz contrar, returneaz캒 Err cu un mesaj.\n"
"        neimplementat!()\n"
"    }\n"
"}\n"
"\n"
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&amp;mut self) -&gt; Option<OsString> {\n"
"        // Continua탵i s캒 apela탵i readdir p칙n캒 c칙nd primim 칥napoi un pointer "
"NULL.\n"
"        neimplementat!()\n"
"    }\n"
"}\n"
"\n"
"impl Drop for DirectoryIterator {\n"
"    fn drop(&amp;mut self) {\n"
"        // Cheam캒 closedir dup캒 cum este necesar.\n"
"        neimplementat!()\n"
"    }\n"
"}\n"
"\n"
"fn main() -&gt; Rezultat<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"files: {:#?}\", iter.collect::&lt;Vec<_>&gt;());\n"
"    Ok((())\n"
"}\n"
"```"

#: src/android.md:1
#, fuzzy
msgid "Welcome to Rust in Android"
msgstr "Bine a탵i venit la Rust 칥n Android"

#: src/android.md:3
#, fuzzy
msgid ""
"Rust is supported for native platform development on Android. This means "
"that you can write new operating system services in Rust, as well as "
"extending existing services."
msgstr ""
"Rust este acceptat pentru dezvoltarea platformei native pe Android. Acest "
"lucru 칥nseamn캒 c캒 pute탵i scrie noi servicii de sistem de operare 칥n Rust, "
"precum 탳i extinde serviciile existente."

#: src/android.md:7
#, fuzzy
msgid ""
"We will attempt to call Rust from one of your own projects today. So try to "
"find a little corner of your code base where we can move some lines of code "
"to Rust. The fewer dependencies and \"exotic\" types the better. Something "
"that parses some raw bytes would be ideal."
msgstr ""
"Vom 칥ncerca s캒 칥l sun캒m pe Rust de la unul dintre proiectele dumneavoastr캒 "
"ast캒zi. A탳adar, 칥ncerca탵i s캒 g캒si탵i un col탵i탳or din baza dumneavoastr캒 de "
"cod 칥n care s캒 putem muta c칙teva linii de cod 칥n Rust. Cu c칙t mai pu탵ine "
"dependen탵e 탳i tipuri \"exotice\", cu at칙t mai bine. Ceva care analizeaz캒 "
"ni탳te octe탵i brute ar fi ideal."

#: src/android/setup.md:3
#, fuzzy
msgid ""
"We will be using an Android Virtual Device to test our code. Make sure you "
"have access to one or create a new one with:"
msgstr ""
"Vom folosi un dispozitiv virtual Android pentru a testa codul nostru. "
"Asigura탵i-v캒 c캒 ave탵i acces la unul sau crea탵i unul nou cu:"

#: src/android/setup.md:12
#, fuzzy
msgid ""
"Please see the [Android Developer Codelab](https://source.android.com/docs/"
"setup/start) for details."
msgstr ""
"V캒 rug캒m s캒 consulta탵i [Android Developer Codelab](https://source.android."
"com/docs/setup/start) pentru detalii."

#: src/android/build-rules.md:3
#, fuzzy
msgid "The Android build system (Soong) supports Rust via a number of modules:"
msgstr ""
"Sistemul de compilare Android (Soong) accept캒 Rust prin intermediul unui "
"num캒r de module:"

#: src/android/build-rules.md:5
#, fuzzy
msgid "Module Type"
msgstr "Tipul de modul"

#: src/android/build-rules.md:5
msgid "Description"
msgstr "Descriere"

#: src/android/build-rules.md:7
#, fuzzy
msgid "`rust_binary`"
msgstr "`rust_binary`"

#: src/android/build-rules.md:7
#, fuzzy
msgid "Produces a Rust binary."
msgstr "Produce un binar Rust."

#: src/android/build-rules.md:8
#, fuzzy
msgid "`rust_library`"
msgstr "`rust_library`"

#: src/android/build-rules.md:8
#, fuzzy
msgid "Produces a Rust library, and provides both `rlib` and `dylib` variants."
msgstr ""
"Produce o bibliotec캒 Rust 탳i ofer캒 at칙t variantele `rlib`, c칙t 탳i `dylib`."

#: src/android/build-rules.md:9
#, fuzzy
msgid "`rust_ffi`"
msgstr "`rust_ffi`"

#: src/android/build-rules.md:9
#, fuzzy
msgid ""
"Produces a Rust C library usable by `cc` modules, and provides both static "
"and shared variants."
msgstr ""
"Produce o bibliotec캒 Rust C utilizabil캒 de modulele `cc` 탳i ofer캒 at칙t "
"variante statice c칙t 탳i partajate."

#: src/android/build-rules.md:10
#, fuzzy
msgid "`rust_proc_macro`"
msgstr "`rust_proc_macro`"

#: src/android/build-rules.md:10
#, fuzzy
msgid ""
"Produces a `proc-macro` Rust library. These are analogous to compiler "
"plugins."
msgstr ""
"Produce o bibliotec캒 Rust `proc-macro`. Acestea sunt analoge cu plugin-urile "
"de compilator."

#: src/android/build-rules.md:11
#, fuzzy
msgid "`rust_test`"
msgstr "`rust_test`"

#: src/android/build-rules.md:11
#, fuzzy
msgid "Produces a Rust test binary that uses the standard Rust test harness."
msgstr ""
"Produce un binar de testare Rust care utilizeaz캒 harna탳amentul standard de "
"testare Rust."

#: src/android/build-rules.md:12
#, fuzzy
msgid "`rust_fuzz`"
msgstr "`rust_fuzz`"

#: src/android/build-rules.md:12
#, fuzzy
msgid "Produces a Rust fuzz binary leveraging `libfuzzer`."
msgstr "Produce un binar Rust fuzz folosind `libfuzzer`."

#: src/android/build-rules.md:13
#, fuzzy
msgid "`rust_protobuf`"
msgstr "`rust_protobuf`"

#: src/android/build-rules.md:13
#, fuzzy
msgid ""
"Generates source and produces a Rust library that provides an interface for "
"a particular protobuf."
msgstr ""
"Genereaz캒 sursa 탳i produce o bibliotec캒 Rust care ofer캒 o interfa탵캒 pentru "
"un anumit protobuf."

#: src/android/build-rules.md:14
#, fuzzy
msgid "`rust_bindgen`"
msgstr "`rust_bindgen`"

#: src/android/build-rules.md:14
#, fuzzy
msgid ""
"Generates source and produces a Rust library containing Rust bindings to C "
"libraries."
msgstr ""
"Genereaz캒 sursa 탳i produce o bibliotec캒 Rust care con탵ine leg캒turi Rust "
"pentru bibliotecile C."

#: src/android/build-rules.md:16
#, fuzzy
msgid "We will look at `rust_binary` and `rust_library` next."
msgstr "칉n continuare vom analiza `rust_binary` 탳i `rust_library`."

#: src/android/build-rules/binary.md:1
#, fuzzy
msgid "Rust Binaries"
msgstr "Binare Rust"

#: src/android/build-rules/binary.md:3
#, fuzzy
msgid ""
"Let us start with a simple application. At the root of an AOSP checkout, "
"create the following files:"
msgstr ""
"S캒 칥ncepem cu o aplica탵ie simpl캒. La r캒d캒cina unei verific캒ri AOSP, crea탵i "
"urm캒toarele fi탳iere:"

#: src/android/build-rules/binary.md:6 src/android/build-rules/library.md:13
#, fuzzy
msgid "_hello_rust/Android.bp_:"
msgstr "hello_rust/Android.bp_:"

#: src/android/build-rules/binary.md:8
#, fuzzy
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust\",\n"
"    crate_name: \"hello_rust\",\n"
"    srcs: [\"src/main.rs\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust\",\n"
"    crate_name: \"hello_rust\",\n"
"    srcs: [\"src/main.rs\"],\n"
"}\n"
"```"

#: src/android/build-rules/binary.md:16 src/android/build-rules/library.md:34
#, fuzzy
msgid "_hello_rust/src/main.rs_:"
msgstr "hello_rust/src/main.rs_:"

#: src/android/build-rules/binary.md:18
#, fuzzy
msgid ""
"```rust\n"
"//! Rust demo.\n"
"\n"
"/// Prints a greeting to standard output.\n"
"fn main() {\n"
"    println!(\"Hello from Rust!\");\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"//! Demo Rust.\n"
"\n"
"/// Tip캒re탳te un salut pe ie탳irea standard.\n"
"fn main() {\n"
"    println!(\"Hello from Rust!\");\n"
"}\n"
"```"

#: src/android/build-rules/binary.md:27
#, fuzzy
msgid "You can now build, push, and run the binary:"
msgstr "Acum pute탵i s캒 construi탵i, s캒 distribui탵i 탳i s캒 rula탵i fi탳ierul binar:"

#: src/android/build-rules/binary.md:29
#, fuzzy
msgid ""
"```shell\n"
"m hello_rust\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust /data/local/tmp\"\n"
"adb shell /data/local/tmp/hello_rust\n"
"```"
msgstr ""
"```shell\n"
"m hello_rust\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust /data/local/tmp\"\n"
"adb shell /data/local/tmp/hello_rust\n"
"```"

#: src/android/build-rules/library.md:1
#, fuzzy
msgid "Rust Libraries"
msgstr "Biblioteci Rust"

#: src/android/build-rules/library.md:3
#, fuzzy
msgid "You use `rust_library` to create a new Rust library for Android."
msgstr ""
"Utiliza탵i `rust_library` pentru a crea o nou캒 bibliotec캒 Rust pentru Android."

#: src/android/build-rules/library.md:5
#, fuzzy
msgid "Here we declare a dependency on two libraries:"
msgstr "Aici declar캒m o dependen탵캒 fa탵캒 de dou캒 biblioteci:"

#: src/android/build-rules/library.md:7
#, fuzzy
msgid "`libgreeting`, which we define below,"
msgstr "`libgreeting`, pe care 칥l definim mai jos,"

#: src/android/build-rules/library.md:8
#, fuzzy
msgid ""
"`libtextwrap`, which is a crate already vendored in [`external/rust/crates/`]"
"(https://cs.android.com/android/platform/superproject/+/master:external/rust/"
"crates/)."
msgstr ""
"`libtextwrap`, care este un crate deja v칙ndut 칥n [`external/rust/crates/`]"
"(https://cs.android.com/android/platform/superproject/+/master:external/rust/"
"crates/)."

#: src/android/build-rules/library.md:15
#, fuzzy
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_with_dep\",\n"
"    crate_name: \"hello_rust_with_dep\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"libgreetings\",\n"
"        \"libtextwrap\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"\n"
"rust_library {\n"
"    name: \"libgreetings\",\n"
"    crate_name: \"greetings\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_with_dep\",\n"
"    crate_name: \"hello_rust_with_dep\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"libgreetings\",\n"
"        \"libtextwrap\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"\n"
"rust_library {\n"
"    name: \"libgreetings\",\n"
"    crate_name: \"greetings\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"}\n"
"```"

#: src/android/build-rules/library.md:36
#, fuzzy
msgid ""
"```rust,ignore\n"
"//! Rust demo.\n"
"\n"
"use greetings::greeting;\n"
"use textwrap::fill;\n"
"\n"
"/// Prints a greeting to standard output.\n"
"fn main() {\n"
"    println!(\"{}\", fill(&greeting(\"Bob\"), 24));\n"
"}\n"
"```"
msgstr ""
"```칥ncredere,ignora\n"
"//! Demo Rust.\n"
"\n"
"folosi탵i greetings::greeting;\n"
"use textwrap::fill;\n"
"\n"
"/// Tip캒re탳te un mesaj de salut pe ie탳irea standard.\n"
"fn main() {\n"
"    println!(\"{}\", fill(&greeting(\"Bob\"), 24));\n"
"}\n"
"```"

#: src/android/build-rules/library.md:48
#, fuzzy
msgid "_hello_rust/src/lib.rs_:"
msgstr "hello_rust/src/lib.rs_:"

#: src/android/build-rules/library.md:50
#, fuzzy
msgid ""
"```rust,ignore\n"
"//! Greeting library.\n"
"\n"
"/// Greet `name`.\n"
"pub fn greeting(name: &str) -> String {\n"
"    format!(\"Hello {name}, it is very nice to meet you!\")\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"//! Biblioteca de salut.\n"
"\n"
"/// Saluta탵i `name`.\n"
"pub fn greeting(name: &str) -> String {\n"
"    format!(\"Bun캒 ziua {name}, m캒 bucur s캒 v캒 cunosc!\")\n"
"}\n"
"```"

#: src/android/build-rules/library.md:59
#, fuzzy
msgid "You build, push, and run the binary like before:"
msgstr "Construi탵i, distribui탵i 탳i rula탵i programul binar la fel ca 칥nainte:"

#: src/android/build-rules/library.md:61
#, fuzzy
msgid ""
"```shell\n"
"m hello_rust_with_dep\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/hello_rust_with_dep\n"
"```"
msgstr ""
"```shell\n"
"m hello_rust_with_dep\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/hello_rust_with_dep\n"
"```"

#: src/android/aidl.md:3
#, fuzzy
msgid ""
"The [Android Interface Definition Language (AIDL)](https://developer.android."
"com/guide/components/aidl) is supported in Rust:"
msgstr ""
"Limbajul [Android Interface Definition Language (AIDL)](https://developer."
"android.com/guide/components/aidl) este acceptat 칥n Rust:"

#: src/android/aidl.md:6
#, fuzzy
msgid "Rust code can call existing AIDL servers,"
msgstr "Codul Rust poate apela serverele AIDL existente,"

#: src/android/aidl.md:7
#, fuzzy
msgid "You can create new AIDL servers in Rust."
msgstr "Pute탵i crea noi servere AIDL 칥n Rust."

#: src/android/aidl/interface.md:1
#, fuzzy
msgid "AIDL Interfaces"
msgstr "Interfe탵e AIDL"

#: src/android/aidl/interface.md:3
#, fuzzy
msgid "You declare the API of your service using an AIDL interface:"
msgstr "Declara탵i API-ul serviciului dumneavoastr캒 utiliz칙nd o interfa탵캒 AIDL:"

#: src/android/aidl/interface.md:5
#, fuzzy
msgid ""
"_birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl_:"
msgstr ""
"_birthday_service/aidl/com/exemple/birthdayservice/IBirthdayService.aidl_:"

#: src/android/aidl/interface.md:17
#, fuzzy
msgid "_birthday_service/aidl/Android.bp_:"
msgstr "_birthday_service/aidl/Android.bp_:"

#: src/android/aidl/interface.md:19
#, fuzzy
msgid ""
"```javascript\n"
"aidl_interface {\n"
"    name: \"com.example.birthdayservice\",\n"
"    srcs: [\"com/example/birthdayservice/*.aidl\"],\n"
"    unstable: true,\n"
"    backend: {\n"
"        rust: { // Rust is not enabled by default\n"
"            enabled: true,\n"
"        },\n"
"    },\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"aidl_interface {\n"
"    name: \"com.example.birthdayservice\",\n"
"    srcs: [\"com/example/birthdayservice/*.aidl\"],\n"
"    unstable: true,\n"
"    backend: {\n"
"        rust: { // Rust nu este activat 칥n mod implicit\n"
"            enabled: true,\n"
"        },\n"
"    },\n"
"}\n"
"```"

#: src/android/aidl/interface.md:32
#, fuzzy
msgid ""
"Add `vendor_available: true` if your AIDL file is used by a binary in the "
"vendor partition."
msgstr ""
"Ad캒uga탵i `vendor_available: true` dac캒 fi탳ierul dvs. AIDL este utilizat de "
"un fi탳ier binar din parti탵ia furnizorului."

#: src/android/aidl/implementation.md:1
#, fuzzy
msgid "Service Implementation"
msgstr "Implementarea serviciilor"

#: src/android/aidl/implementation.md:3
#, fuzzy
msgid "We can now implement the AIDL service:"
msgstr "Acum putem implementa serviciul AIDL:"

#: src/android/aidl/implementation.md:5
#, fuzzy
msgid "_birthday_service/src/lib.rs_:"
msgstr "_birthday_service/src/lib.rs_:"

#: src/android/aidl/implementation.md:7
#, fuzzy
msgid ""
"```rust,ignore\n"
"//! Implementation of the `IBirthdayService` AIDL interface.\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::"
"IBirthdayService::IBirthdayService;\n"
"use com_example_birthdayservice::binder;\n"
"\n"
"/// The `IBirthdayService` implementation.\n"
"pub struct BirthdayService;\n"
"\n"
"impl binder::Interface for BirthdayService {}\n"
"\n"
"impl IBirthdayService for BirthdayService {\n"
"    fn wishHappyBirthday(&self, name: &str, years: i32) -> binder::"
"Result<String> {\n"
"        Ok(format!(\n"
"            \"Happy Birthday {name}, congratulations with the {years} years!"
"\"\n"
"        ))\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"//! Implementarea interfe탵ei AIDL `IBirthdayService`.\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::"
"IBirthdayService::IBirthdayService;\n"
"use com_example_birthdayservice::binder;\n"
"\n"
"/// Implementarea `IBirthdayService`.\n"
"pub struct struct BirthdayService;\n"
"\n"
"impl binder::Interfa탵캒 pentru BirthdayService {}\n"
"\n"
"impl IBirthdayService pentru BirthdayService {\n"
"    fn wishHappyBirthday(&amp;self, name: &amp;str, years: i32) -&gt; "
"binder::Result<String> {\n"
"        Ok(format!(\n"
"            \"La mul탵i ani {name}, felicit캒ri pentru {years} ani!\"\n"
"        ))\n"
"    }\n"
"}\n"
"```"

#: src/android/aidl/implementation.md:26 src/android/aidl/server.md:28
#: src/android/aidl/client.md:37
#, fuzzy
msgid "_birthday_service/Android.bp_:"
msgstr "_birthday_service/Android.bp_:"

#: src/android/aidl/implementation.md:28
#, fuzzy
msgid ""
"```javascript\n"
"rust_library {\n"
"    name: \"libbirthdayservice\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    crate_name: \"birthdayservice\",\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_library {\n"
"    name: \"libbirthdayservice\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    crate_name: \"birthdayservice\",\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"}\n"
"```"

#: src/android/aidl/server.md:1
#, fuzzy
msgid "AIDL Server"
msgstr "Server AIDL"

#: src/android/aidl/server.md:3
#, fuzzy
msgid "Finally, we can create a server which exposes the service:"
msgstr "칉n cele din urm캒, putem crea un server care s캒 expun캒 serviciul:"

#: src/android/aidl/server.md:5
#, fuzzy
msgid "_birthday_service/src/server.rs_:"
msgstr "_birthday_service/src/server.rs_:"

#: src/android/aidl/server.md:7
#, fuzzy
msgid ""
"```rust,ignore\n"
"//! Birthday service.\n"
"use birthdayservice::BirthdayService;\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::"
"IBirthdayService::BnBirthdayService;\n"
"use com_example_birthdayservice::binder;\n"
"\n"
"const SERVICE_IDENTIFIER: &str = \"birthdayservice\";\n"
"\n"
"/// Entry point for birthday service.\n"
"fn main() {\n"
"    let birthday_service = BirthdayService;\n"
"    let birthday_service_binder = BnBirthdayService::new_binder(\n"
"        birthday_service,\n"
"        binder::BinderFeatures::default(),\n"
"    );\n"
"    binder::add_service(SERVICE_IDENTIFIER, birthday_service_binder."
"as_binder())\n"
"        .expect(\"Failed to register service\");\n"
"    binder::ProcessState::join_thread_pool()\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"//! Serviciul de aniversare.\n"
"folosi탵i birthdayservice::BirthdayService;\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::"
"IBirthdayService::BnBirthdayService;\n"
"use com_example_birthdayservice::binder;\n"
"\n"
"const SERVICE_IDENTIFIER: &str = \"birthdayservice\";\n"
"\n"
"/// Punct de intrare pentru serviciul de aniversare.\n"
"fn main() {\n"
"    let birthday_service = BirthdayService;\n"
"    let birthday_service_binder = BnBirthdayService::new_binder(\n"
"        birthday_service,\n"
"        binder::BinderFeatures::default(),\n"
"    );\n"
"    binder::add_service(SERVICE_IDENTIFIER, birthday_service_binder."
"as_binder())\n"
"        .expect(\"Failed to register service\");\n"
"    binder::ProcessState::join_thread_pool()\n"
"}\n"
"```"

#: src/android/aidl/server.md:30
#, fuzzy
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_server\",\n"
"    crate_name: \"birthday_server\",\n"
"    srcs: [\"src/server.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"        \"libbirthdayservice\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_server\",\n"
"    crate_name: \"birthday_server\",\n"
"    srcs: [\"src/server.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"        \"libbirthdayservice\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"

#: src/android/aidl/deploy.md:3
#, fuzzy
msgid "We can now build, push, and start the service:"
msgstr "Acum putem construi, 칥mpinge 탳i porni serviciul:"

#: src/android/aidl/deploy.md:5
#, fuzzy
msgid ""
"```shell\n"
"m birthday_server\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/birthday_server\n"
"```"
msgstr ""
"```shell\n"
"m birthday_server\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/birthday_server\n"
"```"

#: src/android/aidl/deploy.md:11
#, fuzzy
msgid "In another terminal, check that the service runs:"
msgstr "칉ntr-un alt terminal, verifica탵i dac캒 serviciul ruleaz캒:"

#: src/android/aidl/deploy.md:21
#, fuzzy
msgid "You can also call the service with `service call`:"
msgstr "De asemenea, pute탵i apela serviciul cu `service call`:"

#: src/android/aidl/client.md:1
#, fuzzy
msgid "AIDL Client"
msgstr "Client AIDL"

#: src/android/aidl/client.md:3
#, fuzzy
msgid "Finally, we can create a Rust client for our new service."
msgstr ""
"칉n cele din urm캒, putem crea un client Rust pentru noul nostru serviciu."

#: src/android/aidl/client.md:5
#, fuzzy
msgid "_birthday_service/src/client.rs_:"
msgstr "_birthday_service/src/client.rs_:"

#: src/android/aidl/client.md:7
#, fuzzy
msgid ""
"```rust,ignore\n"
"//! Birthday service.\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::"
"IBirthdayService::IBirthdayService;\n"
"use com_example_birthdayservice::binder;\n"
"\n"
"const SERVICE_IDENTIFIER: &str = \"birthdayservice\";\n"
"\n"
"/// Connect to the BirthdayService.\n"
"pub fn connect() -> Result<binder::Strong<dyn IBirthdayService>, binder::"
"StatusCode> {\n"
"    binder::get_interface(SERVICE_IDENTIFIER)\n"
"}\n"
"\n"
"/// Call the birthday service.\n"
"fn main() -> Result<(), binder::Status> {\n"
"    let name = std::env::args()\n"
"        .nth(1)\n"
"        .unwrap_or_else(|| String::from(\"Bob\"));\n"
"    let years = std::env::args()\n"
"        .nth(2)\n"
"        .and_then(|arg| arg.parse::<i32>().ok())\n"
"        .unwrap_or(42);\n"
"\n"
"    binder::ProcessState::start_thread_pool();\n"
"    let service = connect().expect(\"Failed to connect to "
"BirthdayService\");\n"
"    let msg = service.wishHappyBirthday(&name, years)?;\n"
"    println!(\"{msg}\");\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""
"```칥ncredere,ignora\n"
"//! Serviciul de aniversare.\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::"
"IBirthdayService::IBirthdayService;\n"
"use com_example_birthdayservice::binder;\n"
"\n"
"const SERVICE_IDENTIFIER: &amp;str = \"birthdayservice\";\n"
"\n"
"/// Conecteaz캒-te la BirthdayService.\n"
"pub fn connect() -&gt; Result&lt;binder::Strong<dyn IBirthdayService>, "
"binder::StatusCode&gt; {\n"
"    binder::get_interface(SERVICE_IDENTIFIER)\n"
"}\n"
"\n"
"/// Cheam캒 serviciul de aniversare.\n"
"fn main() -&gt; Rezultat<(), binder::Status> {\n"
"    let name = std::env::args()\n"
"        .nth(1)\n"
"        .unwrap_or_else(|| String::from(\"Bob\"));\n"
"    let years = std::env::args()\n"
"        .nth(2)\n"
"        .and_then(|arg| arg.parse::<i32>().ok()))\n"
"        .unwrap_or(42);\n"
"\n"
"    binder::ProcessState::start_thread_pool();\n"
"    let service = connect().expect(\"Failed to connect to "
"BirthdayService\");\n"
"    let msg = service.wishHappyBirthday(&amp;name, years)?;\n"
"    println!(\"{msg}\");\n"
"    Ok((())\n"
"}\n"
"```"

#: src/android/aidl/client.md:39
#, fuzzy
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_client\",\n"
"    crate_name: \"birthday_client\",\n"
"    srcs: [\"src/client.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_client\",\n"
"    crate_name: \"birthday_client\",\n"
"    srcs: [\"src/client.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"

#: src/android/aidl/client.md:52
#, fuzzy
msgid "Notice that the client does not depend on `libbirthdayservice`."
msgstr "Observa탵i c캒 clientul nu depinde de `libbirthdayservice`."

#: src/android/aidl/client.md:54
#, fuzzy
msgid "Build, push, and run the client on your device:"
msgstr "Crea탵i, distribui탵i 탳i rula탵i clientul pe dispozitivul dvs:"

#: src/android/aidl/client.md:56
#, fuzzy
msgid ""
"```shell\n"
"m birthday_client\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_client /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/birthday_client Charlie 60\n"
"```"
msgstr ""
"```shell\n"
"m birthday_client\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_client /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/birthday_client Charlie 60\n"
"```"

#: src/android/aidl/changing.md:3
#, fuzzy
msgid ""
"Let us extend the API with more functionality: we want to let clients "
"specify a list of lines for the birthday card:"
msgstr ""
"S캒 extindem API-ul cu mai multe func탵ionalit캒탵i: dorim s캒 permitem "
"clien탵ilor s캒 specifice o list캒 de linii pentru felicitarea de ziua de "
"na탳tere:"

#: src/android/logging.md:3
#, fuzzy
msgid ""
"You should use the `log` crate to automatically log to `logcat` (on-device) "
"or `stdout` (on-host):"
msgstr ""
"Ar trebui s캒 folosi탵i caseta `log` pentru a 칥nregistra automat 칥n `logcat` "
"(pe dispozitiv) sau `stdout` (pe gazd캒):"

#: src/android/logging.md:6
#, fuzzy
msgid "_hello_rust_logs/Android.bp_:"
msgstr "salut_rust_logs/Android.bp_:"

#: src/android/logging.md:8
#, fuzzy
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_logs\",\n"
"    crate_name: \"hello_rust_logs\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"liblog_rust\",\n"
"        \"liblogger\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"    host_supported: true,\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_logs\",\n"
"    crate_name: \"hello_rust_logs\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"liblog_rust\",\n"
"        \"liblogger\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"    host_supported: true,\n"
"}\n"
"```"

#: src/android/logging.md:22
#, fuzzy
msgid "_hello_rust_logs/src/main.rs_:"
msgstr "hello_rust_logs/src/main.rs_:"

#: src/android/logging.md:24
#, fuzzy
msgid ""
"```rust,ignore\n"
"//! Rust logging demo.\n"
"\n"
"use log::{debug, error, info};\n"
"\n"
"/// Logs a greeting.\n"
"fn main() {\n"
"    logger::init(\n"
"        logger::Config::default()\n"
"            .with_tag_on_device(\"rust\")\n"
"            .with_min_level(log::Level::Trace),\n"
"    );\n"
"    debug!(\"Starting program.\");\n"
"    info!(\"Things are going fine.\");\n"
"    error!(\"Something went wrong!\");\n"
"}\n"
"```"
msgstr ""
"```칥ncredere,ignora\n"
"//! Demonstra탵ie de logare Rust.\n"
"\n"
"folosi탵i log::{debug, error, info};\n"
"\n"
"/// 칉nregistreaz캒 un mesaj de salut.\n"
"fn main() {\n"
"    logger::init(\n"
"        logger::Config::default()\n"
"            .with_tag_on_device(\"rust\")\n"
"            .with_min_level(log::Level::Trace),\n"
"    );\n"
"    debug!(\"Starting program.\");\n"
"    info!(\"Lucrurile merg bine.\");\n"
"    error!(\"Ceva a mers prost!\");\n"
"}\n"
"```"

#: src/android/logging.md:42 src/android/interoperability/with-c/bindgen.md:98
#: src/android/interoperability/with-c/rust.md:73
#, fuzzy
msgid "Build, push, and run the binary on your device:"
msgstr ""
"Crea탵i, distribui탵i 탳i rula탵i programul binar pe dispozitivul dumneavoastr캒:"

#: src/android/logging.md:44
#, fuzzy
msgid ""
"```shell\n"
"m hello_rust_logs\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/hello_rust_logs\n"
"```"
msgstr ""
"```shell\n"
"m hello_rust_logs\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/hello_rust_logs\n"
"```"

#: src/android/logging.md:50
#, fuzzy
msgid "The logs show up in `adb logcat`:"
msgstr "Jurnalele apar 칥n `adb logcat`:"

#: src/android/interoperability.md:3
#, fuzzy
msgid ""
"Rust has excellent support for interoperability with other languages. This "
"means that you can:"
msgstr ""
"Rust are un suport excelent pentru interoperabilitatea cu alte limbaje. "
"Acest lucru 칥nseamn캒 c캒 pute탵i:"

#: src/android/interoperability.md:6
#, fuzzy
msgid "Call Rust functions from other languages."
msgstr "Apelarea func탵iilor Rust din alte limbaje."

#: src/android/interoperability.md:7
#, fuzzy
msgid "Call functions written in other languages from Rust."
msgstr "Apelarea func탵iilor scrise 칥n alte limbaje din Rust."

#: src/android/interoperability.md:9
#, fuzzy
msgid ""
"When you call functions in a foreign language we say that you're using a "
"_foreign function interface_, also known as FFI."
msgstr ""
"Atunci c칙nd apela탵i func탵ii 칥ntr-o limb캒 str캒in캒, spunem c캒 utiliza탵i o "
"_interfa탵캒 de func탵ii str캒ine_, cunoscut캒 탳i sub numele de FFI."

#: src/android/interoperability/with-c.md:1
#, fuzzy
msgid "Interoperability with C"
msgstr "Interoperabilitate cu C"

#: src/android/interoperability/with-c.md:3
#, fuzzy
msgid ""
"Rust has full support for linking object files with a C calling convention. "
"Similarly, you can export Rust functions and call them from C."
msgstr ""
"Rust are un suport complet pentru legarea fi탳ierelor de obiecte cu o "
"conven탵ie de apelare C. 칉n mod similar, pute탵i exporta func탵ii Rust 탳i le "
"pute탵i apela din C."

#: src/android/interoperability/with-c.md:6
#, fuzzy
msgid "You can do it by hand if you want:"
msgstr "Pute탵i s캒 o face탵i manual, dac캒 dori탵i:"

#: src/android/interoperability/with-c.md:8
#, fuzzy
msgid ""
"```rust\n"
"extern \"C\" {\n"
"    fn abs(x: i32) -> i32;\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = -42;\n"
"    let abs_x = unsafe { abs(x) };\n"
"    println!(\"{x}, {abs_x}\");\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"extern \"C\" {\n"
"    fn abs(x: i32) -> i32;\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = -42;\n"
"    let abs_x = unsafe { abs(x) };\n"
"    println!(\"{x}, {abs_x}\");\n"
"}\n"
"```"

#: src/android/interoperability/with-c.md:20
#, fuzzy
msgid ""
"We already saw this in the [Safe FFI Wrapper exercise](../../exercises/day-3/"
"safe-ffi-wrapper.md)."
msgstr ""
"Am v캒zut deja acest lucru 칥n [Exerci탵iul [Safe FFI Wrapper] (../../exerci탵ii/"
"zi-3/safe-ffi-wrapper.md)."

#: src/android/interoperability/with-c.md:23
#, fuzzy
msgid ""
"This assumes full knowledge of the target platform. Not recommended for "
"production."
msgstr ""
"Acest lucru presupune cunoa탳terea complet캒 a platformei 탵int캒. Nu se "
"recomand캒 pentru produc탵ie."

#: src/android/interoperability/with-c.md:26
#, fuzzy
msgid "We will look at better options next."
msgstr "칉n continuare, vom examina op탵iuni mai bune."

#: src/android/interoperability/with-c/bindgen.md:1
#, fuzzy
msgid "Using Bindgen"
msgstr "Utilizarea Bindgen"

#: src/android/interoperability/with-c/bindgen.md:3
#, fuzzy
msgid ""
"The [bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html) "
"tool can auto-generate bindings from a C header file."
msgstr ""
"Instrumentul [bindgen](https://rust-lang.github.io/rust-bindgen/introduction."
"html) poate genera automat leg캒turile dintr-un fi탳ier de antet C."

#: src/android/interoperability/with-c/bindgen.md:6
#, fuzzy
msgid "First create a small C library:"
msgstr "Mai 칥nt칙i crea탵i o mic캒 bibliotec캒 C:"

#: src/android/interoperability/with-c/bindgen.md:8
#, fuzzy
msgid "_interoperability/bindgen/libbirthday.h_:"
msgstr "interoperabilitate/bindgen/libbirthday.h_:"

#: src/android/interoperability/with-c/bindgen.md:19
#, fuzzy
msgid "_interoperability/bindgen/libbirthday.c_:"
msgstr "interoperabilitate/bindgen/libbirthday.c_:"

#: src/android/interoperability/with-c/bindgen.md:21
#, fuzzy
msgid ""
"```c\n"
"#include <stdio.h>\n"
"#include \"libbirthday.h\"\n"
"\n"
"void print_card(const card* card) {\n"
"  printf(\"+--------------\\n\");\n"
"  printf(\"| Happy Birthday %s!\\n\", card->name);\n"
"  printf(\"| Congratulations with the %i years!\\n\", card->years);\n"
"  printf(\"+--------------\\n\");\n"
"}\n"
"```"
msgstr ""
"```c\n"
"#include <stdio.h>\n"
"#include \"libbirthday.h\"\n"
"\n"
"void print_card(const card* card) {\n"
"  printf(\"+--------------\\n\");\n"
"  printf(\"| La mul탵i ani %s!\\n\", card->name);\n"
"  printf(\"| Felicit캒ri pentru %i ani!\\n\", card->years);\n"
"  printf(\"+--------------\\n\");\n"
"}\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:33
#, fuzzy
msgid "Add this to your `Android.bp` file:"
msgstr "Ad캒uga탵i acest lucru la fi탳ierul `Android.bp`:"

#: src/android/interoperability/with-c/bindgen.md:35
#: src/android/interoperability/with-c/bindgen.md:55
#: src/android/interoperability/with-c/bindgen.md:69
#: src/android/interoperability/with-c/bindgen.md:108
#, fuzzy
msgid "_interoperability/bindgen/Android.bp_:"
msgstr "interoperabilitate/bindgen/Android.bp_:"

#: src/android/interoperability/with-c/bindgen.md:37
#, fuzzy
msgid ""
"```javascript\n"
"cc_library {\n"
"    name: \"libbirthday\",\n"
"    srcs: [\"libbirthday.c\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"cc_library {\n"
"    name: \"libbirthday\",\n"
"    srcs: [\"libbirthday.c\"],\n"
"}\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:44
#, fuzzy
msgid ""
"Create a wrapper header file for the library (not strictly needed in this "
"example):"
msgstr ""
"Crea탵i un fi탳ier de antet de 칥nf캒탳urare pentru bibliotec캒 (nu este strict "
"necesar 칥n acest exemplu):"

#: src/android/interoperability/with-c/bindgen.md:47
#, fuzzy
msgid "_interoperability/bindgen/libbirthday_wrapper.h_:"
msgstr "interoperabilitate/bindgen/libbirthday_wrapper.h_:"

#: src/android/interoperability/with-c/bindgen.md:49
#, fuzzy
msgid ""
"```c\n"
"#include \"libbirthday.h\"\n"
"```"
msgstr ""
"```c\n"
"#include \"libbirthday.h\"\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:53
#, fuzzy
msgid "You can now auto-generate the bindings:"
msgstr "Acum pute탵i s캒 genera탵i automat leg캒turile:"

#: src/android/interoperability/with-c/bindgen.md:57
#, fuzzy
msgid ""
"```javascript\n"
"rust_bindgen {\n"
"    name: \"libbirthday_bindgen\",\n"
"    crate_name: \"birthday_bindgen\",\n"
"    wrapper_src: \"libbirthday_wrapper.h\",\n"
"    source_stem: \"bindings\",\n"
"    static_libs: [\"libbirthday\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_bindgen {\n"
"    name: \"libbirthday_bindgen\",\n"
"    crate_name: \"birthday_bindgen\",\n"
"    wrapper_src: \"libbirthday_wrapper.h\",\n"
"    source_stem: \"bindings\",\n"
"    static_libs: [\"libbirthday\"],\n"
"}\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:67
#, fuzzy
msgid "Finally, we can use the bindings in our Rust program:"
msgstr "칉n cele din urm캒, putem utiliza leg캒turile 칥n programul nostru Rust:"

#: src/android/interoperability/with-c/bindgen.md:71
#, fuzzy
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"print_birthday_card\",\n"
"    srcs: [\"main.rs\"],\n"
"    rustlibs: [\"libbirthday_bindgen\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_binary {\n"
"    name: \"print_birthday_card\",\n"
"    srcs: [\"main.rs\"],\n"
"    rustlibs: [\"libbirthday_bindgen\"],\n"
"}\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:79
#, fuzzy
msgid "_interoperability/bindgen/main.rs_:"
msgstr "interoperabilitate/bindgen/main.rs_:"

#: src/android/interoperability/with-c/bindgen.md:81
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"//! Bindgen demo.\n"
"\n"
"use birthday_bindgen::{card, print_card};\n"
"\n"
"fn main() {\n"
"    let name = std::ffi::CString::new(\"Peter\").unwrap();\n"
"    let card = card {\n"
"        name: name.as_ptr(),\n"
"        years: 42,\n"
"    };\n"
"    unsafe {\n"
"        print_card(&card as *const card);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,compile_fail\n"
"//! Bindgen demo.\n"
"\n"
"use birthday_bindgen::{card, print_card};\n"
"\n"
"fn main() {\n"
"    let name = std::ffi::CString::new(\"Peter\").unwrap();\n"
"    let card = card {\n"
"        name: name.as_ptr(),\n"
"        ani: 42,\n"
"    };\n"
"    unsafe {\n"
"        print_card(&card as *const card);\n"
"    }\n"
"}\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:100
#, fuzzy
msgid ""
"```shell\n"
"m print_birthday_card\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/print_birthday_card\n"
"```"
msgstr ""
"```shell\n"
"m print_birthday_card\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/print_birthday_card\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:106
#, fuzzy
msgid "Finally, we can run auto-generated tests to ensure the bindings work:"
msgstr ""
"칉n cele din urm캒, putem rula teste generate automat pentru a ne asigura c캒 "
"leg캒turile func탵ioneaz캒:"

#: src/android/interoperability/with-c/bindgen.md:110
#, fuzzy
msgid ""
"```javascript\n"
"rust_test {\n"
"    name: \"libbirthday_bindgen_test\",\n"
"    srcs: [\":libbirthday_bindgen\"],\n"
"    crate_name: \"libbirthday_bindgen_test\",\n"
"    test_suites: [\"general-tests\"],\n"
"    auto_gen_config: true,\n"
"    clippy_lints: \"none\", // Generated file, skip linting\n"
"    lints: \"none\",\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_test {\n"
"    name: \"libbirthday_bindgen_test\",\n"
"    srcs: [\":libbirthday_bindgen\"],\n"
"    crate_name: \"libbirthday_bindgen_test\",\n"
"    test_suites: [\"general-tests\"],\n"
"    auto_gen_config: true,\n"
"    clippy_lints: \"none\", // Fi탳ier generat, s캒ri탵i peste linting\n"
"    lints: \"none\",\n"
"}\n"
"```"

#: src/android/interoperability/with-c/rust.md:1
#, fuzzy
msgid "Calling Rust"
msgstr "Apelarea Rust"

#: src/android/interoperability/with-c/rust.md:3
#, fuzzy
msgid "Exporting Rust functions and types to C is easy:"
msgstr "Exportul func탵iilor 탳i tipurilor Rust 칥n C este u탳or:"

#: src/android/interoperability/with-c/rust.md:5
#, fuzzy
msgid "_interoperability/rust/libanalyze/analyze.rs_"
msgstr "interoperabilitate/interoperabilitate/rust/libanalyze/analyze.rs_"

#: src/android/interoperability/with-c/rust.md:7
#, fuzzy
msgid ""
"```rust,editable\n"
"//! Rust FFI demo.\n"
"#![deny(improper_ctypes_definitions)]\n"
"\n"
"use std::os::raw::c_int;\n"
"\n"
"/// Analyze the numbers.\n"
"#[no_mangle]\n"
"pub extern \"C\" fn analyze_numbers(x: c_int, y: c_int) {\n"
"    if x < y {\n"
"        println!(\"x ({x}) is smallest!\");\n"
"    } else {\n"
"        println!(\"y ({y}) is probably larger than x ({x})\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"//! Demonstra탵ie Rust FFI.\n"
"#![deny(improper_ctypes_definitions)]\n"
"\n"
"use std::os::raw::c_int;\n"
"\n"
"/// Analiza탵i numerele.\n"
"#[no_mangle]\n"
"pub extern \"C\" fn analyze_numbers(x: c_int, y: c_int) {\n"
"    if x < y {\n"
"        println!(\"x ({x}) este cel mai mic!\");\n"
"    } else {\n"
"        println!(\"y ({y}) este probabil mai mare dec칙t x ({x})\");\n"
"    }\n"
"}\n"
"```"

#: src/android/interoperability/with-c/rust.md:24
#, fuzzy
msgid "_interoperability/rust/libanalyze/analyze.h_"
msgstr "interoperabilitate/interoperabilitate/rust/libanalyze/analyze.h_"

#: src/android/interoperability/with-c/rust.md:26
#, fuzzy
msgid ""
"```c\n"
"#ifndef ANALYSE_H\n"
"#define ANALYSE_H\n"
"\n"
"extern \"C\" {\n"
"void analyze_numbers(int x, int y);\n"
"}\n"
"\n"
"#endif\n"
"```"
msgstr ""
"```c\n"
"#ifndef ANALYSE_H\n"
"#define ANALYSE_H\n"
"\n"
"extern \"C\" {\n"
"void analyze_numbers(int x, int y);\n"
"}\n"
"\n"
"#endif\n"
"```"

#: src/android/interoperability/with-c/rust.md:37
#, fuzzy
msgid "_interoperability/rust/libanalyze/Android.bp_"
msgstr "interoperabilitate/interoperabilitate/rusine/libanaliza/Android.bp_"

#: src/android/interoperability/with-c/rust.md:39
#, fuzzy
msgid ""
"```javascript\n"
"rust_ffi {\n"
"    name: \"libanalyze_ffi\",\n"
"    crate_name: \"analyze_ffi\",\n"
"    srcs: [\"analyze.rs\"],\n"
"    include_dirs: [\".\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_ffi {\n"
"    name: \"libanalyze_ffi\",\n"
"    crate_name: \"analyze_ffi\",\n"
"    srcs: [\"analyze.rs\"],\n"
"    include_dirs: [\".\"],\n"
"}\n"
"```"

#: src/android/interoperability/with-c/rust.md:48
#, fuzzy
msgid "We can now call this from a C binary:"
msgstr "Acum putem apela acest lucru dintr-un binar C:"

#: src/android/interoperability/with-c/rust.md:50
#, fuzzy
msgid "_interoperability/rust/analyze/main.c_"
msgstr "interoperabilitate/rust/analiza/main.c_"

#: src/android/interoperability/with-c/rust.md:52
#, fuzzy
msgid ""
"```c\n"
"#include \"analyze.h\"\n"
"\n"
"int main() {\n"
"  analyze_numbers(10, 20);\n"
"  analyze_numbers(123, 123);\n"
"  return 0;\n"
"}\n"
"```"
msgstr ""
"```c\n"
"#include \"analyze.h\"\n"
"\n"
"int main() {\n"
"  analyze_numbers(10, 20);\n"
"  analyze_numbers(123, 123);\n"
"  return 0;\n"
"}\n"
"```"

#: src/android/interoperability/with-c/rust.md:62
#, fuzzy
msgid "_interoperability/rust/analyze/Android.bp_"
msgstr "interoperabilitate/칥nc캒lzire/antreprenoriat/analiza/Android.bp_"

#: src/android/interoperability/with-c/rust.md:64
#, fuzzy
msgid ""
"```javascript\n"
"cc_binary {\n"
"    name: \"analyze_numbers\",\n"
"    srcs: [\"main.c\"],\n"
"    static_libs: [\"libanalyze_ffi\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"cc_binary {\n"
"    name: \"analyze_numbers\",\n"
"    srcs: [\"main.c\"],\n"
"    static_libs: [\"libanalyze_ffi\"],\n"
"}\n"
"```"

#: src/android/interoperability/with-c/rust.md:75
#, fuzzy
msgid ""
"```shell\n"
"m analyze_numbers\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/analyze_numbers\n"
"```"
msgstr ""
"```shell\n"
"m analyze_numbers\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/analyze_numbers\n"
"```"

#: src/android/interoperability/with-c/rust.md:83
#, fuzzy
msgid ""
"`#[no_mangle]` disables Rust's usual name mangling, so the exported symbol "
"will just be the name of the function. You can also use `#[export_name = "
"\"some_name\"]` to specify whatever name you want."
msgstr ""
"`#[no_mangle]` dezactiveaz캒 manipularea obi탳nuit캒 a numelor din Rust, astfel "
"칥nc칙t simbolul exportat va fi doar numele func탵iei. De asemenea, pute탵i "
"utiliza `#[export_name = \"some_name\"]` pentru a specifica orice nume "
"dori탵i."

#: src/android/interoperability/cpp.md:3
#, fuzzy
msgid ""
"The [CXX crate](https://cxx.rs/) makes it possible to do safe "
"interoperability between Rust and C++."
msgstr ""
"[CXX crate](https://cxx.rs/) face posibil캒 realizarea unei "
"interoperabilit캒탵i sigure 칥ntre Rust 탳i C++."

#: src/android/interoperability/cpp.md:6
#, fuzzy
msgid "The overall approach looks like this:"
msgstr "Abordarea general캒 arat캒 칥n felul urm캒tor:"

#: src/android/interoperability/cpp/bridge.md:3
msgid ""
"CXX relies on a description of the function signatures that will be exposed "
"from each language to the other. You provide this description using extern "
"blocks in a Rust module annotated with the `#[cxx::bridge]` attribute macro."
msgstr ""

#: src/android/interoperability/cpp/bridge.md:7
msgid ""
"```rust,ignore\n"
"#[allow(unsafe_op_in_unsafe_fn)]\n"
"#[cxx::bridge(namespace = \"org::blobstore\")]\n"
"mod ffi {\n"
"    // Shared structs with fields visible to both languages.\n"
"    struct BlobMetadata {\n"
"        size: usize,\n"
"        tags: Vec<String>,\n"
"    }\n"
"\n"
"    // Rust types and signatures exposed to C++.\n"
"    extern \"Rust\" {\n"
"        type MultiBuf;\n"
"\n"
"        fn next_chunk(buf: &mut MultiBuf) -> &[u8];\n"
"    }\n"
"\n"
"    // C++ types and signatures exposed to Rust.\n"
"    unsafe extern \"C++\" {\n"
"        include!(\"include/blobstore.h\");\n"
"\n"
"        type BlobstoreClient;\n"
"\n"
"        fn new_blobstore_client() -> UniquePtr<BlobstoreClient>;\n"
"        fn put(self: Pin<&mut BlobstoreClient>, parts: &mut MultiBuf) -> "
"u64;\n"
"        fn tag(self: Pin<&mut BlobstoreClient>, blobid: u64, tag: &str);\n"
"        fn metadata(&self, blobid: u64) -> BlobMetadata;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/cpp/bridge.md:40
msgid "The bridge is generally declared in an `ffi` module within your crate."
msgstr ""

#: src/android/interoperability/cpp/bridge.md:41
msgid ""
"From the declarations made in the bridge module, CXX will generate matching "
"Rust and C++ type/function definitions in order to expose those items to "
"both languages."
msgstr ""

#: src/android/interoperability/cpp/bridge.md:44
msgid ""
"To view the generated Rust code, use [cargo-expand](https://github.com/"
"dtolnay/cargo-expand) to view the expanded proc macro. For most of the "
"examples you would use `cargo expand ::ffi` to expand just the `ffi` module "
"(though this doesn't apply for Android projects)."
msgstr ""

#: src/android/interoperability/cpp/bridge.md:47
msgid "To view the generated C++ code, look in `target/cxxbridge`."
msgstr ""

#: src/android/interoperability/cpp/rust-bridge.md:1
msgid "Rust Bridge Declarations"
msgstr ""

#: src/android/interoperability/cpp/rust-bridge.md:3
msgid ""
"```rust,ignore\n"
"#[cxx::bridge]\n"
"mod ffi {\n"
"    extern \"Rust\" {\n"
"        type MyType; // Opaque type\n"
"        fn foo(&self); // Method on `MyType`\n"
"        fn bar() -> Box<MyType>; // Free function\n"
"    }\n"
"}\n"
"\n"
"struct MyType(i32);\n"
"\n"
"impl MyType {\n"
"    fn foo(&self) {\n"
"        println!(\"{}\", self.0);\n"
"    }\n"
"}\n"
"\n"
"fn bar() -> Box<MyType> {\n"
"    Box::new(MyType(123))\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/cpp/rust-bridge.md:28
msgid ""
"Items declared in the `extern \"Rust\"` reference items that are in scope in "
"the parent module."
msgstr ""

#: src/android/interoperability/cpp/rust-bridge.md:30
msgid ""
"The CXX code generator uses your `extern \"Rust\"` section(s) to produce a C+"
"+ header file containing the corresponding C++ declarations. The generated "
"header has the same path as the Rust source file containing the bridge, "
"except with a .rs.h file extension."
msgstr ""

#: src/android/interoperability/cpp/generated-cpp.md:3
msgid ""
"```rust,ignore\n"
"#[cxx::bridge]\n"
"mod ffi {\n"
"    // Rust types and signatures exposed to C++.\n"
"    extern \"Rust\" {\n"
"        type MultiBuf;\n"
"\n"
"        fn next_chunk(buf: &mut MultiBuf) -> &[u8];\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/cpp/generated-cpp.md:15
msgid "Results in (roughly) the following C++:"
msgstr ""

#: src/android/interoperability/cpp/cpp-bridge.md:1
msgid "C++ Bridge Declarations"
msgstr ""

#: src/android/interoperability/cpp/cpp-bridge.md:3
msgid ""
"```rust,ignore\n"
"#[cxx::bridge]\n"
"mod ffi {\n"
"    // C++ types and signatures exposed to Rust.\n"
"    unsafe extern \"C++\" {\n"
"        include!(\"include/blobstore.h\");\n"
"\n"
"        type BlobstoreClient;\n"
"\n"
"        fn new_blobstore_client() -> UniquePtr<BlobstoreClient>;\n"
"        fn put(self: Pin<&mut BlobstoreClient>, parts: &mut MultiBuf) -> "
"u64;\n"
"        fn tag(self: Pin<&mut BlobstoreClient>, blobid: u64, tag: &str);\n"
"        fn metadata(&self, blobid: u64) -> BlobMetadata;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/cpp/cpp-bridge.md:20
msgid "Results in (roughly) the following Rust:"
msgstr ""

#: src/android/interoperability/cpp/cpp-bridge.md:22
msgid ""
"```rust,ignore\n"
"#[repr(C)]\n"
"pub struct BlobstoreClient {\n"
"    _private: ::cxx::private::Opaque,\n"
"}\n"
"\n"
"pub fn new_blobstore_client() -> ::cxx::UniquePtr<BlobstoreClient> {\n"
"    extern \"C\" {\n"
"        #[link_name = \"org$blobstore$cxxbridge1$new_blobstore_client\"]\n"
"        fn __new_blobstore_client() -> *mut BlobstoreClient;\n"
"    }\n"
"    unsafe { ::cxx::UniquePtr::from_raw(__new_blobstore_client()) }\n"
"}\n"
"\n"
"impl BlobstoreClient {\n"
"    pub fn put(&self, parts: &mut MultiBuf) -> u64 {\n"
"        extern \"C\" {\n"
"            #[link_name = \"org$blobstore$cxxbridge1$BlobstoreClient$put\"]\n"
"            fn __put(\n"
"                _: &BlobstoreClient,\n"
"                parts: *mut ::cxx::core::ffi::c_void,\n"
"            ) -> u64;\n"
"        }\n"
"        unsafe {\n"
"            __put(self, parts as *mut MultiBuf as *mut ::cxx::core::ffi::"
"c_void)\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// ...\n"
"```"
msgstr ""

#: src/android/interoperability/cpp/cpp-bridge.md:56
msgid ""
"The programmer does not need to promise that the signatures they have typed "
"in are accurate. CXX performs static assertions that the signatures exactly "
"correspond with what is declared in C++."
msgstr ""

#: src/android/interoperability/cpp/cpp-bridge.md:59
msgid ""
"`unsafe extern` blocks allow you to declare C++ functions that are safe to "
"call from Rust."
msgstr ""

#: src/android/interoperability/cpp/shared-types.md:3
msgid ""
"```rust,ignore\n"
"#[cxx::bridge]\n"
"mod ffi {\n"
"    #[derive(Clone, Debug, Hash)]\n"
"    struct PlayingCard {\n"
"        suit: Suit,\n"
"        value: u8,  // A=1, J=11, Q=12, K=13\n"
"    }\n"
"\n"
"    enum Suit {\n"
"        Clubs,\n"
"        Diamonds,\n"
"        Hearts,\n"
"        Spades,\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/cpp/shared-types.md:23
msgid "Only C-like (unit) enums are supported."
msgstr ""

#: src/android/interoperability/cpp/shared-types.md:24
msgid ""
"A limited number of traits are supported for `#[derive()]` on shared types. "
"Corresponding functionality is also generated for the C++ code, e.g. if you "
"derive `Hash` also generates an implementation of `std::hash` for the "
"corresponding C++ type."
msgstr ""

#: src/android/interoperability/cpp/shared-enums.md:15
#, fuzzy
msgid "Generated Rust:"
msgstr "Rust nesigur"

#: src/android/interoperability/cpp/shared-enums.md:33
msgid "Generated C++:"
msgstr ""

#: src/android/interoperability/cpp/shared-enums.md:46
msgid ""
"On the Rust side, the code generated for shared enums is actually a struct "
"wrapping a numeric value. This is because it is not UB in C++ for an enum "
"class to hold a value different from all of the listed variants, and our "
"Rust representation needs to have the same behavior."
msgstr ""

#: src/android/interoperability/cpp/rust-result.md:3
msgid ""
"```rust,ignore\n"
"#[cxx::bridge]\n"
"mod ffi {\n"
"    extern \"Rust\" {\n"
"        fn fallible(depth: usize) -> Result<String>;\n"
"    }\n"
"}\n"
"\n"
"fn fallible(depth: usize) -> anyhow::Result<String> {\n"
"    if depth == 0 {\n"
"        return Err(anyhow::Error::msg(\"fallible1 requires depth > 0\"));\n"
"    }\n"
"\n"
"    Ok(\"Success!\".into())\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/cpp/rust-result.md:22
msgid ""
"Rust functions that return `Result` are translated to exceptions on the C++ "
"side."
msgstr ""

#: src/android/interoperability/cpp/rust-result.md:24
msgid ""
"The exception thrown will always be of type `rust::Error`, which primarily "
"exposes a way to get the error message string. The error message will come "
"from the error type's `Display` impl."
msgstr ""

#: src/android/interoperability/cpp/rust-result.md:27
msgid ""
"A panic unwinding from Rust to C++ will always cause the process to "
"immediately terminate."
msgstr ""

#: src/android/interoperability/cpp/cpp-exception.md:3
msgid ""
"```rust,ignore\n"
"#[cxx::bridge]\n"
"mod ffi {\n"
"    unsafe extern \"C++\" {\n"
"        include!(\"example/include/example.h\");\n"
"        fn fallible(depth: usize) -> Result<String>;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    if let Err(err) = ffi::fallible(99) {\n"
"        eprintln!(\"Error: {}\", err);\n"
"        process::exit(1);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/cpp/cpp-exception.md:22
msgid ""
"C++ functions declared to return a `Result` will catch any thrown exception "
"on the C++ side and return it as an `Err` value to the calling Rust function."
msgstr ""

#: src/android/interoperability/cpp/cpp-exception.md:24
msgid ""
"If an exception is thrown from an extern \"C++\" function that is not "
"declared by the CXX bridge to return `Result`, the program calls C++'s `std::"
"terminate`. The behavior is equivalent to the same exception being thrown "
"through a `noexcept` C++ function."
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:3
#, fuzzy
msgid "Rust Type"
msgstr "Rugin캒 prin exemplu"

#: src/android/interoperability/cpp/type-mapping.md:3
#, fuzzy
msgid "C++ Type"
msgstr "Exemplu C++"

#: src/android/interoperability/cpp/type-mapping.md:5
#, fuzzy
msgid "`String`"
msgstr "Sir"

#: src/android/interoperability/cpp/type-mapping.md:5
#, fuzzy
msgid "`rust::String`"
msgstr "`rust_bindgen`"

#: src/android/interoperability/cpp/type-mapping.md:6
#, fuzzy
msgid "`rust::Str`"
msgstr "`rust_test`"

#: src/android/interoperability/cpp/type-mapping.md:7
#, fuzzy
msgid "`CxxString`"
msgstr "Sir"

#: src/android/interoperability/cpp/type-mapping.md:7
#, fuzzy
msgid "`std::string`"
msgstr "탳ir:"

#: src/android/interoperability/cpp/type-mapping.md:8
msgid "`&[T]`/`&mut [T]`"
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:8
#, fuzzy
msgid "`rust::Slice`"
msgstr "`rust_ffi`"

#: src/android/interoperability/cpp/type-mapping.md:9
#, fuzzy
msgid "`Box<T>`"
msgstr "`Box`"

#: src/android/interoperability/cpp/type-mapping.md:9
msgid "`rust::Box<T>`"
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:10
msgid "`UniquePtr<T>`"
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:10
msgid "`std::unique_ptr<T>`"
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:11
#, fuzzy
msgid "`Vec<T>`"
msgstr "`Vec`"

#: src/android/interoperability/cpp/type-mapping.md:11
#, fuzzy
msgid "`rust::Vec<T>`"
msgstr "`mpsc::Receiver<T>`"

#: src/android/interoperability/cpp/type-mapping.md:12
#, fuzzy
msgid "`CxxVector<T>`"
msgstr "`Celula<T>`"

#: src/android/interoperability/cpp/type-mapping.md:12
#, fuzzy
msgid "`std::vector<T>`"
msgstr "`mpsc::Receiver<T>`"

#: src/android/interoperability/cpp/type-mapping.md:16
msgid ""
"These types can be used in the fields of shared structs and the arguments "
"and returns of extern functions."
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:18
msgid ""
"Note that Rust's `String` does not map directly to `std::string`. There are "
"a few reasons for this:"
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:20
msgid ""
"`std::string` does not uphold the UTF-8 invariant that `String` requires."
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:21
msgid ""
"The two types have different layouts in memory and so can't be passed "
"directly between languages."
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:23
msgid ""
"`std::string` requires move constructors that don't match Rust's move "
"semantics, so a `std::string` can't be passed by value to Rust."
msgstr ""

#: src/android/interoperability/cpp/android-build-cpp.md:1
#: src/android/interoperability/cpp/android-cpp-genrules.md:1
#: src/android/interoperability/cpp/android-build-rust.md:1
#, fuzzy
msgid "Building in Android"
msgstr "Rust 칥n Android"

#: src/android/interoperability/cpp/android-build-cpp.md:3
msgid ""
"Create a `cc_library_static` to build the C++ library, including the CXX "
"generated header and source file."
msgstr ""

#: src/android/interoperability/cpp/android-build-cpp.md:6
msgid ""
"```javascript\n"
"cc_library_static {\n"
"    name: \"libcxx_test_cpp\",\n"
"    srcs: [\"cxx_test.cpp\"],\n"
"    generated_headers: [\n"
"        \"cxx-bridge-header\",\n"
"        \"libcxx_test_bridge_header\"\n"
"    ],\n"
"    generated_sources: [\"libcxx_test_bridge_code\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/cpp/android-build-cpp.md:20
msgid ""
"Point out that `libcxx_test_bridge_header` and `libcxx_test_bridge_code` are "
"the dependencies for the CXX-generated C++ bindings. We'll show how these "
"are setup on the next slide."
msgstr ""

#: src/android/interoperability/cpp/android-build-cpp.md:23
msgid ""
"Note that you also need to depend on the `cxx-bridge-header` library in "
"order to pull in common CXX definitions."
msgstr ""

#: src/android/interoperability/cpp/android-build-cpp.md:25
msgid ""
"Full docs for using CXX in Android can be found in [the Android docs]"
"(https://source.android.com/docs/setup/build/rust/building-rust-modules/"
"android-rust-patterns#rust-cpp-interop-using-cxx). You may want to share "
"that link with the class so that students know where they can find these "
"instructions again in the future."
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:3
msgid ""
"Create two genrules: One to generate the CXX header, and one to generate the "
"CXX source file. These are then used as inputs to the `cc_library_static`."
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:6
msgid ""
"```javascript\n"
"// Generate a C++ header containing the C++ bindings\n"
"// to the Rust exported functions in lib.rs.\n"
"genrule {\n"
"    name: \"libcxx_test_bridge_header\",\n"
"    tools: [\"cxxbridge\"],\n"
"    cmd: \"$(location cxxbridge) $(in) --header > $(out)\",\n"
"    srcs: [\"lib.rs\"],\n"
"    out: [\"lib.rs.h\"],\n"
"}\n"
"\n"
"// Generate the C++ code that Rust calls into.\n"
"genrule {\n"
"    name: \"libcxx_test_bridge_code\",\n"
"    tools: [\"cxxbridge\"],\n"
"    cmd: \"$(location cxxbridge) $(in) > $(out)\",\n"
"    srcs: [\"lib.rs\"],\n"
"    out: [\"lib.rs.cc\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:29
msgid ""
"The `cxxbridge` tool is a standalone tool that generates the C++ side of the "
"bridge module. It is included in Android and available as a Soong tool."
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:31
msgid ""
"By convention, if your Rust source file is `lib.rs` your header file will be "
"named `lib.rs.h` and your source file will be named `lib.rs.cc`. This naming "
"convention isn't enforced, though."
msgstr ""

#: src/android/interoperability/cpp/android-build-rust.md:3
msgid ""
"Create a `rust_binary` that depends on `libcxx` and your `cc_library_static`."
msgstr ""

#: src/android/interoperability/cpp/android-build-rust.md:5
#, fuzzy
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"cxx_test\",\n"
"    srcs: [\"lib.rs\"],\n"
"    rustlibs: [\"libcxx\"],\n"
"    static_libs: [\"libcxx_test_cpp\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_binary {\n"
"    name: \"print_birthday_card\",\n"
"    srcs: [\"main.rs\"],\n"
"    rustlibs: [\"libbirthday_bindgen\"],\n"
"}\n"
"```"

#: src/android/interoperability/java.md:1
#, fuzzy
msgid "Interoperability with Java"
msgstr "Interoperabilitate cu Java"

#: src/android/interoperability/java.md:3
#, fuzzy
msgid ""
"Java can load shared objects via [Java Native Interface (JNI)](https://en."
"wikipedia.org/wiki/Java_Native_Interface). The [`jni` crate](https://docs.rs/"
"jni/) allows you to create a compatible library."
msgstr ""
"Java poate 칥nc캒rca obiecte partajate prin intermediul [Java Native Interface "
"(JNI)](https://en.wikipedia.org/wiki/Java_Native_Interface). Cr캒iasa [`jni` "
"crate](https://docs.rs/jni/) v캒 permite s캒 crea탵i o bibliotec캒 compatibil캒."

#: src/android/interoperability/java.md:7
#, fuzzy
msgid "First, we create a Rust function to export to Java:"
msgstr "Mai 칥nt칙i, cre캒m o func탵ie Rust pentru a exporta 칥n Java:"

#: src/android/interoperability/java.md:9
#, fuzzy
msgid "_interoperability/java/src/lib.rs_:"
msgstr "interoperabilitate/java/src/lib.rs_:"

#: src/android/interoperability/java.md:11
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"//! Rust <-> Java FFI demo.\n"
"\n"
"use jni::objects::{JClass, JString};\n"
"use jni::sys::jstring;\n"
"use jni::JNIEnv;\n"
"\n"
"/// HelloWorld::hello method implementation.\n"
"#[no_mangle]\n"
"pub extern \"system\" fn Java_HelloWorld_hello(\n"
"    env: JNIEnv,\n"
"    _class: JClass,\n"
"    name: JString,\n"
") -> jstring {\n"
"    let input: String = env.get_string(name).unwrap().into();\n"
"    let greeting = format!(\"Hello, {input}!\");\n"
"    let output = env.new_string(greeting).unwrap();\n"
"    output.into_inner()\n"
"}\n"
"```"
msgstr ""
"```rust,compile_fail\n"
"//! Rust <-> Java FFI demo.\n"
"\n"
"folosi탵i jni::objects::{JClass, JString};\n"
"use jni::sys::jstring;\n"
"use jni::JNIEnv;\n"
"\n"
"/// Implementarea metodei HelloWorld::hello.\n"
"#[no_mangle]\n"
"pub extern \"system\" fn Java_HelloWorld_hello(\n"
"    env: JNIEnv,\n"
"    _class: JClass,\n"
"    name: JString,\n"
") -&gt; jstring {\n"
"    let input: String = env.get_string(name).unwrap().into();\n"
"    let greeting = format!(\"Hello, {input}!\");\n"
"    let output = env.new_string(greeting).unwrap();\n"
"    output.into_inner()\n"
"}\n"
"```"

#: src/android/interoperability/java.md:32
#: src/android/interoperability/java.md:62
#, fuzzy
msgid "_interoperability/java/Android.bp_:"
msgstr "interoperabilitate/java/Android.bp_:"

#: src/android/interoperability/java.md:34
#, fuzzy
msgid ""
"```javascript\n"
"rust_ffi_shared {\n"
"    name: \"libhello_jni\",\n"
"    crate_name: \"hello_jni\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    rustlibs: [\"libjni\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_ffi_shared {\n"
"    nume: \"libhello_jni\",\n"
"    crate_name: \"hello_jni\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    rustlibs: [\"libjni\"],\n"
"}\n"
"```"

#: src/android/interoperability/java.md:43
#, fuzzy
msgid "Finally, we can call this function from Java:"
msgstr "칉n cele din urm캒, putem apela aceast캒 func탵ie din Java:"

#: src/android/interoperability/java.md:45
#, fuzzy
msgid "_interoperability/java/HelloWorld.java_:"
msgstr "interoperabilitate/java/HelloWorld.java_:"

#: src/android/interoperability/java.md:47
#, fuzzy
msgid ""
"```java\n"
"class HelloWorld {\n"
"    private static native String hello(String name);\n"
"\n"
"    static {\n"
"        System.loadLibrary(\"hello_jni\");\n"
"    }\n"
"\n"
"    public static void main(String[] args) {\n"
"        String output = HelloWorld.hello(\"Alice\");\n"
"        System.out.println(output);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```java\n"
"clasa HelloWorld {\n"
"    private static nativ privat String hello(String name);\n"
"\n"
"    static {\n"
"        System.loadLibrary(\"hello_jni\");\n"
"    }\n"
"\n"
"    public static void main(String[] args) {\n"
"        String output = HelloWorld.hello(\"Alice\");\n"
"        System.out.println(output);\n"
"    }\n"
"}\n"
"```"

#: src/android/interoperability/java.md:64
#, fuzzy
msgid ""
"```javascript\n"
"java_binary {\n"
"    name: \"helloworld_jni\",\n"
"    srcs: [\"HelloWorld.java\"],\n"
"    main_class: \"HelloWorld\",\n"
"    required: [\"libhello_jni\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"java_binary {\n"
"    name: \"helloworld_jni\",\n"
"    srcs: [\"HelloWorld.java\"],\n"
"    main_class: \"HelloWorld\",\n"
"    required: [\"libhello_jni\"],\n"
"}\n"
"```"

#: src/android/interoperability/java.md:73
#, fuzzy
msgid "Finally, you can build, sync, and run the binary:"
msgstr ""
"칉n cele din urm캒, pute탵i s캒 construi탵i, s캒 sincroniza탵i 탳i s캒 executa탵i "
"programul binar:"

#: src/exercises/android/morning.md:3
#, fuzzy
msgid ""
"This is a group exercise: We will look at one of the projects you work with "
"and try to integrate some Rust into it. Some suggestions:"
msgstr ""
"Acesta este un exerci탵iu de grup: Ne vom uita la unul dintre proiectele la "
"care lucra탵i 탳i vom 칥ncerca s캒 integr캒m 칥n el Rust. C칙teva sugestii:"

#: src/exercises/android/morning.md:6
#, fuzzy
msgid "Call your AIDL service with a client written in Rust."
msgstr "Apela탵i serviciul AIDL cu un client scris 칥n Rust."

#: src/exercises/android/morning.md:8
#, fuzzy
msgid "Move a function from your project to Rust and call it."
msgstr "Muta탵i o func탵ie din proiectul dvs. 칥n Rust 탳i apela탵i-o."

#: src/exercises/android/morning.md:12
#, fuzzy
msgid ""
"No solution is provided here since this is open-ended: it relies on someone "
"in the class having a piece of code which you can turn in to Rust on the fly."
msgstr ""
"Nu se ofer캒 nicio solu탵ie aici, deoarece este o 칥ntrebare deschis캒: se "
"bazeaz캒 pe faptul c캒 cineva din clas캒 are o bucat캒 de cod pe care o pute탵i "
"transforma 칥n Rust din mers."

#: src/bare-metal.md:1
#, fuzzy
msgid "Welcome to Bare Metal Rust"
msgstr "Bine a탵i venit la Bare Metal Rust"

#: src/bare-metal.md:3
#, fuzzy
msgid ""
"This is a standalone one-day course about bare-metal Rust, aimed at people "
"who are familiar with the basics of Rust (perhaps from completing the "
"Comprehensive Rust course), and ideally also have some experience with bare-"
"metal programming in some other language such as C."
msgstr ""
"Acesta este un curs independent de o zi despre Rust, care se adreseaz캒 "
"persoanelor care sunt familiarizate cu elementele de baz캒 ale Rust (poate 칥n "
"urma absolvirii cursului Comprehensive Rust) 탳i care, 칥n mod ideal, au 탳i o "
"anumit캒 experien탵캒 칥n programarea bare-metal 칥ntr-un alt limbaj, cum ar fi C."

#: src/bare-metal.md:7
#, fuzzy
msgid ""
"Today we will talk about 'bare-metal' Rust: running Rust code without an OS "
"underneath us. This will be divided into several parts:"
msgstr ""
"Ast캒zi vom vorbi despre Rust \"bare-metal\": rularea codului Rust f캒r캒 un "
"sistem de operare sub noi. Acest subiect va fi 칥mp캒r탵it 칥n mai multe p캒r탵i:"

#: src/bare-metal.md:10
#, fuzzy
msgid "What is `no_std` Rust?"
msgstr "Ce este `no_std` Rust?"

#: src/bare-metal.md:11
#, fuzzy
msgid "Writing firmware for microcontrollers."
msgstr "Scrierea de firmware pentru microcontrolere."

#: src/bare-metal.md:12
#, fuzzy
msgid "Writing bootloader / kernel code for application processors."
msgstr "Scrierea codului bootloader / kernel pentru procesoarele de aplica탵ii."

#: src/bare-metal.md:13
#, fuzzy
msgid "Some useful crates for bare-metal Rust development."
msgstr "C칙teva l캒di탵e utile pentru dezvoltarea Rust pe suport metalic gol."

#: src/bare-metal.md:15
#, fuzzy
msgid ""
"For the microcontroller part of the course we will use the [BBC micro:bit]"
"(https://microbit.org/) v2 as an example. It's a [development board](https://"
"tech.microbit.org/hardware/) based on the Nordic nRF51822 microcontroller "
"with some LEDs and buttons, an I2C-connected accelerometer and compass, and "
"an on-board SWD debugger."
msgstr ""
"Pentru partea de microcontroler a cursului vom folosi [BBC micro:bit]"
"(https://microbit.org/) v2 ca exemplu. Este o [plac캒 de dezvoltare](https://"
"tech.microbit.org/hardware/) bazat캒 pe microcontrolerul Nordic nRF51822 cu "
"c칙teva LED-uri 탳i butoane, un accelerometru 탳i o busol캒 conectate I2C 탳i un "
"depanator SWD la bord."

#: src/bare-metal.md:20
#, fuzzy
msgid ""
"To get started, install some tools we'll need later. On gLinux or Debian:"
msgstr ""
"Pentru a 칥ncepe, instala탵i c칙teva instrumente de care vom avea nevoie mai "
"t칙rziu. Pe gLinux sau Debian:"

#: src/bare-metal.md:30
#, fuzzy
msgid ""
"And give users in the `plugdev` group access to the micro:bit programmer:"
msgstr ""
"탲i oferi탵i utilizatorilor din grupul `plugdev` acces la programatorul micro:"
"bit:"

#: src/bare-metal.md:38 src/bare-metal/microcontrollers/debugging.md:27
#, fuzzy
msgid "On MacOS:"
msgstr "Pe MacOS:"

#: src/bare-metal/no_std.md:1
#, fuzzy
msgid "`no_std`"
msgstr "`no_std`"

#: src/bare-metal/no_std.md:7
#, fuzzy
msgid "`core`"
msgstr "`core`"

#: src/bare-metal/no_std.md:12 src/bare-metal/alloc.md:1
#, fuzzy
msgid "`alloc`"
msgstr "`alloc`"

#: src/bare-metal/no_std.md:17
#, fuzzy
msgid "`std`"
msgstr "`std`"

#: src/bare-metal/no_std.md:24
#, fuzzy
msgid "Slices, `&str`, `CStr`"
msgstr "Slices, `&str`, `CStr`"

#: src/bare-metal/no_std.md:25
#, fuzzy
msgid "`NonZeroU8`..."
msgstr "`NonZeroU8`..."

#: src/bare-metal/no_std.md:26
#, fuzzy
msgid "`Option`, `Result`"
msgstr "`Op탵iune`, `Rezultat`"

#: src/bare-metal/no_std.md:27
#, fuzzy
msgid "`Display`, `Debug`, `write!`..."
msgstr "`Display`, `Debug`, `write!`..."

#: src/bare-metal/no_std.md:29
#, fuzzy
msgid "`panic!`, `assert_eq!`..."
msgstr "`panic!`, `assert_eq!`..."

#: src/bare-metal/no_std.md:30
#, fuzzy
msgid "`NonNull` and all the usual pointer-related functions"
msgstr "`NonNull` 탳i toate func탵iile obi탳nuite legate de pointer"

#: src/bare-metal/no_std.md:31
#, fuzzy
msgid "`Future` and `async`/`await`"
msgstr "`Future` 탳i `async`/`await`"

#: src/bare-metal/no_std.md:32
#, fuzzy
msgid "`fence`, `AtomicBool`, `AtomicPtr`, `AtomicU32`..."
msgstr "`fence`, `AtomicBool`, `AtomicPtr`, `AtomicU32`..."

#: src/bare-metal/no_std.md:33
#, fuzzy
msgid "`Duration`"
msgstr "`Durat캒`"

#: src/bare-metal/no_std.md:38
#, fuzzy
msgid "`Box`, `Cow`, `Arc`, `Rc`"
msgstr "`Box`, `Cow`, `Arc`, `Rc`"

#: src/bare-metal/no_std.md:39
#, fuzzy
msgid "`Vec`, `BinaryHeap`, `BtreeMap`, `LinkedList`, `VecDeque`"
msgstr "`Vec`, `BinaryHeap`, `BtreeMap`, `LinkedList`, `VecDeque`"

#: src/bare-metal/no_std.md:40
#, fuzzy
msgid "`String`, `CString`, `format!`"
msgstr "`String`, `CString`, `format!`"

#: src/bare-metal/no_std.md:45
#, fuzzy
msgid "`Error`"
msgstr "`Error`"

#: src/bare-metal/no_std.md:47
#, fuzzy
msgid "`Mutex`, `Condvar`, `Barrier`, `Once`, `RwLock`, `mpsc`"
msgstr "`Mutex`, `Condvar`, `Barrier`, `Once`, `RwLock`, `mpsc`"

#: src/bare-metal/no_std.md:48
#, fuzzy
msgid "`File` and the rest of `fs`"
msgstr "`File` 탳i restul de `fs`"

#: src/bare-metal/no_std.md:49
#, fuzzy
msgid "`println!`, `Read`, `Write`, `Stdin`, `Stdout` and the rest of `io`"
msgstr "`println!`, `Read`, `Write`, `Stdin`, `Stdout` 탳i restul de `io`"

#: src/bare-metal/no_std.md:50
#, fuzzy
msgid "`Path`, `OsString`"
msgstr "`Path`, `OsString`"

#: src/bare-metal/no_std.md:51
#, fuzzy
msgid "`net`"
msgstr "`net`"

#: src/bare-metal/no_std.md:52
#, fuzzy
msgid "`Command`, `Child`, `ExitCode`"
msgstr "`Command`, `Child`, `ExitCode`"

#: src/bare-metal/no_std.md:53
#, fuzzy
msgid "`spawn`, `sleep` and the rest of `thread`"
msgstr "`spawn`, `sleep` 탳i restul de `thread`"

#: src/bare-metal/no_std.md:54
#, fuzzy
msgid "`SystemTime`, `Instant`"
msgstr "`SystemTime`, `Instant`"

#: src/bare-metal/no_std.md:62
#, fuzzy
msgid "`HashMap` depends on RNG."
msgstr "`HashMap` depinde de RNG."

#: src/bare-metal/no_std.md:63
#, fuzzy
msgid "`std` re-exports the contents of both `core` and `alloc`."
msgstr "`std` reexport캒 con탵inutul at칙t al lui `core` c칙t 탳i al lui `alloc`."

#: src/bare-metal/minimal.md:1
#, fuzzy
msgid "A minimal `no_std` program"
msgstr "Un program minimal `no_std`"

#: src/bare-metal/minimal.md:17
#, fuzzy
msgid "This will compile to an empty binary."
msgstr "Aceasta va compila un binar gol."

#: src/bare-metal/minimal.md:18
#, fuzzy
msgid "`std` provides a panic handler; without it we must provide our own."
msgstr ""
"`std` ofer캒 un gestionar de panic캒; 칥n lipsa acestuia, trebuie s캒 ne "
"furniz캒m propriul gestionar."

#: src/bare-metal/minimal.md:19
#, fuzzy
msgid "It can also be provided by another crate, such as `panic-halt`."
msgstr "Acesta poate fi furnizat 탳i de o alt캒 lad캒, cum ar fi `panic-halt`."

#: src/bare-metal/minimal.md:20
#, fuzzy
msgid ""
"Depending on the target, you may need to compile with `panic = \"abort\"` to "
"avoid an error about `eh_personality`."
msgstr ""
"칉n func탵ie de 탵int캒, este posibil s캒 fie nevoie s캒 compila탵i cu `panic = "
"\"abort\"` pentru a evita o eroare cu privire la `eh_personality`."

#: src/bare-metal/minimal.md:22
#, fuzzy
msgid ""
"Note that there is no `main` or any other entry point; it's up to you to "
"define your own entry point. This will typically involve a linker script and "
"some assembly code to set things up ready for Rust code to run."
msgstr ""
"Re탵ine탵i c캒 nu exist캒 niciun `main` sau alt punct de intrare; depinde de "
"dumneavoastr캒 s캒 v캒 defini탵i propriul punct de intrare. Acest lucru va "
"implica, de obicei, un script de linker 탳i ceva cod de asamblare pentru a "
"preg캒ti lucrurile pentru a permite rularea codului Rust."

#: src/bare-metal/alloc.md:3
#, fuzzy
msgid ""
"To use `alloc` you must implement a [global (heap) allocator](https://doc."
"rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html)."
msgstr ""
"Pentru a utiliza `alloc` trebuie s캒 implementa탵i un [alocator global (heap)]"
"(https://doc.rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html)."

#: src/bare-metal/alloc.md:6
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate alloc;\n"
"extern crate panic_halt as _;\n"
"\n"
"use alloc::string::ToString;\n"
"use alloc::vec::Vec;\n"
"use buddy_system_allocator::LockedHeap;\n"
"\n"
"#[global_allocator]\n"
"static HEAP_ALLOCATOR: LockedHeap<32> = LockedHeap::<32>::new();\n"
"\n"
"static mut HEAP: [u8; 65536] = [0; 65536];\n"
"\n"
"pub fn entry() {\n"
"    // Safe because `HEAP` is only used here and `entry` is only called "
"once.\n"
"    unsafe {\n"
"        // Give the allocator some memory to allocate.\n"
"        HEAP_ALLOCATOR\n"
"            .lock()\n"
"            .init(HEAP.as_mut_ptr() as usize, HEAP.len());\n"
"    }\n"
"\n"
"    // Now we can do things that require heap allocation.\n"
"    let mut v = Vec::new();\n"
"    v.push(\"A string\".to_string());\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate alloc;\n"
"extern crate panic_halt as _;\n"
"\n"
"folosi탵i alloc::string::ToString;\n"
"use alloc::vec::Vec;\n"
"use buddy_system_allocator::LockedHeap;\n"
"\n"
"#[global_allocator]\n"
"static HEAP_ALLOCATOR: LockedHeap<32> = LockedHeap:::<32>::new();\n"
"\n"
"static mut HEAP: [u8; 65536] = [0; 65536];\n"
"\n"
"pub fn entry() {\n"
"    // Sigur, deoarece `HEAP` este folosit doar aici 탳i `entry` este apelat "
"o singur캒 dat캒.\n"
"    unsafe {\n"
"        // Da탵i alocatorului o anumit캒 memorie de alocat.\n"
"        HEAP_ALLOCATOR\n"
"            .lock()\n"
"            .init(HEAP.as_mut_ptr() as usize, HEAP.len());\n"
"    }\n"
"\n"
"    // Acum putem face lucruri care necesit캒 alocarea heap.\n"
"    let mut v = Vec::new();\n"
"    v.push(\"Un 탳ir de caractere\".to_string());\n"
"}\n"
"```"

#: src/bare-metal/alloc.md:39
#, fuzzy
msgid ""
"`buddy_system_allocator` is a third-party crate implementing a basic buddy "
"system allocator. Other crates are available, or you can write your own or "
"hook into your existing allocator."
msgstr ""
"`buddy_system_allocator` este un crate ter탵 care implementeaz캒 un alocator "
"de baz캒 pentru sistemul de prieteni. Sunt disponibile 탳i alte crates, sau "
"pute탵i s캒 v캒 scrie탵i propriul alocator sau s캒 v캒 conecta탵i la alocatorul "
"existent."

#: src/bare-metal/alloc.md:41
#, fuzzy
msgid ""
"The const parameter of `LockedHeap` is the max order of the allocator; i.e. "
"in this case it can allocate regions of up to 2\\*\\*32 bytes."
msgstr ""
"Parametrul const al `LockedHeap` este ordinea maxim캒 a alocatorului; adic캒, "
"칥n acest caz, acesta poate aloca regiuni de p칙n캒 la 2\\*\\*32 octe탵i."

#: src/bare-metal/alloc.md:43
#, fuzzy
msgid ""
"If any crate in your dependency tree depends on `alloc` then you must have "
"exactly one global allocator defined in your binary. Usually this is done in "
"the top-level binary crate."
msgstr ""
"Dac캒 orice crate din arborele de dependen탵캒 depinde de `alloc`, atunci "
"trebuie s캒 ave탵i exact un alocator global definit 칥n binarul dumneavoastr캒. "
"De obicei, acest lucru se face 칥n crate-ul binar de nivel superior."

#: src/bare-metal/alloc.md:45
#, fuzzy
msgid ""
"`extern crate panic_halt as _` is necessary to ensure that the `panic_halt` "
"crate is linked in so we get its panic handler."
msgstr ""
"`extern crate panic_halt as _` este necesar pentru a ne asigura c캒 crate-ul "
"`panic_halt` este legat, astfel 칥nc칙t s캒 ob탵inem gestionarul de panic캒 al "
"acestuia."

#: src/bare-metal/alloc.md:47
#, fuzzy
msgid "This example will build but not run, as it doesn't have an entry point."
msgstr ""
"Acest exemplu va fi construit, dar nu va fi executat, deoarece nu are un "
"punct de intrare."

#: src/bare-metal/microcontrollers.md:3
#, fuzzy
msgid ""
"The `cortex_m_rt` crate provides (among other things) a reset handler for "
"Cortex M microcontrollers."
msgstr ""
"Crate `cortex_m_rt` ofer캒 (printre altele) un gestionar de resetare pentru "
"microcontrolerele Cortex M."

#: src/bare-metal/microcontrollers.md:21
#, fuzzy
msgid ""
"Next we'll look at how to access peripherals, with increasing levels of "
"abstraction."
msgstr ""
"칉n continuare, vom examina modul de accesare a perifericelor, cu niveluri de "
"abstractizare din ce 칥n ce mai mari."

#: src/bare-metal/microcontrollers.md:25
#, fuzzy
msgid ""
"The `cortex_m_rt::entry` macro requires that the function have type `fn() -"
"> !`, because returning to the reset handler doesn't make sense."
msgstr ""
"Macroul `cortex_m_rt::entry` necesit캒 ca func탵ia s캒 aib캒 tipul `fn() -> !`, "
"deoarece 칥ntoarcerea la gestionarul de resetare nu are sens."

#: src/bare-metal/microcontrollers.md:27
#, fuzzy
msgid "Run the example with `cargo embed --bin minimal`"
msgstr "Rula탵i exemplul cu `cargo embed --bin minimal`"

#: src/bare-metal/microcontrollers/mmio.md:3
#, fuzzy
msgid ""
"Most microcontrollers access peripherals via memory-mapped IO. Let's try "
"turning on an LED on our micro:bit:"
msgstr ""
"Majoritatea microcontrolerelor acceseaz캒 perifericele prin intermediul IO "
"mapate 칥n memorie. S캒 칥ncerc캒m s캒 aprindem un LED pe micro:bit-ul nostru:"

#: src/bare-metal/microcontrollers/mmio.md:6
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"mod interrupts;\n"
"\n"
"use core::mem::size_of;\n"
"use cortex_m_rt::entry;\n"
"\n"
"/// GPIO port 0 peripheral address\n"
"const GPIO_P0: usize = 0x5000_0000;\n"
"\n"
"// GPIO peripheral offsets\n"
"const PIN_CNF: usize = 0x700;\n"
"const OUTSET: usize = 0x508;\n"
"const OUTCLR: usize = 0x50c;\n"
"\n"
"// PIN_CNF fields\n"
"const DIR_OUTPUT: u32 = 0x1;\n"
"const INPUT_DISCONNECT: u32 = 0x1 << 1;\n"
"const PULL_DISABLED: u32 = 0x0 << 2;\n"
"const DRIVE_S0S1: u32 = 0x0 << 8;\n"
"const SENSE_DISABLED: u32 = 0x0 << 16;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
"    let pin_cnf_21 = (GPIO_P0 + PIN_CNF + 21 * size_of::<u32>()) as *mut "
"u32;\n"
"    let pin_cnf_28 = (GPIO_P0 + PIN_CNF + 28 * size_of::<u32>()) as *mut "
"u32;\n"
"    // Safe because the pointers are to valid peripheral control registers, "
"and\n"
"    // no aliases exist.\n"
"    unsafe {\n"
"        pin_cnf_21.write_volatile(\n"
"            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | "
"SENSE_DISABLED,\n"
"        );\n"
"        pin_cnf_28.write_volatile(\n"
"            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | "
"SENSE_DISABLED,\n"
"        );\n"
"    }\n"
"\n"
"    // Set pin 28 low and pin 21 high to turn the LED on.\n"
"    let gpio0_outset = (GPIO_P0 + OUTSET) as *mut u32;\n"
"    let gpio0_outclr = (GPIO_P0 + OUTCLR) as *mut u32;\n"
"    // Safe because the pointers are to valid peripheral control registers, "
"and\n"
"    // no aliases exist.\n"
"    unsafe {\n"
"        gpio0_outclr.write_volatile(1 << 28);\n"
"        gpio0_outset.write_volatile(1 << 21);\n"
"    }\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"mod 칥ntreruperi;\n"
"\n"
"use core::mem::size_of;\n"
"use cortex_m_rt::entry;\n"
"\n"
"/// Adresa periferic캒 a portului GPIO 0\n"
"const GPIO_P0: usize = 0x5000_0000;\n"
"\n"
"// Decalajele perifericelor GPIO\n"
"const PIN_CNF: usize = 0x700;\n"
"const OUTSET: usize = 0x508;\n"
"const OUTCLR: usize = 0x50c;\n"
"\n"
"// c칙mpuri PIN_CNF\n"
"const DIR_OUTPUT: u32 = 0x1;\n"
"const INPUT_DISCONNECT: u32 = 0x1 &lt;&lt; 1;\n"
"const PULL_DISABLED: u32 = 0x0 &lt;&lt; 2;\n"
"const DRIVE_S0S1: u32 = 0x0 &lt;&lt; 8;\n"
"const SENSE_DISABLED: u32 = 0x0 &lt;< 16;\n"
"\n"
"#[entry]\n"
"fn main() ->! {\n"
"    // Configura탵i pinii GPIO 0 21 탳i 28 ca ie탳iri push-pull.\n"
"    let pin_cnf_21 = (GPIO_P0 + PIN_CNF + 21 * size_of:::<u32>())) as *mut "
"u32;\n"
"    let pin_cnf_28 = (GPIO_P0 + PIN_CNF + 28 * size_of:::<u32>())) as *mut "
"u32;\n"
"    // Sigur, deoarece indicatorii sunt c캒tre registre de control periferice "
"valide 탳i\n"
"    // nu exist캒 alias-uri.\n"
"    unsafe {\n"
"        pin_cnf_21.write_volatile(\n"
"            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | "
"SENSE_DISABLED,\n"
"        );\n"
"        pin_cnf_28.write_volatile(\n"
"            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | "
"SENSE_DISABLED,\n"
"        );\n"
"    }\n"
"\n"
"    // Seta탵i pinul 28 la nivel sc캒zut 탳i pinul 21 la nivel ridicat pentru a "
"aprinde LED-ul.\n"
"    let gpio0_outset = (GPIO_P0 + OUTSET) as *mut u32;\n"
"    let gpio0_outclr = (GPIO_P0 + OUTCLR) as *mut u32;\n"
"    // Sigur, deoarece indicatorii sunt la registre de control periferice "
"valide 탳i\n"
"    // nu exist캒 alias-uri.\n"
"    unsafe {\n"
"        gpio0_outclr.write_volatile(1 &lt;&lt; 28);\n"
"        gpio0_outset.write_volatile(1 &lt;&lt; 21);\n"
"    }\n"
"\n"
"    loop {}\n"
"}\n"
"```"

#: src/bare-metal/microcontrollers/mmio.md:64
#, fuzzy
msgid ""
"GPIO 0 pin 21 is connected to the first column of the LED matrix, and pin 28 "
"to the first row."
msgstr ""
"Pinul 21 al GPIO 0 este conectat la prima coloan캒 a matricei de LED-uri, iar "
"pinul 28 la primul r칙nd."

#: src/bare-metal/microcontrollers/mmio.md:66
#: src/bare-metal/microcontrollers/pacs.md:59
#: src/bare-metal/microcontrollers/hals.md:43
#: src/bare-metal/microcontrollers/board-support.md:34
#, fuzzy
msgid "Run the example with:"
msgstr "Rula탵i exemplul cu:"

#: src/bare-metal/microcontrollers/pacs.md:1
#, fuzzy
msgid "Peripheral Access Crates"
msgstr "L캒zi de acces periferic"

#: src/bare-metal/microcontrollers/pacs.md:3
#, fuzzy
msgid ""
"[`svd2rust`](https://crates.io/crates/svd2rust) generates mostly-safe Rust "
"wrappers for memory-mapped peripherals from [CMSIS-SVD](https://www.keil.com/"
"pack/doc/CMSIS/SVD/html/index.html) files."
msgstr ""
"[`svd2rust`](https://crates.io/crates/svd2rust) genereaz캒 칥nveli탳uri Rust 칥n "
"mare parte sigure pentru perifericele cu memorie map캒 din fi탳ierele [CMSIS-"
"SVD](https://www.keil.com/pack/doc/CMSIS/SVD/html/index.html)."

#: src/bare-metal/microcontrollers/pacs.md:7
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use cortex_m_rt::entry;\n"
"use nrf52833_pac::Peripherals;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let p = Peripherals::take().unwrap();\n"
"    let gpio0 = p.P0;\n"
"\n"
"    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
"    gpio0.pin_cnf[21].write(|w| {\n"
"        w.dir().output();\n"
"        w.input().disconnect();\n"
"        w.pull().disabled();\n"
"        w.drive().s0s1();\n"
"        w.sense().disabled();\n"
"        w\n"
"    });\n"
"    gpio0.pin_cnf[28].write(|w| {\n"
"        w.dir().output();\n"
"        w.input().disconnect();\n"
"        w.pull().disabled();\n"
"        w.drive().s0s1();\n"
"        w.sense().disabled();\n"
"        w\n"
"    });\n"
"\n"
"    // Set pin 28 low and pin 21 high to turn the LED on.\n"
"    gpio0.outclr.write(|w| w.pin28().clear());\n"
"    gpio0.outset.write(|w| w.pin21().set());\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use cortex_m_rt::entry;\n"
"use nrf52833_pac::Peripherals;\n"
"\n"
"#[intrare]\n"
"fn main() -> ! {\n"
"    let p = Peripherals::take().unwrap();\n"
"    let gpio0 = p.P0;\n"
"\n"
"    // Configura탵i pinii GPIO 0 21 탳i 28 ca ie탳iri push-pull.\n"
"    gpio0.pin_cnf[21].write(|w| {\n"
"        w.dir().output();\n"
"        w.input().disconnect();\n"
"        w.pull().dezactivat();\n"
"        w.drive().s0s1();\n"
"        w.sense().disabled();\n"
"        w\n"
"    });\n"
"    gpio0.pin_cnf[28].write(|w| {\n"
"        w.dir().output();\n"
"        w.intrare().deconectare();\n"
"        w.pull().dezactivat();\n"
"        w.drive().s0s1();\n"
"        w.sense().disabled();\n"
"        w\n"
"    });\n"
"\n"
"    // Seta탵i pinul 28 la nivel sc캒zut 탳i pinul 21 la nivel ridicat pentru a "
"aprinde LED-ul.\n"
"    gpio0.outclr.write(|w| w.pin28().clear());\n"
"    gpio0.outset.write(|w| w.pin21().set());\n"
"\n"
"    bucla {}\n"
"}\n"
"```"

#: src/bare-metal/microcontrollers/pacs.md:49
#, fuzzy
msgid ""
"SVD (System View Description) files are XML files typically provided by "
"silicon vendors which describe the memory map of the device."
msgstr ""
"Fi탳ierele SVD (System View Description) sunt fi탳iere XML furnizate de obicei "
"de furnizorii de siliciu care descriu harta de memorie a dispozitivului."

#: src/bare-metal/microcontrollers/pacs.md:51
#, fuzzy
msgid ""
"They are organised by peripheral, register, field and value, with names, "
"descriptions, addresses and so on."
msgstr ""
"Acestea sunt organizate 칥n func탵ie de periferic, registru, c칙mp 탳i valoare, "
"cu nume, descrieri, adrese etc."

#: src/bare-metal/microcontrollers/pacs.md:53
#, fuzzy
msgid ""
"SVD files are often buggy and incomplete, so there are various projects "
"which patch the mistakes, add missing details, and publish the generated "
"crates."
msgstr ""
"Fi탳ierele SVD sunt deseori eronate 탳i incomplete, a탳a c캒 exist캒 diverse "
"proiecte care corecteaz캒 gre탳elile, adaug캒 detaliile lips캒 탳i public캒 "
"l캒di탵ele generate."

#: src/bare-metal/microcontrollers/pacs.md:55
#, fuzzy
msgid "`cortex-m-rt` provides the vector table, among other things."
msgstr "`cortex-m-rt` furnizeaz캒, printre altele, tabelul vectorial."

#: src/bare-metal/microcontrollers/pacs.md:56
#, fuzzy
msgid ""
"If you `cargo install cargo-binutils` then you can run `cargo objdump --bin "
"pac -- -d --no-show-raw-insn` to see the resulting binary."
msgstr ""
"Dac캒 instala탵i `cargo install cargo-binutils` atunci pute탵i rula `cargo "
"objdump --bin pac -- -d --no-show-raw-insn` pentru a vedea binarul rezultat."

#: src/bare-metal/microcontrollers/hals.md:1
#, fuzzy
msgid "HAL crates"
msgstr "L캒zi HAL"

#: src/bare-metal/microcontrollers/hals.md:3
#, fuzzy
msgid ""
"[HAL crates](https://github.com/rust-embedded/awesome-embedded-rust#hal-"
"implementation-crates) for many microcontrollers provide wrappers around "
"various peripherals. These generally implement traits from [`embedded-hal`]"
"(https://crates.io/crates/embedded-hal)."
msgstr ""
"[HAL crates](https://github.com/rust-embedded/awesome-embedded-rust#hal-"
"implementation-crates) pentru multe microcontrolere ofer캒 칥nveli탳uri 칥n "
"jurul diferitelor periferice. Acestea implementeaz캒 칥n general tr캒s캒turi din "
"[`embedded-hal`](https://crates.io/crates/embedded-hal)."

#: src/bare-metal/microcontrollers/hals.md:7
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use cortex_m_rt::entry;\n"
"use nrf52833_hal::gpio::{p0, Level};\n"
"use nrf52833_hal::pac::Peripherals;\n"
"use nrf52833_hal::prelude::*;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let p = Peripherals::take().unwrap();\n"
"\n"
"    // Create HAL wrapper for GPIO port 0.\n"
"    let gpio0 = p0::Parts::new(p.P0);\n"
"\n"
"    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
"    let mut col1 = gpio0.p0_28.into_push_pull_output(Level::High);\n"
"    let mut row1 = gpio0.p0_21.into_push_pull_output(Level::Low);\n"
"\n"
"    // Set pin 28 low and pin 21 high to turn the LED on.\n"
"    col1.set_low().unwrap();\n"
"    row1.set_high().unwrap();\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use cortex_m_rt::entry;\n"
"use nrf52833_hal::gpio::{p0, Level};\n"
"use nrf52833_hal::pac::Peripherals;\n"
"use nrf52833_hal::prelude::*;\n"
"\n"
"#[intrare]\n"
"fn main() -> ! {\n"
"    let p = Peripherals::take().unwrap();\n"
"\n"
"    // Creeaz캒 un HAL wrapper pentru portul GPIO 0.\n"
"    let gpio0 = p0::Parts::new(p.P0);\n"
"\n"
"    // Configura탵i pinii GPIO 0 21 탳i 28 ca ie탳iri push-pull.\n"
"    let mut col1 = gpio0.p0_28.into_push_pull_output(Level::High);\n"
"    let mut row1 = gpio0.p0_21.into_push_pull_output(Level::Low);\n"
"\n"
"    // Seta탵i pinul 28 la nivel sc캒zut 탳i pinul 21 la nivel ridicat pentru a "
"aprinde LED-ul.\n"
"    col1.set_low().unwrap();\n"
"    row1.set_high().unwrap();\n"
"\n"
"    bucla {}\n"
"}\n"
"```"

#: src/bare-metal/microcontrollers/hals.md:39
#, fuzzy
msgid ""
"`set_low` and `set_high` are methods on the `embedded_hal` `OutputPin` trait."
msgstr ""
"`set_low` 탳i `set_high` sunt metode ale tr캒s캒turii `OutputPin` "
"`embedded_hal`."

#: src/bare-metal/microcontrollers/hals.md:40
#, fuzzy
msgid ""
"HAL crates exist for many Cortex-M and RISC-V devices, including various "
"STM32, GD32, nRF, NXP, MSP430, AVR and PIC microcontrollers."
msgstr ""
"HAL crates exist캒 pentru multe dispozitive Cortex-M 탳i RISC-V, inclusiv "
"pentru diverse microcontrolere STM32, GD32, nRF, NXP, MSP430, AVR 탳i PIC."

#: src/bare-metal/microcontrollers/board-support.md:1
#, fuzzy
msgid "Board support crates"
msgstr "Suport de bord l캒zi"

#: src/bare-metal/microcontrollers/board-support.md:3
#, fuzzy
msgid ""
"Board support crates provide a further level of wrapping for a specific "
"board for convenience."
msgstr ""
"L캒zile de sus탵inere a pl캒cilor ofer캒 un nivel suplimentar de 칥mpachetare "
"pentru o anumit캒 plac캒, pentru mai mult캒 comoditate."

#: src/bare-metal/microcontrollers/board-support.md:28
#, fuzzy
msgid ""
"In this case the board support crate is just providing more useful names, "
"and a bit of initialisation."
msgstr ""
"칉n acest caz, suportul pentru pl캒ci ofer캒 doar nume mai utile 탳i o mic캒 "
"ini탵ializare."

#: src/bare-metal/microcontrollers/board-support.md:30
#, fuzzy
msgid ""
"The crate may also include drivers for some on-board devices outside of the "
"microcontroller itself."
msgstr ""
"De asemenea, pachetul poate include drivere pentru unele dispozitive de la "
"bord 칥n afara microcontrolerului propriu-zis."

#: src/bare-metal/microcontrollers/board-support.md:32
#, fuzzy
msgid "`microbit-v2` includes a simple driver for the LED matrix."
msgstr "`microbit-v2` include un driver simplu pentru matricea de LED-uri."

#: src/bare-metal/microcontrollers/type-state.md:1
#, fuzzy
msgid "The type state pattern"
msgstr "Modelul de stare de tip"

#: src/bare-metal/microcontrollers/type-state.md:3
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let p = Peripherals::take().unwrap();\n"
"    let gpio0 = p0::Parts::new(p.P0);\n"
"\n"
"    let pin: P0_01<Disconnected> = gpio0.p0_01;\n"
"\n"
"    // let gpio0_01_again = gpio0.p0_01; // Error, moved.\n"
"    let pin_input: P0_01<Input<Floating>> = pin.into_floating_input();\n"
"    if pin_input.is_high().unwrap() {\n"
"        // ...\n"
"    }\n"
"    let mut pin_output: P0_01<Output<OpenDrain>> = pin_input\n"
"        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, "
"Level::Low);\n"
"    pin_output.set_high().unwrap();\n"
"    // pin_input.is_high(); // Error, moved.\n"
"\n"
"    let _pin2: P0_02<Output<OpenDrain>> = gpio0\n"
"        .p0_02\n"
"        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, "
"Level::Low);\n"
"    let _pin3: P0_03<Output<PushPull>> = gpio0.p0_03."
"into_push_pull_output(Level::Low);\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"#[intrare]\n"
"fn main() -&gt; ! {\n"
"    let p = Peripherals::take().unwrap();\n"
"    let gpio0 = p0::Parts::new(p.P0);\n"
"\n"
"    let pin: P0_01<Disconnected> = gpio0.p0_01;\n"
"\n"
"    // let gpio0_01_01_again = gpio0.p0_01; // Error, moved.\n"
"    let pin_input: P0_01&lt;Input<Floating>&gt; = pin."
"into_floating_input();\n"
"    if pin_input.is_high().unwrap() {\n"
"        // ...\n"
"    }\n"
"    let mut pin_output: P0_01&lt;Output<OpenDrain>&gt; = pin_input\n"
"        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, "
"Level::Low);\n"
"    pin_output.set_high().unwrap();\n"
"    // pin_input.is_high(); // Eroare, mutat.\n"
"\n"
"    let _pin2: P0_02&lt;Output<OpenDrain>&gt; = gpio0\n"
"        .p0_02\n"
"        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, "
"Level::Low);\n"
"    let _pin3: P0_03&lt;Output<PushPull>&gt; = gpio0.p0_03."
"into_push_pull_output(Level::Low);\n"
"\n"
"    bucla {}\n"
"}\n"
"```"

#: src/bare-metal/microcontrollers/type-state.md:32
#, fuzzy
msgid ""
"Pins don't implement `Copy` or `Clone`, so only one instance of each can "
"exist. Once a pin is moved out of the port struct nobody else can take it."
msgstr ""
"Pinii nu implementeaz캒 `Copy` sau `Clone`, astfel 칥nc칙t poate exista doar o "
"singur캒 instan탵캒 a fiec캒ruia. Odat캒 ce un pin este mutat din structura "
"portului, nimeni altcineva nu 칥l poate lua."

#: src/bare-metal/microcontrollers/type-state.md:34
#, fuzzy
msgid ""
"Changing the configuration of a pin consumes the old pin instance, so you "
"can뗪 keep use the old instance afterwards."
msgstr ""
"Schimbarea configura탵iei unui pin consum캒 vechea instan탵캒 de pin, astfel "
"칥nc칙t nu mai pute탵i continua s캒 folosi탵i vechea instan탵캒 dup캒 aceea."

#: src/bare-metal/microcontrollers/type-state.md:36
#, fuzzy
msgid ""
"The type of a value indicates the state that it is in: e.g. in this case, "
"the configuration state of a GPIO pin. This encodes the state machine into "
"the type system, and ensures that you don't try to use a pin in a certain "
"way without properly configuring it first. Illegal state transitions are "
"caught at compile time."
msgstr ""
"Tipul unei valori indic캒 starea 칥n care se afl캒 aceasta: de exemplu, 칥n "
"acest caz, starea de configurare a unui pin GPIO. Acest lucru codific캒 "
"ma탳ina de stare 칥n sistemul de tipuri 탳i garanteaz캒 c캒 nu 칥ncerca탵i s캒 "
"utiliza탵i un pin 칥ntr-un anumit mod f캒r캒 s캒-l configura탵i mai 칥nt칙i 칥n mod "
"corespunz캒tor. Tranzi탵iile de stare ilegale sunt detectate 칥n momentul "
"compil캒rii."

#: src/bare-metal/microcontrollers/type-state.md:40
#, fuzzy
msgid ""
"You can call `is_high` on an input pin and `set_high` on an output pin, but "
"not vice-versa."
msgstr ""
"Pute탵i apela `is_high` pe un pin de intrare 탳i `set_high` pe un pin de "
"ie탳ire, dar nu 탳i invers."

#: src/bare-metal/microcontrollers/type-state.md:41
#, fuzzy
msgid "Many HAL crates follow this pattern."
msgstr "Multe l캒zi HAL urmeaz캒 acest model."

#: src/bare-metal/microcontrollers/embedded-hal.md:1
#, fuzzy
msgid "`embedded-hal`"
msgstr "`embedded-hal`"

#: src/bare-metal/microcontrollers/embedded-hal.md:3
#, fuzzy
msgid ""
"The [`embedded-hal`](https://crates.io/crates/embedded-hal) crate provides a "
"number of traits covering common microcontroller peripherals."
msgstr ""
"Cr캒iasa [`embedded-hal`](https://crates.io/crates/embedded-hal) ofer캒 o "
"serie de caracteristici care acoper캒 perifericele comune ale "
"microcontrolerului."

#: src/bare-metal/microcontrollers/embedded-hal.md:6
#, fuzzy
msgid "GPIO"
msgstr "GPIO"

#: src/bare-metal/microcontrollers/embedded-hal.md:7
#, fuzzy
msgid "ADC"
msgstr "ADC"

#: src/bare-metal/microcontrollers/embedded-hal.md:8
#, fuzzy
msgid "I2C, SPI, UART, CAN"
msgstr "I2C, SPI, UART, CAN"

#: src/bare-metal/microcontrollers/embedded-hal.md:9
#, fuzzy
msgid "RNG"
msgstr "RNG"

#: src/bare-metal/microcontrollers/embedded-hal.md:10
#, fuzzy
msgid "Timers"
msgstr "Cronometre"

#: src/bare-metal/microcontrollers/embedded-hal.md:11
#, fuzzy
msgid "Watchdogs"
msgstr "C칙ini de paz캒"

#: src/bare-metal/microcontrollers/embedded-hal.md:13
#, fuzzy
msgid ""
"Other crates then implement [drivers](https://github.com/rust-embedded/"
"awesome-embedded-rust#driver-crates) in terms of these traits, e.g. an "
"accelerometer driver might need an I2C or SPI bus implementation."
msgstr ""
"Alte crates implementeaz캒 apoi [drivere](https://github.com/rust-embedded/"
"awesome-embedded-rust#driver-crates) 칥n func탵ie de aceste caracteristici, de "
"exemplu, un driver pentru accelerometru poate avea nevoie de o implementare "
"a bus-ului I2C sau SPI."

#: src/bare-metal/microcontrollers/embedded-hal.md:19
#, fuzzy
msgid ""
"There are implementations for many microcontrollers, as well as other "
"platforms such as Linux on Raspberry Pi."
msgstr ""
"Exist캒 implement캒ri pentru multe microcontrolere, precum 탳i pentru alte "
"platforme, cum ar fi Linux pe Raspberry Pi."

#: src/bare-metal/microcontrollers/embedded-hal.md:21
#, fuzzy
msgid ""
"There is work in progress on an `async` version of `embedded-hal`, but it "
"isn't stable yet."
msgstr ""
"Se lucreaz캒 칥n prezent la o versiune `async` a `embedded-hal`, dar nu este "
"칥nc캒 stabil캒."

#: src/bare-metal/microcontrollers/probe-rs.md:1
#, fuzzy
msgid "`probe-rs`, `cargo-embed`"
msgstr "`probe-rs`, `cargo-embed`"

#: src/bare-metal/microcontrollers/probe-rs.md:3
#, fuzzy
msgid ""
"[probe-rs](https://probe.rs/) is a handy toolset for embedded debugging, "
"like OpenOCD but better integrated."
msgstr ""
"[probe-rs](https://probe.rs/) este un set de instrumente utile pentru "
"depanarea embedded, precum OpenOCD, dar mai bine integrat."

#: src/bare-metal/microcontrollers/probe-rs.md:6
#, fuzzy
msgid ""
"SWD (Serial Wire Debug) and JTAG via CMSIS-DAP, ST-Link and J-Link probes"
msgstr ""
"SWD (Serial Wire Debug) 탳i JTAG prin sonde CMSIS-DAP, ST-Link 탳i J-Link"

#: src/bare-metal/microcontrollers/probe-rs.md:7
#, fuzzy
msgid "GDB stub and Microsoft DAP (Debug Adapter Protocol) server"
msgstr "GDB stub 탳i serverul Microsoft DAP (Debug Adapter Protocol)"

#: src/bare-metal/microcontrollers/probe-rs.md:8
#, fuzzy
msgid "Cargo integration"
msgstr "Integrarea 칥nc캒rc캒turii"

#: src/bare-metal/microcontrollers/probe-rs.md:10
#, fuzzy
msgid ""
"`cargo-embed` is a cargo subcommand to build and flash binaries, log RTT "
"(Real Time Transfers) output and connect GDB. It's configured by an `Embed."
"toml` file in your project directory."
msgstr ""
"`cargo-embed` este o subcomand캒 cargo pentru a construi 탳i afi탳a binare, a "
"칥nregistra ie탳irea RTT (Real Time Transfers) 탳i a conecta GDB. Este "
"configurat캒 de un fi탳ier `Embed.toml` din directorul proiectului "
"dumneavoastr캒."

#: src/bare-metal/microcontrollers/probe-rs.md:16
#, fuzzy
msgid ""
"[CMSIS-DAP](https://arm-software.github.io/CMSIS_5/DAP/html/index.html) is "
"an Arm standard protocol over USB for an in-circuit debugger to access the "
"CoreSight Debug Access Port of various Arm Cortex processors. It's what the "
"on-board debugger on the BBC micro:bit uses."
msgstr ""
"[CMSIS-DAP](https://arm-software.github.io/CMSIS_5/DAP/html/index.html) este "
"un protocol standard Arm prin USB pentru ca un depanator in-circuit s캒 "
"acceseze portul de acces la depanare CoreSight al diferitelor procesoare Arm "
"Cortex. Este ceea ce folose탳te depanatorul de bord de pe BBC micro:bit."

#: src/bare-metal/microcontrollers/probe-rs.md:19
#, fuzzy
msgid ""
"ST-Link is a range of in-circuit debuggers from ST Microelectronics, J-Link "
"is a range from SEGGER."
msgstr ""
"ST-Link este o gam캒 de depanatoare 칥n circuit de la ST Microelectronics, iar "
"J-Link este o gam캒 de la SEGGER."

#: src/bare-metal/microcontrollers/probe-rs.md:21
#, fuzzy
msgid ""
"The Debug Access Port is usually either a 5-pin JTAG interface or 2-pin "
"Serial Wire Debug."
msgstr ""
"Portul de acces pentru depanare este, de obicei, fie o interfa탵캒 JTAG cu 5 "
"pini, fie o interfa탵캒 de depanare prin cablu serial cu 2 pini."

#: src/bare-metal/microcontrollers/probe-rs.md:22
#, fuzzy
msgid ""
"probe-rs is a library which you can integrate into your own tools if you "
"want to."
msgstr ""
"probe-rs este o bibliotec캒 pe care o pute탵i integra 칥n propriile "
"instrumente, dac캒 dori탵i."

#: src/bare-metal/microcontrollers/probe-rs.md:23
#, fuzzy
msgid ""
"The [Microsoft Debug Adapter Protocol](https://microsoft.github.io/debug-"
"adapter-protocol/) lets VSCode and other IDEs debug code running on any "
"supported microcontroller."
msgstr ""
"[Microsoft Debug Adapter Protocol](https://microsoft.github.io/debug-adapter-"
"protocol/) permite VSCode 탳i altor IDE-uri s캒 depaneze codul care ruleaz캒 pe "
"orice microcontroler acceptat."

#: src/bare-metal/microcontrollers/probe-rs.md:25
#, fuzzy
msgid "cargo-embed is a binary built using the probe-rs library."
msgstr "cargo-embed este un binar construit folosind biblioteca probe-rs."

#: src/bare-metal/microcontrollers/probe-rs.md:26
#, fuzzy
msgid ""
"RTT (Real Time Transfers) is a mechanism to transfer data between the debug "
"host and the target through a number of ringbuffers."
msgstr ""
"RTT (Real Time Transfers) este un mecanism de transfer de date 칥ntre gazda "
"de depanare 탳i 탵int캒 prin intermediul unui num캒r de ringbufferi."

#: src/bare-metal/microcontrollers/debugging.md:3
#, fuzzy
msgid "_Embed.toml_:"
msgstr "_Embed.toml_:"

#: src/bare-metal/microcontrollers/debugging.md:13
#, fuzzy
msgid "In one terminal under `src/bare-metal/microcontrollers/examples/`:"
msgstr "칉ntr-un terminal, sub `src/bare-metal/microcontrollers/examples/`:"

#: src/bare-metal/microcontrollers/debugging.md:19
#, fuzzy
msgid "In another terminal in the same directory:"
msgstr "칉ntr-un alt terminal din acela탳i director:"

#: src/bare-metal/microcontrollers/debugging.md:21
#, fuzzy
msgid "On gLinux or Debian:"
msgstr "Pe gLinux sau Debian:"

#: src/bare-metal/microcontrollers/debugging.md:34
#, fuzzy
msgid "In GDB, try running:"
msgstr "칉n GDB, 칥ncerca탵i s캒 rula탵i:"

#: src/bare-metal/microcontrollers/other-projects.md:1
#: src/bare-metal/aps/other-projects.md:1
#, fuzzy
msgid "Other projects"
msgstr "Alte proiecte"

#: src/bare-metal/microcontrollers/other-projects.md:3
#, fuzzy
msgid "[RTIC](https://rtic.rs/)"
msgstr "[RTIC](https://rtic.rs/)"

#: src/bare-metal/microcontrollers/other-projects.md:4
#, fuzzy
msgid "\"Real-Time Interrupt-driven Concurrency\""
msgstr "\"Concurren탵a 칥n timp real bazat캒 pe 칥ntreruperi\""

#: src/bare-metal/microcontrollers/other-projects.md:5
#, fuzzy
msgid ""
"Shared resource management, message passing, task scheduling, timer queue"
msgstr ""
"Gestionarea resurselor partajate, trecerea mesajelor, programarea "
"sarcinilor, coada de timp"

#: src/bare-metal/microcontrollers/other-projects.md:6
#, fuzzy
msgid "[Embassy](https://embassy.dev/)"
msgstr "[Ambasada](https://embassy.dev/)"

#: src/bare-metal/microcontrollers/other-projects.md:7
#, fuzzy
msgid "`async` executors with priorities, timers, networking, USB"
msgstr "executori `async` cu priorit캒탵i, cronometre, re탵ea, USB"

#: src/bare-metal/microcontrollers/other-projects.md:8
#, fuzzy
msgid "[TockOS](https://www.tockos.org/documentation/getting-started)"
msgstr "[TockOS](https://www.tockos.org/documentation/getting-started)"

#: src/bare-metal/microcontrollers/other-projects.md:9
#, fuzzy
msgid ""
"Security-focused RTOS with preemptive scheduling and Memory Protection Unit "
"support"
msgstr ""
"RTOS axat pe securitate, cu programare preemptiv캒 탳i suport pentru unitatea "
"de protec탵ie a memoriei"

#: src/bare-metal/microcontrollers/other-projects.md:10
#, fuzzy
msgid "[Hubris](https://hubris.oxide.computer/)"
msgstr "[Hubris](https://hubris.oxide.computer/)"

#: src/bare-metal/microcontrollers/other-projects.md:11
#, fuzzy
msgid ""
"Microkernel RTOS from Oxide Computer Company with memory protection, "
"unprivileged drivers, IPC"
msgstr ""
"Microkernel RTOS de la Oxide Computer Company cu protec탵ie de memorie, "
"drivere neprivilegiate, IPC"

#: src/bare-metal/microcontrollers/other-projects.md:12
#, fuzzy
msgid "[Bindings for FreeRTOS](https://github.com/lobaro/FreeRTOS-rust)"
msgstr "[Leg캒turi pentru FreeRTOS](https://github.com/lobaro/FreeRTOS-rust)"

#: src/bare-metal/microcontrollers/other-projects.md:13
#, fuzzy
msgid ""
"Some platforms have `std` implementations, e.g. [esp-idf](https://esp-rs."
"github.io/book/overview/using-the-standard-library.html)."
msgstr ""
"Unele platforme au implement캒ri `std`, de exemplu [esp-idf](https://esp-rs."
"github.io/book/overview/using-the-standard-library.html)."

#: src/bare-metal/microcontrollers/other-projects.md:18
#, fuzzy
msgid "RTIC can be considered either an RTOS or a concurrency framework."
msgstr "RTIC poate fi considerat fie un RTOS, fie un cadru de concuren탵캒."

#: src/bare-metal/microcontrollers/other-projects.md:19
#, fuzzy
msgid "It doesn't include any HALs."
msgstr "Nu include niciun HAL."

#: src/bare-metal/microcontrollers/other-projects.md:20
#, fuzzy
msgid ""
"It uses the Cortex-M NVIC (Nested Virtual Interrupt Controller) for "
"scheduling rather than a proper kernel."
msgstr ""
"Acesta utilizeaz캒 Cortex-M NVIC (Nested Virtual Interrupt Controller) pentru "
"programare, 칥n loc de un kernel propriu-zis."

#: src/bare-metal/microcontrollers/other-projects.md:22
#, fuzzy
msgid "Cortex-M only."
msgstr "Numai Cortex-M."

#: src/bare-metal/microcontrollers/other-projects.md:23
#, fuzzy
msgid ""
"Google uses TockOS on the Haven microcontroller for Titan security keys."
msgstr ""
"Google folose탳te TockOS pe microcontrolerul Haven pentru cheile de "
"securitate Titan."

#: src/bare-metal/microcontrollers/other-projects.md:24
#, fuzzy
msgid ""
"FreeRTOS is mostly written in C, but there are Rust bindings for writing "
"applications."
msgstr ""
"FreeRTOS este scris 칥n mare parte 칥n C, dar exist캒 leg캒turi Rust pentru "
"scrierea de aplica탵ii."

#: src/exercises/bare-metal/morning.md:3
#, fuzzy
msgid ""
"We will read the direction from an I2C compass, and log the readings to a "
"serial port."
msgstr ""
"Vom citi direc탵ia de la o busol캒 I2C 탳i vom 칥nregistra citirile pe un port "
"serial."

#: src/exercises/bare-metal/compass.md:3
#, fuzzy
msgid ""
"We will read the direction from an I2C compass, and log the readings to a "
"serial port. If you have time, try displaying it on the LEDs somehow too, or "
"use the buttons somehow."
msgstr ""
"Vom citi direc탵ia de la o busol캒 I2C 탳i vom 칥nregistra citirile pe un port "
"serial. Dac캒 ave탵i timp, 칥ncerca탵i s캒 o afi탳a탵i cumva 탳i pe LED-uri sau s캒 "
"folosi탵i cumva butoanele."

#: src/exercises/bare-metal/compass.md:6
#, fuzzy
msgid "Hints:"
msgstr "Sugestii:"

#: src/exercises/bare-metal/compass.md:8
#, fuzzy
msgid ""
"Check the documentation for the [`lsm303agr`](https://docs.rs/lsm303agr/"
"latest/lsm303agr/) and [`microbit-v2`](https://docs.rs/microbit-v2/latest/"
"microbit/) crates, as well as the [micro:bit hardware](https://tech.microbit."
"org/hardware/)."
msgstr ""
"Consulta탵i documenta탵ia pentru pachetele [`lsm303agr`](https://docs.rs/"
"lsm303agr/latest/lsm303agr/) 탳i [`microbit-v2`](https://docs.rs/microbit-v2/"
"latest/microbit/), precum 탳i pentru [micro:bit hardware](https://tech."
"microbit.org/hardware/)."

#: src/exercises/bare-metal/compass.md:11
#, fuzzy
msgid ""
"The LSM303AGR Inertial Measurement Unit is connected to the internal I2C bus."
msgstr ""
"Unitatea de m캒surare iner탵ial캒 LSM303AGR este conectat캒 la magistrala "
"intern캒 I2C."

#: src/exercises/bare-metal/compass.md:12
#, fuzzy
msgid ""
"TWI is another name for I2C, so the I2C master peripheral is called TWIM."
msgstr ""
"TWI este un alt nume pentru I2C, astfel 칥nc칙t perifericul master I2C se "
"nume탳te TWIM."

#: src/exercises/bare-metal/compass.md:13
#, fuzzy
msgid ""
"The LSM303AGR driver needs something implementing the `embedded_hal::"
"blocking::i2c::WriteRead` trait. The [`microbit::hal::Twim`](https://docs.rs/"
"microbit-v2/latest/microbit/hal/struct.Twim.html) struct implements this."
msgstr ""
"Driverul LSM303AGR are nevoie de ceva care s캒 implementeze tr캒s캒tura "
"`embedded_hal::blocking::i2c::WriteRead`. Structura [`microbit::hal::Twim`]"
"(https://docs.rs/microbit-v2/latest/microbit/hal/struct.Twim.html) "
"implementeaz캒 acest lucru."

#: src/exercises/bare-metal/compass.md:17
#, fuzzy
msgid ""
"You have a [`microbit::Board`](https://docs.rs/microbit-v2/latest/microbit/"
"struct.Board.html) struct with fields for the various pins and peripherals."
msgstr ""
"Ave탵i o structur캒 [`microbit::Board`](https://docs.rs/microbit-v2/latest/"
"microbit/struct.Board.html) cu c칙mpuri pentru diver탳i pini 탳i periferice."

#: src/exercises/bare-metal/compass.md:19
#, fuzzy
msgid ""
"You can also look at the [nRF52833 datasheet](https://infocenter.nordicsemi."
"com/pdf/nRF52833_PS_v1.5.pdf) if you want, but it shouldn't be necessary for "
"this exercise."
msgstr ""
"Dac캒 dori탵i, pute탵i consulta 탳i [nRF52833 datasheet](https://infocenter."
"nordicsemi.com/pdf/nRF52833_PS_v1.5.pdf), dar nu ar trebui s캒 fie necesar "
"pentru acest exerci탵iu."

#: src/exercises/bare-metal/compass.md:23
#, fuzzy
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and "
"look in the `compass` directory for the following files."
msgstr ""
"Desc캒rca탵i [탳ablonul de exerci탵ii] (../../comprehensive-rust-exercises.zip) "
"탳i c캒uta탵i 칥n directorul `compass` urm캒toarele fi탳iere."

#: src/exercises/bare-metal/compass.md:26 src/exercises/bare-metal/rtc.md:19
#, fuzzy
msgid "_src/main.rs_:"
msgstr "src/main.rs_:"

#: src/exercises/bare-metal/compass.md:30
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use core::fmt::Write;\n"
"use cortex_m_rt::entry;\n"
"use microbit::{hal::uarte::{Baudrate, Parity, Uarte}, Board};\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let board = Board::take().unwrap();\n"
"\n"
"    // Configure serial port.\n"
"    let mut serial = Uarte::new(\n"
"        board.UARTE0,\n"
"        board.uart.into(),\n"
"        Parity::EXCLUDED,\n"
"        Baudrate::BAUD115200,\n"
"    );\n"
"\n"
"    // Set up the I2C controller and Inertial Measurement Unit.\n"
"    // TODO\n"
"\n"
"    writeln!(serial, \"Ready.\").unwrap();\n"
"\n"
"    loop {\n"
"        // Read compass data and log it to the serial port.\n"
"        // TODO\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use core::fmt::Write;\n"
"use cortex_m_rt::entry;\n"
"use microbit::{hal::uarte::{Baudrate, Parity, Uarte}, Board};\n"
"\n"
"#[intrare]\n"
"fn main() -> ! {\n"
"    let board = Board::take().unwrap();\n"
"\n"
"    // Configura탵i portul serial.\n"
"    let mut serial = Uarte::new(\n"
"        board.UARTE0,\n"
"        board.uart.into(),\n"
"        Parity::EXCLUDED,\n"
"        Baudrate::BAUD115200,\n"
"    );\n"
"\n"
"    // Configura탵i controlerul I2C 탳i unitatea de m캒surare iner탵ial캒.\n"
"    // TODO\n"
"\n"
"    writeln!(serial, \"Ready.\").unwrap();\n"
"\n"
"    bucl캒 {\n"
"        // Citi탵i datele busolei 탳i 칥nregistra탵i-le pe portul serial.\n"
"        // TODO\n"
"    }\n"
"}\n"
"```"

#: src/exercises/bare-metal/compass.md:64 src/exercises/bare-metal/rtc.md:385
#, fuzzy
msgid "_Cargo.toml_ (you shouldn't need to change this):"
msgstr "_Cargo.toml_ (nu ar trebui s캒 fie nevoie s캒 modifica탵i acest lucru):"

#: src/exercises/bare-metal/compass.md:85
#, fuzzy
msgid "_Embed.toml_ (you shouldn't need to change this):"
msgstr "_Embed.toml_ (nu ar trebui s캒 fie nevoie s캒 modifica탵i acest lucru):"

#: src/exercises/bare-metal/compass.md:100 src/exercises/bare-metal/rtc.md:985
#, fuzzy
msgid "_.cargo/config.toml_ (you shouldn't need to change this):"
msgstr ""
"_.cargo/config.toml_ (nu ar trebui s캒 fie nevoie s캒 modifica탵i acest lucru):"

#: src/exercises/bare-metal/compass.md:112
#, fuzzy
msgid "See the serial output on Linux with:"
msgstr "Vede탵i ie탳irea serial캒 pe Linux cu:"

#: src/exercises/bare-metal/compass.md:118
#, fuzzy
msgid ""
"Or on Mac OS something like (the device name may be slightly different):"
msgstr ""
"Sau, pe Mac OS, ceva de genul (numele dispozitivului poate fi u탳or diferit):"

#: src/exercises/bare-metal/compass.md:124
#, fuzzy
msgid "Use Ctrl+A Ctrl+Q to quit picocom."
msgstr "Folosi탵i Ctrl+A Ctrl+Q pentru a ie탳i din picocom."

#: src/bare-metal/aps.md:1
#, fuzzy
msgid "Application processors"
msgstr "Procesoare de aplica탵ii"

#: src/bare-metal/aps.md:3
#, fuzzy
msgid ""
"So far we've talked about microcontrollers, such as the Arm Cortex-M series. "
"Now let's try writing something for Cortex-A. For simplicity we'll just work "
"with QEMU's aarch64 ['virt'](https://qemu-project.gitlab.io/qemu/system/arm/"
"virt.html) board."
msgstr ""
"P칙n캒 acum am vorbit despre microcontrolere, cum ar fi seria Arm Cortex-M. "
"Acum s캒 칥ncerc캒m s캒 scriem ceva pentru Cortex-A. Pentru simplitate, vom "
"lucra doar cu placa aarch64 ['virt'](https://qemu-project.gitlab.io/qemu/"
"system/arm/virt.html) a lui QEMU."

#: src/bare-metal/aps.md:9
#, fuzzy
msgid ""
"Broadly speaking, microcontrollers don't have an MMU or multiple levels of "
"privilege (exception levels on Arm CPUs, rings on x86), while application "
"processors do."
msgstr ""
"칉n linii mari, microcontrolerele nu au un MMU sau mai multe niveluri de "
"privilegii (niveluri de excep탵ie la procesoarele Arm, inele la x86), 칥n timp "
"ce procesoarele de aplica탵ii au."

#: src/bare-metal/aps.md:11
#, fuzzy
msgid ""
"QEMU supports emulating various different machines or board models for each "
"architecture. The 'virt' board doesn't correspond to any particular real "
"hardware, but is designed purely for virtual machines."
msgstr ""
"QEMU suport캒 emularea mai multor ma탳ini sau modele de pl캒ci diferite pentru "
"fiecare arhitectur캒. Placa \"virt\" nu corespunde unui anumit hardware real, "
"ci este conceput캒 exclusiv pentru ma탳ini virtuale."

#: src/bare-metal/aps/entry-point.md:3
#, fuzzy
msgid ""
"Before we can start running Rust code, we need to do some initialisation."
msgstr ""
"칉nainte de a 칥ncepe s캒 rul캒m codul Rust, trebuie s캒 facem o anumit캒 "
"ini탵ializare."

#: src/bare-metal/aps/entry-point.md:5
#, fuzzy
msgid ""
"```armasm\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"    /*\n"
"     * Load and apply the memory management configuration, ready to enable "
"MMU and\n"
"     * caches.\n"
"     */\n"
"    adrp x30, idmap\n"
"    msr ttbr0_el1, x30\n"
"\n"
"    mov_i x30, .Lmairval\n"
"    msr mair_el1, x30\n"
"\n"
"    mov_i x30, .Ltcrval\n"
"    /* Copy the supported PA range into TCR_EL1.IPS. */\n"
"    mrs x29, id_aa64mmfr0_el1\n"
"    bfi x30, x29, #32, #4\n"
"\n"
"    msr tcr_el1, x30\n"
"\n"
"    mov_i x30, .Lsctlrval\n"
"\n"
"    /*\n"
"     * Ensure everything before this point has completed, then invalidate "
"any\n"
"     * potentially stale local TLB entries before they start being used.\n"
"     */\n"
"    isb\n"
"    tlbi vmalle1\n"
"    ic iallu\n"
"    dsb nsh\n"
"    isb\n"
"\n"
"    /*\n"
"     * Configure sctlr_el1 to enable MMU and cache and don't proceed until "
"this\n"
"     * has completed.\n"
"     */\n"
"    msr sctlr_el1, x30\n"
"    isb\n"
"\n"
"    /* Disable trapping floating point access in EL1. */\n"
"    mrs x30, cpacr_el1\n"
"    orr x30, x30, #(0x3 << 20)\n"
"    msr cpacr_el1, x30\n"
"    isb\n"
"\n"
"    /* Zero out the bss section. */\n"
"    adr_l x29, bss_begin\n"
"    adr_l x30, bss_end\n"
"0:  cmp x29, x30\n"
"    b.hs 1f\n"
"    stp xzr, xzr, [x29], #16\n"
"    b 0b\n"
"\n"
"1:  /* Prepare the stack. */\n"
"    adr_l x30, boot_stack_end\n"
"    mov sp, x30\n"
"\n"
"    /* Set up exception vector. */\n"
"    adr x30, vector_table_el1\n"
"    msr vbar_el1, x30\n"
"\n"
"    /* Call into Rust code. */\n"
"    bl main\n"
"\n"
"    /* Loop forever waiting for interrupts. */\n"
"2:  wfi\n"
"    b 2b\n"
"```"
msgstr ""
"```armasm\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"intrare:\n"
"    /*\n"
"     * 칉nc캒rca탵i 탳i aplica탵i configura탵ia de gestionare a memoriei, "
"preg캒tit캒 pentru a activa MMU 탳i\n"
"     * memoria cache.\n"
"     */\n"
"    adrp x30, idmap\n"
"    msr ttbr0_el1, x30\n"
"\n"
"    mov_i x30, .Lmairval\n"
"    msr mair_el1, x30\n"
"\n"
"    mov_i x30, .Ltcrval\n"
"    /* Copiaz캒 intervalul PA acceptat 칥n TCR_EL1.IPS. */\n"
"    mrs x29, id_aa64mmfr0_el1\n"
"    bfi x30, x29, #32, #4\n"
"\n"
"    msr tcr_el1, x30\n"
"\n"
"    mov_i x30, .Lsctlrval\n"
"\n"
"    /*\n"
"     * Asigur캒-te c캒 tot ceea ce a precedat acest punct s-a finalizat, apoi "
"invalideaz캒 orice\n"
"     * toate intr캒rile TLB locale poten탵ial vechi 칥nainte de a 칥ncepe s캒 fie "
"utilizate.\n"
"     */\n"
"    isb\n"
"    tlbi vmalle1\n"
"    ic iallu\n"
"    dsb nsh\n"
"    isb\n"
"\n"
"    /*\n"
"     * Configura탵i sctlr_el1 pentru a activa MMU 탳i memoria cache 탳i nu "
"continua탵i p칙n캒 c칙nd acest lucru\n"
"     * nu este finalizat캒.\n"
"     */\n"
"    msr sctlr_el1, x30\n"
"    isb\n"
"\n"
"    /* Dezactiveaz캒 captarea accesului 칥n virgul캒 mobil캒 칥n EL1. */\n"
"    mrs x30, cpacr_el1\n"
"    orr x30, x30, #(0x3 << 20)\n"
"    msr cpacr_el1, x30\n"
"    isb\n"
"\n"
"    /* Elimin캒 sec탵iunea bss. */\n"
"    adr_l x29, bss_begin\n"
"    adr_l x30, bss_end\n"
"0: cmp x29, x30\n"
"    b.hs 1f\n"
"    stp xzr, xzr, [x29], #16\n"
"    b 0b\n"
"\n"
"1: /* Preg캒te탳te stiva. */\n"
"    adr_l x30, boot_stack_end\n"
"    mov sp, x30\n"
"\n"
"    /* Seteaz캒 vectorul de excep탵ie. */\n"
"    adr x30, vector_table_el1\n"
"    msr vbar_el1, x30\n"
"\n"
"    /* Apel 칥n codul Rust. */\n"
"    bl main\n"
"\n"
"    /* Bucl캒 ve탳nic캒 칥n a탳teptarea 칥ntreruperilor. */\n"
"2: wfi\n"
"    b 2b\n"
"```"

#: src/bare-metal/aps/entry-point.md:77
#, fuzzy
msgid ""
"This is the same as it would be for C: initialising the processor state, "
"zeroing the BSS, and setting up the stack pointer."
msgstr ""
"Aceasta este aceea탳i ca 탳i 칥n C: ini탵ializarea st캒rii procesorului, anularea "
"BSS 탳i stabilirea pointerului de stiv캒."

#: src/bare-metal/aps/entry-point.md:79
#, fuzzy
msgid ""
"The BSS (block starting symbol, for historical reasons) is the part of the "
"object file which containing statically allocated variables which are "
"initialised to zero. They are omitted from the image, to avoid wasting space "
"on zeroes. The compiler assumes that the loader will take care of zeroing "
"them."
msgstr ""
"BSS (simbolul de pornire al blocului, din motive istorice) este partea din "
"fi탳ierul obiect care con탵ine variabilele alocate static care sunt "
"ini탵ializate la zero. Acestea sunt omise din imagine, pentru a se evita "
"risipa de spa탵iu cu zerouri. Compilatorul porne탳te de la premisa c캒 "
"칥nc캒rc캒torul se va ocupa de punerea lor la zero."

#: src/bare-metal/aps/entry-point.md:83
#, fuzzy
msgid ""
"The BSS may already be zeroed, depending on how memory is initialised and "
"the image is loaded, but we zero it to be sure."
msgstr ""
"Este posibil ca BSS s캒 fie deja zero, 칥n func탵ie de modul 칥n care memoria "
"este ini탵ializat캒 탳i imaginea este 칥nc캒rcat캒, dar trebuie s캒 칥l punem la "
"zero pentru a fi siguri."

#: src/bare-metal/aps/entry-point.md:85
#, fuzzy
msgid ""
"We need to enable the MMU and cache before reading or writing any memory. If "
"we don't:"
msgstr ""
"Trebuie s캒 activ캒m MMU 탳i memoria cache 칥nainte de a citi sau scrie 칥n "
"memorie. Dac캒 nu o facem:"

#: src/bare-metal/aps/entry-point.md:86
#, fuzzy
msgid ""
"Unaligned accesses will fault. We build the Rust code for the `aarch64-"
"unknown-none` target which sets `+strict-align` to prevent the compiler "
"generating unaligned accesses, so it should be fine in this case, but this "
"is not necessarily the case in general."
msgstr ""
"Acces캒rile nealiniate vor fi defectuoase. Noi construim codul Rust pentru "
"탵inta `aarch64-unknown-none` care seteaz캒 `+strict-align` pentru a preveni "
"compilatorul s캒 genereze accese nealiniate, deci ar trebui s캒 fie 칥n regul캒 "
"칥n acest caz, dar nu este neap캒rat cazul 칥n general."

#: src/bare-metal/aps/entry-point.md:89
#, fuzzy
msgid ""
"If it were running in a VM, this can lead to cache coherency issues. The "
"problem is that the VM is accessing memory directly with the cache disabled, "
"while the host has cacheable aliases to the same memory. Even if the host "
"doesn't explicitly access the memory, speculative accesses can lead to cache "
"fills, and then changes from one or the other will get lost when the cache "
"is cleaned or the VM enables the cache. (Cache is keyed by physical address, "
"not VA or IPA.)"
msgstr ""
"Dac캒 ar fi rulat 칥ntr-o ma탳in캒 virtual캒, acest lucru poate duce la probleme "
"de coeren탵캒 a memoriei cache. Problema const캒 칥n faptul c캒 ma탳ina virtual캒 "
"acceseaz캒 memoria direct, cu memoria cache dezactivat캒, 칥n timp ce gazda are "
"alias-uri care pot fi stocate 칥n memoria cache pentru aceea탳i memorie. Chiar "
"dac캒 gazda nu acceseaz캒 칥n mod explicit memoria, acces캒rile speculative pot "
"duce la umplerea memoriei cache, iar apoi modific캒rile de la unul sau de la "
"cel캒lalt se vor pierde atunci c칙nd memoria cache este cur캒탵at캒 sau c칙nd VM "
"activeaz캒 memoria cache. (Memoria cache este codificat캒 칥n func탵ie de adresa "
"fizic캒, nu de VA sau IPA)"

#: src/bare-metal/aps/entry-point.md:94
#, fuzzy
msgid ""
"For simplicity, we just use a hardcoded pagetable (see `idmap.S`) which "
"identity maps the first 1 GiB of address space for devices, the next 1 GiB "
"for DRAM, and another 1 GiB higher up for more devices. This matches the "
"memory layout that QEMU uses."
msgstr ""
"Pentru simplitate, folosim doar o tabel캒 de pagini codificat캒 (a se vedea "
"`idmap.S`) care mapeaz캒 identitar primul 1 GiB de spa탵iu de adrese pentru "
"dispozitive, urm캒torul 1 GiB pentru DRAM 탳i 칥nc캒 1 GiB mai sus pentru mai "
"multe dispozitive. Acest lucru se potrive탳te cu dispunerea memoriei pe care "
"o folose탳te QEMU."

#: src/bare-metal/aps/entry-point.md:97
#, fuzzy
msgid ""
"We also set up the exception vector (`vbar_el1`), which we'll see more about "
"later."
msgstr ""
"De asemenea, am configurat vectorul de excep탵ii (`vbar_el1`), despre care "
"vom vedea mai multe mai t칙rziu."

#: src/bare-metal/aps/entry-point.md:98
#, fuzzy
msgid ""
"All examples this afternoon assume we will be running at exception level 1 "
"(EL1). If you need to run at a different exception level you'll need to "
"modify `entry.S` accordingly."
msgstr ""
"Toate exemplele din aceast캒 dup캒-amiaz캒 presupun c캒 vom func탵iona la nivelul "
"de excep탵ie 1 (EL1). Dac캒 ave탵i nevoie s캒 rula탵i la un alt nivel de "
"excep탵ie, va trebui s캒 modifica탵i `entry.S` 칥n consecin탵캒."

#: src/bare-metal/aps/inline-assembly.md:1
#, fuzzy
msgid "Inline assembly"
msgstr "Ansamblu 칥n linie"

#: src/bare-metal/aps/inline-assembly.md:3
#, fuzzy
msgid ""
"Sometimes we need to use assembly to do things that aren't possible with "
"Rust code. For example, to make an HVC (hypervisor call) to tell the "
"firmware to power off the system:"
msgstr ""
"Uneori trebuie s캒 folosim asamblarea pentru a face lucruri care nu sunt "
"posibile cu codul Rust. De exemplu, pentru a face un apel HVC (hypervisor "
"call) pentru a spune firmware-ului s캒 opreasc캒 sistemul:"

#: src/bare-metal/aps/inline-assembly.md:6
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"use core::arch::asm;\n"
"use core::panic::PanicInfo;\n"
"\n"
"mod exceptions;\n"
"\n"
"const PSCI_SYSTEM_OFF: u32 = 0x84000008;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(_x0: u64, _x1: u64, _x2: u64, _x3: u64) {\n"
"    // Safe because this only uses the declared registers and doesn't do\n"
"    // anything with memory.\n"
"    unsafe {\n"
"        asm!(\"hvc #0\",\n"
"            inout(\"w0\") PSCI_SYSTEM_OFF => _,\n"
"            inout(\"w1\") 0 => _,\n"
"            inout(\"w2\") 0 => _,\n"
"            inout(\"w3\") 0 => _,\n"
"            inout(\"w4\") 0 => _,\n"
"            inout(\"w5\") 0 => _,\n"
"            inout(\"w6\") 0 => _,\n"
"            inout(\"w7\") 0 => _,\n"
"            options(nomem, nostack)\n"
"        );\n"
"    }\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"use core::arch::asm;\n"
"use core::panic::PanicInfo;\n"
"\n"
"mod exceptions;\n"
"\n"
"const PSCI_SYSTEM_OFF: u32 = 0x84000008;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(_x0: u64, _x1: u64, _x2: u64, _x3: u64) {\n"
"    // Sigur pentru c캒 acest lucru folose탳te doar registrele declarate 탳i nu "
"face\n"
"    // nimic cu memoria.\n"
"    nesigur {\n"
"        asm!(\"hvc #0\",\n"
"            inout(\"w0\") PSCI_SYSTEM_OFF => _,\n"
"            inout(\"w1\") 0 => _,\n"
"            inout(\"w2\") 0 => _,\n"
"            inout(\"w3\") 0 => _,\n"
"            inout(\"w4\") 0 => _,\n"
"            inout(\"w5\") 0 => _,\n"
"            inout(\"w6\") 0 => _,\n"
"            inout(\"w7\") 0 => _,\n"
"            op탵iuni(nomem, nostack)\n"
"        );\n"
"    }\n"
"\n"
"    loop {}\n"
"}\n"
"```"

#: src/bare-metal/aps/inline-assembly.md:39
#, fuzzy
msgid ""
"(If you actually want to do this, use the [`smccc`](https://crates.io/crates/"
"smccc) crate which has wrappers for all these functions.)"
msgstr ""
"(Dac캒 dori탵i s캒 face탵i acest lucru, folosi탵i cr캒iasa [`smccc`](https://"
"crates.io/crates/smccc) care are 칥nveli탳uri pentru toate aceste func탵ii.)"

#: src/bare-metal/aps/inline-assembly.md:43
#, fuzzy
msgid ""
"PSCI is the Arm Power State Coordination Interface, a standard set of "
"functions to manage system and CPU power states, among other things. It is "
"implemented by EL3 firmware and hypervisors on many systems."
msgstr ""
"PSCI este Interfa탵a de coordonare a st캒rii de alimentare a bra탵ului, un set "
"standard de func탵ii pentru gestionarea st캒rii de alimentare a sistemului 탳i "
"a procesorului, printre altele. Este implementat캒 de firmware-ul EL3 탳i de "
"hipervizoarele de pe multe sisteme."

#: src/bare-metal/aps/inline-assembly.md:46
#, fuzzy
msgid ""
"The `0 => _` syntax means initialise the register to 0 before running the "
"inline assembly code, and ignore its contents afterwards. We need to use "
"`inout` rather than `in` because the call could potentially clobber the "
"contents of the registers."
msgstr ""
"Sintaxa `0 => _` 칥nseamn캒 ini탵ializarea registrului la 0 칥nainte de a rula "
"codul de asamblare 칥n linie 탳i ignorarea con탵inutului acestuia dup캒 aceea. "
"Trebuie s캒 folosim mai degrab캒 `inout` dec칙t `in` deoarece apelul ar putea "
"s캒 distrug캒 con탵inutul registrelor."

#: src/bare-metal/aps/inline-assembly.md:49
#, fuzzy
msgid ""
"This `main` function needs to be `#[no_mangle]` and `extern \"C\"` because "
"it is called from our entry point in `entry.S`."
msgstr ""
"Aceast캒 func탵ie `main` trebuie s캒 fie `#[no_mangle]` 탳i `extern \"C\"` "
"deoarece este apelat캒 din punctul nostru de intrare 칥n `entry.S`."

#: src/bare-metal/aps/inline-assembly.md:51
#, fuzzy
msgid ""
"`_x0``_x3` are the values of registers `x0``x3`, which are conventionally "
"used by the bootloader to pass things like a pointer to the device tree. "
"According to the standard aarch64 calling convention (which is what `extern "
"\"C\"` specifies to use), registers `x0``x7` are used for the first 8 "
"arguments passed to a function, so `entry.S` doesn't need to do anything "
"special except make sure it doesn't change these registers."
msgstr ""
"`_x0`-`_x3` sunt valorile registrelor `x0`-`x3`, care sunt utilizate 칥n mod "
"conven탵ional de c캒tre bootloader pentru a transmite lucruri precum un "
"pointer la arborele de dispozitive. 칉n conformitate cu conven탵ia standard de "
"apelare aarch64 (care este cea pe care `extern \"C\"` specific캒 s캒 o "
"foloseasc캒), registrele `x0`-`x7` sunt folosite pentru primele 8 argumente "
"transmise unei func탵ii, astfel 칥nc칙t `entry.S` nu trebuie s캒 fac캒 nimic "
"special, cu excep탵ia faptului c캒 trebuie s캒 se asigure c캒 nu modific캒 aceste "
"registre."

#: src/bare-metal/aps/inline-assembly.md:56
#, fuzzy
msgid ""
"Run the example in QEMU with `make qemu_psci` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"Rula탵i exemplul 칥n QEMU cu `make qemu_psci` 칥n `src/bare-metal/aps/examples`."

#: src/bare-metal/aps/mmio.md:1
#, fuzzy
msgid "Volatile memory access for MMIO"
msgstr "Acces la memoria volatil캒 pentru MMIO"

#: src/bare-metal/aps/mmio.md:3
#, fuzzy
msgid "Use `pointer::read_volatile` and `pointer::write_volatile`."
msgstr "Utiliza탵i `pointer::read_volatile` 탳i `pointer::write_volatile`."

#: src/bare-metal/aps/mmio.md:4
#, fuzzy
msgid "Never hold a reference."
msgstr "Nu 탵ine탵i niciodat캒 o referin탵캒."

#: src/bare-metal/aps/mmio.md:5
#, fuzzy
msgid ""
"`addr_of!` lets you get fields of structs without creating an intermediate "
"reference."
msgstr ""
"`addr_of!` v캒 permite s캒 ob탵ine탵i c칙mpurile structurilor f캒r캒 a crea o "
"referin탵캒 intermediar캒."

#: src/bare-metal/aps/mmio.md:9
#, fuzzy
msgid ""
"Volatile access: read or write operations may have side-effects, so prevent "
"the compiler or hardware from reordering, duplicating or eliding them."
msgstr ""
"Acces volatil: Opera탵iunile de citire sau scriere pot avea efecte secundare, "
"deci 칥mpiedica탵i compilatorul sau hardware-ul s캒 le reordoneze, s캒 le "
"dubleze sau s캒 le eludeze."

#: src/bare-metal/aps/mmio.md:11
#, fuzzy
msgid ""
"Usually if you write and then read, e.g. via a mutable reference, the "
"compiler may assume that the value read is the same as the value just "
"written, and not bother actually reading memory."
msgstr ""
"De obicei, dac캒 scrie탵i 탳i apoi citi탵i, de exemplu, prin intermediul unei "
"referin탵e mutabile, compilatorul poate presupune c캒 valoarea citit캒 este "
"aceea탳i cu cea care tocmai a fost scris캒 탳i nu se mai obose탳te s캒 citeasc캒 "
"efectiv memoria."

#: src/bare-metal/aps/mmio.md:13
#, fuzzy
msgid ""
"Some existing crates for volatile access to hardware do hold references, but "
"this is unsound. Whenever a reference exist, the compiler may choose to "
"dereference it."
msgstr ""
"Unele cutii existente pentru accesul volatil la hardware con탵in referin탵e, "
"dar acest lucru nu este corect. Ori de c칙te ori exist캒 o referin탵캒, "
"compilatorul poate alege s캒 o deregleze."

#: src/bare-metal/aps/mmio.md:15
#, fuzzy
msgid ""
"Use the `addr_of!` macro to get struct field pointers from a pointer to the "
"struct."
msgstr ""
"Utiliza탵i macroul `addr_of!` pentru a ob탵ine pointeri de c칙mpuri de "
"structur캒 dintr-un pointer la structur캒."

#: src/bare-metal/aps/uart.md:1
#, fuzzy
msgid "Let's write a UART driver"
msgstr "S캒 scriem un driver UART"

#: src/bare-metal/aps/uart.md:3
#, fuzzy
msgid ""
"The QEMU 'virt' machine has a [PL011](https://developer.arm.com/"
"documentation/ddi0183/g) UART, so let's write a driver for that."
msgstr ""
"Ma탳ina QEMU 'virt' are o UART [PL011](https://developer.arm.com/"
"documentation/ddi0183/g), a탳a c캒 haide탵i s캒 scriem un driver pentru aceasta."

#: src/bare-metal/aps/uart.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"const FLAG_REGISTER_OFFSET: usize = 0x18;\n"
"const FR_BUSY: u8 = 1 << 3;\n"
"const FR_TXFF: u8 = 1 << 5;\n"
"\n"
"/// Minimal driver for a PL011 UART.\n"
"#[derive(Debug)]\n"
"pub struct Uart {\n"
"    base_address: *mut u8,\n"
"}\n"
"\n"
"impl Uart {\n"
"    /// Constructs a new instance of the UART driver for a PL011 device at "
"the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the 8 MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
"    pub unsafe fn new(base_address: *mut u8) -> Self {\n"
"        Self { base_address }\n"
"    }\n"
"\n"
"    /// Writes a single byte to the UART.\n"
"    pub fn write_byte(&self, byte: u8) {\n"
"        // Wait until there is room in the TX buffer.\n"
"        while self.read_flag_register() & FR_TXFF != 0 {}\n"
"\n"
"        // Safe because we know that the base address points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe {\n"
"            // Write to the TX buffer.\n"
"            self.base_address.write_volatile(byte);\n"
"        }\n"
"\n"
"        // Wait until the UART is no longer busy.\n"
"        while self.read_flag_register() & FR_BUSY != 0 {}\n"
"    }\n"
"\n"
"    fn read_flag_register(&self) -> u8 {\n"
"        // Safe because we know that the base address points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe { self.base_address.add(FLAG_REGISTER_OFFSET)."
"read_volatile() }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"const FLAG_REGISTER_OFFSET: usize = 0x18;\n"
"const FR_BUSY: u8 = 1 << 3;\n"
"const FR_TXFF: u8 = 1 << 5;\n"
"\n"
"/// Driver minim pentru o UART PL011.\n"
"#[derive(Debug)]\n"
"pub struct Uart {\n"
"    base_address: *mut u8,\n"
"}\n"
"\n"
"impl Uart {\n"
"    /// Construie탳te o nou캒 instan탵캒 a driverului UART pentru un dispozitiv "
"PL011 la nivelul\n"
"    /// adresa de baz캒 dat캒.\n"
"    ///\n"
"    /// # Siguran탵캒\n"
"    ///\n"
"    /// Adresa de baz캒 dat캒 trebuie s캒 indice cele 8 registre de control "
"MMIO ale unui dispozitiv de tip\n"
"    /// PL011, care trebuie s캒 fie mapate 칥n spa탵iul de adrese al "
"procesului\n"
"    /// ca memorie a dispozitivului 탳i s캒 nu aib캒 alte pseudonime.\n"
"    pub unsafe fn new(base_address: *mut u8) -> Self {\n"
"        Self { base_address }\n"
"    }\n"
"\n"
"    /// Scrie un singur octet pe UART.\n"
"    pub fn write_byte(&self, byte: u8) {\n"
"        // A탳teapt캒 p칙n캒 c칙nd exist캒 loc 칥n memoria tampon TX.\n"
"        while self.read_flag_register() & FR_TXFF != 0 {}\n"
"\n"
"        // Sigur, deoarece 탳tim c캒 adresa de baz캒 indic캒 adresa de control\n"
"        // registre ale unui dispozitiv PL011 care este mapat "
"corespunz캒tor.\n"
"        nesigur {\n"
"            // Scrie탵i 칥n memoria tampon TX.\n"
"            self.base_address.write_volatile(byte);\n"
"        }\n"
"\n"
"        // A탳tepta탵i p칙n캒 c칙nd UART nu mai este ocupat캒.\n"
"        while self.read_flag_register() & FR_BUSY != 0 {}\n"
"    }\n"
"\n"
"    fn read_flag_register(&self) -> u8 {\n"
"        // 칉n siguran탵캒, deoarece 탳tim c캒 adresa de baz캒 indic캒 adresa de "
"control\n"
"        // registre ale unui dispozitiv PL011 care este mapat "
"corespunz캒tor.\n"
"        unsafe { self.base_address.add(FLAG_REGISTER_OFFSET)."
"read_volatile() } }\n"
"    }\n"
"}\n"
"```"

#: src/bare-metal/aps/uart.md:55
#, fuzzy
msgid ""
"Note that `Uart::new` is unsafe while the other methods are safe. This is "
"because as long as the caller of `Uart::new` guarantees that its safety "
"requirements are met (i.e. that there is only ever one instance of the "
"driver for a given UART, and nothing else aliasing its address space), then "
"it is always safe to call `write_byte` later because we can assume the "
"necessary preconditions."
msgstr ""
"Re탵ine탵i c캒 `Uart::new` este nesigur캒, 칥n timp ce celelalte metode sunt "
"sigure. Acest lucru se datoreaz캒 faptului c캒, at칙ta timp c칙t apelantul lui "
"`Uart::new` garanteaz캒 c캒 cerin탵ele sale de siguran탵캒 sunt 칥ndeplinite (de "
"exemplu, c캒 exist캒 doar o singur캒 instan탵캒 a driverului pentru o anumit캒 "
"UART 탳i nimic altceva care s캒 se al캒ture spa탵iului s캒u de adrese), atunci "
"este 칥ntotdeauna sigur s캒 apel캒m mai t칙rziu `write_byte`, deoarece putem "
"presupune condi탵iile prealabile necesare."

#: src/bare-metal/aps/uart.md:60
#, fuzzy
msgid ""
"We could have done it the other way around (making `new` safe but "
"`write_byte` unsafe), but that would be much less convenient to use as every "
"place that calls `write_byte` would need to reason about the safety"
msgstr ""
"Am fi putut face invers (f캒c칙nd `new` sigur, dar `write_byte` nesigur), dar "
"ar fi fost mult mai pu탵in convenabil de utilizat, deoarece fiecare loc care "
"apeleaz캒 `write_byte` ar trebui s캒 se g칙ndeasc캒 la siguran탵a lui `write_byte`"

#: src/bare-metal/aps/uart.md:63
#, fuzzy
msgid ""
"This is a common pattern for writing safe wrappers of unsafe code: moving "
"the burden of proof for soundness from a large number of places to a smaller "
"number of places."
msgstr ""
"Acesta este un model comun pentru scrierea de 칥nveli탳uri sigure pentru cod "
"nesigur: mutarea sarcinii de a dovedi soliditatea de la un num캒r mare de "
"locuri la un num캒r mai mic de locuri."

#: src/bare-metal/aps/uart/traits.md:1
#, fuzzy
msgid "More traits"
msgstr "Mai multe tr캒s캒turi"

#: src/bare-metal/aps/uart/traits.md:3
#, fuzzy
msgid ""
"We derived the `Debug` trait. It would be useful to implement a few more "
"traits too."
msgstr ""
"Am derivat tr캒s캒tura `Debug`. Ar fi util s캒 implement캒m 탳i alte c칙teva "
"tr캒s캒turi."

#: src/bare-metal/aps/uart/traits.md:5
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"use core::fmt::{self, Write};\n"
"\n"
"impl Write for Uart {\n"
"    fn write_str(&mut self, s: &str) -> fmt::Result {\n"
"        for c in s.as_bytes() {\n"
"            self.write_byte(*c);\n"
"        }\n"
"        Ok(())\n"
"    }\n"
"}\n"
"\n"
"// Safe because it just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
"unsafe impl Send for Uart {}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"use core::fmt::{self, Write};\n"
"\n"
"impl Write pentru Uart {\n"
"    fn write_str(&mut self, s: &str) -> fmt::Result {\n"
"        for c in s.as_bytes() {\n"
"            self.write_byte(*c);\n"
"        }\n"
"        Ok((())\n"
"    }\n"
"}\n"
"\n"
"// Sigur, deoarece con탵ine doar un pointer c캒tre memoria dispozitivului, "
"care poate fi\n"
"// accesat캒 din orice context.\n"
"unsafe impl Send pentru Uart {}\n"
"```"

#: src/bare-metal/aps/uart/traits.md:24
#, fuzzy
msgid ""
"Implementing `Write` lets us use the `write!` and `writeln!` macros with our "
"`Uart` type."
msgstr ""
"Implementarea `Write` ne permite s캒 folosim macrogramele `write!` 탳i "
"`writeln!` cu tipul nostru `Uart`."

#: src/bare-metal/aps/uart/traits.md:25
#, fuzzy
msgid ""
"Run the example in QEMU with `make qemu_minimal` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"Rula탵i exemplul 칥n QEMU cu `make qemu_minimal` 칥n `src/bare-metal/aps/"
"examples`."

#: src/bare-metal/aps/better-uart.md:1
#, fuzzy
msgid "A better UART driver"
msgstr "Un driver UART mai bun"

#: src/bare-metal/aps/better-uart.md:3
#, fuzzy
msgid ""
"The PL011 actually has [a bunch more registers](https://developer.arm.com/"
"documentation/ddi0183/g/programmers-model/summary-of-registers), and adding "
"offsets to construct pointers to access them is error-prone and hard to "
"read. Plus, some of them are bit fields which would be nice to access in a "
"structured way."
msgstr ""
"PL011 are de fapt [o gr캒mad캒 de registre](https://developer.arm.com/"
"documentation/ddi0183/g/programmers-model/summary-of-registers), iar "
"ad캒ugarea de offset-uri pentru a construi pointeri pentru a le accesa este "
"predispus캒 la erori 탳i greu de citit. 칉n plus, unele dintre ele sunt c칙mpuri "
"de bi탵i care ar fi frumos s캒 fie accesate 칥ntr-un mod structurat."

#: src/bare-metal/aps/better-uart.md:7
msgid "Offset"
msgstr "Decalaj"

#: src/bare-metal/aps/better-uart.md:7
#, fuzzy
msgid "Register name"
msgstr "Nume registru"

#: src/bare-metal/aps/better-uart.md:7
msgid "Width"
msgstr "L캒콖ime"

#: src/bare-metal/aps/better-uart.md:9
#, fuzzy
msgid "0x00"
msgstr "0x00"

#: src/bare-metal/aps/better-uart.md:9
#, fuzzy
msgid "DR"
msgstr "DR"

#: src/bare-metal/aps/better-uart.md:9
msgid "12"
msgstr "12"

#: src/bare-metal/aps/better-uart.md:10
#, fuzzy
msgid "0x04"
msgstr "0x04"

#: src/bare-metal/aps/better-uart.md:10
#, fuzzy
msgid "RSR"
msgstr "RSR"

#: src/bare-metal/aps/better-uart.md:10
msgid "4"
msgstr "4"

#: src/bare-metal/aps/better-uart.md:11
#, fuzzy
msgid "0x18"
msgstr "0x18"

#: src/bare-metal/aps/better-uart.md:11
msgid "FR"
msgstr "V"

#: src/bare-metal/aps/better-uart.md:11
msgid "9"
msgstr "9"

#: src/bare-metal/aps/better-uart.md:12
#, fuzzy
msgid "0x20"
msgstr "0x20"

#: src/bare-metal/aps/better-uart.md:12
#, fuzzy
msgid "ILPR"
msgstr "ILPR"

#: src/bare-metal/aps/better-uart.md:12 src/bare-metal/aps/better-uart.md:15
msgid "8"
msgstr "8"

#: src/bare-metal/aps/better-uart.md:13
#, fuzzy
msgid "0x24"
msgstr "0x24"

#: src/bare-metal/aps/better-uart.md:13
#, fuzzy
msgid "IBRD"
msgstr "IBRD"

#: src/bare-metal/aps/better-uart.md:13 src/bare-metal/aps/better-uart.md:16
#, fuzzy
msgid "16"
msgstr "16"

#: src/bare-metal/aps/better-uart.md:14
#, fuzzy
msgid "0x28"
msgstr "0x28"

#: src/bare-metal/aps/better-uart.md:14
#, fuzzy
msgid "FBRD"
msgstr "FBRD"

#: src/bare-metal/aps/better-uart.md:14 src/bare-metal/aps/better-uart.md:17
msgid "6"
msgstr "6"

#: src/bare-metal/aps/better-uart.md:15
#, fuzzy
msgid "0x2c"
msgstr "0x2c"

#: src/bare-metal/aps/better-uart.md:15
#, fuzzy
msgid "LCR_H"
msgstr "LCR_H"

#: src/bare-metal/aps/better-uart.md:16
#, fuzzy
msgid "0x30"
msgstr "0x30"

#: src/bare-metal/aps/better-uart.md:16
msgid "CR"
msgstr "GD"

#: src/bare-metal/aps/better-uart.md:17
#, fuzzy
msgid "0x34"
msgstr "0x34"

#: src/bare-metal/aps/better-uart.md:17
#, fuzzy
msgid "IFLS"
msgstr "IFLS"

#: src/bare-metal/aps/better-uart.md:18
#, fuzzy
msgid "0x38"
msgstr "0x38"

#: src/bare-metal/aps/better-uart.md:18
#, fuzzy
msgid "IMSC"
msgstr "IMSC"

#: src/bare-metal/aps/better-uart.md:18 src/bare-metal/aps/better-uart.md:19
#: src/bare-metal/aps/better-uart.md:20 src/bare-metal/aps/better-uart.md:21
msgid "11"
msgstr "11"

#: src/bare-metal/aps/better-uart.md:19
#, fuzzy
msgid "0x3c"
msgstr "0x3c"

#: src/bare-metal/aps/better-uart.md:19
#, fuzzy
msgid "RIS"
msgstr "RIS"

#: src/bare-metal/aps/better-uart.md:20
#, fuzzy
msgid "0x40"
msgstr "0x40"

#: src/bare-metal/aps/better-uart.md:20
#, fuzzy
msgid "MIS"
msgstr "MIS"

#: src/bare-metal/aps/better-uart.md:21
#, fuzzy
msgid "0x44"
msgstr "0x44"

#: src/bare-metal/aps/better-uart.md:21
#, fuzzy
msgid "ICR"
msgstr "ICR"

#: src/bare-metal/aps/better-uart.md:22
#, fuzzy
msgid "0x48"
msgstr "0x48"

#: src/bare-metal/aps/better-uart.md:22
#, fuzzy
msgid "DMACR"
msgstr "DMACR"

#: src/bare-metal/aps/better-uart.md:22
msgid "3"
msgstr "3"

#: src/bare-metal/aps/better-uart.md:26
#, fuzzy
msgid "There are also some ID registers which have been omitted for brevity."
msgstr ""
"Exist캒, de asemenea, unele registre de identificare care au fost omise "
"pentru a fi mai scurte."

#: src/bare-metal/aps/better-uart/bitflags.md:3
#, fuzzy
msgid ""
"The [`bitflags`](https://crates.io/crates/bitflags) crate is useful for "
"working with bitflags."
msgstr ""
"Cr캒iasa [`bitflags`](https://crates.io/crates/bitflags) este util캒 pentru a "
"lucra cu bitflags."

#: src/bare-metal/aps/better-uart/bitflags.md:5
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"use bitflags::bitflags;\n"
"\n"
"bitflags! {\n"
"    /// Flags from the UART flag register.\n"
"    #[repr(transparent)]\n"
"    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n"
"    struct Flags: u16 {\n"
"        /// Clear to send.\n"
"        const CTS = 1 << 0;\n"
"        /// Data set ready.\n"
"        const DSR = 1 << 1;\n"
"        /// Data carrier detect.\n"
"        const DCD = 1 << 2;\n"
"        /// UART busy transmitting data.\n"
"        const BUSY = 1 << 3;\n"
"        /// Receive FIFO is empty.\n"
"        const RXFE = 1 << 4;\n"
"        /// Transmit FIFO is full.\n"
"        const TXFF = 1 << 5;\n"
"        /// Receive FIFO is full.\n"
"        const RXFF = 1 << 6;\n"
"        /// Transmit FIFO is empty.\n"
"        const TXFE = 1 << 7;\n"
"        /// Ring indicator.\n"
"        const RI = 1 << 8;\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"folosi탵i bitflags::bitflags;\n"
"\n"
"bitflags! {\n"
"    /// Semnalizatoare din registrul de semnalizare UART.\n"
"    #[repr(transparent)]\n"
"    #[derive(Copy, Clone, Debug, Eq, PartialEq)]]\n"
"    struct Flags: u16 {\n"
"        /// Clear to send.\n"
"        const CTS = 1 << 0;\n"
"        /// Set de date preg캒tit.\n"
"        const DSR = 1 << 1;\n"
"        /// Data carrier detect.\n"
"        const DCD = 1 << 2;\n"
"        /// UART ocupat캒 s캒 transmit캒 date.\n"
"        const BUSY = 1 << 3;\n"
"        /// Receive FIFO este gol.\n"
"        const RXFE = 1 << 4;\n"
"        /// Transmit FIFO este plin.\n"
"        const TXFF = 1 << 5;\n"
"        /// Receive FIFO este plin.\n"
"        const RXFF = 1 << 6;\n"
"        /// Transmit FIFO este gol.\n"
"        const TXFE = 1 << 7;\n"
"        /// Indicator de inel.\n"
"        const RI = 1 << 8;\n"
"    }\n"
"}\n"
"```"

#: src/bare-metal/aps/better-uart/bitflags.md:37
#, fuzzy
msgid ""
"The `bitflags!` macro creates a newtype something like `Flags(u16)`, along "
"with a bunch of method implementations to get and set flags."
msgstr ""
"Macroul `bitflags!` creeaz캒 un nou tip, ceva de genul `Flags(u16)`, 칥mpreun캒 "
"cu o serie de implement캒ri de metode pentru a ob탵ine 탳i seta steaguri."

#: src/bare-metal/aps/better-uart/registers.md:1
#, fuzzy
msgid "Multiple registers"
msgstr "Registre multiple"

#: src/bare-metal/aps/better-uart/registers.md:3
#, fuzzy
msgid ""
"We can use a struct to represent the memory layout of the UART's registers."
msgstr ""
"Putem folosi o structur캒 pentru a reprezenta structura de memorie a "
"registrelor UART."

#: src/bare-metal/aps/better-uart/registers.md:41
#, fuzzy
msgid ""
"[`#[repr(C)]`](https://doc.rust-lang.org/reference/type-layout.html#the-c-"
"representation) tells the compiler to lay the struct fields out in order, "
"following the same rules as C. This is necessary for our struct to have a "
"predictable layout, as default Rust representation allows the compiler to "
"(among other things) reorder fields however it sees fit."
msgstr ""
"[`#[repr(C)]`](https://doc.rust-lang.org/reference/type-layout.html#the-c-"
"representation) 칥i spune compilatorului s캒 a탳eze c칙mpurile structurii 칥n "
"ordine, urm칙nd acelea탳i reguli ca 탳i 칥n C. Acest lucru este necesar pentru "
"ca structura noastr캒 s캒 aib캒 o dispunere previzibil캒, deoarece reprezentarea "
"implicit캒 Rust permite compilatorului (printre altele) s캒 reordoneze "
"c칙mpurile dup캒 cum crede de cuviin탵캒."

#: src/bare-metal/aps/better-uart/driver.md:3
#, fuzzy
msgid "Now let's use the new `Registers` struct in our driver."
msgstr "Acum s캒 folosim noua structur캒 `Registers` 칥n driverul nostru."

#: src/bare-metal/aps/better-uart/driver.md:5
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"/// Driver for a PL011 UART.\n"
"#[derive(Debug)]\n"
"pub struct Uart {\n"
"    registers: *mut Registers,\n"
"}\n"
"\n"
"impl Uart {\n"
"    /// Constructs a new instance of the UART driver for a PL011 device at "
"the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the 8 MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
"    pub unsafe fn new(base_address: *mut u32) -> Self {\n"
"        Self {\n"
"            registers: base_address as *mut Registers,\n"
"        }\n"
"    }\n"
"\n"
"    /// Writes a single byte to the UART.\n"
"    pub fn write_byte(&self, byte: u8) {\n"
"        // Wait until there is room in the TX buffer.\n"
"        while self.read_flag_register().contains(Flags::TXFF) {}\n"
"\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe {\n"
"            // Write to the TX buffer.\n"
"            addr_of_mut!((*self.registers).dr).write_volatile(byte.into());\n"
"        }\n"
"\n"
"        // Wait until the UART is no longer busy.\n"
"        while self.read_flag_register().contains(Flags::BUSY) {}\n"
"    }\n"
"\n"
"    /// Reads and returns a pending byte, or `None` if nothing has been "
"received.\n"
"    pub fn read_byte(&self) -> Option<u8> {\n"
"        if self.read_flag_register().contains(Flags::RXFE) {\n"
"            None\n"
"        } else {\n"
"            let data = unsafe { addr_of!((*self.registers).dr)."
"read_volatile() };\n"
"            // TODO: Check for error conditions in bits 8-11.\n"
"            Some(data as u8)\n"
"        }\n"
"    }\n"
"\n"
"    fn read_flag_register(&self) -> Flags {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe { addr_of!((*self.registers).fr).read_volatile() }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"/// Driver pentru o UART PL011.\n"
"#[derive(Debug)]\n"
"pub struct Uart {\n"
"    registers: *mut Registers,\n"
"}\n"
"\n"
"impl Uart {\n"
"    /// Construie탳te o nou캒 instan탵캒 a driverului UART pentru un dispozitiv "
"PL011 la nivelul\n"
"    /// adresa de baz캒 dat캒.\n"
"    ///\n"
"    /// # Siguran탵캒\n"
"    ///\n"
"    /// Adresa de baz캒 dat캒 trebuie s캒 indice cele 8 registre de control "
"MMIO ale unui dispozitiv de tip\n"
"    /// PL011, care trebuie s캒 fie mapate 칥n spa탵iul de adrese al "
"procesului\n"
"    /// ca memorie a dispozitivului 탳i s캒 nu aib캒 alte pseudonime.\n"
"    pub unsafe fn new(base_address: *mut u32) -&gt; Self {\n"
"        Self {\n"
"            registers: base_address as *mut Registers,\n"
"        }\n"
"    }\n"
"\n"
"    /// Scrie un singur octet pe UART.\n"
"    pub fn write_byte(&amp;self, byte: u8) {\n"
"        // A탳teapt캒 p칙n캒 c칙nd exist캒 spa탵iu 칥n bufferul TX.\n"
"        while self.read_flag_register().contains(Flags::TXFF) {}\n"
"\n"
"        // Sigur, deoarece 탳tim c캒 self.registers indic캒 controlul\n"
"        // registre ale unui dispozitiv PL011 care este mapat "
"corespunz캒tor.\n"
"        nesigur {\n"
"            // Scrie탵i 칥n memoria tampon TX.\n"
"            addr_of_mut!((*self.registers).dr).write_volatile(byte.into());\n"
"        }\n"
"\n"
"        // A탳tepta탵i p칙n캒 c칙nd UART-ul nu mai este ocupat.\n"
"        while self.read_flag_register().contains(Flags::BUSY) {}\n"
"    }\n"
"\n"
"    /// Cite탳te 탳i returneaz캒 un octet 칥n a탳teptare sau `None` dac캒 nu a "
"fost primit nimic.\n"
"    pub fn read_byte(&amp;self) -&gt; Option<u8> {\n"
"        if self.read_flag_register().contains(Flags::RXFE) {\n"
"            None\n"
"        } else {\n"
"            let data = unsafe { addr_of!((*self.registers).dr)."
"read_volatile() };\n"
"            // TODO: Verifica탵i dac캒 exist캒 condi탵ii de eroare 칥n bi탵ii "
"8-11.\n"
"            Some(data as u8)\n"
"        }\n"
"    }\n"
"\n"
"    fn read_flag_register(&amp;self) -&gt; Flags {\n"
"        // Sigur, deoarece 탳tim c캒 self.registers indic캒 controlul\n"
"        // registre ale unui dispozitiv PL011 care este mapat 칥n mod "
"corespunz캒tor.\n"
"        unsafe { addr_of!((*self.registers).fr).read_volatile() } }\n"
"    }\n"
"}\n"
"```"

#: src/bare-metal/aps/better-uart/driver.md:64
#, fuzzy
msgid ""
"Note the use of `addr_of!` / `addr_of_mut!` to get pointers to individual "
"fields without creating an intermediate reference, which would be unsound."
msgstr ""
"Re탵ine탵i utilizarea lui `addr_of!` / `addr_of_mut!` pentru a ob탵ine pointeri "
"la c칙mpuri individuale f캒r캒 a crea o referin탵캒 intermediar캒, ceea ce ar fi "
"nesigur."

#: src/bare-metal/aps/better-uart/using.md:1
#: src/bare-metal/aps/logging/using.md:1
#, fuzzy
msgid "Using it"
msgstr "Folosirea Cargo"

#: src/bare-metal/aps/better-uart/using.md:3
#, fuzzy
msgid ""
"Let's write a small program using our driver to write to the serial console, "
"and echo incoming bytes."
msgstr ""
"S캒 scriem un mic program care utilizeaz캒 driverul nostru pentru a scrie pe "
"consola serial캒 탳i pentru a reda ecourile octe탵ilor care intr캒."

#: src/bare-metal/aps/better-uart/using.md:6
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"mod exceptions;\n"
"mod pl011;\n"
"\n"
"use crate::pl011::Uart;\n"
"use core::fmt::Write;\n"
"use core::panic::PanicInfo;\n"
"use log::error;\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Base address of the primary PL011 UART.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 "
"device,\n"
"    // and nothing else accesses that address range.\n"
"    let mut uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"\n"
"    writeln!(uart, \"main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})\").unwrap();\n"
"\n"
"    loop {\n"
"        if let Some(byte) = uart.read_byte() {\n"
"            uart.write_byte(byte);\n"
"            match byte {\n"
"                b'\\r' => {\n"
"                    uart.write_byte(b'\\n');\n"
"                }\n"
"                b'q' => break,\n"
"                _ => {}\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    writeln!(uart, \"Bye!\").unwrap();\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"excep탵ii mod;\n"
"mod pl011;\n"
"\n"
"use crate::pl011::Uart;\n"
"use core::fmt::Write;\n"
"use core::panic::PanicInfo;\n"
"use log::error;\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Adresa de baz캒 a UART PL011 primar캒.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Sigur, deoarece `PL011_BASE_ADDRESS` este adresa de baz캒 a unui "
"dispozitiv PL011,\n"
"    // 탳i nimic altceva nu acceseaz캒 acest interval de adrese.\n"
"    let mut uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"\n"
"    writeln!(uart, \"main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})\").unwrap();\n"
"\n"
"    loop {\n"
"        if let Some(byte) = uart.read_byte() {\n"
"            uart.write_byte(byte);\n"
"            match byte {\n"
"                b'\\r' =&gt; {\n"
"                    uart.write_byte(b'\\n');\n"
"                }\n"
"                b'q' =&gt; break,\n"
"                _ =&gt {}\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    writeln!(uart, \"Bye!\").unwrap();\n"
"    system_off:::<Hvc>().unwrap();\n"
"}\n"
"```"

#: src/bare-metal/aps/better-uart/using.md:51
#, fuzzy
msgid ""
"As in the [inline assembly](../inline-assembly.md) example, this `main` "
"function is called from our entry point code in `entry.S`. See the speaker "
"notes there for details."
msgstr ""
"Ca 탳i 칥n exemplul [inline assembly](../inline-assembly.md), aceast캒 func탵ie "
"`main` este apelat캒 din codul punctului de intrare 칥n `entry.S`. Pentru "
"detalii, consulta탵i notele vorbitorului de acolo."

#: src/bare-metal/aps/better-uart/using.md:53
#, fuzzy
msgid ""
"Run the example in QEMU with `make qemu` under `src/bare-metal/aps/examples`."
msgstr ""
"Rula탵i exemplul 칥n QEMU cu `make qemu` 칥n `src/bare-metal/aps/examples`."

#: src/bare-metal/aps/logging.md:3
#, fuzzy
msgid ""
"It would be nice to be able to use the logging macros from the [`log`]"
"(https://crates.io/crates/log) crate. We can do this by implementing the "
"`Log` trait."
msgstr ""
"Ar fi frumos s캒 putem folosi macrogramele de logare de la [`log`](https://"
"crates.io/crates/log) crate. Putem face acest lucru prin implementarea "
"tr캒s캒turii `Log`."

#: src/bare-metal/aps/logging.md:6
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"use crate::pl011::Uart;\n"
"use core::fmt::Write;\n"
"use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};\n"
"use spin::mutex::SpinMutex;\n"
"\n"
"static LOGGER: Logger = Logger {\n"
"    uart: SpinMutex::new(None),\n"
"};\n"
"\n"
"struct Logger {\n"
"    uart: SpinMutex<Option<Uart>>,\n"
"}\n"
"\n"
"impl Log for Logger {\n"
"    fn enabled(&self, _metadata: &Metadata) -> bool {\n"
"        true\n"
"    }\n"
"\n"
"    fn log(&self, record: &Record) {\n"
"        writeln!(\n"
"            self.uart.lock().as_mut().unwrap(),\n"
"            \"[{}] {}\",\n"
"            record.level(),\n"
"            record.args()\n"
"        )\n"
"        .unwrap();\n"
"    }\n"
"\n"
"    fn flush(&self) {}\n"
"}\n"
"\n"
"/// Initialises UART logger.\n"
"pub fn init(uart: Uart, max_level: LevelFilter) -> Result<(), "
"SetLoggerError> {\n"
"    LOGGER.uart.lock().replace(uart);\n"
"\n"
"    log::set_logger(&LOGGER)?;\n"
"    log::set_max_level(max_level);\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"use crate::pl011::Uart;\n"
"use core::fmt::Write;\n"
"use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};\n"
"use spin::mutex::SpinMutex;\n"
"\n"
"static LOGGER: Logger = Logger {\n"
"    uart: SpinMutex::new(None),\n"
"};\n"
"\n"
"struct Logger {\n"
"    uart: SpinMutex&lt;Option<Uart>&gt;,\n"
"}\n"
"\n"
"impl Log for Logger {\n"
"    fn enabled(&amp;self, _metadata: &amp;Metadata) -&gt; bool {\n"
"        true\n"
"    }\n"
"\n"
"    fn log(&amp;self, record: &amp;Record) {\n"
"        writeln!(\n"
"            self.uart.lock().as_mut().unwrap(),\n"
"            \"[{}] {}\",\n"
"            record.level(),\n"
"            record.args()\n"
"        )\n"
"        .unwrap();\n"
"    }\n"
"\n"
"    fn flush(&amp;self) {}\n"
"}\n"
"\n"
"/// Ini탵ializeaz캒 loggerul UART.\n"
"pub fn init(uart: Uart, max_level: LevelFilter) -&gt; Result<(), "
"SetLoggerError> {\n"
"    LOGGER.uart.lock().replace(uart);\n"
"\n"
"    log::set_logger(&amp;LOGGER)?;\n"
"    log::set_max_level(max_level);\n"
"    Ok((())\n"
"}\n"
"```"

#: src/bare-metal/aps/logging.md:50
#, fuzzy
msgid ""
"The unwrap in `log` is safe because we initialise `LOGGER` before calling "
"`set_logger`."
msgstr ""
"Desf캒탳urarea 칥n `log` este sigur캒 deoarece ini탵ializ캒m `LOGGER` 칥nainte de a "
"apela `set_logger`."

#: src/bare-metal/aps/logging/using.md:3
#, fuzzy
msgid "We need to initialise the logger before we use it."
msgstr "Trebuie s캒 ini탵ializ캒m loggerul 칥nainte de a-l utiliza."

#: src/bare-metal/aps/logging/using.md:5
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"mod exceptions;\n"
"mod logger;\n"
"mod pl011;\n"
"\n"
"use crate::pl011::Uart;\n"
"use core::panic::PanicInfo;\n"
"use log::{error, info, LevelFilter};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Base address of the primary PL011 UART.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 "
"device,\n"
"    // and nothing else accesses that address range.\n"
"    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"    logger::init(uart, LevelFilter::Trace).unwrap();\n"
"\n"
"    info!(\"main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})\");\n"
"\n"
"    assert_eq!(x1, 42);\n"
"\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[panic_handler]\n"
"fn panic(info: &PanicInfo) -> ! {\n"
"    error!(\"{info}\");\n"
"    system_off::<Hvc>().unwrap();\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"excep탵ii mod;\n"
"mod logger;\n"
"mod pl011;\n"
"\n"
"use crate::pl011::Uart;\n"
"use core::panic::PanicInfo;\n"
"use log::{error, info, LevelFilter};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Adresa de baz캒 a UART PL011 primar캒.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Sigur, deoarece `PL011_BASE_ADDRESS` este adresa de baz캒 a unui "
"dispozitiv PL011,\n"
"    // 탳i nimic altceva nu acceseaz캒 acest interval de adrese.\n"
"    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"    logger::init(uart, LevelFilter::Trace).unwrap();\n"
"\n"
"    info!(\"main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})\");\n"
"\n"
"    assert_eq!(x1, 42);\n"
"\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[panic_handler]\n"
"fn panic(info: &amp;PanicInfo) -&gt; ! {\n"
"    error!(\"{info}\");\n"
"    system_off:::<Hvc>().unwrap();\n"
"    bucla {}\n"
"}\n"
"```"

#: src/bare-metal/aps/logging/using.md:46
#, fuzzy
msgid "Note that our panic handler can now log details of panics."
msgstr ""
"Re탵ine탵i c캒 gestionarul nostru de panic캒 poate acum s캒 칥nregistreze "
"detaliile panicii."

#: src/bare-metal/aps/logging/using.md:47
#, fuzzy
msgid ""
"Run the example in QEMU with `make qemu_logger` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"Rula탵i exemplul 칥n QEMU cu `make qemu_logger` 칥n `src/bare-metal/aps/"
"examples`."

#: src/bare-metal/aps/exceptions.md:3
#, fuzzy
msgid ""
"AArch64 defines an exception vector table with 16 entries, for 4 types of "
"exceptions (synchronous, IRQ, FIQ, SError) from 4 states (current EL with "
"SP0, current EL with SPx, lower EL using AArch64, lower EL using AArch32). "
"We implement this in assembly to save volatile registers to the stack before "
"calling into Rust code:"
msgstr ""
"AArch64 define탳te un tabel de vectori de excep탵ii cu 16 intr캒ri, pentru 4 "
"tipuri de excep탵ii (sincron캒, IRQ, FIQ, SError) din 4 st캒ri (EL curent cu "
"SP0, EL curent cu SPx, EL inferior utiliz칙nd AArch64, EL inferior utiliz칙nd "
"AArch32). Implement캒m acest lucru 칥n asamblare pentru a salva registrele "
"volatile pe stiv캒 칥nainte de a apela 칥n codul Rust:"

#: src/bare-metal/aps/exceptions.md:64
#, fuzzy
msgid "EL is exception level; all our examples this afternoon run in EL1."
msgstr ""
"EL reprezint캒 nivelul de excep탵ie; toate exemplele noastre din aceast캒 dup캒-"
"amiaz캒 ruleaz캒 칥n EL1."

#: src/bare-metal/aps/exceptions.md:65
#, fuzzy
msgid ""
"For simplicity we aren't distinguishing between SP0 and SPx for the current "
"EL exceptions, or between AArch32 and AArch64 for the lower EL exceptions."
msgstr ""
"Pentru simplificare, nu facem distinc탵ie 칥ntre SP0 탳i SPx pentru excep탵iile "
"EL curente, sau 칥ntre AArch32 탳i AArch64 pentru excep탵iile EL inferioare."

#: src/bare-metal/aps/exceptions.md:67
#, fuzzy
msgid ""
"For this example we just log the exception and power down, as we don't "
"expect any of them to actually happen."
msgstr ""
"Pentru acest exemplu, ne limit캒m la 칥nregistrarea excep탵iei 탳i la oprirea "
"aliment캒rii, deoarece nu ne a탳tept캒m ca vreuna dintre acestea s캒 se 칥nt칙mple."

#: src/bare-metal/aps/exceptions.md:69
#, fuzzy
msgid ""
"We can think of exception handlers and our main execution context more or "
"less like different threads. [`Send` and `Sync`](../../concurrency/send-sync."
"md) will control what we can share between them, just like with threads. For "
"example, if we want to share some value between exception handlers and the "
"rest of the program, and it's `Send` but not `Sync`, then we'll need to wrap "
"it in something like a `Mutex` and put it in a static."
msgstr ""
"Ne putem g칙ndi la gestionarii de excep탵ii 탳i la contextul nostru principal "
"de execu탵ie mai mult sau mai pu탵in ca la fire diferite. [`Send` 탳i `Sync`]"
"(../../concurrency/send-sync.md) vor controla ceea ce putem partaja 칥ntre "
"ele, la fel ca 칥n cazul firelor de execu탵ie. De exemplu, dac캒 dorim s캒 "
"partaj캒m o anumit캒 valoare 칥ntre gestionarii de excep탵ii 탳i restul "
"programului, iar aceasta este `Send`, dar nu `Sync`, atunci va trebui s캒 o "
"칥nf캒탳ur캒m 칥n ceva de genul `Mutex` 탳i s캒 o punem 칥ntr-o static캒."

#: src/bare-metal/aps/other-projects.md:3
#, fuzzy
msgid "[oreboot](https://github.com/oreboot/oreboot)"
msgstr "[oreboot](https://github.com/oreboot/oreboot)"

#: src/bare-metal/aps/other-projects.md:4
#, fuzzy
msgid "\"coreboot without the C\""
msgstr "\"coreboot f캒r캒 C\""

#: src/bare-metal/aps/other-projects.md:5
#, fuzzy
msgid "Supports x86, aarch64 and RISC-V."
msgstr "Suport캒 x86, aarch64 탳i RISC-V."

#: src/bare-metal/aps/other-projects.md:6
#, fuzzy
msgid "Relies on LinuxBoot rather than having many drivers itself."
msgstr "Se bazeaz캒 pe LinuxBoot 칥n loc s캒 aib캒 multe drivere."

#: src/bare-metal/aps/other-projects.md:7
#, fuzzy
msgid ""
"[Rust RaspberryPi OS tutorial](https://github.com/rust-embedded/rust-"
"raspberrypi-OS-tutorials)"
msgstr ""
"[Tutorial Rust RaspberryPi OS](https://github.com/rust-embedded/rust-"
"raspberrypi-OS-tutorials)"

#: src/bare-metal/aps/other-projects.md:8
#, fuzzy
msgid ""
"Initialisation, UART driver, simple bootloader, JTAG, exception levels, "
"exception handling, page tables"
msgstr ""
"Ini탵ializare, driver UART, bootloader simplu, JTAG, niveluri de excep탵ie, "
"tratarea excep탵iilor, tabele de pagini"

#: src/bare-metal/aps/other-projects.md:10
#, fuzzy
msgid ""
"Some dodginess around cache maintenance and initialisation in Rust, not "
"necessarily a good example to copy for production code."
msgstr ""
"Unele dificult캒탵i 칥n ceea ce prive탳te 칥ntre탵inerea 탳i ini탵ializarea cache-"
"ului 칥n Rust, nu neap캒rat un exemplu bun de copiat pentru codul de produc탵ie."

#: src/bare-metal/aps/other-projects.md:12
#, fuzzy
msgid "[`cargo-call-stack`](https://crates.io/crates/cargo-call-stack)"
msgstr "[`cargo-call-stack`](https://crates.io/crates/cargo-call-stack)"

#: src/bare-metal/aps/other-projects.md:13
#, fuzzy
msgid "Static analysis to determine maximum stack usage."
msgstr "Analiza static캒 pentru a determina utilizarea maxim캒 a stivei."

#: src/bare-metal/aps/other-projects.md:17
#, fuzzy
msgid ""
"The RaspberryPi OS tutorial runs Rust code before the MMU and caches are "
"enabled. This will read and write memory (e.g. the stack). However:"
msgstr ""
"Tutorialul RaspberryPi OS ruleaz캒 codul Rust 칥nainte ca MMU 탳i memoria cache "
"s캒 fie activate. Aceasta va citi 탳i va scrie 칥n memorie (de exemplu, stiva). "
"Cu toate acestea:"

#: src/bare-metal/aps/other-projects.md:19
#, fuzzy
msgid ""
"Without the MMU and cache, unaligned accesses will fault. It builds with "
"`aarch64-unknown-none` which sets `+strict-align` to prevent the compiler "
"generating unaligned accesses so it should be alright, but this is not "
"necessarily the case in general."
msgstr ""
"F캒r캒 MMU 탳i memoria cache, acces캒rile nealiniate vor e탳ua. Se construie탳te "
"cu `aarch64-unknown-none`, care seteaz캒 `+strict-align` pentru a 칥mpiedica "
"compilatorul s캒 genereze accese nealiniate, deci ar trebui s캒 fie 칥n regul캒, "
"dar acest lucru nu este neap캒rat valabil 칥n general."

#: src/bare-metal/aps/other-projects.md:22
#, fuzzy
msgid ""
"If it were running in a VM, this can lead to cache coherency issues. The "
"problem is that the VM is accessing memory directly with the cache disabled, "
"while the host has cacheable aliases to the same memory. Even if the host "
"doesn't explicitly access the memory, speculative accesses can lead to cache "
"fills, and then changes from one or the other will get lost. Again this is "
"alright in this particular case (running directly on the hardware with no "
"hypervisor), but isn't a good pattern in general."
msgstr ""
"Dac캒 ar fi rulat 칥ntr-o ma탳in캒 virtual캒, acest lucru poate duce la probleme "
"de coeren탵캒 a memoriei cache. Problema const캒 칥n faptul c캒 ma탳ina virtual캒 "
"acceseaz캒 memoria direct, cu memoria cache dezactivat캒, 칥n timp ce gazda are "
"alias-uri care pot fi stocate 칥n memoria cache pentru aceea탳i memorie. Chiar "
"dac캒 gazda nu acceseaz캒 칥n mod explicit memoria, acces캒rile speculative pot "
"duce la umplerea cache-ului, iar apoi modific캒rile de la unul sau de la "
"cel캒lalt se vor pierde. Din nou, acest lucru este 칥n regul캒 칥n acest caz "
"particular (care ruleaz캒 direct pe hardware f캒r캒 hipervizor), dar nu este un "
"model bun 칥n general."

#: src/bare-metal/useful-crates.md:3
#, fuzzy
msgid ""
"We'll go over a few crates which solve some common problems in bare-metal "
"programming."
msgstr ""
"Vom trece 칥n revist캒 c칙teva crates care rezolv캒 unele probleme comune 칥n "
"programarea bare-metal."

#: src/bare-metal/useful-crates/zerocopy.md:1
#, fuzzy
msgid "`zerocopy`"
msgstr "`zerocopie`"

#: src/bare-metal/useful-crates/zerocopy.md:3
#, fuzzy
msgid ""
"The [`zerocopy`](https://docs.rs/zerocopy/) crate (from Fuchsia) provides "
"traits and macros for safely converting between byte sequences and other "
"types."
msgstr ""
"Cr캒iasa [`zerocopy`](https://docs.rs/zerocopy/) (din Fuchsia) ofer캒 "
"tr캒s캒turi 탳i macro-uri pentru conversia 칥n siguran탵캒 칥ntre secven탵e de "
"octe탵i 탳i alte tipuri."

#: src/bare-metal/useful-crates/zerocopy.md:40
#, fuzzy
msgid ""
"This is not suitable for MMIO (as it doesn't use volatile reads and writes), "
"but can be useful for working with structures shared with hardware e.g. by "
"DMA, or sent over some external interface."
msgstr ""
"Acest lucru nu este potrivit pentru MMIO (deoarece nu utilizeaz캒 citiri 탳i "
"scrieri volatile), dar poate fi util pentru lucrul cu structuri partajate cu "
"hardware, de exemplu prin DMA, sau trimise prin intermediul unei interfe탵e "
"externe."

#: src/bare-metal/useful-crates/zerocopy.md:45
#, fuzzy
msgid ""
"`FromBytes` can be implemented for types for which any byte pattern is "
"valid, and so can safely be converted from an untrusted sequence of bytes."
msgstr ""
"`FromBytes` poate fi implementat pentru tipurile pentru care orice model de "
"octe탵i este valabil 탳i, prin urmare, poate fi convertit 칥n siguran탵캒 dintr-o "
"secven탵캒 de octe탵i nesigur캒."

#: src/bare-metal/useful-crates/zerocopy.md:47
#, fuzzy
msgid ""
"Attempting to derive `FromBytes` for these types would fail, because "
"`RequestType` doesn't use all possible u32 values as discriminants, so not "
"all byte patterns are valid."
msgstr ""
"칉ncercarea de a deriva `FromBytes` pentru aceste tipuri ar e탳ua, deoarece "
"`RequestType` nu utilizeaz캒 toate valorile u32 posibile ca discriminan탵i, "
"astfel 칥nc칙t nu toate modelele de octe탵i sunt valide."

#: src/bare-metal/useful-crates/zerocopy.md:49
#, fuzzy
msgid ""
"`zerocopy::byteorder` has types for byte-order aware numeric primitives."
msgstr ""
"`zerocopy::byteorder` are tipuri pentru primitive numerice care cunosc "
"ordinea octe탵ilor."

#: src/bare-metal/useful-crates/zerocopy.md:50
#, fuzzy
msgid ""
"Run the example with `cargo run` under `src/bare-metal/useful-crates/"
"zerocopy-example/`. (It won't run in the Playground because of the crate "
"dependency.)"
msgstr ""
"Rula탵i exemplul cu `cargo run` 칥n `src/bare-metal/useful-crates/zerocopy-"
"example/`. (Nu va rula 칥n Playground din cauza dependen탵ei de crate)"

#: src/bare-metal/useful-crates/aarch64-paging.md:1
#, fuzzy
msgid "`aarch64-paging`"
msgstr "`aarch64-paging`"

#: src/bare-metal/useful-crates/aarch64-paging.md:3
#, fuzzy
msgid ""
"The [`aarch64-paging`](https://crates.io/crates/aarch64-paging) crate lets "
"you create page tables according to the AArch64 Virtual Memory System "
"Architecture."
msgstr ""
"Cr캒iasa [`aarch64-paging`](https://crates.io/crates/aarch64-paging) v캒 "
"permite s캒 crea탵i tabele de pagini 칥n conformitate cu arhitectura sistemului "
"de memorie virtual캒 AArch64."

#: src/bare-metal/useful-crates/aarch64-paging.md:6
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"use aarch64_paging::{\n"
"    idmap::IdMap,\n"
"    paging::{Attributes, MemoryRegion},\n"
"};\n"
"\n"
"const ASID: usize = 1;\n"
"const ROOT_LEVEL: usize = 1;\n"
"\n"
"// Create a new page table with identity mapping.\n"
"let mut idmap = IdMap::new(ASID, ROOT_LEVEL);\n"
"// Map a 2 MiB region of memory as read-only.\n"
"idmap.map_range(\n"
"    &MemoryRegion::new(0x80200000, 0x80400000),\n"
"    Attributes::NORMAL | Attributes::NON_GLOBAL | Attributes::READ_ONLY,\n"
").unwrap();\n"
"// Set `TTBR0_EL1` to activate the page table.\n"
"idmap.activate();\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"use aarch64_paging::{\n"
"    idmap::IdMap,\n"
"    paginare::{Attributes, MemoryRegion},\n"
"};\n"
"\n"
"const ASID: usize = 1;\n"
"const ROOT_LEVEL: usize = 1;\n"
"\n"
"// Crea탵i o nou캒 tabel캒 de pagini cu coresponden탵캒 de identitate.\n"
"let mut idmap = IdMap::new(ASID, ROOT_LEVEL);\n"
"// Map캒 o regiune de 2 MiB de memorie ca fiind de numai citire.\n"
"idmap.map_range(\n"
"    &MemoryRegion::new(0x80200000, 0x80400000),\n"
"    Attributes::NORMAL | Attributes::NON_GLOBAL | Attributes::READ_ONLY,\n"
").unwrap();\n"
"// Seta탵i `TTBR0_EL1` pentru a activa tabelul de pagini.\n"
"idmap.activate();\n"
"```"

#: src/bare-metal/useful-crates/aarch64-paging.md:28
#, fuzzy
msgid ""
"For now it only supports EL1, but support for other exception levels should "
"be straightforward to add."
msgstr ""
"Deocamdat캒, accept캒 doar EL1, dar ar trebui s캒 fie u탳or de ad캒ugat suportul "
"pentru alte niveluri de excep탵ie."

#: src/bare-metal/useful-crates/aarch64-paging.md:30
#, fuzzy
msgid ""
"This is used in Android for the [Protected VM Firmware](https://cs.android."
"com/android/platform/superproject/+/master:packages/modules/Virtualization/"
"pvmfw/)."
msgstr ""
"Aceasta este utilizat캒 칥n Android pentru [Protected VM Firmware] (https://cs."
"android.com/android/platform/superproject/+/master:packages/modules/"
"Virtualization/pvmfw/)."

#: src/bare-metal/useful-crates/aarch64-paging.md:31
#, fuzzy
msgid ""
"There's no easy way to run this example, as it needs to run on real hardware "
"or under QEMU."
msgstr ""
"Nu exist캒 o modalitate u탳oar캒 de a rula acest exemplu, deoarece trebuie s캒 "
"ruleze pe hardware real sau 칥n QEMU."

#: src/bare-metal/useful-crates/buddy_system_allocator.md:1
#, fuzzy
msgid "`buddy_system_allocator`"
msgstr "`buddy_system_allocator`"

#: src/bare-metal/useful-crates/buddy_system_allocator.md:3
#, fuzzy
msgid ""
"[`buddy_system_allocator`](https://crates.io/crates/buddy_system_allocator) "
"is a third-party crate implementing a basic buddy system allocator. It can "
"be used both for [`LockedHeap`](https://docs.rs/buddy_system_allocator/0.9.0/"
"buddy_system_allocator/struct.LockedHeap.html) implementing [`GlobalAlloc`]"
"(https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html) so you can use "
"the standard `alloc` crate (as we saw [before](../alloc.md)), or for "
"allocating other address space. For example, we might want to allocate MMIO "
"space for PCI BARs:"
msgstr ""
"[`buddy_system_allocator`](https://crates.io/crates/buddy_system_allocator) "
"este o cr캒ias캒 ter탵캒 parte care implementeaz캒 un alocator de baz캒 pentru "
"sistemul de prieteni. Acesta poate fi utilizat at칙t pentru [`LockedHeap`]"
"(https://docs.rs/buddy_system_allocator/0.9.0/buddy_system_allocator/struct."
"LockedHeap.html) care implementeaz캒 [`GlobalAlloc`](https://doc.rust-lang."
"org/core/alloc/trait.GlobalAlloc.html), astfel 칥nc칙t s캒 pute탵i utiliza crate-"
"ul standard `alloc` (a탳a cum am v캒zut [칥nainte](../alloc.md)), c칙t 탳i pentru "
"alocarea altor spa탵ii de adrese. De exemplu, am putea dori s캒 aloc캒m spa탵iu "
"MMIO pentru BAR-uri PCI:"

#: src/bare-metal/useful-crates/buddy_system_allocator.md:26
#, fuzzy
msgid "PCI BARs always have alignment equal to their size."
msgstr "BAR-urile PCI au 칥ntotdeauna o aliniere egal캒 cu dimensiunea lor."

#: src/bare-metal/useful-crates/buddy_system_allocator.md:27
#, fuzzy
msgid ""
"Run the example with `cargo run` under `src/bare-metal/useful-crates/"
"allocator-example/`. (It won't run in the Playground because of the crate "
"dependency.)"
msgstr ""
"Rula탵i exemplul cu `cargo run` 칥n `src/bare-metal/useful-crates/allocator-"
"example/`. (Nu va rula 칥n Playground din cauza dependen탵ei de crate)"

#: src/bare-metal/useful-crates/tinyvec.md:1
#, fuzzy
msgid "`tinyvec`"
msgstr "`tinyvec`"

#: src/bare-metal/useful-crates/tinyvec.md:3
#, fuzzy
msgid ""
"Sometimes you want something which can be resized like a `Vec`, but without "
"heap allocation. [`tinyvec`](https://crates.io/crates/tinyvec) provides "
"this: a vector backed by an array or slice, which could be statically "
"allocated or on the stack, which keeps track of how many elements are used "
"and panics if you try to use more than are allocated."
msgstr ""
"Uneori dori탵i ceva care poate fi redimensionat ca un `Vec`, dar f캒r캒 alocare "
"de heap. [`tinyvec`](https://crates.io/crates/tinyvec) ofer캒 acest lucru: un "
"vector sus탵inut de o matrice sau de o felie, care poate fi alocat static sau "
"pe stiv캒, care 탵ine eviden탵a num캒rului de elemente utilizate 탳i intr캒 칥n "
"panic캒 dac캒 칥ncerca탵i s캒 utiliza탵i mai multe dec칙t sunt alocate."

#: src/bare-metal/useful-crates/tinyvec.md:23
#, fuzzy
msgid ""
"`tinyvec` requires that the element type implement `Default` for "
"initialisation."
msgstr ""
"`tinyvec` necesit캒 ca tipul de element s캒 implementeze `Default` pentru "
"ini탵ializare."

#: src/bare-metal/useful-crates/tinyvec.md:24
#, fuzzy
msgid ""
"The Rust Playground includes `tinyvec`, so this example will run fine inline."
msgstr ""
"Rust Playground include `tinyvec`, deci acest exemplu va rula bine 칥n linie."

#: src/bare-metal/useful-crates/spin.md:1
#, fuzzy
msgid "`spin`"
msgstr "`spin`"

#: src/bare-metal/useful-crates/spin.md:3
#, fuzzy
msgid ""
"`std::sync::Mutex` and the other synchronisation primitives from `std::sync` "
"are not available in `core` or `alloc`. How can we manage synchronisation or "
"interior mutability, such as for sharing state between different CPUs?"
msgstr ""
"`std::sync::Mutex` 탳i celelalte primitive de sincronizare din `std::sync` nu "
"sunt disponibile 칥n `core` sau `alloc`. Cum putem gestiona sincronizarea sau "
"mutabilitatea interioar캒, cum ar fi pentru partajarea st캒rii 칥ntre diferite "
"unit캒탵i centrale de procesare?"

#: src/bare-metal/useful-crates/spin.md:7
#, fuzzy
msgid ""
"The [`spin`](https://crates.io/crates/spin) crate provides spinlock-based "
"equivalents of many of these primitives."
msgstr ""
"Cr캒iasa [`spin`](https://crates.io/crates/spin) ofer캒 echivalente bazate pe "
"spinlock pentru multe dintre aceste primitive."

#: src/bare-metal/useful-crates/spin.md:23
#, fuzzy
msgid "Be careful to avoid deadlock if you take locks in interrupt handlers."
msgstr ""
"Ave탵i grij캒 s캒 evita탵i blocajul dac캒 lua탵i blocaje 칥n gestionarii de "
"칥ntreruperi."

#: src/bare-metal/useful-crates/spin.md:24
#, fuzzy
msgid ""
"`spin` also has a ticket lock mutex implementation; equivalents of `RwLock`, "
"`Barrier` and `Once` from `std::sync`;  and `Lazy` for lazy initialisation."
msgstr ""
"`spin` are, de asemenea, o implementare a unui mutex de blocare a biletului; "
"echivalen탵i ai lui `RwLock`, `Barrier` 탳i `Once` din `std::sync`; 탳i `Lazy` "
"pentru ini탵ializare lene탳캒."

#: src/bare-metal/useful-crates/spin.md:26
#, fuzzy
msgid ""
"The [`once_cell`](https://crates.io/crates/once_cell) crate also has some "
"useful types for late initialisation with a slightly different approach to "
"`spin::once::Once`."
msgstr ""
"Cr캒iasa [`once_cell`](https://crates.io/crates/once_cell) are, de asemenea, "
"c칙teva tipuri utile pentru ini탵ializarea t칙rzie cu o abordare u탳or diferit캒 "
"de `spin::once::Once`."

#: src/bare-metal/useful-crates/spin.md:28
#, fuzzy
msgid ""
"The Rust Playground includes `spin`, so this example will run fine inline."
msgstr ""
"Rust Playground include `spin`, astfel c캒 acest exemplu va rula f캒r캒 "
"probleme 칥n linie."

#: src/bare-metal/android.md:3
#, fuzzy
msgid ""
"To build a bare-metal Rust binary in AOSP, you need to use a "
"`rust_ffi_static` Soong rule to build your Rust code, then a `cc_binary` "
"with a linker script to produce the binary itself, and then a `raw_binary` "
"to convert the ELF to a raw binary ready to be run."
msgstr ""
"Pentru a construi un binar Rust de tip bare-metal 칥n AOSP, trebuie s캒 "
"utiliza탵i o regul캒 Soong `rust_ffi_static` pentru a construi codul Rust, "
"apoi un `cc_binary` cu un script linker pentru a produce binarul propriu-zis "
"탳i apoi un `raw_binary` pentru a converti ELF-ul 칥ntr-un binar brut gata de "
"a fi rulat."

#: src/bare-metal/android/vmbase.md:3
#, fuzzy
msgid ""
"For VMs running under crosvm on aarch64, the [vmbase](https://android."
"googlesource.com/platform/packages/modules/Virtualization/+/refs/heads/"
"master/vmbase/) library provides a linker script and useful defaults for the "
"build rules, along with an entry point, UART console logging and more."
msgstr ""
"Pentru ma탳inile virtuale care ruleaz캒 sub crosvm pe aarch64, biblioteca "
"[vmbase](https://android.googlesource.com/platform/packages/modules/"
"Virtualization/+/refs/heads/master/vmbase/) ofer캒 un script de linker 탳i "
"valori implicite utile pentru regulile de compilare, 칥mpreun캒 cu un punct de "
"intrare, logare a consolei UART 탳i multe altele."

#: src/bare-metal/android/vmbase.md:21
#, fuzzy
msgid ""
"The `main!` macro marks your main function, to be called from the `vmbase` "
"entry point."
msgstr ""
"Macroul `main!` marcheaz캒 func탵ia principal캒, care va fi apelat캒 din punctul "
"de intrare `vmbase`."

#: src/bare-metal/android/vmbase.md:22
#, fuzzy
msgid ""
"The `vmbase` entry point handles console initialisation, and issues a "
"PSCI_SYSTEM_OFF to shutdown the VM if your main function returns."
msgstr ""
"Punctul de intrare `vmbase` se ocup캒 de ini탵ializarea consolei 탳i emite un "
"PSCI_SYSTEM_OFF pentru a 칥nchide VM dac캒 func탵ia principal캒 se 칥ntoarce."

#: src/exercises/bare-metal/afternoon.md:3
#, fuzzy
msgid "We will write a driver for the PL031 real-time clock device."
msgstr "Vom scrie un driver pentru dispozitivul de ceas 칥n timp real PL031."

#: src/exercises/bare-metal/rtc.md:1
#: src/exercises/bare-metal/solutions-afternoon.md:3
#, fuzzy
msgid "RTC driver"
msgstr "Driver RTC"

#: src/exercises/bare-metal/rtc.md:3
#, fuzzy
msgid ""
"The QEMU aarch64 virt machine has a [PL031](https://developer.arm.com/"
"documentation/ddi0224/c) real-time clock at 0x9010000. For this exercise, "
"you should write a driver for it."
msgstr ""
"Ma탳ina virtual캒 QEMU aarch64 are un ceas 칥n timp real [PL031](https://"
"developer.arm.com/documentation/ddi0224/c) la 0x9010000. Pentru acest "
"exerci탵iu, trebuie s캒 scrie탵i un driver pentru acesta."

#: src/exercises/bare-metal/rtc.md:6
#, fuzzy
msgid ""
"Use it to print the current time to the serial console. You can use the "
"[`chrono`](https://crates.io/crates/chrono) crate for date/time formatting."
msgstr ""
"Utiliza탵i-o pentru a imprima ora curent캒 pe consola serial캒. Pute탵i utiliza "
"crate-ul [`chrono`](https://crates.io/crates/chrono) pentru formatarea datei/"
"orei."

#: src/exercises/bare-metal/rtc.md:8
#, fuzzy
msgid ""
"Use the match register and raw interrupt status to busy-wait until a given "
"time, e.g. 3 seconds in the future. (Call [`core::hint::spin_loop`](https://"
"doc.rust-lang.org/core/hint/fn.spin_loop.html) inside the loop.)"
msgstr ""
"Utiliza탵i registrul de potrivire 탳i starea brut캒 a 칥ntreruperii pentru a "
"a탳tepta ocupat p칙n캒 la un anumit moment, de exemplu, 3 secunde 칥n viitor. "
"(Chema탵i [`core::hint::spin_loop`](https://doc.rust-lang.org/core/hint/fn."
"spin_loop.html) 칥n interiorul buclei)"

#: src/exercises/bare-metal/rtc.md:10
#, fuzzy
msgid ""
"_Extension if you have time:_ Enable and handle the interrupt generated by "
"the RTC match. You can use the driver provided in the [`arm-gic`](https://"
"docs.rs/arm-gic/) crate to configure the Arm Generic Interrupt Controller."
msgstr ""
"extindere dac캒 ave탵i timp:_ Activa탵i 탳i gestiona탵i 칥ntreruperea generat캒 de "
"meciul RTC. Pute탵i utiliza driverul furnizat 칥n cr캒iasa [`arm-gic`](https://"
"docs.rs/arm-gic/) pentru a configura controlerul generic de 칥ntreruperi Arm "
"Generic Interrupt Controller."

#: src/exercises/bare-metal/rtc.md:12
#, fuzzy
msgid "Use the RTC interrupt, which is wired to the GIC as `IntId::spi(2)`."
msgstr ""
"Utiliza탵i 칥ntreruperea RTC, care este conectat캒 la GIC ca `IntId::spi(2)`."

#: src/exercises/bare-metal/rtc.md:13
#, fuzzy
msgid ""
"Once the interrupt is enabled, you can put the core to sleep via `arm_gic::"
"wfi()`, which will cause the core to sleep until it receives an interrupt."
msgstr ""
"Odat캒 ce 칥ntreruperea este activat캒, pute탵i pune nucleul 칥n stare de veghe "
"prin intermediul `arm_gic::wfi()`, ceea ce va face ca nucleul s캒 doarm캒 p칙n캒 "
"c칙nd va primi o 칥ntrerupere."

#: src/exercises/bare-metal/rtc.md:16
#, fuzzy
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and "
"look in the `rtc` directory for the following files."
msgstr ""
"Desc캒rca탵i [탳ablonul de exerci탵ii] (../../comprehensive-rust-exercises.zip) "
"탳i c캒uta탵i 칥n directorul `rtc` urm캒toarele fi탳iere."

#: src/exercises/bare-metal/rtc.md:23
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"mod exceptions;\n"
"mod logger;\n"
"mod pl011;\n"
"\n"
"use crate::pl011::Uart;\n"
"use arm_gic::gicv3::GicV3;\n"
"use core::panic::PanicInfo;\n"
"use log::{error, info, trace, LevelFilter};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Base addresses of the GICv3.\n"
"const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;\n"
"const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 as _;\n"
"\n"
"/// Base address of the primary PL011 UART.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 "
"device,\n"
"    // and nothing else accesses that address range.\n"
"    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"    logger::init(uart, LevelFilter::Trace).unwrap();\n"
"\n"
"    info!(\"main({:#x}, {:#x}, {:#x}, {:#x})\", x0, x1, x2, x3);\n"
"\n"
"    // Safe because `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the "
"base\n"
"    // addresses of a GICv3 distributor and redistributor respectively, and\n"
"    // nothing else accesses those address ranges.\n"
"    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, "
"GICR_BASE_ADDRESS) };\n"
"    gic.setup();\n"
"\n"
"    // TODO: Create instance of RTC driver and print current time.\n"
"\n"
"    // TODO: Wait for 3 seconds.\n"
"\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[panic_handler]\n"
"fn panic(info: &PanicInfo) -> ! {\n"
"    error!(\"{info}\");\n"
"    system_off::<Hvc>().unwrap();\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""
"```rust,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"excep탵ii mod;\n"
"mod logger;\n"
"mod pl011;\n"
"\n"
"use crate::pl011::Uart;\n"
"use arm_gic::gicv3::GicV3;\n"
"use core::panic::PanicInfo;\n"
"use log::{error, info, trace, LevelFilter};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Adresele de baz캒 ale GICv3.\n"
"const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;\n"
"const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 ca _;\n"
"\n"
"/// Adresa de baz캒 a UART primar캒 PL011.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Sigur, deoarece `PL011_BASE_ADDRESS` este adresa de baz캒 a unui "
"dispozitiv PL011,\n"
"    // 탳i nimic altceva nu acceseaz캒 acest interval de adrese.\n"
"    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"    logger::init(uart, LevelFilter::Trace).unwrap();\n"
"\n"
"    info!(\"main({:#x}, {:#x}, {:#x}, {:#x})\", x0, x1, x2, x3);\n"
"\n"
"    // Sigur, deoarece `GICD_BASE_ADDRESS` 탳i `GICR_BASE_ADDRESS` reprezint캒 "
"baza\n"
"    // adrese ale unui distribuitor 탳i, respectiv, redistribuitor GICv3, "
"iar\n"
"    // nimic altceva nu acceseaz캒 aceste intervale de adrese.\n"
"    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, "
"GICR_BASE_ADDRESS) };\n"
"    gic.setup();\n"
"\n"
"    // TODO: Crea탵i o instan탵캒 a driverului RTC 탳i imprima탵i ora curent캒.\n"
"\n"
"    // TODO: A탳tepta탵i 3 secunde.\n"
"\n"
"    system_off:::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[panic_handler]\n"
"fn panic(info: &amp;PanicInfo) -&gt; ! {\n"
"    error!(\"{info}\");\n"
"    system_off:::<Hvc>().unwrap();\n"
"    bucla {}\n"
"}\n"
"```"

#: src/exercises/bare-metal/rtc.md:75
#, fuzzy
msgid ""
"_src/exceptions.rs_ (you should only need to change this for the 3rd part of "
"the exercise):"
msgstr ""
"_src/exceptions.rs_ (ar trebui s캒 fie nevoie s캒 modifica탵i acest lucru doar "
"pentru a treia parte a exerci탵iului):"

#: src/exercises/bare-metal/rtc.md:79
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"use arm_gic::gicv3::GicV3;\n"
"use log::{error, info, trace};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn sync_exception_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"sync_exception_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn irq_current(_elr: u64, _spsr: u64) {\n"
"    trace!(\"irq_current\");\n"
"    let intid = GicV3::get_and_acknowledge_interrupt().expect(\"No pending "
"interrupt\");\n"
"    info!(\"IRQ {intid:?}\");\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn fiq_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"fiq_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn serr_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"serr_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn sync_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"sync_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn irq_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"irq_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn fiq_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"fiq_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn serr_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"serr_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"```"
msgstr ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licen탵iat sub Licen탵a Apache, versiunea 2.0 (denumit캒 칥n continuare "
"\"Licen탵a\");\n"
"// nu ave탵i voie s캒 utiliza탵i acest fi탳ier dec칙t 칥n conformitate cu "
"Licen탵a.\n"
"// Pute탵i ob탵ine o copie a Licen탵ei la adresa\n"
"//\n"
"// http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Cu excep탵ia cazului 칥n care legea aplicabil캒 o impune sau se convine 칥n "
"scris, software-ul\n"
"// distribuit 칥n temeiul licen탵ei este distribuit pe o BAZ캑 \"AS IS\",\n"
"// F캑R캑 GARAN탴II SAU CONDI탴II DE NICI UN FEL, fie ele exprese sau "
"implicite.\n"
"// Consulta탵i Licen탵a pentru limbajul specific care reglementeaz캒 "
"permisiunile 탳i\n"
"// limit캒ri 칥n cadrul Licen탵ei.\n"
"\n"
"use arm_gic::gicv3::GicV3;\n"
"use log::{error, info, trace};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn sync_exception_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"sync_exception_current\");\n"
"    system_off:::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn irq_current(_elr: u64, _spsr: u64) {\n"
"    trace!(\"irq_current\");\n"
"    let intid = GicV3::get_and_acknowledge_interrupt().expect(\"No pending "
"interrupt\");\n"
"    info!(\"IRQ {intid:?}\");\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn fiq_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"fiq_current\");\n"
"    system_off:::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn serr_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"serr_current\");\n"
"    system_off:::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn sync_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"sync_lower\");\n"
"    system_off:::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn irq_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"irq_lower\");\n"
"    system_off:::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn fiq_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"fiq_lower\");\n"
"    system_off:::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn serr_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"serr_lower\");\n"
"    system_off:::<Hvc>().unwrap();\n"
"}\n"
"```"

#: src/exercises/bare-metal/rtc.md:149
#, fuzzy
msgid "_src/logger.rs_ (you shouldn't need to change this):"
msgstr ""
"_src/logger.rs_ (nu ar trebui s캒 fie nevoie s캒 modifica탵i acest lucru):"

#: src/exercises/bare-metal/rtc.md:153
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: main\n"
"use crate::pl011::Uart;\n"
"use core::fmt::Write;\n"
"use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};\n"
"use spin::mutex::SpinMutex;\n"
"\n"
"static LOGGER: Logger = Logger {\n"
"    uart: SpinMutex::new(None),\n"
"};\n"
"\n"
"struct Logger {\n"
"    uart: SpinMutex<Option<Uart>>,\n"
"}\n"
"\n"
"impl Log for Logger {\n"
"    fn enabled(&self, _metadata: &Metadata) -> bool {\n"
"        true\n"
"    }\n"
"\n"
"    fn log(&self, record: &Record) {\n"
"        writeln!(\n"
"            self.uart.lock().as_mut().unwrap(),\n"
"            \"[{}] {}\",\n"
"            record.level(),\n"
"            record.args()\n"
"        )\n"
"        .unwrap();\n"
"    }\n"
"\n"
"    fn flush(&self) {}\n"
"}\n"
"\n"
"/// Initialises UART logger.\n"
"pub fn init(uart: Uart, max_level: LevelFilter) -> Result<(), "
"SetLoggerError> {\n"
"    LOGGER.uart.lock().replace(uart);\n"
"\n"
"    log::set_logger(&LOGGER)?;\n"
"    log::set_max_level(max_level);\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licen탵iat sub Licen탵a Apache, versiunea 2.0 (denumit캒 칥n continuare "
"\"Licen탵a\");\n"
"// nu ave탵i voie s캒 utiliza탵i acest fi탳ier dec칙t 칥n conformitate cu "
"Licen탵a.\n"
"// Pute탵i ob탵ine o copie a Licen탵ei la adresa\n"
"//\n"
"// http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Cu excep탵ia cazului 칥n care legea aplicabil캒 o impune sau se convine 칥n "
"scris, software-ul\n"
"// distribuit 칥n temeiul licen탵ei este distribuit pe o BAZ캑 \"AS IS\",\n"
"// F캑R캑 GARAN탴II SAU CONDI탴II DE NICI UN FEL, fie ele exprese sau "
"implicite.\n"
"// Consulta탵i Licen탵a pentru limbajul specific care reglementeaz캒 "
"permisiunile 탳i\n"
"// limit캒ri 칥n cadrul Licen탵ei.\n"
"\n"
"// ANCHET캑: principal\n"
"use crate::pl011::Uart;\n"
"use core::fmt::Write;\n"
"use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};\n"
"use spin::mutex::SpinMutex;\n"
"\n"
"static LOGGER: Logger = Logger {\n"
"    uart: SpinMutex::new(None),\n"
"};\n"
"\n"
"struct Logger {\n"
"    uart: SpinMutex&lt;Option<Uart>&gt;,\n"
"}\n"
"\n"
"impl Log for Logger {\n"
"    fn enabled(&amp;self, _metadata: &amp;Metadata) -&gt; bool {\n"
"        true\n"
"    }\n"
"\n"
"    fn log(&amp;self, record: &amp;Record) {\n"
"        writeln!(\n"
"            self.uart.lock().as_mut().unwrap(),\n"
"            \"[{}] {}\",\n"
"            record.level(),\n"
"            record.args()\n"
"        )\n"
"        .unwrap();\n"
"    }\n"
"\n"
"    fn flush(&amp;self) {}\n"
"}\n"
"\n"
"/// Ini탵ializeaz캒 loggerul UART.\n"
"pub fn init(uart: Uart, max_level: LevelFilter) -&gt; Result<(), "
"SetLoggerError> {\n"
"    LOGGER.uart.lock().replace(uart);\n"
"\n"
"    log::set_logger(&amp;LOGGER)?;\n"
"    log::set_max_level(max_level);\n"
"    Ok((())\n"
"}\n"
"```"

#: src/exercises/bare-metal/rtc.md:210
#, fuzzy
msgid "_src/pl011.rs_ (you shouldn't need to change this):"
msgstr "_src/pl011.rs_ (nu ar trebui s캒 fie nevoie s캒 modifica탵i acest lucru):"

#: src/exercises/bare-metal/rtc.md:214
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"#![allow(unused)]\n"
"\n"
"use core::fmt::{self, Write};\n"
"use core::ptr::{addr_of, addr_of_mut};\n"
"\n"
"// ANCHOR: Flags\n"
"use bitflags::bitflags;\n"
"\n"
"bitflags! {\n"
"    /// Flags from the UART flag register.\n"
"    #[repr(transparent)]\n"
"    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n"
"    struct Flags: u16 {\n"
"        /// Clear to send.\n"
"        const CTS = 1 << 0;\n"
"        /// Data set ready.\n"
"        const DSR = 1 << 1;\n"
"        /// Data carrier detect.\n"
"        const DCD = 1 << 2;\n"
"        /// UART busy transmitting data.\n"
"        const BUSY = 1 << 3;\n"
"        /// Receive FIFO is empty.\n"
"        const RXFE = 1 << 4;\n"
"        /// Transmit FIFO is full.\n"
"        const TXFF = 1 << 5;\n"
"        /// Receive FIFO is full.\n"
"        const RXFF = 1 << 6;\n"
"        /// Transmit FIFO is empty.\n"
"        const TXFE = 1 << 7;\n"
"        /// Ring indicator.\n"
"        const RI = 1 << 8;\n"
"    }\n"
"}\n"
"// ANCHOR_END: Flags\n"
"\n"
"bitflags! {\n"
"    /// Flags from the UART Receive Status Register / Error Clear Register.\n"
"    #[repr(transparent)]\n"
"    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n"
"    struct ReceiveStatus: u16 {\n"
"        /// Framing error.\n"
"        const FE = 1 << 0;\n"
"        /// Parity error.\n"
"        const PE = 1 << 1;\n"
"        /// Break error.\n"
"        const BE = 1 << 2;\n"
"        /// Overrun error.\n"
"        const OE = 1 << 3;\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Registers\n"
"#[repr(C, align(4))]\n"
"struct Registers {\n"
"    dr: u16,\n"
"    _reserved0: [u8; 2],\n"
"    rsr: ReceiveStatus,\n"
"    _reserved1: [u8; 19],\n"
"    fr: Flags,\n"
"    _reserved2: [u8; 6],\n"
"    ilpr: u8,\n"
"    _reserved3: [u8; 3],\n"
"    ibrd: u16,\n"
"    _reserved4: [u8; 2],\n"
"    fbrd: u8,\n"
"    _reserved5: [u8; 3],\n"
"    lcr_h: u8,\n"
"    _reserved6: [u8; 3],\n"
"    cr: u16,\n"
"    _reserved7: [u8; 3],\n"
"    ifls: u8,\n"
"    _reserved8: [u8; 3],\n"
"    imsc: u16,\n"
"    _reserved9: [u8; 2],\n"
"    ris: u16,\n"
"    _reserved10: [u8; 2],\n"
"    mis: u16,\n"
"    _reserved11: [u8; 2],\n"
"    icr: u16,\n"
"    _reserved12: [u8; 2],\n"
"    dmacr: u8,\n"
"    _reserved13: [u8; 3],\n"
"}\n"
"// ANCHOR_END: Registers\n"
"\n"
"// ANCHOR: Uart\n"
"/// Driver for a PL011 UART.\n"
"#[derive(Debug)]\n"
"pub struct Uart {\n"
"    registers: *mut Registers,\n"
"}\n"
"\n"
"impl Uart {\n"
"    /// Constructs a new instance of the UART driver for a PL011 device at "
"the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
"    pub unsafe fn new(base_address: *mut u32) -> Self {\n"
"        Self {\n"
"            registers: base_address as *mut Registers,\n"
"        }\n"
"    }\n"
"\n"
"    /// Writes a single byte to the UART.\n"
"    pub fn write_byte(&self, byte: u8) {\n"
"        // Wait until there is room in the TX buffer.\n"
"        while self.read_flag_register().contains(Flags::TXFF) {}\n"
"\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe {\n"
"            // Write to the TX buffer.\n"
"            addr_of_mut!((*self.registers).dr).write_volatile(byte.into());\n"
"        }\n"
"\n"
"        // Wait until the UART is no longer busy.\n"
"        while self.read_flag_register().contains(Flags::BUSY) {}\n"
"    }\n"
"\n"
"    /// Reads and returns a pending byte, or `None` if nothing has been "
"received.\n"
"    pub fn read_byte(&self) -> Option<u8> {\n"
"        if self.read_flag_register().contains(Flags::RXFE) {\n"
"            None\n"
"        } else {\n"
"            let data = unsafe { addr_of!((*self.registers).dr)."
"read_volatile() };\n"
"            // TODO: Check for error conditions in bits 8-11.\n"
"            Some(data as u8)\n"
"        }\n"
"    }\n"
"\n"
"    fn read_flag_register(&self) -> Flags {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe { addr_of!((*self.registers).fr).read_volatile() }\n"
"    }\n"
"}\n"
"// ANCHOR_END: Uart\n"
"\n"
"impl Write for Uart {\n"
"    fn write_str(&mut self, s: &str) -> fmt::Result {\n"
"        for c in s.as_bytes() {\n"
"            self.write_byte(*c);\n"
"        }\n"
"        Ok(())\n"
"    }\n"
"}\n"
"\n"
"// Safe because it just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
"unsafe impl Send for Uart {}\n"
"```"
msgstr ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licen탵iat sub Licen탵a Apache, versiunea 2.0 (denumit캒 칥n continuare "
"\"Licen탵a\");\n"
"// nu ave탵i voie s캒 utiliza탵i acest fi탳ier dec칙t 칥n conformitate cu "
"Licen탵a.\n"
"// Pute탵i ob탵ine o copie a Licen탵ei la adresa\n"
"//\n"
"// http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Cu excep탵ia cazului 칥n care legea aplicabil캒 o impune sau se convine 칥n "
"scris, software-ul\n"
"// distribuit 칥n temeiul licen탵ei este distribuit pe o BAZ캑 \"AS IS\",\n"
"// F캑R캑 GARAN탴II SAU CONDI탴II DE NICI UN FEL, fie ele exprese sau "
"implicite.\n"
"// Consulta탵i Licen탵a pentru limbajul specific care reglementeaz캒 "
"permisiunile 탳i\n"
"// limit캒ri 칥n cadrul Licen탵ei.\n"
"\n"
"#![allow(unused)]\n"
"\n"
"use core::fmt::{self, Write};\n"
"use core::ptr::{addr_of, addr_of_mut};\n"
"\n"
"// ANCHOR: Flags\n"
"use bitflags::bitflags;\n"
"\n"
"bitflags! {\n"
"    /// Semnalizatoare din registrul de semnalizare UART.\n"
"    #[repr(transparent)]\n"
"    #[derive(Copy, Clone, Debug, Eq, PartialEq)]]\n"
"    struct Flags: u16 {\n"
"        /// Clear to send.\n"
"        const CTS = 1 &lt;&lt; 0;\n"
"        /// Set de date preg캒tit.\n"
"        const DSR = 1 &lt;&lt; 1;\n"
"        /// Data carrier detect.\n"
"        const DCD = 1 &lt;&lt; 2;\n"
"        /// UART ocupat캒 s캒 transmit캒 date.\n"
"        const BUSY = 1 &lt;&lt; 3;\n"
"        /// Receive FIFO este gol.\n"
"        const RXFE = 1 &lt;&lt; 4;\n"
"        /// Transmit FIFO este plin.\n"
"        const TXFF = 1 &lt;&lt; 5;\n"
"        /// Receive FIFO este plin.\n"
"        const RXFF = 1 &lt;&lt; 6;\n"
"        /// Transmit FIFO este gol.\n"
"        const TXFE = 1 &lt;&lt; 7;\n"
"        /// Indicator de inel.\n"
"        const RI = 1 &lt;&lt; 8;\n"
"    }\n"
"}\n"
"// ANCHOR_END: Steaguri\n"
"\n"
"bitflags! {\n"
"    /// Flags din registrul de stare de recep탵ie UART / registrul de "
"탳tergere a erorilor.\n"
"    #[repr(transparent)]\n"
"    #[derive(Copy, Clone, Debug, Eq, PartialEq)]]\n"
"    struct ReceiveStatus: u16 {\n"
"        /// Framing error.\n"
"        const FE = 1 &lt;&lt; 0;\n"
"        /// Eroare de paritate.\n"
"        const PE = 1 &lt;&lt; 1;\n"
"        /// Eroare de 칥ntrerupere.\n"
"        const BE = 1 &lt;&lt; 2;\n"
"        /// Eroare de dep캒탳ire.\n"
"        const OE = 1 &lt;&lt; 3;\n"
"    }\n"
"}\n"
"\n"
"// ANCHET캑: Registre\n"
"#[repr(C, align(4))]\n"
"struct Registers {\n"
"    dr: u16,\n"
"    _reserved0: [u8; 2],\n"
"    rsr: ReceiveStatus,\n"
"    _reserved1: [u8; 19],\n"
"    fr: Flags,\n"
"    _reserved2: [u8; 6],\n"
"    ilpr: u8,\n"
"    _reserved3: [u8; 3],\n"
"    ibrd: u16,\n"
"    _reserved4: [u8; 2],\n"
"    fbrd: u8,\n"
"    _reserved5: [u8; 3],\n"
"    lcr_h: u8,\n"
"    _reserved6: [u8; 3],\n"
"    cr: u16,\n"
"    _rezervat7: [u8; 3],\n"
"    ifls: u8,\n"
"    _reserved8: [u8; 3],\n"
"    imsc: u16,\n"
"    _rezervat9: [u8; 2],\n"
"    ris: u16,\n"
"    _reserved10: [u8; 2],\n"
"    mis: u16,\n"
"    _rezervat11: [u8; 2],\n"
"    icr: u16,\n"
"    _rezervat12: [u8; 2],\n"
"    dmacr: u8,\n"
"    _reserved13: [u8; 3],\n"
"}\n"
"// ANCHOR_END: Registre\n"
"\n"
"// ANCHOR: Uart\n"
"/// Driver pentru un UART PL011.\n"
"#[derive(Debug)]\n"
"pub struct Uart {\n"
"    registers: *mut Registers,\n"
"}\n"
"\n"
"impl Uart {\n"
"    /// Construie탳te o nou캒 instan탵캒 a driverului UART pentru un dispozitiv "
"PL011 la nivelul\n"
"    /// adresa de baz캒 dat캒.\n"
"    ///\n"
"    /// # Siguran탵캒\n"
"    ///\n"
"    /// Adresa de baz캒 dat캒 trebuie s캒 indice registrele de control MMIO ale "
"unui dispozitiv de tip\n"
"    /// PL011, care trebuie s캒 fie mapate 칥n spa탵iul de adrese al "
"procesului\n"
"    /// ca memorie a dispozitivului 탳i s캒 nu aib캒 alte pseudonime.\n"
"    pub unsafe fn new(base_address: *mut u32) -&gt; Self {\n"
"        Self {\n"
"            registers: base_address as *mut Registers,\n"
"        }\n"
"    }\n"
"\n"
"    /// Scrie un singur octet pe UART.\n"
"    pub fn write_byte(&amp;self, byte: u8) {\n"
"        // A탳teapt캒 p칙n캒 c칙nd exist캒 loc 칥n memoria tampon TX.\n"
"        while self.read_flag_register().contains(Flags::TXFF) {}\n"
"\n"
"        // Sigur, deoarece 탳tim c캒 self.registers indic캒 controlul\n"
"        // registre ale unui dispozitiv PL011 care este mapat "
"corespunz캒tor.\n"
"        nesigur {\n"
"            // Scrie탵i 칥n memoria tampon TX.\n"
"            addr_of_mut!((*self.registers).dr).write_volatile(byte.into());\n"
"        }\n"
"\n"
"        // A탳tepta탵i p칙n캒 c칙nd UART-ul nu mai este ocupat.\n"
"        while self.read_flag_register().contains(Flags::BUSY) {}\n"
"    }\n"
"\n"
"    /// Cite탳te 탳i returneaz캒 un octet 칥n a탳teptare sau `None` dac캒 nu a "
"fost primit nimic.\n"
"    pub fn read_byte(&amp;self) -&gt; Option<u8> {\n"
"        if self.read_flag_register().contains(Flags::RXFE) {\n"
"            None\n"
"        } else {\n"
"            let data = unsafe { addr_of!((*self.registers).dr)."
"read_volatile() };\n"
"            // TODO: Verifica탵i dac캒 exist캒 condi탵ii de eroare 칥n bi탵ii "
"8-11.\n"
"            Some(data as u8)\n"
"        }\n"
"    }\n"
"\n"
"    fn read_flag_register(&amp;self) -&gt; Flags {\n"
"        // Sigur, deoarece 탳tim c캒 self.registers indic캒 controlul\n"
"        // registre ale unui dispozitiv PL011 care este mapat "
"corespunz캒tor.\n"
"        unsafe { addr_of!((*self.registers).fr).read_volatile() } }\n"
"    }\n"
"}\n"
"// ANCHOR_END: Uart\n"
"\n"
"impl Write pentru Uart {\n"
"    fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result {\n"
"        for c in s.as_bytes() {\n"
"            self.write_byte(*c);\n"
"        }\n"
"        Ok((())\n"
"    }\n"
"}\n"
"\n"
"// Sigur, deoarece con탵ine doar un pointer c캒tre memoria dispozitivului, "
"care poate fi\n"
"// accesat캒 din orice context.\n"
"unsafe impl Send pentru Uart {}\n"
"```"

#: src/exercises/bare-metal/rtc.md:410
#, fuzzy
msgid "_build.rs_ (you shouldn't need to change this):"
msgstr "_build.rs_ (nu ar trebui s캒 fie nevoie s캒 modifica탵i acest lucru):"

#: src/exercises/bare-metal/rtc.md:414
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"use cc::Build;\n"
"use std::env;\n"
"\n"
"fn main() {\n"
"    #[cfg(target_os = \"linux\")]\n"
"    env::set_var(\"CROSS_COMPILE\", \"aarch64-linux-gnu\");\n"
"    #[cfg(not(target_os = \"linux\"))]\n"
"    env::set_var(\"CROSS_COMPILE\", \"aarch64-none-elf\");\n"
"\n"
"    Build::new()\n"
"        .file(\"entry.S\")\n"
"        .file(\"exceptions.S\")\n"
"        .file(\"idmap.S\")\n"
"        .compile(\"empty\")\n"
"}\n"
"```"
msgstr ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licen탵iat sub Licen탵a Apache, versiunea 2.0 (denumit캒 칥n continuare "
"\"Licen탵a\");\n"
"// nu ave탵i voie s캒 utiliza탵i acest fi탳ier dec칙t 칥n conformitate cu "
"Licen탵a.\n"
"// Pute탵i ob탵ine o copie a Licen탵ei la adresa\n"
"//\n"
"// http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Cu excep탵ia cazului 칥n care legea aplicabil캒 o impune sau se convine 칥n "
"scris, software-ul\n"
"// distribuit 칥n temeiul licen탵ei este distribuit pe o BAZ캑 \"AS IS\",\n"
"// F캑R캑 GARAN탴II SAU CONDI탴II DE NICI UN FEL, fie ele exprese sau "
"implicite.\n"
"// Consulta탵i Licen탵a pentru limbajul specific care reglementeaz캒 "
"permisiunile 탳i\n"
"// limit캒ri 칥n cadrul Licen탵ei.\n"
"\n"
"utiliza탵i cc::Build;\n"
"use std::env;\n"
"\n"
"fn main() {\n"
"    #[cfg(target_os = \"linux\")]]\n"
"    env::set_var(\"CROSS_COMPILE\", \"aarch64-linux-gnu\");\n"
"    #[cfg(not(target_os = \"linux\"))]]\n"
"    env::set_var(\"CROSS_COMPILE\", \"aarch64-none-elf\");\n"
"\n"
"    Build::new()\n"
"        .file(\"entry.S\")\n"
"        .file(\"exceptions.S\")\n"
"        .file(\"idmap.S\")\n"
"        .compile(\"empty\")\n"
"}\n"
"```"

#: src/exercises/bare-metal/rtc.md:446
#, fuzzy
msgid "_entry.S_ (you shouldn't need to change this):"
msgstr "_entry.S_ (nu ar trebui s캒 fie nevoie s캒 modifica탵i acest lucru):"

#: src/exercises/bare-metal/rtc.md:450
#, fuzzy
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
".macro adr_l, reg:req, sym:req\n"
"\tadrp \\reg, \\sym\n"
"\tadd \\reg, \\reg, :lo12:\\sym\n"
".endm\n"
"\n"
".macro mov_i, reg:req, imm:req\n"
"\tmovz \\reg, :abs_g3:\\imm\n"
"\tmovk \\reg, :abs_g2_nc:\\imm\n"
"\tmovk \\reg, :abs_g1_nc:\\imm\n"
"\tmovk \\reg, :abs_g0_nc:\\imm\n"
".endm\n"
"\n"
".set .L_MAIR_DEV_nGnRE,\t0x04\n"
".set .L_MAIR_MEM_WBWA,\t0xff\n"
".set .Lmairval, .L_MAIR_DEV_nGnRE | (.L_MAIR_MEM_WBWA << 8)\n"
"\n"
"/* 4 KiB granule size for TTBR0_EL1. */\n"
".set .L_TCR_TG0_4KB, 0x0 << 14\n"
"/* 4 KiB granule size for TTBR1_EL1. */\n"
".set .L_TCR_TG1_4KB, 0x2 << 30\n"
"/* Disable translation table walk for TTBR1_EL1, generating a translation "
"fault instead. */\n"
".set .L_TCR_EPD1, 0x1 << 23\n"
"/* Translation table walks for TTBR0_EL1 are inner sharable. */\n"
".set .L_TCR_SH_INNER, 0x3 << 12\n"
"/*\n"
" * Translation table walks for TTBR0_EL1 are outer write-back read-allocate "
"write-allocate\n"
" * cacheable.\n"
" */\n"
".set .L_TCR_RGN_OWB, 0x1 << 10\n"
"/*\n"
" * Translation table walks for TTBR0_EL1 are inner write-back read-allocate "
"write-allocate\n"
" * cacheable.\n"
" */\n"
".set .L_TCR_RGN_IWB, 0x1 << 8\n"
"/* Size offset for TTBR0_EL1 is 2**39 bytes (512 GiB). */\n"
".set .L_TCR_T0SZ_512, 64 - 39\n"
".set .Ltcrval, .L_TCR_TG0_4KB | .L_TCR_TG1_4KB | .L_TCR_EPD1 | ."
"L_TCR_RGN_OWB\n"
".set .Ltcrval, .Ltcrval | .L_TCR_RGN_IWB | .L_TCR_SH_INNER | ."
"L_TCR_T0SZ_512\n"
"\n"
"/* Stage 1 instruction access cacheability is unaffected. */\n"
".set .L_SCTLR_ELx_I, 0x1 << 12\n"
"/* SP alignment fault if SP is not aligned to a 16 byte boundary. */\n"
".set .L_SCTLR_ELx_SA, 0x1 << 3\n"
"/* Stage 1 data access cacheability is unaffected. */\n"
".set .L_SCTLR_ELx_C, 0x1 << 2\n"
"/* EL0 and EL1 stage 1 MMU enabled. */\n"
".set .L_SCTLR_ELx_M, 0x1 << 0\n"
"/* Privileged Access Never is unchanged on taking an exception to EL1. */\n"
".set .L_SCTLR_EL1_SPAN, 0x1 << 23\n"
"/* SETEND instruction disabled at EL0 in aarch32 mode. */\n"
".set .L_SCTLR_EL1_SED, 0x1 << 8\n"
"/* Various IT instructions are disabled at EL0 in aarch32 mode. */\n"
".set .L_SCTLR_EL1_ITD, 0x1 << 7\n"
".set .L_SCTLR_EL1_RES1, (0x1 << 11) | (0x1 << 20) | (0x1 << 22) | (0x1 << "
"28) | (0x1 << 29)\n"
".set .Lsctlrval, .L_SCTLR_ELx_M | .L_SCTLR_ELx_C | .L_SCTLR_ELx_SA | ."
"L_SCTLR_EL1_ITD | .L_SCTLR_EL1_SED\n"
".set .Lsctlrval, .Lsctlrval | .L_SCTLR_ELx_I | .L_SCTLR_EL1_SPAN | ."
"L_SCTLR_EL1_RES1\n"
"\n"
"/**\n"
" * This is a generic entry point for an image. It carries out the operations "
"required to prepare the\n"
" * loaded image to be run. Specifically, it zeroes the bss section using "
"registers x25 and above,\n"
" * prepares the stack, enables floating point, and sets up the exception "
"vector. It preserves x0-x3\n"
" * for the Rust entry point, as these may contain boot parameters.\n"
" */\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"\t/* Load and apply the memory management configuration, ready to enable MMU "
"and caches. */\n"
"\tadrp x30, idmap\n"
"\tmsr ttbr0_el1, x30\n"
"\n"
"\tmov_i x30, .Lmairval\n"
"\tmsr mair_el1, x30\n"
"\n"
"\tmov_i x30, .Ltcrval\n"
"\t/* Copy the supported PA range into TCR_EL1.IPS. */\n"
"\tmrs x29, id_aa64mmfr0_el1\n"
"\tbfi x30, x29, #32, #4\n"
"\n"
"\tmsr tcr_el1, x30\n"
"\n"
"\tmov_i x30, .Lsctlrval\n"
"\n"
"\t/*\n"
"\t * Ensure everything before this point has completed, then invalidate any "
"potentially stale\n"
"\t * local TLB entries before they start being used.\n"
"\t */\n"
"\tisb\n"
"\ttlbi vmalle1\n"
"\tic iallu\n"
"\tdsb nsh\n"
"\tisb\n"
"\n"
"\t/*\n"
"\t * Configure sctlr_el1 to enable MMU and cache and don't proceed until "
"this has completed.\n"
"\t */\n"
"\tmsr sctlr_el1, x30\n"
"\tisb\n"
"\n"
"\t/* Disable trapping floating point access in EL1. */\n"
"\tmrs x30, cpacr_el1\n"
"\torr x30, x30, #(0x3 << 20)\n"
"\tmsr cpacr_el1, x30\n"
"\tisb\n"
"\n"
"\t/* Zero out the bss section. */\n"
"\tadr_l x29, bss_begin\n"
"\tadr_l x30, bss_end\n"
"0:\tcmp x29, x30\n"
"\tb.hs 1f\n"
"\tstp xzr, xzr, [x29], #16\n"
"\tb 0b\n"
"\n"
"1:\t/* Prepare the stack. */\n"
"\tadr_l x30, boot_stack_end\n"
"\tmov sp, x30\n"
"\n"
"\t/* Set up exception vector. */\n"
"\tadr x30, vector_table_el1\n"
"\tmsr vbar_el1, x30\n"
"\n"
"\t/* Call into Rust code. */\n"
"\tbl main\n"
"\n"
"\t/* Loop forever waiting for interrupts. */\n"
"2:\twfi\n"
"\tb 2b\n"
"```"
msgstr ""
"```armasm\n"
"/*\n"
" * Drepturi de autor 2023 Google LLC\n"
" *\n"
" * Licen탵iat sub licen탵a Apache License, versiunea 2.0 (\"Licen탵a\");\n"
" * nu ave탵i voie s캒 utiliza탵i acest fi탳ier dec칙t 칥n conformitate cu "
"Licen탵a.\n"
" * Pute탵i ob탵ine o copie a Licen탵ei la adresa\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Cu excep탵ia cazului 칥n care legisla탵ia aplicabil캒 o impune sau se convine "
"칥n scris, software-ul\n"
" * distribuit 칥n temeiul licen탵ei este distribuit pe o BAZ캑 \"AS IS\",\n"
" * F캑R캑 GARAN탴II SAU CONDI탴II DE NICI UN FEL, fie ele exprese sau "
"implicite.\n"
" * Consulta탵i Licen탵a pentru limbajul specific care reglementeaz캒 "
"permisiunile 탳i\n"
" * limit캒ri 칥n cadrul Licen탵ei.\n"
" */\n"
"\n"
".macro adr_l, reg:req, sym:req\n"
"\tadrp \\reg, \\sym\n"
"\tadd \\reg, \\reg, :lo12:\\sym\n"
".endm\n"
"\n"
".macro mov_i, reg:req, imm:req\n"
"\tmovz \\reg, :abs_g3:\\imm\n"
"\tmovk \\reg, :abs_g2_nc:\\imm\n"
"\tmovk \\reg, :abs_g1_nc:\\imm\n"
"\tmovk \\reg, :abs_g0_nc:\\imm\n"
".endm\n"
"\n"
".set .L_MAIR_DEV_nGnRE, 0x04\n"
".set .L_MAIR_MEM_WBWA, 0xff\n"
".set .Lmairval, .L_MAIR_DEV_nGnRE | (.L_MAIR_MEM_WBWA << 8)\n"
"\n"
"/* dimensiunea granulelor de 4 KiB pentru TTBR0_EL1. */\n"
".set .L_TCR_TG0_4KB, 0x0 << 14\n"
"/* dimensiunea granulelor de 4 KiB pentru TTBR1_EL1. */\n"
".set .L_TCR_TG1_4KB, 0x2 << 30\n"
"/* Dezactiveaz캒 mersul pe tabela de traducere pentru TTBR1_EL1, gener칙nd 칥n "
"schimb o eroare de traducere. */\n"
".set .L_TCR_EPD1, 0x1 << 23\n"
"/* Plimb캒rile tabelelor de traducere pentru TTBR0_EL1 sunt partajabile la "
"nivel intern. */\n"
".set .L_TCR_SH_INNER, 0x3 << 12\n"
"/*\n"
" * Mersul tabelelor de conversie pentru TTBR0_EL1 este de tip write-back "
"extern read-allocate write-allocate\n"
" * cu memorie cache.\n"
" */\n"
".set .L_TCR_RGN_OWB, 0x1 << 10\n"
"/*\n"
" * Traducerea tabelelor de conversie pentru TTBR0_EL1 sunt de tip write-back "
"read-allocate write-allocate interior\n"
" * care pot fi stocate 칥n memoria cache.\n"
" */\n"
".set .L_TCR_RGN_IWB, 0x1 << 8\n"
"/* Decalajul de dimensiune pentru TTBR0_EL1 este de 2**39 octe탵i (512 GiB). "
"*/\n"
".set .L_TCR_T0SZ_512, 64 - 39\n"
".set .Ltcrval, .L_TCR_TG0_4KB | .L_TCR_TG1_4KB | .L_TCR_EPD1 | ."
"L_TCR_RGN_OWB\n"
".set .Ltcrval, .Ltcrval | .L_TCR_RGN_IWB | .L_TCR_SH_INNER | ."
"L_TCR_T0SZ_512\n"
"\n"
"/* Nu este afectat캒 capacitatea de stocare 칥n memoria cache a accesului la "
"instruc탵iunile din etapa 1. */\n"
".set .L_SCTLR_ELx_I, 0x1 << 12\n"
"/* Defec탵iune de aliniere SP dac캒 SP nu este aliniat la o limit캒 de 16 "
"octe탵i. */\n"
".set .L_SCTLR_ELx_SA, 0x1 << 3\n"
"/* Cacheabilitatea accesului la datele din etapa 1 nu este afectat캒. */\n"
".set .L_SCTLR_ELx_C, 0x1 << 2\n"
"/* Etapa 1 a MMU EL0 탳i EL1 a fost activat캒. */\n"
".set .L_SCTLR_ELx_M, 0x1 << 0\n"
"/* Privileged Access Never este neschimbat la luarea unei excep탵ii la EL1. "
"*/\n"
".set .L_SCTLR_EL1_SPAN, 0x1 << 23\n"
"/* Instruc탵iunea SETEND dezactivat캒 la EL0 칥n modul aarch32. */\n"
".set .L_SCTLR_EL1_SED, 0x1 << 8\n"
"/* Diverse instruc탵iuni IT sunt dezactivate la EL0 칥n modul aarch32. */\n"
".set .L_SCTLR_EL1_ITD, 0x1 << 7\n"
".set .L_SCTLR_EL1_RES1, (0x1 << 11) | (0x1 << 20) | (0x1 << 22) | (0x1 << "
"28) | (0x1 << 29)\n"
".set .Lsctlrval, .L_SCTLR_ELx_M | .L_SCTLR_ELx_C | .L_SCTLR_ELx_SA | ."
"L_SCTLR_EL1_ITD | .L_SCTLR_EL1_SED\n"
".set .Lsctlrval, .Lsctlrval | .L_SCTLR_ELx_I | .L_SCTLR_EL1_SPAN | ."
"L_SCTLR_EL1_RES1\n"
"\n"
"/**\n"
" * Acesta este un punct de intrare generic pentru o imagine. Acesta "
"efectueaz캒 opera탵iile necesare pentru a preg캒ti imaginea\n"
" * imaginea 칥nc캒rcat캒 pentru a fi rulat캒. 칉n mod specific, se reseteaz캒 la "
"zero sec탵iunea bss folosind registrele x25 탳i mai sus,\n"
" * preg캒te탳te stiva, activeaz캒 virgul캒 mobil캒 탳i stabile탳te vectorul de "
"excep탵ii. P캒streaz캒 x0-x3\n"
" * pentru punctul de intrare Rust, deoarece acestea pot con탵ine parametrii "
"de pornire.\n"
" */\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"\t/* 칉ncarc캒 탳i aplic캒 configura탵ia de gestionare a memoriei, gata s캒 "
"activeze MMU 탳i cache-urile. */\n"
"\tadrp x30, idmap\n"
"\tmsr ttbr0_el1, x30\n"
"\n"
"\tmov_i x30, .Lmairval\n"
"\tmsr mair_el1, x30\n"
"\n"
"\tmov_i x30, .Ltcrval\n"
"\t/* Copiaz캒 intervalul PA acceptat 칥n TCR_EL1.IPS. */\n"
"\tmrs x29, id_aa64mmfr0_el1\n"
"\tbfi x30, x29, #32, #4\n"
"\n"
"\tmsr tcr_el1, x30\n"
"\n"
"\tmov_i x30, .Lsctlrval\n"
"\n"
"\t/*\n"
"\t * Asigur캒-te c캒 tot ceea ce s-a 칥nt칙mplat 칥nainte de acest punct s-a "
"finalizat, apoi invalideaz캒 orice date poten탵ial vechi\n"
"\t * locale TLB 칥nainte ca acestea s캒 칥nceap캒 s캒 fie utilizate.\n"
"\t */\n"
"\tisb\n"
"\ttlbi vmalle1\n"
"\tic iallu\n"
"\tdsb nsh\n"
"\tisb\n"
"\n"
"\t/*\n"
"\t * Configura탵i sctlr_el1 pentru a activa MMU 탳i memoria cache 탳i nu "
"continua탵i p칙n캒 c칙nd acest lucru nu este finalizat.\n"
"\t */\n"
"\tmsr sctlr_el1, x30\n"
"\tisb\n"
"\n"
"\t/* Dezactiveaz캒 captarea accesului 칥n virgul캒 mobil캒 칥n EL1. */\n"
"\tmrs x30, cpacr_el1\n"
"\torr x30, x30, #(0x3 << 20)\n"
"\tmsr cpacr_el1, x30\n"
"\tisb\n"
"\n"
"\t/* Elimin캒 sec탵iunea bss. */\n"
"\tadr_l x29, bss_begin\n"
"\tadr_l x30, bss_end\n"
"0: cmp x29, x30\n"
"\tb.hs 1f\n"
"\tstp xzr, xzr, [x29], #16\n"
"\tb 0b\n"
"\n"
"1: /* Preg캒te탳te stiva. */\n"
"\tadr_l x30, boot_stack_end\n"
"\tmov sp, x30\n"
"\n"
"\t/* Seteaz캒 vectorul de excep탵ie. */\n"
"\tadr x30, vector_table_el1\n"
"\tmsr vbar_el1, x30\n"
"\n"
"\t/* Apel 칥n codul Rust. */\n"
"\tbl main\n"
"\n"
"\t/* Bucla ve탳nic캒 칥n a탳teptarea 칥ntreruperilor. */\n"
"2: wfi\n"
"\tb 2b\n"
"```"

#: src/exercises/bare-metal/rtc.md:595
#, fuzzy
msgid "_exceptions.S_ (you shouldn't need to change this):"
msgstr "_exceptions.S_ (nu ar trebui s캒 fie nevoie s캒 modifica탵i acest lucru):"

#: src/exercises/bare-metal/rtc.md:599
#, fuzzy
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"/**\n"
" * Saves the volatile registers onto the stack. This currently takes 14\n"
" * instructions, so it can be used in exception handlers with 18 "
"instructions\n"
" * left.\n"
" *\n"
" * On return, x0 and x1 are initialised to elr_el2 and spsr_el2 "
"respectively,\n"
" * which can be used as the first and second arguments of a subsequent "
"call.\n"
" */\n"
".macro save_volatile_to_stack\n"
"\t/* Reserve stack space and save registers x0-x18, x29 & x30. */\n"
"\tstp x0, x1, [sp, #-(8 * 24)]!\n"
"\tstp x2, x3, [sp, #8 * 2]\n"
"\tstp x4, x5, [sp, #8 * 4]\n"
"\tstp x6, x7, [sp, #8 * 6]\n"
"\tstp x8, x9, [sp, #8 * 8]\n"
"\tstp x10, x11, [sp, #8 * 10]\n"
"\tstp x12, x13, [sp, #8 * 12]\n"
"\tstp x14, x15, [sp, #8 * 14]\n"
"\tstp x16, x17, [sp, #8 * 16]\n"
"\tstr x18, [sp, #8 * 18]\n"
"\tstp x29, x30, [sp, #8 * 20]\n"
"\n"
"\t/*\n"
"\t * Save elr_el1 & spsr_el1. This such that we can take nested exception\n"
"\t * and still be able to unwind.\n"
"\t */\n"
"\tmrs x0, elr_el1\n"
"\tmrs x1, spsr_el1\n"
"\tstp x0, x1, [sp, #8 * 22]\n"
".endm\n"
"\n"
"/**\n"
" * Restores the volatile registers from the stack. This currently takes 14\n"
" * instructions, so it can be used in exception handlers while still leaving "
"18\n"
" * instructions left; if paired with save_volatile_to_stack, there are 4\n"
" * instructions to spare.\n"
" */\n"
".macro restore_volatile_from_stack\n"
"\t/* Restore registers x2-x18, x29 & x30. */\n"
"\tldp x2, x3, [sp, #8 * 2]\n"
"\tldp x4, x5, [sp, #8 * 4]\n"
"\tldp x6, x7, [sp, #8 * 6]\n"
"\tldp x8, x9, [sp, #8 * 8]\n"
"\tldp x10, x11, [sp, #8 * 10]\n"
"\tldp x12, x13, [sp, #8 * 12]\n"
"\tldp x14, x15, [sp, #8 * 14]\n"
"\tldp x16, x17, [sp, #8 * 16]\n"
"\tldr x18, [sp, #8 * 18]\n"
"\tldp x29, x30, [sp, #8 * 20]\n"
"\n"
"\t/* Restore registers elr_el1 & spsr_el1, using x0 & x1 as scratch. */\n"
"\tldp x0, x1, [sp, #8 * 22]\n"
"\tmsr elr_el1, x0\n"
"\tmsr spsr_el1, x1\n"
"\n"
"\t/* Restore x0 & x1, and release stack space. */\n"
"\tldp x0, x1, [sp], #8 * 24\n"
".endm\n"
"\n"
"/**\n"
" * This is a generic handler for exceptions taken at the current EL while "
"using\n"
" * SP0. It behaves similarly to the SPx case by first switching to SPx, "
"doing\n"
" * the work, then switching back to SP0 before returning.\n"
" *\n"
" * Switching to SPx and calling the Rust handler takes 16 instructions. To\n"
" * restore and return we need an additional 16 instructions, so we can "
"implement\n"
" * the whole handler within the allotted 32 instructions.\n"
" */\n"
".macro current_exception_sp0 handler:req\n"
"\tmsr spsel, #1\n"
"\tsave_volatile_to_stack\n"
"\tbl \\handler\n"
"\trestore_volatile_from_stack\n"
"\tmsr spsel, #0\n"
"\teret\n"
".endm\n"
"\n"
"/**\n"
" * This is a generic handler for exceptions taken at the current EL while "
"using\n"
" * SPx. It saves volatile registers, calls the Rust handler, restores "
"volatile\n"
" * registers, then returns.\n"
" *\n"
" * This also works for exceptions taken from EL0, if we don't care about\n"
" * non-volatile registers.\n"
" *\n"
" * Saving state and jumping to the Rust handler takes 15 instructions, and\n"
" * restoring and returning also takes 15 instructions, so we can fit the "
"whole\n"
" * handler in 30 instructions, under the limit of 32.\n"
" */\n"
".macro current_exception_spx handler:req\n"
"\tsave_volatile_to_stack\n"
"\tbl \\handler\n"
"\trestore_volatile_from_stack\n"
"\teret\n"
".endm\n"
"\n"
".section .text.vector_table_el1, \"ax\"\n"
".global vector_table_el1\n"
".balign 0x800\n"
"vector_table_el1:\n"
"sync_cur_sp0:\n"
"\tcurrent_exception_sp0 sync_exception_current\n"
"\n"
".balign 0x80\n"
"irq_cur_sp0:\n"
"\tcurrent_exception_sp0 irq_current\n"
"\n"
".balign 0x80\n"
"fiq_cur_sp0:\n"
"\tcurrent_exception_sp0 fiq_current\n"
"\n"
".balign 0x80\n"
"serr_cur_sp0:\n"
"\tcurrent_exception_sp0 serr_current\n"
"\n"
".balign 0x80\n"
"sync_cur_spx:\n"
"\tcurrent_exception_spx sync_exception_current\n"
"\n"
".balign 0x80\n"
"irq_cur_spx:\n"
"\tcurrent_exception_spx irq_current\n"
"\n"
".balign 0x80\n"
"fiq_cur_spx:\n"
"\tcurrent_exception_spx fiq_current\n"
"\n"
".balign 0x80\n"
"serr_cur_spx:\n"
"\tcurrent_exception_spx serr_current\n"
"\n"
".balign 0x80\n"
"sync_lower_64:\n"
"\tcurrent_exception_spx sync_lower\n"
"\n"
".balign 0x80\n"
"irq_lower_64:\n"
"\tcurrent_exception_spx irq_lower\n"
"\n"
".balign 0x80\n"
"fiq_lower_64:\n"
"\tcurrent_exception_spx fiq_lower\n"
"\n"
".balign 0x80\n"
"serr_lower_64:\n"
"\tcurrent_exception_spx serr_lower\n"
"\n"
".balign 0x80\n"
"sync_lower_32:\n"
"\tcurrent_exception_spx sync_lower\n"
"\n"
".balign 0x80\n"
"irq_lower_32:\n"
"\tcurrent_exception_spx irq_lower\n"
"\n"
".balign 0x80\n"
"fiq_lower_32:\n"
"\tcurrent_exception_spx fiq_lower\n"
"\n"
".balign 0x80\n"
"serr_lower_32:\n"
"\tcurrent_exception_spx serr_lower\n"
"```"
msgstr ""
"```armasm\n"
"/*\n"
" * Drepturi de autor 2023 Google LLC\n"
" *\n"
" * Licen탵iat sub licen탵a Apache License, versiunea 2.0 (\"Licen탵a\");\n"
" * nu ave탵i voie s캒 utiliza탵i acest fi탳ier dec칙t 칥n conformitate cu "
"Licen탵a.\n"
" * Pute탵i ob탵ine o copie a Licen탵ei la adresa\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Cu excep탵ia cazului 칥n care legisla탵ia aplicabil캒 o impune sau se convine "
"칥n scris, software-ul\n"
" * distribuit 칥n temeiul licen탵ei este distribuit pe o BAZ캑 \"AS IS\",\n"
" * F캑R캑 GARAN탴II SAU CONDI탴II DE NICI UN FEL, fie ele exprese sau "
"implicite.\n"
" * Consulta탵i Licen탵a pentru limbajul specific care reglementeaz캒 "
"permisiunile 탳i\n"
" * limit캒ri 칥n cadrul Licen탵ei.\n"
" */\n"
"\n"
"/**\n"
" * Salveaz캒 registrele volatile pe stiv캒. Acest lucru dureaz캒 칥n prezent 14\n"
" * instruc탵iuni, astfel 칥nc칙t poate fi utilizat 칥n gestionarii de excep탵ii "
"cu 18 instruc탵iuni\n"
" * st칙nga.\n"
" *\n"
" * La 칥ntoarcere, x0 탳i x1 sunt ini탵ializate la elr_el2 탳i, respectiv, "
"spsr_el2,\n"
" * care pot fi utilizate ca primul 탳i al doilea argument al unui apel "
"ulterior.\n"
" */\n"
".macro save_volatile_to_stack\n"
"\t/* Rezerv캒 spa탵iul stivei 탳i salveaz캒 registrele x0-x18, x29 & x30. */\n"
"\tstp x0, x1, [sp, #-(8 * 24)]!\n"
"\tstp x2, x3, [sp, #8 * 2]\n"
"\tstp x4, x5, [sp, #8 * 4]\n"
"\tstp x6, x7, [sp, #8 * 6]\n"
"\tstp x8, x9, [sp, #8 * 8]\n"
"\tstp x10, x11, [sp, #8 * 10]\n"
"\tstp x12, x13, [sp, #8 * 12]\n"
"\tstp x14, x15, [sp, #8 * 14]\n"
"\tstp x16, x17, [sp, #8 * 16]\n"
"\tstr x18, [sp, #8 * 18]\n"
"\tstp x29, x30, [sp, #8 * 20]\n"
"\n"
"\t/*\n"
"\t * Salva탵i elr_el1 & spsr_el1. Acest lucru astfel 칥nc칙t s캒 putem lua "
"excep탵ii imbricate\n"
"\t * 탳i totu탳i s캒 putem derula.\n"
"\t */\n"
"\tmrs x0, elr_el1\n"
"\tmrs x1, spsr_el1\n"
"\tstp x0, x1, [sp, #8 * 22]\n"
".endm\n"
"\n"
"/**\n"
" * Restabile탳te registrele volatile din stiv캒. 칉n prezent, acest lucru "
"dureaz캒 14\n"
" * instruc탵iuni, astfel 칥nc칙t poate fi utilizat캒 칥n gestionarii de excep탵ii, "
"l캒s칙nd 칥n continuare 18\n"
" * instruc탵iuni r캒mase; dac캒 este asociat cu save_volatile_to_stack, mai "
"r캒m칙n 4 instruc탵iuni\n"
" * instruc탵iuni de rezerv캒.\n"
" */\n"
".macro restore_volatile_from_stack\n"
"\t/* Restaureaz캒 registrele x2-x18, x29 탳i x30. */\n"
"\tldp x2, x3, [sp, #8 * 2]\n"
"\tldp x4, x5, [sp, #8 * 4]\n"
"\tldp x6, x7, [sp, #8 * 6]\n"
"\tldp x8, x9, [sp, #8 * 8]\n"
"\tldp x10, x11, [sp, #8 * 10]\n"
"\tldp x12, x13, [sp, #8 * 12]\n"
"\tldp x14, x15, [sp, #8 * 14]\n"
"\tldp x16, x17, [sp, #8 * 16]\n"
"\tldr x18, [sp, #8 * 18]\n"
"\tldp x29, x30, [sp, #8 * 20]\n"
"\n"
"\t/* Restaura탵i registrele elr_el1 & spsr_el1, folosind x0 & x1 ca zero. */\n"
"\tldp x0, x1, [sp, #8 * 22]\n"
"\tmsr elr_el1, x0\n"
"\tmsr spsr_el1, x1\n"
"\n"
"\t/* Restaura탵i x0 & x1 탳i elibera탵i spa탵iul din stiv캒. */\n"
"\tldp x0, x1, [sp], #8 * 24\n"
".endm\n"
"\n"
"/**\n"
" * Acesta este un gestionar generic pentru excep탵iile luate la EL curent 칥n "
"timp ce se utilizeaz캒\n"
" * SP0. Se comport캒 칥n mod similar cu cazul SPx, trec칙nd mai 칥nt칙i la SPx, "
"f캒c칙nd\n"
" * treaba, apoi revine la SP0 칥nainte de a se 칥ntoarce.\n"
" *\n"
" * Comutarea 칥n SPx 탳i apelarea gestionarului Rust necesit캒 16 instruc탵iuni. "
"La\n"
" * restabilirea 탳i 칥ntoarcerea avem nevoie de 칥nc캒 16 instruc탵iuni, astfel "
"칥nc칙t s캒 putem implementa\n"
" * 칥ntregul manipulator 칥n cele 32 de instruc탵iuni alocate.\n"
" */\n"
".macro current_exception_sp0 handler:req\n"
"\tmsr spsel, #1\n"
"\tsave_volatile_to_stack\n"
"\tbl \\handler\n"
"\trestore_volatile_from_stack\n"
"\tmsr spsel, #0\n"
"\teret\n"
".endm\n"
"\n"
"/**\n"
" * Acesta este un gestionar generic pentru excep탵iile luate la EL curent 칥n "
"timp ce se utilizeaz캒\n"
" * SPx. Acesta salveaz캒 registrele volatile, apeleaz캒 gestionarul Rust, "
"restabile탳te registrele volatile\n"
" * 탳i apoi se 칥ntoarce.\n"
" *\n"
" * Acest lucru func탵ioneaz캒 탳i pentru excep탵iile luate din EL0, dac캒 nu ne "
"pas캒 de\n"
" * registrele nevolatile.\n"
" *\n"
" * Salvarea st캒rii 탳i saltul la gestionarul Rust dureaz캒 15 instruc탵iuni, "
"iar\n"
" * restabilirea 탳i 칥ntoarcerea dureaz캒, de asemenea, 15 instruc탵iuni, astfel "
"칥nc칙t putem 칥ncadra 칥ntreaga\n"
" * 칥n 30 de instruc탵iuni, sub limita de 32.\n"
" */\n"
".macro current_exception_spx handler:req\n"
"\tsave_volatile_to_stack\n"
"\tbl \\handler\n"
"\trestore_volatile_from_stack\n"
"\teret\n"
".endm\n"
"\n"
".section .text.vector_table_el1, \"ax\"\n"
".global vector_table_el1\n"
".balign 0x800\n"
"vector_table_el1:\n"
"sync_cur_sp0:\n"
"\tcurrent_exception_sp0 sync_exception_current\n"
"\n"
".balign 0x80\n"
"irq_cur_sp0:\n"
"\tcurrent_exception_sp0 irq_current\n"
"\n"
".balign 0x80\n"
"fiq_cur_sp0:\n"
"\tcurrent_exception_sp0 fiq_current\n"
"\n"
".balign 0x80\n"
"serr_cur_sp0:\n"
"\tcurrent_exception_sp0 serr_current\n"
"\n"
".balign 0x80\n"
"sync_cur_spx:\n"
"\tcurrent_exception_spx sync_exception_current\n"
"\n"
".balign 0x80\n"
"irq_cur_spx:\n"
"\tcurrent_exception_spx irq_current\n"
"\n"
".balign 0x80\n"
"fiq_cur_spx:\n"
"\tcurrent_exception_spx fiq_current\n"
"\n"
".balign 0x80\n"
"serr_cur_spx:\n"
"\tcurrent_exception_spx serr_current\n"
"\n"
".balign 0x80\n"
"sync_lower_64:\n"
"\tcurrent_exception_spx sync_lower\n"
"\n"
".balign 0x80\n"
"irq_lower_64:\n"
"\tcurrent_exception_spx irq_lower\n"
"\n"
".balign 0x80\n"
"fiq_lower_64:\n"
"\tcurrent_exception_spx fiq_lower\n"
"\n"
".balign 0x80\n"
"serr_lower_64:\n"
"\tcurrent_exception_spx serr_lower\n"
"\n"
".balign 0x80\n"
"sync_lower_32:\n"
"\tcurrent_exception_spx sync_lower\n"
"\n"
".balign 0x80\n"
"irq_lower_32:\n"
"\tcurrent_exception_spx irq_lower\n"
"\n"
".balign 0x80\n"
"fiq_lower_32:\n"
"\tcurrent_exception_spx fiq_lower\n"
"\n"
".balign 0x80\n"
"serr_lower_32:\n"
"\tcurrent_exception_spx serr_lower\n"
"```"

#: src/exercises/bare-metal/rtc.md:780
#, fuzzy
msgid "_idmap.S_ (you shouldn't need to change this):"
msgstr "_idmap.S_ (nu ar trebui s캒 fie nevoie s캒 modifica탵i acest lucru):"

#: src/exercises/bare-metal/rtc.md:784
#, fuzzy
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
".set .L_TT_TYPE_BLOCK, 0x1\n"
".set .L_TT_TYPE_PAGE,  0x3\n"
".set .L_TT_TYPE_TABLE, 0x3\n"
"\n"
"/* Access flag. */\n"
".set .L_TT_AF, 0x1 << 10\n"
"/* Not global. */\n"
".set .L_TT_NG, 0x1 << 11\n"
".set .L_TT_XN, 0x3 << 53\n"
"\n"
".set .L_TT_MT_DEV, 0x0 << 2\t\t\t// MAIR #0 (DEV_nGnRE)\n"
".set .L_TT_MT_MEM, (0x1 << 2) | (0x3 << 8)\t// MAIR #1 (MEM_WBWA), inner "
"shareable\n"
"\n"
".set .L_BLOCK_DEV, .L_TT_TYPE_BLOCK | .L_TT_MT_DEV | .L_TT_AF | .L_TT_XN\n"
".set .L_BLOCK_MEM, .L_TT_TYPE_BLOCK | .L_TT_MT_MEM | .L_TT_AF | .L_TT_NG\n"
"\n"
".section \".rodata.idmap\", \"a\", %progbits\n"
".global idmap\n"
".align 12\n"
"idmap:\n"
"\t/* level 1 */\n"
"\t.quad\t\t.L_BLOCK_DEV | 0x0\t\t    // 1 GiB of device mappings\n"
"\t.quad\t\t.L_BLOCK_MEM | 0x40000000\t// 1 GiB of DRAM\n"
"\t.fill\t\t254, 8, 0x0\t\t\t// 254 GiB of unmapped VA space\n"
"\t.quad\t\t.L_BLOCK_DEV | 0x4000000000 // 1 GiB of device mappings\n"
"\t.fill\t\t255, 8, 0x0\t\t\t// 255 GiB of remaining VA space\n"
"```"
msgstr ""
"```armasm\n"
"/*\n"
" * Drepturi de autor 2023 Google LLC\n"
" *\n"
" * Licen탵iat sub licen탵a Apache License, versiunea 2.0 (\"Licen탵a\");\n"
" * nu ave탵i voie s캒 utiliza탵i acest fi탳ier dec칙t 칥n conformitate cu "
"Licen탵a.\n"
" * Pute탵i ob탵ine o copie a Licen탵ei la adresa\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Cu excep탵ia cazului 칥n care legisla탵ia aplicabil캒 o impune sau se convine "
"칥n scris, software-ul\n"
" * distribuit 칥n temeiul licen탵ei este distribuit pe o BAZ캑 \"AS IS\",\n"
" * F캑R캑 GARAN탴II SAU CONDI탴II DE NICI UN FEL, fie ele exprese sau "
"implicite.\n"
" * Consulta탵i Licen탵a pentru limbajul specific care reglementeaz캒 "
"permisiunile 탳i\n"
" * limit캒ri 칥n cadrul Licen탵ei.\n"
" */\n"
"\n"
".set .L_TT_TYPE_BLOCK, 0x1\n"
".set .L_TT_TYPE_PAGE, 0x3\n"
".set .L_TT_TYPE_TABLE, 0x3\n"
"\n"
"/* Indicator de acces. */\n"
".set .L_TT_AF, 0x1 << 10\n"
"/* Nu este global. */\n"
".set .L_TT_NG, 0x1 << 11\n"
".set .L_TT_XN, 0x3 << 53\n"
"\n"
".set .L_TT_MT_DEV, 0x0 << 2 // MAIR #0 (DEV_nGnRE)\n"
".set .L_TT_MT_MEM, (0x1 << 2) | (0x3 << 8) // MAIR #1 (MEM_WBWA), partajabil "
"칥n interior\n"
"\n"
".set .L_BLOCK_DEV, .L_TT_TYPE_BLOCK | .L_TT_MT_DEV | .L_TT_AF | .L_TT_XN\n"
".set .L_BLOCK_MEM, .L_TT_TYPE_BLOCK | .L_TT_MT_MEM | .L_TT_AF | .L_TT_NG\n"
"\n"
".section \".rodata.idmap\", \"a\", %progbits\n"
".global idmap\n"
".align 12\n"
"idmap:\n"
"\t/* nivel 1 */\n"
"\t.quad .L_BLOCK_DEV | 0x0 // 1 GiB de mapare a dispozitivelor\n"
"\t.quad .L_BLOCK_MEM | 0x40000000 // 1 GiB de DRAM\n"
"\t.fill 254, 8, 0x0 // 254 GiB de spa탵iu VA nemarcat\n"
"\t.quad .L_BLOCK_DEV | 0x4000000000 // 1 GiB de mapare a dispozitivelor\n"
"\t.fill 255, 8, 0x0 // 255 GiB de spa탵iu VA r캒mas\n"
"```"

#: src/exercises/bare-metal/rtc.md:829
#, fuzzy
msgid "_image.ld_ (you shouldn't need to change this):"
msgstr "_image.ld_ (nu ar trebui s캒 fie nevoie s캒 modifica탵i acest lucru):"

#: src/exercises/bare-metal/rtc.md:833
#, fuzzy
msgid ""
"```ld\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"/*\n"
" * Code will start running at this symbol which is placed at the start of "
"the\n"
" * image.\n"
" */\n"
"ENTRY(entry)\n"
"\n"
"MEMORY\n"
"{\n"
"\timage : ORIGIN = 0x40080000, LENGTH = 2M\n"
"}\n"
"\n"
"SECTIONS\n"
"{\n"
"\t/*\n"
"\t * Collect together the code.\n"
"\t */\n"
"\t.init : ALIGN(4096) {\n"
"\t\ttext_begin = .;\n"
"\t\t*(.init.entry)\n"
"\t\t*(.init.*)\n"
"\t} >image\n"
"\t.text : {\n"
"\t\t*(.text.*)\n"
"\t} >image\n"
"\ttext_end = .;\n"
"\n"
"\t/*\n"
"\t * Collect together read-only data.\n"
"\t */\n"
"\t.rodata : ALIGN(4096) {\n"
"\t\trodata_begin = .;\n"
"\t\t*(.rodata.*)\n"
"\t} >image\n"
"\t.got : {\n"
"\t\t*(.got)\n"
"\t} >image\n"
"\trodata_end = .;\n"
"\n"
"\t/*\n"
"\t * Collect together the read-write data including .bss at the end which\n"
"\t * will be zero'd by the entry code.\n"
"\t */\n"
"\t.data : ALIGN(4096) {\n"
"\t\tdata_begin = .;\n"
"\t\t*(.data.*)\n"
"\t\t/*\n"
"\t\t * The entry point code assumes that .data is a multiple of 32\n"
"\t\t * bytes long.\n"
"\t\t */\n"
"\t\t. = ALIGN(32);\n"
"\t\tdata_end = .;\n"
"\t} >image\n"
"\n"
"\t/* Everything beyond this point will not be included in the binary. */\n"
"\tbin_end = .;\n"
"\n"
"\t/* The entry point code assumes that .bss is 16-byte aligned. */\n"
"\t.bss : ALIGN(16)  {\n"
"\t\tbss_begin = .;\n"
"\t\t*(.bss.*)\n"
"\t\t*(COMMON)\n"
"\t\t. = ALIGN(16);\n"
"\t\tbss_end = .;\n"
"\t} >image\n"
"\n"
"\t.stack (NOLOAD) : ALIGN(4096) {\n"
"\t\tboot_stack_begin = .;\n"
"\t\t. += 40 * 4096;\n"
"\t\t. = ALIGN(4096);\n"
"\t\tboot_stack_end = .;\n"
"\t} >image\n"
"\n"
"\t. = ALIGN(4K);\n"
"\tPROVIDE(dma_region = .);\n"
"\n"
"\t/*\n"
"\t * Remove unused sections from the image.\n"
"\t */\n"
"\t/DISCARD/ : {\n"
"\t\t/* The image loads itself so doesn't need these sections. */\n"
"\t\t*(.gnu.hash)\n"
"\t\t*(.hash)\n"
"\t\t*(.interp)\n"
"\t\t*(.eh_frame_hdr)\n"
"\t\t*(.eh_frame)\n"
"\t\t*(.note.gnu.build-id)\n"
"\t}\n"
"}\n"
"```"
msgstr ""
"```ld\n"
"/*\n"
" * Drepturi de autor 2023 Google LLC\n"
" *\n"
" * Licen탵iat sub Licen탵a Apache, versiunea 2.0 (denumit캒 칥n continuare "
"\"Licen탵a\");\n"
" * nu ave탵i voie s캒 utiliza탵i acest fi탳ier dec칙t 칥n conformitate cu "
"Licen탵a.\n"
" * Pute탵i ob탵ine o copie a Licen탵ei la adresa\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Cu excep탵ia cazului 칥n care legisla탵ia aplicabil캒 o impune sau se convine "
"칥n scris, software-ul\n"
" * distribuit 칥n temeiul licen탵ei este distribuit pe o BAZ캑 \"AS IS\",\n"
" * F캑R캑 GARAN탴II SAU CONDI탴II DE NICI UN FEL, fie ele exprese sau "
"implicite.\n"
" * Consulta탵i Licen탵a pentru limbajul specific care reglementeaz캒 "
"permisiunile 탳i\n"
" * limit캒ri 칥n cadrul Licen탵ei.\n"
" */\n"
"\n"
"/*\n"
" * Codul va 칥ncepe s캒 ruleze la acest simbol care este plasat la 칥nceputul\n"
" * imagine.\n"
" */\n"
"ENTRY(intrare)\n"
"\n"
"MEMORIE\n"
"{\n"
"\timage : ORIGIN = 0x40080000, LENGTH = 2M\n"
"}\n"
"\n"
"SEC탴IUNI\n"
"{\n"
"\t/*\n"
"\t * Aduna탵i 칥mpreun캒 codul.\n"
"\t */\n"
"\t.init : ALIGN(4096) {\n"
"\t\ttext_begin = ..;\n"
"\t\t*(.init.entry)\n"
"\t\t*(.init.*)\n"
"\t} >imagine\n"
"\t.text : {\n"
"\t\t*(.text.*)\n"
"\t} >imagine\n"
"\ttext_end = ..;\n"
"\n"
"\t/*\n"
"\t * Adun캒 칥mpreun캒 datele numai pentru citire.\n"
"\t */\n"
"\t.rodata : ALIGN(4096) {\n"
"\t\trodata_begin = ..;\n"
"\t\t*(.rodata.*)\n"
"\t} >imagine\n"
"\t.got : {\n"
"\t\t*(.got)\n"
"\t} >imagine\n"
"\trodata_end = .;\n"
"\n"
"\t/*\n"
"\t * Colecteaz캒 칥mpreun캒 datele de citire-scriere, inclusiv .bss de la "
"sf칙r탳it, care\n"
"\t * va fi anulat de codul de intrare.\n"
"\t */\n"
"\t.data : ALIGN(4096) {\n"
"\t\tdata_begin = ..;\n"
"\t\t*(.data.*)\n"
"\t\t/*\n"
"\t\t * Codul punctului de intrare presupune c캒 .data este un multiplu de 32\n"
"\t\t * octe탵i.\n"
"\t\t */\n"
"\t\t. = ALIGN(32);\n"
"\t\tdata_end = .;\n"
"\t} >imagine\n"
"\n"
"\t/* Tot ceea ce dep캒탳e탳te acest punct nu va fi inclus 칥n binar. */\n"
"\tbin_end = ..;\n"
"\n"
"\t/* Codul punctului de intrare presupune c캒 .bss este aliniat pe 16 octe탵i. "
"*/\n"
"\t.bss : ALIGN(16) {\n"
"\t\tbss_begin = ..;\n"
"\t\t*(.bss.*)\n"
"\t\t*(COMUN)\n"
"\t\t. = ALIGN(16);\n"
"\t\tbss_end = .;\n"
"\t} >imagine\n"
"\n"
"\t.stack (NOLOAD) : ALIGN(4096) {\n"
"\t\tboot_stack_begin = ..;\n"
"\t\t. += 40 * 4096;\n"
"\t\t. = ALIGN(4096);\n"
"\t\tboot_stack_end = .;\n"
"\t} >imagine\n"
"\n"
"\t. = ALIGN(4K);\n"
"\tPROVIDE(dma_region = .);\n"
"\n"
"\t/*\n"
"\t * Elimin캒 sec탵iunile neutilizate din imagine.\n"
"\t */\n"
"\t/DISCARD/ : {\n"
"\t\t/* Imaginea se 칥ncarc캒 singur캒, deci nu are nevoie de aceste sec탵iuni. "
"*/\n"
"\t\t*(.gnu.hash)\n"
"\t\t*(.hash)\n"
"\t\t*(.interp)\n"
"\t\t*(.eh_frame_hdr)\n"
"\t\t*(.eh_frame)\n"
"\t\t*(.note.gnu.build-id)\n"
"\t}\n"
"}\n"
"```"

#: src/exercises/bare-metal/rtc.md:940
#, fuzzy
msgid "_Makefile_ (you shouldn't need to change this):"
msgstr "_Makefile_ (nu ar trebui s캒 fie nevoie s캒 modifica탵i acest lucru):"

#: src/exercises/bare-metal/rtc.md:944
#, fuzzy
msgid ""
"```makefile\n"
"# Copyright 2023 Google LLC\n"
"#\n"
"# Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"# you may not use this file except in compliance with the License.\n"
"# You may obtain a copy of the License at\n"
"#\n"
"#      http://www.apache.org/licenses/LICENSE-2.0\n"
"#\n"
"# Unless required by applicable law or agreed to in writing, software\n"
"# distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"# See the License for the specific language governing permissions and\n"
"# limitations under the License.\n"
"\n"
"UNAME := $(shell uname -s)\n"
"ifeq ($(UNAME),Linux)\n"
"\tTARGET = aarch64-linux-gnu\n"
"else\n"
"\tTARGET = aarch64-none-elf\n"
"endif\n"
"OBJCOPY = $(TARGET)-objcopy\n"
"\n"
".PHONY: build qemu_minimal qemu qemu_logger\n"
"\n"
"all: rtc.bin\n"
"\n"
"build:\n"
"\tcargo build\n"
"\n"
"rtc.bin: build\n"
"\t$(OBJCOPY) -O binary target/aarch64-unknown-none/debug/rtc $@\n"
"\n"
"qemu: rtc.bin\n"
"\tqemu-system-aarch64 -machine virt,gic-version=3 -cpu max -serial mon:stdio "
"-display none -kernel $< -s\n"
"\n"
"clean:\n"
"\tcargo clean\n"
"\trm -f *.bin\n"
"```"
msgstr ""
"```makefile\n"
"# Copyright 2023 Google LLC\n"
"#\n"
"# Licen탵iat sub licen탵a Apache License, versiunea 2.0 (\"Licen탵a\");\n"
"# nu ave탵i voie s캒 utiliza탵i acest fi탳ier dec칙t 칥n conformitate cu Licen탵a.\n"
"# Pute탵i ob탵ine o copie a Licen탵ei la adresa\n"
"#\n"
"# http://www.apache.org/licenses/LICENSE-2.0\n"
"#\n"
"# Cu excep탵ia cazului 칥n care legea aplicabil캒 o impune sau se convine 칥n "
"scris, software-ul\n"
"# distribuit 칥n temeiul licen탵ei este distribuit pe o BAZ캑 \"AS IS\",\n"
"# F캑R캑 GARAN탴II SAU CONDI탴II DE NICI UN FEL, fie ele exprese sau implicite.\n"
"# Consulta탵i Licen탵a pentru limbajul specific care reglementeaz캒 "
"permisiunile 탳i\n"
"# limit캒ri 칥n cadrul licen탵ei.\n"
"\n"
"UNAME := $(shell uname -s)\n"
"ifeq ($(UNAME),Linux)\n"
"\tTARGET = aarch64-linux-gnu\n"
"else\n"
"\tTARGET = aarch64-none-elf\n"
"endif\n"
"OBJCOPY = $(TARGET)-objcopy\n"
"\n"
".PHONY: build qemu_minimal qemu qemu_logger\n"
"\n"
"all: rtc.bin\n"
"\n"
"build:\n"
"\tcargo build\n"
"\n"
"rtc.bin: build\n"
"\t$(OBJCOPY) -O binary target/aarch64-unknown-none/debug/rtc $@\n"
"\n"
"qemu: rtc.bin\n"
"\tqemu-system-aarch64 -machine virt,gic-version=3 -cpu max -serial mon:stdio "
"-display none -kernel $< -s -s\n"
"\n"
"clean:\n"
"\tcargo clean\n"
"\trm -f *.bin\n"
"```"

#: src/exercises/bare-metal/rtc.md:995
#, fuzzy
msgid "Run the code in QEMU with `make qemu`."
msgstr "Rula탵i codul 칥n QEMU cu `make qemu`."

#: src/concurrency.md:1
#, fuzzy
msgid "Welcome to Concurrency in Rust"
msgstr "Bine a탵i venit la Concurrency 칥n Rust"

#: src/concurrency.md:3
#, fuzzy
msgid ""
"Rust has full support for concurrency using OS threads with mutexes and "
"channels."
msgstr ""
"Rust are un suport complet pentru concuren탵캒 folosind fire de execu탵ie OS cu "
"mutexuri 탳i canale."

#: src/concurrency.md:6
#, fuzzy
msgid ""
"The Rust type system plays an important role in making many concurrency bugs "
"compile time bugs. This is often referred to as _fearless concurrency_ since "
"you can rely on the compiler to ensure correctness at runtime."
msgstr ""
"Sistemul de tipuri Rust joac캒 un rol important 칥n transformarea multor erori "
"de concuren탵캒 칥n erori de timp de compilare. Acest lucru este deseori "
"denumit _concuren탵캒 f캒r캒 fric캒_, deoarece v캒 pute탵i baza pe compilator "
"pentru a asigura corectitudinea la momentul execu탵iei."

#: src/concurrency/threads.md:3
#, fuzzy
msgid "Rust threads work similarly to threads in other languages:"
msgstr ""
"Firele de execu탵ie din Rust func탵ioneaz캒 칥n mod similar cu cele din alte "
"limbaje:"

#: src/concurrency/threads.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    thread::spawn(|| {\n"
"        for i in 1..10 {\n"
"            println!(\"Count in thread: {i}!\");\n"
"            thread::sleep(Duration::from_millis(5));\n"
"        }\n"
"    });\n"
"\n"
"    for i in 1..5 {\n"
"        println!(\"Main thread: {i}\");\n"
"        thread::sleep(Duration::from_millis(5));\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"folose탳te std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    thread::spawn(|| {|\n"
"        for i in 1..10 {\n"
"            println!(\"Num캒r 칥n fir: {i}!\");\n"
"            thread::sleep(Duration::from_millis(5));\n"
"        }\n"
"    });\n"
"\n"
"    for i in 1..5 {\n"
"        println!(\"Fire principal캒: {i}\");\n"
"        thread::sleep(Duration::from_millis(5));\n"
"    }\n"
"}\n"
"```"

#: src/concurrency/threads.md:24
#, fuzzy
msgid "Threads are all daemon threads, the main thread does not wait for them."
msgstr "Firele sunt toate fire de tip daemon, firul principal nu le a탳teapt캒."

#: src/concurrency/threads.md:25
#, fuzzy
msgid "Thread panics are independent of each other."
msgstr "Panica firelor este independent캒 una de cealalt캒."

#: src/concurrency/threads.md:26
#, fuzzy
msgid "Panics can carry a payload, which can be unpacked with `downcast_ref`."
msgstr ""
"Panicile pot transporta o sarcin캒 util캒, care poate fi despachetat캒 cu "
"`downcast_ref`."

#: src/concurrency/threads.md:32
#, fuzzy
msgid ""
"Notice that the thread is stopped before it reaches 10  the main thread is "
"not waiting."
msgstr ""
"Observa탵i c캒 firul este oprit 칥nainte de a ajunge la 10 - firul principal nu "
"a탳teapt캒."

#: src/concurrency/threads.md:35
#, fuzzy
msgid ""
"Use `let handle = thread::spawn(...)` and later `handle.join()` to wait for "
"the thread to finish."
msgstr ""
"Utiliza탵i `let handle = thread::spawn(...)` 탳i mai t칙rziu `handle.join()` "
"pentru a a탳tepta ca firul s캒 se termine."

#: src/concurrency/threads.md:38
#, fuzzy
msgid "Trigger a panic in the thread, notice how this doesn't affect `main`."
msgstr ""
"Declan탳eaz캒 o panic캒 칥n firul de discu탵ie, observa탵i cum acest lucru nu "
"afecteaz캒 `main`."

#: src/concurrency/threads.md:40
#, fuzzy
msgid ""
"Use the `Result` return value from `handle.join()` to get access to the "
"panic payload. This is a good time to talk about [`Any`](https://doc.rust-"
"lang.org/std/any/index.html)."
msgstr ""
"Utiliza탵i valoarea de returnare `Result` din `handle.join()` pentru a ob탵ine "
"acces la sarcina util캒 de panic캒. Acesta este un moment bun pentru a vorbi "
"despre [`Any`](https://doc.rust-lang.org/std/any/index.html)."

#: src/concurrency/scoped-threads.md:3
#, fuzzy
msgid "Normal threads cannot borrow from their environment:"
msgstr "Firele normale nu pot 칥mprumuta din mediul lor:"

#: src/concurrency/scoped-threads.md:5
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"use std::thread;\n"
"\n"
"fn foo() {\n"
"    let s = String::from(\"Hello\");\n"
"    thread::spawn(|| {\n"
"        println!(\"Length: {}\", s.len());\n"
"    });\n"
"}\n"
"\n"
"fn main() {\n"
"    foo();\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"folose탳te std::thread;\n"
"\n"
"fn foo() {\n"
"    let s = String::from(\"Hello\");\n"
"    thread::spawn(|| {|\n"
"        println!(\"Lungime: {}\", s.len());\n"
"    });\n"
"}\n"
"\n"
"fn main() {\n"
"    foo();\n"
"}\n"
"```"

#: src/concurrency/scoped-threads.md:20
#, fuzzy
msgid ""
"However, you can use a [scoped thread](https://doc.rust-lang.org/std/thread/"
"fn.scope.html) for this:"
msgstr ""
"Cu toate acestea, pute탵i utiliza un [scoped thread](https://doc.rust-lang."
"org/std/thread/fn.scope.html) pentru acest lucru:"

#: src/concurrency/scoped-threads.md:22
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let s = String::from(\"Hello\");\n"
"\n"
"    thread::scope(|scope| {\n"
"        scope.spawn(|| {\n"
"            println!(\"Length: {}\", s.len());\n"
"        });\n"
"    });\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"folose탳te std::thread;\n"
"\n"
"fn main() {\n"
"    let s = String::from(\"Hello\");\n"
"\n"
"    thread::scope(|scope| {\n"
"        scope.spawn(|| {|\n"
"            println!(\"Lungime: {}\", s.len());\n"
"        });\n"
"    });\n"
"}\n"
"```"

#: src/concurrency/scoped-threads.md:40
#, fuzzy
msgid ""
"The reason for that is that when the `thread::scope` function completes, all "
"the threads are guaranteed to be joined, so they can return borrowed data."
msgstr ""
"Motivul este c캒, atunci c칙nd func탵ia `thread::scope` se finalizeaz캒, toate "
"firele sunt garantate a fi unite, astfel 칥nc칙t pot returna date 칥mprumutate."

#: src/concurrency/scoped-threads.md:41
#, fuzzy
msgid ""
"Normal Rust borrowing rules apply: you can either borrow mutably by one "
"thread, or immutably by any number of threads."
msgstr ""
"Se aplic캒 regulile normale de 칥mprumut Rust: pute탵i 칥mprumuta fie 칥n mod "
"mutabil de c캒tre un singur fir, fie 칥n mod imuabil de c캒tre orice num캒r de "
"fire."

#: src/concurrency/channels.md:3
#, fuzzy
msgid ""
"Rust channels have two parts: a `Sender<T>` and a `Receiver<T>`. The two "
"parts are connected via the channel, but you only see the end-points."
msgstr ""
"Canalele Rust au dou캒 p캒r탵i: un `Sender<T>` 탳i un `Receiver<T>`. Cele dou캒 "
"p캒r탵i sunt conectate prin intermediul canalului, dar nu se v캒d dec칙t "
"punctele finale."

#: src/concurrency/channels.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::channel();\n"
"\n"
"    tx.send(10).unwrap();\n"
"    tx.send(20).unwrap();\n"
"\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"\n"
"    let tx2 = tx.clone();\n"
"    tx2.send(30).unwrap();\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"folosi탵i std::sync::mpsc;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::channel();\n"
"\n"
"    tx.send(10).unwrap();\n"
"    tx.send(20).unwrap();\n"
"\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"\n"
"    let tx2 = tx.clone();\n"
"    tx2.send(30).unwrap();\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"}\n"
"```"

#: src/concurrency/channels.md:26
#, fuzzy
msgid ""
"`mpsc` stands for Multi-Producer, Single-Consumer. `Sender` and `SyncSender` "
"implement `Clone` (so you can make multiple producers) but `Receiver` does "
"not."
msgstr ""
"`mpsc` 칥nseamn캒 Multi-Producer, Single-Consumer. `Sender` 탳i `SyncSender` "
"implementeaz캒 `Clone` (astfel 칥nc칙t s캒 pute탵i face mai mul탵i produc캒tori), "
"dar `Receiver` nu o face."

#: src/concurrency/channels.md:28
#, fuzzy
msgid ""
"`send()` and `recv()` return `Result`. If they return `Err`, it means the "
"counterpart `Sender` or `Receiver` is dropped and the channel is closed."
msgstr ""
"`send()` 탳i `recv()` returneaz캒 `Result`. Dac캒 acestea returneaz캒 `Err`, "
"칥nseamn캒 c캒 omologul `Sender` sau `Receiver` este abandonat 탳i canalul este "
"칥nchis."

#: src/concurrency/channels/unbounded.md:3
#, fuzzy
msgid "You get an unbounded and asynchronous channel with `mpsc::channel()`:"
msgstr "Ob탵ine탵i un canal nem캒rginit 탳i asincron cu `mpsc::channel()`:"

#: src/concurrency/channels/unbounded.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::channel();\n"
"\n"
"    thread::spawn(move || {\n"
"        let thread_id = thread::current().id();\n"
"        for i in 1..10 {\n"
"            tx.send(format!(\"Message {i}\")).unwrap();\n"
"            println!(\"{thread_id:?}: sent Message {i}\");\n"
"        }\n"
"        println!(\"{thread_id:?}: done\");\n"
"    });\n"
"    thread::sleep(Duration::from_millis(100));\n"
"\n"
"    for msg in rx.iter() {\n"
"        println!(\"Main: got {msg}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"folosi탵i std::sync::mpsc;\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::channel();\n"
"\n"
"    thread::spawn(move || {| {\n"
"        let thread_id = thread::current().id();\n"
"        for i in 1..10 {\n"
"            tx.send(format!(\"Message {i}\")).unwrap();\n"
"            println!(\"{thread_id:?}: a trimis mesajul {i}\");\n"
"        }\n"
"        println!(\"{thread_id:?}: terminat\");\n"
"    });\n"
"    thread::sleep(Duration::from_millis(100));\n"
"\n"
"    for msg in rx.iter() {\n"
"        println!(\"Main: got {msg}\");\n"
"    }\n"
"}\n"
"```"

#: src/concurrency/channels/bounded.md:3
#, fuzzy
msgid ""
"With bounded (synchronous) channels, `send` can block the current thread:"
msgstr "Cu canale limitate (sincrone), `send` poate bloca firul curent:"

#: src/concurrency/channels/bounded.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::sync_channel(3);\n"
"\n"
"    thread::spawn(move || {\n"
"        let thread_id = thread::current().id();\n"
"        for i in 1..10 {\n"
"            tx.send(format!(\"Message {i}\")).unwrap();\n"
"            println!(\"{thread_id:?}: sent Message {i}\");\n"
"        }\n"
"        println!(\"{thread_id:?}: done\");\n"
"    });\n"
"    thread::sleep(Duration::from_millis(100));\n"
"\n"
"    for msg in rx.iter() {\n"
"        println!(\"Main: got {msg}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"folosi탵i std::sync::mpsc;\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::sync_channel(3);\n"
"\n"
"    thread::spawn(move || {| {\n"
"        let thread_id = thread::current().id();\n"
"        for i in 1..10 {\n"
"            tx.send(format!(\"Message {i}\")).unwrap();\n"
"            println!(\"{thread_id:?}: a trimis mesajul {i}\");\n"
"        }\n"
"        println!(\"{thread_id:?}: terminat\");\n"
"    });\n"
"    thread::sleep(Duration::from_millis(100));\n"
"\n"
"    for msg in rx.iter() {\n"
"        println!(\"Main: got {msg}\");\n"
"    }\n"
"}\n"
"```"

#: src/concurrency/channels/bounded.md:31
#, fuzzy
msgid ""
"Calling `send` will block the current thread until there is space in the "
"channel for the new message. The thread can be blocked indefinitely if there "
"is nobody who reads from the channel."
msgstr ""
"Apelul la `send` va bloca firul curent p칙n캒 c칙nd va exista spa탵iu 칥n canal "
"pentru noul mesaj. Firul poate fi blocat la nesf칙r탳it dac캒 nimeni nu cite탳te "
"de pe canal."

#: src/concurrency/channels/bounded.md:32
#, fuzzy
msgid ""
"A call to `send` will abort with an error (that is why it returns `Result`) "
"if the channel is closed. A channel is closed when the receiver is dropped."
msgstr ""
"Un apel la `send` va e탳ua cu o eroare (de aceea returneaz캒 `Result`) dac캒 "
"canalul este 칥nchis. Un canal este 칥nchis atunci c칙nd receptorul este "
"abandonat."

#: src/concurrency/channels/bounded.md:33
#, fuzzy
msgid ""
"A bounded channel with a size of zero is called a \"rendezvous channel\". "
"Every send will block the current thread until another thread calls `read`."
msgstr ""
"Un canal delimitat cu dimensiunea zero se nume탳te \"canal de 칥nt칙lnire\". "
"Fiecare trimitere va bloca firul curent p칙n캒 c칙nd un alt fir va apela `read`."

#: src/concurrency/send-sync.md:1
#, fuzzy
msgid "`Send` and `Sync`"
msgstr "`Send` 탳i `Sync`"

#: src/concurrency/send-sync.md:3
#, fuzzy
msgid ""
"How does Rust know to forbid shared access across threads? The answer is in "
"two traits:"
msgstr ""
"Cum 탳tie Rust s캒 interzic캒 accesul partajat 칥ntre fire de execu탵ie? "
"R캒spunsul se afl캒 칥n dou캒 tr캒s캒turi:"

#: src/concurrency/send-sync.md:5
#, fuzzy
msgid ""
"[`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html): a type `T` "
"is `Send` if it is safe to move a `T` across a thread boundary."
msgstr ""
"[`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html): un tip `T` "
"este `Send` dac캒 este sigur s캒 mu탵i un `T` peste o limit캒 de fir."

#: src/concurrency/send-sync.md:7
#, fuzzy
msgid ""
"[`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html): a type `T` "
"is `Sync` if it is safe to move a `&T` across a thread boundary."
msgstr ""
"[`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html): un tip `T` "
"este `Sync` dac캒 este sigur s캒 mu탵i un `&T` peste o limit캒 de fir."

#: src/concurrency/send-sync.md:10
#, fuzzy
msgid ""
"`Send` and `Sync` are [unsafe traits](../unsafe/unsafe-traits.md). The "
"compiler will automatically derive them for your types as long as they only "
"contain `Send` and `Sync` types. You can also implement them manually when "
"you know it is valid."
msgstr ""
"`Send` 탳i `Sync` sunt [tr캒s캒turi nesigure](../unsafe/unsafe-traits.md). "
"Compilatorul le va deriva 칥n mod automat pentru tipurile dvs. at칙ta timp c칙t "
"acestea con탵in doar tipurile `Send` 탳i `Sync`. De asemenea, le pute탵i "
"implementa manual atunci c칙nd 탳ti탵i c캒 este valabil."

#: src/concurrency/send-sync.md:20
#, fuzzy
msgid ""
"One can think of these traits as markers that the type has certain thread-"
"safety properties."
msgstr ""
"Aceste tr캒s캒turi pot fi considerate ca fiind indicatoare ale faptului c캒 "
"tipul are anumite propriet캒탵i de siguran탵캒 a firelor."

#: src/concurrency/send-sync.md:21
#, fuzzy
msgid "They can be used in the generic constraints as normal traits."
msgstr ""
"Acestea pot fi utilizate 칥n cadrul constr칙ngerilor generice ca 탳i tr캒s캒turi "
"normale."

#: src/concurrency/send-sync/send.md:1
#, fuzzy
msgid "`Send`"
msgstr "`Send`"

#: src/concurrency/send-sync/send.md:3
#, fuzzy
msgid ""
"A type `T` is [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html) "
"if it is safe to move a `T` value to another thread."
msgstr ""
"Un tip `T` este [`Send`](https://doc.rust-lang.org/std/marker/trait.Send."
"html) dac캒 este sigur s캒 mu탵i o valoare `T` c캒tre un alt fir."

#: src/concurrency/send-sync/send.md:5
#, fuzzy
msgid ""
"The effect of moving ownership to another thread is that _destructors_ will "
"run in that thread. So the question is when you can allocate a value in one "
"thread and deallocate it in another."
msgstr ""
"Efectul mut캒rii propriet캒탵ii c캒tre un alt fir este c캒 _destructori_ vor rula "
"칥n acel fir. A탳adar, 칥ntrebarea este c칙nd pute탵i aloca o valoare 칥ntr-un fir "
"탳i o pute탵i dezaloca 칥n alt fir."

#: src/concurrency/send-sync/send.md:13
#, fuzzy
msgid ""
"As an example, a connection to the SQLite library must only be accessed from "
"a single thread."
msgstr ""
"De exemplu, o conexiune la biblioteca SQLite trebuie s캒 fie accesat캒 numai "
"de pe un singur fir de execu탵ie."

#: src/concurrency/send-sync/sync.md:1
#, fuzzy
msgid "`Sync`"
msgstr "`Sync`"

#: src/concurrency/send-sync/sync.md:3
#, fuzzy
msgid ""
"A type `T` is [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) "
"if it is safe to access a `T` value from multiple threads at the same time."
msgstr ""
"Un tip `T` este [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync."
"html) dac캒 este sigur s캒 accesezi o valoare `T` din mai multe fire de "
"execu탵ie 칥n acela탳i timp."

#: src/concurrency/send-sync/sync.md:6
#, fuzzy
msgid "More precisely, the definition is:"
msgstr "Mai exact, defini탵ia este:"

#: src/concurrency/send-sync/sync.md:8
#, fuzzy
msgid "`T` is `Sync` if and only if `&T` is `Send`"
msgstr "`T` este `Sync` dac캒 탳i numai dac캒 `&T` este `Send`"

#: src/concurrency/send-sync/sync.md:14
#, fuzzy
msgid ""
"This statement is essentially a shorthand way of saying that if a type is "
"thread-safe for shared use, it is also thread-safe to pass references of it "
"across threads."
msgstr ""
"Aceast캒 afirma탵ie este, 칥n esen탵캒, un mod prescurtat de a spune c캒, dac캒 un "
"tip este sigur pentru utilizarea partajat캒, este, de asemenea, sigur pentru "
"a trece referin탵e ale acestuia 칥ntre fire."

#: src/concurrency/send-sync/sync.md:16
#, fuzzy
msgid ""
"This is because if a type is Sync it means that it can be shared across "
"multiple threads without the risk of data races or other synchronization "
"issues, so it is safe to move it to another thread. A reference to the type "
"is also safe to move to another thread, because the data it references can "
"be accessed from any thread safely."
msgstr ""
"Acest lucru se datoreaz캒 faptului c캒, dac캒 un tip este Sync, 칥nseamn캒 c캒 "
"poate fi partajat 칥ntre mai multe fire de execu탵ie f캒r캒 riscul de curse de "
"date sau alte probleme de sincronizare, astfel 칥nc칙t este sigur s캒 칥l muta탵i "
"pe un alt fir de execu탵ie. O referin탵캒 la tip este, de asemenea, sigur캒 "
"pentru a fi mutat캒 칥n alt fir, deoarece datele la care face referire pot fi "
"accesate 칥n siguran탵캒 din orice fir."

#: src/concurrency/send-sync/examples.md:3
#, fuzzy
msgid "`Send + Sync`"
msgstr "`Send + Sync`"

#: src/concurrency/send-sync/examples.md:5
#, fuzzy
msgid "Most types you come across are `Send + Sync`:"
msgstr "Majoritatea tipurilor pe care le 칥nt칙lni탵i sunt de tip `Send + Sync`:"

#: src/concurrency/send-sync/examples.md:7
#, fuzzy
msgid "`i8`, `f32`, `bool`, `char`, `&str`, ..."
msgstr "`i8`, `f32`, `bool`, `char`, `&str`, ..."

#: src/concurrency/send-sync/examples.md:8
#, fuzzy
msgid "`(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ..."
msgstr "`(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ..."

#: src/concurrency/send-sync/examples.md:9
#, fuzzy
msgid "`String`, `Option<T>`, `Vec<T>`, `Box<T>`, ..."
msgstr "`String`, `Option<T>`, `Vec<T>`, `Box<T>`, ..."

#: src/concurrency/send-sync/examples.md:10
#, fuzzy
msgid "`Arc<T>`: Explicitly thread-safe via atomic reference count."
msgstr ""
"`Arc<T>`: 칉n mod explicit, thread-safe prin num캒rul de referin탵e atomice."

#: src/concurrency/send-sync/examples.md:11
#, fuzzy
msgid "`Mutex<T>`: Explicitly thread-safe via internal locking."
msgstr "`Mutex<T>`: 칉n mod explicit, thread-safe prin blocare intern캒."

#: src/concurrency/send-sync/examples.md:12
#, fuzzy
msgid "`AtomicBool`, `AtomicU8`, ...: Uses special atomic instructions."
msgstr ""
"`AtomicBool`, `AtomicU8`, ....: Utilizeaz캒 instruc탵iuni atomice speciale."

#: src/concurrency/send-sync/examples.md:14
#, fuzzy
msgid ""
"The generic types are typically `Send + Sync` when the type parameters are "
"`Send + Sync`."
msgstr ""
"Tipurile generice sunt de obicei `Send + Sync` atunci c칙nd parametrii de tip "
"sunt `Send + Sync`."

#: src/concurrency/send-sync/examples.md:17
#, fuzzy
msgid "`Send + !Sync`"
msgstr "`Send + !Sync`"

#: src/concurrency/send-sync/examples.md:19
#, fuzzy
msgid ""
"These types can be moved to other threads, but they're not thread-safe. "
"Typically because of interior mutability:"
msgstr ""
"Aceste tipuri pot fi mutate 칥n alte fire de execu탵ie, dar nu sunt sigure "
"pentru fire de execu탵ie. De obicei, din cauza mutabilit캒탵ii interioare:"

#: src/concurrency/send-sync/examples.md:22
#, fuzzy
msgid "`mpsc::Sender<T>`"
msgstr "`mpsc::Sender<T>`"

#: src/concurrency/send-sync/examples.md:23
#, fuzzy
msgid "`mpsc::Receiver<T>`"
msgstr "`mpsc::Receiver<T>`"

#: src/concurrency/send-sync/examples.md:24
#, fuzzy
msgid "`Cell<T>`"
msgstr "`Celula<T>`"

#: src/concurrency/send-sync/examples.md:25
#, fuzzy
msgid "`RefCell<T>`"
msgstr "`RefCell<T>`"

#: src/concurrency/send-sync/examples.md:27
#, fuzzy
msgid "`!Send + Sync`"
msgstr "`!Send + Sync`"

#: src/concurrency/send-sync/examples.md:29
#, fuzzy
msgid ""
"These types are thread-safe, but they cannot be moved to another thread:"
msgstr ""
"Aceste tipuri sunt sigure pentru firul de execu탵ie, dar nu pot fi mutate 칥n "
"alt fir de execu탵ie:"

#: src/concurrency/send-sync/examples.md:31
#, fuzzy
msgid ""
"`MutexGuard<T: Sync>`: Uses OS level primitives which must be deallocated on "
"the thread which created them."
msgstr ""
"`MutexGuard<T: Sync>`: Utilizeaz캒 primitive la nivelul sistemului de operare "
"care trebuie s캒 fie dezalocate pe firul care le-a creat."

#: src/concurrency/send-sync/examples.md:34
#, fuzzy
msgid "`!Send + !Sync`"
msgstr "`!Send +Sync`"

#: src/concurrency/send-sync/examples.md:36
#, fuzzy
msgid "These types are not thread-safe and cannot be moved to other threads:"
msgstr ""
"Aceste tipuri nu sunt sigure pentru fire de execu탵ie 탳i nu pot fi mutate 칥n "
"alte fire de execu탵ie:"

#: src/concurrency/send-sync/examples.md:38
#, fuzzy
msgid ""
"`Rc<T>`: each `Rc<T>` has a reference to an `RcBox<T>`, which contains a non-"
"atomic reference count."
msgstr ""
"`Rc<T>`: fiecare `Rc<T>` are o referin탵캒 la un `RcBox<T>`, care con탵ine un "
"num캒r de referin탵e neatomice."

#: src/concurrency/send-sync/examples.md:40
#, fuzzy
msgid ""
"`*const T`, `*mut T`: Rust assumes raw pointers may have special concurrency "
"considerations."
msgstr ""
"`*const T`, `*mut T`: Rust presupune c캒 indicatoarele brute pot avea "
"considera탵ii speciale privind concuren탵a."

#: src/concurrency/shared_state.md:3
#, fuzzy
msgid ""
"Rust uses the type system to enforce synchronization of shared data. This is "
"primarily done via two types:"
msgstr ""
"Rust utilizeaz캒 sistemul de tipuri pentru a impune sincronizarea datelor "
"partajate. Acest lucru se face 칥n principal prin intermediul a dou캒 tipuri:"

#: src/concurrency/shared_state.md:6
#, fuzzy
msgid ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html), atomic "
"reference counted `T`: handles sharing between threads and takes care to "
"deallocate `T` when the last reference is dropped,"
msgstr ""
"[`Arc<T>`]](https://doc.rust-lang.org/std/sync/struct.Arc.html), referin탵캒 "
"atomic캒 num캒rat캒 `T`: se ocup캒 de partajarea 칥ntre fire 탳i are grij캒 s캒 "
"dezalocalizeze `T` atunci c칙nd se renun탵캒 la ultima referin탵캒,"

#: src/concurrency/shared_state.md:8
#, fuzzy
msgid ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html): ensures "
"mutually exclusive access to the `T` value."
msgstr ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html): asigur캒 "
"accesul reciproc exclusiv la valoarea `T`."

#: src/concurrency/shared_state/arc.md:1
#, fuzzy
msgid "`Arc`"
msgstr "`Arc`"

#: src/concurrency/shared_state/arc.md:3
#, fuzzy
msgid ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html) allows shared "
"read-only access via `Arc::clone`:"
msgstr ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html) permite "
"accesul partajat numai pentru citire prin intermediul `Arc::clone`:"

#: src/concurrency/shared_state/arc.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"use std::sync::Arc;\n"
"\n"
"fn main() {\n"
"    let v = Arc::new(vec![10, 20, 30]);\n"
"    let mut handles = Vec::new();\n"
"    for _ in 1..5 {\n"
"        let v = Arc::clone(&v);\n"
"        handles.push(thread::spawn(move || {\n"
"            let thread_id = thread::current().id();\n"
"            println!(\"{thread_id:?}: {v:?}\");\n"
"        }));\n"
"    }\n"
"\n"
"    handles.into_iter().for_each(|h| h.join().unwrap());\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"folose탳te std::thread;\n"
"use std::sync::Arc;\n"
"\n"
"fn main() {\n"
"    let v = Arc::new(vec![10, 20, 30]);\n"
"    let mut handles = Vec::new();\n"
"    for _ in 1..5 {\n"
"        let v = Arc::clone(&v);\n"
"        handles.push(thread::spawn(move || {| {\n"
"            let thread_id = thread::current().id();\n"
"            println!(\"{thread_id:?}: {v:?}\");\n"
"        }));\n"
"    }\n"
"\n"
"    handles.into_iter().for_each(|h| h.join().unwrap()));\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"

#: src/concurrency/shared_state/arc.md:29
#, fuzzy
msgid ""
"`Arc` stands for \"Atomic Reference Counted\", a thread safe version of `Rc` "
"that uses atomic operations."
msgstr ""
"`Arc` este acronimul de la \"Atomic Reference Counted\", o versiune thread "
"safe a `Rc` care utilizeaz캒 opera탵ii atomice."

#: src/concurrency/shared_state/arc.md:31
#, fuzzy
msgid ""
"`Arc<T>` implements `Clone` whether or not `T` does. It implements `Send` "
"and `Sync` if and only if `T` implements them both."
msgstr ""
"`Arc<T>` implementeaz캒 `Clone` indiferent dac캒 `T` o face sau nu. "
"Implementeaz캒 `Send` 탳i `Sync` dac캒 탳i numai dac캒 `T` le implementeaz캒 pe "
"am칙ndou캒."

#: src/concurrency/shared_state/arc.md:33
#, fuzzy
msgid ""
"`Arc::clone()` has the cost of atomic operations that get executed, but "
"after that the use of the `T` is free."
msgstr ""
"`Arc::clone()` are costul opera탵iunilor atomice care se execut캒, dar dup캒 "
"aceea utilizarea lui `T` este gratuit캒."

#: src/concurrency/shared_state/arc.md:35
#, fuzzy
msgid ""
"Beware of reference cycles, `Arc` does not use a garbage collector to detect "
"them."
msgstr ""
"Aten탵ie la ciclurile de referin탵캒, `Arc` nu folose탳te un garbage collector "
"pentru a le detecta."

#: src/concurrency/shared_state/arc.md:36
#, fuzzy
msgid "`std::sync::Weak` can help."
msgstr "`std::sync::Weak` poate fi de ajutor."

#: src/concurrency/shared_state/mutex.md:1
#, fuzzy
msgid "`Mutex`"
msgstr "`Mutex`"

#: src/concurrency/shared_state/mutex.md:3
#, fuzzy
msgid ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html) ensures "
"mutual exclusion _and_ allows mutable access to `T` behind a read-only "
"interface:"
msgstr ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html) asigur캒 "
"excluderea reciproc캒 _탳i_ permite accesul mutabil la `T` 칥n spatele unei "
"interfe탵e de numai citire:"

#: src/concurrency/shared_state/mutex.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::sync::Mutex;\n"
"\n"
"fn main() {\n"
"    let v = Mutex::new(vec![10, 20, 30]);\n"
"    println!(\"v: {:?}\", v.lock().unwrap());\n"
"\n"
"    {\n"
"        let mut guard = v.lock().unwrap();\n"
"        guard.push(40);\n"
"    }\n"
"\n"
"    println!(\"v: {:?}\", v.lock().unwrap());\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"folosi탵i std::sync::Mutex;\n"
"\n"
"fn main() {\n"
"    let v = Mutex::new(vec![10, 20, 30]);\n"
"    println!(\"v: {:?}\", v.lock().unwrap());\n"
"\n"
"    {\n"
"        let mut guard = v.lock().unwrap();\n"
"        guard.push(40);\n"
"    }\n"
"\n"
"    println!(\"v: {:?}\", v.lock().unwrap());\n"
"}\n"
"```"

#: src/concurrency/shared_state/mutex.md:22
#, fuzzy
msgid ""
"Notice how we have a [`impl<T: Send> Sync for Mutex<T>`](https://doc.rust-"
"lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E) blanket "
"implementation."
msgstr ""
"Observa탵i cum avem o implementare de p캒tur캒 [`impl<T: Send> Sync for "
"Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-Sync-"
"for-Mutex%3CT%3E)."

#: src/concurrency/shared_state/mutex.md:31
#, fuzzy
msgid ""
"`Mutex` in Rust looks like a collection with just one element - the "
"protected data."
msgstr ""
"`Mutex` 칥n Rust arat캒 ca o colec탵ie cu un singur element - datele protejate."

#: src/concurrency/shared_state/mutex.md:32
#, fuzzy
msgid ""
"It is not possible to forget to acquire the mutex before accessing the "
"protected data."
msgstr ""
"Nu este posibil s캒 se uite s캒 se achizi탵ioneze mutexul 칥nainte de a accesa "
"datele protejate."

#: src/concurrency/shared_state/mutex.md:33
#, fuzzy
msgid ""
"You can get an `&mut T` from an `&Mutex<T>` by taking the lock. The "
"`MutexGuard` ensures that the `&mut T` doesn't outlive the lock being held."
msgstr ""
"Pute탵i ob탵ine un `&amp;mut T` dintr-un `&amp;Mutex<T>` prin luarea unui "
"blocaj. `MutexGuard` se asigur캒 c캒 `&amp;mut T` nu supravie탵uie탳te mai mult "
"dec칙t blocajul de탵inut."

#: src/concurrency/shared_state/mutex.md:35
#, fuzzy
msgid ""
"`Mutex<T>` implements both `Send` and `Sync` iff (if and only if) `T` "
"implements `Send`."
msgstr ""
"`Mutex<T>` implementeaz캒 at칙t `Send` c칙t 탳i `Sync` dac캒 (dac캒 탳i numai dac캒) "
"`T` implementeaz캒 `Send`."

#: src/concurrency/shared_state/mutex.md:36
#, fuzzy
msgid "A read-write lock counterpart - `RwLock`."
msgstr "O contraparte de blocare la citire-scriere - `RwLock`."

#: src/concurrency/shared_state/mutex.md:37
#, fuzzy
msgid "Why does `lock()` return a `Result`? "
msgstr "De ce `lock()` returneaz캒 un `Result`?"

#: src/concurrency/shared_state/mutex.md:38
#, fuzzy
msgid ""
"If the thread that held the `Mutex` panicked, the `Mutex` becomes "
"\"poisoned\" to signal that the data it protected might be in an "
"inconsistent state. Calling `lock()` on a poisoned mutex fails with a "
"[`PoisonError`](https://doc.rust-lang.org/std/sync/struct.PoisonError.html). "
"You can call `into_inner()` on the error to recover the data regardless."
msgstr ""
"칉n cazul 칥n care firul care de탵inea `Mutex` intr캒 칥n panic캒, `Mutex` devine "
"\"otr캒vit\" pentru a semnala c캒 datele pe care le protejeaz캒 ar putea fi "
"칥ntr-o stare inconsistent캒. Apelul la `lock()` pe un mutex otr캒vit e탳ueaz캒 "
"cu un [`PoisonError`](https://doc.rust-lang.org/std/sync/struct.PoisonError."
"html). Pute탵i apela `into_inner()` la eroare pentru a recupera datele "
"indiferent de situa탵ie."

#: src/concurrency/shared_state/example.md:3
#, fuzzy
msgid "Let us see `Arc` and `Mutex` in action:"
msgstr "S캒 vedem `Arc` 탳i `Mutex` 칥n ac탵iune:"

#: src/concurrency/shared_state/example.md:5
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"use std::thread;\n"
"// use std::sync::{Arc, Mutex};\n"
"\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let handle = thread::spawn(|| {\n"
"        v.push(10);\n"
"    });\n"
"    v.push(1000);\n"
"\n"
"    handle.join().unwrap();\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"folose탳te std::thread;\n"
"// use std::sync::{Arc, Mutex};\n"
"\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let handle = thread::spawn(|| {| {\n"
"        v.push(10);\n"
"    });\n"
"    v.push(1000);\n"
"\n"
"    handle.join().unwrap();\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"

#: src/concurrency/shared_state/example.md:23
#, fuzzy
msgid "Possible solution:"
msgstr "O posibil캒 solu탵ie:"

#: src/concurrency/shared_state/example.md:25
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let v = Arc::new(Mutex::new(vec![10, 20, 30]));\n"
"\n"
"    let v2 = Arc::clone(&v);\n"
"    let handle = thread::spawn(move || {\n"
"        let mut v2 = v2.lock().unwrap();\n"
"        v2.push(10);\n"
"    });\n"
"\n"
"    {\n"
"        let mut v = v.lock().unwrap();\n"
"        v.push(1000);\n"
"    }\n"
"\n"
"    handle.join().unwrap();\n"
"\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editabil\n"
"folose탳te std::sync::{Arc, Mutex};\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let v = Arc::new(Mutex::new(vec![10, 20, 30]));\n"
"\n"
"    let v2 = Arc::clone(&v);\n"
"    let handle = thread::spawn(move || {| {\n"
"        let mut v2 = v2.lock().unwrap();\n"
"        v2.push(10);\n"
"    });\n"
"\n"
"    {\n"
"        let mut v = v.lock().unwrap();\n"
"        v.push(1000);\n"
"    }\n"
"\n"
"    handle.join().unwrap();\n"
"\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"

#: src/concurrency/shared_state/example.md:49
#, fuzzy
msgid "Notable parts:"
msgstr "P캒r탵i notabile:"

#: src/concurrency/shared_state/example.md:51
#, fuzzy
msgid ""
"`v` is wrapped in both `Arc` and `Mutex`, because their concerns are "
"orthogonal."
msgstr ""
"`v` este 칥nf캒탳urat at칙t 칥n `Arc` c칙t 탳i 칥n `Mutex`, deoarece preocup캒rile "
"lor sunt ortogonale."

#: src/concurrency/shared_state/example.md:52
#, fuzzy
msgid ""
"Wrapping a `Mutex` in an `Arc` is a common pattern to share mutable state "
"between threads."
msgstr ""
"칉nf캒탳urarea unui `Mutex` 칥ntr-un `Arc` este un model comun de partajare a "
"st캒rii mutabile 칥ntre fire."

#: src/concurrency/shared_state/example.md:53
#, fuzzy
msgid ""
"`v: Arc<_>` needs to be cloned as `v2` before it can be moved into another "
"thread. Note `move` was added to the lambda signature."
msgstr ""
"`v: Arc<_>` trebuie s캒 fie clonat ca `v2` 칥nainte de a putea fi mutat 칥ntr-"
"un alt fir de execu탵ie. Re탵ine탵i c캒 `move` a fost ad캒ugat la semn캒tura "
"lambda."

#: src/concurrency/shared_state/example.md:54
#, fuzzy
msgid ""
"Blocks are introduced to narrow the scope of the `LockGuard` as much as "
"possible."
msgstr ""
"Blocurile sunt introduse pentru a restr칙nge c칙t mai mult posibil domeniul de "
"aplicare al `LockGuard`."

#: src/exercises/concurrency/morning.md:3
#, fuzzy
msgid "Let us practice our new concurrency skills with"
msgstr "S캒 ne exers캒m noile noastre abilit캒탵i de concuren탵캒 cu"

#: src/exercises/concurrency/morning.md:5
#, fuzzy
msgid "Dining philosophers: a classic problem in concurrency."
msgstr "Filozofii care m캒n칙nc캒: o problem캒 clasic캒 칥n concuren탵캒."

#: src/exercises/concurrency/morning.md:7
#, fuzzy
msgid ""
"Multi-threaded link checker: a larger project where you'll use Cargo to "
"download dependencies and then check links in parallel."
msgstr ""
"Verificator de leg캒turi cu mai multe fire: un proiect mai mare 칥n care ve탵i "
"folosi Cargo pentru a desc캒rca dependen탵ele 탳i apoi pentru a verifica "
"leg캒turile 칥n paralel."

#: src/exercises/concurrency/dining-philosophers.md:3
#, fuzzy
msgid "The dining philosophers problem is a classic problem in concurrency:"
msgstr ""
"Problema filozofilor care servesc masa este o problem캒 clasic캒 칥n domeniul "
"concuren탵ei:"

#: src/exercises/concurrency/dining-philosophers.md:5
#, fuzzy
msgid ""
"Five philosophers dine together at the same table. Each philosopher has "
"their own place at the table. There is a fork between each plate. The dish "
"served is a kind of spaghetti which has to be eaten with two forks. Each "
"philosopher can only alternately think and eat. Moreover, a philosopher can "
"only eat their spaghetti when they have both a left and right fork. Thus two "
"forks will only be available when their two nearest neighbors are thinking, "
"not eating. After an individual philosopher finishes eating, they will put "
"down both forks."
msgstr ""
"Cinci filozofi iau masa 칥mpreun캒 la aceea탳i mas캒. Fiecare filozof are "
"propriul loc la mas캒. 칉ntre fiecare farfurie se afl캒 c칙te o furculi탵캒. Felul "
"de m칙ncare servit este un fel de spaghete care trebuie m칙ncate cu dou캒 "
"furculi탵e. Fiecare filozof nu poate dec칙t s캒 g칙ndeasc캒 탳i s캒 m캒n칙nce "
"alternativ. 칉n plus, un filozof poate m칙nca spaghetele doar dac캒 are at칙t "
"furculi탵a din st칙nga, c칙t 탳i cea din dreapta. Astfel, cele dou캒 furculi탵e "
"vor fi disponibile doar atunci c칙nd cei doi vecini cei mai apropia탵i "
"g칙ndesc, nu m캒n칙nc캒. Dup캒 ce un filozof individual termin캒 de m칙ncat, el va "
"pune jos ambele furculi탵e."

#: src/exercises/concurrency/dining-philosophers.md:13
#, fuzzy
msgid ""
"You will need a local [Cargo installation](../../cargo/running-locally.md) "
"for this exercise. Copy the code below to a file called `src/main.rs`, fill "
"out the blanks, and test that `cargo run` does not deadlock:"
msgstr ""
"Ve탵i avea nevoie de o [instalare Cargo] local캒 (../../cargo/running-locally."
"md) pentru acest exerci탵iu. Copia탵i codul de mai jos 칥ntr-un fi탳ier numit "
"`src/main.rs`, completa탵i spa탵iile goale 탳i testa탵i dac캒 `cargo run` nu se "
"blocheaz캒:"

#: src/exercises/concurrency/dining-philosophers.md:19
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"use std::sync::{mpsc, Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    // left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
"}\n"
"\n"
"impl Philosopher {\n"
"    fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))\n"
"            .unwrap();\n"
"    }\n"
"\n"
"    fn eat(&self) {\n"
"        // Pick up forks...\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Hypatia\", \"Plato\", \"Aristotle\", \"Pythagoras\"];\n"
"\n"
"fn main() {\n"
"    // Create forks\n"
"\n"
"    // Create philosophers\n"
"\n"
"    // Make each of them think and eat 100 times\n"
"\n"
"    // Output their thoughts\n"
"}\n"
"```"
msgstr ""
"```rust,compile_fail\n"
"use std::sync::{mpsc, Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    // left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
"}\n"
"\n"
"impl Philosopher {\n"
"    fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} are o idee nou캒!\", &self.name))\n"
"            .unwrap();\n"
"    }\n"
"\n"
"    fn eat(&self) {\n"
"        // Ridic캒 furculi탵ele...\n"
"        println!(\"{} m캒n칙nc캒...\", &self.name);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrate\", \"Hypatia\", \"Platon\", \"Aristotel\", \"Pitagora\"];\n"
"\n"
"fn main() {\n"
"    // Crea탵i furci\n"
"\n"
"    // Creeaz캒 filosofi\n"
"\n"
"    // F캒-i pe fiecare dintre ei s캒 g칙ndeasc캒 탳i s캒 m캒n칙nce de 100 de ori\n"
"\n"
"    // Scoate탵i g칙ndurile lor\n"
"}\n"
"```"

#: src/exercises/concurrency/dining-philosophers.md:61
#, fuzzy
msgid "You can use the following `Cargo.toml`:"
msgstr "Pute탵i utiliza urm캒torul `Cargo.toml`:"

#: src/exercises/concurrency/dining-philosophers.md:65
#, fuzzy
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"```"
msgstr ""
"```toml\n"
"[pachet]\n"
"name = \"dining-philosophers\"\n"
"versiune = \"0.1.0\"\n"
"edition = \"2021\"\n"
"```"

#: src/exercises/concurrency/link-checker.md:3
#, fuzzy
msgid ""
"Let us use our new knowledge to create a multi-threaded link checker. It "
"should start at a webpage and check that links on the page are valid. It "
"should recursively check other pages on the same domain and keep doing this "
"until all pages have been validated."
msgstr ""
"S캒 folosim noile noastre cuno탳tin탵e pentru a crea un verificator de leg캒turi "
"cu mai multe fire. Acesta ar trebui s캒 porneasc캒 de la o pagin캒 web 탳i s캒 "
"verifice dac캒 leg캒turile de pe pagin캒 sunt valide. Ar trebui s캒 verifice 칥n "
"mod recursiv alte pagini din acela탳i domeniu 탳i s캒 continue s캒 fac캒 acest "
"lucru p칙n캒 c칙nd toate paginile sunt validate."

#: src/exercises/concurrency/link-checker.md:8
#, fuzzy
msgid ""
"For this, you will need an HTTP client such as [`reqwest`](https://docs.rs/"
"reqwest/). Create a new Cargo project and `reqwest` it as a dependency with:"
msgstr ""
"Pentru aceasta, ve탵i avea nevoie de un client HTTP, cum ar fi [`reqwest`]"
"(https://docs.rs/reqwest/). Crea탵i un nou proiect Cargo 탳i `reqwest` ca "
"dependen탵캒 cu:"

#: src/exercises/concurrency/link-checker.md:17
#, fuzzy
msgid ""
"If `cargo add` fails with `error: no such subcommand`, then please edit the "
"`Cargo.toml` file by hand. Add the dependencies listed below."
msgstr ""
"Dac캒 `cargo add` e탳ueaz캒 cu `error: no such subcommand`, atunci v캒 rug캒m s캒 "
"edita탵i manual fi탳ierul `Cargo.toml`. Ad캒uga탵i dependen탵ele enumerate mai "
"jos."

#: src/exercises/concurrency/link-checker.md:20
#, fuzzy
msgid ""
"You will also need a way to find links. We can use [`scraper`](https://docs."
"rs/scraper/) for that:"
msgstr ""
"Ve탵i avea nevoie, de asemenea, de o modalitate de a g캒si leg캒turi. Putem "
"folosi [`scraper`](https://docs.rs/scraper/) pentru asta:"

#: src/exercises/concurrency/link-checker.md:26
#, fuzzy
msgid ""
"Finally, we'll need some way of handling errors. We use [`thiserror`]"
"(https://docs.rs/thiserror/) for that:"
msgstr ""
"칉n cele din urm캒, vom avea nevoie de o modalitate de gestionare a erorilor. "
"Pentru aceasta, vom folosi [`thiserror`](https://docs.rs/thiserror/):"

#: src/exercises/concurrency/link-checker.md:33
#, fuzzy
msgid ""
"The `cargo add` calls will update the `Cargo.toml` file to look like this:"
msgstr ""
"Apelurile `cargo add` vor actualiza fi탳ierul `Cargo.toml` astfel 칥nc칙t s캒 "
"arate astfel:"

#: src/exercises/concurrency/link-checker.md:37
#, fuzzy
msgid ""
"```toml\n"
"[package]\n"
"name = \"link-checker\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-"
"tls\"] }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"
msgstr ""
"```toml\n"
"[pachet]\n"
"name = \"link-checker\"\n"
"versiune = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependen탵e]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-"
"tls\"]] } }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"

#: src/exercises/concurrency/link-checker.md:50
#, fuzzy
msgid ""
"You can now download the start page. Try with a small site such as `https://"
"www.google.org/`."
msgstr ""
"Acum pute탵i desc캒rca pagina de start. 칉ncerca탵i cu un site mic, cum ar fi "
"`https://www.google.org/`."

#: src/exercises/concurrency/link-checker.md:53
#, fuzzy
msgid "Your `src/main.rs` file should look something like this:"
msgstr "Fi탳ierul dvs. `src/main.rs` ar trebui s캒 arate cam a탳a:"

#: src/exercises/concurrency/link-checker.md:57
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"use reqwest::{blocking::Client, Url};\n"
"use scraper::{Html, Selector};\n"
"use thiserror::Error;\n"
"\n"
"#[derive(Error, Debug)]\n"
"enum Error {\n"
"    #[error(\"request error: {0}\")]\n"
"    ReqwestError(#[from] reqwest::Error),\n"
"    #[error(\"bad http response: {0}\")]\n"
"    BadResponse(String),\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"struct CrawlCommand {\n"
"    url: Url,\n"
"    extract_links: bool,\n"
"}\n"
"\n"
"fn visit_page(client: &Client, command: &CrawlCommand) -> Result<Vec<Url>, "
"Error> {\n"
"    println!(\"Checking {:#}\", command.url);\n"
"    let response = client.get(command.url.clone()).send()?;\n"
"    if !response.status().is_success() {\n"
"        return Err(Error::BadResponse(response.status().to_string()));\n"
"    }\n"
"\n"
"    let mut link_urls = Vec::new();\n"
"    if !command.extract_links {\n"
"        return Ok(link_urls);\n"
"    }\n"
"\n"
"    let base_url = response.url().to_owned();\n"
"    let body_text = response.text()?;\n"
"    let document = Html::parse_document(&body_text);\n"
"\n"
"    let selector = Selector::parse(\"a\").unwrap();\n"
"    let href_values = document\n"
"        .select(&selector)\n"
"        .filter_map(|element| element.value().attr(\"href\"));\n"
"    for href in href_values {\n"
"        match base_url.join(href) {\n"
"            Ok(link_url) => {\n"
"                link_urls.push(link_url);\n"
"            }\n"
"            Err(err) => {\n"
"                println!(\"On {base_url:#}: ignored unparsable {href:?}: "
"{err}\");\n"
"            }\n"
"        }\n"
"    }\n"
"    Ok(link_urls)\n"
"}\n"
"\n"
"fn main() {\n"
"    let client = Client::new();\n"
"    let start_url = Url::parse(\"https://www.google.org\").unwrap();\n"
"    let crawl_command = CrawlCommand{ url: start_url, extract_links: "
"true };\n"
"    match visit_page(&client, &crawl_command) {\n"
"        Ok(links) => println!(\"Links: {links:#?}\"),\n"
"        Err(err) => println!(\"Could not extract links: {err:#}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,compile_fail\n"
"use reqwest::{blocking::Client, Url};\n"
"use scraper::{Html, Selector};\n"
"use thiserror::Error;\n"
"\n"
"#[derive(Error, Debug)]\n"
"enum Error {\n"
"    #[error(\"request error: {0}\")]\n"
"    ReqwestError(#[din] reqwest::Error),\n"
"    #[error(\"bad http response: {0}\")]]\n"
"    BadResponse(String),\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"struct CrawlCommand {\n"
"    url: Url,\n"
"    extract_links: bool,\n"
"}\n"
"\n"
"fn visit_page(client: &amp;Client, command: &amp;CrawlCommand) -&gt; "
"Result&lt;Vec<Url>, Error&gt; {\n"
"    println!(\"Checking {:#}\", command.url);\n"
"    let response = client.get(command.url.clone()).send()?;\n"
"    if !response.status().is_succes() {\n"
"        return Err(Error::BadResponse(response.status().to_string())));\n"
"    }\n"
"\n"
"    let mut link_urls = Vec::new();\n"
"    if !command.extract_links {\n"
"        return Ok(link_urls);\n"
"    }\n"
"\n"
"    let base_url = response.url().to_owned();\n"
"    let body_text = response.text()?;\n"
"    let document = Html::parse_document(&amp;body_text);\n"
"\n"
"    let selector = Selector::parse(\"a\").unwrap();\n"
"    let href_values = document\n"
"        .select(&amp;selector)\n"
"        .filter_map(|element| element.value().attr(\"href\")));\n"
"    for href in href_values {\n"
"        match base_url.join(href) {\n"
"            Ok(link_url) =&gt; {\n"
"                link_urls.push(link_url);\n"
"            }\n"
"            Err(err) =&gt; {\n"
"                println!(\"Pe {base_url:#}: ignorat unparsable {href:?}: "
"{err}\");\n"
"            }\n"
"        }\n"
"    }\n"
"    Ok(link_urls)\n"
"}\n"
"\n"
"fn main() {\n"
"    let client = Client::new();\n"
"    let start_url = Url::parse(\"https://www.google.org\").unwrap();\n"
"    let crawl_command = CrawlCommand{ url: start_url, extract_links: "
"true };\n"
"    match visit_page(&amp;client, &amp;crawl_command) {\n"
"        Ok(links) =&gt; println!(\"Links: {links:#?}\"),\n"
"        Err(err) =&gt; println!(\"Could not extract links: {err:#}\"),\n"
"    }\n"
"}\n"
"```"

#: src/exercises/concurrency/link-checker.md:120
#, fuzzy
msgid "Run the code in `src/main.rs` with"
msgstr "Rula탵i codul din `src/main.rs` cu"

#: src/exercises/concurrency/link-checker.md:128
#, fuzzy
msgid ""
"Use threads to check the links in parallel: send the URLs to be checked to a "
"channel and let a few threads check the URLs in parallel."
msgstr ""
"Folosi탵i fire de execu탵ie pentru a verifica leg캒turile 칥n paralel: trimite탵i "
"URL-urile care trebuie verificate pe un canal 탳i l캒sa탵i c칙teva fire de "
"execu탵ie s캒 verifice URL-urile 칥n paralel."

#: src/exercises/concurrency/link-checker.md:130
#, fuzzy
msgid ""
"Extend this to recursively extract links from all pages on the `www.google."
"org` domain. Put an upper limit of 100 pages or so so that you don't end up "
"being blocked by the site."
msgstr ""
"Extinde탵i acest lucru pentru a extrage 칥n mod recursiv leg캒turile din toate "
"paginile de pe domeniul `www.google.org`. Pune탵i o limit캒 superioar캒 de "
"aproximativ 100 de pagini, astfel 칥nc칙t s캒 nu ajunge탵i s캒 fi탵i blocat de "
"site."

#: src/async.md:1
#, fuzzy
msgid "Async Rust"
msgstr "Async Rust"

#: src/async.md:3
#, fuzzy
msgid ""
"\"Async\" is a concurrency model where multiple tasks are executed "
"concurrently by executing each task until it would block, then switching to "
"another task that is ready to make progress. The model allows running a "
"larger number of tasks on a limited number of threads. This is because the "
"per-task overhead is typically very low and operating systems provide "
"primitives for efficiently identifying I/O that is able to proceed."
msgstr ""
"\"Async\" este un model de simultaneitate 칥n care mai multe sarcini sunt "
"executate simultan prin executarea fiec캒rei sarcini p칙n캒 c칙nd se blocheaz캒, "
"apoi se trece la o alt캒 sarcin캒 care este gata s캒 progreseze. Acest model "
"permite rularea unui num캒r mai mare de sarcini pe un num캒r limitat de fire "
"de execu탵ie. Acest lucru se datoreaz캒 faptului c캒, de obicei, costurile de "
"operare per sarcin캒 sunt foarte sc캒zute, iar sistemele de operare ofer캒 "
"primitive pentru identificarea eficient캒 a I/O care pot continua."

#: src/async.md:10
#, fuzzy
msgid ""
"Rust's asynchronous operation is based on \"futures\", which represent work "
"that may be completed in the future. Futures are \"polled\" until they "
"signal that they are complete."
msgstr ""
"Func탵ionarea asincron캒 a Rust se bazeaz캒 pe \"futures\", care reprezint캒 "
"munca ce poate fi finalizat캒 칥n viitor. Futures sunt \"interogate\" p칙n캒 "
"c칙nd semnaleaz캒 c캒 sunt finalizate."

#: src/async.md:14
#, fuzzy
msgid ""
"Futures are polled by an async runtime, and several different runtimes are "
"available."
msgstr ""
"Futures sunt interogate de un timp de execu탵ie asincron 탳i sunt disponibile "
"mai multe timpuri de execu탵ie diferite."

#: src/async.md:17
#, fuzzy
msgid "Comparisons"
msgstr "Compara탵ii"

#: src/async.md:19
#, fuzzy
msgid ""
"Python has a similar model in its `asyncio`. However, its `Future` type is "
"callback-based, and not polled. Async Python programs require a \"loop\", "
"similar to a runtime in Rust."
msgstr ""
"Python are un model similar 칥n `asyncio`. Cu toate acestea, tipul s캒u "
"`Future` se bazeaz캒 pe callback 탳i nu pe polled. Programele asincrone din "
"Python necesit캒 o \"bucl캒\", similar캒 cu un timp de execu탵ie 칥n Rust."

#: src/async.md:23
#, fuzzy
msgid ""
"JavaScript's `Promise` is similar, but again callback-based. The language "
"runtime implements the event loop, so many of the details of Promise "
"resolution are hidden."
msgstr ""
"`Promise` din JavaScript este similar, dar se bazeaz캒 din nou pe callback. "
"Timpul de execu탵ie al limbajului implementeaz캒 bucla de evenimente, astfel "
"칥nc칙t multe dintre detaliile rezolv캒rii promisiunilor sunt ascunse."

#: src/async/async-await.md:1
#, fuzzy
msgid "`async`/`await`"
msgstr "`async`/`await`"

#: src/async/async-await.md:3
#, fuzzy
msgid ""
"At a high level, async Rust code looks very much like \"normal\" sequential "
"code:"
msgstr ""
"La un nivel 칥nalt, codul Rust asincron seam캒n캒 foarte mult cu codul "
"secven탵ial \"normal\":"

#: src/async/async-await.md:5
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"use futures::executor::block_on;\n"
"\n"
"async fn count_to(count: i32) {\n"
"    for i in 1..=count {\n"
"        println!(\"Count is: {i}!\");\n"
"    }\n"
"}\n"
"\n"
"async fn async_main(count: i32) {\n"
"    count_to(count).await;\n"
"}\n"
"\n"
"fn main() {\n"
"    block_on(async_main(10));\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"folosi탵i futures::executor::block_on;\n"
"\n"
"async fn count_to(count: i32) {\n"
"    for i in 1..=count {\n"
"        println!(\"Count is: {i}!\");\n"
"    }\n"
"}\n"
"\n"
"async fn async_main(count: i32) {\n"
"    count_to(count).await;\n"
"}\n"
"\n"
"fn main() {\n"
"    block_on(async_main(10));\n"
"}\n"
"```"

#: src/async/async-await.md:27
#, fuzzy
msgid ""
"Note that this is a simplified example to show the syntax. There is no long "
"running operation or any real concurrency in it!"
msgstr ""
"Re탵ine탵i c캒 acesta este un exemplu simplificat pentru a ar캒ta sintaxa. Nu "
"exist캒 nicio opera탵iune de lung캒 durat캒 sau vreo concuren탵캒 real캒!"

#: src/async/async-await.md:30
#, fuzzy
msgid "What is the return type of an async call?"
msgstr "Care este tipul de returnare al unui apel asincron?"

#: src/async/async-await.md:31
#, fuzzy
msgid "Use `let future: () = async_main(10);` in `main` to see the type."
msgstr ""
"Utiliza탵i `let future: () = async_main(10);` 칥n `main` pentru a vedea tipul."

#: src/async/async-await.md:33
#, fuzzy
msgid ""
"The \"async\" keyword is syntactic sugar. The compiler replaces the return "
"type with a future. "
msgstr ""
"Cuv칙ntul cheie \"async\" este un zah캒r sintactic. Compilatorul 칥nlocuie탳te "
"tipul return cu un future."

#: src/async/async-await.md:36
#, fuzzy
msgid ""
"You cannot make `main` async, without additional instructions to the "
"compiler on how to use the returned future."
msgstr ""
"Nu pute탵i face ca `main` s캒 fie asincron, f캒r캒 instruc탵iuni suplimentare "
"pentru compilator cu privire la modul de utilizare a viitorului returnat."

#: src/async/async-await.md:39
#, fuzzy
msgid ""
"You need an executor to run async code. `block_on` blocks the current thread "
"until the provided future has run to completion. "
msgstr ""
"Ave탵i nevoie de un executor pentru a rula cod asincron. `block_on` blocheaz캒 "
"firul curent p칙n캒 c칙nd viitorul furnizat a fost executat p칙n캒 la finalizare."

#: src/async/async-await.md:42
#, fuzzy
msgid ""
"`.await` asynchronously waits for the completion of another operation. "
"Unlike `block_on`, `.await` doesn't block the current thread."
msgstr ""
"`.await` a탳teapt캒 칥n mod asincron finalizarea unei alte opera탵iuni. Spre "
"deosebire de `block_on`, `.await` nu blocheaz캒 firul curent."

#: src/async/async-await.md:45
#, fuzzy
msgid ""
"`.await` can only be used inside an `async` function (or block; these are "
"introduced later). "
msgstr ""
"`.await` poate fi folosit numai 칥n interiorul unei func탵ii `async` (sau "
"bloc; acestea sunt prezentate mai t칙rziu)."

#: src/async/futures.md:3
#, fuzzy
msgid ""
"[`Future`](https://doc.rust-lang.org/std/future/trait.Future.html) is a "
"trait, implemented by objects that represent an operation that may not be "
"complete yet. A future can be polled, and `poll` returns a [`Poll`](https://"
"doc.rust-lang.org/std/task/enum.Poll.html)."
msgstr ""
"[`Future`](https://doc.rust-lang.org/std/future/trait.Future.html) este o "
"tr캒s캒tur캒, implementat캒 de obiecte care reprezint캒 o opera탵iune care poate "
"s캒 nu fie 칥nc캒 finalizat캒. Un viitor poate fi interogat, iar `poll` "
"returneaz캒 un [`Poll`](https://doc.rust-lang.org/std/task/enum.Poll.html)."

#: src/async/futures.md:23
#, fuzzy
msgid ""
"An async function returns an `impl Future`. It's also possible (but "
"uncommon) to implement `Future` for your own types. For example, the "
"`JoinHandle` returned from `tokio::spawn` implements `Future` to allow "
"joining to it."
msgstr ""
"O func탵ie asincron캒 returneaz캒 un `impl Future`. De asemenea, este posibil "
"(dar mai pu탵in obi탳nuit) s캒 implementa탵i `Future` pentru propriile tipuri. "
"De exemplu, `JoinHandle` returnat de `tokio::spawn` implementeaz캒 `Future` "
"pentru a permite 칥mbinarea cu acesta."

#: src/async/futures.md:27
#, fuzzy
msgid ""
"The `.await` keyword, applied to a Future, causes the current async function "
"to pause until that Future is ready, and then evaluates to its output."
msgstr ""
"Cuv칙ntul cheie `.await`, aplicat la un Future, determin캒 func탵ia asincron캒 "
"curent캒 s캒 se opreasc캒 p칙n캒 c칙nd Future-ul este gata 탳i apoi evalueaz캒 la "
"ie탳ire."

#: src/async/futures.md:32
#, fuzzy
msgid ""
"The `Future` and `Poll` types are implemented exactly as shown; click the "
"links to show the implementations in the docs."
msgstr ""
"Tipurile `Future` 탳i `Poll` sunt implementate exact a탳a cum se arat캒; face탵i "
"clic pe linkuri pentru a vedea implement캒rile din documenta탵ie."

#: src/async/futures.md:35
#, fuzzy
msgid ""
"We will not get to `Pin` and `Context`, as we will focus on writing async "
"code, rather than building new async primitives. Briefly:"
msgstr ""
"Nu vom ajunge la `Pin` 탳i `Context`, deoarece ne vom concentra pe scrierea "
"de cod asincron, mai degrab캒 dec칙t pe construirea de noi primitive "
"asincrone. Pe scurt:"

#: src/async/futures.md:38
#, fuzzy
msgid ""
"`Context` allows a Future to schedule itself to be polled again when an "
"event occurs."
msgstr ""
"`Context` permite unui Future s캒 se programeze pentru a fi interogat din nou "
"atunci c칙nd are loc un eveniment."

#: src/async/futures.md:41
#, fuzzy
msgid ""
"`Pin` ensures that the Future isn't moved in memory, so that pointers into "
"that future remain valid. This is required to allow references to remain "
"valid after an `.await`."
msgstr ""
"`Pin` se asigur캒 c캒 viitorul nu este mutat 칥n memorie, astfel 칥nc칙t "
"indicatorii c캒tre acel viitor r캒m칙n valabili. Acest lucru este necesar "
"pentru a permite ca referin탵ele s캒 r캒m칙n캒 valabile dup캒 un `.await`."

#: src/async/runtimes.md:3
#, fuzzy
msgid ""
"A _runtime_ provides support for performing operations asynchronously (a "
"_reactor_) and is responsible for executing futures (an _executor_). Rust "
"does not have a \"built-in\" runtime, but several options are available:"
msgstr ""
"Un _runtime_ ofer캒 suport pentru efectuarea de opera탵ii asincrone (un "
"_reactor_) 탳i este responsabil pentru executarea futures (un _executor_). "
"Rust nu are un timp de execu탵ie \"칥ncorporat\", dar sunt disponibile mai "
"multe op탵iuni:"

#: src/async/runtimes.md:7
#, fuzzy
msgid ""
"[Tokio](https://tokio.rs/): performant, with a well-developed ecosystem of "
"functionality like [Hyper](https://hyper.rs/) for HTTP or [Tonic](https://"
"github.com/hyperium/tonic) for gRPC."
msgstr ""
"[Tokio](https://tokio.rs/): performant, cu un ecosistem bine dezvoltat de "
"func탵ionalit캒탵i precum [Hyper](https://hyper.rs/) pentru HTTP sau [Tonic]"
"(https://github.com/hyperium/tonic) pentru gRPC."

#: src/async/runtimes.md:10
#, fuzzy
msgid ""
"[async-std](https://async.rs/): aims to be a \"std for async\", and includes "
"a basic runtime in `async::task`."
msgstr ""
"[async-std](https://async.rs/): 칥탳i propune s캒 fie un \"std pentru async\" "
"탳i include un timp de execu탵ie de baz캒 칥n `async::task`."

#: src/async/runtimes.md:12
#, fuzzy
msgid "[smol](https://docs.rs/smol/latest/smol/): simple and lightweight"
msgstr "[smol](https://docs.rs/smol/latest/smol/): simplu 탳i u탳or"

#: src/async/runtimes.md:14
#, fuzzy
msgid ""
"Several larger applications have their own runtimes. For example, [Fuchsia]"
"(https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/lib/fuchsia-"
"async/src/lib.rs) already has one."
msgstr ""
"Mai multe aplica탵ii mai mari au propriile lor timpuri de execu탵ie. De "
"exemplu, [Fuchsia](https://fuchsia.googlesource.com/fuchsia/+/refs/heads/"
"main/src/lib/fuchsia-async/src/lib.rs) are deja unul."

#: src/async/runtimes.md:20
#, fuzzy
msgid ""
"Note that of the listed runtimes, only Tokio is supported in the Rust "
"playground. The playground also does not permit any I/O, so most interesting "
"async things can't run in the playground."
msgstr ""
"Re탵ine탵i c캒, dintre timpii de execu탵ie enumera탵i, numai Tokio este acceptat "
"칥n zona de joac캒 Rust. De asemenea, terenul de joac캒 nu permite niciun fel "
"de I/O, astfel 칥nc칙t cele mai multe lucruri asincrone interesante nu pot fi "
"rulate 칥n terenul de joac캒."

#: src/async/runtimes.md:24
#, fuzzy
msgid ""
"Futures are \"inert\" in that they do not do anything (not even start an I/O "
"operation) unless there is an executor polling them. This differs from JS "
"Promises, for example, which will run to completion even if they are never "
"used."
msgstr ""
"Futures sunt \"iner탵i\", 칥n sensul c캒 nu fac nimic (nici m캒car nu 칥ncep o "
"opera탵iune de I/O) dec칙t dac캒 exist캒 un executor care s캒 le interogheze. "
"Acest lucru este diferit de JS Promises, de exemplu, care vor fi executate "
"p칙n캒 la finalizare chiar dac캒 nu sunt folosite niciodat캒."

#: src/async/runtimes/tokio.md:4
#, fuzzy
msgid "Tokio provides: "
msgstr "Tokio ofer캒:"

#: src/async/runtimes/tokio.md:6
#, fuzzy
msgid "A multi-threaded runtime for executing asynchronous code."
msgstr ""
"Un timp de execu탵ie cu mai multe fire de execu탵ie pentru executarea de cod "
"asincron."

#: src/async/runtimes/tokio.md:7
#, fuzzy
msgid "An asynchronous version of the standard library."
msgstr "O versiune asincron캒 a bibliotecii standard."

#: src/async/runtimes/tokio.md:8
#, fuzzy
msgid "A large ecosystem of libraries."
msgstr "Un ecosistem mare de biblioteci."

#: src/async/runtimes/tokio.md:10
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"use tokio::time;\n"
"\n"
"async fn count_to(count: i32) {\n"
"    for i in 1..=count {\n"
"        println!(\"Count in task: {i}!\");\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"    }\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    tokio::spawn(count_to(10));\n"
"\n"
"    for i in 1..5 {\n"
"        println!(\"Main task: {i}\");\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"folosi탵i tokio::time;\n"
"\n"
"async fn count_to(count: i32) {\n"
"    for i in 1..=count {\n"
"        println!(\"Count in task: {i}!\");\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"    }\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    tokio::spawn(count_to(10));\n"
"\n"
"    for i in 1..5 {\n"
"        println!(\"Sarcina principal캒: {i}\");\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"    }\n"
"}\n"
"```"

#: src/async/runtimes/tokio.md:33
#, fuzzy
msgid "With the `tokio::main` macro we can now make `main` async."
msgstr ""
"Cu ajutorul macroului `tokio::main` putem face acum ca `main` s캒 fie "
"asincronizat."

#: src/async/runtimes/tokio.md:35
#, fuzzy
msgid "The `spawn` function creates a new, concurrent \"task\"."
msgstr "Func탵ia `spawn` creeaz캒 o nou캒 \"sarcin캒\" concurent캒."

#: src/async/runtimes/tokio.md:37
#, fuzzy
msgid "Note: `spawn` takes a `Future`, you don't call `.await` on `count_to`."
msgstr "Not캒: `spawn` ia un `Future`, nu se apeleaz캒 `.await` pe `count_to`."

#: src/async/runtimes/tokio.md:39
#, fuzzy
msgid "**Further exploration:**"
msgstr "**Explorare suplimentar캒:**"

#: src/async/runtimes/tokio.md:41
#, fuzzy
msgid ""
"Why does `count_to` not (usually) get to 10? This is an example of async "
"cancellation. `tokio::spawn` returns a handle which can be awaited to wait "
"until it finishes."
msgstr ""
"De ce `count_to` nu ajunge (de obicei) la 10? Acesta este un exemplu de "
"anulare asincron캒. `tokio::spawn` returneaz캒 un handle care poate fi "
"a탳teptat pentru a a탳tepta p칙n캒 c칙nd se termin캒."

#: src/async/runtimes/tokio.md:45
#, fuzzy
msgid "Try `count_to(10).await` instead of spawning."
msgstr "칉ncearc캒 `count_to(10).await` 칥n loc de spawning."

#: src/async/runtimes/tokio.md:47
#, fuzzy
msgid "Try awaiting the task returned from `tokio::spawn`."
msgstr "칉ncerca탵i s캒 a탳tepta탵i sarcina returnat캒 de `tokio::spawn`."

#: src/async/tasks.md:3
#, fuzzy
msgid "Rust has a task system, which is a form of lightweight threading."
msgstr "Rust are un sistem de sarcini, care este o form캒 de threading u탳or."

#: src/async/tasks.md:5
#, fuzzy
msgid ""
"A task has a single top-level future which the executor polls to make "
"progress. That future may have one or more nested futures that its `poll` "
"method polls, corresponding loosely to a call stack. Concurrency within a "
"task is possible by polling multiple child futures, such as racing a timer "
"and an I/O operation."
msgstr ""
"O sarcin캒 are un singur viitor de nivel superior pe care executorul 칥l "
"sondeaz캒 pentru a progresa. Acel viitor poate avea unul sau mai multe "
"viitoare imbricate pe care metoda sa `poll` le interogheaz캒, ceea ce "
"corespunde, 칥n linii mari, unei stive de apeluri. Concuren탵a 칥n cadrul unei "
"sarcini este posibil캒 prin interogarea mai multor futures mai mici, cum ar "
"fi cursele dintre un cronometru 탳i o opera탵iune I/O."

#: src/async/tasks.md:10
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"use tokio::io::{self, AsyncReadExt, AsyncWriteExt};\n"
"use tokio::net::TcpListener;\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> io::Result<()> {\n"
"    let listener = TcpListener::bind(\"127.0.0.1:6142\").await?;\n"
"\tprintln!(\"listening on port 6142\");\n"
"\n"
"    loop {\n"
"        let (mut socket, addr) = listener.accept().await?;\n"
"\n"
"        println!(\"connection from {addr:?}\");\n"
"\n"
"        tokio::spawn(async move {\n"
"            if let Err(e) = socket.write_all(b\"Who are you?\\n\").await {\n"
"                println!(\"socket error: {e:?}\");\n"
"                return;\n"
"            }\n"
"\n"
"            let mut buf = vec![0; 1024];\n"
"            let reply = match socket.read(&mut buf).await {\n"
"                Ok(n) => {\n"
"                    let name = std::str::from_utf8(&buf[..n]).unwrap()."
"trim();\n"
"                    format!(\"Thanks for dialing in, {name}!\\n\")\n"
"                }\n"
"                Err(e) => {\n"
"                    println!(\"socket error: {e:?}\");\n"
"                    return;\n"
"                }\n"
"            };\n"
"\n"
"            if let Err(e) = socket.write_all(reply.as_bytes()).await {\n"
"                println!(\"socket error: {e:?}\");\n"
"            }\n"
"        });\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,compile_fail\n"
"use tokio::io::{self, AsyncReadExt, AsyncWriteExt};\n"
"use tokio::net::TcpListener;\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> io::Result<()> {\n"
"    let listener = TcpListener::bind(\"127.0.0.1:6142\").await?;\n"
"\tprintln!(\"listening on port 6142\");\n"
"\n"
"    loop {\n"
"        let (mut socket, addr) = listener.accept().await?;\n"
"\n"
"        println!(\"conexiune de la {addr:?}\");\n"
"\n"
"        tokio::spawn(async move {\n"
"            if let Err(e) = socket.write_all(b \"Who are you?\\n\").await {\n"
"                println!(\"eroare de socket: {e:?}\");\n"
"                return;\n"
"            }\n"
"\n"
"            let mut buf = vec![0; 1024];\n"
"            let reply = match socket.read(&mut buf).await {\n"
"                Ok(n) => {\n"
"                    let name = std::str::from_utf8(&buf[..n]).unwrap()."
"trim();\n"
"                    format!(\"Mul탵umesc pentru apelare, {name}!\\n\")\n"
"                }\n"
"                Err(e) => {\n"
"                    println!(\"eroare de socket: {e:?}\");\n"
"                    return;\n"
"                }\n"
"            };\n"
"\n"
"            if let Err(e) = socket.write_all(reply.as_bytes()).await {\n"
"                println!(\"eroare socket: {e:?}\");\n"
"            }\n"
"        });\n"
"    }\n"
"}\n"
"```"

#: src/async/tasks.md:52 src/async/control-flow/join.md:36
#, fuzzy
msgid ""
"Copy this example into your prepared `src/main.rs` and run it from there."
msgstr ""
"Copia탵i acest exemplu 칥n fi탳ierul preg캒tit `src/main.rs` 탳i rula탵i-l de "
"acolo."

#: src/async/tasks.md:54
#, fuzzy
msgid ""
"Try connecting to it with a TCP connection tool like [nc](https://www.unix."
"com/man-page/linux/1/nc/) or [telnet](https://www.unix.com/man-page/linux/1/"
"telnet/)."
msgstr ""
"칉ncerca탵i s캒 v캒 conecta탵i la acesta cu un instrument de conexiune TCP, cum "
"ar fi [nc](https://www.unix.com/man-page/linux/1/nc/) sau [telnet](https://"
"www.unix.com/man-page/linux/1/telnet/)."

#: src/async/tasks.md:56
#, fuzzy
msgid ""
"Ask students to visualize what the state of the example server would be with "
"a few connected clients. What tasks exist? What are their Futures?"
msgstr ""
"Cere탵i elevilor s캒 vizualizeze care ar fi starea serverului de exemplu cu "
"c칙탵iva clien탵i conecta탵i. Ce sarcini exist캒? Care este viitorul lor?"

#: src/async/tasks.md:59
#, fuzzy
msgid ""
"This is the first time we've seen an `async` block. This is similar to a "
"closure, but does not take any arguments. Its return value is a Future, "
"similar to an `async fn`. "
msgstr ""
"Aceasta este prima dat캒 c칙nd vedem un bloc `async`. Acesta este asem캒n캒tor "
"cu o 칥nchidere, dar nu prime탳te niciun argument. Valoarea sa de 칥ntoarcere "
"este un Future, similar cu un `async fn`."

#: src/async/tasks.md:63
#, fuzzy
msgid ""
"Refactor the async block into a function, and improve the error handling "
"using `?`. "
msgstr ""
"Reface탵i blocul asincron 칥ntr-o func탵ie 탳i 칥mbun캒t캒탵i탵i gestionarea erorilor "
"folosind `?`."

#: src/async/channels.md:3
#, fuzzy
msgid ""
"Several crates have support for asynchronous channels. For instance `tokio`:"
msgstr ""
"Mai multe crates au suport pentru canale asincrone. De exemplu, `tokio`:"

#: src/async/channels.md:5
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"use tokio::sync::mpsc::{self, Receiver};\n"
"\n"
"async fn ping_handler(mut input: Receiver<()>) {\n"
"    let mut count: usize = 0;\n"
"\n"
"    while let Some(_) = input.recv().await {\n"
"        count += 1;\n"
"        println!(\"Received {count} pings so far.\");\n"
"    }\n"
"\n"
"    println!(\"ping_handler complete\");\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let (sender, receiver) = mpsc::channel(32);\n"
"    let ping_handler_task = tokio::spawn(ping_handler(receiver));\n"
"    for i in 0..10 {\n"
"        sender.send(()).await.expect(\"Failed to send ping.\");\n"
"        println!(\"Sent {} pings so far.\", i + 1);\n"
"    }\n"
"\n"
"    drop(sender);\n"
"    ping_handler_task.await.expect(\"Something went wrong in ping handler "
"task.\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"use tokio::sync::mpsc::{self, Receiver};\n"
"\n"
"async fn ping_handler(mut input: Receiver<()>) {\n"
"    let mut count: usize = 0;\n"
"\n"
"    while let Some(_) = input.recv().await {\n"
"        count += 1;\n"
"        println!(\"Received {count} pings so far.\");\n"
"    }\n"
"\n"
"    println!(\"ping_handler complete\");\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let (sender, receiver) = mpsc::channel(32);\n"
"    let ping_handler_task = tokio::spawn(ping_handler(receiver));\n"
"    for i in 0..10 {\n"
"        sender.send(()).await.expect(\"Failed to send ping.\");\n"
"        println!(\"Sent {} pings so far.\", i + 1);\n"
"    }\n"
"\n"
"    drop(sender);\n"
"    ping_handler_task.await.expect(\"Ceva nu a mers bine 칥n sarcina de "
"gestionare a ping-ului.\");\n"
"}\n"
"```"

#: src/async/channels.md:35
#, fuzzy
msgid "Change the channel size to `3` and see how it affects the execution."
msgstr ""
"Schimba탵i dimensiunea canalului la `3` 탳i vede탵i cum afecteaz캒 execu탵ia."

#: src/async/channels.md:37
#, fuzzy
msgid ""
"Overall, the interface is similar to the `sync` channels as seen in the "
"[morning class](concurrency/channels.md)."
msgstr ""
"칉n general, interfa탵a este similar캒 cu cea a canalelor `sync`, a탳a cum se "
"vede 칥n [morning class](concurrency/channels.md)."

#: src/async/channels.md:40
#, fuzzy
msgid "Try removing the `std::mem::drop` call. What happens? Why?"
msgstr "칉ncerca탵i s캒 elimina탵i apelul `std::mem::drop`. Ce se 칥nt칙mpl캒? De ce?"

#: src/async/channels.md:42
#, fuzzy
msgid ""
"The [Flume](https://docs.rs/flume/latest/flume/) crate has channels that "
"implement both `sync` and `async` `send` and `recv`. This can be convenient "
"for complex applications with both IO and heavy CPU processing tasks."
msgstr ""
"Crate [Flume](https://docs.rs/flume/latest/flume/) are canale care "
"implementeaz캒 at칙t `sync` c칙t 탳i `async` `send` 탳i `recv`. Acest lucru poate "
"fi convenabil pentru aplica탵iile complexe cu sarcini de procesare at칙t IO, "
"c칙t 탳i grele pentru CPU."

#: src/async/channels.md:46
#, fuzzy
msgid ""
"What makes working with `async` channels preferable is the ability to "
"combine them with other `future`s to combine them and create complex control "
"flow."
msgstr ""
"Ceea ce face ca lucrul cu canalele `async` s캒 fie preferabil este "
"capacitatea de a le combina cu alte `future` pentru a le combina 탳i a crea "
"un flux de control complex."

#: src/async/control-flow.md:1
#, fuzzy
msgid "Futures Control Flow"
msgstr "Fluxul de control al contractelor futures"

#: src/async/control-flow.md:3
#, fuzzy
msgid ""
"Futures can be combined together to produce concurrent compute flow graphs. "
"We have already seen tasks, that function as independent threads of "
"execution."
msgstr ""
"Futures pot fi combinate 칥mpreun캒 pentru a produce grafice de flux de calcul "
"concurent. Am v캒zut deja sarcini, care func탵ioneaz캒 ca fire de execu탵ie "
"independente."

#: src/async/control-flow.md:6
#, fuzzy
msgid "[Join](control-flow/join.md)"
msgstr "[Join](control-flow/join.md)"

#: src/async/control-flow.md:7
#, fuzzy
msgid "[Select](control-flow/select.md)"
msgstr "[Selectare](control-flow/select.md)"

#: src/async/control-flow/join.md:3
#, fuzzy
msgid ""
"A join operation waits until all of a set of futures are ready, and returns "
"a collection of their results. This is similar to `Promise.all` in "
"JavaScript or `asyncio.gather` in Python."
msgstr ""
"O opera탵iune de 칥mbinare a탳teapt캒 p칙n캒 c칙nd to탵i viitorii dintr-un set de "
"viitoare sunt gata 탳i returneaz캒 o colec탵ie de rezultate ale acestora. Acest "
"lucru este similar cu `Promise.all` 칥n JavaScript sau `asyncio.gather` 칥n "
"Python."

#: src/async/control-flow/join.md:7
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"use anyhow::Result;\n"
"use futures::future;\n"
"use reqwest;\n"
"use std::collections::HashMap;\n"
"\n"
"async fn size_of_page(url: &str) -> Result<usize> {\n"
"    let resp = reqwest::get(url).await?;\n"
"    Ok(resp.text().await?.len())\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let urls: [&str; 4] = [\n"
"        \"https://google.com\",\n"
"        \"https://httpbin.org/ip\",\n"
"        \"https://play.rust-lang.org/\",\n"
"        \"BAD_URL\",\n"
"    ];\n"
"    let futures_iter = urls.into_iter().map(size_of_page);\n"
"    let results = future::join_all(futures_iter).await;\n"
"    let page_sizes_dict: HashMap<&str, Result<usize>> =\n"
"        urls.into_iter().zip(results.into_iter()).collect();\n"
"    println!(\"{:?}\", page_sizes_dict);\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"utiliza탵i anyhow::Result;\n"
"use futures::future;\n"
"use reqwest;\n"
"use std::collections::HashMap;\n"
"\n"
"async fn size_of_page(url: &amp;str) -&gt; Result<usize> { {\n"
"    let resp = reqwest::get(url).await?;\n"
"    Ok(resp.text().await?.len())\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let urls: [&amp;str; 4] = [\n"
"        \"https://google.com\",\n"
"        \"https://httpbin.org/ip\",\n"
"        \"https://play.rust-lang.org/\",\n"
"        \"BAD_URL\",\n"
"    ];\n"
"    let futures_iter = urls.into_iter().map(size_of_page);\n"
"    let results = future::join_all(futures_iter).await;\n"
"    let page_sizes_dict: HashMap&lt;&amp;str, Result<usize>&gt; = =\n"
"        urls.into_iter().zip(results.into_iter()).collect();\n"
"    println!(\"{:?}\", page_sizes_dict);\n"
"}\n"
"```"

#: src/async/control-flow/join.md:38
#, fuzzy
msgid ""
"For multiple futures of disjoint types, you can use `std::future::join!` but "
"you must know how many futures you will have at compile time. This is "
"currently in the `futures` crate, soon to be stabilised in `std::future`."
msgstr ""
"Pentru mai multe futures de tipuri disjuncte, pute탵i utiliza `std::future::"
"join!`, dar trebuie s캒 탳ti탵i c칙te futures ve탵i avea 칥n momentul compil캒rii. "
"Acest lucru se afl캒 칥n prezent 칥n cr캒iasa `futures`, urm칙nd a fi stabilizat "
"칥n cur칙nd 칥n `std::future`."

#: src/async/control-flow/join.md:42
#, fuzzy
msgid ""
"The risk of `join` is that one of the futures may never resolve, this would "
"cause your program to stall. "
msgstr ""
"Riscul `join` este ca unul dintre futures s캒 nu se rezolve niciodat캒, ceea "
"ce ar face ca programul dumneavoastr캒 s캒 se blocheze."

#: src/async/control-flow/join.md:45
#, fuzzy
msgid ""
"You can also combine `join_all` with `join!` for instance to join all "
"requests to an http service as well as a database query. Try adding a "
"`tokio::time::sleep` to the future, using `futures::join!`. This is not a "
"timeout (that requires `select!`, explained in the next chapter), but "
"demonstrates `join!`."
msgstr ""
"De asemenea, pute탵i combina `join_all` cu `join!`, de exemplu, pentru a uni "
"toate cererile c캒tre un serviciu http, precum 탳i o interogare a unei baze de "
"date. 칉ncerca탵i s캒 ad캒uga탵i un `tokio::time::sleep` la viitor, folosind "
"`futures::join!`. Acesta nu este un timeout (care necesit캒 `select!`, "
"explicat 칥n capitolul urm캒tor), ci demonstreaz캒 `join!`."

#: src/async/control-flow/select.md:3
#, fuzzy
msgid ""
"A select operation waits until any of a set of futures is ready, and "
"responds to that future's result. In JavaScript, this is similar to `Promise."
"race`. In Python, it compares to `asyncio.wait(task_set, return_when=asyncio."
"FIRST_COMPLETED)`."
msgstr ""
"O opera탵iune de selectare a탳teapt캒 p칙n캒 c칙nd oricare dintre un set de "
"viitoare este gata 탳i r캒spunde la rezultatul viitorului respectiv. 칉n "
"JavaScript, aceast캒 opera탵iune este similar캒 cu `Promise.race`. 칉n Python, "
"se compar캒 cu `asyncio.wait(task_set, return_when=asyncio.FIRST_COMPLETED)`."

#: src/async/control-flow/select.md:8
#, fuzzy
msgid ""
"Similar to a match statement, the body of `select!` has a number of arms, "
"each of the form `pattern = future => statement`. When the `future` is "
"ready, the `statement` is executed with the variables in `pattern` bound to "
"the `future`'s result."
msgstr ""
"La fel ca o instruc탵iune match, corpul instruc탵iunii `select!` are mai multe "
"bra탵e, fiecare de forma `pattern = future => statement`. C칙nd `future` este "
"gata, `statement` este executat cu variabilele din `pattern` legate de "
"rezultatul `future`."

#: src/async/control-flow/select.md:13
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"use tokio::sync::mpsc::{self, Receiver};\n"
"use tokio::time::{sleep, Duration};\n"
"\n"
"#[derive(Debug, PartialEq)]\n"
"enum Animal {\n"
"    Cat { name: String },\n"
"    Dog { name: String },\n"
"}\n"
"\n"
"async fn first_animal_to_finish_race(\n"
"    mut cat_rcv: Receiver<String>,\n"
"    mut dog_rcv: Receiver<String>,\n"
") -> Option<Animal> {\n"
"    tokio::select! {\n"
"        cat_name = cat_rcv.recv() => Some(Animal::Cat { name: cat_name? }),\n"
"        dog_name = dog_rcv.recv() => Some(Animal::Dog { name: dog_name? })\n"
"    }\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let (cat_sender, cat_receiver) = mpsc::channel(32);\n"
"    let (dog_sender, dog_receiver) = mpsc::channel(32);\n"
"    tokio::spawn(async move {\n"
"        sleep(Duration::from_millis(500)).await;\n"
"        cat_sender\n"
"            .send(String::from(\"Felix\"))\n"
"            .await\n"
"            .expect(\"Failed to send cat.\");\n"
"    });\n"
"    tokio::spawn(async move {\n"
"        sleep(Duration::from_millis(50)).await;\n"
"        dog_sender\n"
"            .send(String::from(\"Rex\"))\n"
"            .await\n"
"            .expect(\"Failed to send dog.\");\n"
"    });\n"
"\n"
"    let winner = first_animal_to_finish_race(cat_receiver, dog_receiver)\n"
"        .await\n"
"        .expect(\"Failed to receive winner\");\n"
"\n"
"    println!(\"Winner is {winner:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"use tokio::sync::mpsc::{self, Receiver};\n"
"use tokio::time::{sleep, Duration};\n"
"\n"
"#[derive(Debug, PartialEq)]\n"
"enum Animal {\n"
"    Cat { name: String },\n"
"    Dog { name: String },\n"
"}\n"
"\n"
"async fn first_animal_to_finish_race(\n"
"    mut cat_rcv: Receptor<String>,\n"
"    mut dog_rcv: Receptor<String>,\n"
") -&gt; Option<Animal> {\n"
"    tokio::select! {\n"
"        cat_name = cat_rcv.recv() =&gt; Some(Animal::Cat { name: "
"cat_name? }),\n"
"        dog_name = dog_rcv.recv() =&gt; Some(Animal::Dog { name: "
"dog_name? })\n"
"    }\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let (cat_sender, cat_receiver) = mpsc::channel(32);\n"
"    let (dog_sender, dog_receiver) = mpsc::channel(32);\n"
"    tokio::spawn(async move {\n"
"        sleep(Duration::from_millis(500)).await;\n"
"        cat_sender\n"
"            .send(String::from(\"Felix\"))\n"
"            .await\n"
"            .expect(\"Nu s-a reu탳it trimiterea pisicii.\");\n"
"    });\n"
"    tokio::spawn(async move {\n"
"        sleep(Duration::from_millis(50)).await;\n"
"        dog_sender\n"
"            .send(String::from(\"Rex\"))\n"
"            .await\n"
"            .expect(\"Nu s-a reu탳it trimiterea c칙inelui.\");\n"
"    });\n"
"\n"
"    let winner = first_animal_to_finish_race(cat_receiver, dog_receiver)\n"
"        .await\n"
"        .expect(\"Failed to receive winner\");\n"
"\n"
"    println!(\"C칙탳tig캒torul este {winner:?}\");\n"
"}\n"
"```"

#: src/async/control-flow/select.md:62
#, fuzzy
msgid ""
"In this example, we have a race between a cat and a dog. "
"`first_animal_to_finish_race` listens to both channels and will pick "
"whichever arrives first. Since the dog takes 50ms, it wins against the cat "
"that take 500ms."
msgstr ""
"칉n acest exemplu, avem o curs캒 칥ntre o pisic캒 탳i un c칙ine. "
"`first_animal_to_finish_race` ascult캒 ambele canale 탳i 칥l va alege pe cel "
"care ajunge primul. Deoarece c칙inele are nevoie de 50ms, c칙탳tig캒 칥mpotriva "
"pisicii care are nevoie de 500ms."

#: src/async/control-flow/select.md:67
#, fuzzy
msgid ""
"You can use `oneshot` channels in this example as the channels are supposed "
"to receive only one `send`."
msgstr ""
"칉n acest exemplu, pute탵i utiliza canale `oneshot`, deoarece canalele trebuie "
"s캒 primeasc캒 doar un singur `send`."

#: src/async/control-flow/select.md:70
#, fuzzy
msgid ""
"Try adding a deadline to the race, demonstrating selecting different sorts "
"of futures."
msgstr ""
"칉ncerca탵i s캒 ad캒uga탵i un termen limit캒 la curs캒, demonstr칙nd c캒 a탵i selectat "
"diferite tipuri de viitoruri."

#: src/async/control-flow/select.md:73
#, fuzzy
msgid ""
"Note that `select!` drops unmatched branches, which cancels their futures. "
"It is easiest to use when every execution of `select!` creates new futures."
msgstr ""
"Re탵ine탵i c캒 `select!` renun탵캒 la ramurile nepotrivite, ceea ce anuleaz캒 "
"viitorul acestora. Este cel mai u탳or de utilizat atunci c칙nd fiecare "
"execu탵ie a `select!` creeaz캒 noi futures."

#: src/async/control-flow/select.md:76
#, fuzzy
msgid ""
"An alternative is to pass `&mut future` instead of the future itself, but "
"this can lead to issues, further discussed in the pinning slide."
msgstr ""
"O alternativ캒 este de a trece `&mut future` 칥n locul viitorului 칥nsu탳i, dar "
"acest lucru poate duce la probleme, discutate 칥n continuare 칥n slide-ul cu "
"privire la fixarea."

#: src/async/pitfalls.md:1
#, fuzzy
msgid "Pitfalls of async/await"
msgstr "Capcanele lui async/await"

#: src/async/pitfalls.md:3
#, fuzzy
msgid ""
"Async / await provides convenient and efficient abstraction for concurrent "
"asynchronous programming. However, the async/await model in Rust also comes "
"with its share of pitfalls and footguns. We illustrate some of them in this "
"chapter:"
msgstr ""
"Async / await ofer캒 o abstractizare convenabil캒 탳i eficient캒 pentru "
"programarea asincron캒 concurent캒. Cu toate acestea, modelul async/await din "
"Rust vine 탳i el cu partea sa de capcane 탳i piedici. 칉n acest capitol "
"ilustr캒m c칙teva dintre ele:"

#: src/async/pitfalls.md:5
#, fuzzy
msgid "[Blocking the Executor](pitfalls/blocking-executor.md)"
msgstr "[Blocarea executorului](pitfalls/blocking-executor.md)"

#: src/async/pitfalls.md:6
#, fuzzy
msgid "[Pin](pitfalls/pin.md)"
msgstr "[Pin](pitfalls/pin.md)"

#: src/async/pitfalls.md:7
#, fuzzy
msgid "[Async Traits](pitfalls/async-traits.md)"
msgstr "[Tr캒s캒turi asincrone](pitfalls/async-traits.md)"

#: src/async/pitfalls.md:8
#, fuzzy
msgid "[Cancellation](pitfalls/cancellation.md)"
msgstr "[Anulare](pitfalls/cancellation.md)"

#: src/async/pitfalls/blocking-executor.md:1
#, fuzzy
msgid "Blocking the executor"
msgstr "Blocarea executorului"

#: src/async/pitfalls/blocking-executor.md:3
#, fuzzy
msgid ""
"Most async runtimes only allow IO tasks to run concurrently. This means that "
"CPU blocking tasks will block the executor and prevent other tasks from "
"being executed. An easy workaround is to use async equivalent methods where "
"possible."
msgstr ""
"Majoritatea timpilor de execu탵ie asincron캒 permit doar executarea simultan캒 "
"a sarcinilor IO. Aceasta 칥nseamn캒 c캒 sarcinile care blocheaz캒 CPU vor bloca "
"executorul 탳i vor 칥mpiedica executarea altor sarcini. O solu탵ie u탳oar캒 este "
"utilizarea unor metode echivalente asincrone acolo unde este posibil."

#: src/async/pitfalls/blocking-executor.md:7
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"use futures::future::join_all;\n"
"use std::time::Instant;\n"
"\n"
"async fn sleep_ms(start: &Instant, id: u64, duration_ms: u64) {\n"
"    std::thread::sleep(std::time::Duration::from_millis(duration_ms));\n"
"    println!(\n"
"        \"future {id} slept for {duration_ms}ms, finished after {}ms\",\n"
"        start.elapsed().as_millis()\n"
"    );\n"
"}\n"
"\n"
"#[tokio::main(flavor = \"current_thread\")]\n"
"async fn main() {\n"
"    let start = Instant::now();\n"
"    let sleep_futures = (1..=10).map(|t| sleep_ms(&start, t, t * 10));\n"
"    join_all(sleep_futures).await;\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"folosi탵i futures::future::join_all;\n"
"use std::time::Instant;\n"
"\n"
"async fn sleep_ms(start: &Instant, id: u64, duration_ms: u64) {\n"
"    std::thread::sleep(std::time::Duration::from_millis(duration_ms));\n"
"    println!(\n"
"        \"viitorul {id} a dormit timp de {duration_ms}ms, terminat dup캒 {}"
"ms\",\n"
"        start.elapsed().as_millis()\n"
"    );\n"
"}\n"
"\n"
"#[tokio::main(flavor = \"current_thread\")]\n"
"async fn main() {\n"
"    let start = Instant::now();\n"
"    let sleep_futures = (1..=10).map(|t| sleep_ms(&start, t, t * 10));\n"
"    join_all(sleep_futures).await;\n"
"}\n"
"```"

#: src/async/pitfalls/blocking-executor.md:29
#, fuzzy
msgid ""
"Run the code and see that the sleeps happen consecutively rather than "
"concurrently."
msgstr ""
"Rula탵i codul 탳i vede탵i c캒 somnul se produce consecutiv 탳i nu concomitent."

#: src/async/pitfalls/blocking-executor.md:32
#, fuzzy
msgid ""
"The `\"current_thread\"` flavor puts all tasks on a single thread. This "
"makes the effect more obvious, but the bug is still present in the multi-"
"threaded flavor."
msgstr ""
"Aroma `\"current_thread\"` pune toate sarcinile pe un singur fir. Acest "
"lucru face ca efectul s캒 fie mai evident, dar eroarea este 칥nc캒 prezent캒 칥n "
"varianta cu mai multe fire."

#: src/async/pitfalls/blocking-executor.md:36
#, fuzzy
msgid ""
"Switch the `std::thread::sleep` to `tokio::time::sleep` and await its result."
msgstr ""
"Schimb캒 `std::thread::sleep` cu `tokio::time::sleep` 탳i a탳teapt캒 rezultatul."

#: src/async/pitfalls/blocking-executor.md:38
#, fuzzy
msgid ""
"Another fix would be to `tokio::task::spawn_blocking` which spawns an actual "
"thread and transforms its handle into a future without blocking the executor."
msgstr ""
"O alt캒 solu탵ie ar fi `tokio::task::spawn_blocking` care genereaz캒 un fir "
"real 탳i transform캒 m칙nerul s캒u 칥ntr-un viitor f캒r캒 a bloca executorul."

#: src/async/pitfalls/blocking-executor.md:41
#, fuzzy
msgid ""
"You should not think of tasks as OS threads. They do not map 1 to 1 and most "
"executors will allow many tasks to run on a single OS thread. This is "
"particularly problematic when interacting with other libraries via FFI, "
"where that library might depend on thread-local storage or map to specific "
"OS threads (e.g., CUDA). Prefer `tokio::task::spawn_blocking` in such "
"situations."
msgstr ""
"Nu ar trebui s캒 v캒 g칙ndi탵i la sarcini ca la fire de sistem de operare. "
"Acestea nu se coreleaz캒 1 la 1 탳i majoritatea executorilor vor permite "
"rularea mai multor sarcini pe un singur fir OS. Acest lucru este deosebit de "
"problematic atunci c칙nd interac탵iona탵i cu alte biblioteci prin intermediul "
"FFI, 칥n cazul 칥n care biblioteca respectiv캒 ar putea depinde de stocarea "
"local캒 a firelor de execu탵ie sau ar putea fi mapat캒 pe anumite fire de "
"execu탵ie ale sistemului de operare (de exemplu, CUDA). Prefera탵i `tokio::"
"task::spawn_blocking` 칥n astfel de situa탵ii."

#: src/async/pitfalls/blocking-executor.md:47
#, fuzzy
msgid ""
"Use sync mutexes with care. Holding a mutex over an `.await` may cause "
"another task to block, and that task may be running on the same thread."
msgstr ""
"Utiliza탵i mutexurile de sincronizare cu grij캒. Men탵inerea unui mutex peste "
"un `.await` poate provoca blocarea unei alte sarcini, iar acea sarcin캒 poate "
"fi executat캒 pe acela탳i fir."

#: src/async/pitfalls/pin.md:3
#, fuzzy
msgid ""
"When you await a future, all local variables (that would ordinarily be "
"stored on a stack frame) are instead stored in the Future for the current "
"async block. If your future has pointers to data on the stack, those "
"pointers might get invalidated. This is unsafe."
msgstr ""
"Atunci c칙nd a탳tepta탵i un viitor, toate variabilele locale (care 칥n mod "
"normal ar fi stocate pe un cadru de stiv캒) sunt stocate 칥n schimb 칥n "
"viitorul pentru blocul asincron curent. 칉n cazul 칥n care viitorul "
"dumneavoastr캒 are pointeri la date de pe stiv캒, ace탳ti pointeri pot fi "
"invalida탵i. Acest lucru nu este sigur."

#: src/async/pitfalls/pin.md:8
#, fuzzy
msgid ""
"Therefore, you must guarantee that the addresses your future points to don't "
"change. That is why we need to `pin` futures. Using the same future "
"repeatedly in a `select!` often leads to issues with pinned values."
msgstr ""
"Prin urmare, trebuie s캒 v캒 asigura탵i c캒 adresele c캒tre care indic캒 viitorul "
"dumneavoastr캒 nu se schimb캒. Acesta este motivul pentru care trebuie s캒 "
"\"fix캒m\" viitoarele. Folosirea aceluia탳i viitor 칥n mod repetat 칥ntr-un "
"`select!` duce adesea la probleme cu valorile fixate."

#: src/async/pitfalls/pin.md:12
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"use tokio::sync::{mpsc, oneshot};\n"
"use tokio::task::spawn;\n"
"use tokio::time::{sleep, Duration};\n"
"\n"
"// A work item. In this case, just sleep for the given time and respond\n"
"// with a message on the `respond_on` channel.\n"
"#[derive(Debug)]\n"
"struct Work {\n"
"    input: u32,\n"
"    respond_on: oneshot::Sender<u32>,\n"
"}\n"
"\n"
"// A worker which listens for work on a queue and performs it.\n"
"async fn worker(mut work_queue: mpsc::Receiver<Work>) {\n"
"    let mut iterations = 0;\n"
"    loop {\n"
"        tokio::select! {\n"
"            Some(work) = work_queue.recv() => {\n"
"                sleep(Duration::from_millis(10)).await; // Pretend to work.\n"
"                work.respond_on\n"
"                    .send(work.input * 1000)\n"
"                    .expect(\"failed to send response\");\n"
"                iterations += 1;\n"
"            }\n"
"            // TODO: report number of iterations every 100ms\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// A requester which requests work and waits for it to complete.\n"
"async fn do_work(work_queue: &mpsc::Sender<Work>, input: u32) -> u32 {\n"
"    let (tx, rx) = oneshot::channel();\n"
"    work_queue\n"
"        .send(Work {\n"
"            input,\n"
"            respond_on: tx,\n"
"        })\n"
"        .await\n"
"        .expect(\"failed to send on work queue\");\n"
"    rx.await.expect(\"failed waiting for response\")\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let (tx, rx) = mpsc::channel(10);\n"
"    spawn(worker(rx));\n"
"    for i in 0..100 {\n"
"        let resp = do_work(&tx, i).await;\n"
"        println!(\"work result for iteration {i}: {resp}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"use tokio::sync::{mpsc, oneshot};\n"
"use tokio::task::spawn;\n"
"use tokio::time::{sleep, Duration};\n"
"\n"
"// Un element de lucru. 칉n acest caz, doar doarme pentru timpul dat 탳i "
"r캒spunde\n"
"// cu un mesaj pe canalul `respond_on`.\n"
"#[derive(Debug)]\n"
"struct Work {\n"
"    input: u32,\n"
"    respond_on: oneshot::Sender<u32>,\n"
"}\n"
"\n"
"// Un lucr캒tor care ascult캒 munca pe o coad캒 탳i o execut캒.\n"
"async fn worker(mut work_queue: mpsc::Receiver<Work>) {\n"
"    let mut iterations = 0;\n"
"    loop {\n"
"        tokio::select! {\n"
"            Some(work) = work_queue.recv() =&gt; {\n"
"                sleep(Duration::from_millis(10)).await; // Pretinde탵i c캒 "
"lucra탵i.\n"
"                work.respond_on\n"
"                    .send(work.input * 1000)\n"
"                    .expect(\"nu a reu탳it s캒 trimit캒 r캒spunsul\");\n"
"                itera탵ii += 1;\n"
"            }\n"
"            // TODO: raporta탵i num캒rul de itera탵ii la fiecare 100ms\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Un solicitant care solicit캒 munc캒 탳i a탳teapt캒 ca aceasta s캒 fie "
"finalizat캒.\n"
"async fn do_work(work_queue: &amp;mpsc::Sender<Work>, input: u32) -&gt; u32 "
"{\n"
"    let (tx, rx) = oneshot::channel();\n"
"    work_queue\n"
"        .send(Work {\n"
"            input,\n"
"            respond_on: tx,\n"
"        })\n"
"        .await\n"
"        .expect(\"nu a reu탳it s캒 trimit캒 칥n coada de lucru\");\n"
"    rx.await.expect(\"a e탳uat 칥n a탳teptarea r캒spunsului\")\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let (tx, rx) = mpsc::channel(10);\n"
"    spawn(worker(rx));\n"
"    for i in 0..100 {\n"
"        let resp = do_work(&amp;tx, i).await;\n"
"        println!(\"work result for iteration {i}: {resp}\");\n"
"    }\n"
"}\n"
"```"

#: src/async/pitfalls/pin.md:68
#, fuzzy
msgid ""
"You may recognize this as an example of the actor pattern. Actors typically "
"call `select!` in a loop."
msgstr ""
"Este posibil s캒 recunoa탳te탵i acest lucru ca fiind un exemplu de model actor. "
"De obicei, actorii apeleaz캒 `select!` 칥ntr-o bucl캒."

#: src/async/pitfalls/pin.md:71
#, fuzzy
msgid ""
"This serves as a summation of a few of the previous lessons, so take your "
"time with it."
msgstr ""
"Aceasta este o rezumare a c칙torva dintre lec탵iile anterioare, a탳a c캒 nu v캒 "
"gr캒bi탵i cu ea."

#: src/async/pitfalls/pin.md:74
#, fuzzy
msgid ""
"Naively add a `_ = sleep(Duration::from_millis(100)) => { println!(..) }` to "
"the `select!`. This will never execute. Why?"
msgstr ""
"Ad캒uga탵i 칥n mod naiv un `_ = sleep(Duration::from_millis(100)) => { println!"
"(..) }` la `select!`. Aceasta nu se va executa niciodat캒. De ce?"

#: src/async/pitfalls/pin.md:77
#, fuzzy
msgid ""
"Instead, add a `timeout_fut` containing that future outside of the `loop`:"
msgstr ""
"칉n schimb, ad캒uga탵i un `timeout_fut` care s캒 con탵in캒 acel viitor 칥n afara "
"`loop`:"

#: src/async/pitfalls/pin.md:88
#, fuzzy
msgid ""
"This still doesn't work. Follow the compiler errors, adding `&mut` to the "
"`timeout_fut` in the `select!` to work around the move, then using `Box::"
"pin`:"
msgstr ""
"Acest lucru tot nu func탵ioneaz캒. Urma탵i erorile compilatorului, ad캒ug칙nd "
"`&mut` la `timeout_fut` 칥n `select!` pentru a evita deplasarea, apoi "
"utiliza탵i `Box::pin`:"

#: src/async/pitfalls/pin.md:102
#, fuzzy
msgid ""
"This compiles, but once the timeout expires it is `Poll::Ready` on every "
"iteration (a fused future would help with this). Update to reset "
"`timeout_fut` every time it expires."
msgstr ""
"Acest lucru se compileaz캒, dar odat캒 ce expir캒 timpul de a탳teptare este "
"`Poll::Ready` la fiecare itera탵ie (un viitor fuzionat ar ajuta cu acest "
"lucru). Actualiza탵i pentru a reseta `timeout_fut` de fiecare dat캒 c칙nd "
"expir캒."

#: src/async/pitfalls/pin.md:106
#, fuzzy
msgid ""
"Box allocates on the heap. In some cases, `std::pin::pin!` (only recently "
"stabilized, with older code often using `tokio::pin!`) is also an option, "
"but that is difficult to use for a future that is reassigned."
msgstr ""
"Box aloc캒 pe heap. 칉n unele cazuri, `std::pin::pin!` (stabilizat doar "
"recent, codul mai vechi folosind adesea `tokio::pin!`) este, de asemenea, o "
"op탵iune, dar este dificil de utilizat pentru un viitor care este realocat."

#: src/async/pitfalls/pin.md:110
#, fuzzy
msgid ""
"Another alternative is to not use `pin` at all but spawn another task that "
"will send to a `oneshot` channel every 100ms."
msgstr ""
"O alt캒 alternativ캒 este s캒 nu folosi탵i `pin` deloc, ci s캒 genera탵i o alt캒 "
"sarcin캒 care va trimite la un canal `oneshot` la fiecare 100ms."

#: src/async/pitfalls/async-traits.md:3
#, fuzzy
msgid ""
"Async methods in traits are not yet supported in the stable channel ([An "
"experimental feature exists in nightly and should be stabilized in the mid "
"term.](https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-"
"nightly.html))"
msgstr ""
"Metodele asincrone din tr캒s캒turi nu sunt 칥nc캒 acceptate 칥n canalul stabil "
"([O caracteristic캒 experimental캒 exist캒 칥n nightly 탳i ar trebui s캒 fie "
"stabilizat캒 pe termen mediu.](https://blog.rust-lang.org/inside-"
"rust/2022/11/17/async-fn-in-trait-nightly.html))"

#: src/async/pitfalls/async-traits.md:5
#, fuzzy
msgid ""
"The crate [async_trait](https://docs.rs/async-trait/latest/async_trait/) "
"provides a workaround through a macro:"
msgstr ""
"Crate [async_trait](https://docs.rs/async-trait/latest/async_trait/) ofer캒 o "
"solu탵ie de rezolvare prin intermediul unei macro:"

#: src/async/pitfalls/async-traits.md:7
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"use async_trait::async_trait;\n"
"use std::time::Instant;\n"
"use tokio::time::{sleep, Duration};\n"
"\n"
"#[async_trait]\n"
"trait Sleeper {\n"
"    async fn sleep(&self);\n"
"}\n"
"\n"
"struct FixedSleeper {\n"
"    sleep_ms: u64,\n"
"}\n"
"\n"
"#[async_trait]\n"
"impl Sleeper for FixedSleeper {\n"
"    async fn sleep(&self) {\n"
"        sleep(Duration::from_millis(self.sleep_ms)).await;\n"
"    }\n"
"}\n"
"\n"
"async fn run_all_sleepers_multiple_times(sleepers: Vec<Box<dyn Sleeper>>, "
"n_times: usize) {\n"
"    for _ in 0..n_times {\n"
"        println!(\"running all sleepers..\");\n"
"        for sleeper in &sleepers {\n"
"            let start = Instant::now();\n"
"            sleeper.sleep().await;\n"
"            println!(\"slept for {}ms\", start.elapsed().as_millis());\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let sleepers: Vec<Box<dyn Sleeper>> = vec![\n"
"        Box::new(FixedSleeper { sleep_ms: 50 }),\n"
"        Box::new(FixedSleeper { sleep_ms: 100 }),\n"
"    ];\n"
"    run_all_sleepers_multiple_times(sleepers, 5).await;\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"use async_trait::async_trait;\n"
"use std::time::Instant;\n"
"use tokio::time::{sleep, Duration};\n"
"\n"
"#[async_trait]\n"
"trait Sleeper {\n"
"    async fn sleep(&amp;self);\n"
"}\n"
"\n"
"struct FixedSleeper {\n"
"    sleep_ms: u64,\n"
"}\n"
"\n"
"#[async_trait]\n"
"impl Sleeper pentru FixedSleeper {\n"
"    async fn sleep(&amp;self) {\n"
"        sleep(Duration::from_millis(self.sleep_ms)).await;\n"
"    }\n"
"}\n"
"\n"
"async fn run_all_sleepers_multiple_times(sleepers: Vec&lt;Box<dyn "
"Sleeper>&gt;, n_times: usize) {\n"
"    for _ in 0..n_times {\n"
"        println!(\"ruleaz캒 toate sleepers..\");\n"
"        for sleeper in &amp;sleepers {\n"
"            let start = Instant::now();\n"
"            sleeper.sleep().await;\n"
"            printlnn!(\"a dormit timp de {}ms\", start.elapsed()."
"as_millis()));\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let sleepers: Vec&lt;Box<dyn Sleeper>&gt; = vec![\n"
"        Box::new(FixedSleeper { sleep_ms: 50 }),\n"
"        Box::new(FixedSleeper { sleep_ms: 100 }),\n"
"    ];\n"
"    run_all_sleepers_multiple_times(sleepers, 5).await;\n"
"}\n"
"```"

#: src/async/pitfalls/async-traits.md:51
#, fuzzy
msgid ""
"`async_trait` is easy to use, but note that it's using heap allocations to "
"achieve this. This heap allocation has performance overhead."
msgstr ""
"`async_trait` este u탳or de utilizat, dar re탵ine탵i c캒 utilizeaz캒 aloc캒ri heap "
"pentru a realiza acest lucru. Aceast캒 alocare 칥n heap are costuri "
"suplimentare de performan탵캒."

#: src/async/pitfalls/async-traits.md:54
#, fuzzy
msgid ""
"The challenges in language support for `async trait` are deep Rust and "
"probably not worth describing in-depth. Niko Matsakis did a good job of "
"explaining them in [this post](https://smallcultfollowing.com/babysteps/"
"blog/2019/10/26/async-fn-in-traits-are-hard/) if you are interested in "
"digging deeper."
msgstr ""
"Provoc캒rile 칥n ceea ce prive탳te suportul lingvistic pentru `async trait` "
"sunt ad칙nci Rust 탳i probabil nu merit캒 s캒 fie descrise 칥n profunzime. Niko "
"Matsakis a f캒cut o treab캒 bun캒 explic칙ndu-le 칥n [aceast캒 postare](https://"
"smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-"
"hard/) dac캒 sunte탵i interesat s캒 aprofunda탵i."

#: src/async/pitfalls/async-traits.md:60
#, fuzzy
msgid ""
"Try creating a new sleeper struct that will sleep for a random amount of "
"time and adding it to the Vec."
msgstr ""
"칉ncerca탵i s캒 crea탵i o nou캒 structur캒 de somn care va dormi pentru o perioad캒 "
"de timp aleatorie 탳i ad캒uga탵i-o la Vec."

#: src/async/pitfalls/cancellation.md:3
#, fuzzy
msgid ""
"Dropping a future implies it can never be polled again. This is called "
"_cancellation_ and it can occur at any `await` point. Care is needed to "
"ensure the system works correctly even when futures are cancelled. For "
"example, it shouldn't deadlock or lose data."
msgstr ""
"Renun탵area la un viitor implic캒 faptul c캒 acesta nu mai poate fi interogat "
"niciodat캒. Acest lucru se nume탳te _cancellation_ 탳i poate avea loc 칥n orice "
"punct de a탳teptare (`await`). Este necesar캒 o aten탵ie deosebit캒 pentru a se "
"asigura c캒 sistemul func탵ioneaz캒 corect chiar 탳i atunci c칙nd futures sunt "
"anulate. De exemplu, nu trebuie s캒 se blocheze sau s캒 piard캒 date."

#: src/async/pitfalls/cancellation.md:8
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"use std::io::{self, ErrorKind};\n"
"use std::time::Duration;\n"
"use tokio::io::{AsyncReadExt, AsyncWriteExt, DuplexStream};\n"
"\n"
"struct LinesReader {\n"
"    stream: DuplexStream,\n"
"}\n"
"\n"
"impl LinesReader {\n"
"    fn new(stream: DuplexStream) -> Self {\n"
"        Self { stream }\n"
"    }\n"
"\n"
"    async fn next(&mut self) -> io::Result<Option<String>> {\n"
"        let mut bytes = Vec::new();\n"
"        let mut buf = [0];\n"
"        while self.stream.read(&mut buf[..]).await? != 0 {\n"
"            bytes.push(buf[0]);\n"
"            if buf[0] == b'\\n' {\n"
"                break;\n"
"            }\n"
"        }\n"
"        if bytes.is_empty() {\n"
"            return Ok(None)\n"
"        }\n"
"        let s = String::from_utf8(bytes)\n"
"            .map_err(|_| io::Error::new(ErrorKind::InvalidData, \"not "
"UTF-8\"))?;\n"
"        Ok(Some(s))\n"
"    }\n"
"}\n"
"\n"
"async fn slow_copy(source: String, mut dest: DuplexStream) -> std::io::"
"Result<()> {\n"
"    for b in source.bytes() {\n"
"        dest.write_u8(b).await?;\n"
"        tokio::time::sleep(Duration::from_millis(10)).await\n"
"    }\n"
"    Ok(())\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> std::io::Result<()> {\n"
"    let (client, server) = tokio::io::duplex(5);\n"
"    let handle = tokio::spawn(slow_copy(\"hi\\nthere\\n\".to_owned(), "
"client));\n"
"\n"
"    let mut lines = LinesReader::new(server);\n"
"    let mut interval = tokio::time::interval(Duration::from_millis(60));\n"
"    loop {\n"
"        tokio::select! {\n"
"            _ = interval.tick() => println!(\"tick!\"),\n"
"            line = lines.next() => if let Some(l) = line? {\n"
"                print!(\"{}\", l)\n"
"            } else {\n"
"                break\n"
"            },\n"
"        }\n"
"    }\n"
"    handle.await.unwrap()?;\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"use std::io::{self, ErrorKind};\n"
"use std::time::Duration;\n"
"use tokio::io::{AsyncReadExt, AsyncWriteExt, DuplexStream};\n"
"\n"
"struct LinesReader {\n"
"    stream: DuplexStream,\n"
"}\n"
"\n"
"impl LinesReader {\n"
"    fn new(stream: DuplexStream) -&gt; Self {\n"
"        Self { stream }\n"
"    }\n"
"\n"
"    async fn next(&amp;mut self) -&gt; io::Result&lt;Option<String>&gt; {\n"
"        let mut bytes = Vec::new();\n"
"        let mut buf = [0];\n"
"        while self.stream.read(&amp;mut buf[..]).await? != 0 {\n"
"            bytes.push(buf[0]);\n"
"            if buf[0] == b'\\n' {\n"
"                break;\n"
"            }\n"
"        }\n"
"        if bytes.is_empty() {\n"
"            return Ok(None)\n"
"        }\n"
"        let s = String::from_utf8(bytes)\n"
"            .map_err(|_| io::Error::new(ErrorKind::InvalidData, \"not "
"UTF-8\")))?;\n"
"        Ok(Some(s))\n"
"    }\n"
"}\n"
"\n"
"async fn slow_copy(source: String, mut dest: DuplexStream) -&gt; std::io::"
"Result<()> {\n"
"    for b in source.bytes() {\n"
"        dest.write_u8(b).await?;\n"
"        tokio::time::sleep(Duration::from_millis(10)).await\n"
"    }\n"
"    Ok((())\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() -&gt; std::io::Result<()> {\n"
"    let (client, server) = tokio::io::duplex(5);\n"
"    let handle = tokio::spawn(slow_copy(\"hi\\nthere\\n\".to_owned(), "
"client));\n"
"\n"
"    let mut lines = LinesReader::new(server);\n"
"    let mut interval = tokio::time::interval(Duration::from_millis(60));\n"
"    loop {\n"
"        tokio::select! {\n"
"            _ = interval.tick() =&gt; println!(\"tick!\"),\n"
"            line = lines.next() =&gt; if let Some(l) = line? {\n"
"                print!(\"{}\", l)\n"
"            } else {\n"
"                break\n"
"            },\n"
"        }\n"
"    }\n"
"    handle.await.unwrap()?;\n"
"    Ok((())\n"
"}\n"
"```"

#: src/async/pitfalls/cancellation.md:72
#, fuzzy
msgid ""
"The compiler doesn't help with cancellation-safety. You need to read API "
"documentation and consider what state your `async fn` holds."
msgstr ""
"Compilatorul nu v캒 ajut캒 칥n ceea ce prive탳te siguran탵a la anulare. Trebuie "
"s캒 citi탵i documenta탵ia API 탳i s캒 v캒 g칙ndi탵i la starea pe care o de탵ine "
"`async fn`."

#: src/async/pitfalls/cancellation.md:75
#, fuzzy
msgid ""
"Unlike `panic` and `?`, cancellation is part of normal control flow (vs "
"error-handling)."
msgstr ""
"Spre deosebire de `panic` 탳i `?`, anularea face parte din fluxul normal de "
"control (fa탵캒 de gestionarea erorilor)."

#: src/async/pitfalls/cancellation.md:78
#, fuzzy
msgid "The example loses parts of the string."
msgstr "Exemplul pierde p캒r탵i din 탳ir."

#: src/async/pitfalls/cancellation.md:80
#, fuzzy
msgid ""
"Whenever the `tick()` branch finishes first, `next()` and its `buf` are "
"dropped."
msgstr ""
"Ori de c칙te ori ramura `tick()` se termin캒 prima, se renun탵캒 la `next()` 탳i "
"la `buf` al acestuia."

#: src/async/pitfalls/cancellation.md:82
#, fuzzy
msgid ""
"`LinesReader` can be made cancellation-safe by making `buf` part of the "
"struct:"
msgstr ""
"`LinesReader` poate fi securizat 칥mpotriva anul캒rii prin includerea lui "
"`buf` 칥n structur캒:"

#: src/async/pitfalls/cancellation.md:83
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"struct LinesReader {\n"
"    stream: DuplexStream,\n"
"    bytes: Vec<u8>,\n"
"    buf: [u8; 1],\n"
"}\n"
"\n"
"impl LinesReader {\n"
"    fn new(stream: DuplexStream) -> Self {\n"
"        Self { stream, bytes: Vec::new(), buf: [0] }\n"
"    }\n"
"    async fn next(&mut self) -> io::Result<Option<String>> {\n"
"        // prefix buf and bytes with self.\n"
"        // ...\n"
"        let raw = std::mem::take(&mut self.bytes);\n"
"        let s = String::from_utf8(raw)\n"
"        // ...\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,compile_fail\n"
"struct LinesReader {\n"
"    stream: DuplexStream,\n"
"    bytes: Vec<u8>,\n"
"    buf: [u8; 1],\n"
"}\n"
"\n"
"impl LinesReader {\n"
"    fn new(stream: DuplexStream) -&gt; Self {\n"
"        Self { stream, bytes: Vec::new(), buf: [0] }\n"
"    }\n"
"    async fn next(&amp;mut self) -&gt; io::Result&lt;Option<String>&gt; {\n"
"        // prefixeaz캒 buf 탳i bytes cu self.\n"
"        // ...\n"
"        let raw = std::mem::take(&amp;mut self.bytes);\n"
"        let s = String::from_utf8(raw)\n"
"        // ...\n"
"    }\n"
"}\n"
"```"

#: src/async/pitfalls/cancellation.md:104
#, fuzzy
msgid ""
"[`Interval::tick`](https://docs.rs/tokio/latest/tokio/time/struct.Interval."
"html#method.tick) is cancellation-safe because it keeps track of whether a "
"tick has been 'delivered'."
msgstr ""
"[`Interval::tick`](https://docs.rs/tokio/latest/tokio/time/struct.Interval."
"html#method.tick) este sigur 칥n ceea ce prive탳te anularea, deoarece 탵ine "
"eviden탵a dac캒 un tick a fost \"livrat\"."

#: src/async/pitfalls/cancellation.md:107
#, fuzzy
msgid ""
"[`AsyncReadExt::read`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncReadExt.html#method.read) is cancellation-safe because it either "
"returns or doesn't read data."
msgstr ""
"[`AsyncReadExt::read`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncReadExt.html#method.read) este sigur 칥n ceea ce prive탳te anularea, "
"deoarece fie returneaz캒, fie nu cite탳te datele."

#: src/async/pitfalls/cancellation.md:110
#, fuzzy
msgid ""
"[`AsyncBufReadExt::read_line`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncBufReadExt.html#method.read_line) is similar to the example and _isn't_ "
"cancellation-safe. See its documentation for details and alternatives."
msgstr ""
"[`AsyncBufReadExt::read_line`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncBufReadExt.html#method.read_line) este similar cu exemplul 탳i _nu este_ "
"sigur la anulare. Consulta탵i documenta탵ia sa pentru detalii 탳i alternative."

#: src/exercises/concurrency/afternoon.md:3
#, fuzzy
msgid ""
"To practice your Async Rust skills, we have again two exercises for you:"
msgstr ""
"Pentru a v캒 exersa abilit캒탵ile Async Rust, avem din nou dou캒 exerci탵ii "
"pentru dumneavoastr캒:"

#: src/exercises/concurrency/afternoon.md:5
#, fuzzy
msgid ""
"Dining philosophers: we already saw this problem in the morning. This time "
"you are going to implement it with Async Rust."
msgstr ""
"Filozofii din sala de mese: am v캒zut deja aceast캒 problem캒 de diminea탵캒. De "
"data aceasta o ve탵i implementa cu Async Rust."

#: src/exercises/concurrency/afternoon.md:8
#, fuzzy
msgid ""
"A Broadcast Chat Application: this is a larger project that allows you "
"experiment with more advanced Async Rust features."
msgstr ""
"O aplica탵ie de chat cu difuzare: acesta este un proiect mai mare care v캒 "
"permite s캒 experimenta탵i cu caracteristici Async Rust mai avansate."

#: src/exercises/concurrency/dining-philosophers-async.md:1
#: src/exercises/concurrency/solutions-afternoon.md:3
#, fuzzy
msgid "Dining Philosophers - Async"
msgstr "Filozofii care m캒n칙nc캒 - Async"

#: src/exercises/concurrency/dining-philosophers-async.md:3
#, fuzzy
msgid ""
"See [dining philosophers](dining-philosophers.md) for a description of the "
"problem."
msgstr ""
"Vezi [dining philosophers](dining-philosophers.md) pentru o descriere a "
"problemei."

#: src/exercises/concurrency/dining-philosophers-async.md:6
#, fuzzy
msgid ""
"As before, you will need a local [Cargo installation](../../cargo/running-"
"locally.md) for this exercise. Copy the code below to a file called `src/"
"main.rs`, fill out the blanks, and test that `cargo run` does not deadlock:"
msgstr ""
"Ca 탳i 칥nainte, ve탵i avea nevoie de o [instalare Cargo] local캒 (../../cargo/"
"running-locally.md) pentru acest exerci탵iu. Copia탵i codul de mai jos 칥ntr-un "
"fi탳ier numit `src/main.rs`, completa탵i spa탵iile goale 탳i testa탵i dac캒 `cargo "
"run` nu se blocheaz캒:"

#: src/exercises/concurrency/dining-philosophers-async.md:13
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"use std::sync::Arc;\n"
"use tokio::time;\n"
"use tokio::sync::mpsc::{self, Sender};\n"
"use tokio::sync::Mutex;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    // left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
"}\n"
"\n"
"impl Philosopher {\n"
"    async fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))."
"await\n"
"            .unwrap();\n"
"    }\n"
"\n"
"    async fn eat(&self) {\n"
"        // Pick up forks...\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Hypatia\", \"Plato\", \"Aristotle\", \"Pythagoras\"];\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    // Create forks\n"
"\n"
"    // Create philosophers\n"
"\n"
"    // Make them think and eat\n"
"\n"
"    // Output their thoughts\n"
"}\n"
"```"
msgstr ""
"```rust,compile_fail\n"
"folosi탵i std::sync::Arc;\n"
"use tokio::time;\n"
"use tokio::sync::mpsc::{self, Sender};\n"
"use tokio::sync::Mutex;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    // left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
"}\n"
"\n"
"impl Philosopher {\n"
"    async fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} are o idee nou캒!\", &self.name))."
"await\n"
"            .unwrap();\n"
"    }\n"
"\n"
"    async fn eat(&self) {\n"
"        // Preia furculi탵ele...\n"
"        println!(\"{} m캒n칙nc캒...\", &self.name);\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrate\", \"Hypatia\", \"Platon\", \"Aristotel\", \"Pitagora\"];\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    // Creeaz캒 furci\n"
"\n"
"    // Creeaz캒 filozofii\n"
"\n"
"    // F캒-i s캒 g칙ndeasc캒 탳i s캒 m캒n칙nce\n"
"\n"
"    // Scoate-le g칙ndurile\n"
"}\n"
"```"

#: src/exercises/concurrency/dining-philosophers-async.md:57
#, fuzzy
msgid ""
"Since this time you are using Async Rust, you'll need a `tokio` dependency. "
"You can use the following `Cargo.toml`:"
msgstr ""
"Deoarece de data aceasta folosi탵i Async Rust, ve탵i avea nevoie de o "
"dependen탵캒 `tokio`. Pute탵i utiliza urm캒torul `Cargo.toml`:"

#: src/exercises/concurrency/dining-philosophers-async.md:62
#, fuzzy
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers-async-dine\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"tokio = {version = \"1.26.0\", features = [\"sync\", \"time\", \"macros\", "
"\"rt-multi-thread\"]}\n"
"```"
msgstr ""
"```toml\n"
"[pachet]\n"
"name = \"dining-philosophers-async-dine\"\n"
"versiune = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependen탵e]\n"
"tokio = {version = \"1.26.0\", features = [\"sync\", \"time\", \"macros\", "
"\"rt-multi-thread\"]}\n"
"```"

#: src/exercises/concurrency/dining-philosophers-async.md:72
#, fuzzy
msgid ""
"Also note that this time you have to use the `Mutex` and the `mpsc` module "
"from the `tokio` crate."
msgstr ""
"De asemenea, re탵ine탵i c캒 de data aceasta trebuie s캒 folosi탵i modulele "
"`Mutex` 탳i `mpsc` de la `tokio` crate."

#: src/exercises/concurrency/dining-philosophers-async.md:77
#, fuzzy
msgid "Can you make your implementation single-threaded? "
msgstr "Po탵i face ca implementarea ta s캒 fie cu un singur fir de execu탵ie?"

#: src/exercises/concurrency/chat-app.md:3
#, fuzzy
msgid ""
"In this exercise, we want to use our new knowledge to implement a broadcast "
"chat application. We have a chat server that the clients connect to and "
"publish their messages. The client reads user messages from the standard "
"input, and sends them to the server. The chat server broadcasts each message "
"that it receives to all the clients."
msgstr ""
"칉n acest exerci탵iu, dorim s캒 folosim noile noastre cuno탳tin탵e pentru a "
"implementa o aplica탵ie de chat cu difuzare. Avem un server de chat la care "
"clien탵ii se conecteaz캒 탳i 칥탳i public캒 mesajele. Clientul cite탳te mesajele "
"utilizatorilor de la intrarea standard 탳i le trimite la server. Serverul de "
"chat difuzeaz캒 fiecare mesaj pe care 칥l prime탳te c캒tre to탵i clien탵ii."

#: src/exercises/concurrency/chat-app.md:9
#, fuzzy
msgid ""
"For this, we use [a broadcast channel](https://docs.rs/tokio/latest/tokio/"
"sync/broadcast/fn.channel.html) on the server, and [`tokio_websockets`]"
"(https://docs.rs/tokio-websockets/0.4.0/tokio_websockets/) for the "
"communication between the client and the server."
msgstr ""
"Pentru aceasta, folosim [un canal de difuzare](https://docs.rs/tokio/latest/"
"tokio/sync/broadcast/fn.channel.html) pe server 탳i [`tokio_websockets`]"
"(https://docs.rs/tokio-websockets/0.4.0/tokio_websockets/) pentru "
"comunicarea dintre client 탳i server."

#: src/exercises/concurrency/chat-app.md:13
#, fuzzy
msgid "Create a new Cargo project and add the following dependencies:"
msgstr "Crea탵i un nou proiect Cargo 탳i ad캒uga탵i urm캒toarele dependen탵e:"

#: src/exercises/concurrency/chat-app.md:15
#, fuzzy
msgid "_Cargo.toml_:"
msgstr "_Cargo.toml_:"

#: src/exercises/concurrency/chat-app.md:19
#, fuzzy
msgid ""
"```toml\n"
"[package]\n"
"name = \"chat-async\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"futures-util = { version = \"0.3.28\", features = [\"sink\"] }\n"
"http = \"0.2.9\"\n"
"tokio = { version = \"1.28.1\", features = [\"full\"] }\n"
"tokio-websockets = { version = \"0.4.0\", features = [\"client\", "
"\"fastrand\", \"server\", \"sha1_smol\"] }\n"
"```"
msgstr ""
"```toml\n"
"[pachet]\n"
"name = \"chat-async\"\n"
"versiune = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependen탵e]\n"
"futures-util = { version = \"0.3.28\", features = [\"sink\"]] }\n"
"http = \"0.2.9\"\n"
"tokio = { version = \"1.28.1\", features = [\"full\"]] }\n"
"tokio-websockets = { version = \"0.4.0\", features = [\"client\", "
"\"fastrand\", \"server\", \"sha1_smol\"] } }\n"
"```"

#: src/exercises/concurrency/chat-app.md:32
#, fuzzy
msgid "The required APIs"
msgstr "API-urile necesare"

#: src/exercises/concurrency/chat-app.md:33
#, fuzzy
msgid ""
"You are going to need the following functions from `tokio` and "
"[`tokio_websockets`](https://docs.rs/tokio-websockets/0.4.0/"
"tokio_websockets/). Spend a few minutes to familiarize yourself with the "
"API. "
msgstr ""
"Ve탵i avea nevoie de urm캒toarele func탵ii din `tokio` 탳i [`tokio_websockets`]"
"(https://docs.rs/tokio-websockets/0.4.0/tokio_websockets/). Petrece탵i c칙teva "
"minute pentru a v캒 familiariza cu API-ul."

#: src/exercises/concurrency/chat-app.md:37
#, fuzzy
msgid ""
"[StreamExt::next()](https://docs.rs/futures-util/0.3.28/futures_util/stream/"
"trait.StreamExt.html#method.next) implemented by `WebsocketStream`: for "
"asynchronously reading messages from a Websocket Stream."
msgstr ""
"[StreamExt::next()](https://docs.rs/futures-util/0.3.28/futures_util/stream/"
"trait.StreamExt.html#method.next) implementat de `WebsocketStream`: pentru "
"citirea asincron캒 a mesajelor dintr-un flux Websocket."

#: src/exercises/concurrency/chat-app.md:39
#, fuzzy
msgid ""
"[SinkExt::send()](https://docs.rs/futures-util/0.3.28/futures_util/sink/"
"trait.SinkExt.html#method.send) implemented by `WebsocketStream`: for "
"asynchronously sending messages on a Websocket Stream."
msgstr ""
"[SinkExt::send()](https://docs.rs/futures-util/0.3.28/futures_util/sink/"
"trait.SinkExt.html#method.send) implementat de `WebsocketStream`: pentru "
"trimiterea asincron캒 de mesaje pe un flux Websocket."

#: src/exercises/concurrency/chat-app.md:41
#, fuzzy
msgid ""
"[Lines::next_line()](https://docs.rs/tokio/latest/tokio/io/struct.Lines."
"html#method.next_line): for asynchronously reading user messages from the "
"standard input."
msgstr ""
"[Lines::next_line()](https://docs.rs/tokio/latest/tokio/io/struct.Lines."
"html#method.next_line): pentru citirea asincron캒 a mesajelor utilizatorului "
"de la intrarea standard."

#: src/exercises/concurrency/chat-app.md:43
#, fuzzy
msgid ""
"[Sender::subscribe()](https://docs.rs/tokio/latest/tokio/sync/broadcast/"
"struct.Sender.html#method.subscribe): for subscribing to a broadcast channel."
msgstr ""
"[Sender::subscribe()](https://docs.rs/tokio/latest/tokio/sync/broadcast/"
"struct.Sender.html#method.subscribe): pentru abonarea la un canal de "
"difuzare."

#: src/exercises/concurrency/chat-app.md:46
#, fuzzy
msgid "Two binaries"
msgstr "Dou캒 binare"

#: src/exercises/concurrency/chat-app.md:48
#, fuzzy
msgid ""
"Normally in a Cargo project, you can have only one binary, and one `src/main."
"rs` file. In this project, we need two binaries. One for the client, and one "
"for the server. You could potentially make them two separate Cargo projects, "
"but we are going to put them in a single Cargo project with two binaries. "
"For this to work, the client and the server code should go under `src/bin` "
"(see the [documentation](https://doc.rust-lang.org/cargo/reference/cargo-"
"targets.html#binaries)). "
msgstr ""
"칉n mod normal, 칥ntr-un proiect Cargo, pute탵i avea un singur fi탳ier binar 탳i "
"un singur fi탳ier `src/main.rs`. 칉n acest proiect, avem nevoie de dou캒 "
"fi탳iere binare. Unul pentru client 탳i unul pentru server. A탵i putea eventual "
"s캒 le face탵i dou캒 proiecte Cargo separate, dar noi le vom pune 칥ntr-un "
"singur proiect Cargo cu dou캒 binare. Pentru ca acest lucru s캒 func탵ioneze, "
"codul clientului 탳i cel al serverului trebuie s캒 se reg캒seasc캒 칥n `src/bin` "
"(a se vedea [documentation](https://doc.rust-lang.org/cargo/reference/cargo-"
"targets.html#binaries))."

#: src/exercises/concurrency/chat-app.md:55
#, fuzzy
msgid ""
"Copy the following server and client code into `src/bin/server.rs` and `src/"
"bin/client.rs`, respectively. Your task is to complete these files as "
"described below. "
msgstr ""
"Copia탵i urm캒torul cod server 탳i client 칥n `src/bin/server.rs` 탳i, respectiv, "
"`src/bin/client.rs`. Sarcina dumneavoastr캒 este de a completa aceste fi탳iere "
"a탳a cum este descris mai jos."

#: src/exercises/concurrency/chat-app.md:59
#: src/exercises/concurrency/solutions-afternoon.md:99
#, fuzzy
msgid "_src/bin/server.rs_:"
msgstr "src/bin/server.rs_:"

#: src/exercises/concurrency/chat-app.md:63
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"use futures_util::sink::SinkExt;\n"
"use futures_util::stream::StreamExt;\n"
"use std::error::Error;\n"
"use std::net::SocketAddr;\n"
"use tokio::net::{TcpListener, TcpStream};\n"
"use tokio::sync::broadcast::{channel, Sender};\n"
"use tokio_websockets::{Message, ServerBuilder, WebsocketStream};\n"
"\n"
"async fn handle_connection(\n"
"    addr: SocketAddr,\n"
"    mut ws_stream: WebsocketStream<TcpStream>,\n"
"    bcast_tx: Sender<String>,\n"
") -> Result<(), Box<dyn Error + Send + Sync>> {\n"
"\n"
"    // TODO: For a hint, see the description of the task below.\n"
"\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> Result<(), Box<dyn Error + Send + Sync>> {\n"
"    let (bcast_tx, _) = channel(16);\n"
"\n"
"    let listener = TcpListener::bind(\"127.0.0.1:2000\").await?;\n"
"    println!(\"listening on port 2000\");\n"
"\n"
"    loop {\n"
"        let (socket, addr) = listener.accept().await?;\n"
"        println!(\"New connection from {addr:?}\");\n"
"        let bcast_tx = bcast_tx.clone();\n"
"        tokio::spawn(async move {\n"
"            // Wrap the raw TCP stream into a websocket.\n"
"            let ws_stream = ServerBuilder::new().accept(socket).await?;\n"
"\n"
"            handle_connection(addr, ws_stream, bcast_tx).await\n"
"        });\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,compile_fail\n"
"use futures_util::sink::SinkExt;\n"
"use futures_util::stream::StreamExt;\n"
"use std::error::Error;\n"
"use std::net::SocketAddr;\n"
"use tokio::net::{TcpListener, TcpStream};\n"
"use tokio::sync::broadcast::{channel, Sender};\n"
"use tokio_websockets::{Message, ServerBuilder, WebsocketStream};\n"
"\n"
"async fn handle_connection(\n"
"    addr: SocketAddr,\n"
"    mut ws_stream: WebsocketStream<TcpStream>,\n"
"    bcast_tx: Sender<String>,\n"
") -&gt; Result&lt;(), Box<dyn Error + Send + Sync>&gt; {\n"
"\n"
"    // TODO: Pentru un indiciu, consulta탵i descrierea sarcinii de mai jos.\n"
"\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() -&gt; Result&lt;(), Box<dyn Error + Send + Sync>&gt; {\n"
"    let (bcast_tx, _) = channel(16);\n"
"\n"
"    let listener = TcpListener::bind(\"127.0.0.1:2000\").await?;\n"
"    println!(\"ascult칙nd pe portul 2000\");\n"
"\n"
"    loop {\n"
"        let (socket, addr) = listener.accept().await?;\n"
"        println!(\"Conexiune nou캒 de la {addr:?}\");\n"
"        let bcast_tx = bcast_tx.clone();\n"
"        tokio::spawn(async move {\n"
"            // 칉nf캒탳ura탵i fluxul TCP brut 칥ntr-un websocket.\n"
"            let ws_stream = ServerBuilder::new().accept(socket).await?;\n"
"\n"
"            handle_connection(addr, ws_stream, bcast_tx).await\n"
"        });\n"
"    }\n"
"}\n"
"```"

#: src/exercises/concurrency/chat-app.md:103
#: src/exercises/concurrency/solutions-afternoon.md:166
#, fuzzy
msgid "_src/bin/client.rs_:"
msgstr "src/bin/client.rs_:"

#: src/exercises/concurrency/chat-app.md:107
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"use futures_util::stream::StreamExt;\n"
"use futures_util::SinkExt;\n"
"use http::Uri;\n"
"use tokio::io::{AsyncBufReadExt, BufReader};\n"
"use tokio_websockets::{ClientBuilder, Message};\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> Result<(), tokio_websockets::Error> {\n"
"    let (mut ws_stream, _) =\n"
"        ClientBuilder::from_uri(Uri::from_static(\"ws://127.0.0.1:2000\"))\n"
"            .connect()\n"
"            .await?;\n"
"\n"
"    let stdin = tokio::io::stdin();\n"
"    let mut stdin = BufReader::new(stdin).lines();\n"
"\n"
"\n"
"    // TODO: For a hint, see the description of the task below.\n"
"\n"
"}\n"
"```"
msgstr ""
"```rust,compile_fail\n"
"use futures_util::stream::StreamExt;\n"
"use futures_util::SinkExt;\n"
"use http::Uri;\n"
"use tokio::io::{AsyncBufReadExt, BufReader};\n"
"use tokio_websockets::{ClientBuilder, Message};\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> Result<(), tokio_websockets::Error> {\n"
"    let (mut ws_stream, _) =\n"
"        ClientBuilder::from_uri(Uri::from_static(\"ws://127.0.0.1:2000\")))\n"
"            .connect()\n"
"            .await?;\n"
"\n"
"    let stdin = tokio::io::stdin();\n"
"    let mut stdin = BufReader::new(stdin).lines();\n"
"\n"
"\n"
"    // TODO: Pentru un indiciu, consulta탵i descrierea sarcinii de mai jos.\n"
"\n"
"}\n"
"```"

#: src/exercises/concurrency/chat-app.md:130
#, fuzzy
msgid "Running the binaries"
msgstr "Rularea fi탳ierelor binare"

#: src/exercises/concurrency/chat-app.md:131
#, fuzzy
msgid "Run the server with:"
msgstr "Rula탵i serverul cu:"

#: src/exercises/concurrency/chat-app.md:137
#, fuzzy
msgid "and the client with:"
msgstr "탳i clientul cu:"

#: src/exercises/concurrency/chat-app.md:145
#, fuzzy
msgid "Implement the `handle_connection` function in `src/bin/server.rs`."
msgstr "Implementa탵i func탵ia `handle_connection` 칥n `src/bin/server.rs`."

#: src/exercises/concurrency/chat-app.md:146
#, fuzzy
msgid ""
"Hint: Use `tokio::select!` for concurrently performing two tasks in a "
"continuous loop. One task receives messages from the client and broadcasts "
"them. The other sends messages received by the server to the client."
msgstr ""
"Indica탵ie: Folosi탵i `tokio::select!` pentru a efectua concomitent dou캒 "
"sarcini 칥ntr-o bucl캒 continu캒. O sarcin캒 prime탳te mesaje de la client 탳i le "
"difuzeaz캒. Cealalt캒 trimite mesajele primite de server c캒tre client."

#: src/exercises/concurrency/chat-app.md:149
#, fuzzy
msgid "Complete the main function in `src/bin/client.rs`."
msgstr "Completa탵i func탵ia principal캒 din `src/bin/client.rs`."

#: src/exercises/concurrency/chat-app.md:150
#, fuzzy
msgid ""
"Hint: As before, use `tokio::select!` in a continuous loop for concurrently "
"performing two tasks: (1) reading user messages from standard input and "
"sending them to the server, and (2) receiving messages from the server, and "
"displaying them for the user."
msgstr ""
"Sugestie: Ca 탳i 칥nainte, utiliza탵i `tokio::select!` 칥ntr-o bucl캒 continu캒 "
"pentru a efectua concomitent dou캒 sarcini: (1) citirea mesajelor "
"utilizatorului de la intrarea standard 탳i trimiterea lor la server 탳i (2) "
"primirea mesajelor de la server 탳i afi탳area lor pentru utilizator."

#: src/exercises/concurrency/chat-app.md:154
#, fuzzy
msgid ""
"Optional: Once you are done, change the code to broadcast messages to all "
"clients, but the sender of the message."
msgstr ""
"Op탵ional: Dup캒 ce a탵i terminat, modifica탵i codul pentru a difuza mesajele "
"c캒tre to탵i clien탵ii, cu excep탵ia expeditorului mesajului."

#: src/thanks.md:3
#, fuzzy
msgid ""
"_Thank you for taking Comprehensive Rust 游!_ We hope you enjoyed it and "
"that it was useful."
msgstr ""
"v캒 mul탵umim c캒 a탵i luat Comprehensive Rust 游!_ Sper캒m c캒 v-a pl캒cut 탳i c캒 a "
"fost util."

#: src/thanks.md:6
#, fuzzy
msgid ""
"We've had a lot of fun putting the course together. The course is not "
"perfect, so if you spotted any mistakes or have ideas for improvements, "
"please get in [contact with us on GitHub](https://github.com/google/"
"comprehensive-rust/discussions). We would love to hear from you."
msgstr ""
"Ne-am distrat foarte mult la amenajarea traseului. Cursul nu este perfect, "
"a탳a c캒, dac캒 a탵i observat gre탳eli sau ave탵i idei de 칥mbun캒t캒탵ire, v캒 rug캒m "
"s캒 intra탵i 칥n [contacta탵i-ne pe GitHub](https://github.com/google/"
"comprehensive-rust/discussions). Ne-ar face pl캒cere s캒 avem ve탳ti de la voi."

#: src/glossary.md:3
#, fuzzy
msgid ""
"The following is a glossary which aims to give a short definition of many "
"Rust terms. For translations, this also serves to connect the term back to "
"the English original."
msgstr ""
"Urm캒torul glosar este un glosar care 칥탳i propune s캒 ofere o scurt캒 defini탵ie "
"a numero탳i termeni Rust. 칉n cazul traducerilor, acesta serve탳te, de "
"asemenea, pentru a face leg캒tura 칥ntre termenul respectiv 탳i originalul 칥n "
"limba englez캒."

#: src/glossary.md:30
#, fuzzy
msgid ""
"allocate:  \n"
"Dynamic memory allocation on [the heap](memory-management/stack-vs-heap.md)."
msgstr ""
"s캒 aloce:  \n"
"Alocarea dinamic캒 a memoriei pe [heap](memory-management/stack-vs-heap.md)."

#: src/glossary.md:32
#, fuzzy
msgid "argument:"
msgstr "argument:"

#: src/glossary.md:33
#, fuzzy
msgid ""
"Bare-metal Rust:  \n"
"Low-level Rust development, often deployed to a system without an operating "
"system. See [Bare-metal Rust](bare-metal.md)."
msgstr ""
"Rust de metal gol:\n"
"Dezvoltare Rust de nivel sc캒zut, adesea implementat캒 pe un sistem f캒r캒 "
"sistem de operare. A se vedea [Bare-metal Rust](bare-metal.md)."

#: src/glossary.md:36
#, fuzzy
msgid ""
"block:  \n"
"See [Blocks](control-flow/blocks.md) and _scope_."
msgstr ""
"bloc:\n"
"A se vedea [Blocuri](control-flow/blocks.md) 탳i _scope_."

#: src/glossary.md:38
#, fuzzy
msgid ""
"borrow:  \n"
"See [Borrowing](ownership/borrowing.md)."
msgstr ""
"칥mprumut:\n"
"A se vedea [칉mprumut](ownership/borrowing.md)."

#: src/glossary.md:40
#, fuzzy
msgid ""
"borrow checker:  \n"
"The part of the Rust compiler which checks that all borrows are valid."
msgstr ""
"verificator de 칥mprumuturi:\n"
"Partea din compilatorul Rust care verific캒 dac캒 toate 칥mprumuturile sunt "
"valide."

#: src/glossary.md:42
#, fuzzy
msgid ""
"brace:  \n"
"`{` and `}`. Also called _curly brace_, they delimit _blocks_."
msgstr ""
"bretele:\n"
"`{` 탳i `}`. Numite 탳i _curly brace_, ele delimiteaz캒 _blocuri_."

#: src/glossary.md:44
#, fuzzy
msgid "build:"
msgstr "construi:"

#: src/glossary.md:45
#, fuzzy
msgid "call:"
msgstr "apel:"

#: src/glossary.md:46
#, fuzzy
msgid ""
"channel:  \n"
"Used to safely pass messages [between threads](concurrency/channels.md)."
msgstr ""
"canal:  \n"
"Folosit pentru a transmite 칥n siguran탵캒 mesaje [칥ntre fire] (concurrency/"
"channels.md)."

#: src/glossary.md:48
#, fuzzy
msgid ""
"Comprehensive Rust 游:  \n"
"The courses here are jointly called Comprehensive Rust 游."
msgstr ""
"Rugin캒 cuprinz캒toare 游:\n"
"Cursurile de aici se numesc 칥n comun Comprehensive Rust 游."

#: src/glossary.md:50
#, fuzzy
msgid "concurrency:"
msgstr "concuren탵a:"

#: src/glossary.md:51
#, fuzzy
msgid ""
"Concurrency in Rust:  \n"
"See [Concurrency in Rust](concurrency.md)."
msgstr ""
"Concurrency 칥n Rust:\n"
"A se vedea [Concurrency in Rust](concurrency.md)."

#: src/glossary.md:53
#, fuzzy
msgid "constant:"
msgstr "constant캒:"

#: src/glossary.md:54
#, fuzzy
msgid "control flow:"
msgstr "fluxul de control:"

#: src/glossary.md:55
#, fuzzy
msgid "crash:"
msgstr "accident:"

#: src/glossary.md:56
#, fuzzy
msgid "enumeration:"
msgstr "enumerare:"

#: src/glossary.md:57
#, fuzzy
msgid "error:"
msgstr "eroare:"

#: src/glossary.md:58
#, fuzzy
msgid "error handling:"
msgstr "gestionarea erorilor:"

#: src/glossary.md:59
#, fuzzy
msgid "exercise:"
msgstr "exerci탵iu:"

#: src/glossary.md:60
#, fuzzy
msgid "function:"
msgstr "func탵ie:"

#: src/glossary.md:61
#, fuzzy
msgid "garbage collector:"
msgstr "colector de gunoi:"

#: src/glossary.md:62
#, fuzzy
msgid "generics:"
msgstr "generice:"

#: src/glossary.md:63
#, fuzzy
msgid "immutable:"
msgstr "imuabile:"

#: src/glossary.md:64
#, fuzzy
msgid "integration test:"
msgstr "testul de integrare:"

#: src/glossary.md:65
msgid "keyword:"
msgstr "cuvinte cheie:"

#: src/glossary.md:66
#, fuzzy
msgid "library:"
msgstr "bibliotec캒:"

#: src/glossary.md:67
#, fuzzy
msgid "macro:"
msgstr "macro:"

#: src/glossary.md:68
#, fuzzy
msgid "main function:"
msgstr "func탵ia principal캒:"

#: src/glossary.md:69
#, fuzzy
msgid "match:"
msgstr "meci:"

#: src/glossary.md:70
#, fuzzy
msgid "memory leak:"
msgstr "scurgere de memorie:"

#: src/glossary.md:71
#, fuzzy
msgid "method:"
msgstr "metoda:"

#: src/glossary.md:72
#, fuzzy
msgid "module:"
msgstr "modul:"

#: src/glossary.md:73
#, fuzzy
msgid "move:"
msgstr "mi탳c캒:"

#: src/glossary.md:74
#, fuzzy
msgid "mutable:"
msgstr "mutabil:"

#: src/glossary.md:75
#, fuzzy
msgid "ownership:"
msgstr "proprietate:"

#: src/glossary.md:76
#, fuzzy
msgid "panic:"
msgstr "panic캒:"

#: src/glossary.md:77
#, fuzzy
msgid "parameter:"
msgstr "parametru:"

#: src/glossary.md:78
#, fuzzy
msgid "pattern:"
msgstr "model:"

#: src/glossary.md:79
#, fuzzy
msgid "payload:"
msgstr "sarcina util캒:"

#: src/glossary.md:80
#, fuzzy
msgid "program:"
msgstr "program:"

#: src/glossary.md:81
#, fuzzy
msgid "programming language:"
msgstr "limbaj de programare:"

#: src/glossary.md:82
#, fuzzy
msgid "receiver:"
msgstr "receptor:"

#: src/glossary.md:83
#, fuzzy
msgid "reference counting:"
msgstr "num캒rarea de referin탵캒:"

#: src/glossary.md:84
#, fuzzy
msgid "return:"
msgstr "retur:"

#: src/glossary.md:85
#, fuzzy
msgid "Rust:"
msgstr "Bine a탵i venit la Comprehensive Rust 游 (ghidul complet pentu Rust)"

#: src/glossary.md:86
#, fuzzy
msgid ""
"Rust Fundamentals:  \n"
"Days 1 to 3 of this course."
msgstr ""
"No탵iuni fundamentale de rugin캒:\n"
"Zilele 1 - 3 ale acestui curs."

#: src/glossary.md:88
#, fuzzy
msgid ""
"Rust in Android:  \n"
"See [Rust in Android](android.md)."
msgstr ""
"Rust 칥n Android:\n"
"A se vedea [Rust in Android](android.md)."

#: src/glossary.md:90
#, fuzzy
msgid "safe:"
msgstr "sigur:"

#: src/glossary.md:91
#, fuzzy
msgid "scope:"
msgstr "domeniul de aplicare:"

#: src/glossary.md:92
#, fuzzy
msgid "standard library:"
msgstr "biblioteca standard:"

#: src/glossary.md:93
#, fuzzy
msgid "static:"
msgstr "static:"

#: src/glossary.md:94
#, fuzzy
msgid "string:"
msgstr "탳ir:"

#: src/glossary.md:95
#, fuzzy
msgid "struct:"
msgstr "struct:"

#: src/glossary.md:96
#, fuzzy
msgid "test:"
msgstr "test:"

#: src/glossary.md:97
#, fuzzy
msgid "thread:"
msgstr "firul:"

#: src/glossary.md:98
#, fuzzy
msgid "thread safety:"
msgstr "siguran탵a filetului:"

#: src/glossary.md:99
#, fuzzy
msgid "trait:"
msgstr "tr캒s캒tur캒:"

#: src/glossary.md:100
#, fuzzy
msgid "type:"
msgstr "tip:"

#: src/glossary.md:101
#, fuzzy
msgid "type inference:"
msgstr "inferen탵a de tip:"

#: src/glossary.md:102
#, fuzzy
msgid "undefined behavior:"
msgstr "comportament nedefinit:"

#: src/glossary.md:103
#, fuzzy
msgid "union:"
msgstr "uniunii:"

#: src/glossary.md:104
#, fuzzy
msgid "unit test:"
msgstr "test unitar:"

#: src/glossary.md:105
#, fuzzy
msgid "unsafe:"
msgstr "nesigur캒:"

#: src/glossary.md:106
#, fuzzy
msgid "variable:\\"
msgstr "variabil캒:\\"

#: src/other-resources.md:1
#, fuzzy
msgid "Other Rust Resources"
msgstr "Alte resurse privind rugina"

#: src/other-resources.md:3
#, fuzzy
msgid ""
"The Rust community has created a wealth of high-quality and free resources "
"online."
msgstr ""
"Comunitatea Rust a creat o multitudine de resurse online gratuite 탳i de "
"칥nalt캒 calitate."

#: src/other-resources.md:6
msgid "Official Documentation"
msgstr "Documenta탵ie oficial캒"

#: src/other-resources.md:8
#, fuzzy
msgid "The Rust project hosts many resources. These cover Rust in general:"
msgstr ""
"Proiectul Rust g캒zduie탳te multe resurse. Acestea se refer캒 la Rust 칥n "
"general:"

#: src/other-resources.md:10
#, fuzzy
msgid ""
"[The Rust Programming Language](https://doc.rust-lang.org/book/): the "
"canonical free book about Rust. Covers the language in detail and includes a "
"few projects for people to build."
msgstr ""
"[Limbajul de programare Rust](https://doc.rust-lang.org/book/): cartea "
"canonic캒 gratuit캒 despre Rust. Acoper캒 limbajul 칥n detaliu 탳i include c칙teva "
"proiecte pe care oamenii le pot construi."

#: src/other-resources.md:13
#, fuzzy
msgid ""
"[Rust By Example](https://doc.rust-lang.org/rust-by-example/): covers the "
"Rust syntax via a series of examples which showcase different constructs. "
"Sometimes includes small exercises where you are asked to expand on the code "
"in the examples."
msgstr ""
"[Rust By Example](https://doc.rust-lang.org/rust-by-example/): acoper캒 "
"sintaxa Rust prin intermediul unei serii de exemple care prezint캒 diferite "
"construc탵ii. Uneori include mici exerci탵ii 칥n care vi se cere s캒 dezvolta탵i "
"codul din exemple."

#: src/other-resources.md:17
#, fuzzy
msgid ""
"[Rust Standard Library](https://doc.rust-lang.org/std/): full documentation "
"of the standard library for Rust."
msgstr ""
"[Rust Standard Library](https://doc.rust-lang.org/std/): documenta탵ia "
"complet캒 a bibliotecii standard pentru Rust."

#: src/other-resources.md:19
#, fuzzy
msgid ""
"[The Rust Reference](https://doc.rust-lang.org/reference/): an incomplete "
"book which describes the Rust grammar and memory model."
msgstr ""
"[The Rust Reference](https://doc.rust-lang.org/reference/): o carte "
"incomplet캒 care descrie gramatica 탳i modelul de memorie Rust."

#: src/other-resources.md:22
#, fuzzy
msgid "More specialized guides hosted on the official Rust site:"
msgstr "Ghiduri mai specializate g캒zduite pe site-ul oficial Rust:"

#: src/other-resources.md:24
#, fuzzy
msgid ""
"[The Rustonomicon](https://doc.rust-lang.org/nomicon/): covers unsafe Rust, "
"including working with raw pointers and interfacing with other languages "
"(FFI)."
msgstr ""
"[The Rustonomicon](https://doc.rust-lang.org/nomicon/): acoper캒 Rustul "
"nesigur, inclusiv lucrul cu pointeri brute 탳i interfa탵a cu alte limbaje "
"(FFI)."

#: src/other-resources.md:27
#, fuzzy
msgid ""
"[Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/): "
"covers the new asynchronous programming model which was introduced after the "
"Rust Book was written."
msgstr ""
"[Programare asincron캒 칥n Rust](https://rust-lang.github.io/async-book/): "
"acoper캒 noul model de programare asincron캒 care a fost introdus dup캒 ce a "
"fost scris캒 cartea Rust."

#: src/other-resources.md:30
#, fuzzy
msgid ""
"[The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): "
"an introduction to using Rust on embedded devices without an operating "
"system."
msgstr ""
"[The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): o "
"introducere 칥n utilizarea Rust pe dispozitive 칥ncorporate f캒r캒 sistem de "
"operare."

#: src/other-resources.md:33
#, fuzzy
msgid "Unofficial Learning Material"
msgstr "Material didactic neoficial"

#: src/other-resources.md:35
#, fuzzy
msgid "A small selection of other guides and tutorial for Rust:"
msgstr "O mic캒 selec탵ie de alte ghiduri 탳i tutoriale pentru Rust:"

#: src/other-resources.md:37
#, fuzzy
msgid ""
"[Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): covers Rust "
"from the perspective of low-level C programmers."
msgstr ""
"[Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): acoper캒 "
"Rust din perspectiva programatorilor C de nivel inferior."

#: src/other-resources.md:39
#, fuzzy
msgid ""
"[Rust for Embedded C Programmers](https://docs.opentitan.org/doc/ug/"
"rust_for_c/): covers Rust from the perspective of developers who write "
"firmware in C."
msgstr ""
"[Rust for Embedded C Programmers](https://docs.opentitan.org/doc/ug/"
"rust_for_c/): acoper캒 Rust din perspectiva dezvoltatorilor care scriu "
"firmware 칥n C."

#: src/other-resources.md:42
#, fuzzy
msgid ""
"[Rust for professionals](https://overexact.com/rust-for-professionals/): "
"covers the syntax of Rust using side-by-side comparisons with other "
"languages such as C, C++, Java, JavaScript, and Python."
msgstr ""
"[Rust pentru profesioni탳ti](https://overexact.com/rust-for-professionals/): "
"acoper캒 sintaxa Rust folosind compara탵ii cu alte limbaje precum C, C++, "
"Java, JavaScript 탳i Python."

#: src/other-resources.md:45
#, fuzzy
msgid ""
"[Rust on Exercism](https://exercism.org/tracks/rust): 100+ exercises to help "
"you learn Rust."
msgstr ""
"[Rust on Exercism](https://exercism.org/tracks/rust): 100+ exerci탵ii pentru "
"a v캒 ajuta s캒 칥nv캒탵a탵i Rust."

#: src/other-resources.md:47
#, fuzzy
msgid ""
"[Ferrous Teaching Material](https://ferrous-systems.github.io/teaching-"
"material/index.html): a series of small presentations covering both basic "
"and advanced part of the Rust language. Other topics such as WebAssembly, "
"and async/await are also covered."
msgstr ""
"[Ferrous Teaching Material](https://ferrous-systems.github.io/teaching-"
"material/index.html): o serie de mici prezent캒ri care acoper캒 at칙t partea de "
"baz캒, c칙t 탳i cea avansat캒 a limbajului Rust. Sunt abordate 탳i alte subiecte, "
"cum ar fi WebAssembly 탳i async/await."

#: src/other-resources.md:52
#, fuzzy
msgid ""
"[Beginner's Series to Rust](https://docs.microsoft.com/en-us/shows/beginners-"
"series-to-rust/) and [Take your first steps with Rust](https://docs."
"microsoft.com/en-us/learn/paths/rust-first-steps/): two Rust guides aimed at "
"new developers. The first is a set of 35 videos and the second is a set of "
"11 modules which covers Rust syntax and basic constructs."
msgstr ""
"[Beginner's Series to Rust] (https://docs.microsoft.com/en-us/shows/"
"beginners-series-to-rust/) 탳i [Take your first steps with Rust] (https://"
"docs.microsoft.com/en-us/learn/paths/rust-first-steps/): dou캒 ghiduri Rust "
"destinate noilor dezvoltatori. Primul este un set de 35 de videoclipuri, iar "
"al doilea este un set de 11 module care acoper캒 sintaxa Rust 탳i "
"construc탵iile de baz캒."

#: src/other-resources.md:58
#, fuzzy
msgid ""
"[Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial."
"github.io/too-many-lists/): in-depth exploration of Rust's memory management "
"rules, through implementing a few different types of list structures."
msgstr ""
"[Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial."
"github.io/too-many-lists/): explorarea 칥n profunzime a regulilor de "
"gestionare a memoriei din Rust, prin implementarea c칙torva tipuri diferite "
"de structuri de liste."

#: src/other-resources.md:63
#, fuzzy
msgid ""
"Please see the [Little Book of Rust Books](https://lborb.github.io/book/) "
"for even more Rust books."
msgstr ""
"V캒 rug캒m s캒 consulta탵i [Little Book of Rust Books](https://lborb.github.io/"
"book/) pentru 탳i mai multe c캒r탵i Rust."

#: src/credits.md:3
#, fuzzy
msgid ""
"The material here builds on top of the many great sources of Rust "
"documentation. See the page on [other resources](other-resources.md) for a "
"full list of useful resources."
msgstr ""
"Materialul de aici se bazeaz캒 pe numeroasele surse excelente de documenta탵ie "
"Rust. Consulta탵i pagina privind [alte resurse](other-resources.md) pentru o "
"list캒 complet캒 de resurse utile."

#: src/credits.md:7
#, fuzzy
msgid ""
"The material of Comprehensive Rust is licensed under the terms of the Apache "
"2.0 license, please see [`LICENSE`](https://github.com/google/comprehensive-"
"rust/blob/main/LICENSE) for details."
msgstr ""
"Materialul din Comprehensive Rust este licen탵iat 칥n conformitate cu termenii "
"licen탵ei Apache 2.0, v캒 rug캒m s캒 consulta탵i [`LICENSE`](https://github.com/"
"google/comprehensive-rust/blob/main/LICENSE) pentru detalii."

#: src/credits.md:12
#, fuzzy
msgid "Rust by Example"
msgstr "Rugin캒 prin exemplu"

#: src/credits.md:14
#, fuzzy
msgid ""
"Some examples and exercises have been copied and adapted from [Rust by "
"Example](https://doc.rust-lang.org/rust-by-example/). Please see the "
"`third_party/rust-by-example/` directory for details, including the license "
"terms."
msgstr ""
"Unele exemple 탳i exerci탵ii au fost copiate 탳i adaptate din [Rust by Example]"
"(https://doc.rust-lang.org/rust-by-example/). V캒 rug캒m s캒 consulta탵i "
"directorul `third_party/rust-by-example/` pentru detalii, inclusiv termenii "
"licen탵ei."

#: src/credits.md:19
#, fuzzy
msgid "Rust on Exercism"
msgstr "Rugin캒 pe Exerci탵iu"

#: src/credits.md:21
#, fuzzy
msgid ""
"Some exercises have been copied and adapted from [Rust on Exercism](https://"
"exercism.org/tracks/rust). Please see the `third_party/rust-on-exercism/` "
"directory for details, including the license terms."
msgstr ""
"Unele exerci탵ii au fost copiate 탳i adaptate din [Rust on Exercism](https://"
"exercism.org/tracks/rust). V캒 rug캒m s캒 consulta탵i directorul `third_party/"
"rust-on-exercism/` pentru detalii, inclusiv termenii licen탵ei."

#: src/credits.md:26
#, fuzzy
msgid "CXX"
msgstr "CXX"

#: src/credits.md:28
#, fuzzy
msgid ""
"The [Interoperability with C++](android/interoperability/cpp.md) section "
"uses an image from [CXX](https://cxx.rs/). Please see the `third_party/cxx/` "
"directory for details, including the license terms."
msgstr ""
"Sec탵iunea [Interoperabilitate cu C++](android/interoperabilitate/cpp.md) "
"utilizeaz캒 o imagine din [CXX](https://cxx.rs/). V캒 rug캒m s캒 consulta탵i "
"directorul `third_party/cxx/` pentru detalii, inclusiv termenii licen탵ei."

#: src/credits.md:34
#, fuzzy
msgid ""
"The [Why Rust? - An Example in C](why-rust/an-example-in-c.md) section has "
"been taken from the presentation slides of [Colin Finck's Master Thesis]"
"(https://colinfinck.de/Master_Thesis_Colin_Finck.pdf). It has been "
"relicensed under the terms of the Apache 2.0 license for this course by the "
"author."
msgstr ""
"Sec탵iunea [De ce Rust? - Un exemplu 칥n C](why-rust/an-example-in-c.md) a "
"fost preluat캒 din slide-urile de prezentare ale [Tezei de masterat a lui "
"Colin Finck](https://colinfinck.de/Master_Thesis_Colin_Finck.pdf). Ea a fost "
"relicen탵iata de c캒tre autor 칥n conformitate cu termenii licen탵ei Apache 2.0 "
"pentru acest curs."

#: src/exercises/solutions.md:3
#, fuzzy
msgid "You will find solutions to the exercises on the following pages."
msgstr "Ve탵i g캒si solu탵iile la exerci탵iile de pe paginile urm캒toare."

#: src/exercises/solutions.md:5
#, fuzzy
msgid ""
"Feel free to ask questions about the solutions [on GitHub](https://github."
"com/google/comprehensive-rust/discussions). Let us know if you have a "
"different or better solution than what is presented here."
msgstr ""
"Nu ezita탵i s캒 pune탵i 칥ntreb캒ri despre solu탵ii [pe GitHub](https://github.com/"
"google/comprehensive-rust/discussions). Anun탵a탵i-ne dac캒 ave탵i o solu탵ie "
"diferit캒 sau mai bun캒 dec칙t cea prezentat캒 aici."

#: src/exercises/day-1/solutions-morning.md:1
#, fuzzy
msgid "Day 1 Morning Exercises"
msgstr "Ziua 1 Exerci탵ii de diminea탵캒"

#: src/exercises/day-1/solutions-morning.md:5
#, fuzzy
msgid "([back to exercise](for-loops.md))"
msgstr "([칥napoi la exerci탵iu](for-loops.md))"

#: src/exercises/day-1/solutions-morning.md:7
#, fuzzy
msgid ""
"```rust\n"
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    let mut result = [[0; 3]; 3];\n"
"    for i in 0..3 {\n"
"        for j in 0..3 {\n"
"            result[j][i] = matrix[i][j];\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n"
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    for row in matrix {\n"
"        println!(\"{row:?}\");\n"
"    }\n"
"}\n"
"\n"
"#[test]\n"
"fn test_transpose() {\n"
"    let matrix = [\n"
"        [101, 102, 103], //\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"    let transposed = transpose(matrix);\n"
"    assert_eq!(\n"
"        transposed,\n"
"        [\n"
"            [101, 201, 301], //\n"
"            [102, 202, 302],\n"
"            [103, 203, 303],\n"
"        ]\n"
"    );\n"
"}\n"
"\n"
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"\n"
"    println!(\"matrix:\");\n"
"    pretty_print(&matrix);\n"
"\n"
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    let mut result = [[0; 3]; 3];\n"
"    for i in 0..3 {\n"
"        for j in 0..3 {\n"
"            result[j][i] = matrix[i][j];\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n"
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    for row in matrix {\n"
"        println!(\"{row:?}\");\n"
"    }\n"
"}\n"
"\n"
"#[test]\n"
"fn test_transpose() {\n"
"    let matrix = [\n"
"        [101, 102, 103], //\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"    let transposed = transpose(matrix);\n"
"    assert_eq!(\n"
"        transposed,\n"
"        [\n"
"            [101, 201, 301], //\n"
"            [102, 202, 302],\n"
"            [103, 203, 303],\n"
"        ]\n"
"    );\n"
"}\n"
"\n"
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- comentariul face ca rustfmt s캒 adauge o "
"linie nou캒\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"\n"
"    println!(\"matrice:\");\n"
"    pretty_print(&matrix);\n"
"\n"
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```"

#: src/exercises/day-1/solutions-morning.md:57
#, fuzzy
msgid "Bonus question"
msgstr "칉ntrebare bonus"

#: src/exercises/day-1/solutions-morning.md:59
#, fuzzy
msgid ""
"It requires more advanced concepts. It might seem that we could use a slice-"
"of-slices (`&[&[i32]]`) as the input type to transpose and thus make our "
"function handle any size of matrix. However, this quickly breaks down: the "
"return type cannot be `&[&[i32]]` since it needs to own the data you return."
msgstr ""
"Aceasta necesit캒 concepte mai avansate. S-ar putea p캒rea c캒 am putea folosi "
"o felie de felii (`&[&[&[i32]]`) ca tip de intrare pentru transpunere 탳i "
"astfel func탵ia noastr캒 ar putea gestiona matrice de orice dimensiune. Cu "
"toate acestea, acest lucru se stric캒 rapid: tipul de retur nu poate fi "
"`&[&[i32]]`, deoarece trebuie s캒 de탵in캒 datele pe care le returnezi."

#: src/exercises/day-1/solutions-morning.md:61
#, fuzzy
msgid ""
"You can attempt to use something like `Vec<Vec<i32>>`, but this doesn't work "
"out-of-the-box either: it's hard to convert from `Vec<Vec<i32>>` to "
"`&[&[i32]]` so now you cannot easily use `pretty_print` either."
msgstr ""
"Pute탵i 칥ncerca s캒 folosi탵i ceva de genul `Vec&lt;Vec<i32>&gt;`, dar nici "
"acest lucru nu func탵ioneaz캒 imediat: este greu de convertit din `Vec&lt;"
"Vec<i32>&gt;` 칥n `&amp;[&amp;[&amp;[i32]]`, astfel 칥nc칙t acum nu pute탵i "
"folosi cu u탳urin탵캒 nici `pretty_print`."

#: src/exercises/day-1/solutions-morning.md:63
#, fuzzy
msgid ""
"Once we get to traits and generics, we'll be able to use the [`std::convert::"
"AsRef`](https://doc.rust-lang.org/std/convert/trait.AsRef.html) trait to "
"abstract over anything that can be referenced as a slice."
msgstr ""
"Odat캒 ce ajungem la tr캒s캒turi 탳i la generice, vom putea folosi tr캒s캒tura "
"[`std::convert::AsRef`](https://doc.rust-lang.org/std/convert/trait.AsRef."
"html) pentru a abstractiza orice poate fi referit ca o felie."

#: src/exercises/day-1/solutions-morning.md:65
#, fuzzy
msgid ""
"```rust\n"
"use std::convert::AsRef;\n"
"use std::fmt::Debug;\n"
"\n"
"fn pretty_print<T, Line, Matrix>(matrix: Matrix)\n"
"where\n"
"    T: Debug,\n"
"    // A line references a slice of items\n"
"    Line: AsRef<[T]>,\n"
"    // A matrix references a slice of lines\n"
"    Matrix: AsRef<[Line]>\n"
"{\n"
"    for row in matrix.as_ref() {\n"
"        println!(\"{:?}\", row.as_ref());\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    // &[&[i32]]\n"
"    pretty_print(&[&[1, 2, 3], &[4, 5, 6], &[7, 8, 9]]);\n"
"    // [[&str; 2]; 2]\n"
"    pretty_print([[\"a\", \"b\"], [\"c\", \"d\"]]);\n"
"    // Vec<Vec<i32>>\n"
"    pretty_print(vec![vec![1, 2], vec![3, 4]]);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use std::convert::AsRef;\n"
"use std::fmt::Debug;\n"
"\n"
"fn pretty_print<T, Line, Matrix>(matrix: Matrix)\n"
"unde\n"
"    T: Debug,\n"
"    // O linie se refer캒 la o felie de elemente\n"
"    Linie: AsRef<[T]>,\n"
"    // O matrice se refer캒 la o felie de linii\n"
"    Matrix: AsRef<[Line]>\n"
"{\n"
"    for row in matrix.as_ref() {\n"
"        println!(\"{:?}\", row.as_ref());\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    // &amp;[&amp;[i32]]\n"
"    pretty_print(&amp;[&amp;[&amp;[1, 2, 3], &amp;[4, 5, 6], &amp;[7, 8, "
"9]]);\n"
"    // [[&amp;[&amp;str; 2]; 2]\n"
"    pretty_print([[[\"a\", \"b\"], [\"c\", \"d\"]]]);\n"
"    // Vec&lt;Vec<i32>&gt\n"
"    pretty_print(vec![vec![1, 2], vec![3, 4]]);\n"
"}\n"
"```"

#: src/exercises/day-1/solutions-morning.md:92
#, fuzzy
msgid ""
"In addition, the type itself would not enforce that the child slices are of "
"the same length, so such variable could contain an invalid matrix."
msgstr ""
"칉n plus, tipul 칥n sine nu ar impune ca feliile copil s캒 aib캒 aceea탳i "
"lungime, astfel 칥nc칙t o astfel de variabil캒 ar putea con탵ine o matrice "
"invalid캒."

#: src/exercises/day-1/solutions-afternoon.md:1
#, fuzzy
msgid "Day 1 Afternoon Exercises"
msgstr "Ziua 1 Exerci탵ii de dup캒-amiaz캒"

#: src/exercises/day-1/solutions-afternoon.md:5
#, fuzzy
msgid "([back to exercise](luhn.md))"
msgstr "([back to exercise](luhn.md))"

#: src/exercises/day-1/solutions-afternoon.md:7
#, fuzzy
msgid ""
"```rust\n"
"pub fn luhn(cc_number: &str) -> bool {\n"
"    let mut sum = 0;\n"
"    let mut double = false;\n"
"    let mut digit_seen = 0;\n"
"\n"
"    for c in cc_number.chars().filter(|&f| f != ' ').rev() {\n"
"        if let Some(digit) = c.to_digit(10) {\n"
"            if double {\n"
"                let double_digit = digit * 2;\n"
"                sum += if double_digit > 9 {\n"
"                    double_digit - 9\n"
"                } else {\n"
"                    double_digit\n"
"                };\n"
"            } else {\n"
"                sum += digit;\n"
"            }\n"
"            double = !double;\n"
"            digit_seen += 1;\n"
"        } else {\n"
"            return false;\n"
"        }\n"
"    }\n"
"\n"
"    if digit_seen < 2 {\n"
"        return false;\n"
"    }\n"
"\n"
"    sum % 10 == 0\n"
"}\n"
"\n"
"fn main() {\n"
"    let cc_number = \"1234 5678 1234 5670\";\n"
"    println!(\n"
"        \"Is {cc_number} a valid credit card number? {}\",\n"
"        if luhn(cc_number) { \"yes\" } else { \"no\" }\n"
"    );\n"
"}\n"
"\n"
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\"));\n"
"    assert!(!luhn(\"foo 0 0\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_empty_cc_number() {\n"
"    assert!(!luhn(\"\"));\n"
"    assert!(!luhn(\" \"));\n"
"    assert!(!luhn(\"  \"));\n"
"    assert!(!luhn(\"    \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_single_digit_cc_number() {\n"
"    assert!(!luhn(\"0\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_two_digit_cc_number() {\n"
"    assert!(luhn(\" 0 0 \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_valid_cc_number() {\n"
"    assert!(luhn(\"4263 9826 4026 9299\"));\n"
"    assert!(luhn(\"4539 3195 0343 6467\"));\n"
"    assert!(luhn(\"7992 7398 713\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_invalid_cc_number() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"pub fn luhn(cc_number: &str) -> bool {\n"
"    let mut sum = 0;\n"
"    let mut double = false;\n"
"    let mut digit_seen = 0;\n"
"\n"
"    for c in cc_number.chars().filter(|&f| f != ' ').rev() {\n"
"        if let Some(digit) = c.to_digit(10) {\n"
"            if double {\n"
"                let double_digit = digit * 2;\n"
"                sum += if double_digit > 9 {\n"
"                    double_digit - 9\n"
"                } else {\n"
"                    double_digit\n"
"                };\n"
"            } else {\n"
"                sum += digit;\n"
"            }\n"
"            double = !double;\n"
"            digit_seen += 1;\n"
"        } else {\n"
"            return false;\n"
"        }\n"
"    }\n"
"\n"
"    if digit_seen < 2 {\n"
"        returneaz캒 false;\n"
"    }\n"
"\n"
"    sum % 10 == 0\n"
"}\n"
"\n"
"fn main() {\n"
"    let cc_number = \"1234 5678 1234 5670\";\n"
"    println!(\n"
"        \"Este {cc_number} un num캒r de card de credit valid? {}\",\n"
"        if luhn(cc_number) { \"yes\" } else { \"no\" }\n"
"    );\n"
"}\n"
"\n"
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\")));\n"
"    assert!(!luhn(\"foo 0 0\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_vid_num캒r_cc_vid() {\n"
"    assert!(!luhn(\"\")));\n"
"    assert!(!luhn(\" \")));\n"
"    assert!(!luhn(\" \")));\n"
"    assert!(!luhn(\" \")));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_single_digit_cc_number() {\n"
"    assert!(!luhn(\"0\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_two_digit_cc_number() {\n"
"    assert!(luhn(\" 0 0 0 \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_valid_cc_number() {\n"
"    assert!(luhn(\"4263 9826 4026 9299\")));\n"
"    assert!(luhn(\"4539 3195 0343 6467\")));\n"
"    assert!(luhn(\"7992 7398 713\")));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_invalid_cc_number() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\")));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\")));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\")));\n"
"}\n"
"```"

#: src/exercises/day-1/solutions-afternoon.md:86
#, fuzzy
msgid "Pattern matching"
msgstr "Potrivire de 탳abloane"

#: src/exercises/day-1/solutions-afternoon.md:88
#, fuzzy
msgid ""
"```rust\n"
"/// An operation to perform on two subexpressions.\n"
"#[derive(Debug)]\n"
"enum Operation {\n"
"    Add,\n"
"    Sub,\n"
"    Mul,\n"
"    Div,\n"
"}\n"
"\n"
"/// An expression, in tree form.\n"
"#[derive(Debug)]\n"
"enum Expression {\n"
"    /// An operation on two subexpressions.\n"
"    Op {\n"
"        op: Operation,\n"
"        left: Box<Expression>,\n"
"        right: Box<Expression>,\n"
"    },\n"
"\n"
"    /// A literal value\n"
"    Value(i64),\n"
"}\n"
"\n"
"/// The result of evaluating an expression.\n"
"#[derive(Debug, PartialEq, Eq)]\n"
"enum Res {\n"
"    /// Evaluation was successful, with the given result.\n"
"    Ok(i64),\n"
"    /// Evaluation failed, with the given error message.\n"
"    Err(String),\n"
"}\n"
"// Allow `Ok` and `Err` as shorthands for `Res::Ok` and `Res::Err`.\n"
"use Res::{Err, Ok};\n"
"\n"
"fn eval(e: Expression) -> Res {\n"
"    match e {\n"
"        Expression::Op { op, left, right } => {\n"
"            let left = match eval(*left) {\n"
"                Ok(v) => v,\n"
"                Err(msg) => return Err(msg),\n"
"            };\n"
"            let right = match eval(*right) {\n"
"                Ok(v) => v,\n"
"                Err(msg) => return Err(msg),\n"
"            };\n"
"            Ok(match op {\n"
"                Operation::Add => left + right,\n"
"                Operation::Sub => left - right,\n"
"                Operation::Mul => left * right,\n"
"                Operation::Div => {\n"
"                    if right == 0 {\n"
"                        return Err(String::from(\"division by zero\"));\n"
"                    } else {\n"
"                        left / right\n"
"                    }\n"
"                }\n"
"            })\n"
"        }\n"
"        Expression::Value(v) => Ok(v),\n"
"    }\n"
"}\n"
"\n"
"#[test]\n"
"fn test_value() {\n"
"    assert_eq!(eval(Expression::Value(19)), Ok(19));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_sum() {\n"
"    assert_eq!(\n"
"        eval(Expression::Op {\n"
"            op: Operation::Add,\n"
"            left: Box::new(Expression::Value(10)),\n"
"            right: Box::new(Expression::Value(20)),\n"
"        }),\n"
"        Ok(30)\n"
"    );\n"
"}\n"
"\n"
"#[test]\n"
"fn test_recursion() {\n"
"    let term1 = Expression::Op {\n"
"        op: Operation::Mul,\n"
"        left: Box::new(Expression::Value(10)),\n"
"        right: Box::new(Expression::Value(9)),\n"
"    };\n"
"    let term2 = Expression::Op {\n"
"        op: Operation::Mul,\n"
"        left: Box::new(Expression::Op {\n"
"            op: Operation::Sub,\n"
"            left: Box::new(Expression::Value(3)),\n"
"            right: Box::new(Expression::Value(4)),\n"
"        }),\n"
"        right: Box::new(Expression::Value(5)),\n"
"    };\n"
"    assert_eq!(\n"
"        eval(Expression::Op {\n"
"            op: Operation::Add,\n"
"            left: Box::new(term1),\n"
"            right: Box::new(term2),\n"
"        }),\n"
"        Ok(85)\n"
"    );\n"
"}\n"
"\n"
"#[test]\n"
"fn test_error() {\n"
"    assert_eq!(\n"
"        eval(Expression::Op {\n"
"            op: Operation::Div,\n"
"            left: Box::new(Expression::Value(99)),\n"
"            right: Box::new(Expression::Value(0)),\n"
"        }),\n"
"        Err(String::from(\"division by zero\"))\n"
"    );\n"
"}\n"
"fn main() {\n"
"    let expr = Expression::Op {\n"
"        op: Operation::Sub,\n"
"        left: Box::new(Expression::Value(20)),\n"
"        right: Box::new(Expression::Value(10)),\n"
"    };\n"
"    println!(\"expr: {:?}\", expr);\n"
"    println!(\"result: {:?}\", eval(expr));\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"/// O opera탵ie care trebuie efectuat캒 asupra a dou캒 subexpresii.\n"
"#[derive(Debug)]\n"
"enum Operation {\n"
"    Add,\n"
"    Sub,\n"
"    Mul,\n"
"    Div,\n"
"}\n"
"\n"
"/// O expresie, 칥n form캒 de arbore.\n"
"#[derive(Debug)]\n"
"enum Expression {\n"
"    /// O opera탵ie asupra a dou캒 subexpresii.\n"
"    Op {\n"
"        op: Opera탵ie,\n"
"        left: Box<Expression>,\n"
"        dreapta: Caseta<Expression>,\n"
"    },\n"
"\n"
"    /// O valoare literal캒\n"
"    Valoare(i64),\n"
"}\n"
"\n"
"/// Rezultatul evalu캒rii unei expresii.\n"
"#[derive(Debug, PartialEq, Eq)]\n"
"enum Res {\n"
"    /// Evaluarea a avut succes, cu rezultatul dat.\n"
"    Ok(i64),\n"
"    /// Evaluarea a e탳uat, cu mesajul de eroare dat.\n"
"    Err(String),\n"
"}\n"
"// Permite탵i `Ok` 탳i `Err` ca prescurt캒ri pentru `Res::Ok` 탳i `Res::Err`.\n"
"use Res::{Err, Ok};\n"
"\n"
"fn eval(e: Expression) -&gt; Res {\n"
"    match e {\n"
"        Expression::Op { op, left, right } =&gt; {\n"
"            let left = match eval(*left) {\n"
"                Ok(v) =&gt; v,\n"
"                Err(msg) =&gt; return Err(msg),\n"
"            };\n"
"            let right = match eval(*right) {\n"
"                Ok(v) =&gt; v,\n"
"                Err(msg) =&gt; return Err(msg),\n"
"            };\n"
"            Ok(match op {\n"
"                Operation::Add =&gt; left + right,\n"
"                Operation::Sub =&gt; st칙nga - dreapta,\n"
"                Operation::Mul =&gt; st칙nga * dreapta,\n"
"                Operation::Div =&gt; {\n"
"                    if right == 0 {\n"
"                        return Err(String::from(\"diviziune cu zero\"));\n"
"                    } else {\n"
"                        st칙nga / dreapta\n"
"                    }\n"
"                }\n"
"            })\n"
"        }\n"
"        Expresie::Valoare(v) =&gt; Ok(v),\n"
"    }\n"
"}\n"
"\n"
"#[test]\n"
"fn test_valoare_test() {\n"
"    assert_eq!(eval(Expression::Value(19)), Ok(19));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_sum() {\n"
"    assert_eq!(\n"
"        eval(Expression::Op {\n"
"            op: Operation::Add,\n"
"            left: Box::new(Expression::Value(10)),\n"
"            right: Box::new(Expression::Value(20)),\n"
"        }),\n"
"        Ok(30)\n"
"    );\n"
"}\n"
"\n"
"#[test]\n"
"fn test_recursiune_test() {\n"
"    let term1 = Expression::Op {\n"
"        op: Operation::Mul,\n"
"        left: Box::new(Expression::Value(10)),\n"
"        right: Box::new(Expression::Value(9)),\n"
"    };\n"
"    let term2 = Expression::Op {\n"
"        op: Operation::Mul,\n"
"        left: Box::new(Expression::Op {\n"
"            op: Operation::Sub,\n"
"            left: Box::new(Expression::Value(3)),\n"
"            right: Box::new(Expresie::Valoare(4)),\n"
"        }),\n"
"        dreapta: Box::new(Expression::Value(5)),\n"
"    };\n"
"    assert_eq!(\n"
"        eval(Expression::Op {\n"
"            op: Operation::Add,\n"
"            left: Box::new(term1),\n"
"            right: Box::new(term2),\n"
"        }),\n"
"        Ok(85)\n"
"    );\n"
"}\n"
"\n"
"#[test]\n"
"fn test_error() {\n"
"    assert_eq!(\n"
"        eval(Expression::Op {\n"
"            op: Operation::Div,\n"
"            left: Box::new(Expression::Value(99)),\n"
"            right: Box::new(Expresie::Valoare(0)),\n"
"        }),\n"
"        Err(String::from(\"칥mp캒r탵ire la zero\"))\n"
"    );\n"
"}\n"
"fn main() {\n"
"    let expr = Expression::Op {\n"
"        op: Operation::Sub,\n"
"        left: Box::new(Expression::Value(20)),\n"
"        right: Box::new(Expresie::Valoare(10)),\n"
"    };\n"
"    println!(\"expr: {:?}\", expr);\n"
"    println!(\"rezultat: {:?}\", eval(expr));\n"
"}\n"
"```"

#: src/exercises/day-2/solutions-morning.md:1
#, fuzzy
msgid "Day 2 Morning Exercises"
msgstr "Ziua 2 Exerci탵ii de diminea탵캒"

#: src/exercises/day-2/solutions-morning.md:3
#, fuzzy
msgid "Designing a Library"
msgstr "Proiectarea unei biblioteci"

#: src/exercises/day-2/solutions-morning.md:5
#, fuzzy
msgid "([back to exercise](book-library.md))"
msgstr "([back to exercise](book-library.md))"

#: src/exercises/day-2/solutions-morning.md:7
#, fuzzy
msgid ""
"```rust\n"
"struct Library {\n"
"    books: Vec<Book>,\n"
"}\n"
"\n"
"struct Book {\n"
"    title: String,\n"
"    year: u16,\n"
"}\n"
"\n"
"impl Book {\n"
"    // This is a constructor, used below.\n"
"    fn new(title: &str, year: u16) -> Book {\n"
"        Book {\n"
"            title: String::from(title),\n"
"            year,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Implement the methods below. Notice how the `self` parameter\n"
"// changes type to indicate the method's required level of ownership\n"
"// over the object:\n"
"//\n"
"// - `&self` for shared read-only access,\n"
"// - `&mut self` for unique and mutable access,\n"
"// - `self` for unique access by value.\n"
"impl Library {\n"
"\n"
"    fn new() -> Library {\n"
"        Library { books: Vec::new() }\n"
"    }\n"
"\n"
"    fn len(&self) -> usize {\n"
"        self.books.len()\n"
"    }\n"
"\n"
"    fn is_empty(&self) -> bool {\n"
"        self.books.is_empty()\n"
"    }\n"
"\n"
"    fn add_book(&mut self, book: Book) {\n"
"        self.books.push(book)\n"
"    }\n"
"\n"
"    fn print_books(&self) {\n"
"        for book in &self.books {\n"
"            println!(\"{}, published in {}\", book.title, book.year);\n"
"        }\n"
"    }\n"
"\n"
"    fn oldest_book(&self) -> Option<&Book> {\n"
"        // Using a closure and a built-in method:\n"
"        // self.books.iter().min_by_key(|book| book.year)\n"
"\n"
"        // Longer hand-written solution:\n"
"        let mut oldest: Option<&Book> = None;\n"
"        for book in self.books.iter() {\n"
"            if oldest.is_none() || book.year < oldest.unwrap().year {\n"
"                oldest = Some(book);\n"
"            }\n"
"        }\n"
"\n"
"        oldest\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut library = Library::new();\n"
"\n"
"    println!(\n"
"        \"The library is empty: library.is_empty() -> {}\",\n"
"        library.is_empty()\n"
"    );\n"
"\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"\n"
"    println!(\n"
"        \"The library is no longer empty: library.is_empty() -> {}\",\n"
"        library.is_empty()\n"
"    );\n"
"\n"
"    library.print_books();\n"
"\n"
"    match library.oldest_book() {\n"
"        Some(book) => println!(\"The oldest book is {}\", book.title),\n"
"        None => println!(\"The library is empty!\"),\n"
"    }\n"
"\n"
"    println!(\"The library has {} books\", library.len());\n"
"    library.print_books();\n"
"}\n"
"\n"
"#[test]\n"
"fn test_library_len() {\n"
"    let mut library = Library::new();\n"
"    assert_eq!(library.len(), 0);\n"
"    assert!(library.is_empty());\n"
"\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    assert_eq!(library.len(), 2);\n"
"    assert!(!library.is_empty());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_library_is_empty() {\n"
"    let mut library = Library::new();\n"
"    assert!(library.is_empty());\n"
"\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    assert!(!library.is_empty());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_library_print_books() {\n"
"    let mut library = Library::new();\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    // We could try and capture stdout, but let us just call the\n"
"    // method to start with.\n"
"    library.print_books();\n"
"}\n"
"\n"
"#[test]\n"
"fn test_library_oldest_book() {\n"
"    let mut library = Library::new();\n"
"    assert!(library.oldest_book().is_none());\n"
"\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    assert_eq!(\n"
"        library.oldest_book().map(|b| b.title.as_str()),\n"
"        Some(\"Lord of the Rings\")\n"
"    );\n"
"\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    assert_eq!(\n"
"        library.oldest_book().map(|b| b.title.as_str()),\n"
"        Some(\"Alice's Adventures in Wonderland\")\n"
"    );\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"struct Biblioteca {\n"
"    c캒r탵i: Vec<Book>,\n"
"}\n"
"\n"
"struct Book {\n"
"    titlu: String,\n"
"    year: u16,\n"
"}\n"
"\n"
"impl Book {\n"
"    // Acesta este un constructor, utilizat mai jos.\n"
"    fn new(title: &amp;str, year: u16) -&gt; Book {\n"
"        Carte {\n"
"            title: String::from(title),\n"
"            year,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Implementa탵i metodele de mai jos. Observa탵i modul 칥n care parametrul "
"`self`\n"
"// 칥탳i schimb캒 tipul pentru a indica nivelul necesar de proprietate al "
"metodei\n"
"// asupra obiectului:\n"
"//\n"
"// - `&amp;self` pentru acces partajat numai pentru citire,\n"
"// - `&amp;mut self` pentru acces unic 탳i mutabil,\n"
"// - `self` pentru acces unic prin valoare.\n"
"impl Library {\n"
"\n"
"    fn new() -&gt; Library {\n"
"        Bibliotec캒 { books: Vec::new() }\n"
"    }\n"
"\n"
"    fn len(&amp;self) -&gt; usize {\n"
"        self.books.len()\n"
"    }\n"
"\n"
"    fn is_empty(&amp;self) -&gt; bool {\n"
"        self.books.is_empty()\n"
"    }\n"
"\n"
"    fn add_book(&amp;mut self, book: Book) {\n"
"        self.books.push(book)\n"
"    }\n"
"\n"
"    fn print_books(&amp;self) {\n"
"        for book in &amp;self.books {\n"
"            println!(\"{}, publicat 칥n {}\", book.title, book.year);\n"
"        }\n"
"    }\n"
"\n"
"    fn oldest_book(&amp;self) -&gt; Option<&Book> {\n"
"        // Utilizarea unei 칥nchideri 탳i a unei metode 칥ncorporate:\n"
"        // self.books.iter().min_by_key(|book| book.year)\n"
"\n"
"        // Solu탵ie mai lung캒 scris캒 de m칙n캒:\n"
"        let mut oldest: Option<&Book> = None;\n"
"        for book in self.books.iter() {\n"
"            if oldest.is_none() || book.year < oldest.unwrap().year {\n"
"                oldest = Some(book);\n"
"            }\n"
"        }\n"
"\n"
"        oldest\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut library = Library::new();\n"
"\n"
"    println!(\n"
"        \"The library is empty: library.is_empty() -> {}\",\n"
"        library.is_empty()\n"
"    );\n"
"\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"\n"
"    println!(\n"
"        \"The library is no longer empty: library.is_empty() -> {}\",\n"
"        library.is_empty()\n"
"    );\n"
"\n"
"    library.print_books();\n"
"\n"
"    match library.oldest_book() {\n"
"        Some(book) => println!(\"Cea mai veche carte este {}\", book."
"title),\n"
"        None =&gt; printlnn!(\"Biblioteca este goal캒!\"),\n"
"    }\n"
"\n"
"    printlnn!(\"Biblioteca are {} c캒r탵i\", library.len());\n"
"    library.print_books();\n"
"}\n"
"\n"
"#[test]\n"
"fn test_test_library_len() {\n"
"    let mut library = Library::new();\n"
"    assert_eq!(library.len(), 0);\n"
"    assert!(library.is_empty());\n"
"\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Aventurile lui Alice 칥n 탴ara Minunilor\", "
"1865));\n"
"    assert_eq!(library.len(), 2);\n"
"    assert!(!library.is_empty());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_biblioteca_este_vid캒() {\n"
"    let mut library = Library::new();\n"
"    assert!(library.is_empty());\n"
"\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    assert!(!library.is_empty());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_biblioteca_imprim캒_c캒r탵i() {\n"
"    let mut library = Library::new();\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Aventurile lui Alice 칥n 탴ara Minunilor\", "
"1865));\n"
"    // Am putea 칥ncerca s캒 captur캒m stdout, dar haide탵i s캒 apel캒m pur 탳i "
"simplu la func탵ia\n"
"    // metoda pentru 칥nceput.\n"
"    library.print_books();\n"
"}\n"
"\n"
"#[test]\n"
"fn test_biblioteca_cea_mai_veche_carte() {\n"
"    let mut library = Library::new();\n"
"    assert!(library.oldest_book().is_none()));\n"
"\n"
"    library.add_book(Book::new(\"St캒p칙nul Inelelor\", 1954));\n"
"    assert_eq!(\n"
"        library.oldest_book().map(|b| b.title.as_str()),\n"
"        Some(\"St캒p칙nul inelelor\")\n"
"    );\n"
"\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    assert_eq!(\n"
"        library.oldest_book().map(|b| b.title.as_str()),\n"
"        Some(\"Aventurile lui Alice 칥n 탴ara Minunilor\")\n"
"    );\n"
"}\n"
"```"

#: src/exercises/day-2/solutions-morning.md:153
#, fuzzy
msgid "([back to exercise](health-statistics.md))"
msgstr "([back to exercise](health-statistics.md))"

#: src/exercises/day-2/solutions-morning.md:155
#, fuzzy
msgid ""
"```rust\n"
"pub struct User {\n"
"    name: String,\n"
"    age: u32,\n"
"    height: f32,\n"
"    visit_count: usize,\n"
"    last_blood_pressure: Option<(u32, u32)>,\n"
"}\n"
"\n"
"pub struct Measurements {\n"
"    height: f32,\n"
"    blood_pressure: (u32, u32),\n"
"}\n"
"\n"
"pub struct HealthReport<'a> {\n"
"    patient_name: &'a str,\n"
"    visit_count: u32,\n"
"    height_change: f32,\n"
"    blood_pressure_change: Option<(i32, i32)>,\n"
"}\n"
"\n"
"impl User {\n"
"    pub fn new(name: String, age: u32, height: f32) -> Self {\n"
"        Self {\n"
"            name,\n"
"            age,\n"
"            height,\n"
"            visit_count: 0,\n"
"            last_blood_pressure: None,\n"
"        }\n"
"    }\n"
"\n"
"    pub fn name(&self) -> &str {\n"
"        &self.name\n"
"    }\n"
"\n"
"    pub fn age(&self) -> u32 {\n"
"        self.age\n"
"    }\n"
"\n"
"    pub fn height(&self) -> f32 {\n"
"        self.height\n"
"    }\n"
"\n"
"    pub fn doctor_visits(&self) -> u32 {\n"
"        self.visit_count as u32\n"
"    }\n"
"\n"
"    pub fn set_age(&mut self, new_age: u32) {\n"
"        self.age = new_age\n"
"    }\n"
"\n"
"    pub fn set_height(&mut self, new_height: f32) {\n"
"        self.height = new_height\n"
"    }\n"
"\n"
"    pub fn visit_doctor(&mut self, measurements: Measurements) -> "
"HealthReport {\n"
"        self.visit_count += 1;\n"
"        let bp = measurements.blood_pressure;\n"
"        let report = HealthReport {\n"
"            patient_name: &self.name,\n"
"            visit_count: self.visit_count as u32,\n"
"            height_change: measurements.height - self.height,\n"
"            blood_pressure_change: match self.last_blood_pressure {\n"
"                Some(lbp) => Some((\n"
"                    bp.0 as i32 - lbp.0 as i32,\n"
"                    bp.1 as i32 - lbp.1 as i32\n"
"                )),\n"
"                None => None,\n"
"            }\n"
"        };\n"
"        self.height = measurements.height;\n"
"        self.last_blood_pressure = Some(bp);\n"
"        report\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    println!(\"I'm {} and my age is {}\", bob.name(), bob.age());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_height() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.height(), 155.2);\n"
"}\n"
"\n"
"#[test]\n"
"fn test_set_age() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.age(), 32);\n"
"    bob.set_age(33);\n"
"    assert_eq!(bob.age(), 33);\n"
"}\n"
"\n"
"#[test]\n"
"fn test_visit() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.doctor_visits(), 0);\n"
"    let report = bob.visit_doctor(Measurements {\n"
"        height: 156.1,\n"
"        blood_pressure: (120, 80),\n"
"    });\n"
"    assert_eq!(report.patient_name, \"Bob\");\n"
"    assert_eq!(report.visit_count, 1);\n"
"    assert_eq!(report.blood_pressure_change, None);\n"
"\n"
"    let report = bob.visit_doctor(Measurements {\n"
"        height: 156.1,\n"
"        blood_pressure: (115, 76),\n"
"    });\n"
"\n"
"    assert_eq!(report.visit_count, 2);\n"
"    assert_eq!(report.blood_pressure_change, Some((-5, -4)));\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"pub struct Utilizator {\n"
"    name: String,\n"
"    age: u32,\n"
"    칥n캒l탵ime: f32,\n"
"    visit_count: usize,\n"
"    last_blood_pressure: Option<(u32, u32)>,\n"
"}\n"
"\n"
"pub struct struct Measurements {\n"
"    height: f32,\n"
"    blood_pressure: (u32, u32),\n"
"}\n"
"\n"
"pub struct struct HealthReport<'a> {\n"
"    patient_name: &'a str,\n"
"    visit_count: u32,\n"
"    height_change: f32,\n"
"    blood_pressure_change: Option<(i32, i32)>,\n"
"}\n"
"\n"
"impl User {\n"
"    pub fn new(name: String, age: u32, height: f32) -> Self {\n"
"        Self {\n"
"            name,\n"
"            v칙rst캒,\n"
"            칥n캒l탵ime,\n"
"            visit_count: 0,\n"
"            last_blood_pressure: niciunul,\n"
"        }\n"
"    }\n"
"\n"
"    pub fn name(&self) -> &str {\n"
"        &self.name\n"
"    }\n"
"\n"
"    pub fn age(&self) -> u32 {\n"
"        self.age\n"
"    }\n"
"\n"
"    pub fn height(&self) -> f32 {\n"
"        self.height\n"
"    }\n"
"\n"
"    pub fn fn doctor_visite(&self) -> u32 {\n"
"        self.visit_count as u32\n"
"    }\n"
"\n"
"    pub fn set_age(&mut self, new_age: u32) {\n"
"        self.age = new_age\n"
"    }\n"
"\n"
"    pub fn set_height(&mut self, new_height: f32) {\n"
"        self.height = new_height\n"
"    }\n"
"\n"
"    pub fn visit_doctor(&mut self, measurements: Measurements) -> "
"HealthReport {\n"
"        self.visit_count += 1;\n"
"        let bp = measurements.blood_pressure;\n"
"        let report = HealthReport {\n"
"            patient_name: &self.name,\n"
"            visit_count: self.visit_count as u32,\n"
"            height_change: measurements.height - self.height,\n"
"            blood_pressure_change: match self.last_blood_pressure {\n"
"                Some(lbp) => Some((\n"
"                    bp.0 as i32 - lbp.0 as i32,\n"
"                    bp.1 as i32 - lbp.1 as i32\n"
"                )),\n"
"                None => None,\n"
"            }\n"
"        };\n"
"        self.height = measurements.height;\n"
"        self.last_blood_pressure = Some(bp);\n"
"        raporteaz캒\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    println!(\"Sunt {} 탳i v칙rsta mea este {}\", bob.name(), bob.age()), bob."
"age());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_칥n캒l탵ime() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.height(), 155.2);\n"
"}\n"
"\n"
"#[test]\n"
"fn test_set_age() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.age(), 32);\n"
"    bob.set_age(33);\n"
"    assert_eq!(bob.age(), 33);\n"
"}\n"
"\n"
"#[test]\n"
"fn test_vizita_test() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.doctor_visiteaz캒(), 0);\n"
"    let report = bob.visit_doctor(Measurements {\n"
"        칥n캒l탵ime: 156,1,\n"
"        blood_pressure: (120, 80),\n"
"    });\n"
"    assert_eq!(report.patient_name, \"Bob\");\n"
"    assert_eq!(report.visit_count, 1);\n"
"    assert_eq!(report.blood_pressure_change, None);\n"
"\n"
"    let report = bob.visit_doctor(Measurements {\n"
"        칥n캒l탵ime: 156,1,\n"
"        blood_pressure: (115, 76),\n"
"    });\n"
"\n"
"    assert_eq!(report.visit_count, 2);\n"
"    assert_eq!(report.blood_pressure_change, Some((-5, -4)));\n"
"}\n"
"```"

#: src/exercises/day-2/solutions-afternoon.md:1
#, fuzzy
msgid "Day 2 Afternoon Exercises"
msgstr "Ziua 2 Exerci탵ii de dup캒-amiaz캒"

#: src/exercises/day-2/solutions-afternoon.md:5
#, fuzzy
msgid "([back to exercise](strings-iterators.md))"
msgstr "([칥napoi la exerci탵iu](strings-iterators.md))"

#: src/exercises/day-2/solutions-afternoon.md:7
#, fuzzy
msgid ""
"```rust\n"
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"\n"
"    let mut request_segments = request_path.split('/');\n"
"\n"
"    for prefix_segment in prefix.split('/') {\n"
"        let Some(request_segment) = request_segments.next() else {\n"
"            return false;\n"
"        };\n"
"        if request_segment != prefix_segment && prefix_segment != \"*\" {\n"
"            return false;\n"
"        }\n"
"    }\n"
"    true\n"
"\n"
"    // Alternatively, Iterator::zip() lets us iterate simultaneously over "
"prefix\n"
"    // and request segments. The zip() iterator is finished as soon as one "
"of\n"
"    // the source iterators is finished, but we need to iterate over all "
"request\n"
"    // segments. A neat trick that makes zip() work is to use map() and "
"chain()\n"
"    // to produce an iterator that returns Some(str) for each pattern "
"segments,\n"
"    // and then returns None indefinitely.\n"
"}\n"
"\n"
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/"
"abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/"
"books\"));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/publishersBooks\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/parent/"
"publishers\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_matches_with_wildcard() {\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/bar/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books/book1\"\n"
"    ));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/"
"publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"\n"
"fn main() {}\n"
"```"
msgstr ""
"```rust\n"
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"\n"
"    let mut request_segments = request_path.split('/');\n"
"\n"
"    for prefix_segment in prefix.split('/') {\n"
"        let Some(request_segment) = request_segments.next() else {\n"
"            return false;\n"
"        };\n"
"        if request_segment != prefix_segment && prefix_segment ! = \"*\" {\n"
"            return false;\n"
"        }\n"
"    }\n"
"    true\n"
"\n"
"    // Alternativ, Iterator::zip() ne permite s캒 iter캒m simultan peste "
"prefixul\n"
"    // 탳i segmentele de cerere. Iteratorul zip() se termin캒 de 칥ndat캒 ce "
"unul din\n"
"    // iteratorii surs캒 se termin캒, dar noi trebuie s캒 iter캒m peste toate "
"cererile\n"
"    // segmente. Un truc ingenios care face ca zip() s캒 func탵ioneze este "
"utilizarea map() 탳i chain()\n"
"    // pentru a produce un iterator care returneaz캒 Some(str) pentru fiecare "
"segment de model,\n"
"    // 탳i apoi returneaz캒 None la nesf칙r탳it.\n"
"}\n"
"\n"
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/"
"abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/"
"books\")));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/publishersBooks\")));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/p캒rin탵i/editori\")));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_matches_with_wildcard() {\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/bar/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books/books/book1\"\n"
"    ));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/"
"publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"\n"
"fn main() {}\n"
"```"

#: src/exercises/day-3/solutions-morning.md:1
#, fuzzy
msgid "Day 3 Morning Exercise"
msgstr "Ziua 3 Exerci탵iul de diminea탵캒"

#: src/exercises/day-3/solutions-morning.md:5
#, fuzzy
msgid "([back to exercise](simple-gui.md))"
msgstr "([칥napoi la exerci탵iu](simple-gui.md))"

#: src/exercises/day-3/solutions-morning.md:7
#, fuzzy
msgid ""
"```rust\n"
"pub trait Widget {\n"
"    /// Natural width of `self`.\n"
"    fn width(&self) -> usize;\n"
"\n"
"    /// Draw the widget into a buffer.\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);\n"
"\n"
"    /// Draw the widget on standard output.\n"
"    fn draw(&self) {\n"
"        let mut buffer = String::new();\n"
"        self.draw_into(&mut buffer);\n"
"        println!(\"{buffer}\");\n"
"    }\n"
"}\n"
"\n"
"pub struct Label {\n"
"    label: String,\n"
"}\n"
"\n"
"impl Label {\n"
"    fn new(label: &str) -> Label {\n"
"        Label {\n"
"            label: label.to_owned(),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Button {\n"
"    label: Label,\n"
"}\n"
"\n"
"impl Button {\n"
"    fn new(label: &str) -> Button {\n"
"        Button {\n"
"            label: Label::new(label),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Window {\n"
"    title: String,\n"
"    widgets: Vec<Box<dyn Widget>>,\n"
"}\n"
"\n"
"impl Window {\n"
"    fn new(title: &str) -> Window {\n"
"        Window {\n"
"            title: title.to_owned(),\n"
"            widgets: Vec::new(),\n"
"        }\n"
"    }\n"
"\n"
"    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
"        self.widgets.push(widget);\n"
"    }\n"
"\n"
"    fn inner_width(&self) -> usize {\n"
"        std::cmp::max(\n"
"            self.title.chars().count(),\n"
"            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
"        )\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        // Add 4 paddings for borders\n"
"        self.inner_width() + 4\n"
"    }\n"
"\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        let mut inner = String::new();\n"
"        for widget in &self.widgets {\n"
"            widget.draw_into(&mut inner);\n"
"        }\n"
"\n"
"        let inner_width = self.inner_width();\n"
"\n"
"        // TODO: after learning about error handling, you can change\n"
"        // draw_into to return Result<(), std::fmt::Error>. Then use\n"
"        // the ?-operator here instead of .unwrap().\n"
"        writeln!(buffer, \"+-{:-<inner_width$}-+\", \"\").unwrap();\n"
"        writeln!(buffer, \"| {:^inner_width$} |\", &self.title).unwrap();\n"
"        writeln!(buffer, \"+={:=<inner_width$}=+\", \"\").unwrap();\n"
"        for line in inner.lines() {\n"
"            writeln!(buffer, \"| {:inner_width$} |\", line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+-{:-<inner_width$}-+\", \"\").unwrap();\n"
"    }\n"
"}\n"
"\n"
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        self.label.width() + 8 // add a bit of padding\n"
"    }\n"
"\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        let width = self.width();\n"
"        let mut label = String::new();\n"
"        self.label.draw_into(&mut label);\n"
"\n"
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"        for line in label.lines() {\n"
"            writeln!(buffer, \"|{:^width$}|\", &line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"    }\n"
"}\n"
"\n"
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        self.label\n"
"            .lines()\n"
"            .map(|line| line.chars().count())\n"
"            .max()\n"
"            .unwrap_or(0)\n"
"    }\n"
"\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        writeln!(buffer, \"{}\", &self.label).unwrap();\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"This is a small text GUI demo."
"\")));\n"
"    window.add_widget(Box::new(Button::new(\n"
"        \"Click me!\"\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"pub trait Widget {\n"
"    /// L캒탵imea natural캒 a lui `self`.\n"
"    fn width(&amp;self) -&gt; usize;\n"
"\n"
"    /// Deseneaz캒 widget-ul 칥ntr-un buffer.\n"
"    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write);\n"
"\n"
"    /// Deseneaz캒 widget-ul pe ie탳irea standard.\n"
"    fn draw(&amp;self) {\n"
"        let mut buffer = String::new();\n"
"        self.draw_into(&amp;mut buffer);\n"
"        println!(\"{buffer}\");\n"
"    }\n"
"}\n"
"\n"
"pub struct Label {\n"
"    label: String,\n"
"}\n"
"\n"
"impl Label {\n"
"    fn new(label: &amp;str) -&gt; Label {\n"
"        Etichet캒 {\n"
"            label: label.to_owned(),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Button {\n"
"    label: Label,\n"
"}\n"
"\n"
"impl Button {\n"
"    fn new(label: &amp;str) -&gt; Button {\n"
"        Button {\n"
"            label: Label::new(label),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Window {\n"
"    title: String,\n"
"    widgets: Vec&lt;Box<dyn Widget>&gt;,\n"
"}\n"
"\n"
"impl Window {\n"
"    fn new(title: &amp;str) -&gt; Window {\n"
"        Window {\n"
"            title: title.to_owned(),\n"
"            widgets: Vec::new(),\n"
"        }\n"
"    }\n"
"\n"
"    fn add_widget(&amp;mut self, widget: Box<dyn Widget>) {\n"
"        self.widgets.push(widget);\n"
"    }\n"
"\n"
"    fn inner_width(&amp;self) -&gt; usize {\n"
"        std::cmp::max(\n"
"            self.title.chars().count(),\n"
"            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
"        )\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl Widget pentru fereastr캒 {\n"
"    fn width(&amp;self) -&gt; usize {\n"
"        // Ad캒uga탵i 4 c캒ptu탳eli pentru margini\n"
"        self.inner_width() + 4\n"
"    }\n"
"\n"
"    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {\n"
"        let mut inner = String::new();\n"
"        for widget in &amp;self.widgets {\n"
"            widget.draw_into(&amp;mut inner);\n"
"        }\n"
"\n"
"        let inner_width = self.inner_width();\n"
"\n"
"        // TODO: dup캒 ce a탵i 칥nv캒탵at despre gestionarea erorilor, pute탵i "
"schimba\n"
"        // draw_into pentru a returna rezultatul<(), std::fmt::Error>. Apoi "
"utiliza탵i\n"
"        // operatorul ?- aici 칥n loc de .unwrap().\n"
"        writeln!(buffer, \"+-{:-<inner_width$}-+\", \"\").unwrap();\n"
"        writeln!(buffer, \"| {:^inner_width$} |\", &amp;self.title)."
"unwrap();\n"
"        writeln!(buffer, \"+={:=<inner_width$}=+\", \"\").unwrap();\n"
"        for line in inner.lines() {\n"
"            writeln!(buffer, \"| {:inner_width$} |\", line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+-{:-<inner_width$}-+\", \"\").unwrap();\n"
"    }\n"
"}\n"
"\n"
"impl Widget pentru Button {\n"
"    fn width(&amp;self) -&gt; usize {\n"
"        self.label.width() + 8 // adaug캒 un pic de umplutur캒\n"
"    }\n"
"\n"
"    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {\n"
"        let width = self.width();\n"
"        let mut label = String::new();\n"
"        self.label.draw_into(&amp;mut label);\n"
"\n"
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"        for line in label.lines() {\n"
"            writeln!(buffer, \"|{:^width$}|\", &amp;line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"    }\n"
"}\n"
"\n"
"impl Widget pentru etichet캒 {\n"
"    fn width(&amp;self) -&gt; usize {\n"
"        self.label\n"
"            .lines()\n"
"            .map(|line| line| line.chars().count()))\n"
"            .max()\n"
"            .unwrap_or(0)\n"
"    }\n"
"\n"
"    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {\n"
"        writeln!(buffer, \"{}\", &amp;self.label).unwrap();\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"Aceasta este o mic캒 demonstra탵ie "
"GUI de text.\")));\n"
"    window.add_widget(Box::new(Button::new(:new(\n"
"        \"Face탵i clic pe mine!\"\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"```"

#: src/exercises/day-3/solutions-morning.md:144
#, fuzzy
msgid "([back to exercise](points-polygons.md))"
msgstr "([칥napoi la exerci탵iu](puncte-poligoane.md))"

#: src/exercises/day-3/solutions-morning.md:146
#, fuzzy
msgid ""
"```rust\n"
"#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n"
"pub struct Point {\n"
"    x: i32,\n"
"    y: i32,\n"
"}\n"
"\n"
"impl Point {\n"
"    pub fn new(x: i32, y: i32) -> Point {\n"
"        Point { x, y }\n"
"    }\n"
"\n"
"    pub fn magnitude(self) -> f64 {\n"
"        f64::from(self.x.pow(2) + self.y.pow(2)).sqrt()\n"
"    }\n"
"\n"
"    pub fn dist(self, other: Point) -> f64 {\n"
"        (self - other).magnitude()\n"
"    }\n"
"}\n"
"\n"
"impl std::ops::Add for Point {\n"
"    type Output = Self;\n"
"\n"
"    fn add(self, other: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x + other.x,\n"
"            y: self.y + other.y,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl std::ops::Sub for Point {\n"
"    type Output = Self;\n"
"\n"
"    fn sub(self, other: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x - other.x,\n"
"            y: self.y - other.y,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Polygon {\n"
"    points: Vec<Point>,\n"
"}\n"
"\n"
"impl Polygon {\n"
"    pub fn new() -> Polygon {\n"
"        Polygon { points: Vec::new() }\n"
"    }\n"
"\n"
"    pub fn add_point(&mut self, point: Point) {\n"
"        self.points.push(point);\n"
"    }\n"
"\n"
"    pub fn left_most_point(&self) -> Option<Point> {\n"
"        self.points.iter().min_by_key(|p| p.x).copied()\n"
"    }\n"
"\n"
"    pub fn iter(&self) -> impl Iterator<Item = &Point> {\n"
"        self.points.iter()\n"
"    }\n"
"\n"
"    pub fn length(&self) -> f64 {\n"
"        if self.points.is_empty() {\n"
"            return 0.0;\n"
"        }\n"
"\n"
"        let mut result = 0.0;\n"
"        let mut last_point = self.points[0];\n"
"        for point in &self.points[1..] {\n"
"            result += last_point.dist(*point);\n"
"            last_point = *point;\n"
"        }\n"
"        result += last_point.dist(self.points[0]);\n"
"        result\n"
"        // Alternatively, Iterator::zip() lets us iterate over the points as "
"pairs\n"
"        // but we need to pair each point with the next one, and the last "
"point\n"
"        // with the first point. The zip() iterator is finished as soon as "
"one of \n"
"        // the source iterators is finished, a neat trick is to combine "
"Iterator::cycle\n"
"        // with Iterator::skip to create the second iterator for the zip and "
"using map \n"
"        // and sum to calculate the total length.\n"
"    }\n"
"}\n"
"\n"
"pub struct Circle {\n"
"    center: Point,\n"
"    radius: i32,\n"
"}\n"
"\n"
"impl Circle {\n"
"    pub fn new(center: Point, radius: i32) -> Circle {\n"
"        Circle { center, radius }\n"
"    }\n"
"\n"
"    pub fn circumference(&self) -> f64 {\n"
"        2.0 * std::f64::consts::PI * f64::from(self.radius)\n"
"    }\n"
"\n"
"    pub fn dist(&self, other: &Self) -> f64 {\n"
"        self.center.dist(other.center)\n"
"    }\n"
"}\n"
"\n"
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}\n"
"\n"
"impl From<Polygon> for Shape {\n"
"    fn from(poly: Polygon) -> Self {\n"
"        Shape::Polygon(poly)\n"
"    }\n"
"}\n"
"\n"
"impl From<Circle> for Shape {\n"
"    fn from(circle: Circle) -> Self {\n"
"        Shape::Circle(circle)\n"
"    }\n"
"}\n"
"\n"
"impl Shape {\n"
"    pub fn perimeter(&self) -> f64 {\n"
"        match self {\n"
"            Shape::Polygon(poly) => poly.length(),\n"
"            Shape::Circle(circle) => circle.circumference(),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    fn round_two_digits(x: f64) -> f64 {\n"
"        (x * 100.0).round() / 100.0\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_magnitude() {\n"
"        let p1 = Point::new(12, 13);\n"
"        assert_eq!(round_two_digits(p1.magnitude()), 17.69);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_dist() {\n"
"        let p1 = Point::new(10, 10);\n"
"        let p2 = Point::new(14, 13);\n"
"        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_add() {\n"
"        let p1 = Point::new(16, 16);\n"
"        let p2 = p1 + Point::new(-4, 3);\n"
"        assert_eq!(p2, Point::new(12, 19));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_left_most_point() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"        assert_eq!(poly.left_most_point(), Some(p1));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_iter() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"\n"
"        let points = poly.iter().cloned().collect::<Vec<_>>();\n"
"        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimeter)\n"
"            .map(round_two_digits)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}\n"
"\n"
"fn main() {}\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Debug, Copy, Clone, PartialEq, Eq)]]\n"
"pub struct struct Point {\n"
"    x: i32,\n"
"    y: i32,\n"
"}\n"
"\n"
"impl Point {\n"
"    pub fn new(x: i32, y: i32) -&gt; Point {\n"
"        Punct { x, y }\n"
"    }\n"
"\n"
"    pub fn magnitude(self) -&gt; f64 {\n"
"        f64::from(self.x.pow(2) + self.y.pow(2)).sqrt()\n"
"    }\n"
"\n"
"    pub fn dist(self, other: Point) -&gt; f64 {\n"
"        (self - other).magnitude()\n"
"    }\n"
"}\n"
"\n"
"impl std::ops::Add for Point {\n"
"    type Output = Self;\n"
"\n"
"    fn add(self, other: Self) -&gt; Self::Output {\n"
"        Self {\n"
"            x: self.x + other.x,\n"
"            y: self.y + other.y,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl std::ops::Sub for Point {\n"
"    type Output = Self;\n"
"\n"
"    fn sub(self, other: Self) -&gt; Self::Output {\n"
"        Self {\n"
"            x: self.x - other.x,\n"
"            y: self.y - other.y,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct struct Polygon {\n"
"    puncte: Vec<Point>,\n"
"}\n"
"\n"
"impl Polygon {\n"
"    pub fn new() -&gt; Polygon {\n"
"        Polygon { points: Vec::new() }\n"
"    }\n"
"\n"
"    pub fn add_point(&amp;mut self, point: Point) {\n"
"        self.points.push(point);\n"
"    }\n"
"\n"
"    pub fn left_most_point(&amp;self) -&gt; Option<Point> {\n"
"        self.points.iter().min_by_key(|p| p.x).copied()\n"
"    }\n"
"\n"
"    pub fn iter(&amp;self) -&gt; impl Iterator<Item = &Point> {\n"
"        self.points.iter()\n"
"    }\n"
"\n"
"    pub fn length(&amp;self) -&gt; f64 {\n"
"        if self.points.is_empty() {\n"
"            return 0.0;\n"
"        }\n"
"\n"
"        let mut result = 0.0;\n"
"        let mut mut last_point = self.points[0];\n"
"        for point in &amp;self.points[1..] {\n"
"            result += last_point.dist(*punct);\n"
"            last_point = *punct;\n"
"        }\n"
"        result += last_point.dist(self.points[0]);\n"
"        rezultat\n"
"        // Alternativ, Iterator::zip() ne permite s캒 iter캒m peste puncte ca "
"perechi\n"
"        // dar trebuie s캒 칥mperechem fiecare punct cu urm캒torul, iar ultimul "
"punct\n"
"        // cu primul punct. Iteratorul zip() se termin캒 de 칥ndat캒 ce unul "
"dintre punctele \n"
"        // iteratorii surs캒 este terminat, un truc ingenios este s캒 combin캒m "
"Iterator::cycle\n"
"        // cu Iterator::skip pentru a crea cel de-al doilea iterator pentru "
"zip 탳i folosind map \n"
"        // 탳i suma pentru a calcula lungimea total캒.\n"
"    }\n"
"}\n"
"\n"
"pub struct Circle {\n"
"    centru: Punct,\n"
"    radius: i32,\n"
"}\n"
"\n"
"impl Circle {\n"
"    pub fn new(center: Point, radius: i32) -&gt; Circle {\n"
"        Cerc { center, radius }\n"
"    }\n"
"\n"
"    pub fn circumference(&amp;self) -&gt; f64 {\n"
"        2.0 * std::f64::consts::PI * f64::from(self.radius)\n"
"    }\n"
"\n"
"    pub fn dist(&amp;self, other: &amp;Self) -&gt; f64 {\n"
"        self.center.dist(other.center)\n"
"    }\n"
"}\n"
"\n"
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}\n"
"\n"
"impl From<Polygon> for Shape {\n"
"    fn from(poly: Polygon) -&gt; Self {\n"
"        Shape::Polygon(poly)\n"
"    }\n"
"}\n"
"\n"
"impl From<Circle> pentru Shape {\n"
"    fn from(circle: Circle) -&gt; Self {\n"
"        Shape::Circle(circle)\n"
"    }\n"
"}\n"
"\n"
"impl Shape {\n"
"    pub fn perimeter(&amp;self) -&gt; f64 {\n"
"        match self {\n"
"            Shape::Polygon(poly) =&gt; poly.length(),\n"
"            Shape::Circle(circle) =&gt; circle.circumference(),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    fn round_two_digits(x: f64) -&gt; f64 {\n"
"        (x * 100.0).round() / 100.0\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_punct_magnitude() {\n"
"        let p1 = Point::new(12, 13);\n"
"        assert_eq!(round_two_digits(p1.magnitude())), 17.69);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_punct_dist() {\n"
"        let p1 = Point::new(10, 10);\n"
"        let p2 = Point::new(14, 13);\n"
"        assert_eq!(round_two_digits(p1.dist(p2))), 5.00);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_punct_add() {\n"
"        let p1 = Point::new(16, 16);\n"
"        let p2 = p1 + Point::new(-4, 3);\n"
"        assert_eq!(p2, Point::new(12, 19));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_poligon_poligon_punctul_cel_mai_st칙nga() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"        assert_eq!(poly.left_most_point(), Some(p1));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_iter() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"\n"
"        let points = poly.iter().cloned().collect::&lt;Vec<_>&gt;();\n"
"        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimetru)\n"
"            .map(round_two_digits)\n"
"            .collect::&lt;Vec<_>&gt;();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}\n"
"\n"
"fn main() {}\n"
"```"

#: src/exercises/day-3/solutions-afternoon.md:1
#, fuzzy
msgid "Day 3 Afternoon Exercises"
msgstr "Ziua 3 Exerci탵ii de dup캒-amiaz캒"

#: src/exercises/day-3/solutions-afternoon.md:5
#, fuzzy
msgid "([back to exercise](safe-ffi-wrapper.md))"
msgstr "([back to exercise](safe-ffi-wrapper.md))"

#: src/exercises/day-3/solutions-afternoon.md:7
#, fuzzy
msgid ""
"```rust\n"
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int};\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    use std::os::raw::{c_long, c_ulong, c_ushort, c_uchar};\n"
"\n"
"    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
"    #[repr(C)]\n"
"    pub struct DIR {\n"
"        _data: [u8; 0],\n"
"        _marker: core::marker::PhantomData<(*mut u8, core::marker::"
"PhantomPinned)>,\n"
"    }\n"
"\n"
"    // Layout according to the Linux man page for readdir(3), where ino_t "
"and\n"
"    // off_t are resolved according to the definitions in\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_ino: c_ulong,\n"
"        pub d_off: c_long,\n"
"        pub d_reclen: c_ushort,\n"
"        pub d_type: c_uchar,\n"
"        pub d_name: [c_char; 256],\n"
"    }\n"
"\n"
"    // Layout according to the macOS man page for dir(5).\n"
"    #[cfg(all(target_os = \"macos\"))]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_fileno: u64,\n"
"        pub d_seekoff: u64,\n"
"        pub d_reclen: u16,\n"
"        pub d_namlen: u16,\n"
"        pub d_type: u8,\n"
"        pub d_name: [c_char; 1024],\n"
"    }\n"
"\n"
"    extern \"C\" {\n"
"        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
"\n"
"        #[cfg(not(all(target_os = \"macos\", target_arch = \"x86_64\")))]\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"\n"
"        // See https://github.com/rust-lang/libc/issues/414 and the section "
"on\n"
"        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).\n"
"        //\n"
"        // \"Platforms that existed before these updates were available\" "
"refers\n"
"        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and "
"PowerPC.\n"
"        #[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n"
"        #[link_name = \"readdir$INODE64\"]\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"\n"
"        pub fn closedir(s: *mut DIR) -> c_int;\n"
"    }\n"
"}\n"
"\n"
"use std::ffi::{CStr, CString, OsStr, OsString};\n"
"use std::os::unix::ffi::OsStrExt;\n"
"\n"
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}\n"
"\n"
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
"        let path = CString::new(path).map_err(|err| format!(\"Invalid path: "
"{err}\"))?;\n"
"        // SAFETY: path.as_ptr() cannot be NULL.\n"
"        let dir = unsafe { ffi::opendir(path.as_ptr()) };\n"
"        if dir.is_null() {\n"
"            Err(format!(\"Could not open {:?}\", path))\n"
"        } else {\n"
"            Ok(DirectoryIterator { path, dir })\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Keep calling readdir until we get a NULL pointer back.\n"
"        // SAFETY: self.dir is never NULL.\n"
"        let dirent = unsafe { ffi::readdir(self.dir) };\n"
"        if dirent.is_null() {\n"
"            // We have reached the end of the directory.\n"
"            return None;\n"
"        }\n"
"        // SAFETY: dirent is not NULL and dirent.d_name is NUL\n"
"        // terminated.\n"
"        let d_name = unsafe { CStr::from_ptr((*dirent).d_name.as_ptr()) };\n"
"        let os_str = OsStr::from_bytes(d_name.to_bytes());\n"
"        Some(os_str.to_owned())\n"
"    }\n"
"}\n"
"\n"
"impl Drop for DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Call closedir as needed.\n"
"        if !self.dir.is_null() {\n"
"            // SAFETY: self.dir is not NULL.\n"
"            if unsafe { ffi::closedir(self.dir) } != 0 {\n"
"                panic!(\"Could not close {:?}\", self.path);\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"    use std::error::Error;\n"
"\n"
"    #[test]\n"
"    fn test_nonexisting_directory() {\n"
"        let iter = DirectoryIterator::new(\"no-such-directory\");\n"
"        assert!(iter.is_err());\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_empty_directory() -> Result<(), Box<dyn Error>> {\n"
"        let tmp = tempfile::TempDir::new()?;\n"
"        let iter = DirectoryIterator::new(\n"
"            tmp.path().to_str().ok_or(\"Non UTF-8 character in path\")?,\n"
"        )?;\n"
"        let mut entries = iter.collect::<Vec<_>>();\n"
"        entries.sort();\n"
"        assert_eq!(entries, &[\".\", \"..\"]);\n"
"        Ok(())\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_nonempty_directory() -> Result<(), Box<dyn Error>> {\n"
"        let tmp = tempfile::TempDir::new()?;\n"
"        std::fs::write(tmp.path().join(\"foo.txt\"), \"The Foo "
"Diaries\\n\")?;\n"
"        std::fs::write(tmp.path().join(\"bar.png\"), \"<PNG>\\n\")?;\n"
"        std::fs::write(tmp.path().join(\"crab.rs\"), \"//! Crab\\n\")?;\n"
"        let iter = DirectoryIterator::new(\n"
"            tmp.path().to_str().ok_or(\"Non UTF-8 character in path\")?,\n"
"        )?;\n"
"        let mut entries = iter.collect::<Vec<_>>();\n"
"        entries.sort();\n"
"        assert_eq!(entries, &[\".\", \"..\", \"bar.png\", \"crab.rs\", \"foo."
"txt\"]);\n"
"        Ok(())\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int};\n"
"    #[cfg(not(target_os = \"macos\"))]]\n"
"    use std::os::raw::{c_long, c_ulong, c_ushort, c_uchar};\n"
"\n"
"    // Tip opac. A se vedea https://doc.rust-lang.org/nomicon/ffi.html.\n"
"    #[repr(C)]\n"
"    pub struct struct DIR {\n"
"        _data: [u8; 0],\n"
"        _marker: core::marker::PhantomData<(*mut u8, core::marker::"
"PhantomPinned)>,\n"
"    }\n"
"\n"
"    // Dispunere 칥n conformitate cu pagina de manual Linux pentru "
"readdir(3), unde ino_t 탳i\n"
"    // off_t sunt rezolvate 칥n conformitate cu defini탵iile din\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"
"    #[cfg(not(target_os = \"macos\"))]]\n"
"    #[repr(C)]\n"
"    pub struct struct dirent {\n"
"        pub d_ino: c_ulong,\n"
"        pub d_off: c_long,\n"
"        pub d_reclen: c_ushort,\n"
"        pub d_type: c_uchar,\n"
"        pub d_name: [c_char; 256],\n"
"    }\n"
"\n"
"    // Dispunere 칥n conformitate cu pagina de manual macOS pentru dir(5).\n"
"    #[cfg(all(target_os = \"macos\"))]]\n"
"    #[repr(C)]\n"
"    pub struct struct dirent {\n"
"        pub d_fileno: u64,\n"
"        pub d_seekoff: u64,\n"
"        pub d_reclen: u16,\n"
"        pub d_namlen: u16,\n"
"        pub d_type: u8,\n"
"        pub d_name: [c_char; 1024],\n"
"    }\n"
"\n"
"    extern \"C\" {\n"
"        pub fn opendir(s: *const c_char) -&gt; *mut DIR;\n"
"\n"
"        #[cfg(not(all(target_os = \"macos\", target_arch = "
"\"x86_64\")))])]]\n"
"        pub fn readdir(s: *mut DIR) -&gt; *const dirent;\n"
"\n"
"        // A se vedea https://github.com/rust-lang/libc/issues/414 탳i "
"sec탵iunea privind\n"
"        // _DARWIN_FEATURE_64_BIT_INODE 칥n pagina de manual macOS pentru "
"stat(2).\n"
"        //\n"
"        // \"Platformele care existau 칥nainte ca aceste actualiz캒ri s캒 fie "
"disponibile\" se refer캒 la\n"
"        // la macOS (spre deosebire de iOS / wearOS / etc.) pe Intel 탳i "
"PowerPC.\n"
"        #[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]]\n"
"        #[link_name = \"readdir$INODE64\"]\n"
"        pub fn readdir(s: *mut DIR) -&gt; *const dirent;\n"
"\n"
"        pub fn closedir(s: *mut DIR) -&gt; c_int;\n"
"    }\n"
"}\n"
"\n"
"use std::ffi::{CStr, CString, OsStr, OsString};\n"
"use std::os::unix::ffi::OsStrExt;\n"
"\n"
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}\n"
"\n"
"impl DirectoryIterator {\n"
"    fn new(path: &amp;str) -&gt; Result<DirectoryIterator, String> {\n"
"        // Apela탵i opendir 탳i returna탵i o valoare Ok dac캒 a func탵ionat,\n"
"        // 칥n caz contrar, returneaz캒 Err cu un mesaj.\n"
"        let path = CString::new(path).map_err(|err| format!(\"Invalid path: "
"{err}\")))?;\n"
"        // SAFETY: path.as_ptr() nu poate fi NULL.\n"
"        let dir = unsafe { ffi::opendir(path.as_ptr())) };\n"
"        if dir.is_null() {\n"
"            Err(format!(\"Could not open {:?}\", path))\n"
"        } else {\n"
"            Ok(DirectoryIterator { path, dir })\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl Iterator pentru DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&amp;mut self) -&gt; Option<OsString> {\n"
"        // Continua탵i s캒 apela탵i readdir p칙n캒 c칙nd primim 칥napoi un pointer "
"NULL.\n"
"        // SAFETY: self.dir nu este niciodat캒 NULL.\n"
"        let dirent = unsafe { ffi::readdir(self.dir) };\n"
"        if dirent.is_null() {\n"
"            // Am ajuns la sf칙r탳itul directorului.\n"
"            return None;\n"
"        }\n"
"        // SAFETY: dirent nu este NULL 탳i dirent.d_name este NUL\n"
"        // terminat.\n"
"        let d_name = unsafe { CStr::from_ptr((*dirent).d_name.as_ptr())) };\n"
"        let os_str = OsStr::from_bytes(d_name.to_bytes());\n"
"        Some(os_str.to_owned())\n"
"    }\n"
"}\n"
"\n"
"impl Drop for DirectoryIterator {\n"
"    fn drop(&amp;mut self) {\n"
"        // Cheam캒 closedir dup캒 cum este necesar.\n"
"        if !self.dir.is_null() {\n"
"            // SAFETY: self.dir nu este NULL.\n"
"            if unsafe { ffi::closedir(self.dir) } != 0 {\n"
"                panic!(\"Could not close {:?}\", self.path);\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"fn main() -&gt; Rezultat<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"files: {:#?}\", iter.collect::&lt;Vec<_>&gt;());\n"
"    Ok((())\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"    use std::error::Error;\n"
"\n"
"    #[test]\n"
"    fn test_nonexisting_directory() {\n"
"        let iter = DirectoryIterator::new(\"nu-nu-este-un-directoriu\");\n"
"        assert!(iter.is_err());\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_teste_directoriu_vid() -&gt; Result&lt;(), Box<dyn Error>&gt; {\n"
"        let tmp = tempfile::TempDir::new()?;\n"
"        let iter = DirectoryIterator::new(\n"
"            tmp.path().to_str().ok_or(\"Non UTF-8 character in path\")?,\n"
"        )?;\n"
"        let mut entries = iter.collect::&lt;Vec<_>&gt;();\n"
"        entries.sort();\n"
"        assert_eq!(entries, &amp;[\".\", \"...\"]);\n"
"        Ok((())\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_test_nonempty_directory() -&gt; Result&lt;(), Box<dyn Error>&gt; "
"{\n"
"        let tmp = tempfile::TempDir::new()?;\n"
"        std::fs::write(tmp.path().join(\"foo.txt\"), \"The Foo "
"Diaries\\n\")?\n"
"        std::fs::write(tmp.path().join(\"bar.png\"), \"<PNG>\\n\")?;\n"
"        std::fs::write(tmp.path().join(\"crab.rs\"), \"//! Crab\\n\")?;\n"
"        let iter = DirectoryIterator::new(\n"
"            tmp.path().to_str().ok_or(\"Non UTF-8 character in path\")?,\n"
"        )?;\n"
"        let mut entries = iter.collect::&lt;Vec<_>&gt;();\n"
"        entries.sort();\n"
"        assert_eq!(entries, &amp;[\".\", \"...\", \"bar.png\", \"crab.rs\", "
"\"foo.txt\"]);\n"
"        Ok((())\n"
"    }\n"
"}\n"
"```"

#: src/exercises/bare-metal/solutions-morning.md:1
#, fuzzy
msgid "Bare Metal Rust Morning Exercise"
msgstr "Exerci탵iu de diminea탵캒 Bare Metal Rust"

#: src/exercises/bare-metal/solutions-morning.md:5
#, fuzzy
msgid "([back to exercise](compass.md))"
msgstr "([back to exercise](compass.md))"

#: src/exercises/bare-metal/solutions-morning.md:7
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use core::fmt::Write;\n"
"use cortex_m_rt::entry;\n"
"use core::cmp::{max, min};\n"
"use lsm303agr::{AccelOutputDataRate, Lsm303agr, MagOutputDataRate};\n"
"use microbit::display::blocking::Display;\n"
"use microbit::hal::prelude::*;\n"
"use microbit::hal::twim::Twim;\n"
"use microbit::hal::uarte::{Baudrate, Parity, Uarte};\n"
"use microbit::hal::Timer;\n"
"use microbit::pac::twim0::frequency::FREQUENCY_A;\n"
"use microbit::Board;\n"
"\n"
"const COMPASS_SCALE: i32 = 30000;\n"
"const ACCELEROMETER_SCALE: i32 = 700;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let board = Board::take().unwrap();\n"
"\n"
"    // Configure serial port.\n"
"    let mut serial = Uarte::new(\n"
"        board.UARTE0,\n"
"        board.uart.into(),\n"
"        Parity::EXCLUDED,\n"
"        Baudrate::BAUD115200,\n"
"    );\n"
"\n"
"    // Set up the I2C controller and Inertial Measurement Unit.\n"
"    writeln!(serial, \"Setting up IMU...\").unwrap();\n"
"    let i2c = Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::"
"K100);\n"
"    let mut imu = Lsm303agr::new_with_i2c(i2c);\n"
"    imu.init().unwrap();\n"
"    imu.set_mag_odr(MagOutputDataRate::Hz50).unwrap();\n"
"    imu.set_accel_odr(AccelOutputDataRate::Hz50).unwrap();\n"
"    let mut imu = imu.into_mag_continuous().ok().unwrap();\n"
"\n"
"    // Set up display and timer.\n"
"    let mut timer = Timer::new(board.TIMER0);\n"
"    let mut display = Display::new(board.display_pins);\n"
"\n"
"    let mut mode = Mode::Compass;\n"
"    let mut button_pressed = false;\n"
"\n"
"    writeln!(serial, \"Ready.\").unwrap();\n"
"\n"
"    loop {\n"
"        // Read compass data and log it to the serial port.\n"
"        while !(imu.mag_status().unwrap().xyz_new_data\n"
"            && imu.accel_status().unwrap().xyz_new_data)\n"
"        {}\n"
"        let compass_reading = imu.mag_data().unwrap();\n"
"        let accelerometer_reading = imu.accel_data().unwrap();\n"
"        writeln!(\n"
"            serial,\n"
"            \"{},{},{}\\t{},{},{}\",\n"
"            compass_reading.x,\n"
"            compass_reading.y,\n"
"            compass_reading.z,\n"
"            accelerometer_reading.x,\n"
"            accelerometer_reading.y,\n"
"            accelerometer_reading.z,\n"
"        )\n"
"        .unwrap();\n"
"\n"
"        let mut image = [[0; 5]; 5];\n"
"        let (x, y) = match mode {\n"
"            Mode::Compass => (\n"
"                scale(-compass_reading.x, -COMPASS_SCALE, COMPASS_SCALE, 0, "
"4) as usize,\n"
"                scale(compass_reading.y, -COMPASS_SCALE, COMPASS_SCALE, 0, "
"4) as usize,\n"
"            ),\n"
"            Mode::Accelerometer => (\n"
"                scale(\n"
"                    accelerometer_reading.x,\n"
"                    -ACCELEROMETER_SCALE,\n"
"                    ACCELEROMETER_SCALE,\n"
"                    0,\n"
"                    4,\n"
"                ) as usize,\n"
"                scale(\n"
"                    -accelerometer_reading.y,\n"
"                    -ACCELEROMETER_SCALE,\n"
"                    ACCELEROMETER_SCALE,\n"
"                    0,\n"
"                    4,\n"
"                ) as usize,\n"
"            ),\n"
"        };\n"
"        image[y][x] = 255;\n"
"        display.show(&mut timer, image, 100);\n"
"\n"
"        // If button A is pressed, switch to the next mode and briefly blink "
"all LEDs on.\n"
"        if board.buttons.button_a.is_low().unwrap() {\n"
"            if !button_pressed {\n"
"                mode = mode.next();\n"
"                display.show(&mut timer, [[255; 5]; 5], 200);\n"
"            }\n"
"            button_pressed = true;\n"
"        } else {\n"
"            button_pressed = false;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n"
"enum Mode {\n"
"    Compass,\n"
"    Accelerometer,\n"
"}\n"
"\n"
"impl Mode {\n"
"    fn next(self) -> Self {\n"
"        match self {\n"
"            Self::Compass => Self::Accelerometer,\n"
"            Self::Accelerometer => Self::Compass,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"fn scale(value: i32, min_in: i32, max_in: i32, min_out: i32, max_out: i32) -"
"> i32 {\n"
"    let range_in = max_in - min_in;\n"
"    let range_out = max_out - min_out;\n"
"    cap(\n"
"        min_out + range_out * (value - min_in) / range_in,\n"
"        min_out,\n"
"        max_out,\n"
"    )\n"
"}\n"
"\n"
"fn cap(value: i32, min_value: i32, max_value: i32) -> i32 {\n"
"    max(min_value, min(value, max_value))\n"
"}\n"
"```"
msgstr ""
"```rust,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use core::fmt::Write;\n"
"use cortex_m_rt::entry;\n"
"use core::cmp::{max, min};\n"
"use lsm303agr::{AccelOutputDataRate, Lsm303agr, MagOutputDataRate};\n"
"use microbit::display::blocking::Display;\n"
"use microbit::hal::prelude::*;\n"
"use microbit::hal::twim::Twim;\n"
"use microbit::hal::uarte::{Baudrate, Parity, Uarte};\n"
"use microbit::hal::Timer;\n"
"use microbit::pac::twim0::frequency::FREQUENCY_A;\n"
"use microbit::Board;\n"
"\n"
"const COMPASS_SCALE: i32 = 30000;\n"
"const ACCELEROMETER_SCALE: i32 = 700;\n"
"\n"
"#[intrare]\n"
"fn main() -> ! {\n"
"    let board = Board::take().unwrap();\n"
"\n"
"    // Configura탵i portul serial.\n"
"    let mut serial = Uarte::new(\n"
"        board.UARTE0,\n"
"        board.uart.into(),\n"
"        Parity::EXCLUDED,\n"
"        Baudrate::BAUD115200,\n"
"    );\n"
"\n"
"    // Configura탵i controlerul I2C 탳i unitatea de m캒surare iner탵ial캒.\n"
"    writeln!(serial, \"Setting up IMU...\").unwrap();\n"
"    let i2c = Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::"
"K100);\n"
"    let mut imu = Lsm303agr::new_with_i2c(i2c);\n"
"    imu.init().unwrap();\n"
"    imu.set_mag_odr(MagOutputDataRate::Hz50).unwrap();\n"
"    imu.set_accel_odr(AccelOutputDataRate::Hz50).unwrap();\n"
"    let mut imu = imu.into_mag_continuous().ok().unwrap();\n"
"\n"
"    // Configura탵i afi탳ajul 탳i cronometrul.\n"
"    let mut timer = Timer::new(board.TIMER0);\n"
"    let mut display = Display::new(board.display_pins);\n"
"\n"
"    let mut mode = Mode::Compass;\n"
"    let mut button_pressed = false;\n"
"\n"
"    writeln!(serial, \"Ready.\").unwrap();\n"
"\n"
"    loop {\n"
"        // Citi탵i datele busolei 탳i 칥nregistra탵i-le pe portul serial.\n"
"        while !(imu.mag_status().unwrap().xyz_new_data\n"
"            && imu.accel_status().unwrap().xyz_new_data)\n"
"        {}\n"
"        let compass_reading = imu.mag_data().unwrap();\n"
"        let accelerometer_reading = imu.accel_data().unwrap();\n"
"        writeln!(\n"
"            serial,\n"
"            \"{},{},{}\\t{},{},{}\",\n"
"            compass_reading.x,\n"
"            compass_reading.y,\n"
"            compass_reading.z,\n"
"            accelerometer_reading.x,\n"
"            accelerometer_reading.y,\n"
"            accelerometer_reading.z,\n"
"        )\n"
"        .unwrap();\n"
"\n"
"        let mut image = [[0; 5]; 5];\n"
"        let (x, y) = match mode {\n"
"            Mode::Compass => (\n"
"                scale(-compass_reading.x, -COMPASS_SCALE, COMPASS_SCALE, 0, "
"4) as usize,\n"
"                scale(compass_reading.y, -COMPASS_SCALE, COMPASS_SCALE, 0, "
"4) as usize,\n"
"            ),\n"
"            Mode::Accelerometer => (\n"
"                scale(\n"
"                    accelerometer_reading.x,\n"
"                    -ACCELEROMETER_SCALE,\n"
"                    ACCELEROMETER_SCALE,\n"
"                    0,\n"
"                    4,\n"
"                ) ca usize,\n"
"                scale(\n"
"                    -accelerometer_reading.y,\n"
"                    -ACCELEROMETER_SCALE,\n"
"                    ACCELEROMETER_SCALE,\n"
"                    0,\n"
"                    4,\n"
"                ) ca usize,\n"
"            ),\n"
"        };\n"
"        image[y][x] = 255;\n"
"        display.show(&mut timer, imagine, 100);\n"
"\n"
"        // Dac캒 este ap캒sat butonul A, se trece la modul urm캒tor 탳i se "
"aprind pentru scurt timp toate LED-urile.\n"
"        if board.buttons.button_a.is_low().unwrap() {\n"
"            if !button_pressed {\n"
"                mode = mode.next();\n"
"                display.show(&mut timer, [[255; 5]; 5]; 5], 200);\n"
"            }\n"
"            button_pressed = true;\n"
"        } else {\n"
"            button_pressed = false;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#[derive(Copy, Clone, Debug, Eq, PartialEq)]]\n"
"enum Mode {\n"
"    Compass,\n"
"    Accelerometru,\n"
"}\n"
"\n"
"impl Mode {\n"
"    fn next(self) -> Self {\n"
"        se potrive탳te cu self {\n"
"            Self::Compass => Self::Accelerometer,\n"
"            Self::Accelerometer => Self::Compass,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"fn scale(value: i32, min_in: i32, max_in: i32, min_out: i32, max_out: i32) -"
"> i32 {\n"
"    let range_in = max_in - min_in;\n"
"    let range_out = max_out - min_out;\n"
"    cap(\n"
"        min_out + range_out * (valoare - min_in) / range_in,\n"
"        min_out,\n"
"        max_out,\n"
"    )\n"
"}\n"
"\n"
"fn cap(value: i32, min_value: i32, max_value: i32) -> i32 {\n"
"    max(min_valoare, min(valoare, max_valoare))\n"
"}\n"
"```"

#: src/exercises/bare-metal/solutions-afternoon.md:5
#, fuzzy
msgid "([back to exercise](rtc.md))"
msgstr "([back to exercise](rtc.md))"

#: src/exercises/bare-metal/solutions-afternoon.md:7
#, fuzzy
msgid "_main.rs_:"
msgstr "_main.rs_:"

#: src/exercises/bare-metal/solutions-afternoon.md:9
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"mod exceptions;\n"
"mod logger;\n"
"mod pl011;\n"
"mod pl031;\n"
"\n"
"use crate::pl031::Rtc;\n"
"use arm_gic::gicv3::{IntId, Trigger};\n"
"use arm_gic::{irq_enable, wfi};\n"
"use chrono::{TimeZone, Utc};\n"
"use core::hint::spin_loop;\n"
"use crate::pl011::Uart;\n"
"use arm_gic::gicv3::GicV3;\n"
"use core::panic::PanicInfo;\n"
"use log::{error, info, trace, LevelFilter};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Base addresses of the GICv3.\n"
"const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;\n"
"const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 as _;\n"
"\n"
"/// Base address of the primary PL011 UART.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"\n"
"/// Base address of the PL031 RTC.\n"
"const PL031_BASE_ADDRESS: *mut u32 = 0x901_0000 as _;\n"
"/// The IRQ used by the PL031 RTC.\n"
"const PL031_IRQ: IntId = IntId::spi(2);\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 "
"device,\n"
"    // and nothing else accesses that address range.\n"
"    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"    logger::init(uart, LevelFilter::Trace).unwrap();\n"
"\n"
"    info!(\"main({:#x}, {:#x}, {:#x}, {:#x})\", x0, x1, x2, x3);\n"
"\n"
"    // Safe because `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the "
"base\n"
"    // addresses of a GICv3 distributor and redistributor respectively, and\n"
"    // nothing else accesses those address ranges.\n"
"    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, "
"GICR_BASE_ADDRESS) };\n"
"    gic.setup();\n"
"\n"
"    // Safe because `PL031_BASE_ADDRESS` is the base address of a PL031 "
"device,\n"
"    // and nothing else accesses that address range.\n"
"    let mut rtc = unsafe { Rtc::new(PL031_BASE_ADDRESS) };\n"
"    let timestamp = rtc.read();\n"
"    let time = Utc.timestamp_opt(timestamp.into(), 0).unwrap();\n"
"    info!(\"RTC: {time}\");\n"
"\n"
"    GicV3::set_priority_mask(0xff);\n"
"    gic.set_interrupt_priority(PL031_IRQ, 0x80);\n"
"    gic.set_trigger(PL031_IRQ, Trigger::Level);\n"
"    irq_enable();\n"
"    gic.enable_interrupt(PL031_IRQ, true);\n"
"\n"
"    // Wait for 3 seconds, without interrupts.\n"
"    let target = timestamp + 3;\n"
"    rtc.set_match(target);\n"
"    info!(\n"
"        \"Waiting for {}\",\n"
"        Utc.timestamp_opt(target.into(), 0).unwrap()\n"
"    );\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    while !rtc.matched() {\n"
"        spin_loop();\n"
"    }\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    info!(\"Finished waiting\");\n"
"\n"
"    // Wait another 3 seconds for an interrupt.\n"
"    let target = timestamp + 6;\n"
"    info!(\n"
"        \"Waiting for {}\",\n"
"        Utc.timestamp_opt(target.into(), 0).unwrap()\n"
"    );\n"
"    rtc.set_match(target);\n"
"    rtc.clear_interrupt();\n"
"    rtc.enable_interrupt(true);\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    while !rtc.interrupt_pending() {\n"
"        wfi();\n"
"    }\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    info!(\"Finished waiting\");\n"
"\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[panic_handler]\n"
"fn panic(info: &PanicInfo) -> ! {\n"
"    error!(\"{info}\");\n"
"    system_off::<Hvc>().unwrap();\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""
"```rust,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"excep탵ii mod;\n"
"mod logger;\n"
"mod pl011;\n"
"mod pl031;\n"
"\n"
"use crate::pl031::Rtc;\n"
"use arm_gic::gicv3::{IntId, Trigger};\n"
"use arm_gic::{irq_enable, wfi};\n"
"use chrono::{TimeZone, Utc};\n"
"use core::hint::spin_loop;\n"
"use crate::pl011::Uart;\n"
"use arm_gic::gicv3::GicV3;\n"
"use core::panic::PanicInfo;\n"
"use log::{error, info, trace, LevelFilter};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Adresele de baz캒 ale GICv3.\n"
"const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;\n"
"const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 ca _;\n"
"\n"
"/// Adresa de baz캒 a UART primar캒 PL011.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"\n"
"/// Adresa de baz캒 a RTC PL031.\n"
"const PL031_BASE_ADDRESS: *mut u32 = 0x901_0000 as _;\n"
"/// IRQ-ul utilizat de PL031 RTC.\n"
"const PL031_IRQ: IntId = IntId::spi(2);\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Sigur, deoarece `PL011_BASE_ADDRESS` este adresa de baz캒 a unui "
"dispozitiv PL011,\n"
"    // 탳i nimic altceva nu acceseaz캒 acest interval de adrese.\n"
"    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"    logger::init(uart, LevelFilter::Trace).unwrap();\n"
"\n"
"    info!(\"main({:#x}, {:#x}, {:#x}, {:#x})\", x0, x1, x2, x3);\n"
"\n"
"    // Sigur, deoarece `GICD_BASE_ADDRESS` 탳i `GICR_BASE_ADDRESS` reprezint캒 "
"baza\n"
"    // adrese ale unui distribuitor 탳i, respectiv, redistribuitor GICv3, "
"iar\n"
"    // nimic altceva nu acceseaz캒 aceste intervale de adrese.\n"
"    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, "
"GICR_BASE_ADDRESS) };\n"
"    gic.setup();\n"
"\n"
"    // Sigur, deoarece `PL031_BASE_ADDRESS` este adresa de baz캒 a unui "
"dispozitiv PL031,\n"
"    // 탳i nimic altceva nu acceseaz캒 acest interval de adrese.\n"
"    let mut rtc = unsafe { Rtc::new(PL031_BASE_ADDRESS) };\n"
"    let timestamp = rtc.read();\n"
"    let time = Utc.timestamp_opt(timestamp.into(), 0).unwrap();\n"
"    info!(\"RTC: {time}\");\n"
"\n"
"    GicV3::set_priority_mask(0xff);\n"
"    gic.set_interrupt_priority(PL031_IRQ, 0x80);\n"
"    gic.set_trigger(PL031_IRQ, Trigger::Level);\n"
"    irq_enable();\n"
"    gic.enable_interrupt(PL031_IRQ, true);\n"
"\n"
"    // A탳tepta탵i timp de 3 secunde, f캒r캒 칥ntreruperi.\n"
"    let target = timestamp + 3;\n"
"    rtc.set_match(target);\n"
"    info!(\n"
"        \"Waiting for {}\",\n"
"        Utc.timestamp_opt(target.into(), 0).unwrap()\n"
"    );\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    while !rtc.matched() {\n"
"        spin_loop();\n"
"    }\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    info!(\"Finished waiting\");\n"
"\n"
"    // A탳tepta탵i 칥nc캒 3 secunde pentru o 칥ntrerupere.\n"
"    let target = timestamp + 6;\n"
"    info!(\n"
"        \"Waiting for {}\",\n"
"        Utc.timestamp_opt(target.into(), 0).unwrap()\n"
"    );\n"
"    rtc.set_match(target);\n"
"    rtc.clear_interrupt();\n"
"    rtc.enable_interrupt(true);\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    while !rtc.interrupt_pending() {\n"
"        wfi();\n"
"    }\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    info!(\"Finished waiting\");\n"
"\n"
"    system_off:::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[panic_handler]\n"
"fn panic(info: &amp;PanicInfo) -&gt; ! {\n"
"    error!(\"{info}\");\n"
"    system_off:::<Hvc>().unwrap();\n"
"    bucla {}\n"
"}\n"
"```"

#: src/exercises/bare-metal/solutions-afternoon.md:127
#, fuzzy
msgid "_pl031.rs_:"
msgstr "_pl031.rs_:"

#: src/exercises/bare-metal/solutions-afternoon.md:129
#, fuzzy
msgid ""
"```rust\n"
"use core::ptr::{addr_of, addr_of_mut};\n"
"\n"
"#[repr(C, align(4))]\n"
"struct Registers {\n"
"    /// Data register\n"
"    dr: u32,\n"
"    /// Match register\n"
"    mr: u32,\n"
"    /// Load register\n"
"    lr: u32,\n"
"    /// Control register\n"
"    cr: u8,\n"
"    _reserved0: [u8; 3],\n"
"    /// Interrupt Mask Set or Clear register\n"
"    imsc: u8,\n"
"    _reserved1: [u8; 3],\n"
"    /// Raw Interrupt Status\n"
"    ris: u8,\n"
"    _reserved2: [u8; 3],\n"
"    /// Masked Interrupt Status\n"
"    mis: u8,\n"
"    _reserved3: [u8; 3],\n"
"    /// Interrupt Clear Register\n"
"    icr: u8,\n"
"    _reserved4: [u8; 3],\n"
"}\n"
"\n"
"/// Driver for a PL031 real-time clock.\n"
"#[derive(Debug)]\n"
"pub struct Rtc {\n"
"    registers: *mut Registers,\n"
"}\n"
"\n"
"impl Rtc {\n"
"    /// Constructs a new instance of the RTC driver for a PL031 device at "
"the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of "
"a\n"
"    /// PL031 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
"    pub unsafe fn new(base_address: *mut u32) -> Self {\n"
"        Self {\n"
"            registers: base_address as *mut Registers,\n"
"        }\n"
"    }\n"
"\n"
"    /// Reads the current RTC value.\n"
"    pub fn read(&self) -> u32 {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        unsafe { addr_of!((*self.registers).dr).read_volatile() }\n"
"    }\n"
"\n"
"    /// Writes a match value. When the RTC value matches this then an "
"interrupt\n"
"    /// will be generated (if it is enabled).\n"
"    pub fn set_match(&mut self, value: u32) {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        unsafe { addr_of_mut!((*self.registers).mr).write_volatile(value) }\n"
"    }\n"
"\n"
"    /// Returns whether the match register matches the RTC value, whether or "
"not\n"
"    /// the interrupt is enabled.\n"
"    pub fn matched(&self) -> bool {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        let ris = unsafe { addr_of!((*self.registers).ris)."
"read_volatile() };\n"
"        (ris & 0x01) != 0\n"
"    }\n"
"\n"
"    /// Returns whether there is currently an interrupt pending.\n"
"    ///\n"
"    /// This should be true if and only if `matched` returns true and the\n"
"    /// interrupt is masked.\n"
"    pub fn interrupt_pending(&self) -> bool {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        let ris = unsafe { addr_of!((*self.registers).mis)."
"read_volatile() };\n"
"        (ris & 0x01) != 0\n"
"    }\n"
"\n"
"    /// Sets or clears the interrupt mask.\n"
"    ///\n"
"    /// When the mask is true the interrupt is enabled; when it is false "
"the\n"
"    /// interrupt is disabled.\n"
"    pub fn enable_interrupt(&mut self, mask: bool) {\n"
"        let imsc = if mask { 0x01 } else { 0x00 };\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        unsafe { addr_of_mut!((*self.registers).imsc)."
"write_volatile(imsc) }\n"
"    }\n"
"\n"
"    /// Clears a pending interrupt, if any.\n"
"    pub fn clear_interrupt(&mut self) {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        unsafe { addr_of_mut!((*self.registers).icr).write_volatile(0x01) }\n"
"    }\n"
"}\n"
"\n"
"// Safe because it just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
"unsafe impl Send for Rtc {}\n"
"```"
msgstr ""
"```rust\n"
"use core::ptr::{addr_of, addr_of_mut};\n"
"\n"
"#[repr(C, align(4))]\n"
"struct Registers {\n"
"    /// Registru de date\n"
"    dr: u32,\n"
"    /// Registru de coresponden탵캒\n"
"    mr: u32,\n"
"    /// Registru de 칥nc캒rcare\n"
"    lr: u32,\n"
"    /// Registrul de control\n"
"    cr: u8,\n"
"    _reserved0: [u8; 3],\n"
"    /// Registru de setare sau 탳tergere a m캒탳tii de 칥ntrerupere\n"
"    imsc: u8,\n"
"    _reserved1: [u8; 3],\n"
"    /// Starea brut캒 a 칥ntreruperii\n"
"    ris: u8,\n"
"    _reserved2: [u8; 3],\n"
"    /// Starea de 칥ntrerupere mascat캒\n"
"    mis: u8,\n"
"    _reserved3: [u8; 3],\n"
"    /// Registrul de 탳tergere a 칥ntreruperii\n"
"    icr: u8,\n"
"    _reserved4: [u8; 3],\n"
"}\n"
"\n"
"/// Driver pentru un ceas de timp real PL031.\n"
"#[derive(Debug)]\n"
"pub struct Rtc {\n"
"    registers: *mut Registers,\n"
"}\n"
"\n"
"impl Rtc {\n"
"    /// Construie탳te o nou캒 instan탵캒 a driverului RTC pentru un dispozitiv "
"PL031 la nivelul\n"
"    /// adresa de baz캒 dat캒.\n"
"    ///\n"
"    /// # Siguran탵캒\n"
"    ///\n"
"    /// Adresa de baz캒 dat캒 trebuie s캒 indice registrele de control MMIO ale "
"unui dispozitiv de tip\n"
"    /// dispozitiv PL031, care trebuie s캒 fie mapate 칥n spa탵iul de adrese al "
"procesului\n"
"    /// ca memorie a dispozitivului 탳i s캒 nu aib캒 alte alias-uri.\n"
"    pub unsafe fn new(base_address: *mut u32) -> Self {\n"
"        Self {\n"
"            registers: base_address as *mut Registers,\n"
"        }\n"
"    }\n"
"\n"
"    /// Cite탳te valoarea RTC curent캒.\n"
"    pub fn read(&self) -> u32 {\n"
"        // Sigur, deoarece 탳tim c캒 self.registers indic캒 controlul\n"
"        // registre ale unui dispozitiv PL031 care este mapat "
"corespunz캒tor.\n"
"        unsafe { addr_of!((*self.registers).dr).read_volatile() } }\n"
"    }\n"
"\n"
"    /// Scrie o valoare de potrivire. Atunci c칙nd valoarea RTC se potrive탳te "
"cu aceasta, atunci o 칥ntrerupere\n"
"    /// va fi generat캒 (dac캒 este activat캒).\n"
"    pub fn set_match(&mut self, value: u32) {\n"
"        // Sigur, deoarece 탳tim c캒 self.registers indic캒 controlul\n"
"        // registre ale unui dispozitiv PL031 care este mapat "
"corespunz캒tor.\n"
"        unsafe { addr_of_mut!((*self.registers).mr)."
"write_volatile(value) } }\n"
"    }\n"
"\n"
"    /// Returneaz캒 dac캒 registrul de potrivire se potrive탳te cu valoarea "
"RTC, indiferent dac캒 este sau nu\n"
"    /// 칥ntreruperea este activat캒.\n"
"    pub fn matched(&self) -> bool {\n"
"        // Sigur, deoarece 탳tim c캒 self.registers indic캒 controlul\n"
"        // registre ale unui dispozitiv PL031 care este mapat "
"corespunz캒tor.\n"
"        let ris = unsafe { addr_of!((*self.registers).ris)."
"read_volatile() };\n"
"        (ris & 0x01) != 0\n"
"    }\n"
"\n"
"    /// Returneaz캒 dac캒 exist캒 칥n prezent o 칥ntrerupere 칥n a탳teptare.\n"
"    ///\n"
"    /// Acest lucru ar trebui s캒 fie adev캒rat dac캒 탳i numai dac캒 `matched` "
"returneaz캒 true 탳i dac캒\n"
"    /// 칥ntreruperea este mascat캒.\n"
"    pub fn interrupt_pending(&self) -> bool {\n"
"        // Sigur, deoarece 탳tim c캒 self.registers indic캒 controlul\n"
"        // registre ale unui dispozitiv PL031 care este mapat "
"corespunz캒tor.\n"
"        let ris = unsafe { addr_of!((*self.registers).mis)."
"read_volatile() };\n"
"        (ris & 0x01) != 0\n"
"    }\n"
"\n"
"    /// Seteaz캒 sau 탳terge masca de 칥ntrerupere.\n"
"    ///\n"
"    /// C칙nd masca este adev캒rat캒, 칥ntreruperea este activat캒; c칙nd este "
"fals캒, 칥ntreruperea este activat캒\n"
"    /// 칥ntreruperea este dezactivat캒.\n"
"    pub fn enable_interrupt(&mut self, mask: bool) {\n"
"        let imsc = if mask { 0x01 } else { 0x00 };\n"
"        // Sigur, deoarece 탳tim c캒 self.registers indic캒 controlul\n"
"        // registre ale unui dispozitiv PL031 care este mapat "
"corespunz캒tor.\n"
"        unsafe { addr_of_mut!((*self.registers).imsc)."
"write_volatile(imsc) } }\n"
"    }\n"
"\n"
"    /// 탲terge o 칥ntrerupere 칥n a탳teptare, dac캒 exist캒.\n"
"    pub fn clear_interrupt(&mut self) {\n"
"        // Sigur, deoarece 탳tim c캒 self.registers indic캒 controlul\n"
"        // registre ale unui dispozitiv PL031 care este mapat "
"corespunz캒tor.\n"
"        unsafe { addr_of_mut!((*self.registers).icr)."
"write_volatile(0x01) } }\n"
"    }\n"
"}\n"
"\n"
"// Sigur, deoarece con탵ine doar un pointer c캒tre memoria dispozitivului, "
"care poate fi\n"
"// accesat캒 din orice context.\n"
"unsafe impl Send pentru Rtc {}\n"
"```"

#: src/exercises/concurrency/solutions-morning.md:1
#, fuzzy
msgid "Concurrency Morning Exercise"
msgstr "Concurrency Exerci탵iu de diminea탵캒"

#: src/exercises/concurrency/solutions-morning.md:5
#, fuzzy
msgid "([back to exercise](dining-philosophers.md))"
msgstr "([back to exercise](dining-philosophers.md))"

#: src/exercises/concurrency/solutions-morning.md:7
#, fuzzy
msgid ""
"```rust\n"
"use std::sync::{mpsc, Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    left_fork: Arc<Mutex<Fork>>,\n"
"    right_fork: Arc<Mutex<Fork>>,\n"
"    thoughts: mpsc::SyncSender<String>,\n"
"}\n"
"\n"
"impl Philosopher {\n"
"    fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))\n"
"            .unwrap();\n"
"    }\n"
"\n"
"    fn eat(&self) {\n"
"        println!(\"{} is trying to eat\", &self.name);\n"
"        let left = self.left_fork.lock().unwrap();\n"
"        let right = self.right_fork.lock().unwrap();\n"
"\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Hypatia\", \"Plato\", \"Aristotle\", \"Pythagoras\"];\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::sync_channel(10);\n"
"\n"
"    let forks = (0..PHILOSOPHERS.len())\n"
"        .map(|_| Arc::new(Mutex::new(Fork)))\n"
"        .collect::<Vec<_>>();\n"
"\n"
"    for i in 0..forks.len() {\n"
"        let tx = tx.clone();\n"
"        let mut left_fork = Arc::clone(&forks[i]);\n"
"        let mut right_fork = Arc::clone(&forks[(i + 1) % forks.len()]);\n"
"\n"
"        // To avoid a deadlock, we have to break the symmetry\n"
"        // somewhere. This will swap the forks without deinitializing\n"
"        // either of them.\n"
"        if i == forks.len() - 1 {\n"
"            std::mem::swap(&mut left_fork, &mut right_fork);\n"
"        }\n"
"\n"
"        let philosopher = Philosopher {\n"
"            name: PHILOSOPHERS[i].to_string(),\n"
"            thoughts: tx,\n"
"            left_fork,\n"
"            right_fork,\n"
"        };\n"
"\n"
"        thread::spawn(move || {\n"
"            for _ in 0..100 {\n"
"                philosopher.eat();\n"
"                philosopher.think();\n"
"            }\n"
"        });\n"
"    }\n"
"\n"
"    drop(tx);\n"
"    for thought in rx {\n"
"        println!(\"{thought}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use std::sync::{mpsc, Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    left_fork: Arc&lt;Mutex<Fork>&gt;,\n"
"    right_fork: Arc&lt;Mutex<Fork>&gt;,\n"
"    thoughts: mpsc::SyncSender<String>,\n"
"}\n"
"\n"
"impl Philosopher {\n"
"    fn think(&amp;self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} are o idee nou캒!\", &amp;self.name))\n"
"            .unwrap();\n"
"    }\n"
"\n"
"    fn eat(&amp;self) {\n"
"        println!(\"{} is trying to eat\", &amp;self.name);\n"
"        let left = self.left_fork.lock().unwrap();\n"
"        let right = self.right_fork.lock().unwrap();\n"
"\n"
"        println!(\"{} is eating...\", &amp;self.name);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &amp;[&amp;str] =\n"
"    &amp;[\"Socrate\", \"Hypatia\", \"Platon\", \"Aristotel\", "
"\"Pitagora\"];\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::sync_channel(10);\n"
"\n"
"    let forks = (0..PHILOSOPHERS.len())\n"
"        .map(|_| Arc::new(Mutex::new(Fork)))\n"
"        .collect::&lt;Vec<_>&gt;();\n"
"\n"
"    for i in 0..forks.len() {\n"
"        let tx = tx.clone();\n"
"        let mut left_fork = Arc::clone(&amp;forks[i]);\n"
"        let mut right_fork = Arc::clone(&amp;forks[(i + 1) % forks."
"len()])]);\n"
"\n"
"        // Pentru a evita un blocaj, trebuie s캒 rupem simetria\n"
"        // undeva. Acest lucru va schimba furcile f캒r캒 a dezinitializa\n"
"        // niciuna dintre ele.\n"
"        if i == forks.len() - 1 {\n"
"            std::mem::swap(&amp;mut left_fork, &amp;mut right_fork);\n"
"        }\n"
"\n"
"        let philosopher = Philosopher {\n"
"            name: PHILOSOPHERS[i].to_string(),\n"
"            thoughts: tx,\n"
"            left_fork,\n"
"            right_fork,\n"
"        };\n"
"\n"
"        thread::spawn(move || {|\n"
"            for _ in 0..100 {\n"
"                philosopher.eat();\n"
"                filosof.think();\n"
"            }\n"
"        });\n"
"    }\n"
"\n"
"    drop(tx);\n"
"    for thought in rx {\n"
"        println!(\"{thought}\");\n"
"    }\n"
"}\n"
"```"

#: src/exercises/concurrency/solutions-morning.md:82
#, fuzzy
msgid "Link Checker"
msgstr "Verificator de leg캒turi"

#: src/exercises/concurrency/solutions-morning.md:84
#, fuzzy
msgid "([back to exercise](link-checker.md))"
msgstr "([back to exercise](link-checker.md))"

#: src/exercises/concurrency/solutions-morning.md:86
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"use std::{sync::Arc, sync::Mutex, sync::mpsc, thread};\n"
"\n"
"use reqwest::{blocking::Client, Url};\n"
"use scraper::{Html, Selector};\n"
"use thiserror::Error;\n"
"\n"
"#[derive(Error, Debug)]\n"
"enum Error {\n"
"    #[error(\"request error: {0}\")]\n"
"    ReqwestError(#[from] reqwest::Error),\n"
"    #[error(\"bad http response: {0}\")]\n"
"    BadResponse(String),\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"struct CrawlCommand {\n"
"    url: Url,\n"
"    extract_links: bool,\n"
"}\n"
"\n"
"fn visit_page(client: &Client, command: &CrawlCommand) -> Result<Vec<Url>, "
"Error> {\n"
"    println!(\"Checking {:#}\", command.url);\n"
"    let response = client.get(command.url.clone()).send()?;\n"
"    if !response.status().is_success() {\n"
"        return Err(Error::BadResponse(response.status().to_string()));\n"
"    }\n"
"\n"
"    let mut link_urls = Vec::new();\n"
"    if !command.extract_links {\n"
"        return Ok(link_urls);\n"
"    }\n"
"\n"
"    let base_url = response.url().to_owned();\n"
"    let body_text = response.text()?;\n"
"    let document = Html::parse_document(&body_text);\n"
"\n"
"    let selector = Selector::parse(\"a\").unwrap();\n"
"    let href_values = document\n"
"        .select(&selector)\n"
"        .filter_map(|element| element.value().attr(\"href\"));\n"
"    for href in href_values {\n"
"        match base_url.join(href) {\n"
"            Ok(link_url) => {\n"
"                link_urls.push(link_url);\n"
"            }\n"
"            Err(err) => {\n"
"                println!(\"On {base_url:#}: ignored unparsable {href:?}: "
"{err}\");\n"
"            }\n"
"        }\n"
"    }\n"
"    Ok(link_urls)\n"
"}\n"
"\n"
"struct CrawlState {\n"
"    domain: String,\n"
"    visited_pages: std::collections::HashSet<String>,\n"
"}\n"
"\n"
"impl CrawlState {\n"
"    fn new(start_url: &Url) -> CrawlState {\n"
"        let mut visited_pages = std::collections::HashSet::new();\n"
"        visited_pages.insert(start_url.as_str().to_string());\n"
"        CrawlState {\n"
"            domain: start_url.domain().unwrap().to_string(),\n"
"            visited_pages,\n"
"        }\n"
"    }\n"
"\n"
"    /// Determine whether links within the given page should be extracted.\n"
"    fn should_extract_links(&self, url: &Url) -> bool {\n"
"        let Some(url_domain) = url.domain() else {\n"
"            return false;\n"
"        };\n"
"        url_domain == self.domain\n"
"    }\n"
"\n"
"    /// Mark the given page as visited, returning false if it had already\n"
"    /// been visited.\n"
"    fn mark_visited(&mut self, url: &Url) -> bool {\n"
"        self.visited_pages.insert(url.as_str().to_string())\n"
"    }\n"
"}\n"
"\n"
"type CrawlResult = Result<Vec<Url>, (Url, Error)>;\n"
"fn spawn_crawler_threads(\n"
"    command_receiver: mpsc::Receiver<CrawlCommand>,\n"
"    result_sender: mpsc::Sender<CrawlResult>,\n"
"    thread_count: u32,\n"
") {\n"
"    let command_receiver = Arc::new(Mutex::new(command_receiver));\n"
"\n"
"    for _ in 0..thread_count {\n"
"        let result_sender = result_sender.clone();\n"
"        let command_receiver = command_receiver.clone();\n"
"        thread::spawn(move || {\n"
"            let client = Client::new();\n"
"            loop {\n"
"                let command_result = {\n"
"                    let receiver_guard = command_receiver.lock().unwrap();\n"
"                    receiver_guard.recv()\n"
"                };\n"
"                let Ok(crawl_command) = command_result else {\n"
"                    // The sender got dropped. No more commands coming in.\n"
"                    break;\n"
"                };\n"
"                let crawl_result = match visit_page(&client, &crawl_command) "
"{\n"
"                    Ok(link_urls) => Ok(link_urls),\n"
"                    Err(error) => Err((crawl_command.url, error)),\n"
"                };\n"
"                result_sender.send(crawl_result).unwrap();\n"
"            }\n"
"        });\n"
"    }\n"
"}\n"
"\n"
"fn control_crawl(\n"
"    start_url: Url,\n"
"    command_sender: mpsc::Sender<CrawlCommand>,\n"
"    result_receiver: mpsc::Receiver<CrawlResult>,\n"
") -> Vec<Url> {\n"
"    let mut crawl_state = CrawlState::new(&start_url);\n"
"    let start_command = CrawlCommand { url: start_url, extract_links: "
"true };\n"
"    command_sender.send(start_command).unwrap();\n"
"    let mut pending_urls = 1;\n"
"\n"
"    let mut bad_urls = Vec::new();\n"
"    while pending_urls > 0 {\n"
"        let crawl_result = result_receiver.recv().unwrap();\n"
"        pending_urls -= 1;\n"
"\n"
"        match crawl_result {\n"
"            Ok(link_urls) => {\n"
"                for url in link_urls {\n"
"                    if crawl_state.mark_visited(&url) {\n"
"                        let extract_links = crawl_state."
"should_extract_links(&url);\n"
"                        let crawl_command = CrawlCommand { url, "
"extract_links };\n"
"                        command_sender.send(crawl_command).unwrap();\n"
"                        pending_urls += 1;\n"
"                    }\n"
"                }\n"
"            }\n"
"            Err((url, error)) => {\n"
"                bad_urls.push(url);\n"
"                println!(\"Got crawling error: {:#}\", error);\n"
"                continue;\n"
"            }\n"
"        }\n"
"    }\n"
"    bad_urls\n"
"}\n"
"\n"
"fn check_links(start_url: Url) -> Vec<Url> {\n"
"    let (result_sender, result_receiver) = mpsc::channel::<CrawlResult>();\n"
"    let (command_sender, command_receiver) = mpsc::channel::"
"<CrawlCommand>();\n"
"    spawn_crawler_threads(command_receiver, result_sender, 16);\n"
"    control_crawl(start_url, command_sender, result_receiver)\n"
"}\n"
"\n"
"fn main() {\n"
"    let start_url = reqwest::Url::parse(\"https://www.google.org\")."
"unwrap();\n"
"    let bad_urls = check_links(start_url);\n"
"    println!(\"Bad URLs: {:#?}\", bad_urls);\n"
"}\n"
"```"
msgstr ""
"```rust,compile_fail\n"
"use std::{sync::Arc, sync::Mutex, sync::mpsc, thread};\n"
"\n"
"use reqwest::{blocking::Client, Url};\n"
"use scraper::{Html, Selector};\n"
"use thiserror::Error;\n"
"\n"
"#[derive(Error, Debug)]\n"
"enum Error {\n"
"    #[error(\"request error: {0}\")]\n"
"    ReqwestError(#[din] reqwest::Error),\n"
"    #[error(\"bad http response: {0}\")]]\n"
"    BadResponse(String),\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"struct CrawlCommand {\n"
"    url: Url,\n"
"    extract_links: bool,\n"
"}\n"
"\n"
"fn visit_page(client: &amp;Client, command: &amp;CrawlCommand) -&gt; "
"Result&lt;Vec<Url>, Error&gt; {\n"
"    println!(\"Checking {:#}\", command.url);\n"
"    let response = client.get(command.url.clone()).send()?;\n"
"    if !response.status().is_succes() {\n"
"        return Err(Error::BadResponse(response.status().to_string())));\n"
"    }\n"
"\n"
"    let mut link_urls = Vec::new();\n"
"    if !command.extract_links {\n"
"        return Ok(link_urls);\n"
"    }\n"
"\n"
"    let base_url = response.url().to_owned();\n"
"    let body_text = response.text()?;\n"
"    let document = Html::parse_document(&amp;body_text);\n"
"\n"
"    let selector = Selector::parse(\"a\").unwrap();\n"
"    let href_values = document\n"
"        .select(&amp;selector)\n"
"        .filter_map(|element| element.value().attr(\"href\")));\n"
"    for href in href_values {\n"
"        match base_url.join(href) {\n"
"            Ok(link_url) =&gt; {\n"
"                link_urls.push(link_url);\n"
"            }\n"
"            Err(err) =&gt; {\n"
"                println!(\"Pe {base_url:#}: ignorat unparsable {href:?}: "
"{err}\");\n"
"            }\n"
"        }\n"
"    }\n"
"    Ok(link_urls)\n"
"}\n"
"\n"
"struct CrawlState {\n"
"    domain: String,\n"
"    visited_pages: std::collections::HashSet<String>,\n"
"}\n"
"\n"
"impl CrawlState {\n"
"    fn new(start_url: &amp;Url) -&gt; CrawlState {\n"
"        let mut visited_pages = std::collections::HashSet::new();\n"
"        visited_pages.insert(start_url.as_str().to_string());\n"
"        CrawlState {\n"
"            domain: start_url.domain().unwrap().to_string(),\n"
"            visited_pages,\n"
"        }\n"
"    }\n"
"\n"
"    /// Determin캒 dac캒 leg캒turile din pagina dat캒 trebuie extrase.\n"
"    fn should_extract_links(&amp;self, url: &amp;Url) -&gt; bool {\n"
"        let Some(url_domain) = url.domain() else {\n"
"            return false;\n"
"        };\n"
"        url_domain == self.domain\n"
"    }\n"
"\n"
"    /// Marcheaz캒 pagina dat캒 ca fiind vizitat캒, return칙nd false dac캒 "
"aceasta a fost deja vizitat캒\n"
"    /// fost vizitat캒.\n"
"    fn mark_visited(&amp;mut self, url: &amp;Url) -&gt; bool {\n"
"        self.visited_pages.insert(url.as_str().to_string()))\n"
"    }\n"
"}\n"
"\n"
"type CrawlResult = Result&lt;Vec<Url>, (Url, Error)&gt;;\n"
"fn spawn_crawler_threads(\n"
"    command_receiver: mpsc::Receiver<CrawlCommand>,\n"
"    result_sender: mpsc::Sender<CrawlResult>,\n"
"    thread_count: u32,\n"
") {\n"
"    let command_receiver = Arc::new(Mutex::new(command_receiver));\n"
"\n"
"    for _ in 0..thread_count {\n"
"        let result_sender = result_sender.clone();\n"
"        let command_receiver = command_receiver.clone();\n"
"        thread::spawn(move || {| {\n"
"            let client = Client::new();\n"
"            loop {\n"
"                let command_result = {\n"
"                    let receiver_guard = command_receiver.lock().unwrap();\n"
"                    receiver_guard.recv()\n"
"                };\n"
"                let Ok(crawl_command) = command_result else {\n"
"                    // Expeditorul a fost abandonat. Nu mai vin comenzi.\n"
"                    break;\n"
"                };\n"
"                let crawl_result = match visit_page(&amp;client, &amp;"
"crawl_comand캒) {\n"
"                    Ok(link_urls) =&gt; Ok(link_urls),\n"
"                    Err(error) =&gt; Err((crawl_comand.url, error)),\n"
"                };\n"
"                result_sender.send(crawl_result).unwrap();\n"
"            }\n"
"        });\n"
"    }\n"
"}\n"
"\n"
"fn control_crawl(\n"
"    start_url: Url,\n"
"    command_sender: mpsc::Sender<CrawlCommand>,\n"
"    result_receiver: mpsc::Receiver<CrawlResult>,\n"
") -&gt; Vec<Url> {\n"
"    let mut crawl_state = CrawlState::new(&amp;start_url);\n"
"    let start_command = CrawlCommand { url: start_url, extract_links: "
"true };\n"
"    command_sender.send(start_command).unwrap();\n"
"    let mut pending_urls = 1;\n"
"\n"
"    let mut bad_urls = Vec::new();\n"
"    while pending_urls &gt; 0 {\n"
"        let crawl_result = result_receiver.recv().unwrap();\n"
"        pending_urls -= 1;\n"
"\n"
"        match crawl_result {\n"
"            Ok(link_urls) =&gt; {\n"
"                for url in link_urls {\n"
"                    if crawl_state.mark_visited(&amp;url) {\n"
"                        let extract_links = crawl_state."
"should_extract_links(&amp;url);\n"
"                        let crawl_command = CrawlCommand { url, "
"extract_links };\n"
"                        command_sender.send(crawl_command).unwrap();\n"
"                        pending_urls += 1;\n"
"                    }\n"
"                }\n"
"            }\n"
"            Err((url, error))) =&gt; {\n"
"                bad_urls.push(url);\n"
"                println!(\"Am primit o eroare de crawling: {:#}\", error);\n"
"                continu캒;\n"
"            }\n"
"        }\n"
"    }\n"
"    bad_urls\n"
"}\n"
"\n"
"fn check_links(start_url: Url) -&gt; Vec<Url> {\n"
"    let (result_sender, result_receiver) = mpsc::channel:::<CrawlResult>();\n"
"    let (command_sender, command_receiver) = mpsc::channel:::"
"<CrawlCommand>();\n"
"    spawn_crawler_threads(command_receiver, result_sender, 16);\n"
"    control_crawl(start_url, command_sender, result_receiver)\n"
"}\n"
"\n"
"fn main() {\n"
"    let start_url = reqwest::Url::parse(\"https://www.google.org\")."
"unwrap();\n"
"    let bad_urls = check_links(start_url);\n"
"    println!(\"URL-uri proaste: {:#?}\", bad_urls);\n"
"}\n"
"```"

#: src/exercises/concurrency/solutions-afternoon.md:1
#, fuzzy
msgid "Concurrency Afternoon Exercise"
msgstr "Exerci탵iul de dup캒-amiaz캒 Concurrency"

#: src/exercises/concurrency/solutions-afternoon.md:5
#, fuzzy
msgid "([back to exercise](dining-philosophers-async.md))"
msgstr "([back to exercise](dining-philosophers-async.md))"

#: src/exercises/concurrency/solutions-afternoon.md:7
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"use std::sync::Arc;\n"
"use tokio::time;\n"
"use tokio::sync::mpsc::{self, Sender};\n"
"use tokio::sync::Mutex;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    left_fork: Arc<Mutex<Fork>>,\n"
"    right_fork: Arc<Mutex<Fork>>,\n"
"    thoughts: Sender<String>,\n"
"}\n"
"\n"
"impl Philosopher {\n"
"    async fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))."
"await\n"
"            .unwrap();\n"
"    }\n"
"\n"
"    async fn eat(&self) {\n"
"        // Pick up forks...\n"
"        let _first_lock = self.left_fork.lock().await;\n"
"        // Add a delay before picking the second fork to allow the "
"execution\n"
"        // to transfer to another task\n"
"        time::sleep(time::Duration::from_millis(1)).await;\n"
"        let _second_lock = self.right_fork.lock().await;\n"
"\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"\n"
"        // The locks are dropped here\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Hypatia\", \"Plato\", \"Aristotle\", \"Pythagoras\"];\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    // Create forks\n"
"    let mut forks = vec![];\n"
"    (0..PHILOSOPHERS.len()).for_each(|_| forks.push(Arc::new(Mutex::"
"new(Fork))));\n"
"\n"
"    // Create philosophers\n"
"    let (philosophers, mut rx) = {\n"
"        let mut philosophers = vec![];\n"
"        let (tx, rx) = mpsc::channel(10);\n"
"        for (i, name) in PHILOSOPHERS.iter().enumerate() {\n"
"            let left_fork = Arc::clone(&forks[i]);\n"
"            let right_fork = Arc::clone(&forks[(i + 1) % PHILOSOPHERS."
"len()]);\n"
"            // To avoid a deadlock, we have to break the symmetry\n"
"            // somewhere. This will swap the forks without deinitializing\n"
"            // either of them.\n"
"            if i  == 0 {\n"
"                std::mem::swap(&mut left_fork, &mut right_fork);\n"
"            }\n"
"            philosophers.push(Philosopher {\n"
"                name: name.to_string(),\n"
"                left_fork,\n"
"                right_fork,\n"
"                thoughts: tx.clone(),\n"
"            });\n"
"        }\n"
"        (philosophers, rx)\n"
"        // tx is dropped here, so we don't need to explicitly drop it later\n"
"    };\n"
"\n"
"    // Make them think and eat\n"
"    for phil in philosophers {\n"
"        tokio::spawn(async move {\n"
"            for _ in 0..100 {\n"
"                phil.think().await;\n"
"                phil.eat().await;\n"
"            }\n"
"        });\n"
"\n"
"    }\n"
"\n"
"    // Output their thoughts\n"
"    while let Some(thought) = rx.recv().await {\n"
"        println!(\"Here is a thought: {thought}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,compile_fail\n"
"folosi탵i std::sync::Arc;\n"
"use tokio::time;\n"
"use tokio::sync::mpsc::{self, Sender};\n"
"use tokio::sync::Mutex;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    left_fork: Arc&lt;Mutex<Fork>&gt;,\n"
"    right_fork: Arc&lt;Mutex<Fork>&gt;,\n"
"    thoughts: Expeditor<String>,\n"
"}\n"
"\n"
"impl Filozof {\n"
"    async fn think(&amp;self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} are o idee nou캒!\", &amp;self.name))."
"await\n"
"            .unwrap();\n"
"    }\n"
"\n"
"    async fn eat(&amp;self) {\n"
"        // Ridic캒 furculi탵ele...\n"
"        let _first_lock = self.left_fork.lock().await;\n"
"        // Ad캒uga탵i o 칥nt칙rziere 칥nainte de a alege a doua furculi탵캒 pentru "
"a permite execu탵ia\n"
"        // s캒 fie transferat캒 c캒tre o alt캒 sarcin캒\n"
"        time::sleep(time::Duration::from_millis(1)).await;\n"
"        let _second_lock = self.right_fork.lock().await;\n"
"\n"
"        println!(\"{} is eating...\", &amp;self.name);\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"\n"
"        // 칉ncuietorile sunt abandonate aici\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &amp;[&amp;str] =\n"
"    &amp;[\"Socrate\", \"Hypatia\", \"Platon\", \"Aristotel\", "
"\"Pitagora\"];\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    // Creeaz캒 furci\n"
"    let mut forks = vec![];\n"
"    (0..PHILOSOPHERS.len()).for_each(|_| forks.push(Arc::new(Mutex::"
"new(Fork))));\n"
"\n"
"    // Crea탵i filozofii\n"
"    let (philosophers, mut rx) = {\n"
"        let mut philosophers = vec![];\n"
"        let (tx, rx) = mpsc::channel(10);\n"
"        for (i, name) in PHILOSOPHERS.iter().enumerate() {\n"
"            let left_fork = Arc::clone(&amp;forks[i]);\n"
"            let right_fork = Arc::clone(&amp;forks[(i + 1) % PHILOSOPHERS."
"len()])]);\n"
"            // Pentru a evita un blocaj, trebuie s캒 rupem simetria\n"
"            // undeva. Acest lucru va schimba furcile f캒r캒 a dezinitializa\n"
"            // niciuna dintre ele.\n"
"            if i == 0 {\n"
"                std::mem::swap(&amp;mut left_fork, &amp;mut right_fork);\n"
"            }\n"
"            philosophers.push(Philosopher {\n"
"                name: name.to_string(),\n"
"                left_fork,\n"
"                right_fork,\n"
"                g칙nduri: tx.clone(),\n"
"            });\n"
"        }\n"
"        (filosofi, rx)\n"
"        // tx este eliminat aici, astfel 칥nc칙t nu trebuie s캒 칥l elimin캒m 칥n "
"mod explicit mai t칙rziu\n"
"    };\n"
"\n"
"    // F캒-i s캒 g칙ndeasc캒 탳i s캒 m캒n칙nce\n"
"    for phil in philosophers {\n"
"        tokio::spawn(async move {\n"
"            for _ in 0..100 {\n"
"                phil.think().await;\n"
"                phil.eat().await;\n"
"            }\n"
"        });\n"
"\n"
"    }\n"
"\n"
"    // Afi탳eaz캒 g칙ndurile lor\n"
"    while let Some(thought) = rx.recv().await {\n"
"        println!(\"Iat캒 un g칙nd: {thought}\");\n"
"    }\n"
"}\n"
"```"

#: src/exercises/concurrency/solutions-afternoon.md:97
#, fuzzy
msgid "([back to exercise](chat-app.md))"
msgstr "([back to exercise](chat-app.md))"

#: src/exercises/concurrency/solutions-afternoon.md:101
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"use futures_util::sink::SinkExt;\n"
"use futures_util::stream::StreamExt;\n"
"use std::error::Error;\n"
"use std::net::SocketAddr;\n"
"use tokio::net::{TcpListener, TcpStream};\n"
"use tokio::sync::broadcast::{channel, Sender};\n"
"use tokio_websockets::{Message, ServerBuilder, WebsocketStream};\n"
"\n"
"async fn handle_connection(\n"
"    addr: SocketAddr,\n"
"    mut ws_stream: WebsocketStream<TcpStream>,\n"
"    bcast_tx: Sender<String>,\n"
") -> Result<(), Box<dyn Error + Send + Sync>> {\n"
"\n"
"    ws_stream\n"
"        .send(Message::text(\"Welcome to chat! Type a message\".into()))\n"
"        .await?;\n"
"    let mut bcast_rx = bcast_tx.subscribe();\n"
"\n"
"    // A continuous loop for concurrently performing two tasks: (1) "
"receiving\n"
"    // messages from `ws_stream` and broadcasting them, and (2) receiving\n"
"    // messages on `bcast_rx` and sending them to the client.\n"
"    loop {\n"
"        tokio::select! {\n"
"            incoming = ws_stream.next() => {\n"
"                match incoming {\n"
"                    Some(Ok(msg)) => {\n"
"                        if let Some(text) = msg.as_text() {\n"
"                            println!(\"From client {addr:?} {text:?}\");\n"
"                            bcast_tx.send(text.into())?;\n"
"                        }\n"
"                    }\n"
"                    Some(Err(err)) => return Err(err.into()),\n"
"                    None => return Ok(()),\n"
"                }\n"
"            }\n"
"            msg = bcast_rx.recv() => {\n"
"                ws_stream.send(Message::text(msg?)).await?;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> Result<(), Box<dyn Error + Send + Sync>> {\n"
"    let (bcast_tx, _) = channel(16);\n"
"\n"
"    let listener = TcpListener::bind(\"127.0.0.1:2000\").await?;\n"
"    println!(\"listening on port 2000\");\n"
"\n"
"    loop {\n"
"        let (socket, addr) = listener.accept().await?;\n"
"        println!(\"New connection from {addr:?}\");\n"
"        let bcast_tx = bcast_tx.clone();\n"
"        tokio::spawn(async move {\n"
"            // Wrap the raw TCP stream into a websocket.\n"
"            let ws_stream = ServerBuilder::new().accept(socket).await?;\n"
"\n"
"            handle_connection(addr, ws_stream, bcast_tx).await\n"
"        });\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,compile_fail\n"
"use futures_util::sink::SinkExt;\n"
"use futures_util::stream::StreamExt;\n"
"use std::error::Error;\n"
"use std::net::SocketAddr;\n"
"use tokio::net::{TcpListener, TcpStream};\n"
"use tokio::sync::broadcast::{channel, Sender};\n"
"use tokio_websockets::{Message, ServerBuilder, WebsocketStream};\n"
"\n"
"async fn handle_connection(\n"
"    addr: SocketAddr,\n"
"    mut ws_stream: WebsocketStream<TcpStream>,\n"
"    bcast_tx: Sender<String>,\n"
") -&gt; Result&lt;(), Box<dyn Error + Send + Sync>&gt; {\n"
"\n"
"    ws_stream\n"
"        .send(Message::text(\"Bine a탵i venit pe chat! Introduce탵i un mesaj\"."
"into())))\n"
"        .await?;\n"
"    let mut bcast_rx = bcast_tx.subscribe();\n"
"\n"
"    // O bucl캒 continu캒 pentru efectuarea concomitent캒 a dou캒 sarcini: (1) "
"primirea\n"
"    // mesaje de la `ws_stream` 탳i difuzarea acestora 탳i (2) primirea\n"
"    // mesaje pe `bcast_rx` 탳i trimiterea lor c캒tre client.\n"
"    bucl캒 {\n"
"        tokio::select! {\n"
"            incoming = ws_stream.next() =&gt; {\n"
"                match incoming {\n"
"                    Some(Ok(msg)) =&gt; {\n"
"                        if let Some(text) = msg.as_text() {\n"
"                            println!(\"De la client {addr:?} {text:?}\");\n"
"                            bcast_tx.send(text.into())?;\n"
"                        }\n"
"                    }\n"
"                    Some(Err(err(err)) =&gt; return Err(err.into())),\n"
"                    None =&gt; return Ok((()),\n"
"                }\n"
"            }\n"
"            msg = bcast_rx.recv() =&gt; {\n"
"                ws_stream.send(Message::text(msg?)).await?;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() -&gt; Result&lt;(), Box<dyn Error + Send + Sync>&gt; {\n"
"    let (bcast_tx, _) = channel(16);\n"
"\n"
"    let listener = TcpListener::bind(\"127.0.0.1:2000\").await?;\n"
"    println!(\"ascult칙nd pe portul 2000\");\n"
"\n"
"    loop {\n"
"        let (socket, addr) = listener.accept().await?;\n"
"        println!(\"Conexiune nou캒 de la {addr:?}\");\n"
"        let bcast_tx = bcast_tx.clone();\n"
"        tokio::spawn(async move {\n"
"            // 칉nf캒탳ura탵i fluxul TCP brut 칥ntr-un websocket.\n"
"            let ws_stream = ServerBuilder::new().accept(socket).await?;\n"
"\n"
"            handle_connection(addr, ws_stream, bcast_tx).await\n"
"        });\n"
"    }\n"
"}\n"
"```"

#: src/exercises/concurrency/solutions-afternoon.md:168
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"use futures_util::stream::StreamExt;\n"
"use futures_util::SinkExt;\n"
"use http::Uri;\n"
"use tokio::io::{AsyncBufReadExt, BufReader};\n"
"use tokio_websockets::{ClientBuilder, Message};\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> Result<(), tokio_websockets::Error> {\n"
"    let (mut ws_stream, _) =\n"
"        ClientBuilder::from_uri(Uri::from_static(\"ws://127.0.0.1:2000\"))\n"
"            .connect()\n"
"            .await?;\n"
"\n"
"    let stdin = tokio::io::stdin();\n"
"    let mut stdin = BufReader::new(stdin).lines();\n"
"\n"
"    // Continuous loop for concurrently sending and receiving messages.\n"
"    loop {\n"
"        tokio::select! {\n"
"            incoming = ws_stream.next() => {\n"
"                match incoming {\n"
"                    Some(Ok(msg)) => {\n"
"                        if let Some(text) = msg.as_text() {\n"
"                            println!(\"From server: {}\", text);\n"
"                        }\n"
"                    },\n"
"                    Some(Err(err)) => return Err(err.into()),\n"
"                    None => return Ok(()),\n"
"                }\n"
"            }\n"
"            res = stdin.next_line() => {\n"
"                match res {\n"
"                    Ok(None) => return Ok(()),\n"
"                    Ok(Some(line)) => ws_stream.send(Message::text(line."
"to_string())).await?,\n"
"                    Err(err) => return Err(err.into()),\n"
"                }\n"
"            }\n"
"\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,compile_fail\n"
"use futures_util::stream::StreamExt;\n"
"use futures_util::SinkExt;\n"
"use http::Uri;\n"
"use tokio::io::{AsyncBufReadExt, BufReader};\n"
"use tokio_websockets::{ClientBuilder, Message};\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> Result<(), tokio_websockets::Error> {\n"
"    let (mut ws_stream, _) =\n"
"        ClientBuilder::from_uri(Uri::from_static(\"ws://127.0.0.1:2000\")))\n"
"            .connect()\n"
"            .await?;\n"
"\n"
"    let stdin = tokio::io::stdin();\n"
"    let mut stdin = BufReader::new(stdin).lines();\n"
"\n"
"    // Bucla continu캒 pentru trimiterea 탳i primirea simultan캒 de mesaje.\n"
"    loop {\n"
"        tokio::select! {\n"
"            incoming = ws_stream.next() => {\n"
"                match incoming {\n"
"                    Some(Ok(msg)) => {\n"
"                        if let Some(text) = msg.as_text() {\n"
"                            println!(\"De la server: {}\", text);\n"
"                        }\n"
"                    },\n"
"                    Some(Err(err(err))) => return Err(err.into()),\n"
"                    None => return Ok((()),\n"
"                }\n"
"            }\n"
"            res = stdin.next_line() => {\n"
"                match res {\n"
"                    Ok(None) => return Ok((()),\n"
"                    Ok(Some(line)) => ws_stream.send(Message::text(line."
"to_string())).await?,\n"
"                    Err(err) => return Err(err.into()),\n"
"                }\n"
"            }\n"
"\n"
"        }\n"
"    }\n"
"}\n"
"```"

#, fuzzy
#~ msgid ""
#~ "See the [CXX tutorial](https://cxx.rs/tutorial.html) for an full example "
#~ "of using this."
#~ msgstr ""
#~ "Consulta탵i [CXX tutorial](https://cxx.rs/tutorial.html) pentru un exemplu "
#~ "complet de utilizare."

#, fuzzy
#~ msgid ""
#~ "At this point, the instructor should switch to the [CXX tutorial](https://"
#~ "cxx.rs/tutorial.html)."
#~ msgstr ""
#~ "칉n acest moment, instructorul ar trebui s캒 treac캒 la [tutorialul CXX]"
#~ "(https://cxx.rs/tutorial.html)."

#, fuzzy
#~ msgid "Walk the students through the tutorial step by step."
#~ msgstr "칉ndruma탵i-i pe elevi prin tutorial pas cu pas."

#, fuzzy
#~ msgid ""
#~ "Highlight how CXX presents a clean interface without unsafe code in _both "
#~ "languages_."
#~ msgstr ""
#~ "Eviden탵ia탵i modul 칥n care CXX prezint캒 o interfa탵캒 curat캒 f캒r캒 cod "
#~ "nesigur 칥n _ambele limbaje_."

#, fuzzy
#~ msgid ""
#~ "Show the correspondence between [Rust and C++ types](https://cxx.rs/"
#~ "bindings.html):"
#~ msgstr ""
#~ "Ar캒ta탵i coresponden탵a dintre [tipurile Rust 탳i C++](https://cxx.rs/"
#~ "bindings.html):"

#, fuzzy
#~ msgid ""
#~ "Explain how a Rust `String` cannot map to a C++ `std::string` (the latter "
#~ "does not uphold the UTF-8 invariant). Show that despite being different "
#~ "types, `rust::String` in C++ can be easily constructed from a C++ `std::"
#~ "string`, making it very ergonomic to use."
#~ msgstr ""
#~ "Explica탵i de ce un `String` din Rust nu poate fi mapat cu un `std::"
#~ "string` din C++ (acesta din urm캒 nu respect캒 invarianta UTF-8). Ar캒ta탵i "
#~ "c캒, 칥n ciuda faptului c캒 sunt tipuri diferite, `rust::String` 칥n C++ "
#~ "poate fi construit cu u탳urin탵캒 dintr-un `std::string` din C++, ceea ce 칥l "
#~ "face foarte ergonomic de utilizat."

#, fuzzy
#~ msgid ""
#~ "Explain that a Rust function returning `Result<T, E>` becomes a function "
#~ "which throws a `E` exception in C++ (and vice versa)."
#~ msgstr ""
#~ "Explica탵i c캒 o func탵ie Rust care returneaz캒 `Result<T, E>` devine o "
#~ "func탵ie care arunc캒 o excep탵ie `E` 칥n C++ (탳i viceversa)."
