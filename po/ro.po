msgid ""
msgstr ""
"Project-Id-Version: Comprehensive Rust 🦀\n"
"POT-Creation-Date: 2024-05-15T20:58:33+03:00\n"
"PO-Revision-Date: 2024-05-15 22:17+0300\n"
"Last-Translator: Razvan Stefanescu <rstefanescu@google.com>\n"
"Language-Team: Romanian <translation-team-ro@lists.sourceforge.net>\n"
"Language: ro\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=n==1 ? 0 : (n==0 || (n%100 > 0 && n%100 < "
"20)) ? 1 : 2;\n"
"X-Generator: Poedit 3.4.4\n"

#: src/SUMMARY.md src/index.md
msgid "Welcome to Comprehensive Rust 🦀"
msgstr "Bine ați venit la Comprehensive Rust 🦀 (ghidul complet pentu Rust)"

#: src/SUMMARY.md src/running-the-course.md
msgid "Running the Course"
msgstr "Rularea cursului"

#: src/SUMMARY.md src/running-the-course/course-structure.md
msgid "Course Structure"
msgstr "Structura cursului"

#: src/SUMMARY.md src/running-the-course/keyboard-shortcuts.md
msgid "Keyboard Shortcuts"
msgstr "Scurtături de tastatură"

#: src/SUMMARY.md src/running-the-course/translations.md
msgid "Translations"
msgstr "Traduceri"

#: src/SUMMARY.md src/cargo.md
msgid "Using Cargo"
msgstr "Folosirea Cargo"

#: src/SUMMARY.md
msgid "Rust Ecosystem"
msgstr "Ecosistemul Rust"

#: src/SUMMARY.md
msgid "Code Samples"
msgstr "Mostre de cod"

#: src/SUMMARY.md
msgid "Running Cargo Locally"
msgstr "Rularea Cargo local"

#: src/SUMMARY.md
msgid "Day 1: Morning"
msgstr "Ziua 1: Dimineața"

#: src/SUMMARY.md src/concurrency/welcome-async.md
msgid "Welcome"
msgstr "Bine ați venit"

#: src/SUMMARY.md src/hello-world.md src/types-and-values/hello-world.md
msgid "Hello, World"
msgstr "Bună lume"

#: src/SUMMARY.md src/hello-world/what-is-rust.md
msgid "What is Rust?"
msgstr "Ce este Rust?"

#: src/SUMMARY.md src/hello-world/benefits.md
msgid "Benefits of Rust"
msgstr "Avantajele Rust"

#: src/SUMMARY.md src/hello-world/playground.md
msgid "Playground"
msgstr "Ciornă"

#: src/SUMMARY.md src/types-and-values.md
msgid "Types and Values"
msgstr "Tipuri și valori"

#: src/SUMMARY.md src/types-and-values/variables.md
msgid "Variables"
msgstr "Variabile"

#: src/SUMMARY.md src/types-and-values/values.md
msgid "Values"
msgstr "Valori"

#: src/SUMMARY.md src/types-and-values/arithmetic.md
msgid "Arithmetic"
msgstr "Aritmetică"

#: src/SUMMARY.md src/types-and-values/inference.md
msgid "Type Inference"
msgstr "Inferența de tip"

#: src/SUMMARY.md src/types-and-values/exercise.md
msgid "Exercise: Fibonacci"
msgstr "Exercițiu: Fibonacci"

#: src/SUMMARY.md src/types-and-values/solution.md
#: src/control-flow-basics/solution.md src/tuples-and-arrays/solution.md
#: src/references/solution.md src/user-defined-types/solution.md
#: src/pattern-matching/solution.md src/methods-and-traits/solution.md
#: src/generics/solution.md src/std-types/solution.md
#: src/std-traits/solution.md src/memory-management/solution.md
#: src/smart-pointers/solution.md src/borrowing/solution.md
#: src/lifetimes/solution.md src/iterators/solution.md src/modules/solution.md
#: src/testing/solution.md src/error-handling/solution.md
#: src/unsafe-rust/solution.md
msgid "Solution"
msgstr "Soluție"

#: src/SUMMARY.md src/control-flow-basics.md
msgid "Control Flow Basics"
msgstr "Bazele fluxului de control"

#: src/SUMMARY.md
msgid "`if` Expressions"
msgstr "Expresii 'if'"

#: src/SUMMARY.md src/control-flow-basics/loops.md
msgid "Loops"
msgstr "Bucle de execuție"

#: src/SUMMARY.md src/control-flow-basics/loops/for.md
msgid "`for`"
msgstr "Bucle `for`"

#: src/SUMMARY.md src/control-flow-basics/loops/loop.md
msgid "`loop`"
msgstr "Bucle `loop`"

#: src/SUMMARY.md src/control-flow-basics/break-continue.md
msgid "`break` and `continue`"
msgstr "`break` și `continue`"

#: src/SUMMARY.md src/control-flow-basics/break-continue/labels.md
msgid "Labels"
msgstr "Etichete"

#: src/SUMMARY.md src/control-flow-basics/blocks-and-scopes.md
msgid "Blocks and Scopes"
msgstr "Blocuri și scopuri"

#: src/SUMMARY.md src/control-flow-basics/blocks-and-scopes/scopes.md
msgid "Scopes and Shadowing"
msgstr "Scopuri și mascări"

#: src/SUMMARY.md src/control-flow-basics/functions.md
msgid "Functions"
msgstr "Funcții"

#: src/SUMMARY.md src/control-flow-basics/macros.md
msgid "Macros"
msgstr "Macro-uri"

#: src/SUMMARY.md src/control-flow-basics/exercise.md
msgid "Exercise: Collatz Sequence"
msgstr "Exercițiu: secvența Collatz"

#: src/SUMMARY.md
msgid "Day 1: Afternoon"
msgstr "Ziua 1: După-amiaza"

#: src/SUMMARY.md src/tuples-and-arrays.md
msgid "Tuples and Arrays"
msgstr "Tupluri și vectori"

#: src/SUMMARY.md src/tuples-and-arrays/arrays.md
msgid "Arrays"
msgstr "Array-uri"

#: src/SUMMARY.md src/tuples-and-arrays/tuples.md
msgid "Tuples"
msgstr "Tupluri"

#: src/SUMMARY.md src/tuples-and-arrays/iteration.md
msgid "Array Iteration"
msgstr "Iterații pe vectori"

#: src/SUMMARY.md src/tuples-and-arrays/destructuring.md
msgid "Patterns and Destructuring"
msgstr "Șabloane și destructurări"

#: src/SUMMARY.md src/tuples-and-arrays/exercise.md
msgid "Exercise: Nested Arrays"
msgstr "Exercițiu: vectori îmbrăcați"

#: src/SUMMARY.md src/references.md
msgid "References"
msgstr "Referinţe"

#: src/SUMMARY.md src/references/shared.md
msgid "Shared References"
msgstr "Referinţe partajare"

#: src/SUMMARY.md src/references/exclusive.md
msgid "Exclusive References"
msgstr "Referințe exclusive"

#: src/SUMMARY.md
msgid "Slices: `&[T]`"
msgstr "Partiții: `&[T]`"

#: src/SUMMARY.md src/references/strings.md
msgid "Strings"
msgstr "Șiruri de caractere"

#: src/SUMMARY.md src/references/exercise.md
msgid "Exercise: Geometry"
msgstr "Exercițiu: Geometrie"

#: src/SUMMARY.md src/user-defined-types.md
msgid "User-Defined Types"
msgstr "Tipuri definite de utilizator"

#: src/SUMMARY.md src/user-defined-types/named-structs.md
msgid "Named Structs"
msgstr "Structuri cu nume"

#: src/SUMMARY.md src/user-defined-types/tuple-structs.md
msgid "Tuple Structs"
msgstr "Structuri Tupluri"

#: src/SUMMARY.md src/user-defined-types/enums.md
#: src/pattern-matching/destructuring-enums.md
msgid "Enums"
msgstr "Enumerări (enums)"

#: src/SUMMARY.md
msgid "Static"
msgstr "Static"

#: src/SUMMARY.md
msgid "Const"
msgstr "Const"

#: src/SUMMARY.md src/user-defined-types/aliases.md
msgid "Type Aliases"
msgstr "Aliasuri de tip"

#: src/SUMMARY.md src/user-defined-types/exercise.md
#, fuzzy
msgid "Exercise: Elevator Events"
msgstr "Exercițiu: Evaluarea expresiilor"

#: src/SUMMARY.md
msgid "Day 2: Morning"
msgstr "Ziua 2: Dimineața"

#: src/SUMMARY.md src/pattern-matching.md
msgid "Pattern Matching"
msgstr "Potrivire de șabloane"

#: src/SUMMARY.md src/pattern-matching/match.md
msgid "Matching Values"
msgstr "Potrivirea valorilor"

#: src/SUMMARY.md
#, fuzzy
msgid "Destructuring Structs"
msgstr "Destructurări"

#: src/SUMMARY.md
msgid "Destructuring Enums"
msgstr "Destructurarea enumerărilor"

#: src/SUMMARY.md src/pattern-matching/let-control-flow.md
msgid "Let Control Flow"
msgstr "Fluxul de control"

#: src/SUMMARY.md src/pattern-matching/exercise.md
msgid "Exercise: Expression Evaluation"
msgstr "Exercițiu: Evaluarea expresiilor"

#: src/SUMMARY.md src/methods-and-traits.md
msgid "Methods and Traits"
msgstr "Metode și trăsături"

#: src/SUMMARY.md src/methods-and-traits/methods.md
msgid "Methods"
msgstr "Metode"

#: src/SUMMARY.md src/methods-and-traits/traits.md
msgid "Traits"
msgstr "Trăsături"

#: src/SUMMARY.md src/methods-and-traits/traits/implementing.md
msgid "Implementing Traits"
msgstr "Implementarea trăsăturilor"

#: src/SUMMARY.md src/methods-and-traits/traits/supertraits.md
msgid "Supertraits"
msgstr "Supertrăsături"

#: src/SUMMARY.md src/methods-and-traits/traits/associated-types.md
msgid "Associated Types"
msgstr "Tipuri asociate"

#: src/SUMMARY.md src/methods-and-traits/deriving.md
msgid "Deriving"
msgstr "Derivarea"

#: src/SUMMARY.md
#, fuzzy
msgid "Exercise: Generic Logger"
msgstr "Exercițiu: Logger generic"

#: src/SUMMARY.md
msgid "Day 2: Afternoon"
msgstr "Ziua 2: După-amiaza"

#: src/SUMMARY.md src/generics.md
msgid "Generics"
msgstr "Produse generice"

#: src/SUMMARY.md src/generics/generic-functions.md
msgid "Generic Functions"
msgstr "Funcții generice"

#: src/SUMMARY.md src/generics/generic-data.md
msgid "Generic Data Types"
msgstr "Tipuri de date generice"

#: src/SUMMARY.md src/generics/generic-traits.md
msgid "Generic Traits"
msgstr "Trăsături generice"

#: src/SUMMARY.md src/generics/trait-bounds.md
msgid "Trait Bounds"
msgstr "Limite de trăsături"

#: src/SUMMARY.md src/generics/impl-trait.md
msgid "`impl Trait`"
msgstr "`impl Trait`"

#: src/SUMMARY.md src/generics/exercise.md
msgid "Exercise: Generic `min`"
msgstr "Exercițiu: 'min' generic"

#: src/SUMMARY.md src/std-types.md
msgid "Standard Library Types"
msgstr "Biblioteca de tipuri standard"

#: src/SUMMARY.md src/std-types/std.md
msgid "Standard Library"
msgstr "Biblioteca standard"

#: src/SUMMARY.md src/std-types/docs.md
msgid "Documentation"
msgstr "Documentație"

#: src/SUMMARY.md
msgid "`Option`"
msgstr "'Option'"

#: src/SUMMARY.md
msgid "`Result`"
msgstr "`Result`"

#: src/SUMMARY.md src/android/aidl/types/primitives.md
#: src/android/interoperability/cpp/type-mapping.md
msgid "`String`"
msgstr "Șir"

#: src/SUMMARY.md src/std-types/vec.md
msgid "`Vec`"
msgstr "`Vec`"

#: src/SUMMARY.md src/std-types/hashmap.md src/bare-metal/no_std.md
msgid "`HashMap`"
msgstr "`HashMap`"

#: src/SUMMARY.md src/std-types/exercise.md
msgid "Exercise: Counter"
msgstr "Exercițiu: numărător"

#: src/SUMMARY.md src/std-traits.md
msgid "Standard Library Traits"
msgstr "Biblioteca standard de trăsături"

#: src/SUMMARY.md src/std-traits/comparisons.md
#: src/concurrency/welcome-async.md
msgid "Comparisons"
msgstr "Comparații"

#: src/SUMMARY.md src/std-traits/operators.md
msgid "Operators"
msgstr "Operatori"

#: src/SUMMARY.md src/std-traits/from-and-into.md
msgid "`From` and `Into`"
msgstr "`From` și `Into`"

#: src/SUMMARY.md src/std-traits/casting.md
msgid "Casting"
msgstr "Transformarea"

#: src/SUMMARY.md src/std-traits/read-and-write.md
msgid "`Read` and `Write`"
msgstr "Citire și scriere"

#: src/SUMMARY.md
msgid "`Default`, struct update syntax"
msgstr "'Default' (implicit), sintaxa de actualizare a structurilor"

#: src/SUMMARY.md src/std-traits/closures.md
msgid "Closures"
msgstr "Închideri"

#: src/SUMMARY.md src/std-traits/exercise.md
msgid "Exercise: ROT13"
msgstr "Exercițiu: ROT13"

#: src/SUMMARY.md
msgid "Day 3: Morning"
msgstr "Ziua 3: Dimineața"

#: src/SUMMARY.md src/memory-management.md
msgid "Memory Management"
msgstr "Gestionarea memoriei"

#: src/SUMMARY.md src/memory-management/review.md
msgid "Review of Program Memory"
msgstr "Utilizarea memoriei de către programe"

#: src/SUMMARY.md src/memory-management/approaches.md
msgid "Approaches to Memory Management"
msgstr "Abordări ale administrării memoriei"

#: src/SUMMARY.md src/memory-management/ownership.md
msgid "Ownership"
msgstr "Posesia"

#: src/SUMMARY.md src/memory-management/move.md
msgid "Move Semantics"
msgstr "Semantica mutărilor"

#: src/SUMMARY.md
msgid "`Clone`"
msgstr "'Clone'"

#: src/SUMMARY.md src/memory-management/copy-types.md
msgid "Copy Types"
msgstr "Tipuri copiate"

#: src/SUMMARY.md
msgid "`Drop`"
msgstr "'Drop'"

#: src/SUMMARY.md src/memory-management/exercise.md
msgid "Exercise: Builder Type"
msgstr "Exercițiu: Tipul constructor"

#: src/SUMMARY.md src/smart-pointers.md
msgid "Smart Pointers"
msgstr "Pointeri inteligenți"

#: src/SUMMARY.md src/smart-pointers/box.md
#: src/android/interoperability/cpp/type-mapping.md
msgid "`Box<T>`"
msgstr "`Box<T>`"

#: src/SUMMARY.md src/smart-pointers/rc.md
msgid "`Rc`"
msgstr "`Rc`"

#: src/SUMMARY.md src/smart-pointers/trait-objects.md
msgid "Trait Objects"
msgstr "Obiecte cu trăsături"

#: src/SUMMARY.md src/smart-pointers/exercise.md
msgid "Exercise: Binary Tree"
msgstr "Exercițiu: arbore binar"

#: src/SUMMARY.md
msgid "Day 3: Afternoon"
msgstr "Ziua 3: După-amiaza"

#: src/SUMMARY.md src/borrowing.md
msgid "Borrowing"
msgstr "Împrumut"

#: src/SUMMARY.md src/borrowing/shared.md
msgid "Borrowing a Value"
msgstr "Împrumutul unei valori"

#: src/SUMMARY.md src/borrowing/borrowck.md
msgid "Borrow Checking"
msgstr "Verificarea împrumuturilor"

#: src/SUMMARY.md src/borrowing/examples.md
#, fuzzy
msgid "Borrow Errors"
msgstr "Împrumutați erorile"

#: src/SUMMARY.md src/borrowing/interior-mutability.md
msgid "Interior Mutability"
msgstr "Mutabilitate internă"

#: src/SUMMARY.md src/borrowing/exercise.md
msgid "Exercise: Health Statistics"
msgstr "Exercițiu: statistici de sănătate"

#: src/SUMMARY.md src/lifetimes.md
msgid "Lifetimes"
msgstr "Durata de viață"

#: src/SUMMARY.md src/lifetimes/lifetime-annotations.md
msgid "Lifetime Annotations"
msgstr "Duratele de viață în anotări"

#: src/SUMMARY.md
msgid "Lifetime Elision"
msgstr "Extinderea duratei de viață"

#: src/SUMMARY.md
msgid "Struct Lifetimes"
msgstr "Durata de viață a structurilor"

#: src/SUMMARY.md src/lifetimes/exercise.md
msgid "Exercise: Protobuf Parsing"
msgstr "Exercițiu: Parsarea Protobuf"

#: src/SUMMARY.md
msgid "Day 4: Morning"
msgstr "Ziua 1: Dimineața"

#: src/SUMMARY.md src/iterators.md
msgid "Iterators"
msgstr "Iteratori"

#: src/SUMMARY.md src/iterators/iterator.md src/bare-metal/no_std.md
msgid "`Iterator`"
msgstr "`Iterator`"

#: src/SUMMARY.md src/iterators/intoiterator.md
msgid "`IntoIterator`"
msgstr "`IntoIterator`"

#: src/SUMMARY.md
msgid "`FromIterator`"
msgstr "`FromIterator`"

#: src/SUMMARY.md src/iterators/exercise.md
msgid "Exercise: Iterator Method Chaining"
msgstr "Exercițiu: Înlăntuirea metodelor iterator"

#: src/SUMMARY.md src/modules.md src/modules/modules.md
msgid "Modules"
msgstr "Module"

#: src/SUMMARY.md src/modules/filesystem.md
msgid "Filesystem Hierarchy"
msgstr "Ierarhia sistemului de fișiere"

#: src/SUMMARY.md src/modules/visibility.md
msgid "Visibility"
msgstr "Vizibilitate"

#: src/SUMMARY.md
msgid "`use`, `super`, `self`"
msgstr "`use`, `super`, `self`"

#: src/SUMMARY.md src/modules/exercise.md
msgid "Exercise: Modules for a GUI Library"
msgstr "Exercițiu: Module pentru o biblioteca pentru interfața grafică"

#: src/SUMMARY.md src/testing.md src/chromium/testing.md
msgid "Testing"
msgstr "Testare"

#: src/SUMMARY.md
msgid "Test Modules"
msgstr "Module de testare"

#: src/SUMMARY.md src/testing/other.md
msgid "Other Types of Tests"
msgstr "Alte tipuri de teste"

#: src/SUMMARY.md src/testing/lints.md
msgid "Compiler Lints and Clippy"
msgstr "Corecții compilator și Clippy"

#: src/SUMMARY.md src/testing/exercise.md
msgid "Exercise: Luhn Algorithm"
msgstr "Exercițiu: Algoritmul Luhn"

#: src/SUMMARY.md
msgid "Day 4: Afternoon"
msgstr "Ziua 4: După-amiaza"

#: src/SUMMARY.md src/error-handling.md
msgid "Error Handling"
msgstr "Gestionarea erorilor"

#: src/SUMMARY.md src/error-handling/panics.md
msgid "Panics"
msgstr "Panică"

#: src/SUMMARY.md src/error-handling/try.md
msgid "Try Operator"
msgstr "Operatorul 'try'"

#: src/SUMMARY.md src/error-handling/try-conversions.md
msgid "Try Conversions"
msgstr "Conversii 'try'"

#: src/SUMMARY.md
msgid "`Error` Trait"
msgstr "Trăsături 'Error'"

#: src/SUMMARY.md src/error-handling/thiserror-and-anyhow.md
msgid "`thiserror` and `anyhow`"
msgstr "`thiserror` și `anyhow`"

#: src/SUMMARY.md
msgid "Exercise: Rewriting with `Result`"
msgstr "Exercițiu: rescrierea cu `Result`"

#: src/SUMMARY.md src/unsafe-rust.md src/unsafe-rust/unsafe.md
msgid "Unsafe Rust"
msgstr "Rust nesigur"

#: src/SUMMARY.md
msgid "Unsafe"
msgstr "Nesigur"

#: src/SUMMARY.md src/unsafe-rust/dereferencing.md
msgid "Dereferencing Raw Pointers"
msgstr "Dereferențierea pointerilor bruți"

#: src/SUMMARY.md src/unsafe-rust/mutable-static.md
msgid "Mutable Static Variables"
msgstr "Variabile statice mutabile"

#: src/SUMMARY.md src/unsafe-rust/unions.md
msgid "Unions"
msgstr "Sindicate (Unions)"

#: src/SUMMARY.md src/unsafe-rust/unsafe-functions.md
msgid "Unsafe Functions"
msgstr "Funcții nesigure"

#: src/SUMMARY.md
msgid "Unsafe Traits"
msgstr "Trăsături nesigure"

#: src/SUMMARY.md
msgid "Exercise: FFI Wrapper"
msgstr "Înpachetare sigură prin FFI"

#: src/SUMMARY.md src/bare-metal/android.md
msgid "Android"
msgstr "Android"

#: src/SUMMARY.md src/android/setup.md src/chromium/setup.md
msgid "Setup"
msgstr "Setare"

#: src/SUMMARY.md src/android/build-rules.md
msgid "Build Rules"
msgstr "Reguli de construcție"

#: src/SUMMARY.md
msgid "Binary"
msgstr "Programe binare"

#: src/SUMMARY.md
msgid "Library"
msgstr "Biblioteci"

#: src/SUMMARY.md src/android/aidl.md
msgid "AIDL"
msgstr "AIDL"

#: src/SUMMARY.md src/android/aidl/birthday-service.md
#, fuzzy
msgid "Birthday Service Tutorial"
msgstr "/** Interfață de serviciu de ziua de naștere. */"

#: src/SUMMARY.md
msgid "Interface"
msgstr "Interfață"

#: src/SUMMARY.md
#, fuzzy
msgid "Service API"
msgstr "Serviciul API"

#: src/SUMMARY.md
msgid "Service"
msgstr "Serviciu"

#: src/SUMMARY.md
msgid "Server"
msgstr "Server"

#: src/SUMMARY.md src/android/aidl/example-service/deploy.md
msgid "Deploy"
msgstr "Lanseaza"

#: src/SUMMARY.md
msgid "Client"
msgstr "Client"

#: src/SUMMARY.md src/android/aidl/example-service/changing-definition.md
msgid "Changing API"
msgstr "Schimbarea API-ului"

#: src/SUMMARY.md
#, fuzzy
msgid "Updating Implementations"
msgstr "Implementare"

#: src/SUMMARY.md
#, fuzzy
msgid "AIDL Types"
msgstr "Tipuri"

#: src/SUMMARY.md src/android/aidl/types/primitives.md
#, fuzzy
msgid "Primitive Types"
msgstr "Tipuri primitive"

#: src/SUMMARY.md src/android/aidl/types/arrays.md
#, fuzzy
msgid "Array Types"
msgstr "Array-uri"

#: src/SUMMARY.md src/android/aidl/types/objects.md
#, fuzzy
msgid "Sending Objects"
msgstr "Obiecte cu trăsături"

#: src/SUMMARY.md src/android/aidl/types/parcelables.md
#, fuzzy
msgid "Parcelables"
msgstr "Variabile"

#: src/SUMMARY.md src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "Sending Files"
msgstr "Trimiterea fișierelor"

#: src/SUMMARY.md src/android/testing/googletest.md
msgid "GoogleTest"
msgstr "GoogleTest"

#: src/SUMMARY.md src/android/testing/mocking.md
msgid "Mocking"
msgstr "Imitarea"

#: src/SUMMARY.md src/android/logging.md src/bare-metal/aps/logging.md
msgid "Logging"
msgstr "Jurnalizare (loguri)"

#: src/SUMMARY.md src/android/interoperability.md
msgid "Interoperability"
msgstr "Interoperabilitate"

#: src/SUMMARY.md
msgid "With C"
msgstr "Cu C"

#: src/SUMMARY.md
msgid "Calling C with Bindgen"
msgstr "Apelarea C cu Bindgen"

#: src/SUMMARY.md
msgid "Calling Rust from C"
msgstr "Apelarea Rust din C"

#: src/SUMMARY.md src/android/interoperability/cpp.md
msgid "With C++"
msgstr "Cu C++"

#: src/SUMMARY.md src/android/interoperability/cpp/bridge.md
msgid "The Bridge Module"
msgstr "Modulul de interconectare"

#: src/SUMMARY.md
msgid "Rust Bridge"
msgstr "Interconectarea cu Rust"

#: src/SUMMARY.md src/android/interoperability/cpp/generated-cpp.md
msgid "Generated C++"
msgstr "Cod C++ generat"

#: src/SUMMARY.md
msgid "C++ Bridge"
msgstr "Interconectarea cu C++"

#: src/SUMMARY.md src/android/interoperability/cpp/shared-types.md
msgid "Shared Types"
msgstr "Tipuri partajate"

#: src/SUMMARY.md src/android/interoperability/cpp/shared-enums.md
msgid "Shared Enums"
msgstr "Enumerări partajate"

#: src/SUMMARY.md src/android/interoperability/cpp/rust-result.md
msgid "Rust Error Handling"
msgstr "Gestionarea erorilor în Rust"

#: src/SUMMARY.md src/android/interoperability/cpp/cpp-exception.md
msgid "C++ Error Handling"
msgstr "Gestionarea erorilor în C++"

#: src/SUMMARY.md src/android/interoperability/cpp/type-mapping.md
msgid "Additional Types"
msgstr "Tipuri suplimentare"

#: src/SUMMARY.md
msgid "Building for Android: C++"
msgstr "Construirea pentru Android: C++"

#: src/SUMMARY.md
msgid "Building for Android: Genrules"
msgstr "Construirea pentru Android: reguli de generare"

#: src/SUMMARY.md
msgid "Building for Android: Rust"
msgstr "Construirea pentru Android: Rust"

#: src/SUMMARY.md
msgid "With Java"
msgstr "Cu Java"

#: src/SUMMARY.md src/exercises/android/morning.md
#: src/exercises/bare-metal/morning.md src/exercises/bare-metal/afternoon.md
#: src/concurrency/sync-exercises.md src/concurrency/async-exercises.md
msgid "Exercises"
msgstr "Exerciții"

#: src/SUMMARY.md
msgid "Chromium"
msgstr "Chromium"

#: src/SUMMARY.md src/chromium/cargo.md
msgid "Comparing Chromium and Cargo Ecosystems"
msgstr "Compararea ecosistemelor Chromium și Cargo"

#: src/SUMMARY.md
msgid "Policy"
msgstr "Politici"

#: src/SUMMARY.md
msgid "Unsafe Code"
msgstr "Cod nesigur"

#: src/SUMMARY.md src/chromium/build-rules/depending.md
msgid "Depending on Rust Code from Chromium C++"
msgstr "În funcție de codul Rust din Chromium C++"

#: src/SUMMARY.md src/chromium/build-rules/vscode.md
msgid "Visual Studio Code"
msgstr "Visual Studio Code"

#: src/SUMMARY.md src/exercises/chromium/third-party.md
msgid "Exercise"
msgstr "Exercițiu"

#: src/SUMMARY.md src/chromium/testing/rust-gtest-interop.md
msgid "`rust_gtest_interop` Library"
msgstr "Biblioteca `rust_gtest_interop`"

#: src/SUMMARY.md src/chromium/testing/build-gn.md
msgid "GN Rules for Rust Tests"
msgstr "Reguli GN pentru testele Rust"

#: src/SUMMARY.md src/chromium/testing/chromium-import-macro.md
msgid "`chromium::import!` Macro"
msgstr "Macro-ul `chromium::import!`"

#: src/SUMMARY.md src/chromium/interoperability-with-cpp.md
msgid "Interoperability with C++"
msgstr "Interoperabilitatea cu C++"

#: src/SUMMARY.md src/chromium/interoperability-with-cpp/example-bindings.md
msgid "Example Bindings"
msgstr "Exemple de legături"

#: src/SUMMARY.md src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid "Limitations of CXX"
msgstr "Limitări ale CXX"

#: src/SUMMARY.md src/chromium/interoperability-with-cpp/error-handling.md
msgid "CXX Error Handling"
msgstr "Gestionarea erorilor în CXX"

#: src/SUMMARY.md
msgid "Error Handling: QR Example"
msgstr "Gestionarea erorilor: exemplu QR"

#: src/SUMMARY.md
msgid "Error Handling: PNG Example"
msgstr "Gestionarea erorilor: exemplu PNG"

#: src/SUMMARY.md
msgid "Using CXX in Chromium"
msgstr "Utilizarea CXX în Chromium"

#: src/SUMMARY.md src/chromium/adding-third-party-crates.md
msgid "Adding Third Party Crates"
msgstr "Adăugarea de lăzi ale unor terțe părți"

#: src/SUMMARY.md
msgid "Configuring Cargo.toml"
msgstr "Configurarea Cargo.toml"

#: src/SUMMARY.md
#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
msgid "Configuring `gnrt_config.toml`"
msgstr "Configurarea `gnrt_config.toml`"

#: src/SUMMARY.md src/chromium/adding-third-party-crates/downloading-crates.md
msgid "Downloading Crates"
msgstr "Descărcarea de lăzi"

#: src/SUMMARY.md
#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid "Generating `gn` Build Rules"
msgstr "Generarea regulilor de compilare `gn`"

#: src/SUMMARY.md src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Resolving Problems"
msgstr "Rezolvarea problemelor"

#: src/SUMMARY.md
#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
msgid "Build Scripts Which Generate Code"
msgstr "Scripturi de construire care generează cod"

#: src/SUMMARY.md
#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
msgid "Build Scripts Which Build C++ or Take Arbitrary Actions"
msgstr ""
"Scripturi de construire care construiesc C++ sau efectuează acțiuni arbitrare"

#: src/SUMMARY.md
#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
msgid "Depending on a Crate"
msgstr "Dependințe de crater"

#: src/SUMMARY.md
msgid "Reviews and Audits"
msgstr "Revizuiri și audituri"

#: src/SUMMARY.md
#, fuzzy
msgid "Checking into Chromium Source Code"
msgstr "Modificări în codul sursă Chromium"

#: src/SUMMARY.md src/chromium/adding-third-party-crates/keeping-up-to-date.md
msgid "Keeping Crates Up to Date"
msgstr "Actualizarea crate-urilor"

#: src/SUMMARY.md
msgid "Bringing It Together - Exercise"
msgstr "Reunind totul - Exercițiu"

#: src/SUMMARY.md src/exercises/chromium/solutions.md
msgid "Exercise Solutions"
msgstr "Soluțiile exercițiilor"

#: src/SUMMARY.md
msgid "Bare Metal: Morning"
msgstr "Direct pe hardware: Dimineața"

#: src/SUMMARY.md src/bare-metal/no_std.md
msgid "`no_std`"
msgstr "`no_std`"

#: src/SUMMARY.md
msgid "A Minimal Example"
msgstr "Un exemplu minimalist"

#: src/SUMMARY.md src/bare-metal/no_std.md src/bare-metal/alloc.md
msgid "`alloc`"
msgstr "`alloc`"

#: src/SUMMARY.md src/bare-metal/microcontrollers.md
msgid "Microcontrollers"
msgstr "Microcontrolere"

#: src/SUMMARY.md src/bare-metal/microcontrollers/mmio.md
msgid "Raw MMIO"
msgstr "MMIO brut"

#: src/SUMMARY.md
msgid "PACs"
msgstr "PAC-uri"

#: src/SUMMARY.md
msgid "HAL Crates"
msgstr "Lăzi (crates) HAL"

#: src/SUMMARY.md
msgid "Board Support Crates"
msgstr "Crates cu suport pentru plăci"

#: src/SUMMARY.md
msgid "The Type State Pattern"
msgstr "Modelul de stare de tip"

#: src/SUMMARY.md src/bare-metal/microcontrollers/embedded-hal.md
msgid "`embedded-hal`"
msgstr "`embedded-hal`"

#: src/SUMMARY.md src/bare-metal/microcontrollers/probe-rs.md
msgid "`probe-rs` and `cargo-embed`"
msgstr "`probe-rs` și `cargo-embed`"

#: src/SUMMARY.md src/bare-metal/microcontrollers/debugging.md
msgid "Debugging"
msgstr "Depanare"

#: src/SUMMARY.md
msgid "Other Projects"
msgstr "Alte proiecte"

#: src/SUMMARY.md src/exercises/bare-metal/compass.md
#: src/exercises/bare-metal/solutions-morning.md
msgid "Compass"
msgstr "Compass"

#: src/SUMMARY.md src/concurrency/sync-exercises/solutions.md
#: src/concurrency/async-exercises/solutions.md
msgid "Solutions"
msgstr "Soluții"

#: src/SUMMARY.md
msgid "Bare Metal: Afternoon"
msgstr "Bare Metal: După-amiază"

#: src/SUMMARY.md
msgid "Application Processors"
msgstr "Procesatori de aplicații"

#: src/SUMMARY.md src/bare-metal/aps/entry-point.md
msgid "Getting Ready to Rust"
msgstr "Pregătiți pentru Rust"

#: src/SUMMARY.md
msgid "Inline Assembly"
msgstr "Ansamblare în linie"

#: src/SUMMARY.md
msgid "MMIO"
msgstr "MMIO"

#: src/SUMMARY.md
msgid "Let's Write a UART Driver"
msgstr "Să scriem un driver UART"

#: src/SUMMARY.md
msgid "More Traits"
msgstr "Mai multe trăsături"

#: src/SUMMARY.md
msgid "A Better UART Driver"
msgstr "Un driver UART mai bun"

#: src/SUMMARY.md src/bare-metal/aps/better-uart/bitflags.md
msgid "Bitflags"
msgstr "Bitflags"

#: src/SUMMARY.md
msgid "Multiple Registers"
msgstr "Registre multiple"

#: src/SUMMARY.md src/bare-metal/aps/better-uart/driver.md
msgid "Driver"
msgstr "Un driver UART mai bun"

#: src/SUMMARY.md
msgid "Using It"
msgstr "Utilizarea acestuia"

#: src/SUMMARY.md src/bare-metal/aps/exceptions.md
msgid "Exceptions"
msgstr "Excepții"

#: src/SUMMARY.md
msgid "Useful Crates"
msgstr "Crates (lăzi) utile"

#: src/SUMMARY.md src/bare-metal/useful-crates/zerocopy.md
msgid "`zerocopy`"
msgstr "`zerocopy`"

#: src/SUMMARY.md src/bare-metal/useful-crates/aarch64-paging.md
msgid "`aarch64-paging`"
msgstr "`aarch64-paging`"

#: src/SUMMARY.md src/bare-metal/useful-crates/buddy_system_allocator.md
msgid "`buddy_system_allocator`"
msgstr "buddy_system_allocator`"

#: src/SUMMARY.md src/bare-metal/useful-crates/tinyvec.md
msgid "`tinyvec`"
msgstr "`tinyvec`"

#: src/SUMMARY.md src/bare-metal/useful-crates/spin.md
msgid "`spin`"
msgstr "`Spin`"

#: src/SUMMARY.md
msgid "`vmbase`"
msgstr "`vmbase`"

#: src/SUMMARY.md
msgid "RTC Driver"
msgstr "Conductor RTC"

#: src/SUMMARY.md
msgid "Concurrency: Morning"
msgstr "Concurență: Dimineața"

#: src/SUMMARY.md src/concurrency/threads.md
msgid "Threads"
msgstr "Conversatii"

#: src/SUMMARY.md src/concurrency/threads/plain.md
#, fuzzy
msgid "Plain Threads"
msgstr "Conversatii"

#: src/SUMMARY.md src/concurrency/threads/scoped.md
msgid "Scoped Threads"
msgstr "Fire de execuție cu scop"

#: src/SUMMARY.md src/concurrency/channels.md
msgid "Channels"
msgstr "Canale"

#: src/SUMMARY.md src/concurrency/channels/senders-receivers.md
#, fuzzy
msgid "Senders and Receivers"
msgstr "Expeditori și destinatari"

#: src/SUMMARY.md src/concurrency/channels/unbounded.md
msgid "Unbounded Channels"
msgstr "Canale nerestricționate"

#: src/SUMMARY.md src/concurrency/channels/bounded.md
msgid "Bounded Channels"
msgstr "Canale delimitate"

#: src/SUMMARY.md src/concurrency/send-sync.md
msgid "`Send` and `Sync`"
msgstr "`Send` și `Sync`"

#: src/SUMMARY.md src/concurrency/send-sync/marker-traits.md
#, fuzzy
msgid "Marker Traits"
msgstr "Mai multe trăsături"

#: src/SUMMARY.md src/concurrency/send-sync/send.md
msgid "`Send`"
msgstr "Trimitere (send)"

#: src/SUMMARY.md src/concurrency/send-sync/sync.md
msgid "`Sync`"
msgstr "Sincronizare (sync)"

#: src/SUMMARY.md src/concurrency/send-sync/examples.md
msgid "Examples"
msgstr "Exemple"

#: src/SUMMARY.md src/concurrency/shared-state.md
msgid "Shared State"
msgstr "Statut comun"

#: src/SUMMARY.md src/concurrency/shared-state/arc.md
msgid "`Arc`"
msgstr "`Arc`"

#: src/SUMMARY.md src/concurrency/shared-state/mutex.md
msgid "`Mutex`"
msgstr "`Mutex`"

#: src/SUMMARY.md src/memory-management/review.md
#: src/error-handling/try-conversions.md
#: src/concurrency/shared-state/example.md
msgid "Example"
msgstr "Exemplu"

#: src/SUMMARY.md src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/sync-exercises/solutions.md
msgid "Dining Philosophers"
msgstr "Filozofii la masă"

#: src/SUMMARY.md src/concurrency/sync-exercises/link-checker.md
msgid "Multi-threaded Link Checker"
msgstr "Verificator de legături cu mai multe fire de execuție"

#: src/SUMMARY.md
msgid "Concurrency: Afternoon"
msgstr "Concurență: După-amiază"

#: src/SUMMARY.md src/concurrency/async.md
msgid "Async Basics"
msgstr "Bazele Async"

#: src/SUMMARY.md src/concurrency/async/async-await.md
msgid "`async`/`await`"
msgstr "async/await"

#: src/SUMMARY.md src/concurrency/async/futures.md
msgid "Futures"
msgstr "Futures"

#: src/SUMMARY.md src/concurrency/async/runtimes.md
#, fuzzy
msgid "Runtimes"
msgstr "Timpi de execuție"

#: src/SUMMARY.md src/concurrency/async/runtimes/tokio.md
msgid "Tokio"
msgstr "Tokio"

#: src/SUMMARY.md src/concurrency/sync-exercises/link-checker.md
#: src/concurrency/async/tasks.md src/concurrency/async-exercises/chat-app.md
msgid "Tasks"
msgstr "Task-uri"

#: src/SUMMARY.md src/concurrency/async-control-flow.md
#, fuzzy
msgid "Channels and Control Flow"
msgstr "Fluxul de control"

#: src/SUMMARY.md src/concurrency/async-control-flow/channels.md
msgid "Async Channels"
msgstr "Canale asincrone"

#: src/SUMMARY.md src/concurrency/async-control-flow/join.md
msgid "Join"
msgstr "Alăturare (join)"

#: src/SUMMARY.md src/concurrency/async-control-flow/select.md
msgid "Select"
msgstr "Selecție (select)"

#: src/SUMMARY.md src/concurrency/async-pitfalls.md
msgid "Pitfalls"
msgstr "Capcane"

#: src/SUMMARY.md
msgid "Blocking the Executor"
msgstr "Blocarea executorului"

#: src/SUMMARY.md src/concurrency/async-pitfalls/pin.md
msgid "`Pin`"
msgstr "`Pin`"

#: src/SUMMARY.md src/concurrency/async-pitfalls/async-traits.md
msgid "Async Traits"
msgstr "Trăsături asincrone"

#: src/SUMMARY.md src/concurrency/async-pitfalls/cancellation.md
msgid "Cancellation"
msgstr "Anulare"

#: src/SUMMARY.md src/concurrency/async-exercises/chat-app.md
#: src/concurrency/async-exercises/solutions.md
msgid "Broadcast Chat Application"
msgstr "Aplicație de chat cu difuzare"

#: src/SUMMARY.md
msgid "Final Words"
msgstr "Ultimele cuvinte"

#: src/SUMMARY.md src/thanks.md
msgid "Thanks!"
msgstr "Va multumim !"

#: src/SUMMARY.md src/glossary.md
msgid "Glossary"
msgstr "Glosar"

#: src/SUMMARY.md
msgid "Other Resources"
msgstr "Alte resurse"

#: src/SUMMARY.md src/credits.md
msgid "Credits"
msgstr "Credite"

#: src/index.md
msgid ""
"[![Build workflow](https://img.shields.io/github/actions/workflow/status/"
"google/comprehensive-rust/build.yml?style=flat-square)](https://github.com/"
"google/comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain) [!"
"[GitHub contributors](https://img.shields.io/github/contributors/google/"
"comprehensive-rust?style=flat-square)](https://github.com/google/"
"comprehensive-rust/graphs/contributors) [![GitHub stars](https://img.shields."
"io/github/stars/google/comprehensive-rust?style=flat-square)](https://github."
"com/google/comprehensive-rust/stargazers)"
msgstr ""
"[![Fluxul de construcție](https://img.shields.io/github/actions/workflow/"
"status/google/comprehensive-rust/build.yml?style=flat-square)](https://"
"github.com/google/comprehensive-rust/actions/workflows/build.yml?"
"query=branch%3Amain) [![Contribuitori GitHub](https://img.shields.io/github/"
"contributors/google/comprehensive-rust?style=flat-square)](https://github."
"com/google/comprehensive-rust/graphs/contributors) [![Stele GitHub](https://"
"img.shields.io/github/stars/google/comprehensive-rust?style=flat-square)]"
"(https://github.com/google/comprehensive-rust/stargazers)"

#: src/index.md
msgid ""
"This is a free Rust course developed by the Android team at Google. The "
"course covers the full spectrum of Rust, from basic syntax to advanced "
"topics like generics and error handling."
msgstr ""
"Acesta este un curs gratuit de Rust dezvoltat de echipa Android de la "
"Google. Cursul acoperă întregul spectru Rust, de la sintaxa de bază până la "
"subiecte avansate, cum ar fi genericele și gestionarea erorilor."

#: src/index.md
msgid ""
"The latest version of the course can be found at <https://google.github.io/"
"comprehensive-rust/>. If you are reading somewhere else, please check there "
"for updates."
msgstr ""
"Cea mai recentă versiune a cursului poate fi găsită la adresa <https://"
"google.github.io/comprehensive-rust/>. Dacă citiți în altă parte, vă rugăm "
"să verificați acolo pentru actualizări."

#: src/index.md
#, fuzzy
msgid "The course is also available [as a PDF](comprehensive-rust.pdf)."
msgstr ""
"Cursul este, de asemenea, disponibil [în format PDF](comprehensive-rust.pdf)."

#: src/index.md
msgid ""
"The goal of the course is to teach you Rust. We assume you don't know "
"anything about Rust and hope to:"
msgstr ""
"Scopul cursului este de a vă învăța Rust. Presupunem că nu știți nimic "
"despre Rust și, la sfârșit, sperăm să:"

#: src/index.md
msgid "Give you a comprehensive understanding of the Rust syntax and language."
msgstr "Aveți o înțelegere cuprinzătoare a sintaxei și a limbajului Rust."

#: src/index.md
msgid "Enable you to modify existing programs and write new programs in Rust."
msgstr ""
"Puteți să modificați programele existente și să scrieți programe noi în Rust."

#: src/index.md
msgid "Show you common Rust idioms."
msgstr "Cunoașteți expresii uzuale din Rust."

#: src/index.md
msgid "We call the first four course days Rust Fundamentals."
msgstr "Primele patru zile de curs se numesc Fundamentele Rust."

#: src/index.md
msgid ""
"Building on this, you're invited to dive into one or more specialized topics:"
msgstr ""
"Pornind de la acestea, sunteți invitați să aprofundați unul sau mai multe "
"subiecte specializate:"

#: src/index.md
msgid ""
"[Android](android.md): a half-day course on using Rust for Android platform "
"development (AOSP). This includes interoperability with C, C++, and Java."
msgstr ""
"[Android](android.md): un curs de o jumătate de zi despre utilizarea Rust "
"pentru dezvoltarea platformei Android (AOSP). Acesta include "
"interoperabilitatea cu C, C++ și Java."

#: src/index.md
msgid ""
"[Chromium](chromium.md): a half-day course on using Rust within Chromium "
"based browsers. This includes interoperability with C++ and how to include "
"third-party crates in Chromium."
msgstr ""
"[Chromium](chromium.md): un curs de o jumătate de zi despre utilizarea Rust "
"pentru navigatoarele bazate pe Chromium. Acesta include interoperabilitatea "
"cu C++ și  utilizarea crate-urilor terțe în Chromium."

#: src/index.md
msgid ""
"[Bare-metal](bare-metal.md): a whole-day class on using Rust for bare-metal "
"(embedded) development. Both microcontrollers and application processors are "
"covered."
msgstr ""
"[Bare-metal](bare-metal.md): un curs de o zi întreagă despre utilizarea Rust "
"pentru dezvoltarea bare-metal (încorporată). Sunt acoperite atât "
"microcontrolerele, cât și procesoarele de aplicații."

#: src/index.md
msgid ""
"[Concurrency](concurrency.md): a whole-day class on concurrency in Rust. We "
"cover both classical concurrency (preemptively scheduling using threads and "
"mutexes) and async/await concurrency (cooperative multitasking using "
"futures)."
msgstr ""
"[Concurrency](concurrency.md): un curs de o zi întreagă despre concurența în "
"Rust. Acoperim atât concurența clasică (programarea preemptivă folosind fire "
"de execuție și mutexuri), cât și concurența async/await (multitasking "
"cooperativ folosind futures)."

#: src/index.md
msgid "Non-Goals"
msgstr "Alte obiective decât cele de bază"

#: src/index.md
msgid ""
"Rust is a large language and we won't be able to cover all of it in a few "
"days. Some non-goals of this course are:"
msgstr ""
"Rust este un limbaj mare și nu vom putea acoperi toate aspectele în câteva "
"zile. Câteva dintre non-obiectivele acestui curs sunt:"

#: src/index.md
msgid ""
"Learning how to develop macros: please see [Chapter 19.5 in the Rust Book]"
"(https://doc.rust-lang.org/book/ch19-06-macros.html) and [Rust by Example]"
"(https://doc.rust-lang.org/rust-by-example/macros.html) instead."
msgstr ""
"Învățarea modului de dezvoltare a macrocomenzilor: vă rugăm să consultați în "
"schimb [Capitolul 19.5 din Rust Book](https://doc.rust-lang.org/book/ch19-06-"
"macros.html) și [Rust by Example](https://doc.rust-lang.org/rust-by-example/"
"macros.html)."

#: src/index.md
msgid "Assumptions"
msgstr "Ipoteze"

#: src/index.md
msgid ""
"The course assumes that you already know how to program. Rust is a "
"statically-typed language and we will sometimes make comparisons with C and "
"C++ to better explain or contrast the Rust approach."
msgstr ""
"Cursul pornește de la premisa că știți deja să programați. Rust este un "
"limbaj cu tipare statică și uneori vom face comparații cu C și C++ pentru a "
"explica mai bine sau a contrasta abordarea Rust."

#: src/index.md
msgid ""
"If you know how to program in a dynamically-typed language such as Python or "
"JavaScript, then you will be able to follow along just fine too."
msgstr ""
"Dacă știți să programați într-un limbaj cu tipuri dinamice, cum ar fi Python "
"sau JavaScript, atunci veți putea să vă descurcați foarte bine."

#: src/index.md
msgid ""
"This is an example of a _speaker note_. We will use these to add additional "
"information to the slides. This could be key points which the instructor "
"should cover as well as answers to typical questions which come up in class."
msgstr ""
"Acesta este un exemplu de _notițe pentru prezentator_. Le vom folosi pentru "
"a adăuga informații suplimentare la diapozitive. Acestea pot fi puncte cheie "
"pe care instructorul ar trebui să le abordeze, precum și răspunsuri la "
"întrebări tipice care apar în clasă."

#: src/running-the-course.md src/running-the-course/course-structure.md
msgid "This page is for the course instructor."
msgstr "Această pagină este destinată instructorului de curs."

#: src/running-the-course.md
msgid ""
"Here is a bit of background information about how we've been running the "
"course internally at Google."
msgstr ""
"Iată câteva informații de fond despre modul în care am desfășurat cursul în "
"cadrul Google."

#: src/running-the-course.md
msgid ""
"We typically run classes from 9:00 am to 4:00 pm, with a 1 hour lunch break "
"in the middle. This leaves 3 hours for the morning class and 3 hours for the "
"afternoon class. Both sessions contain multiple breaks and time for students "
"to work on exercises."
msgstr ""
"De obicei, cursurile se desfășoară între orele 9:00 și 16:00, cu o pauză de "
"masă de o oră la mijloc. Astfel, rămân 3 ore pentru cursul de dimineață și 3 "
"ore pentru cursul de după-amiază. Ambele sesiuni includ multiple pauze "
"pentru a le permite cursanților să lucreze la exerciții."

#: src/running-the-course.md
msgid "Before you run the course, you will want to:"
msgstr "Înainte de a parcurge cursul, veți dori să:"

#: src/running-the-course.md
msgid ""
"Make yourself familiar with the course material. We've included speaker "
"notes to help highlight the key points (please help us by contributing more "
"speaker notes!). When presenting, you should make sure to open the speaker "
"notes in a popup (click the link with a little arrow next to \"Speaker "
"Notes\"). This way you have a clean screen to present to the class."
msgstr ""
"Vă familiarizați cu materialul de curs. Am inclus note ale vorbitorului "
"pentru a evidenția punctele cheie (vă rugăm să ne ajutați contribuind cu mai "
"multe note pentru prezentare!). Atunci când prezentați, asigurați-vă că "
"deschideți notele prezentatorului într-o fereastră pop-up (faceți clic pe "
"link-ul cu o săgeată mică de lângă \"Speaker Notes\"). În acest fel, veți "
"avea un ecran curat pentru a prezenta în fața clasei."

#: src/running-the-course.md
msgid ""
"Decide on the dates. Since the course takes four days, we recommend that you "
"schedule the days over two weeks. Course participants have said that they "
"find it helpful to have a gap in the course since it helps them process all "
"the information we give them."
msgstr ""
"Decideți datele. Deoarece cursul durează patru zile\\i, vă recomandăm să "
"programați zilele pe parcursul a două săptămâni. Participanții la curs au "
"spus că li se pare util să existe un interval în timpul cursului, deoarece "
"îi ajută să proceseze toate informațiile pe care le oferim."

#: src/running-the-course.md
msgid ""
"Find a room large enough for your in-person participants. We recommend a "
"class size of 15-25 people. That's small enough that people are comfortable "
"asking questions --- it's also small enough that one instructor will have "
"time to answer the questions. Make sure the room has _desks_ for yourself "
"and for the students: you will all need to be able to sit and work with your "
"laptops. In particular, you will be doing a lot of live-coding as an "
"instructor, so a lectern won't be very helpful for you."
msgstr ""
"Găsiți o sală suficient de mare pentru participanții prezenți. Vă recomandăm "
"o clasă de 15-25 de persoane. Este suficient de mică pentru ca oamenii să se "
"simtă confortabil să pună întrebări --- este, de asemenea, suficient de mică "
"pentru ca un instructor să aibă timp să răspundă la întrebări. Asigurați-vă "
"că sala are _locuri/birouri pentru dumneavoastră și pentru studenți: cu "
"toții veți avea nevoie să puteți sta jos și să lucrați cu laptopurile. În "
"special, în calitate de instructor, veți face o mulțime de live-coding, așa "
"că un pupitru nu vă va fi de mare ajutor."

#: src/running-the-course.md
msgid ""
"On the day of your course, show up to the room a little early to set things "
"up. We recommend presenting directly using `mdbook serve` running on your "
"laptop (see the [installation instructions](https://github.com/google/"
"comprehensive-rust#building)). This ensures optimal performance with no lag "
"as you change pages. Using your laptop will also allow you to fix typos as "
"you or the course participants spot them."
msgstr ""
"Ajungeți în sală cu suficient timp înainte pentru a pregăti totul. Vă "
"recomandăm să prezentați direct folosind `mdbook serve` care rulează pe "
"laptopul dumneavoastră (consultați [instrucțiuni de instalare](https://"
"github.com/google/comprehensive-rust#building)). Acest lucru asigură o "
"performanță optimă, fără întârzieri în timp ce schimbați paginile. Folosirea "
"laptopului vă va permite, de asemenea, să corectați greșelile de tipar pe "
"măsură ce dumneavoastră sau participanții la curs le descoperiți."

#: src/running-the-course.md
msgid ""
"Let people solve the exercises by themselves or in small groups. We "
"typically spend 30-45 minutes on exercises in the morning and in the "
"afternoon (including time to review the solutions). Make sure to ask people "
"if they're stuck or if there is anything you can help with. When you see "
"that several people have the same problem, call it out to the class and "
"offer a solution, e.g., by showing people where to find the relevant "
"information in the standard library."
msgstr ""
"Lăsați participanții să rezolve exercițiile singuri sau în grupuri mici. În "
"mod obișnuit, dedicăm 30-45 de minute exercițiilor dimineața și după-amiaza "
"(inclusiv timpul necesar pentru revizuirea soluțiilor). Asigurați-vă că îi "
"întrebați pe cursanți dacă s-au blocat sau dacă există ceva cu care îi "
"puteți ajuta. Când vedeți că mai multe persoane au aceeași problemă, "
"anunțați clasa și oferiți o soluție, de exemplu, arătând unde se pot găsi "
"informațiile relevante în biblioteca standard."

#: src/running-the-course.md
msgid ""
"That is all, good luck running the course! We hope it will be as much fun "
"for you as it has been for us!"
msgstr ""
"Asta e tot, mult succes în prezentarea cursului! Sperăm că va fi la fel de "
"distractiv pentru voi cum a fost pentru noi!"

#: src/running-the-course.md
msgid ""
"Please [provide feedback](https://github.com/google/comprehensive-rust/"
"discussions/86) afterwards so that we can keep improving the course. We "
"would love to hear what worked well for you and what can be made better. "
"Your students are also very welcome to [send us feedback](https://github.com/"
"google/comprehensive-rust/discussions/100)!"
msgstr ""
"Vă rugăm să [oferiți sugestii](https://github.com/google/comprehensive-rust/"
"discussions/86) după aceea, astfel încât să putem îmbunătăți cursul. Dorim "
"să aflăm ce a funcționat bine pentru dumneavoastră și ce putem îmbunătăți. "
"Studenții dumneavoastră sunt, de asemenea, foarte bineveniți să [ne trimită "
"feedback](https://github.com/google/comprehensive-rust/discussions/100)!"

#: src/running-the-course/course-structure.md
msgid "Rust Fundamentals"
msgstr "Fundamentele Rust"

#: src/running-the-course/course-structure.md
msgid ""
"The first four days make up [Rust Fundamentals](../welcome-day-1.md). The "
"days are fast paced and we cover a lot of ground!"
msgstr ""
"Primele patru zile alcătuiesc [Fundamentele Rust](../welcome-day-1.md). "
"Cursul se desfășoară într-un ritm rapid și acoperim o mulțime de subiecte!"

#: src/running-the-course/course-structure.md
msgid "Course schedule:"
msgstr "Programul cursului:"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "Day 1 Morning (2 hours and 5 minutes, including breaks)"
msgstr "Ziua 3 Dimineața (2 ore și 15 minute, inclusiv pauzele)"

#: src/running-the-course/course-structure.md
msgid "[Welcome](../welcome-day-1.md) (5 minutes)"
msgstr "[Introducere](../welcome-day-1.md) (5 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Hello, World](../hello-world.md) (15 minutes)"
msgstr "[Hello, World](../hello-world.md) (20 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Types and Values](../types-and-values.md) (40 minutes)"
msgstr "[Tipuri și valori](../types-and-values.md) (1 oră și 5 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Control Flow Basics](../control-flow-basics.md) (40 minutes)"
msgstr "[Bazele fluxului de control](../control-flow-basics.md) (1 oră)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "Day 1 Afternoon (2 hours and 35 minutes, including breaks)"
msgstr "Ziua 1 După-amiaza (2 ore și 55 de minute, inclusiv pauzele)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Tuples and Arrays](../tuples-and-arrays.md) (35 minutes)"
msgstr "[Tupluri și array-uri](../tupluri-și-array-uri.md) (1 oră)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[References](../references.md) (55 minutes)"
msgstr "[Referințe](../references.md) (50 minute)"

#: src/running-the-course/course-structure.md
msgid "[User-Defined Types](../user-defined-types.md) (50 minutes)"
msgstr "[Tipuri definite de utilizator](../user-defined-types.md) (50 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "Day 2 Morning (2 hours and 10 minutes, including breaks)"
msgstr "Ziua 2 Dimineața (3 ore și 5 minute, inclusiv pauzele)"

#: src/running-the-course/course-structure.md
msgid "[Welcome](../welcome-day-2.md) (3 minutes)"
msgstr "[Introducere](../welcome-day-2.md) (3 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Pattern Matching](../pattern-matching.md) (1 hour)"
msgstr "[Potrivirea șabloanelor](../pattern-matching.md) (50 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Methods and Traits](../methods-and-traits.md) (50 minutes)"
msgstr "[Metode și trăsături](../methods-and-traits.md) (55 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "Day 2 Afternoon (4 hours, including breaks)"
msgstr "Ziua 3 După-amiaza (2 ore și 20 de minute, inclusiv pauzele)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Generics](../generics.md) (40 minutes)"
msgstr "[Generice](../generics.md) (45 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Standard Library Types](../std-types.md) (1 hour and 20 minutes)"
msgstr "[Tipuri de bibliotecă standard](../std-types.md) (1 oră și 10 minute)"

#: src/running-the-course/course-structure.md
msgid "[Standard Library Traits](../std-traits.md) (1 hour and 40 minutes)"
msgstr ""
"[Trăsături ale bibliotecii standard](../std-traits.md) (1 oră și 40 de "
"minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "Day 3 Morning (2 hours and 20 minutes, including breaks)"
msgstr "Ziua 3 Dimineața (2 ore și 15 minute, inclusiv pauzele)"

#: src/running-the-course/course-structure.md
msgid "[Welcome](../welcome-day-3.md) (3 minutes)"
msgstr "[Introducere](../welcome-day-3.md) (3 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Memory Management](../memory-management.md) (1 hour)"
msgstr "[Managementul memoriei](../memory-management.md) (1 oră și 10 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Smart Pointers](../smart-pointers.md) (55 minutes)"
msgstr "[Pointeri inteligenți](../smart-pointers.md) (45 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "Day 3 Afternoon (1 hour and 55 minutes, including breaks)"
msgstr "Ziua 3 După-amiaza (2 ore și 20 de minute, inclusiv pauzele)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Borrowing](../borrowing.md) (55 minutes)"
msgstr "[Împrumut](../împrumut.md) (1 oră)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Lifetimes](../lifetimes.md) (50 minutes)"
msgstr "[Referințe](../references.md) (50 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "Day 4 Morning (2 hours and 40 minutes, including breaks)"
msgstr "Ziua 4 Dimineața (3 ore și 5 minute, inclusiv pauzele)"

#: src/running-the-course/course-structure.md
msgid "[Welcome](../welcome-day-4.md) (3 minutes)"
msgstr "[Intorducere](../welcome-day-4.md) (3 minute)"

#: src/running-the-course/course-structure.md
msgid "[Iterators](../iterators.md) (45 minutes)"
msgstr "[Iteratori](../iteratori.md) (45 minute)"

#: src/running-the-course/course-structure.md
msgid "[Modules](../modules.md) (40 minutes)"
msgstr "[Module](../modules.md) (40 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Testing](../testing.md) (45 minutes)"
msgstr "[Testare](../testing.md) (1 oră și 5 minute)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "Day 4 Afternoon (2 hours and 10 minutes, including breaks)"
msgstr "Ziua 3 După-amiaza (2 ore și 20 de minute, inclusiv pauzele)"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Error Handling](../error-handling.md) (55 minutes)"
msgstr "[Gestionarea erorilor](../error-handling.md) (45 minute)"

#: src/running-the-course/course-structure.md
msgid "[Unsafe Rust](../unsafe-rust.md) (1 hour and 5 minutes)"
msgstr "[Unsafe Rust](../unsafe-rust.md) (1 oră și 5 minute)"

#: src/running-the-course/course-structure.md
msgid "Deep Dives"
msgstr "Subiecte  aprofundate"

#: src/running-the-course/course-structure.md
msgid ""
"In addition to the 4-day class on Rust Fundamentals, we cover some more "
"specialized topics:"
msgstr ""
"În plus față de cursul de 4 zile despre fundamentele Rust, abordăm câteva "
"subiecte mai specializate:"

#: src/running-the-course/course-structure.md
msgid "Rust in Android"
msgstr "Rust în Android"

#: src/running-the-course/course-structure.md
msgid ""
"The [Rust in Android](../android.md) deep dive is a half-day course on using "
"Rust for Android platform development. This includes interoperability with "
"C, C++, and Java."
msgstr ""
"[Rust în Android](../android.md) este un curs de o jumătate de zi despre "
"utilizarea Rust pentru dezvoltarea platformei Android. Acesta include "
"interoperabilitatea cu C, C++ și Java."

#: src/running-the-course/course-structure.md
msgid ""
"You will need an [AOSP checkout](https://source.android.com/docs/setup/"
"download/downloading). Make a checkout of the [course repository](https://"
"github.com/google/comprehensive-rust) on the same machine and move the `src/"
"android/` directory into the root of your AOSP checkout. This will ensure "
"that the Android build system sees the `Android.bp` files in `src/android/`."
msgstr ""
"Veți avea nevoie de un [sursele AOSP](https://source.android.com/docs/setup/"
"download/downloading). Efectuați o descărcare a [resurselor cursului]"
"(https://github.com/google/comprehensive-rust) pe aceeași mașină și mutați "
"directorul `src/android/` în rădăcina surselor AOSP. Acest lucru va asigura "
"că sistemul de compilare Android vede fișierele `Android.bp` din `src/"
"android/`."

#: src/running-the-course/course-structure.md
msgid ""
"Ensure that `adb sync` works with your emulator or real device and pre-build "
"all Android examples using `src/android/build_all.sh`. Read the script to "
"see the commands it runs and make sure they work when you run them by hand."
msgstr ""
"Asigurați-vă că `adb sync` funcționează cu emulatorul sau cu dispozitivul "
"real și precompilați toate exemplele Android folosind `src/android/build_all."
"sh`. Citiți scriptul pentru a vedea comenzile pe care le execută și "
"asigurați-vă că acestea funcționează atunci când le executați manual."

#: src/running-the-course/course-structure.md
msgid "Rust in Chromium"
msgstr "Rust în Chromium"

#: src/running-the-course/course-structure.md
msgid ""
"The [Rust in Chromium](../chromium.md) deep dive is a half-day course on "
"using Rust as part of the Chromium browser. It includes using Rust in "
"Chromium's `gn` build system, bringing in third-party libraries (\"crates\") "
"and C++ interoperability."
msgstr ""
"[Rust în Chromium](../chromium.md) este un curs aprofundat de o jumătate de "
"zi despre utilizarea Rust ca parte a browserului Chromium. Acesta include "
"utilizarea Rust în sistemul de compilare `gn` al Chromium, aducerea de "
"biblioteci terțe (\"crates\") și interoperabilitatea C++."

#: src/running-the-course/course-structure.md
msgid ""
"You will need to be able to build Chromium --- a debug, component build is "
"[recommended](../chromium/setup.md) for speed but any build will work. "
"Ensure that you can run the Chromium browser that you've built."
msgstr ""
"Va trebui să puteți construi Chromium --- este [recomandat](../chromium/"
"setup.md) un build de depanare, de componente pentru viteză, dar orice build "
"va funcționa. Asigurați-vă că puteți rula browserul Chromium pe care l-ați "
"construit."

#: src/running-the-course/course-structure.md
msgid "Bare-Metal Rust"
msgstr "Rust direct pe placă"

#: src/running-the-course/course-structure.md
msgid ""
"The [Bare-Metal Rust](../bare-metal.md) deep dive is a full day class on "
"using Rust for bare-metal (embedded) development. Both microcontrollers and "
"application processors are covered."
msgstr ""
"[Rust direct pe placă](../bare-metal.md) este un curs de o zi întreagă "
"despre utilizarea Rust pentru dezvoltarea bare-metal (embedded). Sunt "
"acoperite atât microcontrolerele, cât și procesoarele de aplicații."

#: src/running-the-course/course-structure.md
msgid ""
"For the microcontroller part, you will need to buy the [BBC micro:bit]"
"(https://microbit.org/) v2 development board ahead of time. Everybody will "
"need to install a number of packages as described on the [welcome page](../"
"bare-metal.md)."
msgstr ""
"Pentru partea de microcontroler, va trebui să cumpărați din timp placa de "
"dezvoltare [BBC micro:bit](https://microbit.org/) v2. Toată lumea va trebui "
"să instaleze o serie de pachete, așa cum este descris pe [pagina de bun "
"venit](../bare-metal.md)."

#: src/running-the-course/course-structure.md
msgid "Concurrency in Rust"
msgstr "Concurență în Rust"

#: src/running-the-course/course-structure.md
msgid ""
"The [Concurrency in Rust](../concurrency.md) deep dive is a full day class "
"on classical as well as `async`/`await` concurrency."
msgstr ""
"[Concurența în Rust] (../concurrency.md) este un curs de o zi întreagă "
"despre concurența clasică, precum și despre concurența `async`/`await`."

#: src/running-the-course/course-structure.md
msgid ""
"You will need a fresh crate set up and the dependencies downloaded and ready "
"to go. You can then copy/paste the examples into `src/main.rs` to experiment "
"with them:"
msgstr ""
"Veți avea nevoie de un nou crate configurat și de dependențele descărcate și "
"pregătite. Puteți apoi să copiați exemplele în `src/main.rs` pentru a "
"experimenta cu ele:"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "{{%course outline Concurrency}}"
msgstr "{{%course outline Concurrency}}"

#: src/running-the-course/course-structure.md
msgid "Format"
msgstr "Format"

#: src/running-the-course/course-structure.md
msgid ""
"The course is meant to be very interactive and we recommend letting the "
"questions drive the exploration of Rust!"
msgstr ""
"Cursul se dorește a fi foarte interactiv și vă recomandăm să lăsați "
"întrebările să conducă explorarea Rust!"

#: src/running-the-course/keyboard-shortcuts.md
msgid "There are several useful keyboard shortcuts in mdBook:"
msgstr "În mdBook există mai multe comenzi rapide utile de la tastatură:"

#: src/running-the-course/keyboard-shortcuts.md
msgid "Arrow-Left"
msgstr "Săgeată-stânga"

#: src/running-the-course/keyboard-shortcuts.md
msgid ": Navigate to the previous page."
msgstr ": Navigați la pagina anterioară."

#: src/running-the-course/keyboard-shortcuts.md
msgid "Arrow-Right"
msgstr "Săgeată-dreapta"

#: src/running-the-course/keyboard-shortcuts.md
msgid ": Navigate to the next page."
msgstr ": Navigați la pagina următoare."

#: src/running-the-course/keyboard-shortcuts.md src/cargo/code-samples.md
msgid "Ctrl + Enter"
msgstr "Ctrl + Enter"

#: src/running-the-course/keyboard-shortcuts.md
msgid ": Execute the code sample that has focus."
msgstr ": Executați mostra de cod care are focusul."

#: src/running-the-course/keyboard-shortcuts.md
msgid "s"
msgstr "S"

#: src/running-the-course/keyboard-shortcuts.md
msgid ": Activate the search bar."
msgstr ": Activați bara de căutare."

#: src/running-the-course/translations.md
msgid ""
"The course has been translated into other languages by a set of wonderful "
"volunteers:"
msgstr ""
"Cursul a fost tradus în alte limbi de către o serie de voluntari minunați:"

#: src/running-the-course/translations.md
msgid ""
"[Brazilian Portuguese](https://google.github.io/comprehensive-rust/pt-BR/) "
"by [@rastringer](https://github.com/rastringer), [@hugojacob](https://github."
"com/hugojacob), [@joaovicmendes](https://github.com/joaovicmendes), and "
"[@henrif75](https://github.com/henrif75)."
msgstr ""
"[Braziliană portugheză](https://google.github.io/comprehensive-rust/pt-BR/) "
"de [@rastringer](https://github.com/rastringer), [@hugojacob](https://github."
"com/hugojacob), [@joaovicmendes](https://github.com/joaovicmendes) și "
"[@henrif75](https://github.com/henrif75)."

#: src/running-the-course/translations.md
msgid ""
"[Chinese (Simplified)](https://google.github.io/comprehensive-rust/zh-CN/) "
"by [@suetfei](https://github.com/suetfei), [@wnghl](https://github.com/"
"wnghl), [@anlunx](https://github.com/anlunx), [@kongy](https://github.com/"
"kongy), [@noahdragon](https://github.com/noahdragon), [@superwhd](https://"
"github.com/superwhd), [@SketchK](https://github.com/SketchK), and [@nodmp]"
"(https://github.com/nodmp)."
msgstr ""
"[Chineză (simplificată)](https://google.github.io/comprehensive-rust/zh-CN/) "
"de [@suetfei](https://github.com/suetfei), [@wnghl](https://github.com/"
"wnghl), [@anlunx](https://github.com/anlunx), [@kongy](https://github.com/"
"kongy), [@noahdragon](https://github.com/noahdragon), [@superwhd](https://"
"github.com/superwhd), [@SketchK](https://github.com/SketchK), și [@nodmp]"
"(https://github.com/nodmp)."

#: src/running-the-course/translations.md
msgid ""
"[Chinese (Traditional)](https://google.github.io/comprehensive-rust/zh-TW/) "
"by [@hueich](https://github.com/hueich), [@victorhsieh](https://github.com/"
"victorhsieh), [@mingyc](https://github.com/mingyc), [@kuanhungchen](https://"
"github.com/kuanhungchen), and [@johnathan79717](https://github.com/"
"johnathan79717)."
msgstr ""
"[Chineză (tradițională)](https://google.github.io/comprehensive-rust/zh-TW/) "
"de [@hueich](https://github.com/hueich), [@victorhsieh](https://github.com/"
"victorhsieh), [@mingyc](https://github.com/mingyc), [@kuanhungchen](https://"
"github.com/kuanhungchen), și [@johnathan79717](https://github.com/"
"johnathan79717)."

#: src/running-the-course/translations.md
#, fuzzy
msgid ""
"[Korean](https://google.github.io/comprehensive-rust/ko/) by [@keispace]"
"(https://github.com/keispace), [@jiyongp](https://github.com/jiyongp), "
"[@jooyunghan](https://github.com/jooyunghan), and [@namhyung](https://github."
"com/namhyung)."
msgstr ""
"[Coreană](https://google.github.io/comprehensive-rust/ko/) de [@keispace]"
"(https://github.com/keispace), [@jiyongp](https://github.com/jiyongp) și "
"[@jooyunghan](https://github.com/jooyunghan)."

#: src/running-the-course/translations.md
msgid ""
"[Spanish](https://google.github.io/comprehensive-rust/es/) by [@deavid]"
"(https://github.com/deavid)."
msgstr ""
"[Spaniolă](https://google.github.io/comprehensive-rust/es/) de [@deavid]"
"(https://github.com/deavid)."

#: src/running-the-course/translations.md
msgid ""
"Use the language picker in the top-right corner to switch between languages."
msgstr ""
"Utilizați selectorul de limbă din colțul din dreapta sus pentru a comuta "
"între limbi."

#: src/running-the-course/translations.md
msgid "Incomplete Translations"
msgstr "Traduceri incomplete"

#: src/running-the-course/translations.md
msgid ""
"There is a large number of in-progress translations. We link to the most "
"recently updated translations:"
msgstr ""
"Există un număr mare de traduceri în curs de realizare. Iată cele mai "
"recente traduceri actualizate:"

#: src/running-the-course/translations.md
msgid ""
"[Bengali](https://google.github.io/comprehensive-rust/bn/) by [@raselmandol]"
"(https://github.com/raselmandol)."
msgstr ""
"[Bengaleză](https://google.github.io/comprehensive-rust/bn/) de "
"[@raselmandol](https://github.com/raselmandol)."

#: src/running-the-course/translations.md
#, fuzzy
msgid ""
"[French](https://google.github.io/comprehensive-rust/fr/) by [@KookaS]"
"(https://github.com/KookaS), [@vcaen](https://github.com/vcaen) and "
"[@AdrienBaudemont](https://github.com/AdrienBaudemont)."
msgstr ""
"[Franceză](https://google.github.io/comprehensive-rust/fr/) de [@KookaS]"
"(https://github.com/KookaS) și [@vcaen](https://github.com/vcaen)."

#: src/running-the-course/translations.md
msgid ""
"[German](https://google.github.io/comprehensive-rust/de/) by [@Throvn]"
"(https://github.com/Throvn) and [@ronaldfw](https://github.com/ronaldfw)."
msgstr ""
"[Germană](https://google.github.io/comprehensive-rust/de/) de [@Throvn]"
"(https://github.com/Throvn) și [@ronaldfw](https://github.com/ronaldfw)."

#: src/running-the-course/translations.md
msgid ""
"[Japanese](https://google.github.io/comprehensive-rust/ja/) by [@CoinEZ-JPN]"
"(https://github.com/CoinEZ) and [@momotaro1105](https://github.com/"
"momotaro1105)."
msgstr ""
"[Japoneză](https://google.github.io/comprehensive-rust/ja/) de [@CoinEZ-JPN]"
"(https://github.com/CoinEZ) și [@momotaro1105](https://github.com/"
"momotaro1105)."

#: src/running-the-course/translations.md
#, fuzzy
msgid ""
"[Italian](https://google.github.io/comprehensive-rust/it/) by "
"[@henrythebuilder](https://github.com/henrythebuilder) and [@detro](https://"
"github.com/detro)."
msgstr ""
"[Germană](https://google.github.io/comprehensive-rust/de/) de [@Throvn]"
"(https://github.com/Throvn) și [@ronaldfw](https://github.com/ronaldfw)."

#: src/running-the-course/translations.md
msgid ""
"If you want to help with this effort, please see [our instructions](https://"
"github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md) for how to "
"get going. Translations are coordinated on the [issue tracker](https://"
"github.com/google/comprehensive-rust/issues/282)."
msgstr ""
"Dacă doriți să contribuiți la acest efort, vă rugăm să consultați "
"[instrucțiunile noastre](https://github.com/google/comprehensive-rust/blob/"
"main/TRANSLATIONS.md) pentru a afla cum să începeți. Traducerile sunt "
"coordonate pe [issue tracker](https://github.com/google/comprehensive-rust/"
"issues/282)."

#: src/cargo.md
msgid ""
"When you start reading about Rust, you will soon meet [Cargo](https://doc."
"rust-lang.org/cargo/), the standard tool used in the Rust ecosystem to build "
"and run Rust applications. Here we want to give a brief overview of what "
"Cargo is and how it fits into the wider ecosystem and how it fits into this "
"training."
msgstr ""
"Când începeți să citiți despre Rust, veți face cunoștință cu [Cargo](https://"
"doc.rust-lang.org/cargo/), instrumentul standard utilizat în ecosistemul "
"Rust pentru a construi și rula aplicații Rust. Aici dorim să oferim o scurtă "
"prezentare generală a ceea ce este Cargo și a modului în care se integrează "
"în ecosistemul mai larg și cum se încadrează în acest curs de formare."

#: src/cargo.md
msgid "Installation"
msgstr "Instalare"

#: src/cargo.md
msgid "**Please follow the instructions on <https://rustup.rs/>.**"
msgstr "**Vă rugăm să urmați instrucțiunile de pe <https://rustup.rs/>.**"

#: src/cargo.md
msgid ""
"This will give you the Cargo build tool (`cargo`) and the Rust compiler "
"(`rustc`). You will also get `rustup`, a command line utility that you can "
"use to install to different compiler versions."
msgstr ""
"Astfel veți avea acces la instrumentul de compilare Cargo (`cargo`) și "
"compilatorul Rust (`rustc`). De asemenea, veți obține `rustup`, un utilitar "
"de linie de comandă pe care îl puteți utiliza pentru a instala la diferite "
"versiuni de compilator."

#: src/cargo.md
msgid ""
"After installing Rust, you should configure your editor or IDE to work with "
"Rust. Most editors do this by talking to [rust-analyzer](https://rust-"
"analyzer.github.io/), which provides auto-completion and jump-to-definition "
"functionality for [VS Code](https://code.visualstudio.com/), [Emacs](https://"
"rust-analyzer.github.io/manual.html#emacs), [Vim/Neovim](https://rust-"
"analyzer.github.io/manual.html#vimneovim), and many others. There is also a "
"different IDE available called [RustRover](https://www.jetbrains.com/rust/)."
msgstr ""
"După instalarea Rust, trebuie să vă configurați editorul sau IDE-ul pentru a "
"lucra cu Rust. Majoritatea editorilor fac acest lucru comunicând cu [rust-"
"analyzer](https://rust-analyzer.github.io/), care oferă funcționalitate de "
"autocompletare și de salt la definiție pentru [VS Code](https://code."
"visualstudio.com/), [Emacs](https://rust-analyzer.github.io/manual."
"html#emacs), [Vim/Neovim](https://rust-analyzer.github.io/manual."
"html#vimneovim) și multe altele. Există, de asemenea, un alt IDE disponibil, "
"numit [RustRover](https://www.jetbrains.com/rust/)."

#: src/cargo.md
msgid ""
"On Debian/Ubuntu, you can also install Cargo, the Rust source and the [Rust "
"formatter](https://github.com/rust-lang/rustfmt) via `apt`. However, this "
"gets you an outdated rust version and may lead to unexpected behavior. The "
"command would be:"
msgstr ""
"Pe Debian/Ubuntu, puteți instala, de asemenea, Cargo, sursele Rust și "
"[instrumentul de formatare Rust](https://github.com/rust-lang/rustfmt) prin "
"`apt`. Dar veți avea acces la o versiune Rust învechită care poate duce la "
"un comportament neașteptat. Comanda ar fi:"

#: src/cargo/rust-ecosystem.md
msgid "The Rust Ecosystem"
msgstr "Ecosistemul Rust"

#: src/cargo/rust-ecosystem.md
msgid ""
"The Rust ecosystem consists of a number of tools, of which the main ones are:"
msgstr ""
"Ecosistemul Rust este format dintr-un număr de instrumente, dintre care "
"principalele sunt:"

#: src/cargo/rust-ecosystem.md
msgid ""
"`rustc`: the Rust compiler which turns `.rs` files into binaries and other "
"intermediate formats."
msgstr ""
"`rustc`: compilatorul Rust care transformă fișierele `.rs` în fișiere binare "
"și alte formate intermediare."

#: src/cargo/rust-ecosystem.md
msgid ""
"`cargo`: the Rust dependency manager and build tool. Cargo knows how to "
"download dependencies, usually hosted on <https://crates.io>, and it will "
"pass them to `rustc` when building your project. Cargo also comes with a "
"built-in test runner which is used to execute unit tests."
msgstr ""
"`cargo`: managerul de dependențe Rust și instrumentul de construcție. Cargo "
"știe cum să descarce dependențele, de obicei găzduite pe <https://crates."
"io>, și le va transmite la `rustc` atunci când vă construiți proiectul. "
"Cargo vine, de asemenea, cu un instrument de rulat testele încorporat care "
"este folosit pentru a executa testele unitare."

#: src/cargo/rust-ecosystem.md
msgid ""
"`rustup`: the Rust toolchain installer and updater. This tool is used to "
"install and update `rustc` and `cargo` when new versions of Rust are "
"released. In addition, `rustup` can also download documentation for the "
"standard library. You can have multiple versions of Rust installed at once "
"and `rustup` will let you switch between them as needed."
msgstr ""
"`rustup`: programul de instalare și actualizare a lanțului de instrumente "
"Rust. Acest instrument este utilizat pentru a instala și actualiza `rustc` "
"și `cargo` atunci când sunt lansate noi versiuni de Rust. În plus, `rustup` "
"poate descărca și documentația pentru biblioteca standard. Puteți avea mai "
"multe versiuni de Rust instalate în același timp, iar `rustup` vă va permite "
"să treceți de la una la alta în funcție de necesități."

#: src/cargo/rust-ecosystem.md src/types-and-values/hello-world.md
#: src/references/exclusive.md src/memory-management/move.md
#: src/error-handling/try.md src/android/setup.md
#: src/concurrency/async/async-await.md
msgid "Key points:"
msgstr "Puncte-cheie:"

#: src/cargo/rust-ecosystem.md
msgid ""
"Rust has a rapid release schedule with a new release coming out every six "
"weeks. New releases maintain backwards compatibility with old releases --- "
"plus they enable new functionality."
msgstr ""
"Rust are un program de actualizare rapidă, cu o nouă versiune la fiecare "
"șase săptămâni. Noile versiuni mențin compatibilitatea cu versiunile vechi "
"și adaugă noi funcționalități."

#: src/cargo/rust-ecosystem.md
msgid ""
"There are three release channels: \"stable\", \"beta\", and \"nightly\"."
msgstr ""
"Există trei canale de actualizare: \"stable\", \"beta\" și \"nightly\"."

#: src/cargo/rust-ecosystem.md
msgid ""
"New features are being tested on \"nightly\", \"beta\" is what becomes "
"\"stable\" every six weeks."
msgstr ""
"Noile caracteristici sunt testate pe \"nightly\", \"beta\" este ceea ce "
"devine \"stabil\" la fiecare șase săptămâni."

#: src/cargo/rust-ecosystem.md
msgid ""
"Dependencies can also be resolved from alternative [registries](https://doc."
"rust-lang.org/cargo/reference/registries.html), git, folders, and more."
msgstr ""
"De asemenea, dependențele pot fi rezolvate din [registre](https://doc.rust-"
"lang.org/cargo/reference/registries.html) alternative, git, dosare și altele."

#: src/cargo/rust-ecosystem.md
msgid ""
"Rust also has [editions](https://doc.rust-lang.org/edition-guide/): the "
"current edition is Rust 2021. Previous editions were Rust 2015 and Rust 2018."
msgstr ""
"Rust are, de asemenea, [ediții](https://doc.rust-lang.org/edition-guide/): "
"ediția curentă este Rust 2021. Edițiile anterioare au fost Rust 2015 și Rust "
"2018."

#: src/cargo/rust-ecosystem.md
msgid ""
"The editions are allowed to make backwards incompatible changes to the "
"language."
msgstr ""
"Noile edițiile au dreptul de a face modificări ale limbajului incompatibile "
"cu versiuni mai vechi."

#: src/cargo/rust-ecosystem.md
msgid ""
"To prevent breaking code, editions are opt-in: you select the edition for "
"your crate via the `Cargo.toml` file."
msgstr ""
"Pentru a preveni stricarea codului, edițiile sunt opționale: selectați "
"ediția pentru crate-ul dumneavoastră prin intermediul fișierului `Cargo."
"toml`."

#: src/cargo/rust-ecosystem.md
msgid ""
"To avoid splitting the ecosystem, Rust compilers can mix code written for "
"different editions."
msgstr ""
"Pentru a evita divizarea ecosistemului, compilatoarele Rust pot amesteca "
"coduri scrise pentru ediții diferite."

#: src/cargo/rust-ecosystem.md
msgid ""
"Mention that it is quite rare to ever use the compiler directly not through "
"`cargo` (most users never do)."
msgstr ""
"Menționăm că este destul de rar să folosiți compilatorul direct și nu prin "
"`cargo` (majoritatea utilizatorilor nu o fac niciodată)."

#: src/cargo/rust-ecosystem.md
msgid ""
"It might be worth alluding that Cargo itself is an extremely powerful and "
"comprehensive tool. It is capable of many advanced features including but "
"not limited to:"
msgstr ""
"Cargo este un instrument extrem de puternic și cuprinzător. Acesta are multe "
"caracteristici avansate, incluzând:"

#: src/cargo/rust-ecosystem.md
msgid "Project/package structure"
msgstr "Structura proiectului/pachetului"

#: src/cargo/rust-ecosystem.md
msgid "[workspaces](https://doc.rust-lang.org/cargo/reference/workspaces.html)"
msgstr ""
"[spații de lucru](https://doc.rust-lang.org/cargo/reference/workspaces.html)"

#: src/cargo/rust-ecosystem.md
msgid "Dev Dependencies and Runtime Dependency management/caching"
msgstr ""
"Gestionarea/arhivarea dependențelor de dezvoltare și a dependențelor de timp "
"de execuție"

#: src/cargo/rust-ecosystem.md
msgid ""
"[build scripting](https://doc.rust-lang.org/cargo/reference/build-scripts."
"html)"
msgstr ""
"[scripturile de build](https://doc.rust-lang.org/cargo/reference/build-"
"scripts.html)"

#: src/cargo/rust-ecosystem.md
msgid ""
"[global installation](https://doc.rust-lang.org/cargo/commands/cargo-install."
"html)"
msgstr ""
"[instalarea globală](https://doc.rust-lang.org/cargo/commands/cargo-install."
"html)"

#: src/cargo/rust-ecosystem.md
msgid ""
"It is also extensible with sub command plugins as well (such as [cargo "
"clippy](https://github.com/rust-lang/rust-clippy))."
msgstr ""
"Este, de asemenea, extensibil cu pluginuri de subcomandă (cum ar fi [cargo "
"clippy](https://github.com/rust-lang/rust-clippy))."

#: src/cargo/rust-ecosystem.md
msgid ""
"Read more from the [official Cargo Book](https://doc.rust-lang.org/cargo/)"
msgstr ""
"Citiți mai multe din [cartea oficială Cargo](https://doc.rust-lang.org/"
"cargo/)"

#: src/cargo/code-samples.md
msgid "Code Samples in This Training"
msgstr "Exemple de cod în aceast curs"

#: src/cargo/code-samples.md
msgid ""
"For this training, we will mostly explore the Rust language through examples "
"which can be executed through your browser. This makes the setup much easier "
"and ensures a consistent experience for everyone."
msgstr ""
"În cadrul acestui curs, vom explora limbajul Rust în principal prin exemple "
"care pot fi executate prin intermediul browserului dumneavoastră. Acest "
"lucru face configurarea mult mai ușoară și asigură o experiență coerentă "
"pentru toată lumea."

#: src/cargo/code-samples.md
msgid ""
"Installing Cargo is still encouraged: it will make it easier for you to do "
"the exercises. On the last day, we will do a larger exercise which shows you "
"how to work with dependencies and for that you need Cargo."
msgstr ""
"Instalarea Cargo este în continuare încurajată: vă va fi mai ușor să faceți "
"exercițiile. În ultima zi, vom face un exercițiu mai amplu care vă va arăta "
"cum să lucrați cu dependențele și pentru care aveți nevoie de Cargo."

#: src/cargo/code-samples.md
msgid "The code blocks in this course are fully interactive:"
msgstr "Blocurile de cod din acest curs sunt complet interactive:"

#: src/cargo/code-samples.md src/cargo/running-locally.md
msgid "\"Edit me!\""
msgstr "\"Editează-mă!\""

#: src/cargo/code-samples.md
msgid "You can use "
msgstr "Puteți utiliza "

#: src/cargo/code-samples.md
msgid " to execute the code when focus is in the text box."
msgstr " pentru a executa codul atunci când focusul se află în caseta de text."

#: src/cargo/code-samples.md
msgid ""
"Most code samples are editable like shown above. A few code samples are not "
"editable for various reasons:"
msgstr ""
"Majoritatea mostrelor de cod sunt editabile, așa cum se arată mai sus. "
"Câteva mostre de cod nu sunt editabile din diverse motive:"

#: src/cargo/code-samples.md
msgid ""
"The embedded playgrounds cannot execute unit tests. Copy-paste the code and "
"open it in the real Playground to demonstrate unit tests."
msgstr ""
"Zonele de încercare încorporate nu pot executa teste unitare. Copiați și "
"lipiți codul și deschideți-l în locul de zona de lucru locală pentru a "
"demonstra testele unitare."

#: src/cargo/code-samples.md
msgid ""
"The embedded playgrounds lose their state the moment you navigate away from "
"the page! This is the reason that the students should solve the exercises "
"using a local Rust installation or via the Playground."
msgstr ""
"Zonele de încercare încorporate își pierd starea în momentul în care "
"navigați în afara paginii! Acesta este motivul pentru care elevii trebuie să "
"rezolve exercițiile folosind o instalare locală de Rust sau prin intermediul "
"zonei de încercare."

#: src/cargo/running-locally.md
msgid "Running Code Locally with Cargo"
msgstr "Rularea codului la nivel local cu Cargo"

#: src/cargo/running-locally.md
msgid ""
"If you want to experiment with the code on your own system, then you will "
"need to first install Rust. Do this by following the [instructions in the "
"Rust Book](https://doc.rust-lang.org/book/ch01-01-installation.html). This "
"should give you a working `rustc` and `cargo`. At the time of writing, the "
"latest stable Rust release has these version numbers:"
msgstr ""
"Dacă doriți să experimentați cu codul pe propriul sistem, va trebui să "
"instalați mai întâi Rust. Faceți acest lucru urmând [instrucțiunile din "
"Cartea Rust](https://doc.rust-lang.org/book/ch01-01-installation.html). Veți "
"avea astfel un `rustc` și un `cargo` funcțional. La momentul scrierii "
"acestui articol, cea mai recentă versiune stabilă Rust are versiunea:"

#: src/cargo/running-locally.md
msgid ""
"You can use any later version too since Rust maintains backwards "
"compatibility."
msgstr ""
"Puteți utiliza și orice versiune ulterioară, deoarece Rust păstrează "
"compatibilitatea cu versiunile anterioare."

#: src/cargo/running-locally.md
msgid ""
"With this in place, follow these steps to build a Rust binary from one of "
"the examples in this training:"
msgstr ""
"Ulterior urmați acești pași pentru a construi un binar Rust din unul dintre "
"exemplele din acest curs de instruire:"

#: src/cargo/running-locally.md
msgid "Click the \"Copy to clipboard\" button on the example you want to copy."
msgstr ""
"Apăsați pe butonul \"Copy to clipboard\" (Copiere în clipboard) al "
"exemplului pe care doriți să îl copiați."

#: src/cargo/running-locally.md
msgid ""
"Use `cargo new exercise` to create a new `exercise/` directory for your code:"
msgstr ""
"Utilizați `cargo new exercise` pentru a crea un nou director `exercise/` "
"pentru codul dumneavoastră:"

#: src/cargo/running-locally.md
msgid ""
"Navigate into `exercise/` and use `cargo run` to build and run your binary:"
msgstr ""
"Navigați în `exercise/` și folosiți `cargo run` pentru a construi și rula "
"binarul dumneavoastră:"

#: src/cargo/running-locally.md
msgid ""
"Replace the boiler-plate code in `src/main.rs` with your own code. For "
"example, using the example on the previous page, make `src/main.rs` look like"
msgstr ""
"Înlocuiți codul generic din `src/main.rs` cu propriul cod. De exemplu, "
"folosind exemplul de pe pagina anterioară, faceți`src/main.rs` să arate "
"astfel"

#: src/cargo/running-locally.md
msgid "Use `cargo run` to build and run your updated binary:"
msgstr "Utilizați `cargo run` pentru a construi și rula binarul actualizat:"

#: src/cargo/running-locally.md
msgid ""
"Use `cargo check` to quickly check your project for errors, use `cargo "
"build` to compile it without running it. You will find the output in `target/"
"debug/` for a normal debug build. Use `cargo build --release` to produce an "
"optimized release build in `target/release/`."
msgstr ""
"Folosiți `cargo check` pentru a verifica rapid dacă proiectul dumneavoastră "
"are erori, folosiți `cargo build` pentru a-l compila fără a-l rula. Veți "
"găsi rezultatul în `target/debug/` pentru o compilare normală de depanare. "
"Folosiți `cargo build --release` pentru a produce o compilare optimizată de "
"lansare în `target/release/`."

#: src/cargo/running-locally.md
msgid ""
"You can add dependencies for your project by editing `Cargo.toml`. When you "
"run `cargo` commands, it will automatically download and compile missing "
"dependencies for you."
msgstr ""
"Puteți adăuga dependențe pentru proiectul dumneavoastră prin editarea `Cargo."
"toml`. Când executați comenzile `cargo`, acesta va descărca și compila "
"automat dependențele lipsă pentru dumneavoastră."

#: src/cargo/running-locally.md
msgid ""
"Try to encourage the class participants to install Cargo and use a local "
"editor. It will make their life easier since they will have a normal "
"development environment."
msgstr ""
"Încercați să încurajați participanții la curs să instaleze Cargo și să "
"utilizeze un editor local. Acest lucru le va face viața mai ușoară, deoarece "
"vor avea un mediu de dezvoltare normal."

#: src/welcome-day-1.md
msgid "Welcome to Day 1"
msgstr "Bine ați venit la Ziua 1"

#: src/welcome-day-1.md
msgid ""
"This is the first day of Rust Fundamentals. We will cover a lot of ground "
"today:"
msgstr ""
"Aceasta este prima zi a cursului Rust Fundamentals. Vom acoperi o mulțime de "
"subiecte astăzi:"

#: src/welcome-day-1.md
msgid ""
"Basic Rust syntax: variables, scalar and compound types, enums, structs, "
"references, functions, and methods."
msgstr ""
"Sintaxa de bază Rust: variabile, tipuri scalare și compuse, enumerații, "
"structuri, referințe, funcții și metode."

#: src/welcome-day-1.md
msgid "Types and type inference."
msgstr "Tipuri și inferența de tip."

#: src/welcome-day-1.md
msgid "Control flow constructs: loops, conditionals, and so on."
msgstr "Construcții ale fluxului de control: bucle, condiționale și altele."

#: src/welcome-day-1.md
msgid "User-defined types: structs and enums."
msgstr "Tipuri definite de utilizator: structurile și enumerațiile."

#: src/welcome-day-1.md
msgid "Pattern matching: destructuring enums, structs, and arrays."
msgstr ""
"Găsirea de tipare: destructurarea enumerațiilor, structurilor și a "
"tablourilor."

#: src/welcome-day-1.md src/welcome-day-2.md src/welcome-day-3.md
#: src/welcome-day-4.md src/concurrency/welcome.md
#: src/concurrency/welcome-async.md
msgid "Schedule"
msgstr "Program"

#: src/welcome-day-1.md src/welcome-day-1-afternoon.md src/welcome-day-2.md
#: src/welcome-day-2-afternoon.md src/welcome-day-3.md
#: src/welcome-day-3-afternoon.md src/welcome-day-4.md
#: src/welcome-day-4-afternoon.md src/concurrency/welcome.md
#: src/concurrency/welcome-async.md
msgid "In this session:"
msgstr "În această sesiune:"

#: src/welcome-day-1.md
msgid "[Welcome](./welcome-day-1.md) (5 minutes)"
msgstr "[Introducere](./welcome-day-1.md) (5 minute)"

#: src/welcome-day-1.md
#, fuzzy
msgid "[Hello, World](./hello-world.md) (15 minutes)"
msgstr "[Hello, World](./hello-world.md) (20 minute)"

#: src/welcome-day-1.md
#, fuzzy
msgid "[Types and Values](./types-and-values.md) (40 minutes)"
msgstr "[Tipuri și valori](./types-and-values.md) (1 oră și 5 minute)"

#: src/welcome-day-1.md
#, fuzzy
msgid "[Control Flow Basics](./control-flow-basics.md) (40 minutes)"
msgstr "[Bazele fluxului de control](./control-flow-basics.md) (1 oră)"

#: src/welcome-day-1.md
#, fuzzy
msgid ""
"Including 10 minute breaks, this session should take about 2 hours and 5 "
"minutes"
msgstr ""
"Incluzând pauzele de 10 minute, această sesiune ar trebui să dureze "
"aproximativ 2 ore și 55 de minute"

#: src/welcome-day-1.md
msgid "Please remind the students that:"
msgstr "Vă rugăm să le reamintiți cursanților că:"

#: src/welcome-day-1.md
msgid ""
"They should ask questions when they get them, don't save them to the end."
msgstr ""
"Ar trebui să pună întrebări atunci când le primesc, nu să le lase pentru "
"final."

#: src/welcome-day-1.md
msgid ""
"The class is meant to be interactive and discussions are very much "
"encouraged!"
msgstr ""
"Clasa se dorește a fi interactivă, iar discuțiile sunt foarte încurajate!"

#: src/welcome-day-1.md
msgid ""
"As an instructor, you should try to keep the discussions relevant, i.e., "
"keep the discussions related to how Rust does things vs some other language. "
"It can be hard to find the right balance, but err on the side of allowing "
"discussions since they engage people much more than one-way communication."
msgstr ""
"În calitate de instructor, ar trebui să încercați să păstrați discuțiile "
"relevante, adică să păstrați discuțiile legate de modul în care Rust face "
"lucrurile în comparație cu un alt limbaj. Poate fi greu să găsiți echilibrul "
"potrivit, dar e de preferat să permiteți discuțiile, deoarece acestea "
"antrenează oamenii mult mai mult decât comunicarea unidirecțională."

#: src/welcome-day-1.md
msgid ""
"The questions will likely mean that we talk about things ahead of the slides."
msgstr ""
"Întrebările vor însemna probabil că vom vorbi despre lucruri înainte de "
"prezentarea slide-urilor."

#: src/welcome-day-1.md
msgid ""
"This is perfectly okay! Repetition is an important part of learning. "
"Remember that the slides are just a support and you are free to skip them as "
"you like."
msgstr ""
"Acest lucru este perfect în regulă! Repetiția este o parte importantă a "
"învățării. Nu uitați că diapozitivele sunt doar un suport și că sunteți "
"liberi să le săriți după cum doriți."

#: src/welcome-day-1.md
msgid ""
"The idea for the first day is to show the \"basic\" things in Rust that "
"should have immediate parallels in other languages. The more advanced parts "
"of Rust come on the subsequent days."
msgstr ""
"Ideea pentru prima zi este de a arăta lucrurile \"de bază\" din Rust care ar "
"trebui să aibă paralele imediate cu alte limbaje. Părțile mai avansate din "
"Rust vor fi prezentate în zilele următoare."

#: src/welcome-day-1.md
msgid ""
"If you're teaching this in a classroom, this is a good place to go over the "
"schedule. Note that there is an exercise at the end of each segment, "
"followed by a break. Plan to cover the exercise solution after the break. "
"The times listed here are a suggestion in order to keep the course on "
"schedule. Feel free to be flexible and adjust as necessary!"
msgstr ""
"Dacă predați acest curs în clasă, acesta este un loc bun pentru a trece în "
"revistă programul. Rețineți că există un exercițiu la sfârșitul fiecărui "
"segment, urmat de o pauză. Planificați să acoperiți soluția exercițiului "
"după pauză. Orele listate aici sunt o sugestie pentru a menține cursul în "
"program. Nu ezitați să fiți flexibili și să vă adaptați după cum este "
"necesar!"

#: src/hello-world.md src/types-and-values.md src/control-flow-basics.md
#: src/tuples-and-arrays.md src/references.md src/user-defined-types.md
#: src/pattern-matching.md src/methods-and-traits.md src/generics.md
#: src/std-types.md src/std-traits.md src/memory-management.md
#: src/smart-pointers.md src/borrowing.md src/lifetimes.md src/iterators.md
#: src/modules.md src/testing.md src/error-handling.md src/unsafe-rust.md
#: src/concurrency/threads.md src/concurrency/channels.md
#: src/concurrency/send-sync.md src/concurrency/shared-state.md
#: src/concurrency/sync-exercises.md src/concurrency/async.md
#: src/concurrency/async-control-flow.md src/concurrency/async-pitfalls.md
#: src/concurrency/async-exercises.md
msgid "In this segment:"
msgstr "În acest segment:"

#: src/hello-world.md
msgid "[What is Rust?](./hello-world/what-is-rust.md) (10 minutes)"
msgstr "[Ce este Rust?](./hello-world/what-is-rust.md) (10 minute)"

#: src/hello-world.md
msgid "[Benefits of Rust](./hello-world/benefits.md) (3 minutes)"
msgstr "[Avantajele Rust](./hello-world/benefits.md) (3 minute)"

#: src/hello-world.md
msgid "[Playground](./hello-world/playground.md) (2 minutes)"
msgstr "[Terenul de joacă](./hello-world/playground.md) (2 minute)"

#: src/hello-world.md src/concurrency/send-sync.md
msgid "This segment should take about 15 minutes"
msgstr "Acest segment ar trebui să dureze aproximativ 15 minute"

#: src/hello-world/what-is-rust.md
msgid ""
"Rust is a new programming language which had its [1.0 release in 2015]"
"(https://blog.rust-lang.org/2015/05/15/Rust-1.0.html):"
msgstr ""
"Rust este un nou limbaj de programare care a avut [versiunea 1.0 în 2015]"
"(https://blog.rust-lang.org/2015/05/15/Rust-1.0.html):"

#: src/hello-world/what-is-rust.md
msgid "Rust is a statically compiled language in a similar role as C++"
msgstr "Rust este un limbaj compilat static, cu un rol similar cu C++"

#: src/hello-world/what-is-rust.md
msgid "`rustc` uses LLVM as its backend."
msgstr "`rustc` folosește LLVM ca backend."

#: src/hello-world/what-is-rust.md
msgid ""
"Rust supports many [platforms and architectures](https://doc.rust-lang.org/"
"nightly/rustc/platform-support.html):"
msgstr ""
"Rust suportă multe [platforme și arhitecturi](https://doc.rust-lang.org/"
"nightly/rustc/platform-support.html):"

#: src/hello-world/what-is-rust.md
msgid "x86, ARM, WebAssembly, ..."
msgstr "x86, ARM, WebAssembly, ..."

#: src/hello-world/what-is-rust.md
msgid "Linux, Mac, Windows, ..."
msgstr "Linux, Mac, Windows, ..."

#: src/hello-world/what-is-rust.md
msgid "Rust is used for a wide range of devices:"
msgstr "Rust este utilizat pentru o gamă largă de dispozitive:"

#: src/hello-world/what-is-rust.md
msgid "firmware and boot loaders,"
msgstr "firmware și boot leaders,"

#: src/hello-world/what-is-rust.md
msgid "smart displays,"
msgstr "ecrane inteligente,"

#: src/hello-world/what-is-rust.md
msgid "mobile phones,"
msgstr "telefoane mobile,"

#: src/hello-world/what-is-rust.md
msgid "desktops,"
msgstr "desktop-uri,"

#: src/hello-world/what-is-rust.md
msgid "servers."
msgstr "servere."

#: src/hello-world/what-is-rust.md
msgid "Rust fits in the same area as C++:"
msgstr "Rust se încadrează în aceeași zonă ca și C++:"

#: src/hello-world/what-is-rust.md
msgid "High flexibility."
msgstr "Flexibilitate ridicată."

#: src/hello-world/what-is-rust.md
msgid "High level of control."
msgstr "Nivel ridicat de control."

#: src/hello-world/what-is-rust.md
msgid ""
"Can be scaled down to very constrained devices such as microcontrollers."
msgstr ""
"Poate fi redus pentru a rula pe dispozitive foarte limitate, cum ar fi "
"microcontrolerele."

#: src/hello-world/what-is-rust.md
msgid "Has no runtime or garbage collection."
msgstr "Nu are nevoie de mediu de execuție și nici de colectare de gunoi."

#: src/hello-world/what-is-rust.md
msgid "Focuses on reliability and safety without sacrificing performance."
msgstr ""
"Se concentrează pe fiabilitate și siguranță fără a sacrifica performanța."

#: src/hello-world/benefits.md
msgid "Some unique selling points of Rust:"
msgstr "Câteva caracteristici ale Rust:"

#: src/hello-world/benefits.md
msgid ""
"_Compile time memory safety_ - whole classes of memory bugs are prevented at "
"compile time"
msgstr ""
"_Siguranța memoriei la compilare_ - clase întregi de erori de memorie sunt "
"prevenite la compilare"

#: src/hello-world/benefits.md
msgid "No uninitialized variables."
msgstr "Nu există variabile neinițializate."

#: src/hello-world/benefits.md
msgid "No double-frees."
msgstr "Nu există eliberări duble de memorie."

#: src/hello-world/benefits.md
msgid "No use-after-free."
msgstr "Nu se utilizează după eliberare."

#: src/hello-world/benefits.md
msgid "No `NULL` pointers."
msgstr "Nu există pointeri `NULL`."

#: src/hello-world/benefits.md
msgid "No forgotten locked mutexes."
msgstr "Nu s-au uitat mutexuri blocate."

#: src/hello-world/benefits.md
msgid "No data races between threads."
msgstr "Nu există concurență la date între firele de execuție."

#: src/hello-world/benefits.md
msgid "No iterator invalidation."
msgstr "Nu sunt invalidări ale iteratorilor."

#: src/hello-world/benefits.md
msgid ""
"_No undefined runtime behavior_ - what a Rust statement does is never left "
"unspecified"
msgstr ""
"_Fără comportament nedefinit în timp de execuție_ - ceea ce face o "
"declarație Rust nu este niciodată nespecificat"

#: src/hello-world/benefits.md
msgid "Array access is bounds checked."
msgstr "Accesul la matrice este verificat în funcție de limite."

#: src/hello-world/benefits.md
msgid "Integer overflow is defined (panic or wrap-around)."
msgstr "Este definită depășirea numărului întreg (panică sau wrap-around)."

#: src/hello-world/benefits.md
msgid ""
"_Modern language features_ - as expressive and ergonomic as higher-level "
"languages"
msgstr ""
"_Caracteristicile limbajelor moderne_ - la fel de expresive și ergonomice ca "
"și limbajele de nivel superior"

#: src/hello-world/benefits.md
msgid "Enums and pattern matching."
msgstr "Enums și găsirea de modele."

#: src/hello-world/benefits.md
msgid "Generics."
msgstr "Tipuri generice."

#: src/hello-world/benefits.md
msgid "No overhead FFI."
msgstr "FFI fără costuri suplimentare."

#: src/hello-world/benefits.md
msgid "Zero-cost abstractions."
msgstr "Abstracții fără costuri."

#: src/hello-world/benefits.md
msgid "Great compiler errors."
msgstr "Erorile de compilare importante."

#: src/hello-world/benefits.md
msgid "Built-in dependency manager."
msgstr "Manager de dependențe încorporat."

#: src/hello-world/benefits.md
msgid "Built-in support for testing."
msgstr "Suport pentru testare încorporat."

#: src/hello-world/benefits.md
msgid "Excellent Language Server Protocol support."
msgstr "Suport excelent pentru protocolul serverului de limbă."

#: src/hello-world/benefits.md
msgid ""
"Do not spend much time here. All of these points will be covered in more "
"depth later."
msgstr ""
"Nu petreceți mult timp aici. Toate aceste puncte vor fi abordate mai în "
"profunzime mai târziu."

#: src/hello-world/benefits.md
msgid ""
"Make sure to ask the class which languages they have experience with. "
"Depending on the answer you can highlight different features of Rust:"
msgstr ""
"Nu uitați să întrebați elevii din clasă cu ce limbaje au experiență. În "
"funcție de răspuns, puteți evidenția diferite caracteristici ale Rust:"

#: src/hello-world/benefits.md
msgid ""
"Experience with C or C++: Rust eliminates a whole class of _runtime errors_ "
"via the borrow checker. You get performance like in C and C++, but you don't "
"have the memory unsafety issues. In addition, you get a modern language with "
"constructs like pattern matching and built-in dependency management."
msgstr ""
"Experiență cu C sau C++: Rust elimină o întreagă clasă de erori de execuție "
"prin intermediul verificatorului de împrumuturi. Obțineți performanțe ca în "
"C și C++, dar nu aveți probleme de nesiguranță a memoriei. În plus, obțineți "
"un limbaj modern, cu construcții precum șabloane de potrivire și gestionarea "
"integrată a dependențelor."

#: src/hello-world/benefits.md
msgid ""
"Experience with Java, Go, Python, JavaScript...: You get the same memory "
"safety as in those languages, plus a similar high-level language feeling. In "
"addition you get fast and predictable performance like C and C++ (no garbage "
"collector) as well as access to low-level hardware (should you need it)"
msgstr ""
"Experiență cu Java, Go, Python, JavaScript...: Obțineți aceeași siguranță a "
"memoriei ca în aceste limbaje, plus o senzație similară de limbaj de nivel "
"înalt. În plus, obțineți performanțe rapide și previzibile ca în C și C++ "
"(fără colector de memorie), precum și acces la hardware de nivel scăzut "
"(dacă aveți nevoie)"

#: src/hello-world/playground.md
msgid ""
"The [Rust Playground](https://play.rust-lang.org/) provides an easy way to "
"run short Rust programs, and is the basis for the examples and exercises in "
"this course. Try running the \"hello-world\" program it starts with. It "
"comes with a few handy features:"
msgstr ""
"[Rust Playground](https://play.rust-lang.org/) oferă o modalitate ușoară de "
"a rula programe Rust scurte și reprezintă baza pentru exemplele și "
"exercițiile din acest curs. Încercați să rulați programul \"hello-world\" cu "
"care începe. Acesta vine cu câteva caracteristici utile:"

#: src/hello-world/playground.md
msgid ""
"Under \"Tools\", use the `rustfmt` option to format your code in the "
"\"standard\" way."
msgstr ""
"În secțiunea \"Tools\", utilizați opțiunea `rustfmt` pentru a formata codul "
"în mod \"standard\"."

#: src/hello-world/playground.md
msgid ""
"Rust has two main \"profiles\" for generating code: Debug (extra runtime "
"checks, less optimization) and Release (fewer runtime checks, lots of "
"optimization). These are accessible under \"Debug\" at the top."
msgstr ""
"Rust are două \"profiluri\" principale pentru generarea de cod: Debug "
"(verificări suplimentare în timpul execuției, mai puțină optimizare) și "
"Release (mai puține verificări în timpul execuției, multă optimizare). "
"Acestea sunt accesibile sub \"Debug\" în partea de sus."

#: src/hello-world/playground.md
msgid ""
"If you're interested, use \"ASM\" under \"...\" to see the generated "
"assembly code."
msgstr ""
"Dacă sunteți interesați, utilizați \"ASM\" sub \"...\" pentru a vedea codul "
"de asamblare generat."

#: src/hello-world/playground.md
msgid ""
"As students head into the break, encourage them to open up the playground "
"and experiment a little. Encourage them to keep the tab open and try things "
"out during the rest of the course. This is particularly helpful for advanced "
"students who want to know more about Rust's optimizations or generated "
"assembly."
msgstr ""
"Încurajați cursanții să experimenteze în mediul de lucru virtual pe "
"parcursul restului cursului. Acest lucru este deosebit de util pentru "
"studenții avansați care doresc să afle mai multe despre optimizările Rust "
"sau despre codul în limbaj de asamblare generat."

#: src/types-and-values.md
#, fuzzy
msgid "[Hello, World](./types-and-values/hello-world.md) (5 minutes)"
msgstr "[Hello, World](./hello-world/hello-world.md) (5 minute)"

#: src/types-and-values.md
msgid "[Variables](./types-and-values/variables.md) (5 minutes)"
msgstr "[Variabile](./types-and-values/variables.md) (5 minute)"

#: src/types-and-values.md
#, fuzzy
msgid "[Values](./types-and-values/values.md) (5 minutes)"
msgstr "[Valori](./types-and-values/values.md) (10 minute)"

#: src/types-and-values.md
#, fuzzy
msgid "[Arithmetic](./types-and-values/arithmetic.md) (3 minutes)"
msgstr "[Aritmetică](./types-and-values/arithmetic.md) (5 minute)"

#: src/types-and-values.md
#, fuzzy
msgid "[Type Inference](./types-and-values/inference.md) (3 minutes)"
msgstr "[Inferență de tip](./types-and-values/inference.md) (5 minute)"

#: src/types-and-values.md
#, fuzzy
msgid "[Exercise: Fibonacci](./types-and-values/exercise.md) (15 minutes)"
msgstr "[Exercițiu: Fibonacci](./types-and-values/exercise.md) (30 minute)"

#: src/types-and-values.md src/control-flow-basics.md src/generics.md
#: src/modules.md
#, fuzzy
msgid "This segment should take about 40 minutes"
msgstr "Acest segment ar trebui să dureze aproximativ 40 de minute"

#: src/types-and-values/hello-world.md
msgid ""
"Let us jump into the simplest possible Rust program, a classic Hello World "
"program:"
msgstr ""
"Să trecem la cel mai simplu program Rust posibil, un program clasic Bună "
"Lume:"

#: src/types-and-values/hello-world.md
msgid "\"Hello 🌍!\""
msgstr "\"Bună ziua 🌍!\""

#: src/types-and-values/hello-world.md
msgid "What you see:"
msgstr "Ce vedeți:"

#: src/types-and-values/hello-world.md
msgid "Functions are introduced with `fn`."
msgstr "Funcțiile sunt introduse cu `fn`."

#: src/types-and-values/hello-world.md
msgid "Blocks are delimited by curly braces like in C and C++."
msgstr "Blocurile sunt delimitate prin paranteze curbe, ca în C și C++."

#: src/types-and-values/hello-world.md
msgid "The `main` function is the entry point of the program."
msgstr "Funcția `main` este punctul de intrare al programului."

#: src/types-and-values/hello-world.md
msgid "Rust has hygienic macros, `println!` is an example of this."
msgstr "Rust are macro-uri igienice, `println!` este un exemplu în acest sens."

#: src/types-and-values/hello-world.md
msgid "Rust strings are UTF-8 encoded and can contain any Unicode character."
msgstr ""
"Șirurile de caractere Rust sunt codificate UTF-8 și pot conține orice "
"caracter Unicode."

#: src/types-and-values/hello-world.md
msgid ""
"This slide tries to make the students comfortable with Rust code. They will "
"see a ton of it over the next four days so we start small with something "
"familiar."
msgstr ""
"Această pagină încearcă să îi facă pe cursanți să se simtă confortabil cu "
"codul Rust. Ei vor vedea o mulțime de astfel de fișiere în următoarele trei "
"zile, așa că vom începe cu ceva familiar."

#: src/types-and-values/hello-world.md
msgid ""
"Rust is very much like other languages in the C/C++/Java tradition. It is "
"imperative and it doesn't try to reinvent things unless absolutely necessary."
msgstr ""
"Rust se aseamănă foarte mult cu alte limbaje de genul C/C++/Java. Este "
"imperativ și nu încearcă să reinventeze lucrurile decât dacă este absolut "
"necesar."

#: src/types-and-values/hello-world.md
msgid "Rust is modern with full support for things like Unicode."
msgstr "Rust este modern, cu suport complet pentru lucruri precum Unicode."

#: src/types-and-values/hello-world.md
msgid ""
"Rust uses macros for situations where you want to have a variable number of "
"arguments (no function [overloading](../control-flow-basics/functions.md))."
msgstr ""
"Rust folosește macrocomenzi pentru situațiile în care doriți să aveți un "
"număr variabil de argumente (fără [supraîncărcare](basic-syntax/functions-"
"interlude.md) de funcții )."

#: src/types-and-values/hello-world.md
msgid ""
"Macros being 'hygienic' means they don't accidentally capture identifiers "
"from the scope they are used in. Rust macros are actually only [partially "
"hygienic](https://veykril.github.io/tlborm/decl-macros/minutiae/hygiene."
"html)."
msgstr ""
"Fiind \"igienice\", macrourile înseamnă că nu captează accidental "
"identificatori din domeniul de aplicare în care sunt utilizate. Macro-urile "
"Rust sunt de fapt doar [parțial igienice](https://veykril.github.io/tlborm/"
"decl-macros/minutiae/hygiene.html)."

#: src/types-and-values/hello-world.md
msgid ""
"Rust is multi-paradigm. For example, it has powerful [object-oriented "
"programming features](https://doc.rust-lang.org/book/ch17-00-oop.html), and, "
"while it is not a functional language, it includes a range of [functional "
"concepts](https://doc.rust-lang.org/book/ch13-00-functional-features.html)."
msgstr ""
"Rust este multi-paradigmă. De exemplu, are [caracteristici puternice de "
"programare orientată pe obiecte](https://doc.rust-lang.org/book/ch17-00-oop."
"html) și, deși nu este un limbaj funcțional, include o serie de [concepte "
"funcționale](https://doc.rust-lang.org/book/ch13-00-functional-features."
"html)."

#: src/types-and-values/variables.md
msgid ""
"Rust provides type safety via static typing. Variable bindings are made with "
"`let`:"
msgstr ""
"Rust oferă siguranță de tip prin intermediul tipizării statice. Legăturile "
"variabilelor sunt imuabile în mod implicit:"

#: src/types-and-values/variables.md src/control-flow-basics/loops/for.md
#: src/control-flow-basics/blocks-and-scopes.md
msgid "\"x: {x}\""
msgstr "\"x: {x}\""

#: src/types-and-values/variables.md
msgid ""
"// x = 20;\n"
"    // println!(\"x: {x}\");\n"
msgstr ""
"// x = 20;\n"
"    // println!(\"x: {x}\");\n"

#: src/types-and-values/variables.md
msgid ""
"Uncomment the `x = 20` to demonstrate that variables are immutable by "
"default. Add the `mut` keyword to allow changes."
msgstr ""
"Scoateți comentariul `x = 20` pentru a demonstra că variabilele sunt "
"imuabile în mod implicit. Adăugați cuvântul cheie `mut` pentru a permite "
"modificări."

#: src/types-and-values/variables.md
msgid ""
"The `i32` here is the type of the variable. This must be known at compile "
"time, but type inference (covered later) allows the programmer to omit it in "
"many cases."
msgstr ""
"Aici `i32` este tipul variabilei. Acesta trebuie să fie cunoscut la "
"compilare, dar inferența de tip (abordată mai târziu) permite "
"programatorului să o omită în multe cazuri."

#: src/types-and-values/values.md
msgid ""
"Here are some basic built-in types, and the syntax for literal values of "
"each type."
msgstr ""
"Iată câteva tipuri de bază încorporate și sintaxa pentru valorile literale "
"ale fiecărui tip."

#: src/types-and-values/values.md src/unsafe-rust/exercise.md
msgid "Types"
msgstr "Tipuri"

#: src/types-and-values/values.md
msgid "Literals"
msgstr "Literale"

#: src/types-and-values/values.md
msgid "Signed integers"
msgstr "Numere întregi cu semn"

#: src/types-and-values/values.md
msgid "`i8`, `i16`, `i32`, `i64`, `i128`, `isize`"
msgstr "`i8`, `i16`, `i32`, `i64`, `i128`, `isize`"

#: src/types-and-values/values.md
msgid "`-10`, `0`, `1_000`, `123_i64`"
msgstr "`-10`, `0`, `1_000`, `123_i64`"

#: src/types-and-values/values.md
msgid "Unsigned integers"
msgstr "Întregi fără semn"

#: src/types-and-values/values.md
msgid "`u8`, `u16`, `u32`, `u64`, `u128`, `usize`"
msgstr "`u8`, `u16`, `u32`, `u64`, `u128`, `usize`"

#: src/types-and-values/values.md
msgid "`0`, `123`, `10_u16`"
msgstr "`0`, `123`, `10_u16`"

#: src/types-and-values/values.md
msgid "Floating point numbers"
msgstr "Numere în virgulă mobilă"

#: src/types-and-values/values.md
msgid "`f32`, `f64`"
msgstr "`f32`, `f64`"

#: src/types-and-values/values.md
msgid "`3.14`, `-10.0e20`, `2_f32`"
msgstr "`3.14`, `-10.0e20`, `2_f32`"

#: src/types-and-values/values.md
msgid "Unicode scalar values"
msgstr "Valori scalare Unicode"

#: src/types-and-values/values.md src/android/aidl/types/primitives.md
msgid "`char`"
msgstr "`char`"

#: src/types-and-values/values.md
msgid "`'a'`, `'α'`, `'∞'`"
msgstr "`'a'`, `'α'`, `'∞'`"

#: src/types-and-values/values.md
msgid "Booleans"
msgstr "Booleeni"

#: src/types-and-values/values.md src/android/aidl/types/primitives.md
msgid "`bool`"
msgstr "`bool`"

#: src/types-and-values/values.md
msgid "`true`, `false`"
msgstr "`true`, `false`"

#: src/types-and-values/values.md
msgid "The types have widths as follows:"
msgstr "Tipurile au lungimi după cum urmează:"

#: src/types-and-values/values.md
msgid "`iN`, `uN`, and `fN` are _N_ bits wide,"
msgstr "`iN`, `uN`, și `fN` au o lungime de _N_ biți,"

#: src/types-and-values/values.md
msgid "`isize` and `usize` are the width of a pointer,"
msgstr "`isize` și `usize` reprezintă lungimea unui pointer,"

#: src/types-and-values/values.md
msgid "`char` is 32 bits wide,"
msgstr "`char` are o lungime de 32 de biți,"

#: src/types-and-values/values.md
msgid "`bool` is 8 bits wide."
msgstr "`bool` are o lungime de 8 biți."

#: src/types-and-values/values.md
msgid "There are a few syntaxes which are not shown above:"
msgstr "Există câteva elemente de sintaxă care nu sunt prezentate mai sus:"

#: src/types-and-values/values.md
msgid ""
"All underscores in numbers can be left out, they are for legibility only. So "
"`1_000` can be written as `1000` (or `10_00`), and `123_i64` can be written "
"as `123i64`."
msgstr ""
"Toate sublinierile din numere pot fi omise, ele sunt folosite doar pentru "
"lizibilitate. Astfel, `1_000` poate fi scris ca `1000` (sau `10_00`), iar "
"`123_i64` poate fi scris ca `123i64`."

#: src/types-and-values/arithmetic.md
msgid "\"result: {}\""
msgstr "\"result: {}\""

#: src/types-and-values/arithmetic.md
msgid ""
"This is the first time we've seen a function other than `main`, but the "
"meaning should be clear: it takes three integers, and returns an integer. "
"Functions will be covered in more detail later."
msgstr ""
"Aceasta este prima dată când vedem o altă funcție decât `main`, dar "
"semnificația ar trebui să fie clară: primește trei numere întregi și "
"returnează un număr întreg. Funcțiile vor fi tratate mai în detaliu mai "
"târziu."

#: src/types-and-values/arithmetic.md
msgid "Arithmetic is very similar to other languages, with similar precedence."
msgstr ""
"Aritmetica este foarte asemănătoare cu cea din alte limbaje, cu precedență "
"similară."

#: src/types-and-values/arithmetic.md
msgid ""
"What about integer overflow? In C and C++ overflow of _signed_ integers is "
"actually undefined, and might do different things on different platforms or "
"compilers. In Rust, it's defined."
msgstr ""
"Cum rămâne cu depășirea de numere întregi? În C și C++, depășirea numărului "
"de numere întregi cu semn este, de fapt, nedefinită și poate avea efecte "
"diferite pe diferite platforme sau compilatoare. În Rust, este definită."

#: src/types-and-values/arithmetic.md
#, fuzzy
msgid ""
"Change the `i32`'s to `i16` to see an integer overflow, which panics "
"(checked) in a debug build and wraps in a release build. There are other "
"options, such as overflowing, saturating, and carrying. These are accessed "
"with method syntax, e.g., `(a * b).saturating_add(b * c).saturating_add(c * "
"a)`."
msgstr ""
"Schimbați `i32` în `i16` pentru a vedea o depășire de număr întreg, care "
"intră în panică (verificată) într-o compilare de depanare și care se "
"înfășoară într-o compilare de release. Există și alte opțiuni, cum ar fi "
"depășirea, saturarea și reținerea depășirii. Acestea sunt accesate cu "
"sintaxa metodei, de exemplu, `(a * b).saturating_add(b * c).saturating_add(c "
"* a)`."

#: src/types-and-values/arithmetic.md
msgid ""
"In fact, the compiler will detect overflow of constant expressions, which is "
"why the example requires a separate function."
msgstr ""
"De fapt, compilatorul va detecta depășirea expresiilor constante, motiv "
"pentru care exemplul necesită o funcție separată."

#: src/types-and-values/inference.md
msgid "Rust will look at how the variable is _used_ to determine the type:"
msgstr ""
"Rust se va uita la modul în care variabila este _utilizată_ pentru a "
"determina tipul:"

#: src/types-and-values/inference.md
msgid ""
"This slide demonstrates how the Rust compiler infers types based on "
"constraints given by variable declarations and usages."
msgstr ""
"Această pagină demonstrează modul în care compilatorul Rust deduce tipurile "
"pe baza constrângerilor date de declarațiile și utilizările variabilelor."

#: src/types-and-values/inference.md
msgid ""
"It is very important to emphasize that variables declared like this are not "
"of some sort of dynamic \"any type\" that can hold any data. The machine "
"code generated by such declaration is identical to the explicit declaration "
"of a type. The compiler does the job for us and helps us write more concise "
"code."
msgstr ""
"Este foarte important să subliniem că variabilele declarate astfel nu sunt "
"de un fel de \"tip dinamic\" care poate conține orice date. Codul mașină "
"generat de o astfel de declarație este identic cu declarația explicită a "
"unui tip. Compilatorul face treaba în locul nostru și ne ajută să scriem un "
"cod mai concis."

#: src/types-and-values/inference.md
msgid ""
"When nothing constrains the type of an integer literal, Rust defaults to "
"`i32`. This sometimes appears as `{integer}` in error messages. Similarly, "
"floating-point literals default to `f64`."
msgstr ""
"Atunci când nu există constrângeri pentru tipul unui literal de număr "
"întreg, Rust folosește în mod implicit `i32`. Acest lucru apare uneori ca "
"`{integer}` în mesajele de eroare. În mod similar, literalii în virgulă "
"mobilă sunt în mod implicit `f64`."

#: src/types-and-values/inference.md
msgid "// ERROR: no implementation for `{float} == {integer}`\n"
msgstr "// EROARE: nicio implementare pentru `{float} == {integer}`\n"

#: src/types-and-values/exercise.md
#, fuzzy
msgid ""
"The Fibonacci sequence begins with `[0,1]`. For n>1, the n'th Fibonacci "
"number is calculated recursively as the sum of the n-1'th and n-2'th "
"Fibonacci numbers."
msgstr ""
"Primul și al doilea număr Fibonacci sunt ambele `1`. Pentru n>2, cel de-al n-"
"lea număr Fibonacci se calculează recursiv ca sumă a celor două numere "
"anterioare."

#: src/types-and-values/exercise.md
msgid ""
"Write a function `fib(n)` that calculates the n'th Fibonacci number. When "
"will this function panic?"
msgstr ""
"Scrieți o funcție `fib(n)` care să calculeze al n-lea număr Fibonacci. Când "
"va intra în panică această funcție?"

#: src/types-and-values/exercise.md
msgid "// The base case.\n"
msgstr "// Cazul de bază.\n"

#: src/types-and-values/exercise.md src/control-flow-basics/exercise.md
msgid "\"Implement this\""
msgstr ""
"Încercați să rezolvați mai întâi problema în mod \"simplu\", folosind "
"buclele `for` și numere întregi. Apoi, revedeți soluția și încercați să o "
"implementați cu iteratori."

#: src/types-and-values/exercise.md
msgid "// The recursive case.\n"
msgstr "// Cazul recursiv.\n"

#: src/types-and-values/exercise.md src/types-and-values/solution.md
#, fuzzy
msgid "\"fib({n}) = {}\""
msgstr "\"fib(n) = {}\""

#: src/control-flow-basics.md
#, fuzzy
msgid "[if Expressions](./control-flow-basics/if.md) (4 minutes)"
msgstr "[Macrouri](./control-flow-basics/macros.md) (2 minute)"

#: src/control-flow-basics.md
msgid "[Loops](./control-flow-basics/loops.md) (5 minutes)"
msgstr "[Bucle](./control-flow-basics/loops.md) (5 minute)"

#: src/control-flow-basics.md
#, fuzzy
msgid ""
"[break and continue](./control-flow-basics/break-continue.md) (4 minutes)"
msgstr ""
"[`break` și `continue`](./control-flow-basics/break-continue.md) (5 minute)"

#: src/control-flow-basics.md
#, fuzzy
msgid ""
"[Blocks and Scopes](./control-flow-basics/blocks-and-scopes.md) (5 minutes)"
msgstr ""
"[Blocuri și domenii de aplicare](./control-flow-basics/blocks-and-scopes.md) "
"(10 minute)"

#: src/control-flow-basics.md
msgid "[Functions](./control-flow-basics/functions.md) (3 minutes)"
msgstr "[Funcții](./control-flow-basics/functions.md) (3 minute)"

#: src/control-flow-basics.md
msgid "[Macros](./control-flow-basics/macros.md) (2 minutes)"
msgstr "[Macrouri](./control-flow-basics/macros.md) (2 minute)"

#: src/control-flow-basics.md
#, fuzzy
msgid ""
"[Exercise: Collatz Sequence](./control-flow-basics/exercise.md) (15 minutes)"
msgstr ""
"[Exercițiu: Secvența Collatz](./control-flow-basics/exercițiu.md) (30 minute)"

#: src/control-flow-basics/if.md
msgid "`if` expressions"
msgstr "Expresii 'if'"

#: src/control-flow-basics/if.md
msgid ""
"You use [`if` expressions](https://doc.rust-lang.org/reference/expressions/"
"if-expr.html#if-expressions) exactly like `if` statements in other languages:"
msgstr ""
"[Expresiile `if`](https://doc.rust-lang.org/reference/expressions/if-expr."
"html#if-expressions) se utilizează exact ca și instrucțiunile `if` din alte "
"limbaje:"

#: src/control-flow-basics/if.md
#, fuzzy
msgid "\"zero!\""
msgstr "\"zero!\""

#: src/control-flow-basics/if.md
#, fuzzy
msgid "\"biggish\""
msgstr "\"măricel\""

#: src/control-flow-basics/if.md
msgid "\"huge\""
msgstr "\"imens\""

#: src/control-flow-basics/if.md
msgid ""
"In addition, you can use `if` as an expression. The last expression of each "
"block becomes the value of the `if` expression:"
msgstr ""
"În plus, puteți utiliza `if` ca expresie. Ultima expresie din fiecare bloc "
"devine valoarea expresiei `if`:"

#: src/control-flow-basics/if.md
msgid "\"small\""
msgstr "\"mic\""

#: src/control-flow-basics/if.md
msgid "\"large\""
msgstr "\"mare\""

#: src/control-flow-basics/if.md
msgid "\"number size: {}\""
msgstr "\"dimensiunea numărului: {}\""

#: src/control-flow-basics/if.md
msgid ""
"Because `if` is an expression and must have a particular type, both of its "
"branch blocks must have the same type. Show what happens if you add `;` "
"after `\"small\"` in the second example."
msgstr ""
"Deoarece `if` este o expresie și trebuie să aibă un anumit tip, ambele "
"blocuri de ramificare trebuie să aibă același tip. Să vedem ce se întâmplă "
"dacă adăugați `;` după `x / 2` în al doilea exemplu."

#: src/control-flow-basics/if.md
msgid ""
"When `if` is used in an expression, the expression must have a `;` to "
"separate it from the next statement. Remove the `;` before `println!` to see "
"the compiler error."
msgstr ""
"Atunci când `if` este utilizat într-o expresie, expresia trebuie să aibă un "
"`;` pentru a o separa de următoarea declarație. Eliminați `;` înainte de "
"`println!` pentru a vedea eroarea de compilare."

#: src/control-flow-basics/loops.md
msgid "There are three looping keywords in Rust: `while`, `loop`, and `for`:"
msgstr ""
"În Rust există trei cuvinte cheie pentru bucle: `while`, `loop` și `for`:"

#: src/control-flow-basics/loops.md
msgid "`while`"
msgstr "Bucle `while let`"

#: src/control-flow-basics/loops.md
msgid ""
"The [`while` keyword](https://doc.rust-lang.org/reference/expressions/loop-"
"expr.html#predicate-loops) works much like in other languages, executing the "
"loop body as long as the condition is true."
msgstr ""
"Cuvântul cheie [`while`](https://doc.rust-lang.org/reference/expressions/"
"loop-expr.html#predicate-loops) funcționează foarte asemănător cu alte "
"limbaje, executând bucla cât timp condiția este adevărată."

#: src/control-flow-basics/loops.md
msgid "\"Final x: {x}\""
msgstr "\"Final x: {x}\""

#: src/control-flow-basics/loops/for.md
#, fuzzy
msgid ""
"The [`for` loop](https://doc.rust-lang.org/std/keyword.for.html) iterates "
"over ranges of values or the items in a collection:"
msgstr ""
"Buclele [`for`](https://doc.rust-lang.org/std/keyword.for.html) sunt "
"utilizate pentru a itera peste o gamă de valori:"

#: src/control-flow-basics/loops/for.md
#, fuzzy
msgid "\"elem: {elem}\""
msgstr "\"elem: {elem}\""

#: src/control-flow-basics/loops/for.md
#, fuzzy
msgid ""
"Under the hood `for` loops use a concept called \"iterators\" to handle "
"iterating over different kinds of ranges/collections. Iterators will be "
"discussed in more detail later."
msgstr ""
"În cadrul buclelor `for` se utilizează un concept numit \"iteratori\" pentru "
"a gestiona iterația peste diferite tipuri de intervale/colecții. Iteratorii "
"vor fi discutați mai în detaliu mai târziu."

#: src/control-flow-basics/loops/for.md
msgid ""
"Note that the `for` loop only iterates to `4`. Show the `1..=5` syntax for "
"an inclusive range."
msgstr ""
"Rețineți că bucla `for` va itera doar până la `4`. Prezentați sintaxa `1.."
"=5` pentru un interval inclusiv."

#: src/control-flow-basics/loops/loop.md
msgid ""
"The [`loop` statement](https://doc.rust-lang.org/std/keyword.loop.html) just "
"loops forever, until a `break`."
msgstr ""
"Buclele [`loop`](https://doc.rust-lang.org/std/keyword.loop.html) rulează în "
"continuu până se întâlnește o instrucțiune `break`."

#: src/control-flow-basics/loops/loop.md
msgid "\"{i}\""
msgstr "\"{i}\""

#: src/control-flow-basics/break-continue.md
msgid ""
"If you want to immediately start the next iteration use [`continue`](https://"
"doc.rust-lang.org/reference/expressions/loop-expr.html#continue-expressions)."
msgstr ""
"Dacă doriți să începeți imediat următoarea iterație, utilizați [`continue`]"
"(https://doc.rust-lang.org/reference/expressions/loop-expr.html#continue-"
"expressions)."

#: src/control-flow-basics/break-continue.md
msgid ""
"If you want to exit any kind of loop early, use [`break`](https://doc.rust-"
"lang.org/reference/expressions/loop-expr.html#break-expressions). For "
"`loop`, this can take an optional expression that becomes the value of the "
"`loop` expression."
msgstr ""
"Dacă doriți să ieșiți mai devreme dintr-o buclă, utilizați [`break`](https://"
"doc.rust-lang.org/reference/expressions/loop-expr.html#break-expressions). "
"`loop` poate folosi o expresie opțională care devine valoarea buclei."

#: src/control-flow-basics/break-continue.md src/std-traits/exercise.md
#: src/std-traits/solution.md src/smart-pointers/trait-objects.md
#: src/borrowing/interior-mutability.md src/modules/exercise.md
#: src/modules/solution.md src/android/build-rules/library.md
#: src/android/interoperability/cpp/rust-bridge.md
#: src/concurrency/async-pitfalls/cancellation.md
msgid "\"{}\""
msgstr "\"{}\""

#: src/control-flow-basics/break-continue/labels.md
msgid ""
"Both `continue` and `break` can optionally take a label argument which is "
"used to break out of nested loops:"
msgstr ""
"Atât `continue`, cât și `break` pot primi opțional un argument de tip label, "
"care este utilizat pentru a ieși din buclele imbricate:"

#: src/control-flow-basics/break-continue/labels.md
#, fuzzy
msgid "\"elements searched: {elements_searched}\""
msgstr "\"elemente căutate: {elements_searched}\""

#: src/control-flow-basics/break-continue/labels.md
msgid ""
"Note that `loop` is the only looping construct which returns a non-trivial "
"value. This is because it's guaranteed to be entered at least once (unlike "
"`while` and `for` loops)."
msgstr ""
"Rețineți că `loop` este singura construcție de buclă care returnează o "
"valoare non-trivială. Garantează că bocla este rulată cel puțin o dată (spre "
"deosebire de buclele `while` și `for`)."

#: src/control-flow-basics/blocks-and-scopes.md
msgid "Blocks"
msgstr "Blocuri"

#: src/control-flow-basics/blocks-and-scopes.md
msgid ""
"A block in Rust contains a sequence of expressions, enclosed by braces `{}`. "
"Each block has a value and a type, which are those of the last expression of "
"the block:"
msgstr ""
"Un bloc în Rust conține o secvență de expresii. Fiecare bloc are o valoare "
"și un tip, care sunt cele ale ultimei expresii din bloc:"

#: src/control-flow-basics/blocks-and-scopes.md
msgid "\"y: {y}\""
msgstr "\"y: {y}\""

#: src/control-flow-basics/blocks-and-scopes.md
msgid ""
"If the last expression ends with `;`, then the resulting value and type is "
"`()`."
msgstr ""
"Dacă ultima expresie se termină cu `;`, atunci valoarea și tipul rezultat "
"este `()`."

#: src/control-flow-basics/blocks-and-scopes.md
msgid ""
"You can show how the value of the block changes by changing the last line in "
"the block. For instance, adding/removing a semicolon or using a `return`."
msgstr ""
"Puteți arăta cum se modifică valoarea blocului modificând ultima linie din "
"bloc. De exemplu, adăugând/eliminând un punct și virgulă sau folosind un "
"`return`."

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid "A variable's scope is limited to the enclosing block."
msgstr ""
"Domeniul de aplicare al unei variabile este limitat la blocul care o conține."

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid ""
"You can shadow variables, both those from outer scopes and variables from "
"the same scope:"
msgstr ""
"Puteți dedubla variabilele, atât cele din domenii de aplicare exterioare, "
"cât și variabilele din același domeniu de aplicare:"

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid "\"before: {a}\""
msgstr "\"înainte: {a}\""

#: src/control-flow-basics/blocks-and-scopes/scopes.md src/generics/exercise.md
#: src/generics/solution.md src/std-traits/from-and-into.md
#: src/lifetimes/solution.md
msgid "\"hello\""
msgstr "\"hello\""

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid "\"inner scope: {a}\""
msgstr "\"domeniul de aplicare interior: {a}\""

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid "\"shadowed in inner scope: {a}\""
msgstr "\"dedublată în domeniul interior: {a}\""

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid "\"after: {a}\""
msgstr "\"đupă: {a}\""

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid ""
"Show that a variable's scope is limited by adding a `b` in the inner block "
"in the last example, and then trying to access it outside that block."
msgstr ""
"Arătați că domeniul de aplicare al unei variabile este limitat prin "
"adăugarea unui `b` în blocul interior din ultimul exemplu și apoi prin "
"încercarea de a o accesa în afara blocului."

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid ""
"Shadowing is different from mutation, because after shadowing both "
"variable's memory locations exist at the same time. Both are available under "
"the same name, depending where you use it in the code."
msgstr ""
"Definiție: Dedublarea este diferită de mutație, deoarece după dedublare "
"ambele locații de memorie ale variabilei există în același timp. Ambele sunt "
"disponibile sub același nume, în funcție de locul în care se utilizează în "
"cod."

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid "A shadowing variable can have a different type."
msgstr "O variabilă dedublată poate avea un tip diferit."

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid ""
"Shadowing looks obscure at first, but is convenient for holding on to values "
"after `.unwrap()`."
msgstr ""
"Dedublarea pare obscură la început, dar este convenabilă pentru a păstra "
"valorile după `.unwrap()`."

#: src/control-flow-basics/functions.md
msgid ""
"Declaration parameters are followed by a type (the reverse of some "
"programming languages), then a return type."
msgstr ""
"Parametrii de declarație sunt urmați de un tip (invers decât în alte limbaje "
"de programare), apoi de tipul valorii returnate."

#: src/control-flow-basics/functions.md
msgid ""
"The last expression in a function body (or any block) becomes the return "
"value. Simply omit the `;` at the end of the expression. The `return` "
"keyword can be used for early return, but the \"bare value\" form is "
"idiomatic at the end of a function (refactor `gcd` to use a `return`)."
msgstr ""
"Ultima expresie din corpul unei funcții (sau din orice bloc) devine valoarea "
"de returnare. Pur și simplu omiteți `;` de la sfârșitul expresiei. Cuvântul "
"cheie `return` se poate folosi pentru a ieși anticipat din funcție, dar "
"\"valoarea brută\" este idiomatică la sfârșitul funcției (rescrieți `gcr` "
"pentru a utiliza un `return`)."

#: src/control-flow-basics/functions.md
msgid ""
"Some functions have no return value, and return the 'unit type', `()`. The "
"compiler will infer this if the `-> ()` return type is omitted."
msgstr ""
"Unele funcții nu au nicio valoare de retur și returnează \"tipul unitate\", "
"`()`. Compilatorul va deduce acest lucru în cazul în care tipul de returnare "
"`-> ()` este omis."

#: src/control-flow-basics/functions.md
msgid ""
"Overloading is not supported -- each function has a single implementation."
msgstr ""
"Supraîncărcarea nu este suportată — fiecare funcție are o singură "
"implementare."

#: src/control-flow-basics/functions.md
msgid ""
"Always takes a fixed number of parameters. Default arguments are not "
"supported. Macros can be used to support variadic functions."
msgstr ""
"Acceptă întotdeauna un număr fix de parametri. Argumentele implicite nu sunt "
"acceptate. Se pot utiliza macrocomenzi pentru a sprijini funcțiile variadice."

#: src/control-flow-basics/functions.md
msgid ""
"Always takes a single set of parameter types. These types can be generic, "
"which will be covered later."
msgstr ""
"Acceptă întotdeauna un singur set de tipuri de parametri. Acestea pot fi "
"generice, despre care vom discuta mai târziu."

#: src/control-flow-basics/macros.md
msgid ""
"Macros are expanded into Rust code during compilation, and can take a "
"variable number of arguments. They are distinguished by a `!` at the end. "
"The Rust standard library includes an assortment of useful macros."
msgstr ""
"Macrocomenzile sunt expandate în codul Rust în timpul compilării și pot "
"primi un număr variabil de argumente. Ele se disting prin adăugarea unui `!` "
"la sfârșit. Biblioteca standard Rust include o gamă întreagă de macro-uri "
"utile."

#: src/control-flow-basics/macros.md
msgid ""
"`println!(format, ..)` prints a line to standard output, applying formatting "
"described in [`std::fmt`](https://doc.rust-lang.org/std/fmt/index.html)."
msgstr ""
"`println!(format, ..)` afișează o linie la ieșirea standard, aplicând "
"formatarea specificată în [`std::fmt`](https://doc.rust-lang.org/std/fmt/"
"index.html)."

#: src/control-flow-basics/macros.md
msgid ""
"`format!(format, ..)` works just like `println!` but returns the result as a "
"string."
msgstr ""
"`format!(format, ..)` funcționează la fel ca `println!`, dar returnează "
"rezultatul sub forma unui șir de caractere."

#: src/control-flow-basics/macros.md
msgid "`dbg!(expression)` logs the value of the expression and returns it."
msgstr "`dbg!(expresie)` înregistrează valoarea expresiei și o returnează."

#: src/control-flow-basics/macros.md
msgid ""
"`todo!()` marks a bit of code as not-yet-implemented. If executed, it will "
"panic."
msgstr ""
"`todo!()` marchează o bucată de cod ca fiind neimplementată încă. Dacă este "
"executat, va intra în panică."

#: src/control-flow-basics/macros.md
msgid ""
"`unreachable!()` marks a bit of code as unreachable. If executed, it will "
"panic."
msgstr ""
"`unreachable!()` marchează un fragment de cod ca fiind inaccesibil. Dacă "
"este executat, programul va intra în panică."

#: src/control-flow-basics/macros.md
msgid "\"{n}! = {}\""
msgstr "\"{n}! = {}\""

#: src/control-flow-basics/macros.md
msgid ""
"The takeaway from this section is that these common conveniences exist, and "
"how to use them. Why they are defined as macros, and what they expand to, is "
"not especially critical."
msgstr ""
"Trebuie să rețineți cum să folosiți aceste facilități comune. De ce sunt "
"definite ca macro-uri și la ce se extind acestea nu este deosebit de "
"important."

#: src/control-flow-basics/macros.md
#, fuzzy
msgid ""
"The course does not cover defining macros, but a later section will describe "
"use of derive macros."
msgstr ""
"Cursul nu acoperă definirea macrocomenzilor, dar o secțiune ulterioară va "
"descrie utilizarea macrocomenzilor `derive`."

#: src/control-flow-basics/exercise.md
msgid ""
"The [Collatz Sequence](https://en.wikipedia.org/wiki/Collatz_conjecture) is "
"defined as follows, for an arbitrary n"
msgstr ""
"[Secvența Collatz](https://en.wikipedia.org/wiki/Collatz_conjecture) se "
"definește după cum urmează, pentru un număr n arbitrar"

#: src/control-flow-basics/exercise.md
msgid "1"
msgstr "1"

#: src/control-flow-basics/exercise.md
msgid " greater than zero:"
msgstr " mai mare decât zero:"

#: src/control-flow-basics/exercise.md
msgid "If _n"
msgstr "If _n"

#: src/control-flow-basics/exercise.md
msgid "i"
msgstr "i"

#: src/control-flow-basics/exercise.md
msgid "_ is 1, then the sequence terminates at _n"
msgstr "_ este 1, atunci secvența se termină la _n"

#: src/control-flow-basics/exercise.md
msgid "_."
msgstr "_."

#: src/control-flow-basics/exercise.md
msgid "_ is even, then _n"
msgstr "_ este par, atunci _n"

#: src/control-flow-basics/exercise.md
msgid "i+1"
msgstr "i+1"

#: src/control-flow-basics/exercise.md
msgid " = n"
msgstr " = n"

#: src/control-flow-basics/exercise.md
msgid " / 2_."
msgstr " / 2_."

#: src/control-flow-basics/exercise.md
msgid "_ is odd, then _n"
msgstr "_ este impar, atunci _n"

#: src/control-flow-basics/exercise.md
msgid " = 3 * n"
msgstr " = 3 * n"

#: src/control-flow-basics/exercise.md
msgid " + 1_."
msgstr " + 1_."

#: src/control-flow-basics/exercise.md
msgid "For example, beginning with _n"
msgstr "De exemplu, începând cu _n"

#: src/control-flow-basics/exercise.md
msgid "_ = 3:"
msgstr "_ = 3:"

#: src/control-flow-basics/exercise.md
msgid "3 is odd, so _n"
msgstr "3 este impar, deci _n"

#: src/control-flow-basics/exercise.md
msgid "2"
msgstr "2"

#: src/control-flow-basics/exercise.md
msgid "_ = 3 * 3 + 1 = 10;"
msgstr "_ = 3 * 3 + 1 = 10;"

#: src/control-flow-basics/exercise.md
msgid "10 is even, so _n"
msgstr "10 este par, deci _n"

#: src/control-flow-basics/exercise.md src/bare-metal/aps/better-uart.md
msgid "3"
msgstr "3"

#: src/control-flow-basics/exercise.md
msgid "_ = 10 / 2 = 5;"
msgstr "_ = 10 / 2 = 5;"

#: src/control-flow-basics/exercise.md
msgid "5 is odd, so _n"
msgstr "5 este impar, deci _n"

#: src/control-flow-basics/exercise.md src/bare-metal/aps/better-uart.md
msgid "4"
msgstr "4"

#: src/control-flow-basics/exercise.md
msgid "_ = 3 * 5 + 1 = 16;"
msgstr "_ = 3 * 5 + 1 = 16;"

#: src/control-flow-basics/exercise.md
msgid "16 is even, so _n"
msgstr "16 este par, deci _n"

#: src/control-flow-basics/exercise.md
msgid "5"
msgstr "5"

#: src/control-flow-basics/exercise.md
msgid "_ = 16 / 2 = 8;"
msgstr "_ = 16 / 2 = 8;"

#: src/control-flow-basics/exercise.md
msgid "8 is even, so _n"
msgstr "8 este par, deci _n"

#: src/control-flow-basics/exercise.md src/bare-metal/aps/better-uart.md
msgid "6"
msgstr "6"

#: src/control-flow-basics/exercise.md
msgid "_ = 8 / 2 = 4;"
msgstr "_ = 8 / 2 = 4;"

#: src/control-flow-basics/exercise.md
msgid "4 is even, so _n"
msgstr "4 este par, deci _n"

#: src/control-flow-basics/exercise.md
msgid "7"
msgstr "7"

#: src/control-flow-basics/exercise.md
msgid "_ = 4 / 2 = 2;"
msgstr "_ = 4 / 2 = 2;"

#: src/control-flow-basics/exercise.md
msgid "2 is even, so _n"
msgstr "2 este par, deci _n"

#: src/control-flow-basics/exercise.md src/bare-metal/aps/better-uart.md
msgid "8"
msgstr "8"

#: src/control-flow-basics/exercise.md
msgid "_ = 1; and"
msgstr "_ = 1; and"

#: src/control-flow-basics/exercise.md
msgid "the sequence terminates."
msgstr "secvența se termină."

#: src/control-flow-basics/exercise.md
msgid ""
"Write a function to calculate the length of the collatz sequence for a given "
"initial `n`."
msgstr ""
"Scrieți o funcție care să calculeze lungimea secvenței Collatz pentru un "
"anumit `n` inițial."

#: src/control-flow-basics/exercise.md src/control-flow-basics/solution.md
msgid "/// Determine the length of the collatz sequence beginning at `n`.\n"
msgstr "/// Determinați lungimea secvenței collatz care începe la `n`.\n"

#: src/control-flow-basics/solution.md src/concurrency/threads/scoped.md
msgid "\"Length: {}\""
msgstr "\"Length: {}\""

#: src/welcome-day-1-afternoon.md src/welcome-day-2-afternoon.md
#: src/welcome-day-3-afternoon.md src/welcome-day-4-afternoon.md
msgid "Welcome Back"
msgstr "Bine ați revenit"

#: src/welcome-day-1-afternoon.md
#, fuzzy
msgid "[Tuples and Arrays](./tuples-and-arrays.md) (35 minutes)"
msgstr "[Tupluri și vectori](./tuples-and-arrays.md) (1 oră)"

#: src/welcome-day-1-afternoon.md
#, fuzzy
msgid "[References](./references.md) (55 minutes)"
msgstr "[Referințe](../references.md) (50 minute)"

#: src/welcome-day-1-afternoon.md
msgid "[User-Defined Types](./user-defined-types.md) (50 minutes)"
msgstr "[Tipuri definite de utilizator](../user-defined-types.md) (50 minute)"

#: src/welcome-day-1-afternoon.md
#, fuzzy
msgid ""
"Including 10 minute breaks, this session should take about 2 hours and 35 "
"minutes"
msgstr ""
"Incluzând pauzele de 10 minute, această sesiune ar trebui să dureze "
"aproximativ 2 ore și 55 de minute"

#: src/tuples-and-arrays.md
#, fuzzy
msgid "[Arrays](./tuples-and-arrays/arrays.md) (5 minutes)"
msgstr ""
"[Tupluri și vectori](./tuples-and-arrays/tuples-and-arrays.md)  (10 minute)"

#: src/tuples-and-arrays.md
#, fuzzy
msgid "[Tuples](./tuples-and-arrays/tuples.md) (5 minutes)"
msgstr ""
"[Tupluri și vectori](./tuples-and-arrays/tuples-and-arrays.md)  (10 minute)"

#: src/tuples-and-arrays.md
msgid "[Array Iteration](./tuples-and-arrays/iteration.md) (3 minutes)"
msgstr "[Iterarea pe vectori](./tuples-and-arrays/iteration.md) (3 minute)"

#: src/tuples-and-arrays.md
#, fuzzy
msgid ""
"[Patterns and Destructuring](./tuples-and-arrays/destructuring.md) (5 "
"minutes)"
msgstr "[Destructurare](./tuples-and-arrays/destructuring.md) (5 minute)"

#: src/tuples-and-arrays.md
#, fuzzy
msgid "[Exercise: Nested Arrays](./tuples-and-arrays/exercise.md) (15 minutes)"
msgstr ""
"[Exercițiu: vectori imbricați](./tuples-and-arrays/exercise.mds) (30 minute)"

#: src/tuples-and-arrays.md
#, fuzzy
msgid "This segment should take about 35 minutes"
msgstr "Acest segment ar trebui să dureze aproximativ 55 de minute"

#: src/tuples-and-arrays/arrays.md
msgid ""
"A value of the array type `[T; N]` holds `N` (a compile-time constant) "
"elements of the same type `T`. Note that the length of the array is _part of "
"its type_, which means that `[u8; 3]` and `[u8; 4]` are considered two "
"different types. Slices, which have a size determined at runtime, are "
"covered later."
msgstr ""
"O valoare de tip tablou `[T; N]` conține `N` (o constantă de timp de "
"compilare) elemente de același tip `T`. Rețineți că lungimea tabloului este "
"_parte a tipului său_, ceea ce înseamnă că `[u8; 3]` și `[u8; 4]` sunt "
"considerate două tipuri diferite."

#: src/tuples-and-arrays/arrays.md
msgid ""
"Try accessing an out-of-bounds array element. Array accesses are checked at "
"runtime. Rust can usually optimize these checks away, and they can be "
"avoided using unsafe Rust."
msgstr ""
"Încercați să accesați un element de tablou în afara limitelor. Accesările "
"elementelor din tablou sunt verificate în timpul execuției. De obicei, Rust "
"poate optimiza aceste verificări, iar acestea pot fi evitate folosind unsafe "
"Rust."

#: src/tuples-and-arrays/arrays.md
msgid "We can use literals to assign values to arrays."
msgstr "Putem utiliza literali pentru a atribui valori la matrice."

#: src/tuples-and-arrays/arrays.md
msgid ""
"The `println!` macro asks for the debug implementation with the `?` format "
"parameter: `{}` gives the default output, `{:?}` gives the debug output. "
"Types such as integers and strings implement the default output, but arrays "
"only implement the debug output. This means that we must use debug output "
"here."
msgstr ""
"Macroul `println!` solicită implementarea de depanare cu parametrul de "
"format `?`: `{}` oferă ieșirea implicită, `{:?}` oferă ieșirea de depanare. "
"Tipuri precum întregi și șiruri de caractere implementează ieșirea "
"implicită, dar matricile implementează doar ieșirea de depanare. Aceasta "
"înseamnă că trebuie să folosim aici ieșirea de depanare."

#: src/tuples-and-arrays/arrays.md
msgid ""
"Adding `#`, eg `{a:#?}`, invokes a \"pretty printing\" format, which can be "
"easier to read."
msgstr ""
"Adăugând `#`, de exemplu `{a:#?}`, se invocă un format de tipărire "
"\"frumos\", care poate fi mai ușor de citit."

#: src/tuples-and-arrays/tuples.md
msgid "Like arrays, tuples have a fixed length."
msgstr "Tuplurile au o lungime fixă, întocmai vectorilor."

#: src/tuples-and-arrays/tuples.md
msgid "Tuples group together values of different types into a compound type."
msgstr "Tuplurile grupează valori de tipuri diferite într-un tip compus."

#: src/tuples-and-arrays/tuples.md
msgid ""
"Fields of a tuple can be accessed by the period and the index of the value, "
"e.g. `t.0`, `t.1`."
msgstr ""
"Câmpurile unui tuplu pot fi accesate prin punct și indicele valorii, de "
"exemplu `t.0`, `t.1`."

#: src/tuples-and-arrays/tuples.md
#, fuzzy
msgid ""
"The empty tuple `()` is referred to as the \"unit type\" and signifies "
"absence of a return value, akin to `void` in other languages."
msgstr ""
"Tupla goală `()` este denumită \"tip unitate\" și semnifică absența unei "
"valori de returnare, asemănătoare cu `void` din alte limbaje."

#: src/tuples-and-arrays/iteration.md
msgid "The `for` statement supports iterating over arrays (but not tuples)."
msgstr ""
"Instrucțiunea `for` permite iterația peste tablouri (dar nu și peste "
"tupluri)."

#: src/tuples-and-arrays/iteration.md
msgid ""
"This functionality uses the `IntoIterator` trait, but we haven't covered "
"that yet."
msgstr ""
"Această funcționalitate utilizează trăsătura `IntoIterator`, dar încă nu am "
"abordată-o în cadrul cursului."

#: src/tuples-and-arrays/iteration.md
msgid ""
"The `assert_ne!` macro is new here. There are also `assert_eq!` and `assert!"
"` macros. These are always checked while, debug-only variants like "
"`debug_assert!` compile to nothing in release builds."
msgstr ""
"Macroul `assert_ne!` este nou aici. Există, de asemenea, macrourile "
"`assert_eq!` și `assert!`. Acestea sunt întotdeauna verificate, în timp ce "
"variantele destinate depanării, cum ar fi `debug_assert!`, nu se compilează "
"în versiunile de lansare."

#: src/tuples-and-arrays/destructuring.md
#, fuzzy
msgid ""
"When working with tuples and other structured values it's common to want to "
"extract the inner values into local variables. This can be done manually by "
"directly accessing the inner values:"
msgstr ""
"Atunci când se lucrează cu tupluri și alte valori structurate, este obișnuit "
"să se dorească extragerea valorilor interioare în variabile locale. Acest "
"lucru se poate face manual prin accesarea directă a valorilor interioare:"

#: src/tuples-and-arrays/destructuring.md
#, fuzzy
msgid "\"left: {left}, right: {right}\""
msgstr "\"stânga: {left}, dreapta: {right}\""

#: src/tuples-and-arrays/destructuring.md
#, fuzzy
msgid ""
"However, Rust also supports using pattern matching to destructure a larger "
"value into its constituent parts:"
msgstr ""
"Cu toate acestea, Rust suportă, de asemenea, utilizarea potrivirii de tipare "
"pentru a destructura o valoare mai mare în părțile sale constitutive:"

#: src/tuples-and-arrays/destructuring.md
#, fuzzy
msgid ""
"The patterns used here are \"irrefutable\", meaning that the compiler can "
"statically verify that the value on the right of `=` has the same structure "
"as the pattern."
msgstr ""
"Tiparele utilizate aici sunt \"irefutabile\", ceea ce înseamnă că "
"compilatorul poate verifica static că valoarea din dreapta lui `=` are "
"aceeași structură ca și modelul."

#: src/tuples-and-arrays/destructuring.md
#, fuzzy
msgid ""
"A variable name is an irrefutable pattern that always matches any value, "
"hence why we can also use `let` to declare a single variable."
msgstr ""
"Un nume de variabilă este un model irefutabil care se potrivește întotdeauna "
"cu orice valoare, de aceea putem folosi și `let` pentru a declara o singură "
"variabilă."

#: src/tuples-and-arrays/destructuring.md
#, fuzzy
msgid ""
"Rust also supports using patterns in conditionals, allowing for equality "
"comparison and destructuring to happen at the same time. This form of "
"pattern matching will be discussed in more detail later."
msgstr ""
"Rust acceptă, de asemenea, utilizarea modelelor în condiționale, permițând "
"compararea egalității și destructurarea în același timp. Această formă de "
"potrivire a modelelor va fi discutată mai în detaliu mai târziu."

#: src/tuples-and-arrays/destructuring.md
#, fuzzy
msgid ""
"Edit the examples above to show the compiler error when the pattern doesn't "
"match the value being matched on."
msgstr ""
"Modificați exemplele de mai sus pentru a afișa eroarea compilatorului atunci "
"când modelul nu se potrivește cu valoarea pe care se face potrivirea."

#: src/tuples-and-arrays/exercise.md
msgid "Arrays can contain other arrays:"
msgstr "Vectorii pot conține alți vectori:"

#: src/tuples-and-arrays/exercise.md
msgid "What is the type of this variable?"
msgstr "Care este tipul acestei variabile?"

#: src/tuples-and-arrays/exercise.md
msgid ""
"Use an array such as the above to write a function `transpose` which will "
"transpose a matrix (turn rows into columns):"
msgstr ""
"Folosiți cele de mai sus pentru a scrie o funcție `transpose` care va "
"transpune o matrice (transformă rândurile în coloane):"

#: src/tuples-and-arrays/exercise.md
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and implement the "
"function. This function only operates on 3x3 matrices."
msgstr ""
"Copiați codul de mai jos în <https://play.rust-lang.org/> și implementați "
"funcția."

#: src/tuples-and-arrays/exercise.md src/borrowing/exercise.md
#: src/unsafe-rust/exercise.md
msgid "// TODO: remove this when you're done with your implementation.\n"
msgstr ""
"// TODO: eliminați acest comentariu atunci când ați terminat cu "
"implementarea.\n"

#: src/tuples-and-arrays/exercise.md src/tuples-and-arrays/solution.md
msgid "//\n"
msgstr "//\n"

#: src/tuples-and-arrays/exercise.md src/tuples-and-arrays/solution.md
msgid "// <-- the comment makes rustfmt add a newline\n"
msgstr "// <-- comentariul face ca rustfmt să adauge o linie nouă\n"

#: src/tuples-and-arrays/exercise.md src/tuples-and-arrays/solution.md
msgid "\"matrix: {:#?}\""
msgstr "\"Matricea: {:#?}\""

#: src/tuples-and-arrays/exercise.md src/tuples-and-arrays/solution.md
msgid "\"transposed: {:#?}\""
msgstr "\"transpus: {:#?}\""

#: src/references.md
msgid "[Shared References](./references/shared.md) (10 minutes)"
msgstr "[Referințe partajate](./references/shared.md) (10 minute)"

#: src/references.md
msgid "[Exclusive References](./references/exclusive.md) (10 minutes)"
msgstr "[Referințe exclusive](./references/exclusive.md) (10 minute)"

#: src/references.md
#, fuzzy
msgid "[Slices: &\\[T\\]](./references/slices.md) (10 minutes)"
msgstr "[Slices: &\\[T\\]](./slices-and-lifetimes/slices.md) (10 minute)"

#: src/references.md
#, fuzzy
msgid "[Strings](./references/strings.md) (10 minutes)"
msgstr "[Șiruri](./types-and-values/strings.md) (10 minute)"

#: src/references.md
#, fuzzy
msgid "[Exercise: Geometry](./references/exercise.md) (15 minutes)"
msgstr "[Exercițiu: Geometrie](./references/exercise.md) (30 minute)"

#: src/references.md src/smart-pointers.md src/borrowing.md
#: src/error-handling.md src/concurrency/async-pitfalls.md
#, fuzzy
msgid "This segment should take about 55 minutes"
msgstr "Acest segment ar trebui să dureze aproximativ 55 de minute"

#: src/references/shared.md
#, fuzzy
msgid ""
"A reference provides a way to access another value without taking "
"responsibility for the value, and is also called \"borrowing\". Shared "
"references are read-only, and the referenced data cannot change."
msgstr ""
"O referință oferă o modalitate de a accesa o altă valoare fără a prelua "
"responsabilitatea pentru valoarea respectivă, fiind denumită și "
"\"împrumut\". Referințele partajate sunt numai pentru citire, iar datele la "
"care se face referire nu se pot modifica."

#: src/references/shared.md
#, fuzzy
msgid ""
"A shared reference to a type `T` has type `&T`. A reference value is made "
"with the `&` operator. The `*` operator \"dereferences\" a reference, "
"yielding its value."
msgstr ""
"O referință partajată la un tip `T` are tipul `&T`. O valoare de referință "
"se realizează cu ajutorul operatorului `&`. Operatorul `*` \"de-"
"referențiază\" o referință, obținând valoarea acesteia."

#: src/references/shared.md
msgid "Rust will statically forbid dangling references:"
msgstr "Rust va interzice în mod static referințele invalide:"

#: src/references/shared.md
#, fuzzy
msgid ""
"A reference is said to \"borrow\" the value it refers to, and this is a good "
"model for students not familiar with pointers: code can use the reference to "
"access the value, but is still \"owned\" by the original variable. The "
"course will get into more detail on ownership in day 3."
msgstr ""
"Se spune că o referință \"împrumută\" valoarea la care se referă, iar acesta "
"este un model bun pentru elevii care nu sunt familiarizați cu indicatoarele: "
"codul poate folosi referința pentru a accesa valoarea, dar este în "
"continuare \"deținută\" de variabila originală. Cursul va intra în mai multe "
"detalii despre proprietate în ziua 3."

#: src/references/shared.md
#, fuzzy
msgid ""
"References are implemented as pointers, and a key advantage is that they can "
"be much smaller than the thing they point to. Students familiar with C or C+"
"+ will recognize references as pointers. Later parts of the course will "
"cover how Rust prevents the memory-safety bugs that come from using raw "
"pointers."
msgstr ""
"Referințele sunt implementate sub formă de pointeri, iar un avantaj cheie "
"este că pot fi mult mai mici decât obiectul spre care indică. Studenții "
"familiarizați cu C sau C++ vor recunoaște referințele ca fiind pointeri. "
"Părțile ulterioare ale cursului vor acoperi modul în care Rust previne "
"erorile de siguranță a memoriei care apar în cazul utilizării de pointeri "
"brute."

#: src/references/shared.md
#, fuzzy
msgid ""
"Rust does not automatically create references for you - the `&` is always "
"required."
msgstr ""
"Rust nu creează automat referințe pentru dumneavoastră - `&` este "
"întotdeauna necesar."

#: src/references/shared.md
#, fuzzy
msgid ""
"Rust will auto-dereference in some cases, in particular when invoking "
"methods (try `r.is_ascii()`). There is no need for an `->` operator like in "
"C++."
msgstr ""
"Rust va face auto-dereferențiere în unele cazuri, în special atunci când "
"invocă metode (încercați `ref_x.count_ones()`)."

#: src/references/shared.md
#, fuzzy
msgid ""
"In this example, `r` is mutable so that it can be reassigned (`r = &b`). "
"Note that this re-binds `r`, so that it refers to something else. This is "
"different from C++, where assignment to a reference changes the referenced "
"value."
msgstr ""
"În acest exemplu, `r` este mutabil, astfel încât poate fi realocat (`r = "
"&b`). Rețineți că acest lucru reia `r`, astfel încât acesta se referă la "
"altceva. Acest lucru este diferit de C++, unde atribuirea unei referințe "
"modifică valoarea la care se face referire."

#: src/references/shared.md
#, fuzzy
msgid ""
"A shared reference does not allow modifying the value it refers to, even if "
"that value was mutable. Try `*r = 'X'`."
msgstr ""
"O referință partajată nu permite modificarea valorii la care se referă, "
"chiar dacă valoarea respectivă era mutabilă. Încercați `*r = 'X'`."

#: src/references/shared.md
#, fuzzy
msgid ""
"Rust is tracking the lifetimes of all references to ensure they live long "
"enough. Dangling references cannot occur in safe Rust. `x_axis` would return "
"a reference to `point`, but `point` will be deallocated when the function "
"returns, so this will not compile."
msgstr ""
"Rust urmărește durata de viață a tuturor referințelor pentru a se asigura că "
"acestea trăiesc suficient de mult. În Rust sigur nu pot apărea referințe "
"care să stea în suspensie. `x_axis` ar trebui să returneze o referință la "
"`point`, dar `point` va fi dezalocat atunci când funcția se întoarce, deci "
"nu va fi compilat."

#: src/references/shared.md
msgid "We will talk more about borrowing when we get to ownership."
msgstr ""
"Vom vorbi mai multe despre împrumuturi atunci când vom ajunge la posesie."

#: src/references/exclusive.md
#, fuzzy
msgid ""
"Exclusive references, also known as mutable references, allow changing the "
"value they refer to. They have type `&mut T`."
msgstr ""
"Referințele exclusive, cunoscute și sub denumirea de referințe mutabile, "
"permit modificarea valorii la care se referă. Ele au tipul `&mut T`."

#: src/references/exclusive.md
#, fuzzy
msgid ""
"\"Exclusive\" means that only this reference can be used to access the "
"value. No other references (shared or exclusive) can exist at the same time, "
"and the referenced value cannot be accessed while the exclusive reference "
"exists. Try making an `&point.0` or changing `point.0` while `x_coord` is "
"alive."
msgstr ""
"\"Exclusiv\" înseamnă că numai această referință poate fi utilizată pentru a "
"accesa valoarea. Nici o altă referință (partajată sau exclusivă) nu poate "
"exista în același timp, iar valoarea la care se face referire nu poate fi "
"accesată atât timp cât există o referință exclusivă. Încercați să faceți un "
"`&punct.0` sau să modificați `punct.0` în timp ce `x_coord` este în viață."

#: src/references/exclusive.md
#, fuzzy
msgid ""
"Be sure to note the difference between `let mut x_coord: &i32` and `let "
"x_coord: &mut i32`. The first one represents a shared reference which can be "
"bound to different values, while the second represents an exclusive "
"reference to a mutable value."
msgstr ""
"Nu uitați să observați diferența dintre `let mut ref_x: &i32` și `let ref_x: "
"&mut i32`. Primul reprezintă o referință mutabilă care poate fi legată la "
"diferite valori, în timp ce al doilea reprezintă o referință la o valoare "
"mutabilă."

#: src/references/slices.md
msgid "Slices"
msgstr "Felii"

#: src/references/slices.md
msgid "A slice gives you a view into a larger collection:"
msgstr "O felie (elice) vă oferă o imagine a unei colecții mai mari:"

#: src/references/slices.md
#, fuzzy
msgid "Slices borrow data from the sliced type."
msgstr "Feliile împrumută date din tipul porționat."

#: src/references/slices.md
msgid "Question: What happens if you modify `a[3]` right before printing `s`?"
msgstr ""
"Întrebare: Ce se întâmplă dacă modificați `a[3]` chiar înainte de a afișa "
"`s`?"

#: src/references/slices.md
msgid ""
"We create a slice by borrowing `a` and specifying the starting and ending "
"indexes in brackets."
msgstr ""
"Creăm o felie prin împrumutarea lui `a` și specificarea indicilor de început "
"și de sfârșit între paranteze."

#: src/references/slices.md
msgid ""
"If the slice starts at index 0, Rust's range syntax allows us to drop the "
"starting index, meaning that `&a[0..a.len()]` and `&a[..a.len()]` are "
"identical."
msgstr ""
"Dacă felia începe la indexul 0, sintaxa intervalului din Rust ne permite să "
"renunțăm la indexul de pornire, ceea ce înseamnă că `&a[0..a.len()]` și "
"`&a[..a.len()]` sunt identice."

#: src/references/slices.md
msgid ""
"The same is true for the last index, so `&a[2..a.len()]` and `&a[2..]` are "
"identical."
msgstr ""
"Același lucru este valabil și pentru ultimul indice, astfel încât `&a[2..a."
"len()]` și `&a[2..]` sunt identice."

#: src/references/slices.md
#, fuzzy
msgid ""
"To easily create a slice of the full array, we can therefore use `&a[..]`."
msgstr ""
"Pentru a crea cu ușurință o porțiune din întrega matrice, putem folosi "
"`&a[...]`."

#: src/references/slices.md
#, fuzzy
msgid ""
"`s` is a reference to a slice of `i32`s. Notice that the type of `s` "
"(`&[i32]`) no longer mentions the array length. This allows us to perform "
"computation on slices of different sizes."
msgstr ""
"`s` este o referință la o felie de `i32`s. Observați că tipul lui `s` "
"(`&[i32]`) nu mai menționează dimensiunile matricei. Acest lucru ne permite "
"să efectuăm calcule pe felii de dimensiuni diferite."

#: src/references/slices.md
#, fuzzy
msgid ""
"Slices always borrow from another object. In this example, `a` has to remain "
"'alive' (in scope) for at least as long as our slice."
msgstr ""
"Feliile împrumută întotdeauna de la un alt obiect. În acest exemplu, `a` "
"trebuie să rămână \"în viață\" (în domeniul de aplicare) cel puțin cât felia "
"noastră. "

#: src/references/slices.md
#, fuzzy
msgid ""
"The question about modifying `a[3]` can spark an interesting discussion, but "
"the answer is that for memory safety reasons you cannot do it through `a` at "
"this point in the execution, but you can read the data from both `a` and `s` "
"safely. It works before you created the slice, and again after the "
"`println`, when the slice is no longer used."
msgstr ""
"Întrebarea despre modificarea lui `a[3]` poate stârni o discuție "
"interesantă, dar răspunsul este că, din motive de siguranță a memoriei, nu "
"se poate face acest lucru prin `a` în acest moment al execuției, dar se pot "
"citi datele atât din `a`, cât și din `s` în siguranță. Funcționează înainte "
"de a crea felia și din nou după `println`, când felia nu mai este utilizată. "
"Mai multe detalii vor fi explicate în secțiunea de verificare a "
"împrumuturilor."

#: src/references/strings.md
msgid "We can now understand the two string types in Rust:"
msgstr "Acum putem înțelege cele două tipuri de șiruri de caractere din Rust:"

#: src/references/strings.md
#, fuzzy
msgid "`&str` is a slice of UTF-8 encoded bytes, similar to `&[u8]`."
msgstr "`&str` este o felie de octeți codificați UTF-8, similar cu `&[u8]`."

#: src/references/strings.md
#, fuzzy
msgid ""
"`String` is an owned buffer of UTF-8 encoded bytes, similar to `Vec<T>`."
msgstr "`&str` este o felie de octeți codificați UTF-8, similar cu `&[u8]`."

#: src/references/strings.md src/std-traits/read-and-write.md
#, fuzzy
msgid "\"World\""
msgstr "\"Lumea\""

#: src/references/strings.md
#, fuzzy
msgid "\"s1: {s1}\""
msgstr "\"s1: {s1}\""

#: src/references/strings.md
#, fuzzy
msgid "\"Hello \""
msgstr "\"hello\""

#: src/references/strings.md src/memory-management/move.md
msgid "\"s2: {s2}\""
msgstr "\"s2: {s2}\""

#: src/references/strings.md
#, fuzzy
msgid "\"s3: {s3}\""
msgstr "\"s3: {s3}\""

#: src/references/strings.md
#, fuzzy
msgid ""
"`&str` introduces a string slice, which is an immutable reference to UTF-8 "
"encoded string data stored in a block of memory. String literals "
"(`\"Hello\"`), are stored in the program's binary."
msgstr ""
"`&str` indică o porțiune dintr-un șir de caractere, care este o referință "
"imuabilă la date de șir de caractere codificate UTF-8 stocate într-un bloc "
"de memorie. Șirurile literale (`\"Hello\"`) sunt stocate în binarul "
"programului."

#: src/references/strings.md
#, fuzzy
msgid ""
"Rust's `String` type is a wrapper around a vector of bytes. As with a "
"`Vec<T>`, it is owned."
msgstr ""
"Tipul `String` (șir de caractere) din Rust este un înveliș în jurul unui "
"vector de octeți. La fel ca și în cazul unui `Vec<T>`, acesta este propriu."

#: src/references/strings.md
#, fuzzy
msgid ""
"As with many other types `String::from()` creates a string from a string "
"literal; `String::new()` creates a new empty string, to which string data "
"can be added using the `push()` and `push_str()` methods."
msgstr ""
"Ca și în cazul multor alte tipuri, `String::from()` creează un șir de "
"caractere dintr-un literal de șir; `String::new()` creează un nou șir de "
"caractere gol, la care se pot adăuga date de șiruri de caractere folosind "
"metodele `push()` și `push_str()`."

#: src/references/strings.md
#, fuzzy
msgid ""
"The `format!()` macro is a convenient way to generate an owned string from "
"dynamic values. It accepts the same format specification as `println!()`."
msgstr ""
"Macroul `format!()` este o modalitate convenabilă de a genera un șir de "
"caractere proprii din valori dinamice. Acceptă aceeași specificație de "
"format ca și `println!()`."

#: src/references/strings.md
#, fuzzy
msgid ""
"You can borrow `&str` slices from `String` via `&` and optionally range "
"selection. If you select a byte range that is not aligned to character "
"boundaries, the expression will panic. The `chars` iterator iterates over "
"characters and is preferred over trying to get character boundaries right."
msgstr ""
"Puteți împrumuta felii `&str` de la `String` prin `&` și, opțional, prin "
"selectarea intervalului. Dacă selectați un interval de octeți care nu este "
"aliniat la limitele caracterelor, expresia va intra în panică. Iteratorul "
"`chars` iteră peste caractere și este de preferat în locul încercării de a "
"obține limite de caractere corecte."

#: src/references/strings.md
#, fuzzy
msgid ""
"For C++ programmers: think of `&str` as `std::string_view` from C++, but the "
"one that always points to a valid string in memory. Rust `String` is a rough "
"equivalent of `std::string` from C++ (main difference: it can only contain "
"UTF-8 encoded bytes and will never use a small-string optimization)."
msgstr ""
"Pentru programatorii din C++: gândiți-vă la `&str` ca la `const char*` din C+"
"+, dar cel care indică întotdeauna un șir de caractere valid în memorie. "
"Rust `String` este un echivalent aproximativ al lui `std::string` din C++ "
"(principala diferență: poate conține numai octeți codificați UTF-8 și nu va "
"folosi niciodată o optimizare pentru șiruri mici)."

#: src/references/strings.md
#, fuzzy
msgid "Byte strings literals allow you to create a `&[u8]` value directly:"
msgstr "Șirurile de octeți vă permit să creați direct o valoare `&[u8]`:"

#: src/references/strings.md
msgid ""
"Raw strings allow you to create a `&str` value with escapes disabled: "
"`r\"\\n\" == \"\\\\n\"`. You can embed double-quotes by using an equal "
"amount of `#` on either side of the quotes:"
msgstr ""
"Șirurile brute de caractere vă permit să creați o valoare `&str` având "
"caracterele speciale dezactivate: `r\"\\n\" == \"\\n\"`. Puteți încorpora "
"ghilimele duble folosind o cantitate egală de `#` de o parte și de alta a "
"lor:"

#: src/references/exercise.md
#, fuzzy
msgid ""
"We will create a few utility functions for 3-dimensional geometry, "
"representing a point as `[f64;3]`. It is up to you to determine the function "
"signatures."
msgstr ""
"Vom crea câteva funcții de utilitate pentru geometria tridimensională, "
"reprezentând un punct ca `[f64;3]`. Depinde de dumneavoastră să determinați "
"semnăturile funcțiilor."

#: src/references/exercise.md
#, fuzzy
msgid ""
"// Calculate the magnitude of a vector by summing the squares of its "
"coordinates\n"
"// and taking the square root. Use the `sqrt()` method to calculate the "
"square\n"
"// root, like `v.sqrt()`.\n"
msgstr ""
"// Calculează mărimea unui vector prin însumarea pătratelor coordonatelor "
"sale\n"
"// și luând rădăcina pătrată. Utilizați metoda `sqrt()` pentru a calcula "
"pătratul\n"
"// rădăcina pătrată, cum ar fi `v.sqrt()`.\n"

#: src/references/exercise.md
#, fuzzy
msgid ""
"// Normalize a vector by calculating its magnitude and dividing all of its\n"
"// coordinates by that magnitude.\n"
msgstr ""
"// Normalizați un vector prin calcularea magnitudinii sale și împărțirea "
"tuturor vectorilor săi\n"
"// coordonate la această mărime.\n"

#: src/references/exercise.md
msgid "// Use the following `main` to test your work.\n"
msgstr "// Folosiți următoarea funcție `main` pentru a vă testa munca.\n"

#: src/references/exercise.md src/references/solution.md
msgid "\"Magnitude of a unit vector: {}\""
msgstr "\"Magnitudinea unui vector unitar: {}\""

#: src/references/exercise.md src/references/solution.md
msgid "\"Magnitude of {v:?}: {}\""
msgstr "\"Magnitudine de {v:?}: {}\""

#: src/references/exercise.md src/references/solution.md
msgid "\"Magnitude of {v:?} after normalization: {}\""
msgstr "\"Magnitudinea lui {v:?} după normalizare: {}\""

#: src/references/solution.md
msgid "/// Calculate the magnitude of the given vector.\n"
msgstr "/// Calculează magnitudinea vectorului dat.\n"

#: src/references/solution.md
msgid ""
"/// Change the magnitude of the vector to 1.0 without changing its "
"direction.\n"
msgstr ""
"/// Modificați magnitudinea vectorului la 1.0 fără a-i schimba direcția.\n"

#: src/user-defined-types.md
msgid "[Named Structs](./user-defined-types/named-structs.md) (10 minutes)"
msgstr "[Structuri cu nume](./user-defined-types/named-structs.md) (10 minute)"

#: src/user-defined-types.md
msgid "[Tuple Structs](./user-defined-types/tuple-structs.md) (10 minutes)"
msgstr ""
"[Structuri de tuplu](./user-defined-types/tuple-structs.md) (10 minute)"

#: src/user-defined-types.md
msgid "[Enums](./user-defined-types/enums.md) (5 minutes)"
msgstr "[Enums](./user-defined-types/enums.md) (5 minute)"

#: src/user-defined-types.md
#, fuzzy
msgid "[Static](./user-defined-types/static.md) (5 minutes)"
msgstr "[Static și Const](./user-defined-types/static-and-const.md) (5 minute)"

#: src/user-defined-types.md
msgid "[Type Aliases](./user-defined-types/aliases.md) (2 minutes)"
msgstr "[Aliasuri de tip](./user-defined-types/aliases.md) (2 minute)"

#: src/user-defined-types.md
#, fuzzy
msgid ""
"[Exercise: Elevator Events](./user-defined-types/exercise.md) (15 minutes)"
msgstr ""
"[Exercițiu: Evenimente de lift](./user-defined-types/exercise.md) (15 minute)"

#: src/user-defined-types.md src/methods-and-traits.md src/lifetimes.md
msgid "This segment should take about 50 minutes"
msgstr "Acest segment ar trebui să dureze aproximativ 50 de minute"

#: src/user-defined-types/named-structs.md
msgid "Like C and C++, Rust has support for custom structs:"
msgstr "La fel ca în C și C++, Rust are suport pentru structuri personalizate:"

#: src/user-defined-types/named-structs.md
msgid "\"{} is {} years old\""
msgstr "\"{} are {} ani\""

#: src/user-defined-types/named-structs.md
#: src/android/interoperability/with-c/bindgen.md
msgid "\"Peter\""
msgstr "\"Peter\""

#: src/user-defined-types/named-structs.md
msgid "\"Avery\""
msgstr "\"Avery\""

#: src/user-defined-types/named-structs.md
msgid "\"Jackie\""
msgstr "\"Jackie\""

#: src/user-defined-types/named-structs.md src/user-defined-types/enums.md
#: src/pattern-matching/match.md src/methods-and-traits/methods.md
msgid "Key Points:"
msgstr "Puncte-cheie:"

#: src/user-defined-types/named-structs.md
msgid "Structs work like in C or C++."
msgstr "Structurile funcționează ca în C sau C++."

#: src/user-defined-types/named-structs.md
msgid "Like in C++, and unlike in C, no typedef is needed to define a type."
msgstr ""
"La fel ca în C++ și spre deosebire de C, nu este nevoie de un typedef pentru "
"a defini un tip."

#: src/user-defined-types/named-structs.md
msgid "Unlike in C++, there is no inheritance between structs."
msgstr "Spre deosebire de C++, nu există moștenire între structuri."

#: src/user-defined-types/named-structs.md
#, fuzzy
msgid ""
"This may be a good time to let people know there are different types of "
"structs."
msgstr ""
"Acesta ar putea fi un moment bun pentru a informa oamenii că există diferite "
"tipuri de structuri."

#: src/user-defined-types/named-structs.md
#, fuzzy
msgid ""
"Zero-sized structs (e.g. `struct Foo;`) might be used when implementing a "
"trait on some type but don't have any data that you want to store in the "
"value itself."
msgstr ""
"Structurile de dimensiune zero (de exemplu, `struct Foo;`) pot fi utilizate "
"atunci când se implementează o trăsătură pe un anumit tip, dar nu aveți date "
"pe care doriți să le stocați în valoarea în sine."

#: src/user-defined-types/named-structs.md
#, fuzzy
msgid ""
"The next slide will introduce Tuple structs, used when the field names are "
"not important."
msgstr ""
"Următorul diapozitiv va prezenta structurile Tuple, utilizate atunci când "
"numele câmpurilor nu sunt importante."

#: src/user-defined-types/named-structs.md
#, fuzzy
msgid ""
"If you already have variables with the right names, then you can create the "
"struct using a shorthand."
msgstr ""
"Dacă aveți deja variabile cu numele corecte, puteți crea structura folosind "
"o prescurtare:"

#: src/user-defined-types/named-structs.md
#, fuzzy
msgid ""
"The syntax `..avery` allows us to copy the majority of the fields from the "
"old struct without having to explicitly type it all out. It must always be "
"the last element."
msgstr ""
"Sintaxa `..peter` ne permite să copiem majoritatea câmpurilor din vechea "
"structură fără a fi nevoie să le scriem în mod explicit pe toate. Acesta "
"trebuie să fie întotdeauna ultimul element."

#: src/user-defined-types/tuple-structs.md
#, fuzzy
msgid "If the field names are unimportant, you can use a tuple struct:"
msgstr ""
"În cazul în care numele câmpurilor nu sunt importante, puteți utiliza o "
"structură de tip tuple:"

#: src/user-defined-types/tuple-structs.md
msgid "\"({}, {})\""
msgstr "\"({}, {})\""

#: src/user-defined-types/tuple-structs.md
#, fuzzy
msgid "This is often used for single-field wrappers (called newtypes):"
msgstr ""
"Acest lucru este adesea utilizat pentru învelișurile cu un singur câmp "
"(denumite newtypes):"

#: src/user-defined-types/tuple-structs.md
msgid "\"Ask a rocket scientist at NASA\""
msgstr "\"Întrebați un specialist în rachete de la NASA\""

#: src/user-defined-types/tuple-structs.md
#: src/android/interoperability/cpp/cpp-bridge.md
#: src/bare-metal/microcontrollers/type-state.md
#: src/concurrency/async-pitfalls/cancellation.md
msgid "// ...\n"
msgstr "// ...\n"

#: src/user-defined-types/tuple-structs.md
#, fuzzy
msgid ""
"Newtypes are a great way to encode additional information about the value in "
"a primitive type, for example:"
msgstr ""
"Newtypes reprezintă o modalitate excelentă de a codifica informații "
"suplimentare despre valoarea unui tip primitiv, de exemplu:"

#: src/user-defined-types/tuple-structs.md
#, fuzzy
msgid "The number is measured in some units: `Newtons` in the example above."
msgstr ""
"Numărul este măsurat în anumite unități: `Newtons` în exemplul de mai sus."

#: src/user-defined-types/tuple-structs.md
#, fuzzy
msgid ""
"The value passed some validation when it was created, so you no longer have "
"to validate it again at every use: `PhoneNumber(String)` or `OddNumber(u32)`."
msgstr ""
"Valoarea a trecut printr-o validare atunci când a fost creată, astfel încât "
"nu mai trebuie să o validați din nou la fiecare utilizare: "
"`PhoneNumber(String)` sau `OddNumber(u32)`."

#: src/user-defined-types/tuple-structs.md
#, fuzzy
msgid ""
"Demonstrate how to add a `f64` value to a `Newtons` type by accessing the "
"single field in the newtype."
msgstr ""
"Demonstrați cum să adăugați o valoare `f64` la un tip `Newtons` prin "
"accesarea unui singur câmp din noul tip."

#: src/user-defined-types/tuple-structs.md
#, fuzzy
msgid ""
"Rust generally doesn't like inexplicit things, like automatic unwrapping or "
"for instance using booleans as integers."
msgstr ""
"În general, Rust nu agreează lucrurile inexplicabile, cum ar fi desfacerea "
"automată sau, de exemplu, utilizarea booleenilor ca numere întregi."

#: src/user-defined-types/tuple-structs.md
msgid "Operator overloading is discussed on Day 3 (generics)."
msgstr "Supraîncărcarea operatorilor este discutată în ziua 3 (generice)."

#: src/user-defined-types/tuple-structs.md
#, fuzzy
msgid ""
"The example is a subtle reference to the [Mars Climate Orbiter](https://en."
"wikipedia.org/wiki/Mars_Climate_Orbiter) failure."
msgstr ""
"Exemplul este o referire subtilă la eșecul [Mars Climate Orbiter] (https://"
"en.wikipedia.org/wiki/Mars_Climate_Orbiter)."

#: src/user-defined-types/enums.md
msgid ""
"The `enum` keyword allows the creation of a type which has a few different "
"variants:"
msgstr ""
"Cuvântul cheie `enum` permite crearea unui tip care are câteva variante "
"diferite:"

#: src/user-defined-types/enums.md
msgid "// Simple variant\n"
msgstr "// Variantă simplă\n"

#: src/user-defined-types/enums.md
msgid "// Tuple variant\n"
msgstr "// Varianta cu tupluri\n"

#: src/user-defined-types/enums.md
#, fuzzy
msgid "// Struct variant\n"
msgstr "// Variantă de structură\n"

#: src/user-defined-types/enums.md
msgid "\"On this turn: {:?}\""
msgstr "\"În acest tur: {:?}\""

#: src/user-defined-types/enums.md
#, fuzzy
msgid "Enumerations allow you to collect a set of values under one type."
msgstr "Enumerările vă permit să colectați un set de valori sub un singur tip"

#: src/user-defined-types/enums.md
#, fuzzy
msgid ""
"`Direction` is a type with variants. There are two values of `Direction`: "
"`Direction::Left` and `Direction::Right`."
msgstr ""
"`Direction` este un tip cu variante. Există două valori pentru `Direction`: "
"`Direction::Left` și `Direction::Right`."

#: src/user-defined-types/enums.md
#, fuzzy
msgid ""
"`PlayerMove` is a type with three variants. In addition to the payloads, "
"Rust will store a discriminant so that it knows at runtime which variant is "
"in a `PlayerMove` value."
msgstr ""
"`PlayerMove` este un tip cu trei variante. În plus față de sarcinile utile, "
"Rust va stoca un discriminant, astfel încât să știe la momentul execuției ce "
"variantă se află într-o valoare `PlayerMove`."

#: src/user-defined-types/enums.md
#, fuzzy
msgid "This might be a good time to compare structs and enums:"
msgstr ""
"Acesta ar putea fi un moment bun pentru a compara structurile și "
"enumerațiile:"

#: src/user-defined-types/enums.md
#, fuzzy
msgid ""
"In both, you can have a simple version without fields (unit struct) or one "
"with different types of fields (variant payloads)."
msgstr ""
"În ambele, puteți avea o versiune simplă fără câmpuri (unit struct) sau una "
"cu diferite tipuri de câmpuri (varianta payloads). "

#: src/user-defined-types/enums.md
#, fuzzy
msgid ""
"You could even implement the different variants of an enum with separate "
"structs but then they wouldn't be the same type as they would if they were "
"all defined in an enum."
msgstr ""
"Ați putea chiar să implementați diferitele variante ale unui enum cu "
"structuri separate, dar atunci acestea nu ar fi de același tip ca în cazul "
"în care ar fi definite toate într-un enum."

#: src/user-defined-types/enums.md
#, fuzzy
msgid "Rust uses minimal space to store the discriminant."
msgstr "Rust utilizează un spațiu minim pentru a stoca discriminantul."

#: src/user-defined-types/enums.md
#, fuzzy
msgid "If necessary, it stores an integer of the smallest required size"
msgstr ""
"Dacă este necesar, se stochează un număr întreg de cea mai mică dimensiune "
"necesară"

#: src/user-defined-types/enums.md
#, fuzzy
msgid ""
"If the allowed variant values do not cover all bit patterns, it will use "
"invalid bit patterns to encode the discriminant (the \"niche "
"optimization\"). For example, `Option<&u8>` stores either a pointer to an "
"integer or `NULL` for the `None` variant."
msgstr ""
"În cazul în care valorile variantelor permise nu acoperă toate modelele de "
"biți, se vor utiliza modele de biți nevalabile pentru a codifica "
"discriminantul (\"optimizarea nișei\"). De exemplu, `Option<&u8>` stochează "
"fie un pointer la un întreg, fie `NULL` pentru varianta `None`."

#: src/user-defined-types/enums.md
msgid ""
"You can control the discriminant if needed (e.g., for compatibility with C):"
msgstr ""
"Puteți controla discriminantul dacă este necesar (de exemplu, pentru "
"compatibilitate cu C):"

#: src/user-defined-types/enums.md
msgid ""
"Without `repr`, the discriminant type takes 2 bytes, because 10001 fits 2 "
"bytes."
msgstr ""
"Fără `repr`, tipul de discriminant are nevoie de 2 octeți, deoarece 10001 se "
"reprezintă cu 2 octeți."

#: src/user-defined-types/enums.md src/user-defined-types/static.md
#: src/memory-management/review.md src/memory-management/move.md
#: src/smart-pointers/box.md src/borrowing/shared.md
msgid "More to Explore"
msgstr "Mai multe de explorat"

#: src/user-defined-types/enums.md
msgid ""
"Rust has several optimizations it can employ to make enums take up less "
"space."
msgstr ""
"Rust are mai multe optimizări pe care le poate folosi pentru ca enumerațiile "
"să ocupe mai puțin spațiu."

#: src/user-defined-types/enums.md
msgid ""
"Null pointer optimization: For [some types](https://doc.rust-lang.org/std/"
"option/#representation), Rust guarantees that `size_of::<T>()` equals "
"`size_of::<Option<T>>()`."
msgstr ""
"Optimizarea pointerilor nuli: Pentru [unele tipuri](https://doc.rust-lang."
"org/std/option/#representation) Rust garantează că `size_of::<T>()` este "
"egal cu `size_of::&lt;Opțiune<T>&gt;()`."

#: src/user-defined-types/enums.md
msgid ""
"Example code if you want to show how the bitwise representation _may_ look "
"like in practice. It's important to note that the compiler provides no "
"guarantees regarding this representation, therefore this is totally unsafe."
msgstr ""
"Exemplu de cod pentru a putea arăta în practică reprezentarea pe biți. "
"Compilatorul nu oferă nicio garanție în ceea ce privește această "
"reprezentare, prin urmare este total nesigură."

#: src/user-defined-types/static.md
msgid "`static`"
msgstr "'Static'"

#: src/user-defined-types/static.md
msgid ""
"Static variables will live during the whole execution of the program, and "
"therefore will not move:"
msgstr ""
"Variabilele statice vor fi valabile pe toată durata execuției programului "
"și, prin urmare, nu se vor muta:"

#: src/user-defined-types/static.md
msgid "\"Welcome to RustOS 3.14\""
msgstr "\"RustOS 3.14 vă salută\""

#: src/user-defined-types/static.md
msgid "\"{BANNER}\""
msgstr "\"{BANNER}\""

#: src/user-defined-types/static.md
#, fuzzy
msgid ""
"As noted in the [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-"
"vs-static.html), these are not inlined upon use and have an actual "
"associated memory location. This is useful for unsafe and embedded code, and "
"the variable lives through the entirety of the program execution. When a "
"globally-scoped value does not have a reason to need object identity, "
"`const` is generally preferred."
msgstr ""
"După cum se menționează în [Rust RFC Book](https://rust-lang.github.io/"
"rfcs/0246-const-vs-static.html), acestea nu sunt incluse în cod la utilizare "
"și au o locație de memorie reală asociată. Acest lucru este util pentru "
"codul nesigur și care ruleaza  direct pe device (embedded) , iar variabila "
"există pe toată durata execuției programului. Atunci când o valoare cu "
"acoperire globală nu are nevoie de identitatea obiectului, `const` este în "
"general preferat."

#: src/user-defined-types/static.md
#, fuzzy
msgid "`static` is similar to mutable global variables in C++."
msgstr ""
"`static`, pe de altă parte, este mult mai asemănătoar cu o variabilă globală "
"`const` sau mutabilă în C++."

#: src/user-defined-types/static.md
msgid ""
"`static` provides object identity: an address in memory and state as "
"required by types with interior mutability such as `Mutex<T>`."
msgstr ""
"`static` asigură identitatea obiectului: o adresă în memorie și starea "
"necesară pentru tipurile cu mutabilitate interioară, cum ar fi `Mutex<T>`."

#: src/user-defined-types/static.md
#, fuzzy
msgid ""
"Because `static` variables are accessible from any thread, they must be "
"`Sync`. Interior mutability is possible through a [`Mutex`](https://doc.rust-"
"lang.org/std/sync/struct.Mutex.html), atomic or similar."
msgstr ""
"Deoarece variabilele `statice` sunt accesibile din orice fir de execuție, "
"ele trebuie să fie `Sync`. Mutabilitatea interioară este posibilă prin "
"intermediul unui [`Mutex`](https://doc.rust-lang.org/std/sync/struct.Mutex."
"html), atomic sau similar. De asemenea, este posibil să aveți variabile "
"statice mutabile, dar acestea necesită sincronizare manuală, astfel încât "
"orice acces la ele necesită cod `unsafe`. Ne vom uita la [mutable statics]"
"(../unsafe/mutable-static-variables.md) în capitolul despre Unsafe Rust."

#: src/user-defined-types/static.md
#, fuzzy
msgid "Thread-local data can be created with the macro `std::thread_local`."
msgstr ""
"Datele `thread_local` pot fi create cu ajutorul macroului `std::"
"thread_local`."

#: src/user-defined-types/const.md
msgid "`const`"
msgstr "`const`"

#: src/user-defined-types/const.md
#, fuzzy
msgid ""
"Constants are evaluated at compile time and their values are inlined "
"wherever they are used:"
msgstr ""
"Variabilele constante sunt evaluate la compilare, iar valorile lor sunt "
"înlocuite în cod ori de câte ori sunt utilizate:"

#: src/user-defined-types/const.md
msgid ""
"According to the [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-"
"vs-static.html) these are inlined upon use."
msgstr ""
"În conformitate cu [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-"
"const-vs-static.html), acestea sunt înlocuite în cod la utilizare."

#: src/user-defined-types/const.md
msgid ""
"Only functions marked `const` can be called at compile time to generate "
"`const` values. `const` functions can however be called at runtime."
msgstr ""
"Numai funcțiile marcate `const` pot fi apelate la compilare pentru a genera "
"valori `const`. Funcțiile `const` totuși pot fi apelate în timpul execuției."

#: src/user-defined-types/const.md
#, fuzzy
msgid "Mention that `const` behaves semantically similar to C++'s `constexpr`"
msgstr ""
"Menționați faptul că în Rust `const` are un comportament semantic similar cu "
"`constexpr` din C++."

#: src/user-defined-types/const.md
msgid ""
"It isn't super common that one would need a runtime evaluated constant, but "
"it is helpful and safer than using a static."
msgstr ""
"Nu este foarte des întâlnit cazul în care cineva ar avea nevoie de o "
"constantă evaluată în timp de execuție, dar este utilă și mai sigură decât "
"utilizarea unei constante statice."

#: src/user-defined-types/aliases.md
#, fuzzy
msgid ""
"A type alias creates a name for another type. The two types can be used "
"interchangeably."
msgstr ""
"Un alias de tip creează un nume pentru un alt tip. Cele două tipuri pot fi "
"utilizate în mod interschimbabil."

#: src/user-defined-types/aliases.md
#, fuzzy
msgid "// Aliases are more useful with long, complex types:\n"
msgstr "// Aliasurile sunt mai utile în cazul tipurilor lungi și complexe:\n"

#: src/user-defined-types/aliases.md
#, fuzzy
msgid "C programmers will recognize this as similar to a `typedef`."
msgstr ""
"Programatorii C vor recunoaște acest lucru ca fiind similar cu un `typedef`."

#: src/user-defined-types/exercise.md
#, fuzzy
msgid ""
"We will create a data structure to represent an event in an elevator control "
"system. It is up to you to define the types and functions to construct "
"various events. Use `#[derive(Debug)]` to allow the types to be formatted "
"with `{:?}`."
msgstr ""
"Vom crea o structură de date pentru a reprezenta un eveniment într-un sistem "
"de control al ascensorului. Depinde de dumneavoastră să definiți tipurile și "
"funcțiile pentru a construi diverse evenimente. Utilizați `#[derive(Debug)]` "
"pentru a permite formatarea tipurilor cu `{:?}`."

#: src/user-defined-types/exercise.md
#, fuzzy
msgid ""
"This exercise only requires creating and populating data structures so that "
"`main` runs without errors. The next part of the course will cover getting "
"data out of these structures."
msgstr ""
"Acest exercițiu necesită doar crearea și popularea structurilor de date "
"astfel încât `main` să ruleze fără erori. Următoarea parte a cursului se va "
"ocupa de extragerea datelor din aceste structuri."

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid ""
"/// An event in the elevator system that the controller must react to.\n"
msgstr ""
"/// Un eveniment din sistemul de ascensoare la care trebuie să reacționeze "
"controlerul.\n"

#: src/user-defined-types/exercise.md
#, fuzzy
msgid "// TODO: add required variants\n"
msgstr "// TODO: adăugați variantele necesare\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "/// A direction of travel.\n"
msgstr "/// O direcție de deplasare.\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "/// The car has arrived on the given floor.\n"
msgstr "/// Mașina a ajuns la etajul dat.\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "/// The car doors have opened.\n"
msgstr "/// Portierele mașinii s-au deschis.\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "/// The car doors have closed.\n"
msgstr "/// Ușile mașinii s-au închis.\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid ""
"/// A directional button was pressed in an elevator lobby on the given "
"floor.\n"
msgstr ""
"/// Un buton direcțional a fost apăsat în holul liftului de la etajul dat.\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "/// A floor button was pressed in the elevator car.\n"
msgstr "/// Un buton de podea a fost apăsat în cabina liftului.\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "\"A ground floor passenger has pressed the up button: {:?}\""
msgstr "\"Un pasager de la parter a apăsat butonul de urcare: {:?}\""

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "\"The car has arrived on the ground floor: {:?}\""
msgstr "\"Mașina a ajuns la parter: {:?}\""

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "\"The car door opened: {:?}\""
msgstr "\"S-a deschis portiera mașinii: {:?}\""

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "\"A passenger has pressed the 3rd floor button: {:?}\""
msgstr "\"Un pasager a apăsat butonul de la etajul 3: {:?}\""

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "\"The car door closed: {:?}\""
msgstr "\"Ușa mașinii s-a închis: {:?}\""

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "\"The car has arrived on the 3rd floor: {:?}\""
msgstr "\"Mașina a ajuns la etajul 3: {:?}\""

#: src/user-defined-types/solution.md
#, fuzzy
msgid "/// A button was pressed.\n"
msgstr "/// A fost apăsat un buton.\n"

#: src/user-defined-types/solution.md
#, fuzzy
msgid "/// The car has arrived at the given floor.\n"
msgstr "/// Mașina a ajuns la etajul dat.\n"

#: src/user-defined-types/solution.md
#, fuzzy
msgid "/// The car's doors have opened.\n"
msgstr "/// Portierele mașinii s-au deschis.\n"

#: src/user-defined-types/solution.md
#, fuzzy
msgid "/// The car's doors have closed.\n"
msgstr "/// Portierele mașinii s-au închis.\n"

#: src/user-defined-types/solution.md
#, fuzzy
msgid "/// A floor is represented as an integer.\n"
msgstr "/// Un etaj este reprezentat ca un număr întreg.\n"

#: src/user-defined-types/solution.md
#, fuzzy
msgid "/// A user-accessible button.\n"
msgstr "/// Un buton accesibil utilizatorului.\n"

#: src/user-defined-types/solution.md
#, fuzzy
msgid "/// A button in the elevator lobby on the given floor.\n"
msgstr "/// Un buton în holul liftului de la etajul dat.\n"

#: src/user-defined-types/solution.md
#, fuzzy
msgid "/// A floor button within the car.\n"
msgstr "/// Un buton de podea în interiorul mașinii.\n"

#: src/welcome-day-2.md
msgid "Welcome to Day 2"
msgstr "Bine ați venit în ziua a doua"

#: src/welcome-day-2.md
#, fuzzy
msgid ""
"Now that we have seen a fair amount of Rust, today will focus on Rust's type "
"system:"
msgstr ""
"Acum, că am văzut o cantitate destul de mare de rugină, vom continua cu:"

#: src/welcome-day-2.md
#, fuzzy
msgid "Pattern matching: extracting data from structures."
msgstr ""
"Găsirea de tipare: destructurarea enumerațiilor, structurilor și a "
"tablourilor."

#: src/welcome-day-2.md
#, fuzzy
msgid "Methods: associating functions with types."
msgstr "Metode: asocierea funcțiilor cu tipurile."

#: src/welcome-day-2.md
#, fuzzy
msgid "Traits: behaviors shared by multiple types."
msgstr "Trăsături: comportamente împărtășite de mai multe tipuri."

#: src/welcome-day-2.md
#, fuzzy
msgid "Generics: parameterizing types on other types."
msgstr "Generice: parametrizarea tipurilor pe alte tipuri."

#: src/welcome-day-2.md
#, fuzzy
msgid ""
"Standard library types and traits: a tour of Rust's rich standard library."
msgstr ""
"Tipuri și trăsături ale bibliotecii standard: un tur al bogatei biblioteci "
"standard Rust."

#: src/welcome-day-2.md
#, fuzzy
msgid "[Welcome](./welcome-day-2.md) (3 minutes)"
msgstr "[Introducere](../welcome-day-2.md) (3 minute)"

#: src/welcome-day-2.md
#, fuzzy
msgid "[Pattern Matching](./pattern-matching.md) (1 hour)"
msgstr "[Potrivirea șabloanelor](../pattern-matching.md) (50 minute)"

#: src/welcome-day-2.md
#, fuzzy
msgid "[Methods and Traits](./methods-and-traits.md) (50 minutes)"
msgstr "[Metode și trăsături](./methods-and-traits.md) (55 minute)"

#: src/welcome-day-2.md src/welcome-day-4-afternoon.md
#, fuzzy
msgid ""
"Including 10 minute breaks, this session should take about 2 hours and 10 "
"minutes"
msgstr ""
"Incluzând pauzele de 10 minute, această sesiune ar trebui să dureze "
"aproximativ 2 ore și 15 minute"

#: src/pattern-matching.md
#, fuzzy
msgid "[Matching Values](./pattern-matching/match.md) (10 minutes)"
msgstr "[Potrivirea șabloanelor](../pattern-matching.md) (50 minute)"

#: src/pattern-matching.md
#, fuzzy
msgid ""
"[Destructuring Structs](./pattern-matching/destructuring-structs.md) (4 "
"minutes)"
msgstr "[Destructurare](./pattern-matching/destructuring.md) (10 minute)"

#: src/pattern-matching.md
#, fuzzy
msgid ""
"[Destructuring Enums](./pattern-matching/destructuring-enums.md) (4 minutes)"
msgstr "[Destructurare](./pattern-matching/destructuring.md) (10 minute)"

#: src/pattern-matching.md
#, fuzzy
msgid "[Let Control Flow](./pattern-matching/let-control-flow.md) (10 minutes)"
msgstr ""
"[Lasă controlul să curgă](./pattern-matching/let-control-flow.md) (10 minute)"

#: src/pattern-matching.md
#, fuzzy
msgid ""
"[Exercise: Expression Evaluation](./pattern-matching/exercise.md) (30 "
"minutes)"
msgstr ""
"[Exercițiu: Evaluarea expresiilor](./pattern-matching/exercise.md) (30 "
"minute)"

#: src/pattern-matching.md src/memory-management.md
msgid "This segment should take about 1 hour"
msgstr "Acest segment ar trebui să dureze aproximativ 1 oră"

#: src/pattern-matching/match.md
msgid ""
"The `match` keyword lets you match a value against one or more _patterns_. "
"The comparisons are done from top to bottom and the first match wins."
msgstr ""
"Cuvântul cheie `match` vă permite să comparați o valoare cu unul sau mai "
"multe _șabloane_. Comparațiile se fac de sus în jos, iar prima potrivire "
"câștigă."

#: src/pattern-matching/match.md
msgid "The patterns can be simple values, similarly to `switch` in C and C++:"
msgstr "Modelele pot fi valori simple, la fel ca `switch` în C și C++:"

#: src/pattern-matching/match.md
msgid "'x'"
msgstr "'x'"

#: src/pattern-matching/match.md
msgid "'q'"
msgstr "'q'"

#: src/pattern-matching/match.md
#, fuzzy
msgid "\"Quitting\""
msgstr "\"Renunțarea\""

#: src/pattern-matching/match.md src/generics/exercise.md
#: src/generics/solution.md src/std-traits/solution.md
#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "'a'"
msgstr "'a'"

#: src/pattern-matching/match.md
msgid "'s'"
msgstr "'s'"

#: src/pattern-matching/match.md
msgid "'w'"
msgstr "'w'"

#: src/pattern-matching/match.md
msgid "'d'"
msgstr "'d'"

#: src/pattern-matching/match.md
msgid "\"Moving around\""
msgstr "\"Permutarea\""

#: src/pattern-matching/match.md src/error-handling/exercise.md
#: src/error-handling/solution.md
msgid "'0'"
msgstr "'0'"

#: src/pattern-matching/match.md src/error-handling/exercise.md
#: src/error-handling/solution.md
msgid "'9'"
msgstr "'9'"

#: src/pattern-matching/match.md
msgid "\"Number input\""
msgstr "\"Introducere număr\""

#: src/pattern-matching/match.md
msgid "\"Lowercase: {key}\""
msgstr "\"Litera mică: {key}\""

#: src/pattern-matching/match.md
msgid "\"Something else\""
msgstr "\"Altceva\""

#: src/pattern-matching/match.md
#, fuzzy
msgid ""
"The `_` pattern is a wildcard pattern which matches any value. The "
"expressions _must_ be exhaustive, meaning that it covers every possibility, "
"so `_` is often used as the final catch-all case."
msgstr ""
"Șablonul `_` este un model jocker care se potrivește cu orice valoare. "
"Expresiile _trebuie_ să fie irefutabile, ceea ce înseamnă că acoperă orice "
"posibilitate, astfel încât `_` este adesea utilizat ca ultim caz universal."

#: src/pattern-matching/match.md
msgid ""
"Match can be used as an expression. Just like `if`, each match arm must have "
"the same type. The type is the last expression of the block, if any. In the "
"example above, the type is `()`."
msgstr ""
"Potrivirea se poate folosi ca o expresie. Similar cu 'if', cele două părți "
"ale expresiei trebuie să aibă același tip. Dacă există, ultima expresie din "
"bloc dă tipul. În exemplul anterior, tipul este '()'."

#: src/pattern-matching/match.md
#, fuzzy
msgid ""
"A variable in the pattern (`key` in this example) will create a binding that "
"can be used within the match arm."
msgstr ""
"O variabilă din model (`key` în acest exemplu) va crea o legătură care poate "
"fi utilizată în cadrul brațului de potrivire."

#: src/pattern-matching/match.md
#, fuzzy
msgid "A match guard causes the arm to match only if the condition is true."
msgstr ""
"O protecție de potrivire face ca brațul să se potrivească numai dacă "
"condiția este adevărată."

#: src/pattern-matching/match.md
#, fuzzy
msgid ""
"You might point out how some specific characters are being used when in a "
"pattern"
msgstr ""
"Ați putea indica modul în care sunt folosite anumite caractere specifice "
"atunci când se află într-un șablon"

#: src/pattern-matching/match.md
msgid "`|` as an `or`"
msgstr "`|` ca un `or` (sau)"

#: src/pattern-matching/match.md
msgid "`..` can expand as much as it needs to be"
msgstr "`...` se poate extinde atât cât este nevoie"

#: src/pattern-matching/match.md
msgid "`1..=5` represents an inclusive range"
msgstr "`1..=5` reprezintă un interval inclusiv"

#: src/pattern-matching/match.md
msgid "`_` is a wild card"
msgstr "`_` este un 'joker'"

#: src/pattern-matching/match.md
msgid ""
"Match guards as a separate syntax feature are important and necessary when "
"we wish to concisely express more complex ideas than patterns alone would "
"allow."
msgstr ""
"Gărzile de potrivire, ca o caracteristică sintactică separată, sunt "
"importante și necesare atunci când dorim să exprimăm în mod concis idei mai "
"complexe decât ne-ar permite doar șabloanele."

#: src/pattern-matching/match.md
msgid ""
"They are not the same as separate `if` expression inside of the match arm. "
"An `if` expression inside of the branch block (after `=>`) happens after the "
"match arm is selected. Failing the `if` condition inside of that block won't "
"result in other arms of the original `match` expression being considered."
msgstr ""
"Acestea sunt diferite de expresia `if` din interiorul ramurii de potrivire. "
"O expresie `if` în interiorul blocului de ramificare (după `=>`) apare după "
"ce este selectată ramura de potrivire. În cazul în care nu se îndeplinește "
"condiția `if` din interiorul blocului respectiv, nu vor fi luate în "
"considerare alte ramuri ale expresiei `match` originale."

#: src/pattern-matching/match.md
msgid ""
"The condition defined in the guard applies to every expression in a pattern "
"with an `|`."
msgstr ""
"Condiția definită în gardă se aplică fiecărei expresii dintr-un model cu `|`."

#: src/pattern-matching/destructuring-structs.md
msgid "Structs"
msgstr "Structuri"

#: src/pattern-matching/destructuring-structs.md
#, fuzzy
msgid "Like tuples, Struct can also be destructured by matching:"
msgstr ""
"Ca și tuplurile, structurile și enumerațiile pot fi, de asemenea, "
"destructurate prin potrivire:"

#: src/pattern-matching/destructuring-structs.md
#, fuzzy
msgid "\"x.0 = 1, b = {b}, y = {y}\""
msgstr "\"x.0 = 1, b = {b}, y = {y}\""

#: src/pattern-matching/destructuring-structs.md
#, fuzzy
msgid "\"y = 2, x = {i:?}\""
msgstr "\"y = 2, x = {i:?}\""

#: src/pattern-matching/destructuring-structs.md
#, fuzzy
msgid "\"y = {y}, other fields were ignored\""
msgstr "\"y = {y}, celelalte câmpuri au fost ignorate\""

#: src/pattern-matching/destructuring-structs.md
msgid "Change the literal values in `foo` to match with the other patterns."
msgstr ""
"Modificați valorile literale din `foo` pentru a se potrivi cu celelalte "
"modele."

#: src/pattern-matching/destructuring-structs.md
msgid "Add a new field to `Foo` and make changes to the pattern as needed."
msgstr ""
"Adăugați un nou câmp la `Foo` și modificați șablonul după cum este necesar."

#: src/pattern-matching/destructuring-structs.md
msgid ""
"The distinction between a capture and a constant expression can be hard to "
"spot. Try changing the `2` in the second arm to a variable, and see that it "
"subtly doesn't work. Change it to a `const` and see it working again."
msgstr ""
"Distincția dintre o captură și o expresie constantă poate fi greu de "
"observat. Încercați să schimbați `2` din a două ramură cu o variabilă și "
"vedeți că, în mod subtil, nu mai funcționează. Schimbați-o într-o `const` și "
"vedeți că funcționează din nou."

#: src/pattern-matching/destructuring-enums.md
#, fuzzy
msgid "Like tuples, enums can also be destructured by matching:"
msgstr ""
"Ca și tuplurile, structurile și enumerațiile pot fi, de asemenea, "
"destructurate prin potrivire:"

#: src/pattern-matching/destructuring-enums.md
msgid ""
"Patterns can also be used to bind variables to parts of your values. This is "
"how you inspect the structure of your types. Let us start with a simple "
"`enum` type:"
msgstr ""
"Modelele pot fi, de asemenea, utilizate pentru a lega variabilele de părți "
"ale valorilor din variabile. În acest fel puteți inspecta structura "
"tipurilor dumneavoastră. Să începem cu un tip simplu `enum`:"

#: src/pattern-matching/destructuring-enums.md
#, fuzzy
msgid "\"cannot divide {n} into two equal parts\""
msgstr "\"nu poate împărți {n} în două părți egale\""

#: src/pattern-matching/destructuring-enums.md
#, fuzzy
msgid "\"{n} divided in two is {half}\""
msgstr "\"{n} împărțit la doi este {half}\""

#: src/pattern-matching/destructuring-enums.md
#, fuzzy
msgid "\"sorry, an error happened: {msg}\""
msgstr "\"Îmi pare rău, s-a produs o eroare: {msg}\""

#: src/pattern-matching/destructuring-enums.md
msgid ""
"Here we have used the arms to _destructure_ the `Result` value. In the first "
"arm, `half` is bound to the value inside the `Ok` variant. In the second "
"arm, `msg` is bound to the error message."
msgstr ""
"Aici am folosit ramificațiile pentru a _destructura_ valoarea `Result`. Pe "
"prima ramură `half` este legat de valoarea din interiorul variantei `Ok`. Pe "
"cea de-a doua ramură, `msg` este legat de mesajul de eroare."

#: src/pattern-matching/destructuring-enums.md
msgid ""
"The `if`/`else` expression is returning an enum that is later unpacked with "
"a `match`."
msgstr ""
"Expresia `if`/`else` returnează o enumerație care este ulterior descompusă "
"cu un `match`."

#: src/pattern-matching/destructuring-enums.md
msgid ""
"You can try adding a third variant to the enum definition and displaying the "
"errors when running the code. Point out the places where your code is now "
"inexhaustive and how the compiler tries to give you hints."
msgstr ""
"Puteți încerca să adăugați o a treia variantă la definiția enumerării și să "
"afișați erorile atunci când executați codul. Evidențiați locurile în care "
"codul dvs. este acum neexhaustiv și modul în care compilatorul încearcă să "
"vă ofere indicii."

#: src/pattern-matching/destructuring-enums.md
#, fuzzy
msgid ""
"The values in the enum variants can only be accessed after being pattern "
"matched."
msgstr ""
"Valorile din variantele enum pot fi accesate numai după ce au fost comparate "
"cu un model. Modelul leagă referințele la câmpurile din \"brațul de "
"potrivire\" după `=>`."

#: src/pattern-matching/destructuring-enums.md
#, fuzzy
msgid ""
"Demonstrate what happens when the search is inexhaustive. Note the advantage "
"the Rust compiler provides by confirming when all cases are handled."
msgstr ""
"Demonstrați ce se întâmplă atunci când căutarea este neexhaustivă. Observați "
"avantajul pe care îl oferă compilatorul Rust prin confirmarea momentului în "
"care sunt tratate toate cazurile. "

#: src/pattern-matching/destructuring-enums.md
#, fuzzy
msgid ""
"Save the result of `divide_in_two` in the `result` variable and `match` it "
"in a loop. That won't compile because `msg` is consumed when matched. To fix "
"it, match `&result` instead of `result`. That will make `msg` a reference so "
"it won't be consumed. This [\"match ergonomics\"](https://rust-lang.github."
"io/rfcs/2005-match-ergonomics.html) appeared in Rust 2018. If you want to "
"support older Rust, replace `msg` with `ref msg` in the pattern."
msgstr ""
"Salvați rezultatul `divide_in_two` în variabila `result` și `match` într-o "
"buclă. Acest lucru nu va fi compilat deoarece `msg` este consumat atunci "
"când se potrivește. Pentru a remedia problema, potriviți `&result` în loc de "
"`result`. Acest lucru va face din `msg` o referință, astfel încât nu va fi "
"consumată. Acest [\"match ergonomics\"](https://rust-lang.github.io/"
"rfcs/2005-match-ergonomics.html) a apărut în Rust 2018. Dacă doriți să "
"sprijiniți Rust mai vechi, înlocuiți `msg` cu `ref msg` în model."

#: src/pattern-matching/let-control-flow.md
msgid ""
"Rust has a few control flow constructs which differ from other languages. "
"They are used for pattern matching:"
msgstr ""
"Rust are câteva construcții pentru controlul fluxului care diferă de alte "
"limbaje. Acestea sunt utilizate pentru potrivirea șabloanelor:"

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "`if let` expressions"
msgstr "Expresii 'if let'"

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "`while let` expressions"
msgstr "Expresii 'while let'"

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "`match` expressions"
msgstr "Expresii 'match'"

#: src/pattern-matching/let-control-flow.md
msgid ""
"The [`if let` expression](https://doc.rust-lang.org/reference/expressions/if-"
"expr.html#if-let-expressions) lets you execute different code depending on "
"whether a value matches a pattern:"
msgstr ""
"Expresia [`if let`](https://doc.rust-lang.org/reference/expressions/if-expr."
"html#if-let-expressions) vă permite să executați un cod diferit în funcție "
"de potrivirea unei valori cu un șablon:"

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "\"slept for {:?}\""
msgstr "\"dormit pentru {:?}\""

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "`let else` expressions"
msgstr "Expresii while let"

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid ""
"For the common case of matching a pattern and returning from the function, "
"use [`let else`](https://doc.rust-lang.org/rust-by-example/flow_control/"
"let_else.html). The \"else\" case must diverge (`return`, `break`, or panic "
"- anything but falling off the end of the block)."
msgstr ""
"Pentru cazul obișnuit de potrivire a unui model și de întoarcere din "
"funcție, utilizați [`let else`](https://doc.rust-lang.org/rust-by-example/"
"flow_control/let_else.html). Cazul \"else\" trebuie să difere (`return`, "
"`break` sau panică - orice altceva în afară de căderea de la sfârșitul "
"blocului)."

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "\"got None\""
msgstr "\"Nu am primit nimic\""

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "\"got empty string\""
msgstr "\"a primit un șir gol\""

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "\"not a hex digit\""
msgstr "\"nu o cifră hexagonală\""

#: src/pattern-matching/let-control-flow.md src/pattern-matching/solution.md
msgid "\"result: {:?}\""
msgstr "\"result: {:?}\""

#: src/pattern-matching/let-control-flow.md src/generics/trait-bounds.md
#: src/smart-pointers/solution.md src/testing/solution.md
#: src/android/testing.md src/android/testing/googletest.md
#, fuzzy
msgid "\"foo\""
msgstr "\"foo\""

#: src/pattern-matching/let-control-flow.md
msgid ""
"Like with `if let`, there is a [`while let`](https://doc.rust-lang.org/"
"reference/expressions/loop-expr.html#predicate-pattern-loops) variant which "
"repeatedly tests a value against a pattern:"
msgstr ""
"Ca și în cazul lui `if let`, există o variantă [`while let`](https://doc."
"rust-lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops) "
"care testează în mod repetat o valoare în raport cu un model:"

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid ""
"Here [`String::pop`](https://doc.rust-lang.org/stable/std/string/struct."
"String.html#method.pop) returns `Some(c)` until the string is empty, after "
"which it will return `None`. The `while let` lets us keep iterating through "
"all items."
msgstr ""
"Aici, iteratorul returnat de `v.into_iter()` va returna un `Option<i32>` la "
"fiecare apel la `next()`. Acesta returnează `Some(x)` până când termină, "
"după care va returna `None`. Metoda `while let` ne permite să continuăm "
"iterația prin toate elementele."

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "if-let"
msgstr "Fluxul de control"

#: src/pattern-matching/let-control-flow.md
msgid ""
"Unlike `match`, `if let` does not have to cover all branches. This can make "
"it more concise than `match`."
msgstr ""
"Spre deosebire de `match`, `if let` nu trebuie să acopere toate ramurile. "
"Acest lucru îl poate face mai concis decât `match`."

#: src/pattern-matching/let-control-flow.md
msgid "A common usage is handling `Some` values when working with `Option`."
msgstr ""
"O utilizare obișnuită este manipularea valorilor `Some` atunci când se "
"lucrează cu `Option`."

#: src/pattern-matching/let-control-flow.md
msgid ""
"Unlike `match`, `if let` does not support guard clauses for pattern matching."
msgstr ""
"Spre deosebire de `match`, `if let` nu acceptă clauze de protecție pentru "
"potrivirea de tipare."

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "let-else"
msgstr "let-else"

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid ""
"`if-let`s can pile up, as shown. The `let-else` construct supports "
"flattening this nested code. Rewrite the awkward version for students, so "
"they can see the transformation."
msgstr ""
"`if-let`s se poate acumula, după cum se arată. Construcția `let-else` "
"permite aplatizarea acestui cod imbricate. Rescrieți versiunea ciudată "
"pentru elevi, astfel încât aceștia să poată vedea transformarea."

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "The rewritten version is:"
msgstr "Versiunea rescrisă este:"

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "while-let"
msgstr "bucle `while let`"

#: src/pattern-matching/let-control-flow.md
msgid ""
"Point out that the `while let` loop will keep going as long as the value "
"matches the pattern."
msgstr ""
"Precizați că bucla `while let` va continua atâta timp cât valoarea se "
"potrivește cu modelul."

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid ""
"You could rewrite the `while let` loop as an infinite loop with an if "
"statement that breaks when there is no value to unwrap for `name.pop()`. The "
"`while let` provides syntactic sugar for the above scenario."
msgstr ""
"Ați putea rescrie bucla `while let` ca o buclă infinită cu o instrucțiune if "
"care se întrerupe atunci când nu mai există nicio valoare de desfăcut pentru "
"`iter.next()`. `while let` oferă zahăr sintactic pentru scenariul de mai sus."

#: src/pattern-matching/exercise.md
#, fuzzy
msgid "Let's write a simple recursive evaluator for arithmetic expressions."
msgstr "Să scriem un evaluator recursiv pentru expresii aritmetice simplu."

#: src/pattern-matching/exercise.md
#, fuzzy
msgid ""
"The `Box` type here is a smart pointer, and will be covered in detail later "
"in the course. An expression can be \"boxed\" with `Box::new` as seen in the "
"tests. To evaluate a boxed expression, use the deref operator (`*`) to "
"\"unbox\" it: `eval(*boxed_expr)`."
msgstr ""
"Tipul `Box` de aici este un pointer inteligent și va fi tratat în detaliu "
"mai târziu în curs. O expresie poate fi \"încadrată\" cu `Box::new`, așa cum "
"se vede în teste. Pentru a evalua o expresie încadrată, utilizați operatorul "
"de diferențiere pentru a o \"despacheta\": `eval(*boxed_expr)`."

#: src/pattern-matching/exercise.md
#, fuzzy
msgid ""
"Some expressions cannot be evaluated and will return an error. The standard "
"[`Result<Value, String>`](https://doc.rust-lang.org/std/result/enum.Result."
"html) type is an enum that represents either a successful value "
"(`Ok(Value)`) or an error (`Err(String)`). We will cover this type in detail "
"later."
msgstr ""
"Unele expresii nu pot fi evaluate și vor returna o eroare. Tipul `Res` "
"reprezintă fie o valoare de succes, fie o eroare cu un mesaj. Acest tip este "
"foarte asemănător cu `Result` din biblioteca standard, pe care îl vom vedea "
"mai târziu."

#: src/pattern-matching/exercise.md
#, fuzzy
msgid ""
"Copy and paste the code into the Rust playground, and begin implementing "
"`eval`. The final product should pass the tests. It may be helpful to use "
"`todo!()` and get the tests to pass one-by-one. You can also skip a test "
"temporarily with `#[ignore]`:"
msgstr ""
"Copiați și lipiți codul în locul de joacă Rust și începeți să implementați "
"`eval`. Produsul final ar trebui să treacă testele. Poate fi util să "
"folosiți `todo!()` și să obțineți testele să treacă unul câte unul."

#: src/pattern-matching/exercise.md
#, fuzzy
msgid ""
"If you finish early, try writing a test that results in division by zero or "
"integer overflow. How could you handle this with `Result` instead of a panic?"
msgstr ""
"Dacă terminați mai devreme, încercați să scrieți un test care are ca "
"rezultat o depășire de număr întreg. Cum ați putea gestiona acest lucru cu "
"`Res::Err` în loc de o panică?"

#: src/pattern-matching/exercise.md src/pattern-matching/solution.md
#, fuzzy
msgid "/// An operation to perform on two subexpressions.\n"
msgstr "/// O operație care trebuie efectuată asupra a două subexpresii.\n"

#: src/pattern-matching/exercise.md src/pattern-matching/solution.md
#, fuzzy
msgid "/// An expression, in tree form.\n"
msgstr "/// O expresie, în formă de arbore.\n"

#: src/pattern-matching/exercise.md src/pattern-matching/solution.md
#, fuzzy
msgid "/// An operation on two subexpressions.\n"
msgstr "/// O operație asupra a două subexpresii.\n"

#: src/pattern-matching/exercise.md src/pattern-matching/solution.md
#, fuzzy
msgid "/// A literal value\n"
msgstr "/// O valoare literală\n"

#: src/pattern-matching/exercise.md src/pattern-matching/solution.md
#, fuzzy
msgid "\"division by zero\""
msgstr "\"împărțirea la zero\""

#: src/pattern-matching/solution.md
#, fuzzy
msgid "\"expr: {:?}\""
msgstr "\"expr: {:?}\""

#: src/methods-and-traits.md
#, fuzzy
msgid "[Methods](./methods-and-traits/methods.md) (10 minutes)"
msgstr "[Metode](./methods-and-traits/methods.md) (10 minute)"

#: src/methods-and-traits.md
#, fuzzy
msgid "[Traits](./methods-and-traits/traits.md) (15 minutes)"
msgstr "[Trăsături](./methods-and-traits/traits.md) (10 minute)"

#: src/methods-and-traits.md
#, fuzzy
msgid "[Deriving](./methods-and-traits/deriving.md) (3 minutes)"
msgstr "[Derivare](./methods-and-traits/deriving.md) (5 minute)"

#: src/methods-and-traits.md
#, fuzzy
msgid ""
"[Exercise: Generic Logger](./methods-and-traits/exercise.md) (20 minutes)"
msgstr ""
"[Exercițiu: Logger generic](./methods-and-traits/exercise.md) (20 minute)"

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"Rust allows you to associate functions with your new types. You do this with "
"an `impl` block:"
msgstr ""
"Rust vă permite să asociați funcții cu noile dvs. tipuri. Acest lucru se "
"face cu ajutorul unui bloc `impl`:"

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "// No receiver, a static method\n"
msgstr "// Fără receptor, o metodă statică\n"

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "// Exclusive borrowed read-write access to self\n"
msgstr "// Acces exclusiv împrumutat de citire-scriere pentru sine\n"

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "// Shared and read-only borrowed access to self\n"
msgstr "// Acces împrumutat partajat și numai pentru citire la sine\n"

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "\"Recorded {} laps for {}:\""
msgstr "\"Înregistrat {} ture pentru {}:\""

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "\"Lap {idx}: {lap} sec\""
msgstr "\"Tur {idx}: {lap} sec\""

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "// Exclusive ownership of self\n"
msgstr "// Proprietatea exclusivă a sinelui\n"

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "\"Race {} is finished, total lap time: {}\""
msgstr "\"Cursa {} s-a încheiat, timp total pe tur: {}\""

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "\"Monaco Grand Prix\""
msgstr "\"Marele Premiu de la Monaco\""

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "// race.add_lap(42);\n"
msgstr "// race.add_lap(42);\n"

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"The `self` arguments specify the \"receiver\" - the object the method acts "
"on. There are several common receivers for a method:"
msgstr ""
"Simbolul `&self` de mai sus indică faptul că metoda împrumută obiectul în "
"mod imuabil. Există și alți receptori posibili pentru o metodă:"

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"`&self`: borrows the object from the caller using a shared and immutable "
"reference. The object can be used again afterwards."
msgstr ""
"`&self`: împrumută obiectul de la apelant folosind o referință partajată și "
"imuabilă. Obiectul poate fi utilizat din nou ulterior."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"`&mut self`: borrows the object from the caller using a unique and mutable "
"reference. The object can be used again afterwards."
msgstr ""
"`&mut self`: împrumută obiectul de la apelant folosind o referință unică și "
"mutabilă. Obiectul poate fi utilizat din nou ulterior."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"`self`: takes ownership of the object and moves it away from the caller. The "
"method becomes the owner of the object. The object will be dropped "
"(deallocated) when the method returns, unless its ownership is explicitly "
"transmitted. Complete ownership does not automatically mean mutability."
msgstr ""
"`self`: preia proprietatea asupra obiectului și îl îndepărtează de la "
"apelant. Metoda devine proprietarul obiectului. Obiectul va fi abandonat "
"(dezalocat) la întoarcerea metodei, cu excepția cazului în care proprietatea "
"sa este transmisă în mod explicit. Proprietatea completă nu înseamnă automat "
"mutabilitate."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "`mut self`: same as above, but the method can mutate the object."
msgstr "`mut self`: la fel ca mai sus, dar metoda poate muta obiectul."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"No receiver: this becomes a static method on the struct. Typically used to "
"create constructors which are called `new` by convention."
msgstr ""
"Fără receptor: aceasta devine o metodă statică pe structura. Se utilizează "
"de obicei pentru a crea constructori care sunt numiți `new` prin convenție."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "It can be helpful to introduce methods by comparing them to functions."
msgstr ""
"Poate fi utilă introducerea metodelor prin compararea lor cu funcțiile."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"Methods are called on an instance of a type (such as a struct or enum), the "
"first parameter represents the instance as `self`."
msgstr ""
"Metodele sunt apelate pe o instanță a unui tip (cum ar fi un struct sau "
"enum), primul parametru reprezintă instanța ca `self`."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"Developers may choose to use methods to take advantage of method receiver "
"syntax and to help keep them more organized. By using methods we can keep "
"all the implementation code in one predictable place."
msgstr ""
"Dezvoltatorii pot alege să folosească metode pentru a profita de sintaxa "
"receptorului de metode și pentru a le menține mai bine organizate. Prin "
"utilizarea metodelor putem păstra tot codul de implementare într-un singur "
"loc previzibil."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "Point out the use of the keyword `self`, a method receiver."
msgstr "Indicați utilizarea cuvântului cheie `self`, un receptor de metodă."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"Show that it is an abbreviated term for `self: Self` and perhaps show how "
"the struct name could also be used."
msgstr ""
"Arătați că este un termen prescurtat pentru \"sine\": Self` și, eventual, "
"arătați cum ar putea fi folosit și numele structurii."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"Explain that `Self` is a type alias for the type the `impl` block is in and "
"can be used elsewhere in the block."
msgstr ""
"Explicați că `Self` este un alias de tip pentru tipul în care se află blocul "
"`impl` și poate fi utilizat în altă parte a blocului."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"Note how `self` is used like other structs and dot notation can be used to "
"refer to individual fields."
msgstr ""
"Observați cum `self` este utilizat ca și alte structuri și cum notația cu "
"puncte poate fi utilizată pentru a se referi la câmpuri individuale."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"This might be a good time to demonstrate how the `&self` differs from `self` "
"by trying to run `finish` twice."
msgstr ""
"Acesta ar putea fi un moment bun pentru a demonstra cum diferă `&self` de "
"`self` prin modificarea codului și încercarea de a rula say_hello de două "
"ori."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"Beyond variants on `self`, there are also [special wrapper types](https://"
"doc.rust-lang.org/reference/special-types-and-traits.html) allowed to be "
"receiver types, such as `Box<Self>`."
msgstr ""
"În afară de variantele lui `self`, există și [tipuri speciale de înveliș]"
"(https://doc.rust-lang.org/reference/special-types-and-traits.html) care pot "
"fi tipuri de receptor, cum ar fi `Box<Self>`."

#: src/methods-and-traits/traits.md
#, fuzzy
msgid ""
"Rust lets you abstract over types with traits. They're similar to interfaces:"
msgstr ""
"Rust vă permite să abstractizați tipurile cu ajutorul trăsăturilor. Acestea "
"sunt similare cu interfețele:"

#: src/methods-and-traits/traits.md
#, fuzzy
msgid "/// Return a sentence from this pet.\n"
msgstr "// Reexportați tipurile din acest modul.\n"

#: src/methods-and-traits/traits.md
#, fuzzy
msgid "/// Print a string to the terminal greeting this pet.\n"
msgstr "/// Tipărește un mesaj de salut pe ieșirea standard.\n"

#: src/methods-and-traits/traits.md
#, fuzzy
msgid ""
"A trait defines a number of methods that types must have in order to "
"implement the trait."
msgstr ""
"O trăsătură definește un număr de metode pe care tipurile trebuie să le aibă "
"pentru a implementa trăsătura respectivă."

#: src/methods-and-traits/traits.md
#, fuzzy
msgid ""
"In the \"Generics\" segment, next, we will see how to build functionality "
"that is generic over all types implementing a trait."
msgstr ""
"În continuare, în segmentul \"Generics\", vom vedea cum să construim o "
"funcționalitate care este generică pentru toate tipurile care implementează "
"o trăsătură."

#: src/methods-and-traits/traits/implementing.md
#, fuzzy
msgid "\"Oh you're a cutie! What's your name? {}\""
msgstr "\"Oh, ești un drăguț! Cum te cheamă? {}\""

#: src/methods-and-traits/traits/implementing.md
#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid "\"Woof, my name is {}!\""
msgstr "\"Woof, numele meu este {}!\""

#: src/methods-and-traits/traits/implementing.md
#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid "\"Fido\""
msgstr "\"Fido\""

#: src/methods-and-traits/traits/implementing.md
#, fuzzy
msgid ""
"To implement `Trait` for `Type`, you use an `impl Trait for Type { .. }` "
"block."
msgstr ""
"Trăsăturile sunt implementate într-un `impl <trait> pentru <type> { .. }`."

#: src/methods-and-traits/traits/implementing.md
#, fuzzy
msgid ""
"Unlike Go interfaces, just having matching methods is not enough: a `Cat` "
"type with a `talk()` method would not automatically satisfy `Pet` unless it "
"is in an `impl Pet` block."
msgstr ""
"Spre deosebire de interfețele Go, simpla potrivire a metodelor nu este "
"suficientă: un tip `Cat` cu o metodă `talk()` nu ar satisface automat `Pet` "
"decât dacă se află într-un bloc `impl Pet`."

#: src/methods-and-traits/traits/implementing.md
#, fuzzy
msgid ""
"Traits may provide default implementations of some methods. Default "
"implementations can rely on all the methods of the trait. In this case, "
"`greet` is provided, and relies on `talk`."
msgstr ""
"Trăsăturile pot specifica metode preimplementate (implicite) și metode pe "
"care utilizatorii trebuie să le implementeze ei înșiși. Metodele cu "
"implementări implicite se pot baza pe metodele obligatorii."

#: src/methods-and-traits/traits/supertraits.md
#, fuzzy
msgid ""
"A trait can require that types implementing it also implement other traits, "
"called _supertraits_. Here, any type implementing `Pet` must implement "
"`Animal`."
msgstr ""
"O trăsătură poate impune ca tipurile care o implementează să implementeze și "
"alte trăsături, numite _supertraits_. Aici, orice tip care implementează "
"`Pet` trebuie să implementeze `Animal`."

#: src/methods-and-traits/traits/supertraits.md
#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid "\"Rex\""
msgstr "\"Rex\""

#: src/methods-and-traits/traits/supertraits.md
#, fuzzy
msgid "\"{} has {} legs\""
msgstr "\"{} are {} ani\""

#: src/methods-and-traits/traits/supertraits.md
#, fuzzy
msgid ""
"This is sometimes called \"trait inheritance\" but students should not "
"expect this to behave like OO inheritance. It just specifies an additional "
"requirement on implementations of a trait."
msgstr ""
"Acest lucru se numește uneori \"moștenire de trăsături\", dar studenții nu "
"trebuie să se aștepte ca aceasta să se comporte ca moștenirea OO. Aceasta "
"specifică doar o cerință suplimentară pentru implementările unei trăsături."

#: src/methods-and-traits/traits/associated-types.md
#, fuzzy
msgid ""
"Associated types are placeholder types which are supplied by the trait "
"implementation."
msgstr ""
"Tipurile asociate sunt tipuri de tip \"placeholder\" care sunt furnizate de "
"implementarea trăsăturii."

#: src/methods-and-traits/traits/associated-types.md
#: src/concurrency/async-control-flow/join.md
msgid "\"{:?}\""
msgstr "\"{:?}\""

#: src/methods-and-traits/traits/associated-types.md
#, fuzzy
msgid ""
"Associated types are sometimes also called \"output types\". The key "
"observation is that the implementer, not the caller, chooses this type."
msgstr ""
"Tipurile asociate sunt uneori denumite și \"tipuri de ieșire\". Observația "
"cheie este că acest tip este ales de către implementator, nu de către "
"apelant."

#: src/methods-and-traits/traits/associated-types.md
#, fuzzy
msgid ""
"Many standard library traits have associated types, including arithmetic "
"operators and `Iterator`."
msgstr ""
"Multe trăsături de bibliotecă standard au tipuri asociate, inclusiv "
"operatorii aritmetici și `Iterator`."

#: src/methods-and-traits/deriving.md
#, fuzzy
msgid ""
"Supported traits can be automatically implemented for your custom types, as "
"follows:"
msgstr ""
"Trăsăturile acceptate pot fi implementate automat pentru tipurile dvs. "
"personalizate, după cum urmează:"

#: src/methods-and-traits/deriving.md
#, fuzzy
msgid "// Default trait adds `default` constructor.\n"
msgstr "// Caracteristica implicită adaugă constructorul `default`.\n"

#: src/methods-and-traits/deriving.md
#, fuzzy
msgid "// Clone trait adds `clone` method.\n"
msgstr "// Trăsătura Clone adaugă metoda `clone`.\n"

#: src/methods-and-traits/deriving.md
#, fuzzy
msgid "\"EldurScrollz\""
msgstr "\"EldurScrollz\""

#: src/methods-and-traits/deriving.md
#, fuzzy
msgid "// Debug trait adds support for printing with `{:?}`.\n"
msgstr "// Trăsătura Debug adaugă suport pentru imprimarea cu `{:?}`.\n"

#: src/methods-and-traits/deriving.md
#, fuzzy
msgid "\"{:?} vs. {:?}\""
msgstr "Șir de caractere (string) versus str"

#: src/methods-and-traits/deriving.md
#, fuzzy
msgid ""
"Derivation is implemented with macros, and many crates provide useful derive "
"macros to add useful functionality. For example, `serde` can derive "
"serialization support for a struct using `#[derive(Serialize)]`."
msgstr ""
"Derivarea este implementată cu macro-uri, iar multe crates oferă macro-uri "
"derive utile pentru a adăuga funcționalități utile. De exemplu, `serde` "
"poate deriva suportul de serializare pentru o structură folosind "
"`#[derive(Serialize)]`."

#: src/methods-and-traits/exercise.md
#, fuzzy
msgid "Exercise: Logger Trait"
msgstr "Exercițiu: Logger generic"

#: src/methods-and-traits/exercise.md
#, fuzzy
msgid ""
"Let's design a simple logging utility, using a trait `Logger` with a `log` "
"method. Code which might log its progress can then take an `&impl Logger`. "
"In testing, this might put messages in the test logfile, while in a "
"production build it would send messages to a log server."
msgstr ""
"Să proiectăm un utilitar de logare simplu, folosind o trăsătură `Logger` cu "
"o metodă `log`. Codul care ar putea înregistra progresul său poate lua un "
"`&impl Logger`. În timpul testelor, acesta ar putea plasa mesaje în fișierul "
"de jurnal de test, în timp ce în cazul unei compilări de producție ar "
"trimite mesaje către un server de jurnal."

#: src/methods-and-traits/exercise.md
#, fuzzy
msgid ""
"However, the `StderrLogger` given below logs all messages, regardless of "
"verbosity. Your task is to write a `VerbosityFilter` type that will ignore "
"messages above a maximum verbosity."
msgstr ""
"Cu toate acestea, `StderrLogger` dat mai jos înregistrează toate mesajele, "
"indiferent de verbozitate. Sarcina dvs. este de a scrie un tip "
"`VerbosityFilter` care să ignore mesajele care depășesc o verbozitate maximă."

#: src/methods-and-traits/exercise.md
#, fuzzy
msgid ""
"This is a common pattern: a struct wrapping a trait implementation and "
"implementing that same trait, adding behavior in the process. What other "
"kinds of wrappers might be useful in a logging utility?"
msgstr ""
"Acesta este un model comun: o structură care înfășoară o implementare a unei "
"trăsături și care implementează aceeași trăsătură, adăugând comportament în "
"acest proces. Ce alte tipuri de învelișuri ar putea fi utile într-un "
"utilitar de logare?"

#: src/methods-and-traits/exercise.md src/methods-and-traits/solution.md
#, fuzzy
msgid "/// Log a message at the given verbosity level.\n"
msgstr "/// Înregistrați un mesaj la nivelul de verbozitate dat.\n"

#: src/methods-and-traits/exercise.md src/methods-and-traits/solution.md
#, fuzzy
msgid "\"verbosity={verbosity}: {message}\""
msgstr "\"verbosity={verbosity}: {message}\""

#: src/methods-and-traits/exercise.md src/methods-and-traits/solution.md
#, fuzzy
msgid "\"FYI\""
msgstr "\"FYI\""

#: src/methods-and-traits/exercise.md src/methods-and-traits/solution.md
#, fuzzy
msgid "\"Uhoh\""
msgstr "\"Uhoh\""

#: src/methods-and-traits/exercise.md
#, fuzzy
msgid "// TODO: Define and implement `VerbosityFilter`.\n"
msgstr "// TODO: Definiți și implementați `VerbosityFilter`.\n"

#: src/methods-and-traits/solution.md
#, fuzzy
msgid "/// Only log messages up to the given verbosity level.\n"
msgstr ""
"/// Înregistrați numai mesajele de jurnal până la nivelul de verbozitate "
"dat.\n"

#: src/welcome-day-2-afternoon.md
#, fuzzy
msgid "[Generics](./generics.md) (40 minutes)"
msgstr "[Generice](../generics.md) (45 minute)"

#: src/welcome-day-2-afternoon.md
#, fuzzy
msgid "[Standard Library Types](./std-types.md) (1 hour and 20 minutes)"
msgstr "[Tipuri de bibliotecă standard](../std-types.md) (1 oră și 10 minute)"

#: src/welcome-day-2-afternoon.md
#, fuzzy
msgid "[Standard Library Traits](./std-traits.md) (1 hour and 40 minutes)"
msgstr ""
"[Trăsături ale bibliotecii standard](../std-traits.md) (1 oră și 40 de "
"minute)"

#: src/welcome-day-2-afternoon.md
#, fuzzy
msgid "Including 10 minute breaks, this session should take about 4 hours"
msgstr ""
"Incluzând pauzele de 10 minute, această sesiune ar trebui să dureze "
"aproximativ 2 ore și 55 de minute"

#: src/generics.md
#, fuzzy
msgid "[Generic Functions](./generics/generic-functions.md) (5 minutes)"
msgstr "[Funcții generice](./generics/generic-functions.md) (5 minute)"

#: src/generics.md
#, fuzzy
msgid "[Generic Data Types](./generics/generic-data.md) (10 minutes)"
msgstr "[Tipuri de date generice](./generics/generic-data.md) (15 minute)"

#: src/generics.md
#, fuzzy
msgid "[Trait Bounds](./generics/trait-bounds.md) (10 minutes)"
msgstr "[Limite ale trăsăturilor](./generics/trait-bounds.md) (10 minute)"

#: src/generics.md
#, fuzzy
msgid "[impl Trait](./generics/impl-trait.md) (5 minutes)"
msgstr "[impl Trait](./generics/impl-trait.md) (5 minute)"

#: src/generics.md
#, fuzzy
msgid "[Exercise: Generic min](./generics/exercise.md) (10 minutes)"
msgstr "[Exercițiu: Generic min](./generics/exercise.md) (10 minute)"

#: src/generics/generic-functions.md
#, fuzzy
msgid ""
"Rust supports generics, which lets you abstract algorithms or data "
"structures (such as sorting or a binary tree) over the types used or stored."
msgstr ""
"Rust suportă generice, ceea ce vă permite să abstractizați algoritmi sau "
"structuri de date (cum ar fi sortarea sau un arbore binar) peste tipurile "
"utilizate sau stocate."

#: src/generics/generic-functions.md
#, fuzzy
msgid "/// Pick `even` or `odd` depending on the value of `n`.\n"
msgstr "/// Alege `even` sau `odd` în funcție de valoarea lui `n`.\n"

#: src/generics/generic-functions.md
#, fuzzy
msgid "\"picked a number: {:?}\""
msgstr "\"a ales un număr: {:?}\""

#: src/generics/generic-functions.md
#, fuzzy
msgid "\"picked a tuple: {:?}\""
msgstr "\"a ales un tuple: {:?}\""

#: src/generics/generic-functions.md
#, fuzzy
msgid "\"dog\""
msgstr "\"câine\""

#: src/generics/generic-functions.md
#, fuzzy
msgid "\"cat\""
msgstr "\"cat\""

#: src/generics/generic-functions.md
#, fuzzy
msgid ""
"Rust infers a type for T based on the types of the arguments and return "
"value."
msgstr ""
"Rust deduce un tip pentru T pe baza tipurilor argumentelor și a valorii de "
"returnare."

#: src/generics/generic-functions.md
#, fuzzy
msgid ""
"This is similar to C++ templates, but Rust partially compiles the generic "
"function immediately, so that function must be valid for all types matching "
"the constraints. For example, try modifying `pick` to return `even + odd` if "
"`n == 0`. Even if only the `pick` instantiation with integers is used, Rust "
"still considers it invalid. C++ would let you do this."
msgstr ""
"Acest lucru este similar cu șabloanele C++, dar Rust compilează parțial "
"funcția generică imediat, astfel încât funcția trebuie să fie valabilă "
"pentru toate tipurile care corespund constrângerilor. De exemplu, încercați "
"să modificați `pick` pentru a returna `even + odd` dacă `n == 0`. Chiar dacă "
"se utilizează doar instanțierea `pick` cu numere întregi, Rust o consideră "
"în continuare invalidă. C++ v-ar permite să faceți acest lucru."

#: src/generics/generic-functions.md
#, fuzzy
msgid ""
"Generic code is turned into non-generic code based on the call sites. This "
"is a zero-cost abstraction: you get exactly the same result as if you had "
"hand-coded the data structures without the abstraction."
msgstr ""
"Aceasta este o abstractizare cu costuri zero: obțineți exact același "
"rezultat ca și cum ați fi codat manual structurile de date fără "
"abstractizare."

#: src/generics/generic-data.md
#, fuzzy
msgid "You can use generics to abstract over the concrete field type:"
msgstr ""
"Puteți utiliza elementele generice pentru a face abstracție de tipul de câmp "
"concret:"

#: src/generics/generic-data.md
#, fuzzy
msgid "\"{integer:?} and {float:?}\""
msgstr "\"{integer:?} și {float:?}\""

#: src/generics/generic-data.md
#, fuzzy
msgid "\"coords: {:?}\""
msgstr "\"coords: {:?}\""

#: src/generics/generic-data.md
#, fuzzy
msgid ""
"_Q:_ Why `T` is specified twice in `impl<T> Point<T> {}`? Isn't that "
"redundant?"
msgstr ""
"întrebare: De ce `T` este specificat de două ori în `impl<T> Point<T> {}`? "
"Nu este redundant?"

#: src/generics/generic-data.md
#, fuzzy
msgid ""
"This is because it is a generic implementation section for generic type. "
"They are independently generic."
msgstr ""
"Acest lucru se datorează faptului că este o secțiune de implementare "
"generică pentru un tip generic. Acestea sunt generice în mod independent."

#: src/generics/generic-data.md
#, fuzzy
msgid "It means these methods are defined for any `T`."
msgstr "Aceasta înseamnă că aceste metode sunt definite pentru orice `T`."

#: src/generics/generic-data.md
#, fuzzy
msgid "It is possible to write `impl Point<u32> { .. }`."
msgstr "Este posibil să se scrie `impl Point<u32> { .. }`. "

#: src/generics/generic-data.md
#, fuzzy
msgid ""
"`Point` is still generic and you can use `Point<f64>`, but methods in this "
"block will only be available for `Point<u32>`."
msgstr ""
"`Point` este în continuare generic și puteți utiliza `Point<f64>`, dar "
"metodele din acest bloc vor fi disponibile numai pentru `Point<u32>`."

#: src/generics/generic-data.md
#, fuzzy
msgid ""
"Try declaring a new variable `let p = Point { x: 5, y: 10.0 };`. Update the "
"code to allow points that have elements of different types, by using two "
"type variables, e.g., `T` and `U`."
msgstr ""
"Încercați să declarați o nouă variabilă `let p = Point { x: 5, y: 10.0 };`. "
"Actualizați codul pentru a permite puncte care au elemente de tipuri "
"diferite, utilizând două variabile de tip, de exemplu, `T` și `U`."

#: src/generics/generic-traits.md
#, fuzzy
msgid ""
"Traits can also be generic, just like types and functions. A trait's "
"parameters get concrete types when it is used."
msgstr ""
"Trăsăturile pot fi, de asemenea, generice, la fel ca tipurile și funcțiile. "
"Parametrii unei trăsături primesc tipuri concrete atunci când aceasta este "
"utilizată."

#: src/generics/generic-traits.md
#, fuzzy
msgid "\"Converted from integer: {from}\""
msgstr "\"Convertit din număr întreg: {from}\""

#: src/generics/generic-traits.md
#, fuzzy
msgid "\"Converted from bool: {from}\""
msgstr "\"Convertit din bool: {from}\""

#: src/generics/generic-traits.md
#, fuzzy
msgid "\"{from_int:?}, {from_bool:?}\""
msgstr "\"{from_int:?}, {from_bool:?}\""

#: src/generics/generic-traits.md
#, fuzzy
msgid ""
"The `From` trait will be covered later in the course, but its [definition in "
"the `std` docs](https://doc.rust-lang.org/std/convert/trait.From.html) is "
"simple."
msgstr ""
"Trăsătura `From` va fi abordată mai târziu în curs, dar [definiția sa din "
"documentația `std`](https://doc.rust-lang.org/std/convert/trait.From.html) "
"este simplă."

#: src/generics/generic-traits.md
#, fuzzy
msgid ""
"Implementations of the trait do not need to cover all possible type "
"parameters. Here, `Foo::From(\"hello\")` would not compile because there is "
"no `From<&str>` implementation for `Foo`."
msgstr ""
"Nu este necesar ca implementările trăsăturii să acopere toți parametrii de "
"tip posibili. Aici, `Foo::From(\"hello\")` nu ar fi compilat deoarece nu "
"există o implementare `From<&str>` pentru `Foo`."

#: src/generics/generic-traits.md
#, fuzzy
msgid ""
"Generic traits take types as \"input\", while associated types are a kind of "
"\"output\" type. A trait can have multiple implementations for different "
"input types."
msgstr ""
"Trăsăturile generice iau tipuri ca \"intrare\", în timp ce tipurile asociate "
"sunt un fel de tipuri de \"ieșire\". O trăsătură poate avea mai multe "
"implementări pentru diferite tipuri de intrare."

#: src/generics/generic-traits.md
#, fuzzy
msgid ""
"In fact, Rust requires that at most one implementation of a trait match for "
"any type T. Unlike some other languages, Rust has no heuristic for choosing "
"the \"most specific\" match. There is work on adding this support, called "
"[specialization](https://rust-lang.github.io/rfcs/1210-impl-specialization."
"html)."
msgstr ""
"De fapt, Rust cere ca cel mult o implementare a unei trăsături să se "
"potrivească pentru orice tip T. Spre deosebire de alte limbaje, Rust nu are "
"o euristică pentru alegerea celei mai \"specifice\" potriviri. Se lucrează "
"la adăugarea acestui suport, numit [specializare](https://rust-lang.github."
"io/rfcs/1210-impl-specialization.html)."

#: src/generics/trait-bounds.md
msgid ""
"When working with generics, you often want to require the types to implement "
"some trait, so that you can call this trait's methods."
msgstr ""
"Atunci când lucrați cu metode generice, deseori doriți să solicitați ca "
"tipurile să implementeze o anumită trăsătură, astfel încât să puteți apela "
"metodele acestei trăsături."

#: src/generics/trait-bounds.md
msgid "You can do this with `T: Trait` or `impl Trait`:"
msgstr "Puteți face acest lucru cu `T: Trait` sau `impl Trait`:"

#: src/generics/trait-bounds.md
#, fuzzy
msgid "// struct NotClonable;\n"
msgstr "// struct NotClonable;\n"

#: src/generics/trait-bounds.md
#, fuzzy
msgid "\"{pair:?}\""
msgstr ""
"```rust,editable\n"
"fn duplicate<T: Clone>(a: T) -> (T, T) {\n"
"    (a.clone(), a.clone())\n"
"}\n"
"\n"
"// Syntactic sugar for:\n"
"//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"
"fn add_42_millions(x: impl Into<i32>) -> i32 {\n"
"    x.into() + 42_000_000\n"
"}\n"
"\n"
"// struct NotClonable;\n"
"\n"
"fn main() {\n"
"    let foo = String::from(\"foo\");\n"
"    let pair = duplicate(foo);\n"
"    println!(\"{pair:?}\");\n"
"\n"
"    let many = add_42_millions(42_i8);\n"
"    println!(\"{many}\");\n"
"    let many_more = add_42_millions(10_000_000);\n"
"    println!(\"{many_more}\");\n"
"}\n"
"```"

#: src/generics/trait-bounds.md
#, fuzzy
msgid "Try making a `NonClonable` and passing it to `duplicate`."
msgstr "Încercați să creați un `NonClonable` și să îl treceți la `duplicate`."

#: src/generics/trait-bounds.md
#, fuzzy
msgid "When multiple traits are necessary, use `+` to join them."
msgstr ""
"Atunci când sunt necesare mai multe trăsături, utilizați `+` pentru a le uni."

#: src/generics/trait-bounds.md
msgid "Show a `where` clause, students will encounter it when reading code."
msgstr ""
"Arătați o clauză `where`, elevii o vor întâlni atunci când vor citi codul."

#: src/generics/trait-bounds.md
msgid "It declutters the function signature if you have many parameters."
msgstr "Aranjează semnătura funcției dacă are mulți parametri."

#: src/generics/trait-bounds.md
msgid "It has additional features making it more powerful."
msgstr "Are caracteristici suplimentare care îl fac mai puternic."

#: src/generics/trait-bounds.md
msgid ""
"If someone asks, the extra feature is that the type on the left of \":\" can "
"be arbitrary, like `Option<T>`."
msgstr ""
"Dacă cineva întreabă, caracteristica suplimentară este că tipul din stânga "
"lui \":\" poate fi arbitrar, cum ar fi `Option<T>`."

#: src/generics/trait-bounds.md
#, fuzzy
msgid ""
"Note that Rust does not (yet) support specialization. For example, given the "
"original `duplicate`, it is invalid to add a specialized `duplicate(a: u32)`."
msgstr ""
"Rețineți că Rust nu suportă (încă) specializarea. De exemplu, având în "
"vedere `duplicate` original, nu este valid să se adauge un `duplicate(a: "
"u32)` specializat."

#: src/generics/impl-trait.md
msgid ""
"Similar to trait bounds, an `impl Trait` syntax can be used in function "
"arguments and return values:"
msgstr ""
"La fel ca în cazul limitelor trăsăturilor, o sintaxă `impl Trait` poate fi "
"utilizată în argumentele funcțiilor și în valorile returnate:"

#: src/generics/impl-trait.md
#, fuzzy
msgid ""
"// Syntactic sugar for:\n"
"//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"
msgstr ""
"// Zahăr sintactic pentru:\n"
"// fn add_42_millions&lt;T: Into<i32>&gt;(x: T) -&gt; i32 {\n"

#: src/generics/impl-trait.md
#, fuzzy
msgid "\"{many}\""
msgstr ""
"Proiectul Rust găzduiește multe resurse. Acestea se referă la Rust în "
"general:"

#: src/generics/impl-trait.md
#, fuzzy
msgid "\"{many_more}\""
msgstr "\"{many_more}\""

#: src/generics/impl-trait.md
#, fuzzy
msgid "\"debuggable: {debuggable:?}\""
msgstr "\"debuggable: {debuggable:?}\""

#: src/generics/impl-trait.md
#, fuzzy
msgid ""
"`impl Trait` allows you to work with types which you cannot name. The "
"meaning of `impl Trait` is a bit different in the different positions."
msgstr ""
"Semnificația lui `impl Trait` este puțin diferită în diferitele poziții."

#: src/generics/impl-trait.md
#, fuzzy
msgid ""
"For a parameter, `impl Trait` is like an anonymous generic parameter with a "
"trait bound."
msgstr ""
"Pentru un parametru, `impl Trait` este ca un parametru generic anonim cu o "
"trăsătură legată."

#: src/generics/impl-trait.md
#, fuzzy
msgid ""
"For a return type, it means that the return type is some concrete type that "
"implements the trait, without naming the type. This can be useful when you "
"don't want to expose the concrete type in a public API."
msgstr ""
"Pentru un tip de returnare, înseamnă că tipul de returnare este un tip "
"concret care implementează trăsătura, fără a numi tipul. Acest lucru poate "
"fi util atunci când nu doriți să expuneți tipul concret într-o API publică."

#: src/generics/impl-trait.md
#, fuzzy
msgid ""
"Inference is hard in return position. A function returning `impl Foo` picks "
"the concrete type it returns, without writing it out in the source. A "
"function returning a generic type like `collect<B>() -> B` can return any "
"type satisfying `B`, and the caller may need to choose one, such as with "
"`let x: Vec<_> = foo.collect()` or with the turbofish, `foo.collect::"
"<Vec<_>>()`."
msgstr ""
"Inferența este dificilă în poziția de retur. O funcție care returnează `impl "
"Foo` alege tipul concret pe care îl returnează, fără a scrie acest lucru în "
"sursă. O funcție care returnează un tip generic, cum ar fi `collect<B>() -"
"&gt; B`, poate returna orice tip care satisface `B`, iar apelantul poate fi "
"nevoit să aleagă unul, ca în cazul lui `let x: Vec<_> = foo.collect()` sau "
"cu turbofishul, `foo.collect::&lt;Vec<_>&gt;()`."

#: src/generics/impl-trait.md
#, fuzzy
msgid ""
"What is the type of `debuggable`? Try `let debuggable: () = ..` to see what "
"the error message shows."
msgstr ""
"Care este tipul de `debuggable`? Încercați `let debuggable: () = ..` pentru "
"a vedea ce afișează mesajul de eroare."

#: src/generics/exercise.md
#, fuzzy
msgid ""
"In this short exercise, you will implement a generic `min` function that "
"determines the minimum of two values, using the [`Ord`](https://doc.rust-"
"lang.org/stable/std/cmp/trait.Ord.html) trait."
msgstr ""
"În acest scurt exercițiu, veți implementa o funcție generică `min` care "
"determină minimul a două valori, utilizând o trăsătură `LessThan`."

#: src/generics/exercise.md
#, fuzzy
msgid "// TODO: implement the `min` function used in `main`.\n"
msgstr "// TODO: implementați funcția `min` folosită în `main`.\n"

#: src/generics/exercise.md src/generics/solution.md
#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "'z'"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    inspect(&[0, -2, 3]);\n"
"    inspect(&[0, -2, 3, 4]);\n"
"}\n"
"\n"
"#[rustfmt::skip]\n"
"fn inspect(slice: &[i32]) {\n"
"    println!(\"Spune-mi despre {slice:?}\");\n"
"    match slice {\n"
"        &[0, y, z] => println!(\"Primul element 0, y = {y}, și z = {z}\"),\n"
"        &[1, ..]   => println!(\"Primul element este 1 și restul sunt "
"ignorate\"),\n"
"        _          => println!(\"Toate elementele au fost ignorate\"),\n"
"    }\n"
"}\n"
"```"

#: src/generics/exercise.md src/generics/solution.md
#, fuzzy
msgid "'7'"
msgstr "'x'"

#: src/generics/exercise.md src/generics/solution.md
msgid "'1'"
msgstr "'1'"

#: src/generics/exercise.md src/generics/solution.md
#, fuzzy
msgid "\"goodbye\""
msgstr "\"La revedere\""

#: src/generics/exercise.md src/generics/solution.md
#, fuzzy
msgid "\"bat\""
msgstr "\"bat\""

#: src/generics/exercise.md src/generics/solution.md
#, fuzzy
msgid "\"armadillo\""
msgstr "\"Armadillo\""

#: src/generics/exercise.md
#, fuzzy
msgid ""
"Show students the [`Ord`](https://doc.rust-lang.org/stable/std/cmp/trait.Ord."
"html) trait and [`Ordering`](https://doc.rust-lang.org/stable/std/cmp/enum."
"Ordering.html) enum."
msgstr ""
"[`OsStr`](https://doc.rust-lang.org/std/ffi/struct.OsStr.html) și "
"[`OsString`](https://doc.rust-lang.org/std/ffi/struct.OsString.html)"

#: src/std-types.md
#, fuzzy
msgid "[Standard Library](./std-types/std.md) (3 minutes)"
msgstr "[Biblioteca standard](./std-types/std.md) (3 minute)"

#: src/std-types.md
#, fuzzy
msgid "[Documentation](./std-types/docs.md) (5 minutes)"
msgstr "[Documentație](./std-types/docs.md) (5 minute)"

#: src/std-types.md
#, fuzzy
msgid "[Option](./std-types/option.md) (10 minutes)"
msgstr "[Opțiune](./std-types/option.md) (10 minute)"

#: src/std-types.md
#, fuzzy
msgid "[Result](./std-types/result.md) (10 minutes)"
msgstr "[Rezultat](./std-types/result.md) (10 minute)"

#: src/std-types.md
#, fuzzy
msgid "[String](./std-types/string.md) (10 minutes)"
msgstr "[String](./std-types/string.md) (10 minute)"

#: src/std-types.md
#, fuzzy
msgid "[Vec](./std-types/vec.md) (10 minutes)"
msgstr "[Vec](./std-types/vec.md) (10 minute)"

#: src/std-types.md
#, fuzzy
msgid "[HashMap](./std-types/hashmap.md) (10 minutes)"
msgstr "[HashMap](./std-types/hashmap.md) (10 minute)"

#: src/std-types.md
#, fuzzy
msgid "[Exercise: Counter](./std-types/exercise.md) (20 minutes)"
msgstr "[Exercițiu: Contorizare](./std-types/exercise.md) (10 minute)"

#: src/std-types.md
#, fuzzy
msgid "This segment should take about 1 hour and 20 minutes"
msgstr "Acest segment ar trebui să dureze aproximativ 1 oră și 10 minute"

#: src/std-types.md
#, fuzzy
msgid ""
"For each of the slides in this section, spend some time reviewing the "
"documentation pages, highlighting some of the more common methods."
msgstr ""
"Pentru fiecare dintre diapozitivele din această secțiune, petreceți ceva "
"timp examinând paginile de documentație, subliniind unele dintre cele mai "
"comune metode."

#: src/std-types/std.md
#, fuzzy
msgid ""
"Rust comes with a standard library which helps establish a set of common "
"types used by Rust libraries and programs. This way, two libraries can work "
"together smoothly because they both use the same `String` type."
msgstr ""
"Rust vine cu o bibliotecă standard care ajută la stabilirea unui set de "
"tipuri comune utilizate de bibliotecile și programele Rust. În acest fel, "
"două biblioteci pot lucra împreună fără probleme, deoarece ambele utilizează "
"același tip `String`."

#: src/std-types/std.md
#, fuzzy
msgid ""
"In fact, Rust contains several layers of the Standard Library: `core`, "
"`alloc` and `std`."
msgstr ""
"De fapt, Rust conține mai multe straturi ale bibliotecii standard: `core`, "
"`alloc` și `std`."

#: src/std-types/std.md
#, fuzzy
msgid ""
"`core` includes the most basic types and functions that don't depend on "
"`libc`, allocator or even the presence of an operating system."
msgstr ""
"`core` include cele mai de bază tipuri și funcții care nu depind de `libc`, "
"de alocator sau chiar de prezența unui sistem de operare."

#: src/std-types/std.md
#, fuzzy
msgid ""
"`alloc` includes types which require a global heap allocator, such as `Vec`, "
"`Box` and `Arc`."
msgstr ""
"`alloc` include tipuri care necesită un alocator global de heap, cum ar fi "
"`Vec`, `Box` și `Arc`."

#: src/std-types/std.md
#, fuzzy
msgid ""
"Embedded Rust applications often only use `core`, and sometimes `alloc`."
msgstr ""
"Aplicațiile Rust încorporate folosesc adesea doar `core` și uneori `alloc`."

#: src/std-types/docs.md
#, fuzzy
msgid "Rust comes with extensive documentation. For example:"
msgstr "Rust este însoțit de o documentație extinsă. De exemplu:"

#: src/std-types/docs.md
#, fuzzy
msgid ""
"All of the details about [loops](https://doc.rust-lang.org/stable/reference/"
"expressions/loop-expr.html)."
msgstr ""
"Dacă doriți să ieșiți mai devreme dintr-o buclă, utilizați [`break`](https://"
"doc.rust-lang.org/reference/expressions/loop-expr.html#break-expressions),"

#: src/std-types/docs.md
#, fuzzy
msgid ""
"Primitive types like [`u8`](https://doc.rust-lang.org/stable/std/primitive."
"u8.html)."
msgstr ""
"Tipuri primitive precum [`u8`](https://doc.rust-lang.org/stable/std/"
"primitive.u8.html)."

#: src/std-types/docs.md
#, fuzzy
msgid ""
"Standard library types like [`Option`](https://doc.rust-lang.org/stable/std/"
"option/enum.Option.html) or [`BinaryHeap`](https://doc.rust-lang.org/stable/"
"std/collections/struct.BinaryHeap.html)."
msgstr ""
"[`str`](https://doc.rust-lang.org/std/primitive.str.html) și [`String`]"
"(https://doc.rust-lang.org/std/string/struct.String.html)"

#: src/std-types/docs.md
#, fuzzy
msgid "In fact, you can document your own code:"
msgstr "De fapt, vă puteți documenta propriul cod:"

#: src/std-types/docs.md
#, fuzzy
msgid ""
"/// Determine whether the first argument is divisible by the second "
"argument.\n"
"///\n"
"/// If the second argument is zero, the result is false.\n"
msgstr ""
"/// Determină dacă primul argument este divizibil cu al doilea argument.\n"
"///\n"
"/// Dacă al doilea argument este zero, rezultatul este fals.\n"

#: src/std-types/docs.md
#, fuzzy
msgid ""
"The contents are treated as Markdown. All published Rust library crates are "
"automatically documented at [`docs.rs`](https://docs.rs) using the [rustdoc]"
"(https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html) tool. It is "
"idiomatic to document all public items in an API using this pattern."
msgstr ""
"Conținutul este tratat ca Markdown. Toate crates cu bibliotecă Rust "
"publicate sunt documentate automat la [`docs.rs`](https://docs.rs) folosind "
"instrumentul [rustdoc](https://doc.rust-lang.org/rustdoc/what-is-rustdoc."
"html). Documentarea tuturor elementelelor publice dintr-un API, folosind "
"acest model, este idiomatică. Fragmentele de cod pot documenta utilizarea și "
"vor fi folosite ca teste unitare."

#: src/std-types/docs.md
#, fuzzy
msgid ""
"To document an item from inside the item (such as inside a module), use `//!"
"` or `/*! .. */`, called \"inner doc comments\":"
msgstr ""
"Pentru a documenta un element din interiorul elementului (cum ar fi în "
"interiorul unui modul), utilizați `//!` sau `/*! ... */`, denumite "
"\"comentarii interne ale documentului\":"

#: src/std-types/docs.md
#, fuzzy
msgid ""
"//! This module contains functionality relating to divisibility of "
"integers.\n"
msgstr ""
"//! Acest modul conține funcționalități referitoare la divizibilitatea "
"numerelor întregi.\n"

#: src/std-types/docs.md
#, fuzzy
msgid ""
"Show students the generated docs for the `rand` crate at <https://docs.rs/"
"rand>."
msgstr ""
"Arătați studenților documentația generată pentru crăiasa `rand` la [`docs.rs/"
"rand`](https://docs.rs/rand)."

#: src/std-types/option.md
msgid "Option"
msgstr "Opțiune"

#: src/std-types/option.md
#, fuzzy
msgid ""
"We have already seen some use of `Option<T>`. It stores either a value of "
"type `T` or nothing. For example, [`String::find`](https://doc.rust-lang.org/"
"stable/std/string/struct.String.html#method.find) returns an `Option<usize>`."
msgstr ""
"Am văzut deja cum se utilizează `Opțiunea<T>`. Acesta stochează fie o "
"valoare de tip `T`, fie nimic. De exemplu, [`String::find`](https://doc.rust-"
"lang.org/stable/std/string/struct.String.html#method.find) returnează o "
"`Opțiune<usize>`."

#: src/std-types/option.md
#, fuzzy
msgid "\"Löwe 老虎 Léopard Gepardi\""
msgstr "\"Löwe 老虎 Léopard Gepardi\""

#: src/std-types/option.md
#, fuzzy
msgid "'é'"
msgstr "'é'"

#: src/std-types/option.md
#, fuzzy
msgid "\"find returned {position:?}\""
msgstr "\"find returned {position:?}\""

#: src/std-types/option.md
#, fuzzy
msgid "'Z'"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    inspect(&[0, -2, 3]);\n"
"    inspect(&[0, -2, 3, 4]);\n"
"}\n"
"\n"
"#[rustfmt::skip]\n"
"fn inspect(slice: &[i32]) {\n"
"    println!(\"Spune-mi despre {slice:?}\");\n"
"    match slice {\n"
"        &[0, y, z] => println!(\"Primul element 0, y = {y}, și z = {z}\"),\n"
"        &[1, ..]   => println!(\"Primul element este 1 și restul sunt "
"ignorate\"),\n"
"        _          => println!(\"Toate elementele au fost ignorate\"),\n"
"    }\n"
"}\n"
"```"

#: src/std-types/option.md
#, fuzzy
msgid "\"Character not found\""
msgstr "\"Caracterul nu a fost găsit\""

#: src/std-types/option.md
#, fuzzy
msgid "`Option` is widely used, not just in the standard library."
msgstr ""
"`Option` și `Result` sunt utilizate pe scară largă, nu doar în biblioteca "
"standard."

#: src/std-types/option.md
#, fuzzy
msgid ""
"`unwrap` will return the value in an `Option`, or panic. `expect` is similar "
"but takes an error message."
msgstr ""
"`unwrap` va returna valoarea într-un `Option` sau va intra în panică. "
"`expect` este similar, dar primește un mesaj de eroare."

#: src/std-types/option.md
#, fuzzy
msgid ""
"You can panic on None, but you can't \"accidentally\" forget to check for "
"None."
msgstr ""
"Puteți intra în panică la None, dar nu puteți uita \"din greșeală\" să "
"verificați None."

#: src/std-types/option.md
#, fuzzy
msgid ""
"It's common to `unwrap`/`expect` all over the place when hacking something "
"together, but production code typically handles `None` in a nicer fashion."
msgstr ""
"Este obișnuit să se folosească `unwrap`/`expect` peste tot atunci când se "
"lucrează împreună, dar codul de producție tratează de obicei `None` într-un "
"mod mai plăcut."

#: src/std-types/option.md
#, fuzzy
msgid ""
"The niche optimization means that `Option<T>` often has the same size in "
"memory as `T`."
msgstr ""
"Optimizarea nișei înseamnă că `Opțiunea<T>` are adesea aceeași dimensiune în "
"memorie ca `T`."

#: src/std-types/result.md
msgid "Result"
msgstr "Rezultat"

#: src/std-types/result.md
#, fuzzy
msgid ""
"`Result` is similar to `Option`, but indicates the success or failure of an "
"operation, each with a different type. This is similar to the `Res` defined "
"in the expression exercise, but generic: `Result<T, E>` where `T` is used in "
"the `Ok` variant and `E` appears in the `Err` variant."
msgstr ""
"`Result` este similar cu `Option`, dar indică succesul sau eșecul unei "
"operații, fiecare cu un tip diferit. Acesta este similar cu `Res` definit în "
"exercițiul de exprimare, dar generic: `Result<T, E>` unde `T` este folosit "
"în varianta `Ok` și `E` apare în varianta `Err`."

#: src/std-types/result.md
#, fuzzy
msgid "\"diary.txt\""
msgstr "\"diary.txt\""

#: src/std-types/result.md
#, fuzzy
msgid "\"Dear diary: {contents} ({bytes} bytes)\""
msgstr "\"Dragă jurnalule: {contents} ({bytes} bytes)\""

#: src/std-types/result.md
#, fuzzy
msgid "\"Could not read file content\""
msgstr "\"Nu s-a putut citi conținutul fișierului\""

#: src/std-types/result.md
#, fuzzy
msgid "\"The diary could not be opened: {err}\""
msgstr "\"Jurnalul nu a putut fi deschis: {err}\""

#: src/std-types/result.md
#, fuzzy
msgid ""
"As with `Option`, the successful value sits inside of `Result`, forcing the "
"developer to explicitly extract it. This encourages error checking. In the "
"case where an error should never happen, `unwrap()` or `expect()` can be "
"called, and this is a signal of the developer intent too."
msgstr ""
"Ca și în cazul lui `Option`, valoarea de succes se află în interiorul lui "
"`Result`, obligând dezvoltatorul să o extragă în mod explicit. Acest lucru "
"încurajează verificarea erorilor. În cazul în care o eroare nu ar trebui să "
"apară niciodată, se poate apela la `unwrap()` sau `expect()`, iar acesta "
"este și el un semnal al intenției dezvoltatorului."

#: src/std-types/result.md
#, fuzzy
msgid ""
"`Result` documentation is a recommended read. Not during the course, but it "
"is worth mentioning. It contains a lot of convenience methods and functions "
"that help functional-style programming."
msgstr ""
"documentația `Result` este o lectură recomandată. Nu în timpul cursului, dar "
"merită să fie menționată.  Conține o mulțime de metode și funcții "
"convenabile care ajută la programarea în stil funcțional."

#: src/std-types/result.md
#, fuzzy
msgid ""
"`Result` is the standard type to implement error handling as we will see on "
"Day 4."
msgstr ""
"`Result` este tipul standard pentru a implementa gestionarea erorilor, după "
"cum vom vedea în ziua 3."

#: src/std-types/string.md
msgid "String"
msgstr "Sir"

#: src/std-types/string.md
#, fuzzy
msgid ""
"[`String`](https://doc.rust-lang.org/std/string/struct.String.html) is a "
"growable UTF-8 encoded string:"
msgstr ""
"[`String`](https://doc.rust-lang.org/std/string/struct.String.html) este "
"bufferul standard de șiruri UTF-8, cu alocare în heap, care poate crește:"

#: src/std-types/string.md src/std-traits/read-and-write.md
#: src/memory-management/review.md src/testing/unit-tests.md
#: src/concurrency/threads/scoped.md
#, fuzzy
msgid "\"Hello\""
msgstr "\"hello\""

#: src/std-types/string.md
#, fuzzy
msgid "\"s1: len = {}, capacity = {}\""
msgstr "\"s1: len = {}, capacity = {}\""

#: src/std-types/string.md
msgid "'!'"
msgstr "'!'"

#: src/std-types/string.md
#, fuzzy
msgid "\"s2: len = {}, capacity = {}\""
msgstr "\"s2: len = {}, capacity = {}\""

#: src/std-types/string.md
#, fuzzy
msgid "\"🇨🇭\""
msgstr "\"🇨🇭\""

#: src/std-types/string.md
#, fuzzy
msgid "\"s3: len = {}, number of chars = {}\""
msgstr "\"s3: len = {}, număr de caractere = {}\""

#: src/std-types/string.md
#, fuzzy
msgid ""
"`String` implements [`Deref<Target = str>`](https://doc.rust-lang.org/std/"
"string/struct.String.html#deref-methods-str), which means that you can call "
"all `str` methods on a `String`."
msgstr ""
"`String` implementează [`Deref<Target = str>`](https://doc.rust-lang.org/std/"
"string/struct.String.html#deref-methods-str), ceea ce înseamnă că puteți "
"apela toate metodele `str` pe un `String`."

#: src/std-types/string.md
#, fuzzy
msgid ""
"`String::new` returns a new empty string, use `String::with_capacity` when "
"you know how much data you want to push to the string."
msgstr ""
"`String::new` returnează un nou șir de caractere gol, utilizați `String::"
"with_capacity` atunci când știți câte date doriți să introduceți în șir."

#: src/std-types/string.md
#, fuzzy
msgid ""
"`String::len` returns the size of the `String` in bytes (which can be "
"different from its length in characters)."
msgstr ""
"`String::len` returnează dimensiunea șirului `String` în octeți (care poate "
"fi diferită de lungimea sa în caractere)."

#: src/std-types/string.md
#, fuzzy
msgid ""
"`String::chars` returns an iterator over the actual characters. Note that a "
"`char` can be different from what a human will consider a \"character\" due "
"to [grapheme clusters](https://docs.rs/unicode-segmentation/latest/"
"unicode_segmentation/struct.Graphemes.html)."
msgstr ""
"`String::chars` returnează un iterator peste caracterele actuale. Rețineți "
"că un `char` poate fi diferit de ceea ce un om va considera un \"caracter\" "
"din cauza [grapheme clusters](https://docs.rs/unicode-segmentation/latest/"
"unicode_segmentation/struct.Graphemes.html)."

#: src/std-types/string.md
#, fuzzy
msgid ""
"When people refer to strings they could either be talking about `&str` or "
"`String`."
msgstr ""
"Atunci când oamenii se referă la șiruri de caractere, ei pot vorbi fie "
"despre `&str`, fie despre `String`."

#: src/std-types/string.md
#, fuzzy
msgid ""
"When a type implements `Deref<Target = T>`, the compiler will let you "
"transparently call methods from `T`."
msgstr ""
"Atunci când un tip implementează `Deref<Target = T>`, compilatorul vă va "
"permite să apelați în mod transparent metodele din `T`."

#: src/std-types/string.md
#, fuzzy
msgid ""
"We haven't discussed the `Deref` trait yet, so at this point this mostly "
"explains the structure of the sidebar in the documentation."
msgstr ""
"Nu am discutat încă despre trăsătura `Deref`, așa că, în acest moment, acest "
"lucru explică în mare parte structura barei laterale din documentație."

#: src/std-types/string.md
#, fuzzy
msgid ""
"`String` implements `Deref<Target = str>` which transparently gives it "
"access to `str`'s methods."
msgstr ""
"`String` implementează `Deref<Target = str>`, ceea ce îi oferă în mod "
"transparent acces la metodele lui `str`."

#: src/std-types/string.md
#, fuzzy
msgid "Write and compare `let s3 = s1.deref();` and `let s3 = &*s1;`."
msgstr "Scrieți și comparați `let s3 = s1.deref();` și `let s3 = &*s1;`."

#: src/std-types/string.md
#, fuzzy
msgid ""
"`String` is implemented as a wrapper around a vector of bytes, many of the "
"operations you see supported on vectors are also supported on `String`, but "
"with some extra guarantees."
msgstr ""
"`String` este implementat ca un înveliș în jurul unui vector de octeți, "
"multe dintre operațiile pe care le vedeți acceptate pentru vectori sunt "
"acceptate și pentru `String`, dar cu unele garanții suplimentare."

#: src/std-types/string.md
#, fuzzy
msgid "Compare the different ways to index a `String`:"
msgstr "Comparați diferitele moduri de a indexa un `String`:"

#: src/std-types/string.md
#, fuzzy
msgid ""
"To a character by using `s3.chars().nth(i).unwrap()` where `i` is in-bound, "
"out-of-bounds."
msgstr ""
"La un caracter prin utilizarea `s3.chars().nth(i).unwrap()` unde `i` este în "
"interiorul limitelor, în afara limitelor."

#: src/std-types/string.md
#, fuzzy
msgid ""
"To a substring by using `s3[0..4]`, where that slice is on character "
"boundaries or not."
msgstr ""
"La o subșiră folosind `s3[0..4]`, unde acea felie se află sau nu la limitele "
"caracterelor."

#: src/std-types/string.md
#, fuzzy
msgid ""
"Many types can be converted to a string with the [`to_string`](https://doc."
"rust-lang.org/std/string/trait.ToString.html#tymethod.to_string) method. "
"This trait is automatically implemented for all types that implement "
"`Display`, so anything that can be formatted can also be converted to a "
"string."
msgstr ""
"Multe tipuri pot fi convertite într-un șir de caractere cu ajutorul metodei "
"[`to_string`](https://doc.rust-lang.org/std/string/trait.ToString."
"html#tymethod.to_string). Această trăsătură este implementată automat pentru "
"toate tipurile care implementează `Display`, astfel încât orice poate fi "
"formatat poate fi, de asemenea, convertit într-un șir de caractere."

#: src/std-types/vec.md
#, fuzzy
msgid ""
"[`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html) is the standard "
"resizable heap-allocated buffer:"
msgstr ""
"[`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html) este un buffer "
"standard redimensionabil alocat pe heap:"

#: src/std-types/vec.md
#, fuzzy
msgid "\"v1: len = {}, capacity = {}\""
msgstr "\"v1: len = {}, capacity = {}\""

#: src/std-types/vec.md
#, fuzzy
msgid "\"v2: len = {}, capacity = {}\""
msgstr "\"v2: len = {}, capacity = {}\""

#: src/std-types/vec.md
#, fuzzy
msgid "// Canonical macro to initialize a vector with elements.\n"
msgstr "// Macro canonic pentru a inițializa un vector cu elemente.\n"

#: src/std-types/vec.md
#, fuzzy
msgid "// Retain only the even elements.\n"
msgstr "// Reține doar elementele pare.\n"

#: src/std-types/vec.md
#, fuzzy
msgid "\"{v3:?}\""
msgstr "\"{v3:?}\""

#: src/std-types/vec.md
#, fuzzy
msgid "// Remove consecutive duplicates.\n"
msgstr "// Eliminați duplicatele consecutive.\n"

#: src/std-types/vec.md
#, fuzzy
msgid ""
"`Vec` implements [`Deref<Target = [T]>`](https://doc.rust-lang.org/std/vec/"
"struct.Vec.html#deref-methods-%5BT%5D), which means that you can call slice "
"methods on a `Vec`."
msgstr ""
"`Vec` implementează [`Deref<Target = [T]>`]](https://doc.rust-lang.org/std/"
"vec/struct.Vec.html#deref-methods-%5BT%5D), ceea ce înseamnă că puteți apela "
"metode de feliere pe un `Vec`."

#: src/std-types/vec.md
#, fuzzy
msgid ""
"`Vec` is a type of collection, along with `String` and `HashMap`. The data "
"it contains is stored on the heap. This means the amount of data doesn't "
"need to be known at compile time. It can grow or shrink at runtime."
msgstr ""
"`Vec` este un tip de colecție, alături de `String` și `HashMap`. Datele pe "
"care le conține sunt stocate în heap. Acest lucru înseamnă că nu este "
"necesar să se cunoască cantitatea de date în momentul compilării. Aceasta "
"poate crește sau se poate micșora în timpul execuției."

#: src/std-types/vec.md
#, fuzzy
msgid ""
"Notice how `Vec<T>` is a generic type too, but you don't have to specify `T` "
"explicitly. As always with Rust type inference, the `T` was established "
"during the first `push` call."
msgstr ""
"Observați cum `Vec<T>` este și el un tip generic, dar nu trebuie să "
"specificați `T` în mod explicit. Ca întotdeauna în cazul inferenței de tip "
"Rust, `T` a fost stabilit în timpul primului apel `push`."

#: src/std-types/vec.md
#, fuzzy
msgid ""
"`vec![...]` is a canonical macro to use instead of `Vec::new()` and it "
"supports adding initial elements to the vector."
msgstr ""
"`vec![...]` este o macro canonică care poate fi utilizată în locul lui `Vec::"
"new()` și permite adăugarea de elemente inițiale în vector."

#: src/std-types/vec.md
#, fuzzy
msgid ""
"To index the vector you use `[` `]`, but they will panic if out of bounds. "
"Alternatively, using `get` will return an `Option`. The `pop` function will "
"remove the last element."
msgstr ""
"Pentru a indexa vectorul se folosește `[` ` `]` `, dar se va crea panică "
"dacă este în afara limitelor. Alternativ, folosind `get` se va returna un "
"`Option`. Funcția `pop` va elimina ultimul element."

#: src/std-types/vec.md
#, fuzzy
msgid ""
"Slices are covered on day 3. For now, students only need to know that a "
"value of type `Vec` gives access to all of the documented slice methods, too."
msgstr ""
"Feliile sunt acoperite în ziua 3. Deocamdată, studenții trebuie doar să știe "
"că o valoare de tip `Vec` oferă acces la toate metodele de feliere "
"documentate."

#: src/std-types/hashmap.md
#, fuzzy
msgid "Standard hash map with protection against HashDoS attacks:"
msgstr "Hartă hash standard cu protecție împotriva atacurilor HashDoS:"

#: src/std-types/hashmap.md
#, fuzzy
msgid "\"Adventures of Huckleberry Finn\""
msgstr "\"Aventurile lui Huckleberry Finn\""

#: src/std-types/hashmap.md
#, fuzzy
msgid "\"Grimms' Fairy Tales\""
msgstr "\"Basmele lui Grimms\""

#: src/std-types/hashmap.md
#, fuzzy
msgid "\"Pride and Prejudice\""
msgstr "\"Mândrie și Prejudecată\""

#: src/std-types/hashmap.md
#, fuzzy
msgid "\"Les Misérables\""
msgstr "\"Les Misérables\""

#: src/std-types/hashmap.md
#, fuzzy
msgid "\"We know about {} books, but not Les Misérables.\""
msgstr "\"Știm despre {} cărți, dar nu și despre Les Misérables.\""

#: src/std-types/hashmap.md
#, fuzzy
msgid "\"Alice's Adventure in Wonderland\""
msgstr "\"Aventura lui Alice în Țara Minunilor\""

#: src/std-types/hashmap.md
#, fuzzy
msgid "\"{book}: {count} pages\""
msgstr "\"{book}: {count} pagini\""

#: src/std-types/hashmap.md
#, fuzzy
msgid "\"{book} is unknown.\""
msgstr "\"{book} este necunoscut.\""

#: src/std-types/hashmap.md
#, fuzzy
msgid "// Use the .entry() method to insert a value if nothing is found.\n"
msgstr ""
"// Utilizați metoda .entry() pentru a introduce o valoare dacă nu se găsește "
"nimic.\n"

#: src/std-types/hashmap.md
#, fuzzy
msgid "\"{page_counts:#?}\""
msgstr "\"{page_counts:#?}\""

#: src/std-types/hashmap.md
#, fuzzy
msgid ""
"`HashMap` is not defined in the prelude and needs to be brought into scope."
msgstr ""
"`HashMap` nu este definit în preludiu și trebuie să fie adus în domeniul de "
"aplicare."

#: src/std-types/hashmap.md
#, fuzzy
msgid ""
"Try the following lines of code. The first line will see if a book is in the "
"hashmap and if not return an alternative value. The second line will insert "
"the alternative value in the hashmap if the book is not found."
msgstr ""
"Încercați următoarele linii de cod. Prima linie va verifica dacă o carte se "
"află în hashmap și, în caz contrar, va returna o valoare alternativă. A doua "
"linie va introduce valoarea alternativă în hashmap dacă nu se găsește cartea."

#: src/std-types/hashmap.md
#, fuzzy
msgid "\"Harry Potter and the Sorcerer's Stone\""
msgstr "\"Harry Potter și Piatra Vrăjitoarelor\""

#: src/std-types/hashmap.md
#, fuzzy
msgid "\"The Hunger Games\""
msgstr "\"Jocurile foamei\""

#: src/std-types/hashmap.md
#, fuzzy
msgid "Unlike `vec!`, there is unfortunately no standard `hashmap!` macro."
msgstr ""
"Spre deosebire de `vec!`, din păcate nu există o macro standard `hashmap!`."

#: src/std-types/hashmap.md
#, fuzzy
msgid ""
"Although, since Rust 1.56, HashMap implements [`From<[(K, V); N]>`](https://"
"doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#impl-"
"From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E), which allows "
"us to easily initialize a hash map from a literal array:"
msgstr ""
"Cu toate că, începând cu Rust 1.56, HashMap implementează [`From<[(K, V); "
"N]>`]](https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap."
"html#impl-From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E), "
"ceea ce ne permite să inițializăm cu ușurință o hartă hash dintr-o matrice "
"literală:"

#: src/std-types/hashmap.md
#, fuzzy
msgid ""
"Alternatively HashMap can be built from any `Iterator` which yields key-"
"value tuples."
msgstr ""
"Alternativ, HashMap poate fi construit din orice `Iterator` care produce "
"tupluri cheie-valoare."

#: src/std-types/hashmap.md
#, fuzzy
msgid ""
"We are showing `HashMap<String, i32>`, and avoid using `&str` as key to make "
"examples easier. Using references in collections can, of course, be done, "
"but it can lead into complications with the borrow checker."
msgstr ""
"Prezentăm `HashMap<String, i32>` și evităm să folosim `&str` ca cheie pentru "
"a face exemplele mai ușoare. Folosirea referințelor în colecții se poate "
"face, desigur, dar poate duce la complicații cu verificatorul de împrumuturi."

#: src/std-types/hashmap.md
#, fuzzy
msgid ""
"Try removing `to_string()` from the example above and see if it still "
"compiles. Where do you think we might run into issues?"
msgstr ""
"Încercați să eliminați `to_string()` din exemplul de mai sus și vedeți dacă "
"se compilează în continuare. Unde credeți că am putea întâmpina probleme?"

#: src/std-types/hashmap.md
#, fuzzy
msgid ""
"This type has several \"method-specific\" return types, such as `std::"
"collections::hash_map::Keys`. These types often appear in searches of the "
"Rust docs. Show students the docs for this type, and the helpful link back "
"to the `keys` method."
msgstr ""
"Acest tip are mai multe tipuri de returnare \"specifice metodei\", cum ar fi "
"`std::collections::hash_map::Keys`. Aceste tipuri apar adesea în căutările "
"din documentele Rust. Arătați studenților documentația pentru acest tip și "
"legătura utilă către metoda `keys`."

#: src/std-types/exercise.md
#, fuzzy
msgid ""
"In this exercise you will take a very simple data structure and make it "
"generic. It uses a [`std::collections::HashMap`](https://doc.rust-lang.org/"
"stable/std/collections/struct.HashMap.html) to keep track of which values "
"have been seen and how many times each one has appeared."
msgstr ""
"În acest exercițiu veți lua o structură de date foarte simplă și o veți face "
"generică. Aceasta utilizează un [`std::collections::HashMap`](https://doc."
"rust-lang.org/stable/std/collections/struct.HashMap.html) pentru a ține "
"evidența valorilor care au fost văzute și de câte ori a apărut fiecare "
"dintre ele."

#: src/std-types/exercise.md
#, fuzzy
msgid ""
"The initial version of `Counter` is hard coded to only work for `u32` "
"values. Make the struct and its methods generic over the type of value being "
"tracked, that way `Counter` can track any type of value."
msgstr ""
"Versiunea inițială a lui `Counter` este codificată în mod greșit pentru a "
"funcționa numai pentru valori `u32`. Faceți ca structura și metodele sale să "
"fie generice pentru tipul de valoare urmărit, astfel încât `Counter` să "
"poată urmări orice tip de valoare."

#: src/std-types/exercise.md
#, fuzzy
msgid ""
"If you finish early, try using the [`entry`](https://doc.rust-lang.org/"
"stable/std/collections/struct.HashMap.html#method.entry) method to halve the "
"number of hash lookups required to implement the `count` method."
msgstr ""
"Dacă terminați mai devreme, încercați să folosiți metoda [`entry`](https://"
"doc.rust-lang.org/stable/std/collections/struct.HashMap.html#method.entry) "
"pentru a reduce la jumătate numărul de căutări hash necesare pentru a "
"implementa metoda `count`."

#: src/std-types/exercise.md src/std-types/solution.md
#, fuzzy
msgid ""
"/// Counter counts the number of times each value of type T has been seen.\n"
msgstr ""
"/// Contorul numără numărul de ori de câte ori a fost văzută fiecare valoare "
"de tip T.\n"

#: src/std-types/exercise.md src/std-types/solution.md
#, fuzzy
msgid "/// Create a new Counter.\n"
msgstr "/// Creați un nou contor.\n"

#: src/std-types/exercise.md src/std-types/solution.md
#, fuzzy
msgid "/// Count an occurrence of the given value.\n"
msgstr "/// Numără o apariție a valorii date.\n"

#: src/std-types/exercise.md src/std-types/solution.md
#, fuzzy
msgid "/// Return the number of times the given value has been seen.\n"
msgstr "/// Întoarce numărul de ori în care valoarea dată a fost văzută.\n"

#: src/std-types/exercise.md src/std-types/solution.md
#, fuzzy
msgid "\"saw {} values equal to {}\""
msgstr "\"a văzut {} valori egale cu {}\""

#: src/std-types/exercise.md src/std-types/solution.md
#, fuzzy
msgid "\"apple\""
msgstr "\"măr\""

#: src/std-types/exercise.md src/std-types/solution.md
#, fuzzy
msgid "\"orange\""
msgstr "\"portocaliu\""

#: src/std-types/exercise.md src/std-types/solution.md
#, fuzzy
msgid "\"got {} apples\""
msgstr "\"am primit {} mere\""

#: src/std-traits.md
#, fuzzy
msgid "[Comparisons](./std-traits/comparisons.md) (10 minutes)"
msgstr "[Comparații](./std-traits/comparisons.md) (10 minute)"

#: src/std-traits.md
#, fuzzy
msgid "[Operators](./std-traits/operators.md) (10 minutes)"
msgstr "[Operatori](./std-traits/operators.md) (10 minute)"

#: src/std-traits.md
#, fuzzy
msgid "[From and Into](./std-traits/from-and-into.md) (10 minutes)"
msgstr "[De la și în](./std-traits/from-and-into.md) (10 minute)"

#: src/std-traits.md
#, fuzzy
msgid "[Casting](./std-traits/casting.md) (5 minutes)"
msgstr "[Casting](./std-traits/casting.md) (5 minute)"

#: src/std-traits.md
#, fuzzy
msgid "[Read and Write](./std-traits/read-and-write.md) (10 minutes)"
msgstr "[Citire și scriere](./std-traits/read-and-write.md) (10 minute)"

#: src/std-traits.md
#, fuzzy
msgid "[Default, struct update syntax](./std-traits/default.md) (5 minutes)"
msgstr ""
"[Default, sintaxa de actualizare a structurii](./std-traits/default.md) (5 "
"minute)"

#: src/std-traits.md
#, fuzzy
msgid "[Closures](./std-traits/closures.md) (20 minutes)"
msgstr "[Închideri](./std-traits/closures.md) (20 minute)"

#: src/std-traits.md
#, fuzzy
msgid "[Exercise: ROT13](./std-traits/exercise.md) (30 minutes)"
msgstr "[Exercițiu: ROT13](./std-traits/exercise.md) (30 minute)"

#: src/std-traits.md
#, fuzzy
msgid "This segment should take about 1 hour and 40 minutes"
msgstr "Acest segment ar trebui să dureze aproximativ 1 oră și 40 de minute"

#: src/std-traits.md
#, fuzzy
msgid ""
"As with the standard-library types, spend time reviewing the documentation "
"for each trait."
msgstr ""
"Ca și în cazul tipurilor de bibliotecă standard, petreceți timp examinând "
"documentația pentru fiecare trăsătură."

#: src/std-traits.md
#, fuzzy
msgid "This section is long. Take a break midway through."
msgstr "Această secțiune este lungă. Luați o pauză la jumătatea drumului."

#: src/std-traits/comparisons.md
#, fuzzy
msgid ""
"These traits support comparisons between values. All traits can be derived "
"for types containing fields that implement these traits."
msgstr ""
"Aceste trăsături sprijină comparațiile între valori. Toate trăsăturile pot "
"fi derivate pentru tipurile care conțin câmpuri care implementează aceste "
"trăsături."

#: src/std-traits/comparisons.md
#, fuzzy
msgid "`PartialEq` and `Eq`"
msgstr "`ParțialEq` și `Eq`"

#: src/std-traits/comparisons.md
#, fuzzy
msgid ""
"`PartialEq` is a partial equivalence relation, with required method `eq` and "
"provided method `ne`. The `==` and `!=` operators will call these methods."
msgstr ""
"`PartialEq` este o relație de echivalență parțială, cu metoda obligatorie "
"`eq` și metoda furnizată `ne`. Operatorii `==` și `!=` vor apela aceste "
"metode."

#: src/std-traits/comparisons.md
#, fuzzy
msgid ""
"`Eq` is a full equivalence relation (reflexive, symmetric, and transitive) "
"and implies `PartialEq`. Functions that require full equivalence will use "
"`Eq` as a trait bound."
msgstr ""
"`Eq` este o relație de echivalență completă (reflexivă, simetrică și "
"tranzitivă) și implică `ParțialEq`. Funcțiile care necesită o echivalență "
"completă vor utiliza `Eq` ca o legătură de trăsătură."

#: src/std-traits/comparisons.md
#, fuzzy
msgid "`PartialOrd` and `Ord`"
msgstr "`Read` și `Write`"

#: src/std-traits/comparisons.md
#, fuzzy
msgid ""
"`PartialOrd` defines a partial ordering, with a `partial_cmp` method. It is "
"used to implement the `<`, `<=`, `>=`, and `>` operators."
msgstr ""
"`PartialOrd` definește o ordine parțială, cu o metodă `partial_cmp`. Este "
"utilizat pentru a implementa operatorii `<`, `<=`, `>=` și `>`."

#: src/std-traits/comparisons.md
#, fuzzy
msgid "`Ord` is a total ordering, with `cmp` returning `Ordering`."
msgstr "`Ord` este o ordine totală, cu `cmp` returnând `Ordering`."

#: src/std-traits/comparisons.md
#, fuzzy
msgid ""
"`PartialEq` can be implemented between different types, but `Eq` cannot, "
"because it is reflexive:"
msgstr ""
"`PartialEq` poate fi implementat între tipuri diferite, dar `Eq` nu poate fi "
"implementat, deoarece este reflexiv:"

#: src/std-traits/comparisons.md
#, fuzzy
msgid ""
"In practice, it's common to derive these traits, but uncommon to implement "
"them."
msgstr ""
"În practică, aceste trăsături sunt des întâlnite, dar implementarea lor este "
"mai puțin obișnuită."

#: src/std-traits/operators.md
#, fuzzy
msgid ""
"Operator overloading is implemented via traits in [`std::ops`](https://doc."
"rust-lang.org/std/ops/index.html):"
msgstr ""
"Supraîncărcarea operatorilor este implementată prin intermediul trăsăturilor "
"în [`std::ops`](https://doc.rust-lang.org/std/ops/index.html):"

#: src/std-traits/operators.md
#, fuzzy
msgid "\"{:?} + {:?} = {:?}\""
msgstr "\"{:?} + {:?} = {:?}\""

#: src/std-traits/operators.md src/memory-management/drop.md
#, fuzzy
msgid "Discussion points:"
msgstr "Puncte de discuție:"

#: src/std-traits/operators.md
#, fuzzy
msgid ""
"You could implement `Add` for `&Point`. In which situations is that useful?"
msgstr "Ați putea implementa `Add` pentru `&Point`. În ce situații este utilă?"

#: src/std-traits/operators.md
#, fuzzy
msgid ""
"Answer: `Add:add` consumes `self`. If type `T` for which you are overloading "
"the operator is not `Copy`, you should consider overloading the operator for "
"`&T` as well. This avoids unnecessary cloning on the call site."
msgstr ""
"Răspuns: `Add:add` consumă `self`. Dacă tipul `T` pentru care supraîncărcați "
"operatorul nu este `Copy`, ar trebui să luați în considerare supraîncărcarea "
"operatorului și pentru `&T`. Astfel se evită clonarea inutilă pe locul de "
"apel."

#: src/std-traits/operators.md
#, fuzzy
msgid ""
"Why is `Output` an associated type? Could it be made a type parameter of the "
"method?"
msgstr ""
"De ce este `Output` un tip asociat? Ar putea fi transformat într-un "
"parametru de tip al metodei?"

#: src/std-traits/operators.md
#, fuzzy
msgid ""
"Short answer: Function type parameters are controlled by the caller, but "
"associated types (like `Output`) are controlled by the implementer of a "
"trait."
msgstr ""
"Răspuns scurt: Parametrii de tip funcție sunt controlați de către apelant, "
"dar tipurile asociate (cum ar fi `Output`) sunt controlate de către "
"implementatorul unei trăsături."

#: src/std-traits/operators.md
#, fuzzy
msgid ""
"You could implement `Add` for two different types, e.g. `impl Add<(i32, "
"i32)> for Point` would add a tuple to a `Point`."
msgstr ""
"Ați putea implementa `Add` pentru două tipuri diferite, de exemplu, `impl "
"Add<(i32, i32)> pentru Point` ar adăuga un tuple la un `Point`."

#: src/std-traits/from-and-into.md
#, fuzzy
msgid ""
"Types implement [`From`](https://doc.rust-lang.org/std/convert/trait.From."
"html) and [`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) to "
"facilitate type conversions:"
msgstr ""
"Tipurile implementează [`From`](https://doc.rust-lang.org/std/convert/trait."
"From.html) și [`Into`](https://doc.rust-lang.org/std/convert/trait.Into."
"html) pentru a facilita conversiile de tip:"

#: src/std-traits/from-and-into.md
#, fuzzy
msgid "\"{s}, {addr}, {one}, {bigger}\""
msgstr "\"{s}, {addr}, {one}, {bigger}\""

#: src/std-traits/from-and-into.md
#, fuzzy
msgid ""
"[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) is "
"automatically implemented when [`From`](https://doc.rust-lang.org/std/"
"convert/trait.From.html) is implemented:"
msgstr ""
"[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) este "
"implementat automat atunci când este implementat [`From`](https://doc.rust-"
"lang.org/std/convert/trait.From.html):"

#: src/std-traits/from-and-into.md
#, fuzzy
msgid ""
"That's why it is common to only implement `From`, as your type will get "
"`Into` implementation too."
msgstr ""
"De aceea, este obișnuit să se implementeze doar `From`, deoarece tipul tău "
"va primi și implementarea `Into`."

#: src/std-traits/from-and-into.md
#, fuzzy
msgid ""
"When declaring a function argument input type like \"anything that can be "
"converted into a `String`\", the rule is opposite, you should use `Into`. "
"Your function will accept types that implement `From` and those that _only_ "
"implement `Into`."
msgstr ""
"Atunci când declarați un tip de intrare de argument de funcție de tipul "
"\"orice poate fi convertit într-un `String`\", regula este opusă, trebuie să "
"utilizați `Into`. Funcția dvs. va accepta tipurile care implementează `From` "
"și cele care implementează _doar_ `Into`."

#: src/std-traits/casting.md
#, fuzzy
msgid ""
"Rust has no _implicit_ type conversions, but does support explicit casts "
"with `as`. These generally follow C semantics where those are defined."
msgstr ""
"Rust nu dispune de conversii de tip _implicite_, dar suportă transformări "
"explicite cu `as`. În general, acestea urmează semantica C, acolo unde sunt "
"definite."

#: src/std-traits/casting.md
#, fuzzy
msgid "\"as u16: {}\""
msgstr "\"as u16: {}\""

#: src/std-traits/casting.md
#, fuzzy
msgid "\"as i16: {}\""
msgstr ""
"Biblioteca standard are o implementare a `From<i8> pentru i16`, ceea ce "
"înseamnă că putem converti o variabilă `x` de tip `i8` în `i16` prin "
"apelarea `i16::from(x)`. Sau, mai simplu, cu `x.into()`, deoarece "
"implementarea `From<i8> for i16` creează automat o implementare a `Into<i16> "
"for i8`."

#: src/std-traits/casting.md
#, fuzzy
msgid "\"as u8: {}\""
msgstr "Șirurile de octeți vă permit să creați direct o valoare `&[u8]`:"

#: src/std-traits/casting.md
#, fuzzy
msgid ""
"The results of `as` are _always_ defined in Rust and consistent across "
"platforms. This might not match your intuition for changing sign or casting "
"to a smaller type -- check the docs, and comment for clarity."
msgstr ""
"Rezultatele lui `as` sunt _întotdeauna_ definite în Rust și sunt consecvente "
"pe toate platformele. Este posibil ca acest lucru să nu se potrivească cu "
"intuiția dvs. de a schimba semnul sau de a face casting la un tip mai mic - "
"verificați documentele și comentați pentru claritate."

#: src/std-traits/casting.md
#, fuzzy
msgid ""
"Casting with `as` is a relatively sharp tool that is easy to use "
"incorrectly, and can be a source of subtle bugs as future maintenance work "
"changes the types that are used or the ranges of values in types. Casts are "
"best used only when the intent is to indicate unconditional truncation (e.g. "
"selecting the bottom 32 bits of a `u64` with `as u32`, regardless of what "
"was in the high bits)."
msgstr ""
"Casting-ul cu `as` este un instrument relativ ascuțit, ușor de utilizat în "
"mod incorect și poate fi o sursă de erori subtile pe măsură ce viitoarele "
"lucrări de întreținere modifică tipurile utilizate sau intervalele de valori "
"din tipuri. Castingurile se utilizează cel mai bine numai atunci când "
"intenția este de a indica o trunchiere necondiționată (de exemplu, "
"selectarea celor 32 de biți inferiori ai unui `u64` cu `as u32`, indiferent "
"de ceea ce se afla în biții superiori)."

#: src/std-traits/casting.md
#, fuzzy
msgid ""
"For infallible casts (e.g. `u32` to `u64`), prefer using `From` or `Into` "
"over `as` to confirm that the cast is in fact infallible. For fallible "
"casts, `TryFrom` and `TryInto` are available when you want to handle casts "
"that fit differently from those that don't."
msgstr ""
"În cazul unor distribuții infailibile (de exemplu, de la `u32` la `u64`), se "
"preferă utilizarea lui `From` sau `Into` în locul lui `as` pentru a confirma "
"că distribuția este de fapt infailibilă. Pentru distribuțiile falibile, "
"`TryFrom` și `TryInto` sunt disponibile atunci când doriți să tratați "
"distribuțiile care se potrivesc diferit de cele care nu se potrivesc."

#: src/std-traits/casting.md
#, fuzzy
msgid "Consider taking a break after this slide."
msgstr ""
"Luați în considerare posibilitatea de a lua o pauză după acest diapozitiv."

#: src/std-traits/casting.md
#, fuzzy
msgid ""
"`as` is similar to a C++ static cast. Use of `as` in cases where data might "
"be lost is generally discouraged, or at least deserves an explanatory "
"comment."
msgstr ""
"`as` este similar cu un cast static din C++. Utilizarea lui `as` în cazurile "
"în care datele ar putea fi pierdute este, în general, descurajată sau cel "
"puțin merită un comentariu explicativ."

#: src/std-traits/casting.md
#, fuzzy
msgid "This is common in casting integers to `usize` for use as an index."
msgstr ""
"Acest lucru este obișnuit în cazul în care se transformă numere întregi în "
"`usize` pentru a fi utilizate ca indici."

#: src/std-traits/read-and-write.md
#, fuzzy
msgid ""
"Using [`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) and "
"[`BufRead`](https://doc.rust-lang.org/std/io/trait.BufRead.html), you can "
"abstract over `u8` sources:"
msgstr ""
"Folosind [`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) și "
"[`BufRead`](https://doc.rust-lang.org/std/io/trait.BufRead.html), puteți "
"face abstracție de sursele `u8`:"

#: src/std-traits/read-and-write.md
#, fuzzy
msgid "b\"foo\\nbar\\nbaz\\n\""
msgstr "b \"foo\\nbar\\nbaz\\n\""

#: src/std-traits/read-and-write.md
#, fuzzy
msgid "\"lines in slice: {}\""
msgstr "\"linii în slice: {}\""

#: src/std-traits/read-and-write.md
#, fuzzy
msgid "\"lines in file: {}\""
msgstr "\"linii în fișier: {}\""

#: src/std-traits/read-and-write.md
#, fuzzy
msgid ""
"Similarly, [`Write`](https://doc.rust-lang.org/std/io/trait.Write.html) lets "
"you abstract over `u8` sinks:"
msgstr ""
"În mod similar, [`Write`](https://doc.rust-lang.org/std/io/trait.Write.html) "
"vă permite să faceți abstracție de `u8` sink-uri:"

#: src/std-traits/read-and-write.md
msgid "\"\\n\""
msgstr "\"\\n\""

#: src/std-traits/read-and-write.md
#, fuzzy
msgid "\"Logged: {:?}\""
msgstr "\"Înregistrat: {:?}\""

#: src/std-traits/default.md
#, fuzzy
msgid "The `Default` Trait"
msgstr "Trăsătura `Default` (implicit)"

#: src/std-traits/default.md
#, fuzzy
msgid ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) trait "
"produces a default value for a type."
msgstr ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) "
"caracteristica produce o valoare implicită pentru un tip."

#: src/std-traits/default.md
#, fuzzy
msgid "\"John Smith\""
msgstr "\"John Smith\""

#: src/std-traits/default.md
#, fuzzy
msgid "\"{default_struct:#?}\""
msgstr "'Default' (implicit), sintaxa de actualizare a structurilor"

#: src/std-traits/default.md
#, fuzzy
msgid "\"Y is set!\""
msgstr "\"Y este stabilit!\""

#: src/std-traits/default.md
#, fuzzy
msgid "\"{almost_default_struct:#?}\""
msgstr "\"{almost_default_struct:#?}\""

#: src/std-traits/default.md src/lifetimes/exercise.md
#: src/lifetimes/solution.md
#, fuzzy
msgid "\"{:#?}\""
msgstr "\"{:#?}\""

#: src/std-traits/default.md
#, fuzzy
msgid ""
"It can be implemented directly or it can be derived via `#[derive(Default)]`."
msgstr ""
"Poate fi implementat direct sau poate fi derivat prin `#[derive(Default)]`."

#: src/std-traits/default.md
#, fuzzy
msgid ""
"A derived implementation will produce a value where all fields are set to "
"their default values."
msgstr ""
"O implementare derivată va produce o valoare în care toate câmpurile sunt "
"setate la valorile lor implicite."

#: src/std-traits/default.md
#, fuzzy
msgid "This means all types in the struct must implement `Default` too."
msgstr ""
"Aceasta înseamnă că toate tipurile din structura trebuie să implementeze și "
"`Default`."

#: src/std-traits/default.md
#, fuzzy
msgid ""
"Standard Rust types often implement `Default` with reasonable values (e.g. "
"`0`, `\"\"`, etc)."
msgstr ""
"Tipurile standard Rust implementează adesea `Default` cu valori rezonabile "
"(de exemplu, `0`, `\"\"`, etc.)."

#: src/std-traits/default.md
#, fuzzy
msgid "The partial struct initialization works nicely with default."
msgstr "Copierea parțială a structurii funcționează bine în mod implicit."

#: src/std-traits/default.md
#, fuzzy
msgid ""
"The Rust standard library is aware that types can implement `Default` and "
"provides convenience methods that use it."
msgstr ""
"Biblioteca standard Rust este conștientă de faptul că tipurile pot "
"implementa `Default` și oferă metode de conveniență care îl utilizează."

#: src/std-traits/default.md
#, fuzzy
msgid ""
"The `..` syntax is called [struct update syntax](https://doc.rust-lang.org/"
"book/ch05-01-defining-structs.html#creating-instances-from-other-instances-"
"with-struct-update-syntax)."
msgstr ""
"sintaxa `..` se numește [struct update syntax](https://doc.rust-lang.org/"
"book/ch05-01-defining-structs.html#creating-instances-from-other-instances-"
"with-struct-update-syntax)"

#: src/std-traits/closures.md
#, fuzzy
msgid ""
"Closures or lambda expressions have types which cannot be named. However, "
"they implement special [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn."
"html), [`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), and "
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) traits:"
msgstr ""
"Închiderile sau expresiile lambda au tipuri care nu pot fi numite. Cu toate "
"acestea, ele implementează trăsăturile speciale [`Fn`](https://doc.rust-lang."
"org/std/ops/trait.Fn.html), [`FnMut`](https://doc.rust-lang.org/std/ops/"
"trait.FnMut.html) și [`FnOnce`](https://doc.rust-lang.org/std/ops/trait."
"FnOnce.html):"

#: src/std-traits/closures.md
#, fuzzy
msgid "\"Calling function on {input}\""
msgstr "Apelarea funcțiilor nesigure"

#: src/std-traits/closures.md
#, fuzzy
msgid "\"add_3: {}\""
msgstr "\"add_3: {}\""

#: src/std-traits/closures.md
#, fuzzy
msgid "\"accumulate: {}\""
msgstr "\"acumulează: {}\""

#: src/std-traits/closures.md
#, fuzzy
msgid "\"multiply_sum: {}\""
msgstr "\"multiply_sum: {}\""

#: src/std-traits/closures.md
#, fuzzy
msgid ""
"An `Fn` (e.g. `add_3`) neither consumes nor mutates captured values, or "
"perhaps captures nothing at all. It can be called multiple times "
"concurrently."
msgstr ""
"Un `Fn` (de exemplu, `add_3`) nu consumă și nici nu modifică valorile "
"capturate, sau poate nu captează nimic. Acesta poate fi apelat de mai multe "
"ori simultan."

#: src/std-traits/closures.md
#, fuzzy
msgid ""
"An `FnMut` (e.g. `accumulate`) might mutate captured values. You can call it "
"multiple times, but not concurrently."
msgstr ""
"Un `FnMut` (de exemplu, `accumulate`) poate modifica valorile capturate. Se "
"poate apela de mai multe ori, dar nu concomitent."

#: src/std-traits/closures.md
#, fuzzy
msgid ""
"If you have an `FnOnce` (e.g. `multiply_sum`), you may only call it once. It "
"might consume captured values."
msgstr ""
"Dacă aveți un `FnOnce` (de exemplu, `multiply_sum`), îl puteți apela doar o "
"singură dată. Acesta ar putea consuma valori capturate."

#: src/std-traits/closures.md
#, fuzzy
msgid ""
"`FnMut` is a subtype of `FnOnce`. `Fn` is a subtype of `FnMut` and `FnOnce`. "
"I.e. you can use an `FnMut` wherever an `FnOnce` is called for, and you can "
"use an `Fn` wherever an `FnMut` or `FnOnce` is called for."
msgstr ""
"`FnMut` este un subtip al `FnOnce`. `Fn` este un subtip al lui `FnMut` și "
"`FnOnce`. Adică, puteți utiliza un `FnMut` oriunde se solicită un `FnOnce` "
"și puteți utiliza un `Fn` oriunde se solicită un `FnMut` sau un `FnOnce`."

#: src/std-traits/closures.md
#, fuzzy
msgid ""
"When you define a function that takes a closure, you should take `FnOnce` if "
"you can (i.e. you call it once), or `FnMut` else, and last `Fn`. This allows "
"the most flexibility for the caller."
msgstr ""
"Atunci când definiți o funcție care ia o închidere, ar trebui să luați "
"`FnOnce` dacă puteți (adică să o apelați o singură dată), sau `FnMut` în caz "
"contrar, și în final `Fn`. Acest lucru permite cea mai mare flexibilitate "
"pentru apelant."

#: src/std-traits/closures.md
#, fuzzy
msgid ""
"In contrast, when you have a closure, the most flexible you can have is `Fn` "
"(it can be passed everywhere), then `FnMut`, and lastly `FnOnce`."
msgstr ""
"În schimb, atunci când aveți o închidere, cea mai flexibilă este `Fn` (poate "
"fi trecută peste tot), apoi `FnMut` și, în cele din urmă, `FnOnce`."

#: src/std-traits/closures.md
#, fuzzy
msgid ""
"The compiler also infers `Copy` (e.g. for `add_3`) and `Clone` (e.g. "
"`multiply_sum`), depending on what the closure captures."
msgstr ""
"Compilatorul deduce, de asemenea, `Copy` (de exemplu, pentru `add_3`) și "
"`Clone` (de exemplu, `multiply_sum`), în funcție de ceea ce captează "
"închiderea."

#: src/std-traits/closures.md
#, fuzzy
msgid ""
"By default, closures will capture by reference if they can. The `move` "
"keyword makes them capture by value."
msgstr ""
"În mod implicit, închiderile vor captura prin referință dacă pot. Cuvântul "
"cheie `move` le face să captureze prin valoare."

#: src/std-traits/closures.md src/smart-pointers/trait-objects.md
#, fuzzy
msgid "\"{} {}\""
msgstr "\"{} {}\""

#: src/std-traits/closures.md
#, fuzzy
msgid "\"Hi\""
msgstr "\"Bună\""

#: src/std-traits/closures.md
#, fuzzy
msgid "\"Greg\""
msgstr "\"Salutări\""

#: src/std-traits/exercise.md
#, fuzzy
msgid ""
"In this example, you will implement the classic [\"ROT13\" cipher](https://"
"en.wikipedia.org/wiki/ROT13). Copy this code to the playground, and "
"implement the missing bits. Only rotate ASCII alphabetic characters, to "
"ensure the result is still valid UTF-8."
msgstr ""
"În acest exemplu, veți implementa cifra clasică [\"ROT13\"](https://en."
"wikipedia.org/wiki/ROT13). Copiați acest cod pe terenul de joacă și "
"implementați biții lipsă. Rotiți numai caracterele alfabetice ASCII, pentru "
"a vă asigura că rezultatul este încă valid UTF-8."

#: src/std-traits/exercise.md
#, fuzzy
msgid "// Implement the `Read` trait for `RotDecoder`.\n"
msgstr "// Implementați caracteristica `Read` pentru `RotDecoder`.\n"

#: src/std-traits/exercise.md src/std-traits/solution.md
#, fuzzy
msgid "\"Gb trg gb gur bgure fvqr!\""
msgstr "\"Gb trg gb gb gur bgure fvqr!\""

#: src/std-traits/exercise.md src/std-traits/solution.md
#, fuzzy
msgid "\"To get to the other side!\""
msgstr "\"Pentru a ajunge pe partea cealaltă!\""

#: src/std-traits/exercise.md
#, fuzzy
msgid ""
"What happens if you chain two `RotDecoder` instances together, each rotating "
"by 13 characters?"
msgstr ""
"Ce se întâmplă dacă înlănțuiți două instanțe `RotDecoder` împreună, fiecare "
"rotindu-se cu 13 caractere?"

#: src/std-traits/solution.md
#, fuzzy
msgid "'A'"
msgstr "'A'"

#: src/welcome-day-3.md
#, fuzzy
msgid "Welcome to Day 3"
msgstr "Bine ați venit în ziua 3"

#: src/welcome-day-3.md
#, fuzzy
msgid "Today, we will cover:"
msgstr "Astăzi, vom aborda:"

#: src/welcome-day-3.md
#, fuzzy
msgid ""
"Memory management, lifetimes, and the borrow checker: how Rust ensures "
"memory safety."
msgstr ""
"Gestionarea memoriei, durata de viață și verificatorul de împrumuturi: cum "
"asigură Rust siguranța memoriei."

#: src/welcome-day-3.md
#, fuzzy
msgid "Smart pointers: standard library pointer types."
msgstr "Indicatori inteligenți: tipuri de pointeri din biblioteca standard."

#: src/welcome-day-3.md
#, fuzzy
msgid "[Welcome](./welcome-day-3.md) (3 minutes)"
msgstr "[Introducere](../welcome-day-3.md) (3 minute)"

#: src/welcome-day-3.md
#, fuzzy
msgid "[Memory Management](./memory-management.md) (1 hour)"
msgstr "[Managementul memoriei](../memory-management.md) (1 oră și 10 minute)"

#: src/welcome-day-3.md
#, fuzzy
msgid "[Smart Pointers](./smart-pointers.md) (55 minutes)"
msgstr "[Pointeri inteligenți](../smart-pointers.md) (45 minute)"

#: src/welcome-day-3.md
#, fuzzy
msgid ""
"Including 10 minute breaks, this session should take about 2 hours and 20 "
"minutes"
msgstr ""
"Incluzând pauzele de 10 minute, această sesiune ar trebui să dureze "
"aproximativ 2 ore și 20 de minute"

#: src/memory-management.md
#, fuzzy
msgid "[Review of Program Memory](./memory-management/review.md) (5 minutes)"
msgstr ""
"[Revizuirea memoriei programului](./memory-management/review.md) (5 minute)"

#: src/memory-management.md
#, fuzzy
msgid ""
"[Approaches to Memory Management](./memory-management/approaches.md) (10 "
"minutes)"
msgstr ""
"[Abordări ale managementului memoriei](./memory-management/approaches.md) "
"(10 minute)"

#: src/memory-management.md
#, fuzzy
msgid "[Ownership](./memory-management/ownership.md) (5 minutes)"
msgstr "[Proprietate](./memory-management/ownership.md) (5 minute)"

#: src/memory-management.md
#, fuzzy
msgid "[Move Semantics](./memory-management/move.md) (5 minutes)"
msgstr "[Semantica mutării](./memory-management/move.md) (10 minute)"

#: src/memory-management.md
#, fuzzy
msgid "[Clone](./memory-management/clone.md) (2 minutes)"
msgstr "[Clone](./memory-management/clone.md) (2 minute)"

#: src/memory-management.md
#, fuzzy
msgid "[Copy Types](./memory-management/copy-types.md) (5 minutes)"
msgstr "[Tipuri de copiere](./memory-management/copy-types.md) (5 minute)"

#: src/memory-management.md
#, fuzzy
msgid "[Drop](./memory-management/drop.md) (10 minutes)"
msgstr "[Drop](./memory-management/drop.md) (10 minute)"

#: src/memory-management.md
#, fuzzy
msgid "[Exercise: Builder Type](./memory-management/exercise.md) (20 minutes)"
msgstr ""
"[Exercițiu: Tipul de constructor](./memory-management/exercise.md) (20 "
"minute)"

#: src/memory-management/review.md
#, fuzzy
msgid "Programs allocate memory in two ways:"
msgstr "Programele alocă memoria în două moduri:"

#: src/memory-management/review.md
msgid "Stack: Continuous area of memory for local variables."
msgstr "Stiva: zona continuă de memorie pentru variabilele locale."

#: src/memory-management/review.md
msgid "Values have fixed sizes known at compile time."
msgstr "Valorile au dimensiuni fixe cunoscute în momentul compilării."

#: src/memory-management/review.md
msgid "Extremely fast: just move a stack pointer."
msgstr "Extrem de rapid: este suficient să mutați un pointer la stivă."

#: src/memory-management/review.md
msgid "Easy to manage: follows function calls."
msgstr "Ușor de gestionat: urmărește apelurile de funcții."

#: src/memory-management/review.md
msgid "Great memory locality."
msgstr "Poziționate bună a memoriei."

#: src/memory-management/review.md
msgid "Heap: Storage of values outside of function calls."
msgstr "Heap: stocarea valorilor în afara apelurilor de funcții."

#: src/memory-management/review.md
msgid "Values have dynamic sizes determined at runtime."
msgstr "Valorile au dimensiuni dinamice determinate la momentul execuției."

#: src/memory-management/review.md
msgid "Slightly slower than the stack: some book-keeping needed."
msgstr "Puțin mai lent decât stiva: este nevoie de o anumită contabilitate."

#: src/memory-management/review.md
#, fuzzy
msgid "No guarantee of memory locality."
msgstr "Nu există nicio garanție a poziționării memoriei."

#: src/memory-management/review.md
msgid ""
"Creating a `String` puts fixed-sized metadata on the stack and dynamically "
"sized data, the actual string, on the heap:"
msgstr ""
"Crearea unui `String` plasează metadatele de dimensiuni fixe pe stivă și "
"datele de dimensiuni dinamice, șirul propriu-zis, pe heap:"

#: src/memory-management/review.md
msgid ""
"Mention that a `String` is backed by a `Vec`, so it has a capacity and "
"length and can grow if mutable via reallocation on the heap."
msgstr ""
"Menționați că un `String` este susținut de un `Vec`, deci are o capacitate "
"și o lungime și poate crește dacă este mutabil prin realocare pe heap."

#: src/memory-management/review.md
msgid ""
"If students ask about it, you can mention that the underlying memory is heap "
"allocated using the [System Allocator](https://doc.rust-lang.org/std/alloc/"
"struct.System.html) and custom allocators can be implemented using the "
"[Allocator API](https://doc.rust-lang.org/std/alloc/index.html)"
msgstr ""
"Dacă cursanții vă întreabă despre acest lucru, puteți menționa că memoria de "
"bază este alocată în heap cu ajutorul [System Allocator](https://doc.rust-"
"lang.org/std/alloc/struct.System.html) și că alocatorii personalizați pot fi "
"implementați cu ajutorul [Allocator API](https://doc.rust-lang.org/std/alloc/"
"index.html)"

#: src/memory-management/review.md
msgid ""
"We can inspect the memory layout with `unsafe` Rust. However, you should "
"point out that this is rightfully unsafe!"
msgstr ""
"Putem inspecta dispunerea memoriei cu `unsafe` Rust. Cu toate acestea, ar "
"trebui să precizați că acest lucru este, pe bună dreptate, nesigur!"

#: src/memory-management/review.md src/testing/unit-tests.md
msgid "' '"
msgstr "' '"

#: src/memory-management/review.md
#, fuzzy
msgid "\"world\""
msgstr "\"lume\""

#: src/memory-management/review.md
#, fuzzy
msgid ""
"// DON'T DO THIS AT HOME! For educational purposes only.\n"
"    // String provides no guarantees about its layout, so this could lead "
"to\n"
"    // undefined behavior.\n"
msgstr ""
"// NU FACEȚI ASTA ACASĂ! Doar în scopuri educaționale.\n"
"    // Șirul de caractere nu oferă nicio garanție cu privire la aspectul "
"său, astfel încât acest lucru ar putea duce la\n"
"    // comportament nedefinit.\n"

#: src/memory-management/review.md
#, fuzzy
msgid "\"capacity = {capacity}, ptr = {ptr:#x}, len = {len}\""
msgstr "\"capacity = {capacity}, ptr = {ptr:#x}, len = {len}\""

#: src/memory-management/approaches.md
msgid "Traditionally, languages have fallen into two broad categories:"
msgstr "În mod tradițional, limbajele se împart în două mari categorii:"

#: src/memory-management/approaches.md
msgid "Full control via manual memory management: C, C++, Pascal, ..."
msgstr "Control total prin gestionarea manuală a memoriei: C, C++, Pascal, ..."

#: src/memory-management/approaches.md
#, fuzzy
msgid "Programmer decides when to allocate or free heap memory."
msgstr "Programatorul decide când să aloce sau să elibereze memoria heap."

#: src/memory-management/approaches.md
#, fuzzy
msgid ""
"Programmer must determine whether a pointer still points to valid memory."
msgstr ""
"Programatorul trebuie să determine dacă un pointer mai indică o memorie "
"validă."

#: src/memory-management/approaches.md
#, fuzzy
msgid "Studies show, programmers make mistakes."
msgstr "Studiile arată că programatorii fac greșeli."

#: src/memory-management/approaches.md
msgid ""
"Full safety via automatic memory management at runtime: Java, Python, Go, "
"Haskell, ..."
msgstr ""
"Siguranță totală prin gestionarea automată a memoriei în timpul execuției: "
"Java, Python, Go, Haskell, ..."

#: src/memory-management/approaches.md
#, fuzzy
msgid ""
"A runtime system ensures that memory is not freed until it can no longer be "
"referenced."
msgstr ""
"Un sistem de execuție se asigură că memoria nu este eliberată până când nu "
"mai poate fi utilizată ca referință."

#: src/memory-management/approaches.md
#, fuzzy
msgid ""
"Typically implemented with reference counting, garbage collection, or RAII."
msgstr ""
"De obicei, se implementează cu numărarea referințelor, colectarea gunoiului "
"sau RAII."

#: src/memory-management/approaches.md
msgid "Rust offers a new mix:"
msgstr "Rust oferă un nouă abordare:"

#: src/memory-management/approaches.md
msgid ""
"Full control _and_ safety via compile time enforcement of correct memory "
"management."
msgstr ""
"Control total _și_ siguranță prin aplicarea în timpul compilării a "
"gestionării corecte a memoriei."

#: src/memory-management/approaches.md
msgid "It does this with an explicit ownership concept."
msgstr ""
"Acest lucru se realizează cu ajutorul unui concept explicit de posesie."

#: src/memory-management/approaches.md
#, fuzzy
msgid ""
"This slide is intended to help students coming from other languages to put "
"Rust in context."
msgstr ""
"Această diapozitivă este menită să-i ajute pe studenții care vin din alte "
"limbi să pună Rust în context."

#: src/memory-management/approaches.md
#, fuzzy
msgid ""
"C must manage heap manually with `malloc` and `free`. Common errors include "
"forgetting to call `free`, calling it multiple times for the same pointer, "
"or dereferencing a pointer after the memory it points to has been freed."
msgstr ""
"C trebuie să gestioneze manual heap cu `malloc` și `free`. Printre erorile "
"frecvente se numără uitarea apelării lui `free`, apelarea de mai multe ori "
"pentru același pointer sau dereferențierea unui pointer după ce memoria la "
"care acesta indică a fost eliberată."

#: src/memory-management/approaches.md
#, fuzzy
msgid ""
"C++ has tools like smart pointers (`unique_ptr`, `shared_ptr`) that take "
"advantage of language guarantees about calling destructors to ensure memory "
"is freed when a function returns. It is still quite easy to mis-use these "
"tools and create similar bugs to C."
msgstr ""
"C++ dispune de instrumente precum pointeri inteligenți (`unique_ptr`, "
"`shared_ptr`) care profită de garanțiile limbajului privind apelarea "
"destructoriilor pentru a se asigura că memoria este eliberată atunci când o "
"funcție se întoarce. Este încă destul de ușor să se utilizeze în mod greșit "
"aceste instrumente și să se creeze erori similare cu cele din C."

#: src/memory-management/approaches.md
#, fuzzy
msgid ""
"Java, Go, and Python rely on the garbage collector to identify memory that "
"is no longer reachable and discard it. This guarantees that any pointer can "
"be dereferenced, eliminating use-after-free and other classes of bugs. But, "
"GC has a runtime cost and is difficult to tune properly."
msgstr ""
"Java, Go și Python se bazează pe colectorul de gunoi pentru a identifica "
"memoria care nu mai este accesibilă și pentru a o elimina. Acest lucru "
"garantează faptul că orice pointer poate fi dereferențiat, eliminând astfel "
"utilizarea după liber și alte clase de erori. Însă, GC are un cost în timpul "
"execuției și este dificil de reglat corespunzător."

#: src/memory-management/approaches.md
#, fuzzy
msgid ""
"Rust's ownership and borrowing model can, in many cases, get the performance "
"of C, with alloc and free operations precisely where they are required -- "
"zero cost. It also provides tools similar to C++'s smart pointers. When "
"required, other options such as reference counting are available, and there "
"are even third-party crates available to support runtime garbage collection "
"(not covered in this class)."
msgstr ""
"Modelul de proprietate și împrumut al Rust poate, în multe cazuri, să obțină "
"performanța lui C, cu alocări și operațiuni gratuite exact acolo unde sunt "
"necesare - cost zero. De asemenea, acesta oferă instrumente similare cu "
"indicatoarele inteligente din C++. Atunci când este necesar, sunt "
"disponibile și alte opțiuni, cum ar fi numărarea referințelor, și există "
"chiar și cratere de la terți disponibile pentru a sprijini colectarea "
"gunoiului în timpul execuției (nu sunt acoperite în acest curs)."

#: src/memory-management/ownership.md
#, fuzzy
msgid ""
"All variable bindings have a _scope_ where they are valid and it is an error "
"to use a variable outside its scope:"
msgstr ""
"Toate legăturile de variabile au un _scop_ în care sunt valabile și este o "
"eroare să folosești o variabilă în afara domeniului său de aplicare:"

#: src/memory-management/ownership.md
#, fuzzy
msgid ""
"We say that the variable _owns_ the value. Every Rust value has precisely "
"one owner at all times."
msgstr "Spunem că variabila _deține_ valoarea."

#: src/memory-management/ownership.md
#, fuzzy
msgid ""
"At the end of the scope, the variable is _dropped_ and the data is freed. A "
"destructor can run here to free up resources."
msgstr ""
"La sfârșitul domeniului de aplicare, variabila este \"eliminată\", iar "
"datele sunt eliberate."

#: src/memory-management/ownership.md
#, fuzzy
msgid ""
"Students familiar with garbage-collection implementations will know that a "
"garbage collector starts with a set of \"roots\" to find all reachable "
"memory. Rust's \"single owner\" principle is a similar idea."
msgstr ""
"Studenții familiarizați cu implementările de colectare a gunoiului știu că "
"un colector de gunoi începe cu un set de \"rădăcini\" pentru a găsi toată "
"memoria accesibilă. Principiul \"proprietarului unic\" din Rust este o idee "
"similară."

#: src/memory-management/move.md
msgid "An assignment will transfer _ownership_ between variables:"
msgstr "O atribuire va transfera _posesia_ între variabile:"

#: src/memory-management/move.md
#, fuzzy
msgid "\"Hello!\""
msgstr "\"hello\""

#: src/memory-management/move.md
#, fuzzy
msgid "// println!(\"s1: {s1}\");\n"
msgstr "// println!(\"s1: {s1}\");\n"

#: src/memory-management/move.md
msgid "The assignment of `s1` to `s2` transfers ownership."
msgstr "Atribuirea lui `s1` la `s2` transferă posesiunea."

#: src/memory-management/move.md
msgid "When `s1` goes out of scope, nothing happens: it does not own anything."
msgstr ""
"Când `s1` iese din domeniul de aplicare, nu se întâmplă nimic: nu posedă "
"nimic."

#: src/memory-management/move.md
msgid "When `s2` goes out of scope, the string data is freed."
msgstr ""
"Atunci când `s2` iese din domeniul de aplicare, datele șirului de caractere "
"sunt eliberate."

#: src/memory-management/move.md
msgid "Before move to `s2`:"
msgstr "Înainte de mutarea în `s2`:"

#: src/memory-management/move.md
msgid "After move to `s2`:"
msgstr "După mutarea în `s2`:"

#: src/memory-management/move.md
#, fuzzy
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - -.\n"
":                           :     :                                     :\n"
":    s1 \"(inaccessible)\"    :     :                                     :\n"
":   +-----------+-------+   :     :   +----+----+----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| H  | e  | l  | l  | o  | !  |   :\n"
":   | len       |     6 |   :  |  :   +----+----+----+----+----+----+   :\n"
":   | capacity  |     6 |   :  |  :                                     :\n"
":   +-----------+-------+   :  |  :                                     :\n"
":                           :  |  `- - - - - - - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     6 |   :\n"
":   | capacity  |     6 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stiva                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"(inaccesibl)\"    :     :                           :\n"
":   +—————+———+   :     :   +——+——+——+——+   :\n"
":   | ptr       |   o—+—+—+—+—>| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :  |  :   +——+——+——+——+   :\n"
":   | capacity  |     4 |   :  |  :                           :\n"
":   +—————+———+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +—————+———+   :  |\n"
":   | ptr       |   o—+—+—'\n"
":   | len       |     4 |   :\n"
":   | capacity  |     4 |   :\n"
":   +—————+———+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/memory-management/move.md
msgid ""
"When you pass a value to a function, the value is assigned to the function "
"parameter. This transfers ownership:"
msgstr ""
"Atunci când transmiteți o valoare unei funcții, valoarea este atribuită "
"parametrului funcției. Acest lucru transferă posesia:"

#: src/memory-management/move.md src/memory-management/clone.md
#, fuzzy
msgid "\"Hello {name}\""
msgstr "\"Bună ziua {name}\""

#: src/memory-management/move.md src/memory-management/clone.md
#: src/android/interoperability/java.md
#, fuzzy
msgid "\"Alice\""
msgstr "Felii"

#: src/memory-management/move.md
#, fuzzy
msgid "// say_hello(name);\n"
msgstr "// say_hello(name);\n"

#: src/memory-management/move.md
msgid ""
"Mention that this is the opposite of the defaults in C++, which copies by "
"value unless you use `std::move` (and the move constructor is defined!)."
msgstr ""
"Menționați că acest lucru este opusul valorilor implicite din C++, care "
"copiază prin valoare, cu excepția cazului în care folosiți `std::move` (și "
"constructorul move este definit!)."

#: src/memory-management/move.md
msgid ""
"It is only the ownership that moves. Whether any machine code is generated "
"to manipulate the data itself is a matter of optimization, and such copies "
"are aggressively optimized away."
msgstr ""
"Doar posesia este cea care se schimbă. Generarea codului mașină pentru a "
"manipula datele în sine este o chestiune de optimizare, iar astfel de copii "
"sunt optimizate în mod agresiv."

#: src/memory-management/move.md
msgid ""
"Simple values (such as integers) can be marked `Copy` (see later slides)."
msgstr ""
"Valorile simple (cum ar fi numerele întregi) pot fi marcate cu `Copy` (a se "
"vedea slide-urile ulterioare)."

#: src/memory-management/move.md
msgid "In Rust, clones are explicit (by using `clone`)."
msgstr "În Rust, clonele sunt explicite (prin utilizarea lui `clone`)."

#: src/memory-management/move.md
#, fuzzy
msgid "In the `say_hello` example:"
msgstr "În exemplul `say_hello`:"

#: src/memory-management/move.md
msgid ""
"With the first call to `say_hello`, `main` gives up ownership of `name`. "
"Afterwards, `name` cannot be used anymore within `main`."
msgstr ""
"Odată cu primul apel la `say_hello`, `main` nu mai deține `name` și, "
"ulterior, nu îl mai poate utiliza."

#: src/memory-management/move.md
msgid ""
"The heap memory allocated for `name` will be freed at the end of the "
"`say_hello` function."
msgstr ""
"Memoria heap alocată pentru `name` va fi eliberată la sfârșitul funcției "
"`say_hello`."

#: src/memory-management/move.md
#, fuzzy
msgid ""
"`main` can retain ownership if it passes `name` as a reference (`&name`) and "
"if `say_hello` accepts a reference as a parameter."
msgstr ""
"`main` poate păstra proprietatea dacă transmite `name` ca referință "
"(`&name`) și dacă `say_hello` acceptă o referință ca parametru."

#: src/memory-management/move.md
#, fuzzy
msgid ""
"Alternatively, `main` can pass a clone of `name` in the first call (`name."
"clone()`)."
msgstr ""
"Alternativ, `main` poate transmite o clonă a lui `name` la primul apel "
"(`name.clone()`)."

#: src/memory-management/move.md
#, fuzzy
msgid ""
"Rust makes it harder than C++ to inadvertently create copies by making move "
"semantics the default, and by forcing programmers to make clones explicit."
msgstr ""
"Rust face mai dificilă decât C++ crearea de copii din greșeală, făcând ca "
"semantica de mutare să fie cea implicită și obligând programatorii să facă "
"clonele explicite."

#: src/memory-management/move.md
msgid "Defensive Copies in Modern C++"
msgstr "Copii defensive în C++ modern"

#: src/memory-management/move.md
msgid "Modern C++ solves this differently:"
msgstr "C++ modern rezolvă acest lucru în mod diferit:"

#: src/memory-management/move.md
#, fuzzy
msgid "\"Cpp\""
msgstr "\"Cpp\""

#: src/memory-management/move.md
#, fuzzy
msgid "// Duplicate the data in s1.\n"
msgstr "// Duplicarea datelor din s1.\n"

#: src/memory-management/move.md
msgid ""
"The heap data from `s1` is duplicated and `s2` gets its own independent copy."
msgstr ""
"Datele din heap de la `s1` sunt duplicate, iar `s2` primește propria copie "
"independentă."

#: src/memory-management/move.md
msgid "When `s1` and `s2` go out of scope, they each free their own memory."
msgstr ""
"Atunci când `s1` și `s2` ies din domeniul de aplicare, fiecare își "
"eliberează propria memorie."

#: src/memory-management/move.md
#, fuzzy
msgid "Before copy-assignment:"
msgstr "Înainte de atribuirea copiilor:"

#: src/memory-management/move.md
#, fuzzy
msgid "After copy-assignment:"
msgstr "După atribuirea copiilor:"

#: src/memory-management/move.md
msgid ""
"C++ has made a slightly different choice than Rust. Because `=` copies data, "
"the string data has to be cloned. Otherwise we would get a double-free when "
"either string goes out of scope."
msgstr ""
"În C++ a fost făcută o alegere ușor diferită față de Rust. Deoarece `=` "
"copiază date, datele șirului de caractere trebuie clonate. În caz contrar, "
"am obține o dublă eliberare atunci când oricare dintre șiruri iese din "
"domeniu."

#: src/memory-management/move.md
msgid ""
"C++ also has [`std::move`](https://en.cppreference.com/w/cpp/utility/move), "
"which is used to indicate when a value may be moved from. If the example had "
"been `s2 = std::move(s1)`, no heap allocation would take place. After the "
"move, `s1` would be in a valid but unspecified state. Unlike Rust, the "
"programmer is allowed to keep using `s1`."
msgstr ""
"C++ are, de asemenea, [`std::move`](https://en.cppreference.com/w/cpp/"
"utility/move), care este utilizat pentru a indica când o valoare poate fi "
"mutată. Dacă exemplul ar fi fost `s2 = std::move(s1)`, nu ar fi avut loc "
"nicio alocare de heap. După mutare, `s1` ar fi într-o stare validă, dar "
"nespecificată. Spre deosebire de Rust, programatorului i se permite să "
"continue să folosească `s1`."

#: src/memory-management/move.md
msgid ""
"Unlike Rust, `=` in C++ can run arbitrary code as determined by the type "
"which is being copied or moved."
msgstr ""
"Spre deosebire de Rust, `=` în C++ poate rula cod arbitrar în funcție de "
"tipul care este copiat sau mutat."

#: src/memory-management/clone.md
msgid "Clone"
msgstr "Clonare"

#: src/memory-management/clone.md
#, fuzzy
msgid ""
"Sometimes you _want_ to make a copy of a value. The `Clone` trait "
"accomplishes this."
msgstr ""
"Uneori, doriți să faceți o copie a unei valori. Caracteristica `Clone` "
"realizează acest lucru."

#: src/memory-management/clone.md
#, fuzzy
msgid ""
"The idea of `Clone` is to make it easy to spot where heap allocations are "
"occurring. Look for `.clone()` and a few others like `vec!` or `Box::new`."
msgstr ""
"Ideea lui `Clone` este de a face mai ușor de observat unde au loc alocări de "
"heap. Căutați `.clone()` și alte câteva ca `Vec::new` sau `Box::new`."

#: src/memory-management/clone.md
#, fuzzy
msgid ""
"It's common to \"clone your way out\" of problems with the borrow checker, "
"and return later to try to optimize those clones away."
msgstr ""
"Este obișnuit să \"clonezi\" problemele cu verificatorul de împrumuturi și "
"să revii mai târziu pentru a încerca să optimizezi acele clone."

#: src/memory-management/clone.md
#, fuzzy
msgid ""
"`clone` generally performs a deep copy of the value, meaning that if you e."
"g. clone an array, all of the elements of the array are cloned as well."
msgstr ""
"`clone` efectuează în general o copie profundă a valorii, ceea ce înseamnă "
"că, dacă, de exemplu, clonezi un array, toate elementele array-ului sunt "
"clonate și ele."

#: src/memory-management/clone.md
#, fuzzy
msgid ""
"The behavior for `clone` is user-defined, so it can perform custom cloning "
"logic if needed."
msgstr ""
"Comportamentul pentru `clone` este definit de utilizator, astfel încât "
"acesta poate efectua o logică de clonare personalizată, dacă este necesar."

#: src/memory-management/copy-types.md
#, fuzzy
msgid ""
"While move semantics are the default, certain types are copied by default:"
msgstr ""
"În timp ce semantica de mutare este cea implicită, anumite tipuri sunt "
"copiate în mod implicit:"

#: src/memory-management/copy-types.md
#, fuzzy
msgid "These types implement the `Copy` trait."
msgstr "Aceste tipuri implementează trăsătura `Copy`."

#: src/memory-management/copy-types.md
#, fuzzy
msgid "You can opt-in your own types to use copy semantics:"
msgstr ""
"Puteți opta pentru ca propriile tipuri să utilizeze semantica de copiere:"

#: src/memory-management/copy-types.md
#, fuzzy
msgid "After the assignment, both `p1` and `p2` own their own data."
msgstr "După atribuire, atât `p1` cât și `p2` dețin propriile date."

#: src/memory-management/copy-types.md
#, fuzzy
msgid "We can also use `p1.clone()` to explicitly copy the data."
msgstr "De asemenea, putem folosi `p1.clone()` pentru a copia explicit datele."

#: src/memory-management/copy-types.md
#, fuzzy
msgid "Copying and cloning are not the same thing:"
msgstr "Copierea și clonarea nu sunt același lucru:"

#: src/memory-management/copy-types.md
#, fuzzy
msgid ""
"Copying refers to bitwise copies of memory regions and does not work on "
"arbitrary objects."
msgstr ""
"Copierea se referă la copiile pe biți ale regiunilor de memorie și nu "
"funcționează pe obiecte arbitrare."

#: src/memory-management/copy-types.md
#, fuzzy
msgid ""
"Copying does not allow for custom logic (unlike copy constructors in C++)."
msgstr ""
"Copierea nu permite o logică personalizată (spre deosebire de constructorii "
"de copiere din C++)."

#: src/memory-management/copy-types.md
#, fuzzy
msgid ""
"Cloning is a more general operation and also allows for custom behavior by "
"implementing the `Clone` trait."
msgstr ""
"Clonarea este o operațiune mai generală și permite, de asemenea, un "
"comportament personalizat prin implementarea trăsăturii `Clone`."

#: src/memory-management/copy-types.md
#, fuzzy
msgid "Copying does not work on types that implement the `Drop` trait."
msgstr ""
"Copierea nu funcționează pe tipurile care implementează trăsătura `Drop`."

#: src/memory-management/copy-types.md
#, fuzzy
msgid "In the above example, try the following:"
msgstr "În exemplul de mai sus, încercați următoarele:"

#: src/memory-management/copy-types.md
#, fuzzy
msgid ""
"Add a `String` field to `struct Point`. It will not compile because `String` "
"is not a `Copy` type."
msgstr ""
"Adăugați un câmp `String` la `struct Point`. Nu se va compila deoarece "
"`String` nu este un tip `Copy`."

#: src/memory-management/copy-types.md
#, fuzzy
msgid ""
"Remove `Copy` from the `derive` attribute. The compiler error is now in the "
"`println!` for `p1`."
msgstr ""
"Elimină `Copy` din atributul `derive`. Eroarea de compilare se află acum în "
"`println!` pentru `p1`."

#: src/memory-management/copy-types.md
#, fuzzy
msgid "Show that it works if you clone `p1` instead."
msgstr "Arătați că funcționează dacă clonați `p1` în locul lui."

#: src/memory-management/drop.md
#, fuzzy
msgid "The `Drop` Trait"
msgstr "Trăsătura `Drop` (cădere)"

#: src/memory-management/drop.md
#, fuzzy
msgid ""
"Values which implement [`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop."
"html) can specify code to run when they go out of scope:"
msgstr ""
"Valorile care implementează [`Drop`](https://doc.rust-lang.org/std/ops/trait."
"Drop.html) pot specifica codul care trebuie executat atunci când ies din "
"domeniul de aplicare:"

#: src/memory-management/drop.md
#, fuzzy
msgid "\"Dropping {}\""
msgstr "\"Dropping {}\""

#: src/memory-management/drop.md src/concurrency/sync-exercises/link-checker.md
#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "\"a\""
msgstr "\"a\""

#: src/memory-management/drop.md src/android/testing/googletest.md
#, fuzzy
msgid "\"b\""
msgstr "\"b\""

#: src/memory-management/drop.md
#, fuzzy
msgid "\"c\""
msgstr "\"c\""

#: src/memory-management/drop.md
#, fuzzy
msgid "\"d\""
msgstr "'d'"

#: src/memory-management/drop.md
#, fuzzy
msgid "\"Exiting block B\""
msgstr "\"Ieșirea din blocul B\""

#: src/memory-management/drop.md
#, fuzzy
msgid "\"Exiting block A\""
msgstr "\"Ieșirea din blocul A\""

#: src/memory-management/drop.md
#, fuzzy
msgid "\"Exiting main\""
msgstr "\"Ieșire principală\""

#: src/memory-management/drop.md
#, fuzzy
msgid "Note that `std::mem::drop` is not the same as `std::ops::Drop::drop`."
msgstr ""
"Rețineți că `std::mem::drop` nu este același lucru cu `std::ops::Drop::drop`."

#: src/memory-management/drop.md
#, fuzzy
msgid "Values are automatically dropped when they go out of scope."
msgstr ""
"Valorile sunt eliminate automat atunci când ies din domeniul de aplicare."

#: src/memory-management/drop.md
#, fuzzy
msgid ""
"When a value is dropped, if it implements `std::ops::Drop` then its `Drop::"
"drop` implementation will be called."
msgstr ""
"Atunci când o valoare este eliminată, dacă implementează `std::ops::Drop`, "
"atunci va fi apelată implementarea `Drop::drop` a acesteia."

#: src/memory-management/drop.md
#, fuzzy
msgid ""
"All its fields will then be dropped too, whether or not it implements `Drop`."
msgstr ""
"Toate câmpurile sale vor fi apoi eliminate, indiferent dacă implementează "
"sau nu `Drop`."

#: src/memory-management/drop.md
#, fuzzy
msgid ""
"`std::mem::drop` is just an empty function that takes any value. The "
"significance is that it takes ownership of the value, so at the end of its "
"scope it gets dropped. This makes it a convenient way to explicitly drop "
"values earlier than they would otherwise go out of scope."
msgstr ""
"`std::mem::drop` este doar o funcție goală care acceptă orice valoare. "
"Semnificația este că preia proprietatea asupra valorii, astfel încât la "
"sfârșitul domeniului său de aplicare aceasta este eliminată. Acest lucru o "
"face o modalitate convenabilă de a renunța în mod explicit la valori mai "
"devreme decât ar fi ieșit altfel din domeniul de aplicare."

#: src/memory-management/drop.md
#, fuzzy
msgid ""
"This can be useful for objects that do some work on `drop`: releasing locks, "
"closing files, etc."
msgstr ""
"Acest lucru poate fi util pentru obiectele care efectuează anumite "
"activități la `drop`: eliberarea de blocaje, închiderea fișierelor etc."

#: src/memory-management/drop.md
#, fuzzy
msgid "Why doesn't `Drop::drop` take `self`?"
msgstr "De ce `Drop::drop` nu ia `self`?"

#: src/memory-management/drop.md
#, fuzzy
msgid ""
"Short-answer: If it did, `std::mem::drop` would be called at the end of the "
"block, resulting in another call to `Drop::drop`, and a stack overflow!"
msgstr ""
"Răspuns scurt: Dacă ar fi făcut-o, `std::mem::drop` ar fi fost apelat la "
"sfârșitul blocului, rezultând un alt apel la `Drop::drop` și o depășire a "
"stivei!"

#: src/memory-management/drop.md
#, fuzzy
msgid "Try replacing `drop(a)` with `a.drop()`."
msgstr "Încercați să înlocuiți `drop(a)` cu `a.drop()`."

#: src/memory-management/exercise.md
#, fuzzy
msgid ""
"In this example, we will implement a complex data type that owns all of its "
"data. We will use the \"builder pattern\" to support building a new value "
"piece-by-piece, using convenience functions."
msgstr ""
"În acest exemplu, vom implementa un tip de date complex care deține toate "
"datele sale. Vom utiliza \"modelul de constructor\" pentru a sprijini "
"construirea unei noi valori bucată cu bucată, utilizând funcții de confort."

#: src/memory-management/exercise.md
#, fuzzy
msgid "Fill in the missing pieces."
msgstr "Completați piesele lipsă."

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "/// A representation of a software package.\n"
msgstr "/// O reprezentare a unui pachet software.\n"

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid ""
"/// Return a representation of this package as a dependency, for use in\n"
"    /// building other packages.\n"
msgstr ""
"/// Returnează o reprezentare a acestui pachet ca dependență, pentru a fi "
"utilizată în\n"
"    /// construirea altor pachete.\n"

#: src/memory-management/exercise.md
#, fuzzy
msgid "\"1\""
msgstr "`dbg_size!(bool)`: dimensiune 1 octet, aliniere: 1 octet,"

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid ""
"/// A builder for a Package. Use `build()` to create the `Package` itself.\n"
msgstr ""
"/// Un constructor pentru un pachet. Utilizați `build()` pentru a crea "
"`Pachet` însuși.\n"

#: src/memory-management/exercise.md
#, fuzzy
msgid "\"2\""
msgstr ""
"Același lucru este valabil și pentru ultimul indice, astfel încât `&a[2..a."
"len()]` și `&a[2..]` sunt identice."

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "/// Set the package version.\n"
msgstr "/// Setează versiunea pachetului.\n"

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "/// Set the package authors.\n"
msgstr "/// Setează autorii pachetului.\n"

#: src/memory-management/exercise.md
#, fuzzy
msgid "\"3\""
msgstr "Codificați ambele funcții pentru a opera pe matrici 3 × 3."

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "/// Add an additional dependency.\n"
msgstr "/// Adăugați o dependență suplimentară.\n"

#: src/memory-management/exercise.md
#, fuzzy
msgid "\"4\""
msgstr "\"4\""

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "/// Set the language. If not set, language defaults to None.\n"
msgstr "/// Setați limba. Dacă nu este setată, limba este implicită la None.\n"

#: src/memory-management/exercise.md
#, fuzzy
msgid "\"5\""
msgstr "[Introducere](./welcome-day-1.md) (5 minute)"

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "\"base64\""
msgstr "\"base64\""

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "\"0.13\""
msgstr "\"0.13\""

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "\"base64: {base64:?}\""
msgstr "\"base64: {base64:?}\""

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "\"log\""
msgstr "\"log\""

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "\"0.4\""
msgstr "\"0.4\""

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "\"log: {log:?}\""
msgstr "\"log: {log:?}\""

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "\"serde\""
msgstr "\"serde\""

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "\"djmitche\""
msgstr "\"djmitche\""

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "\"4.0\""
msgstr "\"4.0\""

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "\"serde: {serde:?}\""
msgstr "\"serde: {serde:?}\""

#: src/memory-management/solution.md
#, fuzzy
msgid "\"0.1\""
msgstr "\"0.1\""

#: src/smart-pointers.md
#, fuzzy
msgid "[Box"
msgstr "Cutie (box)"

#: src/smart-pointers.md
#, fuzzy
msgid "](./smart-pointers/box.md) (10 minutes)"
msgstr "](./smart-pointers/box.md) (10 minute)"

#: src/smart-pointers.md
#, fuzzy
msgid "[Rc](./smart-pointers/rc.md) (5 minutes)"
msgstr "[Rc](./smart-pointers/rc.md) (5 minute)"

#: src/smart-pointers.md
#, fuzzy
msgid "[Trait Objects](./smart-pointers/trait-objects.md) (10 minutes)"
msgstr ""
"[Obiecte de trăsături](./methods-and-traits/trait-objects.md) (10 minute)"

#: src/smart-pointers.md
#, fuzzy
msgid "[Exercise: Binary Tree](./smart-pointers/exercise.md) (30 minutes)"
msgstr "[Exercițiu: Arbore binar](./smart-pointers/exercise.md) (30 minute)"

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"[`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) is an owned "
"pointer to data on the heap:"
msgstr ""
"[`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) este un pointer "
"deținut către datele de pe heap:"

#: src/smart-pointers/box.md
#, fuzzy
msgid "\"five: {}\""
msgstr "\"cinci: {}\""

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"`Box<T>` implements `Deref<Target = T>`, which means that you can [call "
"methods from `T` directly on a `Box<T>`](https://doc.rust-lang.org/std/ops/"
"trait.Deref.html#more-on-deref-coercion)."
msgstr ""
"`Box<T>` implementează `Deref<Target = T>`, ceea ce înseamnă că puteți "
"[apela metode din `T` direct pe un `Box<T>`](https://doc.rust-lang.org/std/"
"ops/trait.Deref.html#more-on-deref-coercion)."

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"Recursive data types or data types with dynamic sizes need to use a `Box`:"
msgstr ""
"Tipurile de date recursive sau tipurile de date cu dimensiuni dinamice "
"trebuie să utilizeze un `Box`:"

#: src/smart-pointers/box.md
#, fuzzy
msgid "/// A non-empty list: first element and the rest of the list.\n"
msgstr "/// O listă nevidă: primul element și restul listei.\n"

#: src/smart-pointers/box.md
#, fuzzy
msgid "/// An empty list.\n"
msgstr "/// O listă goală.\n"

#: src/smart-pointers/box.md
#, fuzzy
msgid "\"{list:?}\""
msgstr ""
"[Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial."
"github.io/too-many-lists/): explorarea în profunzime a regulilor de "
"gestionare a memoriei din Rust, prin implementarea câtorva tipuri diferite "
"de structuri de liste."

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - - - .     .- - - - - - - - - - - - - - - - - - - - "
"- - - - -.\n"
":                            :     :                                                 :\n"
":    "
"list                    :     :                                                 :\n"
":   +---------+----+----+    :     :    +---------+----+----+    +------+----"
"+----+  :\n"
":   | Element | 1  | o--+----+-----+--->| Element | 2  | o--+--->| Nil  | // "
"| // |  :\n"
":   +---------+----+----+    :     :    +---------+----+----+    +------+----"
"+----+  :\n"
":                            :     :                                                 :\n"
":                            :     :                                                 :\n"
"'- - - - - - - - - - - - - - '     '- - - - - - - - - - - - - - - - - - - - "
"- - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stiva Heap\n"
".- - - - - - - - - - - - -. .- - - - - - - - - - - - - - - - - - - - - - - "
"-.\n"
": : : :\n"
": listă : : : :\n"
":   +------+----+----+ : : +------+----+----+ +------+----+----+ :\n"
":   | Cons | 1 | o--+----+-----+--->| Cons | 2 | o--++--->| Nil | // | // // "
"| :\n"
":   +------+----+----+ : : +------+----+----+ +------+----+----+ :\n"
": : : :\n"
": : : :\n"
"'- - - - - - - - - - - - -' '- - - - - - - - - - - - - - - - - - - - - - - "
"-'\n"
"```"

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"`Box` is like `std::unique_ptr` in C++, except that it's guaranteed to be "
"not null."
msgstr ""
"`Box` este ca și `std::unique_ptr` în C++, cu excepția faptului că este "
"garantat a nu fi nul."

#: src/smart-pointers/box.md
#, fuzzy
msgid "A `Box` can be useful when you:"
msgstr "Un `Box` poate fi util atunci când:"

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"have a type whose size that can't be known at compile time, but the Rust "
"compiler wants to know an exact size."
msgstr ""
"au un tip a cărui dimensiune nu poate fi cunoscută la compilare, dar "
"compilatorul Rust dorește să știe o dimensiune exactă."

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"want to transfer ownership of a large amount of data. To avoid copying large "
"amounts of data on the stack, instead store the data on the heap in a `Box` "
"so only the pointer is moved."
msgstr ""
"doriți să transferați proprietatea asupra unei cantități mari de date. "
"Pentru a evita copierea unor cantități mari de date pe stivă, stocați în "
"schimb datele pe heap într-un `Box`, astfel încât să fie mutat doar "
"pointerul."

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"If `Box` was not used and we attempted to embed a `List` directly into the "
"`List`, the compiler would not be able to compute a fixed size for the "
"struct in memory (the `List` would be of infinite size)."
msgstr ""
"Dacă nu se folosea `Box` și încercam să încorporăm o `List` direct în "
"`List`, compilatorul nu ar fi calculat o dimensiune fixă a structurii în "
"memorie (`List` ar fi avut o dimensiune infinită)."

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"`Box` solves this problem as it has the same size as a regular pointer and "
"just points at the next element of the `List` in the heap."
msgstr ""
"`Box` rezolvă această problemă, deoarece are aceeași dimensiune ca un "
"pointer obișnuit și indică doar următorul element din `List` în heap."

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"Remove the `Box` in the List definition and show the compiler error. We get "
"the message \"recursive without indirection\", because for data recursion, "
"we have to use indirection, a `Box` or reference of some kind, instead of "
"storing the value directly."
msgstr ""
"Eliminați `Box` din definiția Listei și afișați eroarea de compilare. "
"\"Recursiv cu indirecție\" este un indiciu că poate doriți să folosiți un "
"Box sau o referință de un anumit tip, în loc să stocați direct o valoare."

#: src/smart-pointers/box.md
msgid "Niche Optimization"
msgstr "Optimizari de nișă"

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"Though `Box` looks like `std::unique_ptr` in C++, it cannot be empty/null. "
"This makes `Box` one of the types that allow the compiler to optimize "
"storage of some enums."
msgstr ""
"Deși `Box` seamănă cu `std::unique_ptr` în C++, acesta nu poate fi gol/null. "
"Acest lucru face ca `Box` să fie unul dintre tipurile care permit "
"compilatorului să optimizeze stocarea unor enumerații."

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"For example, `Option<Box<T>>` has the same size, as just `Box<T>`, because "
"compiler uses NULL-value to discriminate variants instead of using explicit "
"tag ([\"Null Pointer Optimization\"](https://doc.rust-lang.org/std/option/"
"#representation)):"
msgstr ""
"De exemplu, `Opțiune&lt;Box<T>&gt;` are aceeași dimensiune ca și `Box<T>`, "
"deoarece compilatorul utilizează valoarea NULL pentru a discrimina "
"variantele în loc să utilizeze o etichetă explicită ([\"Optimizarea "
"pointerului nul\"](https://doc.rust-lang.org/std/option/#representation)):"

#: src/smart-pointers/box.md
#, fuzzy
msgid "\"Just box\""
msgstr "\"Just box\""

#: src/smart-pointers/box.md
#, fuzzy
msgid "\"Optional box\""
msgstr "Opțiune"

#: src/smart-pointers/box.md
#, fuzzy
msgid "\"Size of just_box: {}\""
msgstr "\"Dimensiunea just_box: {}\""

#: src/smart-pointers/box.md
#, fuzzy
msgid "\"Size of optional_box: {}\""
msgstr "\"Dimensiunea cutiei opționale_box: {}\""

#: src/smart-pointers/box.md
#, fuzzy
msgid "\"Size of none: {}\""
msgstr "\"înainte: {a}\""

#: src/smart-pointers/rc.md
#, fuzzy
msgid ""
"[`Rc`](https://doc.rust-lang.org/std/rc/struct.Rc.html) is a reference-"
"counted shared pointer. Use this when you need to refer to the same data "
"from multiple places:"
msgstr ""
"[`Rc`](https://doc.rust-lang.org/std/rc/struct.Rc.html) este un pointer "
"partajat cu numărătoare de referințe. Folosiți-l atunci când trebuie să "
"faceți referire la aceleași date din mai multe locuri:"

#: src/smart-pointers/rc.md
#, fuzzy
msgid "\"a: {a}\""
msgstr "\"a: {a}\""

#: src/smart-pointers/rc.md
#, fuzzy
msgid "\"b: {b}\""
msgstr "\"b: {b}\""

#: src/smart-pointers/rc.md
#, fuzzy
msgid ""
"See [`Arc`](../concurrency/shared_state/arc.md) and [`Mutex`](https://doc."
"rust-lang.org/std/sync/struct.Mutex.html) if you are in a multi-threaded "
"context."
msgstr ""
"Consultați [`Arc`](../concurrency/shared_state/arc.md) și [`Mutex`](https://"
"doc.rust-lang.org/std/sync/struct.Mutex.html) dacă vă aflați într-un context "
"cu mai multe fire."

#: src/smart-pointers/rc.md
#, fuzzy
msgid ""
"You can _downgrade_ a shared pointer into a [`Weak`](https://doc.rust-lang."
"org/std/rc/struct.Weak.html) pointer to create cycles that will get dropped."
msgstr ""
"Puteți transforma un pointer partajat într-un pointer [`Weak`](https://doc."
"rust-lang.org/std/rc/struct.Weak.html) pentru a crea cicluri care vor fi "
"abandonate."

#: src/smart-pointers/rc.md
#, fuzzy
msgid ""
"`Rc`'s count ensures that its contained value is valid for as long as there "
"are references."
msgstr ""
"numărătoarea lui `Rc` asigură că valoarea sa conținută este valabilă atâta "
"timp cât există referințe."

#: src/smart-pointers/rc.md
#, fuzzy
msgid "`Rc` in Rust is like `std::shared_ptr` in C++."
msgstr "`Rc` în Rust este ca `std::shared_ptr` în C++."

#: src/smart-pointers/rc.md
#, fuzzy
msgid ""
"`Rc::clone` is cheap: it creates a pointer to the same allocation and "
"increases the reference count. Does not make a deep clone and can generally "
"be ignored when looking for performance issues in code."
msgstr ""
"`Rc::clone` este ieftin: creează un pointer la aceeași alocare și crește "
"numărul de referințe. Nu realizează o clonă profundă și poate fi în general "
"ignorată atunci când se caută probleme de performanță în cod."

#: src/smart-pointers/rc.md
#, fuzzy
msgid ""
"`make_mut` actually clones the inner value if necessary (\"clone-on-write\") "
"and returns a mutable reference."
msgstr ""
"`make_mut` clonează de fapt valoarea interioară dacă este necesar (\"clone-"
"on-write\") și returnează o referință mutabilă."

#: src/smart-pointers/rc.md
#, fuzzy
msgid "Use `Rc::strong_count` to check the reference count."
msgstr "Utilizați `Rc::strong_count` pentru a verifica numărul de referințe."

#: src/smart-pointers/rc.md
#, fuzzy
msgid ""
"`Rc::downgrade` gives you a _weakly reference-counted_ object to create "
"cycles that will be dropped properly (likely in combination with `RefCell`)."
msgstr ""
"`Rc::downgrade` vă oferă un obiect cu un număr slab de referințe pentru a "
"crea cicluri care vor fi abandonate în mod corespunzător (probabil în "
"combinație cu `RefCell`, pe slide-ul următor)."

#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid ""
"Trait objects allow for values of different types, for instance in a "
"collection:"
msgstr ""
"Obiectele de trăsături permit valori de diferite tipuri, de exemplu într-o "
"colecție:"

#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid "\"Miau!\""
msgstr "\"Miau!\""

#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid "\"Hello, who are you? {}\""
msgstr "\"Bună ziua, cine ești? {}\""

#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid "Memory layout after allocating `pets`:"
msgstr "Dispunerea memoriei după alocarea `pets`:"

#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                           :     :                                             :\n"
":    \"pets: Vec<dyn Pet>\"   :     :   \"data: Cat\"         +----+----+----"
"+----+ :\n"
":   +-----------+-------+   :     :  +-------+-------+    | F  | i  | d  | "
"o  | :\n"
":   | ptr       |   o---+---+--.  :  | lives |     9 |    +----+----+----"
"+----+ :\n"
":   | len       |     2 |   :  |  :  +-------+-------+      "
"^                   :\n"
":   | capacity  |     2 |   :  |  :       ^                 "
"|                   :\n"
":   +-----------+-------+   :  |  :       |                 "
"'-------.           :\n"
":                           :  |  :       |               data:"
"\"Dog\"|           :\n"
":                           :  |  :       |              +-------+--|-------"
"+   :\n"
"`- - - - - - - - - - - - - -'  |  :   +---|-+-----+      | name  |  o, 4, 4 "
"|   :\n"
"                               `--+-->| o o | o o-|----->| age   |        5 "
"|   :\n"
"                                  :   +-|---+-|---+      +-------+----------"
"+   :\n"
"                                  :     |     "
"|                                 :\n"
"                                  `- - -| - - |- - - - - - - - - - - - - - - "
"- -'\n"
"                                        |     |\n"
"                                        |     |                      "
"\"Program text\"\n"
"                                  .- - -| - - |- - - - - - - - - - - - - - - "
"- -.\n"
"                                  :     |     |       "
"vtable                    :\n"
"                                  :     |     |      +----------------------"
"+   :\n"
"                                  :     |     `----->| \"<Dog as Pet>::"
"talk\" |   :\n"
"                                  :     |            +----------------------"
"+   :\n"
"                                  :     |             "
"vtable                    :\n"
"                                  :     |            +----------------------"
"+   :\n"
"                                  :     '----------->| \"<Cat as Pet>::"
"talk\" |   :\n"
"                                  :                  +----------------------"
"+   :\n"
"                                  :                                             :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"
msgstr ""
"```bob\n"
" Stiva Heap\n"
".- - - - - - - - - - - - - -. .- - - - - - - - - - - - - - - - - - - - - - "
"-.\n"
": : : :\n"
": animale de companie : : : +----+----+----+----+----+ :\n"
":   +-----------+-------+ : : : +-----+-----+ .-&gt;| F | i | d | o | :\n"
":   | ptr | o---++-+-+-----+--&gt;| o o | o o | o o | | | +----+----+----"
"+----+----+ :\n"
":   | len | 2 | : : : +-|-|-|-+-|-|-|-+ `---------. :\n"
":   | capacitate | 2 | : :     | | | | | | date | :\n"
":   +-----------+-------+ : :     | | | | +-------+--|-------+ :\n"
": : :     | | | | '--&gt;|| nume | o, 4, 4 | :\n"
": : :     | | | | | vârstă | 5 | :\n"
"`- - - - - - - - - - - - - -' :     | | | +-------+----------+ :\n"
"                                  :     | | | :\n"
"                                  :     | | | | vtable :\n"
"                                  :     | | | +----------------------+ :\n"
"                                  :     | | '----&gt;| \"<Dog as Pet>::"
"talk\" | :\n"
"                                  :     | | +----------------------+ :\n"
"                                  :     | | :\n"
"                                  :     | | date :\n"
"                                  :     | | +-------+-------+ :\n"
"                                  :     | '--&gt;| vieți | 9 | :\n"
"                                  :     | +-------+-------+ :\n"
"                                  :     | :\n"
"                                  :     | vtable :\n"
"                                  :     | +----------------------+ :\n"
"                                  : '----&gt;|| \"<Cat as Pet>::talk\" | :\n"
"                                  : +----------------------+ :\n"
"                                  : :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"

#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid ""
"Types that implement a given trait may be of different sizes. This makes it "
"impossible to have things like `Vec<dyn Pet>` in the example above."
msgstr ""
"Tipurile care implementează o anumită trăsătură pot avea dimensiuni "
"diferite. Acest lucru face imposibilă existența unor lucruri precum `Vec<dyn "
"Pet>` în exemplul de mai sus."

#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid ""
"`dyn Pet` is a way to tell the compiler about a dynamically sized type that "
"implements `Pet`."
msgstr ""
"`dyn Pet` este o modalitate de a indica compilatorului un tip dimensionat "
"dinamic care implementează `Pet`."

#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid ""
"In the example, `pets` is allocated on the stack and the vector data is on "
"the heap. The two vector elements are _fat pointers_:"
msgstr ""
"În acest exemplu, `pets` este alocat pe stivă, iar datele vectorului se află "
"pe heap. Cele două elemente ale vectorului sunt _fat pointeri_:"

#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid ""
"A fat pointer is a double-width pointer. It has two components: a pointer to "
"the actual object and a pointer to the [virtual method table](https://en."
"wikipedia.org/wiki/Virtual_method_table) (vtable) for the `Pet` "
"implementation of that particular object."
msgstr ""
"Un pointer gras este un pointer cu lățime dublă. Acesta are două componente: "
"un pointer la obiectul real și un pointer la [virtual method table](https://"
"en.wikipedia.org/wiki/Virtual_method_table) (vtable) pentru implementarea "
"`Pet` a obiectului respectiv."

#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid ""
"The data for the `Dog` named Fido is the `name` and `age` fields. The `Cat` "
"has a `lives` field."
msgstr ""
"Datele pentru `Dog` numit Fido sunt câmpurile `name` și `age`. Pentru `Cat` "
"există un câmp `lives`."

#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid "Compare these outputs in the above example:"
msgstr "Comparați aceste ieșiri în exemplul de mai sus:"

#: src/smart-pointers/exercise.md
#, fuzzy
msgid ""
"A binary tree is a tree-type data structure where every node has two "
"children (left and right). We will create a tree where each node stores a "
"value. For a given node N, all nodes in a N's left subtree contain smaller "
"values, and all nodes in N's right subtree will contain larger values."
msgstr ""
"Un arbore binar este o structură de date de tip arbore în care fiecare nod "
"are doi copii (stânga și dreapta). Vom crea un arbore în care fiecare nod "
"stochează o valoare. Pentru un anumit nod N, toate nodurile din subarborele "
"stâng al lui N conțin valori mai mici, iar toate nodurile din subarborele "
"drept al lui N vor conține valori mai mari."

#: src/smart-pointers/exercise.md
#, fuzzy
msgid "Implement the following types, so that the given tests pass."
msgstr "Implementați următoarele tipuri, astfel încât testele date să treacă."

#: src/smart-pointers/exercise.md
#, fuzzy
msgid ""
"Extra Credit: implement an iterator over a binary tree that returns the "
"values in order."
msgstr ""
"Credit suplimentar: implementați un iterator pe un arbore binar care "
"returnează valorile în ordine."

#: src/smart-pointers/exercise.md src/smart-pointers/solution.md
#, fuzzy
msgid "/// A node in the binary tree.\n"
msgstr "/// Un nod în arborele binar.\n"

#: src/smart-pointers/exercise.md src/smart-pointers/solution.md
#, fuzzy
msgid "/// A possibly-empty subtree.\n"
msgstr "/// Un subarbore posibil gol.\n"

#: src/smart-pointers/exercise.md src/smart-pointers/solution.md
#, fuzzy
msgid ""
"/// A container storing a set of values, using a binary tree.\n"
"///\n"
"/// If the same value is added multiple times, it is only stored once.\n"
msgstr ""
"/// Un container care stochează un set de valori, utilizând un arbore "
"binar.\n"
"///\n"
"/// În cazul în care aceeași valoare este adăugată de mai multe ori, aceasta "
"este stocată o singură dată.\n"

#: src/smart-pointers/exercise.md
#, fuzzy
msgid "// Implement `new`, `insert`, `len`, and `has` for `Subtree`.\n"
msgstr "// Implementați `new`, `insert`, `len` și `has`.\n"

#: src/smart-pointers/exercise.md src/smart-pointers/solution.md
#, fuzzy
msgid "// not a unique item\n"
msgstr "// nu este un element unic\n"

#: src/smart-pointers/solution.md src/android/testing/googletest.md
#, fuzzy
msgid "\"bar\""
msgstr "\"bar\""

#: src/welcome-day-3-afternoon.md
#, fuzzy
msgid "[Borrowing](./borrowing.md) (55 minutes)"
msgstr "[Împrumut](../împrumut.md) (1 oră)"

#: src/welcome-day-3-afternoon.md
#, fuzzy
msgid "[Lifetimes](./lifetimes.md) (50 minutes)"
msgstr "[Referințe](../references.md) (50 minute)"

#: src/welcome-day-3-afternoon.md
#, fuzzy
msgid ""
"Including 10 minute breaks, this session should take about 1 hour and 55 "
"minutes"
msgstr ""
"Incluzând pauzele de 10 minute, această sesiune ar trebui să dureze "
"aproximativ 3 ore și 5 minute"

#: src/borrowing.md
#, fuzzy
msgid "[Borrowing a Value](./borrowing/shared.md) (10 minutes)"
msgstr "[Împrumutând o valoare](./împrumut/împărtășit.md) (10 minute)"

#: src/borrowing.md
#, fuzzy
msgid "[Borrow Checking](./borrowing/borrowck.md) (10 minutes)"
msgstr "[Verificarea împrumutului](./împrumut/împrumutck.md) (10 minute)"

#: src/borrowing.md
#, fuzzy
msgid "[Borrow Errors](./borrowing/examples.md) (3 minutes)"
msgstr "[Împrumut](../împrumut.md) (1 oră)"

#: src/borrowing.md
#, fuzzy
msgid "[Interior Mutability](./borrowing/interior-mutability.md) (10 minutes)"
msgstr ""
"[Mutabilitatea interioară](./împrumut/interior-mutability.md) (10 minute)"

#: src/borrowing.md
#, fuzzy
msgid "[Exercise: Health Statistics](./borrowing/exercise.md) (20 minutes)"
msgstr ""
"[Exercițiu: Statistici în domeniul sănătății](./împrumut/exercițiu.md) (30 "
"minute)"

#: src/borrowing/shared.md
#, fuzzy
msgid ""
"As we saw before, instead of transferring ownership when calling a function, "
"you can let a function _borrow_ the value:"
msgstr ""
"În loc să transferați proprietatea atunci când apelați o funcție, puteți "
"lăsa o funcție să _împrumute_ valoarea:"

#: src/borrowing/shared.md
#, fuzzy
msgid "The `add` function _borrows_ two points and returns a new point."
msgstr "Funcția `add` adună două puncte și returnează un nou punct."

#: src/borrowing/shared.md
#, fuzzy
msgid "The caller retains ownership of the inputs."
msgstr "Apelantul păstrează dreptul de proprietate asupra intrărilor."

#: src/borrowing/shared.md
#, fuzzy
msgid ""
"This slide is a review of the material on references from day 1, expanding "
"slightly to include function arguments and return values."
msgstr ""
"Acest diapozitiv reprezintă o revizuire a materialului despre referințe din "
"ziua 1, cu o ușoară extindere pentru a include argumentele funcțiilor și "
"valorile de returnare."

#: src/borrowing/shared.md
#, fuzzy
msgid "Notes on stack returns:"
msgstr "Note privind returnările de stivă:"

#: src/borrowing/shared.md
#, fuzzy
msgid ""
"Demonstrate that the return from `add` is cheap because the compiler can "
"eliminate the copy operation. Change the above code to print stack addresses "
"and run it on the [Playground](https://play.rust-lang.org/?"
"version=stable&mode=release&edition=2021&gist=0cb13be1c05d7e3446686ad9947c4671) "
"or look at the assembly in [Godbolt](https://rust.godbolt.org/). In the "
"\"DEBUG\" optimization level, the addresses should change, while they stay "
"the same when changing to the \"RELEASE\" setting:"
msgstr ""
"Demonstrați că întoarcerea din `add` este ieftină deoarece compilatorul "
"poate elimina operația de copiere. Modificați codul de mai sus pentru a "
"imprima adresele stivei și rulați-l pe [Playground](https://play.rust-lang."
"org/) sau examinați ansamblul în [Godbolt](https://rust.godbolt.org/). În "
"nivelul de optimizare \"DEBUG\", adresele ar trebui să se schimbe, în timp "
"ce ele rămân aceleași atunci când treceți la setarea \"RELEASE\":"

#: src/borrowing/shared.md
#, fuzzy
msgid "The Rust compiler can do return value optimization (RVO)."
msgstr "Compilatorul Rust poate face optimizarea valorii de returnare (RVO)."

#: src/borrowing/shared.md
#, fuzzy
msgid ""
"In C++, copy elision has to be defined in the language specification because "
"constructors can have side effects. In Rust, this is not an issue at all. If "
"RVO did not happen, Rust will always perform a simple and efficient `memcpy` "
"copy."
msgstr ""
"În C++, eliziunea de copiere trebuie definită în specificațiile limbajului, "
"deoarece constructorii pot avea efecte secundare. În Rust, acest lucru nu "
"reprezintă deloc o problemă. Dacă RVO nu a avut loc, Rust va efectua "
"întotdeauna o copie `memcpy` simplă și eficientă."

#: src/borrowing/borrowck.md
#, fuzzy
msgid ""
"Rust's _borrow checker_ puts constraints on the ways you can borrow values. "
"For a given value, at any time:"
msgstr ""
"Rust impune constrângeri asupra modalităților în care puteți împrumuta "
"valori:"

#: src/borrowing/borrowck.md
#, fuzzy
msgid "You can have one or more shared references to the value, _or_"
msgstr "Puteți avea una sau mai multe valori `&T` la un moment dat, _sau_"

#: src/borrowing/borrowck.md
#, fuzzy
msgid "You can have exactly one exclusive reference to the value."
msgstr "Puteți avea exact o singură valoare `&mut T`."

#: src/borrowing/borrowck.md
#, fuzzy
msgid ""
"Note that the requirement is that conflicting references not _exist_ at the "
"same point. It does not matter where the reference is dereferenced."
msgstr ""
"Rețineți că cerința este ca referințele conflictuale să nu _existe_ în "
"același punct. Nu contează unde este dereferențiată referința."

#: src/borrowing/borrowck.md
#, fuzzy
msgid ""
"The above code does not compile because `a` is borrowed as mutable (through "
"`c`) and as immutable (through `b`) at the same time."
msgstr ""
"Codul de mai sus nu se compilează pentru că `a` este împrumutat ca mutabil "
"(prin `c`) și ca imuabil (prin `b`) în același timp."

#: src/borrowing/borrowck.md
#, fuzzy
msgid ""
"Move the `println!` statement for `b` before the scope that introduces `c` "
"to make the code compile."
msgstr ""
"Mutați instrucțiunea `println!` pentru `b` înainte de domeniul de aplicare "
"care introduce `c` pentru a face codul să fie compilat."

#: src/borrowing/borrowck.md
#, fuzzy
msgid ""
"After that change, the compiler realizes that `b` is only ever used before "
"the new mutable borrow of `a` through `c`. This is a feature of the borrow "
"checker called \"non-lexical lifetimes\"."
msgstr ""
"După această modificare, compilatorul își dă seama că `b` este folosit doar "
"înainte de noul împrumut mutabil de la `a` la `c`. Aceasta este o "
"caracteristică a verificatorului de împrumuturi numită \"durate de viață non-"
"lexicale\"."

#: src/borrowing/borrowck.md
#, fuzzy
msgid ""
"The exclusive reference constraint is quite strong. Rust uses it to ensure "
"that data races do not occur. Rust also _relies_ on this constraint to "
"optimize code. For example, a value behind a shared reference can be safely "
"cached in a register for the lifetime of that reference."
msgstr ""
"Constrângerea de referință exclusivă este destul de puternică. Rust o "
"folosește pentru a se asigura că nu se produc curse de date. De asemenea, "
"Rust se bazează pe această constrângere pentru a optimiza codul. De exemplu, "
"o valoare din spatele unei referințe partajate poate fi stocată în siguranță "
"într-un registru pe durata de viață a referinței respective."

#: src/borrowing/borrowck.md
#, fuzzy
msgid ""
"The borrow checker is designed to accommodate many common patterns, such as "
"taking exclusive references to different fields in a struct at the same "
"time. But, there are some situations where it doesn't quite \"get it\" and "
"this often results in \"fighting with the borrow checker.\""
msgstr ""
"Verificatorul de împrumuturi este conceput pentru a se adapta la multe "
"modele comune, cum ar fi preluarea de referințe exclusive la diferite "
"câmpuri dintr-o structură în același timp. Dar, există unele situații în "
"care nu prea \"înțelege\", ceea ce duce adesea la \"lupta cu verificatorul "
"de împrumuturi\""

#: src/borrowing/examples.md
#, fuzzy
msgid ""
"As a concrete example of how these borrowing rules prevent memory errors, "
"consider the case of modifying a collection while there are references to "
"its elements:"
msgstr ""
"Ca exemplu concret al modului în care aceste reguli de împrumut previn "
"erorile de memorie, luați în considerare cazul modificării unei colecții în "
"timp ce există referințe la elementele sale:"

#: src/borrowing/examples.md
#, fuzzy
msgid "\"{elem}\""
msgstr "\"elem: {elem}\""

#: src/borrowing/examples.md
#, fuzzy
msgid "Similarly, consider the case of iterator invalidation:"
msgstr "În mod similar, luați în considerare cazul invalidării iteratorilor:"

#: src/borrowing/examples.md
#, fuzzy
msgid ""
"In both of these cases, modifying the collection by pushing new elements "
"into it can potentially invalidate existing references to the collection's "
"elements if the collection has to reallocate."
msgstr ""
"În ambele cazuri, modificarea colecției prin introducerea de noi elemente în "
"colecție poate invalida referințele existente la elementele colecției dacă "
"colecția trebuie realocată."

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid ""
"In some situations, it's necessary to modify data behind a shared (read-"
"only) reference. For example, a shared data structure might have an internal "
"cache, and wish to update that cache from read-only methods."
msgstr ""
"În unele situații, este necesar să se modifice datele din spatele unei "
"referințe partajate (numai pentru citire). De exemplu, o structură de date "
"partajată ar putea avea o memorie cache internă și ar putea dori să "
"actualizeze această memorie cache prin metode numai pentru citire."

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid ""
"The \"interior mutability\" pattern allows exclusive (mutable) access behind "
"a shared reference. The standard library provides several ways to do this, "
"all while still ensuring safety, typically by performing a runtime check."
msgstr ""
"Modelul \"mutabilității interioare\" permite accesul exclusiv (mutabil) în "
"spatele unei referințe partajate. Biblioteca standard oferă mai multe "
"modalități de a face acest lucru, toate asigurând în același timp siguranța, "
"de obicei prin efectuarea unei verificări în timpul execuției."

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid "`RefCell`"
msgstr "Celula/RefCell"

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid "// Note that `cell` is NOT declared as mutable.\n"
msgstr "// Rețineți că `cell` NU este declarat ca fiind mutabil.\n"

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid ""
"// This triggers an error at runtime.\n"
"        // let other = cell.borrow();\n"
"        // println!(\"{}\", *other);\n"
msgstr ""
"// Acest lucru declanșează o eroare în timpul execuției.\n"
"        // let other = cell.borrow();\n"
"        // println!(\"{}\", *other);\n"

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid "\"{cell:?}\""
msgstr "Celula/RefCell"

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid "`Cell`"
msgstr "`Celula<T>`"

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid ""
"`Cell` wraps a value and allows getting or setting the value, even with a "
"shared reference to the `Cell`. However, it does not allow any references to "
"the value. Since there are no references, borrowing rules cannot be broken."
msgstr ""
"`Cell` înfășoară o valoare și permite obținerea sau stabilirea valorii, "
"chiar și cu o referință partajată la `Cell`. Cu toate acestea, nu permite "
"referințe la valoarea respectivă. Deoarece nu există referințe, regulile de "
"împrumut nu pot fi încălcate."

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid ""
"The main thing to take away from this slide is that Rust provides _safe_ "
"ways to modify data behind a shared reference. There are a variety of ways "
"to ensure that safety, and `RefCell` and `Cell` are two of them."
msgstr ""
"Principalul lucru care trebuie reținut din acest diapozitiv este că Rust "
"oferă modalități _sigure_ de a modifica datele din spatele unei referințe "
"partajate. Există o varietate de moduri de a asigura această siguranță, iar "
"`RefCell` și `Cell` sunt două dintre ele."

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid ""
"`RefCell` enforces Rust's usual borrowing rules (either multiple shared "
"references or a single exclusive reference) with a runtime check. In this "
"case, all borrows are very short and never overlap, so the checks always "
"succeed."
msgstr ""
"`RefCell` aplică regulile obișnuite de împrumut din Rust (fie mai multe "
"referințe partajate, fie o singură referință exclusivă) cu o verificare în "
"timpul execuției. În acest caz, toate împrumuturile sunt foarte scurte și nu "
"se suprapun niciodată, astfel încât verificările reușesc întotdeauna."

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid ""
"The extra block in the `RefCell` example is to end the borrow created by the "
"call to `borrow_mut` before we print the cell. Trying to print a borrowed "
"`RefCell` just shows the message `\"{borrowed}\"`."
msgstr ""
"Blocul suplimentar din exemplul `RefCell` are rolul de a încheia împrumutul "
"creat prin apelul la `borrow_mut` înainte de a imprima celula. Încercarea de "
"a imprima o `RefCell` împrumutată nu face decât să afișeze mesajul "
"`\"{borrowed}\"`."

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid ""
"`Cell` is a simpler means to ensure safety: it has a `set` method that takes "
"`&self`. This needs no runtime check, but requires moving values, which can "
"have its own cost."
msgstr ""
"`Cell` este un mijloc mai simplu de a asigura siguranța: are o metodă `set` "
"care ia `&self`. Acest lucru nu necesită o verificare în timpul execuției, "
"dar necesită mutarea valorilor, ceea ce poate avea propriile costuri."

#: src/borrowing/exercise.md
#, fuzzy
msgid ""
"You're working on implementing a health-monitoring system. As part of that, "
"you need to keep track of users' health statistics."
msgstr ""
"Lucrați la implementarea unui sistem de monitorizare a sănătății. În cadrul "
"acestuia, trebuie să țineți evidența statisticilor de sănătate ale "
"utilizatorilor."

#: src/borrowing/exercise.md
#, fuzzy
msgid ""
"You'll start with a stubbed function in an `impl` block as well as a `User` "
"struct definition. Your goal is to implement the stubbed out method on the "
"`User` `struct` defined in the `impl` block."
msgstr ""
"Veți începe cu niște funcții stubbed într-un bloc `impl`, precum și cu o "
"definiție a structurii `User`. Scopul dumneavoastră este de a implementa "
"metodele stubbed out pe `struct` `User` definită în blocul `impl`."

#: src/borrowing/exercise.md
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing "
"method:"
msgstr ""
"Copiați codul de mai jos în <https://play.rust-lang.org/> și completați "
"metodele lipsă:"

#: src/borrowing/exercise.md
#, fuzzy
msgid ""
"\"Update a user's statistics based on measurements from a visit to the "
"doctor\""
msgstr ""
"\"Actualizați statisticile unui utilizator pe baza măsurătorilor de la o "
"vizită la medic\""

#: src/borrowing/exercise.md src/borrowing/solution.md
#: src/android/build-rules/library.md
#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "\"Bob\""
msgstr "\"Bob\""

#: src/borrowing/exercise.md src/borrowing/solution.md
#, fuzzy
msgid "\"I'm {} and my age is {}\""
msgstr "\"Eu sunt {} și vârsta mea este {}\""

#: src/lifetimes.md
#, fuzzy
msgid ""
"[Lifetime Annotations](./lifetimes/lifetime-annotations.md) (10 minutes)"
msgstr ""
"[Adnotări privind durata de viață](./slices-and-lifetimes/lifetime-"
"annotations.md) (10 minute)"

#: src/lifetimes.md
#, fuzzy
msgid "[Lifetime Elision](./lifetimes/lifetime-elision.md) (5 minutes)"
msgstr ""
"[Lifetime Elision](./slices-and-lifetimes/lifetime-elision.md) (5 minute)"

#: src/lifetimes.md
#, fuzzy
msgid "[Struct Lifetimes](./lifetimes/struct-lifetimes.md) (5 minutes)"
msgstr ""
"[Struct Lifetimes](./slices-and-lifetimes/struct-lifetimes.md) (5 minute)"

#: src/lifetimes.md
#, fuzzy
msgid "[Exercise: Protobuf Parsing](./lifetimes/exercise.md) (30 minutes)"
msgstr ""
"[Exercițiu: Parsarea Protobuf](./slices-and-lifetimes/exercise.md) (30 "
"minute)"

#: src/lifetimes/lifetime-annotations.md
#, fuzzy
msgid ""
"A reference has a _lifetime_, which must not \"outlive\" the value it refers "
"to. This is verified by the borrow checker."
msgstr ""
"O referință are o _durată de viață_, care nu trebuie să \"supraviețuiască\" "
"valorii la care se referă. Acest lucru este verificat de către verificatorul "
"de împrumut."

#: src/lifetimes/lifetime-annotations.md
#, fuzzy
msgid ""
"The lifetime can be implicit - this is what we have seen so far. Lifetimes "
"can also be explicit: `&'a Point`, `&'document str`. Lifetimes start with "
"`'` and `'a` is a typical default name. Read `&'a Point` as \"a borrowed "
"`Point` which is valid for at least the lifetime `a`\"."
msgstr ""
"Durata de viață poate fi implicită - aceasta este ceea ce am văzut până "
"acum. Duratele de viață pot fi, de asemenea, explicite: `&'a Point`, "
"`&'document str`. Duratele de viață încep cu `'`, iar `'a` este un nume "
"implicit tipic. Citiți `&'a Point` ca \"un `Point` împrumutat care este "
"valabil cel puțin pentru durata de viață `a`\"."

#: src/lifetimes/lifetime-annotations.md
#, fuzzy
msgid ""
"Lifetimes are always inferred by the compiler: you cannot assign a lifetime "
"yourself. Explicit lifetime annotations create constraints where there is "
"ambiguity; the compiler verifies that there is a valid solution."
msgstr ""
"Adnotările privind durata de viață creează constrângeri; compilatorul "
"verifică dacă există o soluție validă."

#: src/lifetimes/lifetime-annotations.md
#, fuzzy
msgid ""
"Lifetimes become more complicated when considering passing values to and "
"returning values from functions."
msgstr ""
"Duratele de viață devin mai complicate atunci când se ia în considerare "
"transmiterea valorilor către și returnarea valorilor din funcții."

#: src/lifetimes/lifetime-annotations.md
#, fuzzy
msgid "// What is the lifetime of p3?\n"
msgstr "// Care este durata de viață a lui p3?\n"

#: src/lifetimes/lifetime-annotations.md
#, fuzzy
msgid "\"p3: {p3:?}\""
msgstr "\"p3: {p3:?}\""

#: src/lifetimes/lifetime-annotations.md
#, fuzzy
msgid ""
"In this example, the compiler does not know what lifetime to infer for `p3`. "
"Looking inside the function body shows that it can only safely assume that "
"`p3`'s lifetime is the shorter of `p1` and `p2`. But just like types, Rust "
"requires explicit annotations of lifetimes on function arguments and return "
"values."
msgstr ""
"În acest exemplu, compilatorul nu știe ce durată de viață să deducă pentru "
"`p3`. Privind în interiorul corpului funcției arată că poate doar să "
"presupună în mod sigur că durata de viață a lui `p3` este cea mai scurtă "
"dintre `p1` și `p2`. Dar, la fel ca tipurile, Rust necesită adnotări "
"explicite ale duratei de viață pentru argumentele funcțiilor și valorile de "
"returnare."

#: src/lifetimes/lifetime-annotations.md
#, fuzzy
msgid "Add `'a` appropriately to `left_most`:"
msgstr "Adăugați `'a` în mod corespunzător la `left_most`:"

#: src/lifetimes/lifetime-annotations.md
#, fuzzy
msgid ""
"This says, \"given p1 and p2 which both outlive `'a`, the return value lives "
"for at least `'a`."
msgstr ""
"Acest lucru spune: \"date fiind p1 și p2, care amândouă trăiesc mai mult de "
"`'a`, valoarea de întoarcere trăiește cel puțin `'a`."

#: src/lifetimes/lifetime-annotations.md
#, fuzzy
msgid ""
"In common cases, lifetimes can be elided, as described on the next slide."
msgstr ""
"În cazuri obișnuite, duratele de viață pot fi eludate, așa cum este descris "
"în slide-ul următor."

#: src/lifetimes/lifetime-elision.md
msgid "Lifetimes in Function Calls"
msgstr "Duratele de viață în apelurile de funcții"

#: src/lifetimes/lifetime-elision.md
#, fuzzy
msgid ""
"Lifetimes for function arguments and return values must be fully specified, "
"but Rust allows lifetimes to be elided in most cases with [a few simple "
"rules](https://doc.rust-lang.org/nomicon/lifetime-elision.html). This is not "
"inference -- it is just a syntactic shorthand."
msgstr ""
"Duratele de viață pentru argumentele funcțiilor și valorile de retur trebuie "
"să fie specificate în întregime, dar Rust permite ca duratele de viață să "
"fie eludate în majoritatea cazurilor cu [câteva reguli simple](https://doc."
"rust-lang.org/nomicon/lifetime-elision.html)."

#: src/lifetimes/lifetime-elision.md
#, fuzzy
msgid "Each argument which does not have a lifetime annotation is given one."
msgstr ""
"Fiecare argument care nu are o adnotare de durată de viață primește una."

#: src/lifetimes/lifetime-elision.md
#, fuzzy
msgid ""
"If there is only one argument lifetime, it is given to all un-annotated "
"return values."
msgstr ""
"În cazul în care există un singur argument pe durata de viață, acesta este "
"atribuit tuturor valorilor de returnare neanunțate."

#: src/lifetimes/lifetime-elision.md
#, fuzzy
msgid ""
"If there are multiple argument lifetimes, but the first one is for `self`, "
"that lifetime is given to all un-annotated return values."
msgstr ""
"Dacă există mai multe durate de viață ale argumentelor, dar prima este "
"pentru `self`, această durată de viață este acordată tuturor valorilor de "
"returnare neanunțate."

#: src/lifetimes/lifetime-elision.md
#, fuzzy
msgid "In this example, `cab_distance` is trivially elided."
msgstr "În acest exemplu, `cab_distance` este eliminat în mod trivial."

#: src/lifetimes/lifetime-elision.md
#, fuzzy
msgid ""
"The `nearest` function provides another example of a function with multiple "
"references in its arguments that requires explicit annotation."
msgstr ""
"Funcția `nearest` oferă un alt exemplu de funcție cu referințe multiple în "
"argumentele sale care necesită o adnotare explicită."

#: src/lifetimes/lifetime-elision.md
#, fuzzy
msgid "Try adjusting the signature to \"lie\" about the lifetimes returned:"
msgstr ""
"Încercați să ajustați semnătura pentru a \"minți\" cu privire la perioadele "
"de viață returnate:"

#: src/lifetimes/lifetime-elision.md
#, fuzzy
msgid ""
"This won't compile, demonstrating that the annotations are checked for "
"validity by the compiler. Note that this is not the case for raw pointers "
"(unsafe), and this is a common source of errors with unsafe Rust."
msgstr ""
"Acest lucru nu se va compila, demonstrând că validitatea adnotărilor este "
"verificată de compilator. Rețineți că acest lucru nu este valabil și pentru "
"pointeri brute (unsafe), iar aceasta este o sursă comună de erori în cazul "
"Rust unsafe."

#: src/lifetimes/lifetime-elision.md
#, fuzzy
msgid ""
"Students may ask when to use lifetimes. Rust borrows _always_ have "
"lifetimes. Most of the time, elision and type inference mean these don't "
"need to be written out. In more complicated cases, lifetime annotations can "
"help resolve ambiguity. Often, especially when prototyping, it's easier to "
"just work with owned data by cloning values where necessary."
msgstr ""
"Elevii pot întreba când trebuie să folosească duratele de viață. "
"Împrumuturile Rust au _întotdeauna_ durate de viață. De cele mai multe ori, "
"eliziunea și inferența de tip înseamnă că acestea nu trebuie să fie scrise. "
"În cazuri mai complicate, adnotările privind durata de viață pot ajuta la "
"rezolvarea ambiguității. De multe ori, în special în cazul prototipurilor, "
"este mai ușor să lucrați cu datele deținute prin clonarea valorilor acolo "
"unde este necesar."

#: src/lifetimes/struct-lifetimes.md
msgid "Lifetimes in Data Structures"
msgstr "Duratele de viață în structurile de date"

#: src/lifetimes/struct-lifetimes.md
#, fuzzy
msgid ""
"If a data type stores borrowed data, it must be annotated with a lifetime:"
msgstr ""
"În cazul în care un tip de date stochează date împrumutate, acesta trebuie "
"să fie adnotat cu o durată de viață:"

#: src/lifetimes/struct-lifetimes.md
#, fuzzy
msgid "\"Bye {text}!\""
msgstr "\"La revedere {text}!\""

#: src/lifetimes/struct-lifetimes.md
#, fuzzy
msgid "\"The quick brown fox jumps over the lazy dog.\""
msgstr "\"Vulpea cea iute și brună sare peste câinele leneș.\""

#: src/lifetimes/struct-lifetimes.md
#, fuzzy
msgid "// erase(text);\n"
msgstr "// erase(text);\n"

#: src/lifetimes/struct-lifetimes.md
#, fuzzy
msgid "\"{fox:?}\""
msgstr "\"{fox:?}\""

#: src/lifetimes/struct-lifetimes.md
#, fuzzy
msgid "\"{dog:?}\""
msgstr "\"{dog:?}\""

#: src/lifetimes/struct-lifetimes.md
#, fuzzy
msgid ""
"In the above example, the annotation on `Highlight` enforces that the data "
"underlying the contained `&str` lives at least as long as any instance of "
"`Highlight` that uses that data."
msgstr ""
"În exemplul de mai sus, adnotarea pentru `Highlight` impune ca datele care "
"stau la baza `&str` conținute să aibă o durată de viață cel puțin egală cu "
"cea a oricărei instanțe de `Highlight` care utilizează aceste date."

#: src/lifetimes/struct-lifetimes.md
#, fuzzy
msgid ""
"If `text` is consumed before the end of the lifetime of `fox` (or `dog`), "
"the borrow checker throws an error."
msgstr ""
"Dacă `text` este consumat înainte de sfârșitul duratei de viață a lui `fox` "
"(sau `dog`), verificatorul de împrumuturi aruncă o eroare."

#: src/lifetimes/struct-lifetimes.md
#, fuzzy
msgid ""
"Types with borrowed data force users to hold on to the original data. This "
"can be useful for creating lightweight views, but it generally makes them "
"somewhat harder to use."
msgstr ""
"Tipurile cu date împrumutate îi obligă pe utilizatori să păstreze datele "
"originale. Acest lucru poate fi util pentru a crea vizualizări ușoare, dar, "
"în general, le face ceva mai greu de utilizat."

#: src/lifetimes/struct-lifetimes.md
#, fuzzy
msgid "When possible, make data structures own their data directly."
msgstr ""
"Atunci când este posibil, faceți ca structurile de date să dețină direct "
"datele lor."

#: src/lifetimes/struct-lifetimes.md
#, fuzzy
msgid ""
"Some structs with multiple references inside can have more than one lifetime "
"annotation. This can be necessary if there is a need to describe lifetime "
"relationships between the references themselves, in addition to the lifetime "
"of the struct itself. Those are very advanced use cases."
msgstr ""
"Unele structuri cu referințe multiple în interior pot avea mai multe "
"adnotări de durată de viață. Acest lucru poate fi necesar în cazul în care "
"este necesar să se descrie relațiile de durată de viață între referințe, pe "
"lângă durata de viață a structurii în sine. Acestea sunt cazuri de utilizare "
"foarte avansate."

#: src/lifetimes/exercise.md
#, fuzzy
msgid ""
"In this exercise, you will build a parser for the [protobuf binary encoding]"
"(https://protobuf.dev/programming-guides/encoding/). Don't worry, it's "
"simpler than it seems! This illustrates a common parsing pattern, passing "
"slices of data. The underlying data itself is never copied."
msgstr ""
"În acest exercițiu, veți construi un parser pentru [protobuf binary encoding]"
"(https://protobuf.dev/programming-guides/encoding/). Nu vă faceți griji, "
"este mai simplu decât pare! Aceasta ilustrează un model comun de parsare, "
"trecând felii de date. Datele de bază în sine nu sunt niciodată copiate."

#: src/lifetimes/exercise.md
#, fuzzy
msgid ""
"Fully parsing a protobuf message requires knowing the types of the fields, "
"indexed by their field numbers. That is typically provided in a `proto` "
"file. In this exercise, we'll encode that information into `match` "
"statements in functions that get called for each field."
msgstr ""
"Analiza completă a unui mesaj protobuf necesită cunoașterea tipurilor de "
"câmpuri, indexate prin numerele de câmp. Acest lucru este furnizat de obicei "
"într-un fișier `proto`. În acest exercițiu, vom codifica aceste informații "
"în instrucțiuni `match` în funcții care sunt apelate pentru fiecare câmp."

#: src/lifetimes/exercise.md
#, fuzzy
msgid "We'll use the following proto:"
msgstr "Puteți utiliza următorul `Cargo.toml`:"

#: src/lifetimes/exercise.md
#, fuzzy
msgid ""
"A proto message is encoded as a series of fields, one after the next. Each "
"is implemented as a \"tag\" followed by the value. The tag contains a field "
"number (e.g., `2` for the `id` field of a `Person` message) and a wire type "
"defining how the payload should be determined from the byte stream."
msgstr ""
"Un mesaj proto este codificat ca o serie de câmpuri, unul după altul. "
"Fiecare este implementat ca o \"etichetă\" urmată de valoare. Eticheta "
"conține un număr de câmp (de exemplu, `2` pentru câmpul `id` al unui mesaj "
"`Person`) și un tip de fir care definește modul în care încărcătura utilă ar "
"trebui să fie determinată din fluxul de octeți."

#: src/lifetimes/exercise.md
#, fuzzy
msgid ""
"Integers, including the tag, are represented with a variable-length encoding "
"called VARINT. Luckily, `parse_varint` is defined for you below. The given "
"code also defines callbacks to handle `Person` and `PhoneNumber` fields, and "
"to parse a message into a series of calls to those callbacks."
msgstr ""
"Întregii, inclusiv tag-ul, sunt reprezentați cu o codificare de lungime "
"variabilă numită VARINT. Din fericire, `parse_varint` este definit pentru "
"dumneavoastră mai jos. Codul dat definește, de asemenea, callback-uri pentru "
"a gestiona câmpurile `Person` și `PhoneNumber` și pentru a analiza un mesaj "
"într-o serie de apeluri la aceste callback-uri."

#: src/lifetimes/exercise.md
#, fuzzy
msgid ""
"What remains for you is to implement the `parse_field` function and the "
"`ProtoMessage` trait for `Person` and `PhoneNumber`."
msgstr ""
"Ceea ce vă rămâne de făcut este să implementați funcția `parse_field` și "
"trăsătura `ProtoMessage` pentru `Person` și `PhoneNumber`."

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "\"Invalid varint\""
msgstr "\"Invalid varint\""

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "\"Invalid wire-type\""
msgstr "\"Tip de fir invalid\""

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "\"Unexpected EOF\""
msgstr "\"Unexpected EOF\""

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "\"Invalid length\""
msgstr "\"Lungime invalidă\""

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "\"Unexpected wire-type)\""
msgstr "\"Tip de fir neașteptat)\""

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "\"Invalid string (not UTF-8)\""
msgstr "\"Șir nevalabil (nu UTF-8)\""

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "/// A wire type as seen on the wire.\n"
msgstr "/// Un tip de fir, așa cum se vede pe fir.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "/// The Varint WireType indicates the value is a single VARINT.\n"
msgstr "/// Varint WireType indică faptul că valoarea este un singur VARINT.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid ""
"//I64,  -- not needed for this exercise\n"
"    /// The Len WireType indicates that the value is a length represented as "
"a\n"
"    /// VARINT followed by exactly that number of bytes.\n"
msgstr ""
"//I64, -- nu este necesar pentru acest exercițiu\n"
"    /// Tipul de fir Len indică faptul că valoarea este o lungime "
"reprezentată sub forma unui număr de caractere\n"
"    /// VARINT urmat de exact acest număr de octeți.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid ""
"/// The I32 WireType indicates that the value is precisely 4 bytes in\n"
"    /// little-endian order containing a 32-bit signed integer.\n"
msgstr ""
"/// I32 WireType indică faptul că valoarea este exact 4 octeți în\n"
"    /// little-endian care conțin un număr întreg semnat pe 32 de biți.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "/// A field's value, typed based on the wire type.\n"
msgstr "/// Valoarea unui câmp, tipizată în funcție de tipul de fir.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "//I64(i64),  -- not needed for this exercise\n"
msgstr "//I64(i64), -- nu este necesar pentru acest exercițiu\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "/// A field, containing the field number and its value.\n"
msgstr "/// Un câmp, care conține numărul câmpului și valoarea acestuia.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "//1 => WireType::I64,  -- not needed for this exercise\n"
msgstr "//1 => WireType::I64, -- nu este necesar pentru acest exercițiu\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid ""
"/// Parse a VARINT, returning the parsed value and the remaining bytes.\n"
msgstr ""
"/// Analizează un VARINT, returnând valoarea analizată și octeții rămași.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid ""
"// This is the last byte of the VARINT, so convert it to\n"
"            // a u64 and return it.\n"
msgstr ""
"// Acesta este ultimul octet din VARINT, deci convertiți-l în\n"
"            // un u64 și returnați-l.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "// More than 7 bytes is invalid.\n"
msgstr "// Mai mult de 7 octeți este invalid.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "/// Convert a tag into a field number and a WireType.\n"
msgstr "/// Convertește o etichetă într-un număr de câmp și un tip de fir.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "/// Parse a field, returning the remaining bytes\n"
msgstr "/// Parsează un câmp, returnând octeții rămași\n"

#: src/lifetimes/exercise.md
#, fuzzy
msgid ""
"\"Based on the wire type, build a Field, consuming as many bytes as "
"necessary.\""
msgstr ""
"\"Pe baza tipului de fir, construiți un câmp, consumând atâția octeți câți "
"sunt necesari.\""

#: src/lifetimes/exercise.md
#, fuzzy
msgid "\"Return the field, and any un-consumed bytes.\""
msgstr "\"Întoarceți câmpul și toți octeții neconsumați.\""

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid ""
"/// Parse a message in the given data, calling `T::add_field` for each field "
"in\n"
"/// the message.\n"
"///\n"
"/// The entire input is consumed.\n"
msgstr ""
"/// Parsează un mesaj în datele date, apelând `T::add_field` pentru fiecare "
"câmp din\n"
"/// mesajul.\n"
"///\n"
"/// Se consumă întreaga intrare.\n"

#: src/lifetimes/exercise.md
#, fuzzy
msgid "// TODO: Implement ProtoMessage for Person and PhoneNumber.\n"
msgstr "// TODO: Implementați ProtoMessage pentru Person și PhoneNumber.\n"

#: src/lifetimes/solution.md
#, fuzzy
msgid "// Unwrap error because `value` is definitely 4 bytes long.\n"
msgstr "// Eroare de dezarhivare deoarece `value` are o lungime de 4 bytes.\n"

#: src/lifetimes/solution.md
#, fuzzy
msgid "// skip everything else\n"
msgstr "// săriți peste orice altceva\n"

#: src/lifetimes/solution.md
#, fuzzy
msgid "b\"hello\""
msgstr "b \"hello\""

#: src/welcome-day-4.md
#, fuzzy
msgid "Welcome to Day 4"
msgstr "Bine ați venit la Ziua 1"

#: src/welcome-day-4.md
#, fuzzy
msgid ""
"Today we will cover topics relating to building large-scale software in Rust:"
msgstr "Astăzi, vom aborda câteva subiecte mai avansate din Rust:"

#: src/welcome-day-4.md
#, fuzzy
msgid "Iterators: a deep dive on the `Iterator` trait."
msgstr "Iteratori: o scufundare în profunzime în trăsătura `Iterator`."

#: src/welcome-day-4.md
#, fuzzy
msgid "Modules and visibility."
msgstr "Module și vizibilitate."

#: src/welcome-day-4.md
#, fuzzy
msgid "Testing."
msgstr "Testare"

#: src/welcome-day-4.md
#, fuzzy
msgid "Error handling: panics, `Result`, and the try operator `?`."
msgstr "Gestionarea erorilor: panici, `Result` și operatorul try `?`."

#: src/welcome-day-4.md
#, fuzzy
msgid ""
"Unsafe Rust: the escape hatch when you can't express yourself in safe Rust."
msgstr ""
"Unsafe Rust: portița de scăpare atunci când nu te poți exprima în Rust sigur."

#: src/welcome-day-4.md
#, fuzzy
msgid "[Welcome](./welcome-day-4.md) (3 minutes)"
msgstr "[Intorducere](../welcome-day-4.md) (3 minute)"

#: src/welcome-day-4.md
#, fuzzy
msgid "[Iterators](./iterators.md) (45 minutes)"
msgstr "[Iteratori](../iteratori.md) (45 minute)"

#: src/welcome-day-4.md
#, fuzzy
msgid "[Modules](./modules.md) (40 minutes)"
msgstr "[Module](../modules.md) (40 minute)"

#: src/welcome-day-4.md
#, fuzzy
msgid "[Testing](./testing.md) (45 minutes)"
msgstr "[Testare](../testing.md) (1 oră și 5 minute)"

#: src/welcome-day-4.md
#, fuzzy
msgid ""
"Including 10 minute breaks, this session should take about 2 hours and 40 "
"minutes"
msgstr ""
"Incluzând pauzele de 10 minute, această sesiune ar trebui să dureze "
"aproximativ 2 ore și 20 de minute"

#: src/iterators.md
#, fuzzy
msgid "[Iterator](./iterators/iterator.md) (5 minutes)"
msgstr "[Iterator](./iterators/iterator.md) (5 minute)"

#: src/iterators.md
#, fuzzy
msgid "[IntoIterator](./iterators/intoiterator.md) (5 minutes)"
msgstr "[IntoIterator](./iterators/intoiterator.md) (5 minute)"

#: src/iterators.md
#, fuzzy
msgid "[FromIterator](./iterators/fromiterator.md) (5 minutes)"
msgstr "[FromIterator](./iterators/fromiterator.md) (5 minute)"

#: src/iterators.md
#, fuzzy
msgid ""
"[Exercise: Iterator Method Chaining](./iterators/exercise.md) (30 minutes)"
msgstr ""
"[Exercițiu: înlănțuirea metodelor Iterator](./iterators/exercițiu.md) (30 "
"minute)"

#: src/iterators.md src/testing.md
#, fuzzy
msgid "This segment should take about 45 minutes"
msgstr "Acest segment ar trebui să dureze aproximativ 45 de minute"

#: src/iterators/iterator.md
#, fuzzy
msgid ""
"The [`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) "
"trait supports iterating over values in a collection. It requires a `next` "
"method and provides lots of methods. Many standard library types implement "
"`Iterator`, and you can implement it yourself, too:"
msgstr ""
"Caracteristica [`Iterator`](https://doc.rust-lang.org/std/iter/trait."
"Iterator.html) permite iterația peste valorile dintr-o colecție. Aceasta "
"necesită o metodă `next` și oferă o mulțime de metode. Multe tipuri de "
"bibliotecă standard implementează `Iterator` și o puteți implementa și "
"dumneavoastră:"

#: src/iterators/iterator.md
#, fuzzy
msgid "\"fib({i}): {n}\""
msgstr "\"fib({i}): {n}\""

#: src/iterators/iterator.md
#, fuzzy
msgid ""
"The `Iterator` trait implements many common functional programming "
"operations over collections (e.g. `map`, `filter`, `reduce`, etc). This is "
"the trait where you can find all the documentation about them. In Rust these "
"functions should produce the code as efficient as equivalent imperative "
"implementations."
msgstr ""
"Caracteristica `Iterator` implementează multe operații comune de programare "
"funcțională asupra colecțiilor (de exemplu, `map`, `filter`, `reduce` etc.). "
"Aceasta este trăsătura în care puteți găsi toată documentația referitoare la "
"acestea. În Rust, aceste funcții ar trebui să producă cod la fel de eficient "
"ca și implementările imperative echivalente."

#: src/iterators/iterator.md
#, fuzzy
msgid ""
"`IntoIterator` is the trait that makes for loops work. It is implemented by "
"collection types such as `Vec<T>` and references to them such as `&Vec<T>` "
"and `&[T]`. Ranges also implement it. This is why you can iterate over a "
"vector with `for i in some_vec { .. }` but `some_vec.next()` doesn't exist."
msgstr ""
"`IntoIterator` este trăsătura care face ca buclele for să funcționeze. Este "
"implementată prin tipuri de colecții, cum ar fi `Vec<T>` și referințe la "
"acestea, cum ar fi `&amp;Vec<T>` și `&amp;[T]`. De asemenea, este "
"implementată și în cazul intervalelor. Acesta este motivul pentru care "
"puteți itera un vector cu `for i in some_vec { ... }`, dar `some_vec.next()` "
"nu există."

#: src/iterators/intoiterator.md
#, fuzzy
msgid ""
"The `Iterator` trait tells you how to _iterate_ once you have created an "
"iterator. The related trait [`IntoIterator`](https://doc.rust-lang.org/std/"
"iter/trait.IntoIterator.html) defines how to create an iterator for a type. "
"It is used automatically by the `for` loop."
msgstr ""
"Trăsătura `Iterator` vă spune cum să _iterați_ după ce ați creat un "
"iterator. Trăsătura conexă `IntoIterator` vă spune cum să creați iteratorul:"

#: src/iterators/intoiterator.md
#, fuzzy
msgid "\"point = {x}, {y}\""
msgstr "\"point = {x}, {y}\""

#: src/iterators/intoiterator.md
#, fuzzy
msgid ""
"Click through to the docs for `IntoIterator`. Every implementation of "
"`IntoIterator` must declare two types:"
msgstr ""
"Sintaxa de aici înseamnă că fiecare implementare a lui `IntoIterator` "
"trebuie să declare două tipuri:"

#: src/iterators/intoiterator.md
#, fuzzy
msgid "`Item`: the type to iterate over, such as `i8`,"
msgstr "`Item`: tipul peste care iterăm, cum ar fi `i8`,"

#: src/iterators/intoiterator.md
#, fuzzy
msgid "`IntoIter`: the `Iterator` type returned by the `into_iter` method."
msgstr "`IntoIter`: tipul `Iterator` returnat de metoda `into_iter`."

#: src/iterators/intoiterator.md
#, fuzzy
msgid ""
"Note that `IntoIter` and `Item` are linked: the iterator must have the same "
"`Item` type, which means that it returns `Option<Item>`"
msgstr ""
"Rețineți că `IntoIter` și `Item` sunt legate: iteratorul trebuie să aibă "
"același tip `Item`, ceea ce înseamnă că returnează `Opțiune`<Item>`"

#: src/iterators/intoiterator.md
#, fuzzy
msgid "The example iterates over all combinations of x and y coordinates."
msgstr "Exemplul itera peste toate combinațiile de coordonate x și y."

#: src/iterators/intoiterator.md
#, fuzzy
msgid ""
"Try iterating over the grid twice in `main`. Why does this fail? Note that "
"`IntoIterator::into_iter` takes ownership of `self`."
msgstr ""
"Încercați să iterați peste grilă de două ori în `main`. De ce nu reușește "
"acest lucru? Rețineți că `IntoIterator::into_iter` preia proprietatea lui "
"`self`."

#: src/iterators/intoiterator.md
#, fuzzy
msgid ""
"Fix this issue by implementing `IntoIterator` for `&Grid` and storing a "
"reference to the `Grid` in `GridIter`."
msgstr ""
"Rezolvați această problemă implementând `IntoIterator` pentru `&Grid` și "
"stocând o referință la `Grid` în `GridIter`."

#: src/iterators/intoiterator.md
#, fuzzy
msgid ""
"The same problem can occur for standard library types: `for e in "
"some_vector` will take ownership of `some_vector` and iterate over owned "
"elements from that vector. Use `for e in &some_vector` instead, to iterate "
"over references to elements of `some_vector`."
msgstr ""
"Aceeași problemă poate apărea și în cazul tipurilor din biblioteca standard: "
"`for e in some_vector` va prelua proprietatea lui `some_vector` și va itera "
"peste elementele deținute din acel vector. Folosiți în schimb `for e in "
"&some_vector` pentru a itera peste referințele la elementele din "
"`some_vector`."

#: src/iterators/fromiterator.md
msgid "FromIterator"
msgstr "FromIterator"

#: src/iterators/fromiterator.md
#, fuzzy
msgid ""
"[`FromIterator`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html) "
"lets you build a collection from an [`Iterator`](https://doc.rust-lang.org/"
"std/iter/trait.Iterator.html)."
msgstr ""
"[`FromIterator`]](https://doc.rust-lang.org/std/iter/trait.FromIterator."
"html) vă permite să construiți o colecție dintr-un [`Iterator`](https://doc."
"rust-lang.org/std/iter/trait.Iterator.html)."

#: src/iterators/fromiterator.md
#, fuzzy
msgid "\"prime_squares: {prime_squares:?}\""
msgstr "\"prime_squares: {prime_squares:?}\""

#: src/iterators/fromiterator.md
#, fuzzy
msgid "`Iterator` implements"
msgstr "`Iterator`"

#: src/iterators/fromiterator.md
#, fuzzy
msgid "There are two ways to specify `B` for this method:"
msgstr "Există două moduri de a specifica `B` pentru această metodă:"

#: src/iterators/fromiterator.md
#, fuzzy
msgid ""
"With the \"turbofish\": `some_iterator.collect::<COLLECTION_TYPE>()`, as "
"shown. The `_` shorthand used here lets Rust infer the type of the `Vec` "
"elements."
msgstr ""
"Cu \"turbofish\": `some_iterator.collect::<COLLECTION_TYPE>()`, după cum se "
"arată. Prescurtarea `_` folosită aici îi permite lui Rust să deducă tipul "
"elementelor `Vec`."

#: src/iterators/fromiterator.md
#, fuzzy
msgid ""
"With type inference: `let prime_squares: Vec<_> = some_iterator.collect()`. "
"Rewrite the example to use this form."
msgstr ""
"Cu inferență de tip: `let prime_squares: Vec<_> = some_iterator.collect()`. "
"Rescrieți exemplul pentru a utiliza această formă."

#: src/iterators/fromiterator.md
#, fuzzy
msgid ""
"There are basic implementations of `FromIterator` for `Vec`, `HashMap`, etc. "
"There are also more specialized implementations which let you do cool things "
"like convert an `Iterator<Item = Result<V, E>>` into a `Result<Vec<V>, E>`."
msgstr ""
"Există, de asemenea, implementări care vă permit să faceți lucruri "
"interesante, cum ar fi convertirea unui `Iterator&lt;Item = Rezultat<V, "
"E>&gt;` într-un `Resultat&lt;Vec<V>, E&gt;`."

#: src/iterators/exercise.md
#, fuzzy
msgid ""
"In this exercise, you will need to find and use some of the provided methods "
"in the [`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) "
"trait to implement a complex calculation."
msgstr ""
"Puteți implementa trăsătura [`Iterator`](https://doc.rust-lang.org/std/iter/"
"trait.Iterator.html) pe propriile tipuri:"

#: src/iterators/exercise.md
#, fuzzy
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and make the tests "
"pass. Use an iterator expression and `collect` the result to construct the "
"return value."
msgstr ""
"Copiați următorul cod în <https://play.rust-lang.org/> și faceți ca testele "
"să treacă. Încercați să evitați să alocați un `Vec` pentru rezultatele "
"intermediare:"

#: src/iterators/exercise.md src/iterators/solution.md
#, fuzzy
msgid ""
"/// Calculate the differences between elements of `values` offset by "
"`offset`,\n"
"/// wrapping around from the end of `values` to the beginning.\n"
"///\n"
"/// Element `n` of the result is `values[(n+offset)%len] - values[n]`.\n"
msgstr ""
"/// Calculează diferențele dintre elementele din `valorile` decalate cu "
"`offset`,\n"
"/// înfășurându-se de la sfârșitul lui `values` la început.\n"
"///\n"
"/// Elementul `n` al rezultatului este `values[(n+offset)%len] - "
"values[n]`.\n"

#: src/modules.md
#, fuzzy
msgid "[Modules](./modules/modules.md) (3 minutes)"
msgstr "[Module](./module/modules/modules.md) (5 minute)"

#: src/modules.md
#, fuzzy
msgid "[Filesystem Hierarchy](./modules/filesystem.md) (5 minutes)"
msgstr "[Ierarhia sistemului de fișiere](./modules/filesystem.md) (5 minute)"

#: src/modules.md
#, fuzzy
msgid "[Visibility](./modules/visibility.md) (5 minutes)"
msgstr "[Vizibilitate](./modules/visibility.md) (5 minute)"

#: src/modules.md
#, fuzzy
msgid "[use, super, self](./modules/paths.md) (10 minutes)"
msgstr "[use, super, self](./modules/paths.md) (10 minute)"

#: src/modules.md
#, fuzzy
msgid ""
"[Exercise: Modules for a GUI Library](./modules/exercise.md) (15 minutes)"
msgstr ""
"[Exercițiu: Module pentru o bibliotecă GUI](./modules/exercise.md) (15 "
"minute)"

#: src/modules/modules.md
#, fuzzy
msgid "We have seen how `impl` blocks let us namespace functions to a type."
msgstr ""
"Am văzut cum blocurile `impl` ne permit să atribuim funcții de namespace la "
"un tip."

#: src/modules/modules.md
#, fuzzy
msgid "Similarly, `mod` lets us namespace types and functions:"
msgstr ""
"În mod similar, `mod` ne permite să folosim tipuri și funcții de spațiu de "
"nume:"

#: src/modules/modules.md
#, fuzzy
msgid "\"In the foo module\""
msgstr "\"În modulul foo\""

#: src/modules/modules.md
#, fuzzy
msgid "\"In the bar module\""
msgstr "\"În modulul de bar\""

#: src/modules/modules.md
#, fuzzy
msgid ""
"Packages provide functionality and include a `Cargo.toml` file that "
"describes how to build a bundle of 1+ crates."
msgstr ""
"Pachetele oferă funcționalitate și includ un fișier `Cargo.toml` care "
"descrie cum se construiește un pachet de 1+ crates."

#: src/modules/modules.md
#, fuzzy
msgid ""
"Crates are a tree of modules, where a binary crate creates an executable and "
"a library crate compiles to a library."
msgstr ""
"Crates reprezintă un arbore de module, în care un crate binar creează un "
"executabil, iar un crate de bibliotecă compilează o bibliotecă."

#: src/modules/modules.md
#, fuzzy
msgid "Modules define organization, scope, and are the focus of this section."
msgstr ""
"Modulele definesc organizarea, domeniul de aplicare și reprezintă punctul "
"central al acestei secțiuni."

#: src/modules/filesystem.md
#, fuzzy
msgid ""
"Omitting the module content will tell Rust to look for it in another file:"
msgstr ""
"Omiterea conținutului modulului îi va spune lui Rust să îl caute într-un alt "
"fișier:"

#: src/modules/filesystem.md
#, fuzzy
msgid ""
"This tells rust that the `garden` module content is found at `src/garden."
"rs`. Similarly, a `garden::vegetables` module can be found at `src/garden/"
"vegetables.rs`."
msgstr ""
"Acest lucru îi spune lui Rust că conținutul modulului `garden` se găsește la "
"`src/garden.rs`. În mod similar, un modul `garden::vegetables` se găsește la "
"`src/garden/vegetables.rs`."

#: src/modules/filesystem.md
#, fuzzy
msgid "The `crate` root is in:"
msgstr "Rădăcina `crate` este în:"

#: src/modules/filesystem.md
#, fuzzy
msgid "`src/lib.rs` (for a library crate)"
msgstr "`src/lib.rs` (pentru o bibliotecă)"

#: src/modules/filesystem.md
#, fuzzy
msgid "`src/main.rs` (for a binary crate)"
msgstr "`src/main.rs` (pentru un crate binar)"

#: src/modules/filesystem.md
#, fuzzy
msgid ""
"Modules defined in files can be documented, too, using \"inner doc "
"comments\". These document the item that contains them -- in this case, a "
"module."
msgstr ""
"Modulele definite în fișiere pot fi, de asemenea, documentate, folosind "
"\"inner doc comments\". Acestea documentează elementul care le conține - în "
"acest caz, un modul."

#: src/modules/filesystem.md
#, fuzzy
msgid ""
"//! This module implements the garden, including a highly performant "
"germination\n"
"//! implementation.\n"
msgstr ""
"//! Acest modul implementează grădina, inclusiv o germinație foarte "
"performantă\n"
"//! foarte performantă.\n"

#: src/modules/filesystem.md
#, fuzzy
msgid "// Re-export types from this module.\n"
msgstr "// Reexportați tipurile din acest modul.\n"

#: src/modules/filesystem.md
#, fuzzy
msgid "/// Sow the given seed packets.\n"
msgstr "/// Semănați pachetele de semințe date.\n"

#: src/modules/filesystem.md
#, fuzzy
msgid "/// Harvest the produce in the garden that is ready.\n"
msgstr "/// Recoltați produsele din grădină care sunt gata.\n"

#: src/modules/filesystem.md
#, fuzzy
msgid ""
"Before Rust 2018, modules needed to be located at `module/mod.rs` instead of "
"`module.rs`, and this is still a working alternative for editions after 2018."
msgstr ""
"Înainte de Rust 2018, modulele trebuiau să fie localizate la `module/mod.rs` "
"în loc de `module.rs`, iar aceasta este încă o alternativă funcțională "
"pentru edițiile după 2018."

#: src/modules/filesystem.md
#, fuzzy
msgid ""
"The main reason to introduce `filename.rs` as alternative to `filename/mod."
"rs` was because many files named `mod.rs` can be hard to distinguish in IDEs."
msgstr ""
"Motivul principal pentru care s-a introdus `filename.rs` ca alternativă la "
"`filename/mod.rs` a fost acela că multe fișiere numite `mod.rs` pot fi greu "
"de distins în IDE-uri."

#: src/modules/filesystem.md
#, fuzzy
msgid "Deeper nesting can use folders, even if the main module is a file:"
msgstr ""
"În cazul în care este vorba de o înglobare mai profundă, se pot utiliza "
"dosare, chiar dacă modulul principal este un fișier:"

#: src/modules/filesystem.md
#, fuzzy
msgid ""
"The place rust will look for modules can be changed with a compiler "
"directive:"
msgstr ""
"Locul în care rust va căuta modulele poate fi schimbat cu o directivă de "
"compilare:"

#: src/modules/filesystem.md
#, fuzzy
msgid "\"some/path.rs\""
msgstr "\"some/path.rs\""

#: src/modules/filesystem.md
#, fuzzy
msgid ""
"This is useful, for example, if you would like to place tests for a module "
"in a file named `some_module_test.rs`, similar to the convention in Go."
msgstr ""
"Acest lucru este util, de exemplu, dacă doriți să plasați testele pentru un "
"modul într-un fișier numit `some_module_test.rs`, similar convenției din Go."

#: src/modules/visibility.md
#, fuzzy
msgid "Modules are a privacy boundary:"
msgstr "Modulele reprezintă o limită de confidențialitate:"

#: src/modules/visibility.md
#, fuzzy
msgid "Module items are private by default (hides implementation details)."
msgstr ""
"Elementele modulului sunt private în mod implicit (ascunde detaliile de "
"implementare)."

#: src/modules/visibility.md
#, fuzzy
msgid "Parent and sibling items are always visible."
msgstr "Elementele părinților și ale fraților sunt întotdeauna vizibile."

#: src/modules/visibility.md
#, fuzzy
msgid ""
"In other words, if an item is visible in module `foo`, it's visible in all "
"the descendants of `foo`."
msgstr ""
"Cu alte cuvinte, dacă un element este vizibil în modulul `foo`, el este "
"vizibil în toți descendenții lui `foo`."

#: src/modules/visibility.md
#, fuzzy
msgid "\"outer::private\""
msgstr "\"outer::private\""

#: src/modules/visibility.md
#, fuzzy
msgid "\"outer::public\""
msgstr "\"outer::public\""

#: src/modules/visibility.md
#, fuzzy
msgid "\"outer::inner::private\""
msgstr "\"outer::inner::private\""

#: src/modules/visibility.md
#, fuzzy
msgid "\"outer::inner::public\""
msgstr "\"outer::inner::public\""

#: src/modules/visibility.md
#, fuzzy
msgid "Use the `pub` keyword to make modules public."
msgstr "Utilizați cuvântul cheie `pub` pentru a face modulele publice."

#: src/modules/visibility.md
#, fuzzy
msgid ""
"Additionally, there are advanced `pub(...)` specifiers to restrict the scope "
"of public visibility."
msgstr ""
"În plus, există specificatori avansați `pub(...)` pentru a restricționa "
"domeniul de aplicare al vizibilității publice."

#: src/modules/visibility.md
#, fuzzy
msgid ""
"See the [Rust Reference](https://doc.rust-lang.org/reference/visibility-and-"
"privacy.html#pubin-path-pubcrate-pubsuper-and-pubself)."
msgstr ""
"A se vedea [Rust Reference](https://doc.rust-lang.org/reference/visibility-"
"and-privacy.html#pubin-path-pubcrate-pubsuper-and-pubself)."

#: src/modules/visibility.md
#, fuzzy
msgid "Configuring `pub(crate)` visibility is a common pattern."
msgstr "Configurarea vizibilității `pub(crate)` este un model comun."

#: src/modules/visibility.md
#, fuzzy
msgid "Less commonly, you can give visibility to a specific path."
msgstr "Mai rar, puteți oferi vizibilitate unei anumite căi de acces."

#: src/modules/visibility.md
#, fuzzy
msgid ""
"In any case, visibility must be granted to an ancestor module (and all of "
"its descendants)."
msgstr ""
"În orice caz, vizibilitatea trebuie să fie acordată unui modul strămoș (și "
"tuturor descendenților săi)."

#: src/modules/paths.md
#, fuzzy
msgid "use, super, self"
msgstr "`use`, `super`, `self`"

#: src/modules/paths.md
#, fuzzy
msgid ""
"A module can bring symbols from another module into scope with `use`. You "
"will typically see something like this at the top of each module:"
msgstr ""
"Un modul poate aduce simboluri dintr-un alt modul în domeniul de aplicare cu "
"`use`. De obicei, veți vedea ceva de genul acesta în partea de sus a "
"fiecărui modul:"

#: src/modules/paths.md
msgid "Paths"
msgstr "Trasee"

#: src/modules/paths.md
#, fuzzy
msgid "Paths are resolved as follows:"
msgstr "Căile de acces se rezolvă după cum urmează:"

#: src/modules/paths.md
#, fuzzy
msgid "As a relative path:"
msgstr "Ca o cale relativă:"

#: src/modules/paths.md
#, fuzzy
msgid "`foo` or `self::foo` refers to `foo` in the current module,"
msgstr "`foo` sau `self::foo` se referă la `foo` din modulul curent,"

#: src/modules/paths.md
#, fuzzy
msgid "`super::foo` refers to `foo` in the parent module."
msgstr "`super::foo` se referă la `foo` din modulul părinte."

#: src/modules/paths.md
#, fuzzy
msgid "As an absolute path:"
msgstr "Ca o cale absolută:"

#: src/modules/paths.md
#, fuzzy
msgid "`crate::foo` refers to `foo` in the root of the current crate,"
msgstr "`crate::foo` se referă la `foo` din rădăcina cratei curente,"

#: src/modules/paths.md
#, fuzzy
msgid "`bar::foo` refers to `foo` in the `bar` crate."
msgstr "`bar::foo` se referă la `foo` din cadrul `bar` crate."

#: src/modules/paths.md
#, fuzzy
msgid ""
"It is common to \"re-export\" symbols at a shorter path. For example, the "
"top-level `lib.rs` in a crate might have"
msgstr ""
"Se obișnuiește să se \"reexporte\" simboluri pe o cale mai scurtă. De "
"exemplu, la nivelul superior `lib.rs` dintr-o cutie poate avea"

#: src/modules/paths.md
#, fuzzy
msgid ""
"making `DiskStorage` and `NetworkStorage` available to other crates with a "
"convenient, short path."
msgstr ""
"făcând ca `DiskStorage` și `NetworkStorage` să fie disponibile pentru alte "
"crates cu o cale scurtă și convenabilă."

#: src/modules/paths.md
#, fuzzy
msgid ""
"For the most part, only items that appear in a module need to be `use`'d. "
"However, a trait must be in scope to call any methods on that trait, even if "
"a type implementing that trait is already in scope. For example, to use the "
"`read_to_string` method on a type implementing the `Read` trait, you need to "
"`use std::io::Read`."
msgstr ""
"În cea mai mare parte, numai elementele care apar într-un modul trebuie să "
"fie \"utilizate\". Cu toate acestea, o trăsătură trebuie să se afle în "
"domeniul de aplicare pentru a apela orice metodă a acelei trăsături, chiar "
"dacă un tip care implementează acea trăsătură se află deja în domeniul de "
"aplicare. De exemplu, pentru a utiliza metoda `read_to_string` pe un tip "
"care implementează trăsătura `Read`, trebuie să `use std::io::Read`."

#: src/modules/paths.md
#, fuzzy
msgid ""
"The `use` statement can have a wildcard: `use std::io::*`. This is "
"discouraged because it is not clear which items are imported, and those "
"might change over time."
msgstr ""
"Instrucțiunea `use` poate avea un wildcard: `use std::io::*`. Acest lucru "
"este descurajat deoarece nu este clar ce elemente sunt importate, iar "
"acestea se pot schimba în timp."

#: src/modules/exercise.md
#, fuzzy
msgid ""
"In this exercise, you will reorganize a small GUI Library implementation. "
"This library defines a `Widget` trait and a few implementations of that "
"trait, as well as a `main` function."
msgstr ""
"În acest exercițiu, veți reorganiza o mică implementare a unei biblioteci "
"GUI. Această bibliotecă definește o trăsătură `Widget` și câteva "
"implementări ale acestei trăsături, precum și o funcție `main`."

#: src/modules/exercise.md
#, fuzzy
msgid ""
"It is typical to put each type or set of closely-related types into its own "
"module, so each widget type should get its own module."
msgstr ""
"De obicei, fiecare tip sau set de tipuri strâns legate între ele este inclus "
"în propriul modul, astfel încât fiecare tip de widget ar trebui să aibă "
"propriul său modul."

#: src/modules/exercise.md
#, fuzzy
msgid "Cargo Setup"
msgstr "Setare"

#: src/modules/exercise.md
#, fuzzy
msgid ""
"The Rust playground only supports one file, so you will need to make a Cargo "
"project on your local filesystem:"
msgstr ""
"Locul de joacă Rust acceptă doar un singur fișier, așa că va trebui să "
"creați un proiect Cargo în sistemul de fișiere local:"

#: src/modules/exercise.md
#, fuzzy
msgid ""
"Edit the resulting `src/main.rs` to add `mod` statements, and add additional "
"files in the `src` directory."
msgstr ""
"Modificați fișierul `src/main.rs` rezultat pentru a adăuga declarațiile "
"`mod` și adăugați fișiere suplimentare în directorul `src`."

#: src/modules/exercise.md
msgid "Source"
msgstr "Sursă"

#: src/modules/exercise.md
#, fuzzy
msgid "Here's the single-module implementation of the GUI library:"
msgstr "Iată implementarea unui singur modul al bibliotecii GUI:"

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "/// Natural width of `self`.\n"
msgstr "/// Lățimea naturală a lui `self`.\n"

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "/// Draw the widget into a buffer.\n"
msgstr "/// Desenați widget-ul într-un buffer.\n"

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "/// Draw the widget on standard output.\n"
msgstr "/// Desenează widget-ul pe ieșirea standard.\n"

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "\"{buffer}\""
msgstr "\"{buffer}\""

#: src/modules/exercise.md
#, fuzzy
msgid "// Add 4 paddings for borders\n"
msgstr "// Adăugați 4 padding-uri pentru margini\n"

#: src/modules/exercise.md
#, fuzzy
msgid ""
"// TODO: Change draw_into to return Result<(), std::fmt::Error>. Then use "
"the\n"
"        // ?-operator here instead of .unwrap().\n"
msgstr ""
"// TODO: Modificați draw_into pentru a returna Result<(), std::fmt::Error>. "
"Apoi, utilizați\n"
"        // ?-operator aici în loc de .unwrap().\n"

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "\"+-{:-<inner_width$}-+\""
msgstr "\"+-{:-<inner_width$}-+\""

#: src/modules/exercise.md src/modules/solution.md src/testing/unit-tests.md
#: src/testing/solution.md
#, fuzzy
msgid "\"\""
msgstr "\"\""

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "\"| {:^inner_width$} |\""
msgstr "\"| {:^inner_width$} |\""

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "\"+={:=<inner_width$}=+\""
msgstr "\"+={:=<inner_width$}=+\""

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "\"| {:inner_width$} |\""
msgstr "\"| {:inner_width$} |\""

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "// add a bit of padding\n"
msgstr "// adăugați un pic de umplutură\n"

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "\"+{:-<width$}+\""
msgstr "\"+{:-<width$}+\""

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "\"|{:^width$}|\""
msgstr "\"|{:^width$}|\""

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "\"Rust GUI Demo 1.23\""
msgstr "\"Rust GUI Demo 1.23\""

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "\"This is a small text GUI demo.\""
msgstr "\"Acesta este un mic text demonstrativ GUI.\""

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "\"Click me!\""
msgstr "\"Faceți clic pe mine!\""

#: src/modules/exercise.md
#, fuzzy
msgid ""
"Encourage students to divide the code in a way that feels natural for them, "
"and get accustomed to the required `mod`, `use`, and `pub` declarations. "
"Afterward, discuss what organizations are most idiomatic."
msgstr ""
"Încurajați elevii să împartă codul într-un mod natural pentru ei și să se "
"obișnuiască cu declarațiile obligatorii `mod`, `use` și `pub`. După aceea, "
"discutați ce organizații sunt cele mai idiomatice."

#: src/modules/solution.md
#, fuzzy
msgid "// ---- src/widgets.rs ----\n"
msgstr "// ---- src/widgets.rs ---- ----\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ---- src/widgets/label.rs ----\n"
msgstr "// ---- src/widgets/label.rs ---- ----\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ANCHOR_END: Label-width\n"
msgstr "// ANCHOR_END: Lățimea etichetei\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ANCHOR: Label-draw_into\n"
msgstr "// ANCHETĂ: Label-draw_into\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ANCHOR_END: Label-draw_into\n"
msgstr "// ANCHOR_END: Eticheta-drapează_în\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ---- src/widgets/button.rs ----\n"
msgstr "// ---- src/widgets/button.rs ---- ----\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ANCHOR_END: Button-width\n"
msgstr "// ANCHOR_END: Lățimea butonului\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ANCHOR: Button-draw_into\n"
msgstr "// ANCHETĂ: Button-draw_into\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ANCHOR_END: Button-draw_into\n"
msgstr "// ANCHOR_END: Buton-draw_into\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ---- src/widgets/window.rs ----\n"
msgstr "// ---- src/widgets/window.rs ---- ----\n"

#: src/modules/solution.md
#, fuzzy
msgid ""
"// ANCHOR_END: Window-width\n"
"        // Add 4 paddings for borders\n"
msgstr ""
"// ANCHOR_END: Lățimea ferestrei\n"
"        // Adăugați 4 padding-uri pentru margini\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ANCHOR: Window-draw_into\n"
msgstr "// ANCHETĂ: Window-draw_into\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ANCHOR_END: Window-draw_into\n"
msgstr "// ANCHOR_END: Window-draw_into\n"

#: src/modules/solution.md
#, fuzzy
msgid ""
"// TODO: after learning about error handling, you can change\n"
"        // draw_into to return Result<(), std::fmt::Error>. Then use\n"
"        // the ?-operator here instead of .unwrap().\n"
msgstr ""
"// TODO: după ce ați învățat despre gestionarea erorilor, puteți schimba\n"
"        // draw_into pentru a returna Result<(), std::fmt::Error>. Apoi, "
"utilizați\n"
"        // operatorul ?- aici în loc de .unwrap().\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ---- src/main.rs ----\n"
msgstr "// ---- src/main.rs ----\n"

#: src/testing.md
#, fuzzy
msgid "[Test Modules](./testing/unit-tests.md) (5 minutes)"
msgstr "[Module de testare](./testing/unit-tests.md) (5 minute)"

#: src/testing.md
#, fuzzy
msgid "[Other Types of Tests](./testing/other.md) (5 minutes)"
msgstr "[Alte tipuri de teste](./testing/other.md) (10 minute)"

#: src/testing.md
#, fuzzy
msgid "[Compiler Lints and Clippy](./testing/lints.md) (3 minutes)"
msgstr "[Compilatorul Lints și Clippy](./testing/lints.md) (5 minute)"

#: src/testing.md
#, fuzzy
msgid "[Exercise: Luhn Algorithm](./testing/exercise.md) (30 minutes)"
msgstr "[Exercițiu: Algoritmul Luhn](./testing/exercițiu.md) (30 minute)"

#: src/testing/unit-tests.md
msgid "Unit Tests"
msgstr "Teste unitare"

#: src/testing/unit-tests.md
#, fuzzy
msgid "Rust and Cargo come with a simple unit test framework:"
msgstr "Rust și Cargo vin cu un cadru simplu de testare a unităților:"

#: src/testing/unit-tests.md
#, fuzzy
msgid "Unit tests are supported throughout your code."
msgstr "Testele unitare sunt acceptate în tot codul dumneavoastră."

#: src/testing/unit-tests.md
#, fuzzy
msgid "Integration tests are supported via the `tests/` directory."
msgstr ""
"Testele de integrare sunt suportate prin intermediul directorului `tests/`."

#: src/testing/unit-tests.md
#, fuzzy
msgid ""
"Tests are marked with `#[test]`. Unit tests are often put in a nested "
"`tests` module, using `#[cfg(test)]` to conditionally compile them only when "
"building tests."
msgstr ""
"Testele sunt marcate cu `#[test]`. Testele unitare sunt deseori plasate într-"
"un modul `tests` imbricate, folosind `#[cfg(test)]` pentru a le compila "
"condiționat numai atunci când se construiesc testele."

#: src/testing/unit-tests.md
#, fuzzy
msgid "\"Hello World\""
msgstr "Bună lume"

#: src/testing/unit-tests.md
#, fuzzy
msgid "This lets you unit test private helpers."
msgstr "Acest lucru vă permite să testați unitar ajutoarele private."

#: src/testing/unit-tests.md
#, fuzzy
msgid "The `#[cfg(test)]` attribute is only active when you run `cargo test`."
msgstr ""
"Atributul `#[cfg(test)]` este activ numai atunci când executați `cargo test`."

#: src/testing/unit-tests.md
#, fuzzy
msgid "Run the tests in the playground in order to show their results."
msgstr ""
"Executați testele în locul de joacă pentru a arăta rezultatele acestora."

#: src/testing/other.md
msgid "Integration Tests"
msgstr "Teste de integrare"

#: src/testing/other.md
#, fuzzy
msgid "If you want to test your library as a client, use an integration test."
msgstr ""
"Dacă doriți să vă testați biblioteca ca și client, utilizați un test de "
"integrare."

#: src/testing/other.md
#, fuzzy
msgid "Create a `.rs` file under `tests/`:"
msgstr "Creați un fișier `.rs` în `tests/`:"

#: src/testing/other.md
#, fuzzy
msgid "// tests/my_library.rs\n"
msgstr "// tests/my_library.rs\n"

#: src/testing/other.md
#, fuzzy
msgid "These tests only have access to the public API of your crate."
msgstr "Aceste teste au acces numai la API-ul public al seriei dumneavoastră."

#: src/testing/other.md
msgid "Documentation Tests"
msgstr "Teste de documentare"

#: src/testing/other.md
#, fuzzy
msgid "Rust has built-in support for documentation tests:"
msgstr "Rust are un suport încorporat pentru testele de documentare:"

#: src/testing/other.md
#, fuzzy
msgid ""
"/// Shortens a string to the given length.\n"
"///\n"
"/// ```\n"
"/// # use playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"
msgstr ""
"```rust\n"
"/// Scurtează un șir de caractere la lungimea dată.\n"
"///\n"
"/// ```\n"
"/// # folosește playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"
"pub fn shorten_string(s: &str, length: usize) -> &str {\n"
"    &s[..std::cmp::min(length, s.len())]]\n"
"}\n"
"```"

#: src/testing/other.md
#, fuzzy
msgid "Code blocks in `///` comments are automatically seen as Rust code."
msgstr ""
"Blocurile de cod din comentariile `///` sunt considerate automat ca fiind "
"cod Rust."

#: src/testing/other.md
#, fuzzy
msgid "The code will be compiled and executed as part of `cargo test`."
msgstr "Codul va fi compilat și executat ca parte din `cargo test`."

#: src/testing/other.md
#, fuzzy
msgid ""
"Adding `#` in the code will hide it from the docs, but will still compile/"
"run it."
msgstr ""
"Adăugarea lui `# ` în cod îl va ascunde din documentație, dar îl va compila/"
"executa în continuare."

#: src/testing/other.md
#, fuzzy
msgid ""
"Test the above code on the [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."
msgstr ""
"Testați codul de mai sus pe [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."

#: src/testing/lints.md
#, fuzzy
msgid ""
"The Rust compiler produces fantastic error messages, as well as helpful "
"built-in lints. [Clippy](https://doc.rust-lang.org/clippy/) provides even "
"more lints, organized into groups that can be enabled per-project."
msgstr ""
"Compilatorul Rust produce mesaje de eroare fantastice, precum și indicații "
"încorporate utile. [Clippy](https://doc.rust-lang.org/clippy/) oferă și mai "
"multe indicii, organizate în grupuri care pot fi activate pentru fiecare "
"proiect în parte."

#: src/testing/lints.md
#, fuzzy
msgid "\"X probably fits in a u16, right? {}\""
msgstr "\"X probabil că încape într-un u16, nu? {}\""

#: src/testing/lints.md
#, fuzzy
msgid ""
"Run the code sample and examine the error message. There are also lints "
"visible here, but those will not be shown once the code compiles. Switch to "
"the Playground site to show those lints."
msgstr ""
"Rulați exemplul de cod și examinați mesajul de eroare. Aici sunt vizibile și "
"linte, dar acestea nu vor fi afișate odată ce codul se compilează. Treceți "
"la site-ul Playground pentru a afișa aceste linte."

#: src/testing/lints.md
#, fuzzy
msgid ""
"After resolving the lints, run `clippy` on the playground site to show "
"clippy warnings. Clippy has extensive documentation of its lints, and adds "
"new lints (including default-deny lints) all the time."
msgstr ""
"După ce ați rezolvat problemele, rulați `clippy` pe site-ul locului de joacă "
"pentru a afișa avertismentele clippy. Clippy are o documentație extinsă a "
"lints-urilor sale și adaugă noi lints (inclusiv lints default-deny) tot "
"timpul."

#: src/testing/lints.md
#, fuzzy
msgid ""
"Note that errors or warnings with `help: ...` can be fixed with `cargo fix` "
"or via your editor."
msgstr ""
"Rețineți că erorile sau avertismentele cu `help: ...` pot fi corectate cu "
"`cargo fix` sau prin intermediul editorului dumneavoastră."

#: src/testing/exercise.md
msgid "Luhn Algorithm"
msgstr "Algoritmul Luhn"

#: src/testing/exercise.md
msgid ""
"The [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm) is used "
"to validate credit card numbers. The algorithm takes a string as input and "
"does the following to validate the credit card number:"
msgstr ""
"[Algoritmul Luhn](https://en.wikipedia.org/wiki/Luhn_algorithm) este "
"utilizat pentru a valida numerele cardurilor de credit. Algoritmul primește "
"un șir de caractere ca intrare și face următoarele operații pentru a valida "
"numărul cardului de credit:"

#: src/testing/exercise.md
#, fuzzy
msgid "Ignore all spaces. Reject number with fewer than two digits."
msgstr "Ignoră toate spațiile. Respinge numărul cu mai puțin de două cifre."

#: src/testing/exercise.md
#, fuzzy
msgid ""
"Moving from **right to left**, double every second digit: for the number "
"`1234`, we double `3` and `1`. For the number `98765`, we double `6` and `8`."
msgstr ""
"Mergând de la **dreapta la stânga**, se dublează fiecare a doua cifră: "
"pentru numărul `1234`, dublăm `3` și `1`. Pentru numărul `98765`, se "
"dublează `6` și `8`."

#: src/testing/exercise.md
msgid ""
"After doubling a digit, sum the digits if the result is greater than 9. So "
"doubling `7` becomes `14` which becomes `1 + 4 = 5`."
msgstr ""
"După ce o cifră a fost dublată, se adună cifrele dacă rezultatul este mai "
"mare de 9. Astfel, când se dublează `7` se obține `14` care devine `1 + 4 = "
"5`."

#: src/testing/exercise.md
msgid "Sum all the undoubled and doubled digits."
msgstr "Se adună toate cifrele nedublate și dublate."

#: src/testing/exercise.md
msgid "The credit card number is valid if the sum ends with `0`."
msgstr "Numărul cardului de credit este valabil dacă suma se termină cu `0`."

#: src/testing/exercise.md
#, fuzzy
msgid ""
"The provided code provides a buggy implementation of the luhn algorithm, "
"along with two basic unit tests that confirm that most the algorithm is "
"implemented correctly."
msgstr ""
"Codul furnizat oferă o implementare eronată a algoritmului luhn, împreună cu "
"două teste unitare de bază care confirmă că majoritatea algoritmului este "
"implementat corect."

#: src/testing/exercise.md
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and write additional "
"tests to uncover bugs in the provided implementation, fixing any bugs you "
"find."
msgstr ""
"Copiați codul de mai jos în <https://play.rust-lang.org/> și completați "
"funcțiile și metodele care lipsesc:"

#: src/testing/exercise.md src/testing/solution.md
#, fuzzy
msgid "\"4263 9826 4026 9299\""
msgstr "\"4263 9826 4026 9299\""

#: src/testing/exercise.md src/testing/solution.md
#, fuzzy
msgid "\"4539 3195 0343 6467\""
msgstr "\"4539 3195 0343 6467\""

#: src/testing/exercise.md src/testing/solution.md
#, fuzzy
msgid "\"7992 7398 713\""
msgstr "\"7992 7398 713\""

#: src/testing/exercise.md src/testing/solution.md
#, fuzzy
msgid "\"4223 9826 4026 9299\""
msgstr "\"4223 9826 4026 9299\""

#: src/testing/exercise.md src/testing/solution.md
#, fuzzy
msgid "\"4539 3195 0343 6476\""
msgstr "\"4539 3195 0343 6476\""

#: src/testing/exercise.md src/testing/solution.md
#, fuzzy
msgid "\"8273 1232 7352 0569\""
msgstr "\"8273 1232 7352 0569\""

#: src/testing/solution.md
#, fuzzy
msgid "// This is the buggy version that appears in the problem.\n"
msgstr "// Aceasta este versiunea cu erori care apare în problemă.\n"

#: src/testing/solution.md
#, fuzzy
msgid "// This is the solution and passes all of the tests below.\n"
msgstr "// Aceasta este soluția și trece toate testele de mai jos.\n"

#: src/testing/solution.md
#, fuzzy
msgid "\"1234 5678 1234 5670\""
msgstr "\"1234 5678 1234 5670\""

#: src/testing/solution.md
#, fuzzy
msgid "\"Is {cc_number} a valid credit card number? {}\""
msgstr "\"Este {cc_number} un număr de card de credit valid? {}\""

#: src/testing/solution.md
#, fuzzy
msgid "\"yes\""
msgstr "Da (inițializat la compilare)"

#: src/testing/solution.md
#, fuzzy
msgid "\"no\""
msgstr "\"nu\""

#: src/testing/solution.md
#, fuzzy
msgid "\"foo 0 0\""
msgstr "\"foo 0 0 0\""

#: src/testing/solution.md
#, fuzzy
msgid "\" \""
msgstr "\" \""

#: src/testing/solution.md
#, fuzzy
msgid "\"  \""
msgstr "\"  \""

#: src/testing/solution.md
#, fuzzy
msgid "\"    \""
msgstr "\"    \""

#: src/testing/solution.md
#, fuzzy
msgid "\"0\""
msgstr "'0'"

#: src/testing/solution.md
#, fuzzy
msgid "\" 0 0 \""
msgstr "\" 0 0 \""

#: src/welcome-day-4-afternoon.md
#, fuzzy
msgid "[Error Handling](./error-handling.md) (55 minutes)"
msgstr "[Gestionarea erorilor](../error-handling.md) (45 minute)"

#: src/welcome-day-4-afternoon.md
#, fuzzy
msgid "[Unsafe Rust](./unsafe-rust.md) (1 hour and 5 minutes)"
msgstr "[Unsafe Rust](../unsafe-rust.md) (1 oră și 5 minute)"

#: src/error-handling.md
#, fuzzy
msgid "[Panics](./error-handling/panics.md) (3 minutes)"
msgstr "[Panici](./error-handling/panics.md) (3 minute)"

#: src/error-handling.md
#, fuzzy
msgid "[Try Operator](./error-handling/try.md) (5 minutes)"
msgstr "[Operator de încercare](./error-handling/try.md) (5 minute)"

#: src/error-handling.md
#, fuzzy
msgid "[Try Conversions](./error-handling/try-conversions.md) (5 minutes)"
msgstr ""
"[Încercați conversiile](./error-handling/try-conversions.md) (5 minute)"

#: src/error-handling.md
#, fuzzy
msgid "[Error Trait](./error-handling/error.md) (5 minutes)"
msgstr "[Error Trait](./error-handling/error.md) (5 minute)"

#: src/error-handling.md
#, fuzzy
msgid ""
"[thiserror and anyhow](./error-handling/thiserror-and-anyhow.md) (5 minutes)"
msgstr ""
"[thiserror and anyhow](./error-handling/thiserror-and-anyhow.md) (5 minute)"

#: src/error-handling.md
#, fuzzy
msgid ""
"[Exercise: Rewriting with Result](./error-handling/exercise.md) (30 minutes)"
msgstr ""
"[Exercițiu: Rescrierea cu rezultat](./error-handling/exercise.md) (20 minute)"

#: src/error-handling/panics.md
#, fuzzy
msgid "Rust handles fatal errors with a \"panic\"."
msgstr "Rust tratează erorile fatale cu un \"panic\"."

#: src/error-handling/panics.md
#, fuzzy
msgid "Rust will trigger a panic if a fatal error happens at runtime:"
msgstr ""
"Rust va declanșa o panică în cazul în care se produce o eroare fatală în "
"timpul execuției:"

#: src/error-handling/panics.md
#, fuzzy
msgid "\"v[100]: {}\""
msgstr "\"v[100]: {}\""

#: src/error-handling/panics.md
#, fuzzy
msgid "Panics are for unrecoverable and unexpected errors."
msgstr "Panica este pentru erori irecuperabile și neașteptate."

#: src/error-handling/panics.md
#, fuzzy
msgid "Panics are symptoms of bugs in the program."
msgstr "Panicile sunt simptome ale unor erori în program."

#: src/error-handling/panics.md
#, fuzzy
msgid "Runtime failures like failed bounds checks can panic"
msgstr ""
"Eșecurile în timpul execuției, cum ar fi verificările eșuate ale limitelor, "
"pot provoca panică"

#: src/error-handling/panics.md
#, fuzzy
msgid "Assertions (such as `assert!`) panic on failure"
msgstr "Afirmațiile (cum ar fi `assert!`) intră în panică în caz de eșec"

#: src/error-handling/panics.md
#, fuzzy
msgid "Purpose-specific panics can use the `panic!` macro."
msgstr "Panicile cu scop specific pot utiliza macroul `panic!`."

#: src/error-handling/panics.md
#, fuzzy
msgid ""
"A panic will \"unwind\" the stack, dropping values just as if the functions "
"had returned."
msgstr ""
"O panică va \"derula\" stiva, eliminând valorile ca și cum funcțiile s-ar fi "
"întors."

#: src/error-handling/panics.md
#, fuzzy
msgid ""
"Use non-panicking APIs (such as `Vec::get`) if crashing is not acceptable."
msgstr ""
"Folosiți API-uri care nu se blochează (cum ar fi `Vec::get`) dacă nu este "
"acceptabilă blocarea."

#: src/error-handling/panics.md
#, fuzzy
msgid ""
"By default, a panic will cause the stack to unwind. The unwinding can be "
"caught:"
msgstr ""
"În mod implicit, o panică va determina derularea stivei. Desfășurarea poate "
"fi prinsă:"

#: src/error-handling/panics.md
#, fuzzy
msgid "\"No problem here!\""
msgstr "\"Nici o problemă aici!\""

#: src/error-handling/panics.md
#, fuzzy
msgid "\"{result:?}\""
msgstr "\"result: {}\""

#: src/error-handling/panics.md
#, fuzzy
msgid "\"oh no!\""
msgstr "\"Oh, nu!\""

#: src/error-handling/panics.md
#, fuzzy
msgid ""
"Catching is unusual; do not attempt to implement exceptions with "
"`catch_unwind`!"
msgstr ""
"Capturarea este neobișnuită; nu încercați să implementați excepții cu "
"`catch_unwind`!"

#: src/error-handling/panics.md
#, fuzzy
msgid ""
"This can be useful in servers which should keep running even if a single "
"request crashes."
msgstr ""
"Acest lucru poate fi util în cazul serverelor care trebuie să continue să "
"funcționeze chiar dacă o singură cerere se blochează."

#: src/error-handling/panics.md
#, fuzzy
msgid "This does not work if `panic = 'abort'` is set in your `Cargo.toml`."
msgstr ""
"Acest lucru nu funcționează dacă `panic = 'abort'` este setat în `Cargo."
"toml`."

#: src/error-handling/try.md
#, fuzzy
msgid ""
"Runtime errors like connection-refused or file-not-found are handled with "
"the `Result` type, but matching this type on every call can be cumbersome. "
"The try-operator `?` is used to return errors to the caller. It lets you "
"turn the common"
msgstr ""
"Erorile în timpul execuției, cum ar fi connection-refused sau file-not-"
"found, sunt tratate cu tipul `Result`, dar potrivirea acestui tip la fiecare "
"apel poate fi greoaie. Operatorul try `?` este utilizat pentru a returna "
"erorile către apelant. Acesta vă permite să transformați opțiunea comună"

#: src/error-handling/try.md
#, fuzzy
msgid "into the much simpler"
msgstr "în mult mai simplu"

#: src/error-handling/try.md
#, fuzzy
msgid "We can use this to simplify our error handling code:"
msgstr ""
"Putem folosi acest lucru pentru a simplifica codul de tratare a erorilor:"

#: src/error-handling/try.md
#, fuzzy
msgid "//fs::write(\"config.dat\", \"alice\").unwrap();\n"
msgstr "//fs::write(\"config.dat\", \"alice\").unwrap();\n"

#: src/error-handling/try.md src/error-handling/try-conversions.md
#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "\"config.dat\""
msgstr "\"config.dat\""

#: src/error-handling/try.md src/error-handling/try-conversions.md
#, fuzzy
msgid "\"username or error: {username:?}\""
msgstr "\"nume de utilizator sau eroare: {username:?}\""

#: src/error-handling/try.md
#, fuzzy
msgid "Simplify the `read_username` function to use `?`."
msgstr "Simplificarea funcției `read_username` pentru a folosi `?`."

#: src/error-handling/try.md
#, fuzzy
msgid "The `username` variable can be either `Ok(string)` or `Err(error)`."
msgstr "Variabila `username` poate fi fie `Ok(string)`, fie `Err(error)`."

#: src/error-handling/try.md
#, fuzzy
msgid ""
"Use the `fs::write` call to test out the different scenarios: no file, empty "
"file, file with username."
msgstr ""
"Utilizați apelul `fs::write` pentru a testa diferite scenarii: niciun "
"fișier, fișier gol, fișier cu nume de utilizator."

#: src/error-handling/try.md
#, fuzzy
msgid ""
"Note that `main` can return a `Result<(), E>` as long as it implements `std::"
"process::Termination`. In practice, this means that `E` implements `Debug`. "
"The executable will print the `Err` variant and return a nonzero exit status "
"on error."
msgstr ""
"Rețineți că `main` poate returna un `Result<(), E>` atâta timp cât "
"implementează `std::process:Termination`. În practică, acest lucru înseamnă "
"că `E` implementează `Debug`. Executabilul va imprima varianta `Err` și va "
"returna o stare de ieșire diferită de zero în caz de eroare."

#: src/error-handling/try-conversions.md
#, fuzzy
msgid ""
"The effective expansion of `?` is a little more complicated than previously "
"indicated:"
msgstr ""
"Extinderea efectivă a lui `?` este puțin mai complicată decât s-a arătat "
"anterior:"

#: src/error-handling/try-conversions.md
#, fuzzy
msgid "works the same as"
msgstr "funcționează la fel ca"

#: src/error-handling/try-conversions.md
#, fuzzy
msgid ""
"The `From::from` call here means we attempt to convert the error type to the "
"type returned by the function. This makes it easy to encapsulate errors into "
"higher-level errors."
msgstr ""
"Apelul `From::from` de aici înseamnă că încercăm să convertim tipul de "
"eroare în tipul returnat de funcție."

#: src/error-handling/try-conversions.md
#, fuzzy
msgid "\"IO error: {e}\""
msgstr "\"Eroare IO: {e}\""

#: src/error-handling/try-conversions.md
#, fuzzy
msgid "\"Found no username in {path}\""
msgstr "\"Nu am găsit niciun nume de utilizator în {path}\""

#: src/error-handling/try-conversions.md
#, fuzzy
msgid "//std::fs::write(\"config.dat\", \"\").unwrap();\n"
msgstr "//fs::write(\"config.dat\", \"\").unwrap();\n"

#: src/error-handling/try-conversions.md
#, fuzzy
msgid ""
"The `?` operator must return a value compatible with the return type of the "
"function. For `Result`, it means that the error types have to be compatible. "
"A function that returns `Result<T, ErrorOuter>` can only use `?` on a value "
"of type `Result<U, ErrorInner>` if `ErrorOuter` and `ErrorInner` are the "
"same type or if `ErrorOuter` implements `From<ErrorInner>`."
msgstr ""
"Operatorul `?` trebuie să returneze o valoare compatibilă cu tipul de retur "
"al funcției. Pentru `Result`, aceasta înseamnă că tipurile de eroare trebuie "
"să fie compatibile. O funcție care returnează `Result<T, ErrorOuter>` poate "
"folosi `?` pentru o valoare de tip `Result<U, ErrorInner>` numai dacă "
"`ErrorOuter` și `ErrorInner` sunt de același tip sau dacă `ErrorOuter` "
"implementează `From<ErrorInner>`."

#: src/error-handling/try-conversions.md
#, fuzzy
msgid ""
"A common alternative to a `From` implementation is `Result::map_err`, "
"especially when the conversion only happens in one place."
msgstr ""
"O alternativă obișnuită la o implementare `From` este `Result::map_err`, în "
"special atunci când conversia are loc într-un singur loc."

#: src/error-handling/try-conversions.md
#, fuzzy
msgid ""
"There is no compatibility requirement for `Option`. A function returning "
"`Option<T>` can use the `?` operator on `Option<U>` for arbitrary `T` and "
"`U` types."
msgstr ""
"Nu există nicio cerință de compatibilitate pentru `Option`. O funcție care "
"returnează `Option<T>` poate utiliza operatorul `?` pe `Option<U>` pentru "
"tipuri arbitrare `T` și `U`."

#: src/error-handling/try-conversions.md
#, fuzzy
msgid ""
"A function that returns `Result` cannot use `?` on `Option` and vice versa. "
"However, `Option::ok_or` converts `Option` to `Result` whereas `Result::ok` "
"turns `Result` into `Option`."
msgstr ""
"O funcție care returnează `Result` nu poate utiliza `?` pentru `Option` și "
"invers. Cu toate acestea, `Option::ok_or` transformă `Option` în `Result`, "
"în timp ce `Result::ok` transformă `Result` în `Option`."

#: src/error-handling/error.md
msgid "Dynamic Error Types"
msgstr "Tipuri de erori dinamice"

#: src/error-handling/error.md
#, fuzzy
msgid ""
"Sometimes we want to allow any type of error to be returned without writing "
"our own enum covering all the different possibilities. The `std::error::"
"Error` trait makes it easy to create a trait object that can contain any "
"error."
msgstr ""
"Uneori dorim să permitem returnarea oricărui tip de eroare fără a scrie "
"propriul nostru enum care să acopere toate posibilitățile diferite. `std::"
"error::Error` facilitează acest lucru."

#: src/error-handling/error.md
#, fuzzy
msgid "\"count.dat\""
msgstr "\"count.dat\""

#: src/error-handling/error.md
#, fuzzy
msgid "\"1i3\""
msgstr "\"1i3\""

#: src/error-handling/error.md
#, fuzzy
msgid "\"Count: {count}\""
msgstr "\"Conte: {count}\""

#: src/error-handling/error.md
#, fuzzy
msgid "\"Error: {err}\""
msgstr "\"Eroare: {err}\""

#: src/error-handling/error.md
#, fuzzy
msgid ""
"The `read_count` function can return `std::io::Error` (from file operations) "
"or `std::num::ParseIntError` (from `String::parse`)."
msgstr ""
"Funcția `read_count` poate returna `std::io::Error` (din operațiile cu "
"fișiere) sau `std::num::ParseIntError` (din `String::parse`)."

#: src/error-handling/error.md
#, fuzzy
msgid ""
"Boxing errors saves on code, but gives up the ability to cleanly handle "
"different error cases differently in the program. As such it's generally not "
"a good idea to use `Box<dyn Error>` in the public API of a library, but it "
"can be a good option in a program where you just want to display the error "
"message somewhere."
msgstr ""
"Acest lucru economisește cod, dar renunță la capacitatea de a trata în mod "
"curat diferite cazuri de eroare în mod diferit în program. Ca atare, în "
"general nu este o idee bună să folosiți `Box<dyn Error>` în API-ul public al "
"unei biblioteci, dar poate fi o opțiune bună într-un program în care doriți "
"doar să afișați mesajul de eroare undeva."

#: src/error-handling/error.md
#, fuzzy
msgid ""
"Make sure to implement the `std::error::Error` trait when defining a custom "
"error type so it can be boxed. But if you need to support the `no_std` "
"attribute, keep in mind that the `std::error::Error` trait is currently "
"compatible with `no_std` in [nightly](https://github.com/rust-lang/rust/"
"issues/103765) only."
msgstr ""
"Asigurați-vă că implementați trăsătura `std::error::Error` atunci când "
"definiți un tip de eroare personalizat, astfel încât acesta să poată fi "
"încadrat. Dar dacă aveți nevoie să suportați atributul `no_std`, rețineți că "
"trăsătura `std::error::Error` este în prezent compatibilă cu `no_std` doar "
"în [nightly](https://github.com/rust-lang/rust/issues/103765)."

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid ""
"The [`thiserror`](https://docs.rs/thiserror/) and [`anyhow`](https://docs.rs/"
"anyhow/) crates are widely used to simplify error handling."
msgstr ""
"Crăiasa [thiserror](https://docs.rs/thiserror/) este o modalitate populară "
"de a crea o enumerație a erorilor, așa cum am făcut pe pagina anterioară:"

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid ""
"`thiserror` is often used in libraries to create custom error types that "
"implement `From<T>`."
msgstr ""
"`thiserror` este adesea utilizat în biblioteci pentru a crea tipuri de erori "
"personalizate care implementează `From<T>`."

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid ""
"`anyhow` is often used by applications to help with error handling in "
"functions, including adding contextual information to your errors."
msgstr ""
"`anyhow` este adesea utilizat de aplicații pentru a ajuta la gestionarea "
"erorilor în funcții, inclusiv adăugarea de informații contextuale la erori."

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "\"Found no username in {0}\""
msgstr "\"Nu am găsit niciun nume de utilizator în {0}\""

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "\"Failed to open {path}\""
msgstr "\"Nu s-a reușit deschiderea {path}\""

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "\"Failed to read\""
msgstr "\"Nu a reușit să citească\""

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "//fs::write(\"config.dat\", \"\").unwrap();\n"
msgstr "//fs::write(\"config.dat\", \"\").unwrap();\n"

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "\"Username: {username}\""
msgstr "\"Nume de utilizator: {username}\""

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "\"Error: {err:?}\""
msgstr "\"Eroare: {err:?}\""

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "`thiserror`"
msgstr "`Error`"

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid ""
"The `Error` derive macro is provided by `thiserror`, and has lots of useful "
"attributes to help define error types in a compact way."
msgstr ""
"Macroul derivat `Error` este furnizat de `thiserror` și are o mulțime de "
"atribute utile pentru a ajuta la definirea tipurilor de erori într-un mod "
"compact."

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "The `std::error::Error` trait is derived automatically."
msgstr "Caracteristica `std::error::Error` este derivată automat."

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "The message from `#[error]` is used to derive the `Display` trait."
msgstr ""
"Mesajul din `#[error]` este utilizat pentru a obține caracteristica "
"`Display`."

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "`anyhow`"
msgstr "\"oricum"

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid ""
"`anyhow::Error` is essentially a wrapper around `Box<dyn Error>`. As such "
"it's again generally not a good choice for the public API of a library, but "
"is widely used in applications."
msgstr ""
"`anyhow::Error` este în esență un înveliș în jurul lui `Box<dyn Error>`. Ca "
"atare, în general, nu este o alegere bună pentru API-ul public al unei "
"biblioteci, dar este utilizat pe scară largă în aplicații."

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "`anyhow::Result<V>` is a type alias for `Result<V, anyhow::Error>`."
msgstr ""
"`anyhow::Result<V>` este un alias de tip pentru `Result<V, anyhow::Error>`."

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid ""
"Actual error type inside of it can be extracted for examination if necessary."
msgstr ""
"Tipul real de eroare din interiorul acestuia poate fi extras pentru "
"examinare, dacă este necesar."

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid ""
"Functionality provided by `anyhow::Result<T>` may be familiar to Go "
"developers, as it provides similar usage patterns and ergonomics to `(T, "
"error)` from Go."
msgstr ""
"Funcționalitatea oferită de `anyhow::Result<T>` poate fi cunoscută "
"dezvoltatorilor Go, deoarece oferă modele de utilizare și ergonomie similare "
"cu `(T, error)` din Go."

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid ""
"`anyhow::Context` is a trait implemented for the standard `Result` and "
"`Option` types. `use anyhow::Context` is necessary to enable `.context()` "
"and `.with_context()` on those types."
msgstr ""
"`anyhow::Context` este o trăsătură implementată pentru tipurile standard "
"`Result` și `Option`. `use anyhow::Context` este necesar pentru a activa `."
"context()` și `.with_context()` pentru aceste tipuri."

#: src/error-handling/exercise.md
#, fuzzy
msgid "Exercise: Rewriting with Result"
msgstr "Exercițiu: rescrierea cu `Result`"

#: src/error-handling/exercise.md
#, fuzzy
msgid ""
"The following implements a very simple parser for an expression language. "
"However, it handles errors by panicking. Rewrite it to instead use idiomatic "
"error handling and propagate errors to a return from `main`. Feel free to "
"use `thiserror` and `anyhow`."
msgstr ""
"Următorul exemplu implementează un parser foarte simplu pentru un limbaj de "
"expresii. Cu toate acestea, acesta gestionează erorile prin panică. "
"Rescrieți-l pentru a utiliza în schimb o gestionare idiomatică a erorilor și "
"pentru a propaga erorile la o întoarcere din `main`. Nu ezitați să folosiți "
"`thiserror` și `anyhow`."

#: src/error-handling/exercise.md
#, fuzzy
msgid ""
"HINT: start by fixing error handling in the `parse` function. Once that is "
"working correctly, update `Tokenizer` to implement "
"`Iterator<Item=Result<Token, TokenizerError>>` and handle that in the parser."
msgstr ""
"SUGESTIE: începeți prin a remedia gestionarea erorilor în funcția `parse`. "
"Odată ce aceasta funcționează corect, actualizați `Tokenizer` pentru a "
"implementa `Iterator<Item=Result<Token, TokenizerError>>`` și gestionați "
"acest lucru în parser."

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "/// An arithmetic operator.\n"
msgstr "/// Un operator aritmetic.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "/// A token in the expression language.\n"
msgstr "/// Un simbol în limbajul de exprimare.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "/// An expression in the expression language.\n"
msgstr "/// O expresie în limbajul de expresie.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "/// A reference to a variable.\n"
msgstr "/// O referință la o variabilă.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "/// A literal number.\n"
msgstr "/// Un număr literal.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "/// A binary operation.\n"
msgstr "/// O operațiune binară.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "'_'"
msgstr "'_'"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "'+'"
msgstr "'+'"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "'-'"
msgstr "'-'"

#: src/error-handling/exercise.md
#, fuzzy
msgid "\"Unexpected character {c}\""
msgstr "\"Caracter neașteptat {c}\""

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "\"Unexpected end of input\""
msgstr "\"Sfârșitul neașteptat al intrării\""

#: src/error-handling/exercise.md
#, fuzzy
msgid "\"Invalid 32-bit integer'\""
msgstr "\"Număr întreg de 32 de biți invalid\""

#: src/error-handling/exercise.md
#, fuzzy
msgid "\"Unexpected token {tok:?}\""
msgstr "\"Jetoane neașteptate {tok:?}\""

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "// Look ahead to parse a binary operation if present.\n"
msgstr ""
"// Se uită înainte pentru a analiza o operațiune binară, dacă este "
"prezentă.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "\"10+foo+20-30\""
msgstr "\"10+foo+20-30\""

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "\"{expr:?}\""
msgstr "\"{expr:?}\""

#: src/error-handling/solution.md
#, fuzzy
msgid "\"Unexpected character '{0}' in input\""
msgstr "\"Caracter neașteptat \"{0}\" în intrare\""

#: src/error-handling/solution.md
#, fuzzy
msgid "\"Tokenizer error: {0}\""
msgstr "\"Eroare de tokenizare: {0}\""

#: src/error-handling/solution.md
#, fuzzy
msgid "\"Unexpected token {0:?}\""
msgstr "\"Jetoane neașteptate {0:?}\""

#: src/error-handling/solution.md
#, fuzzy
msgid "\"Invalid number\""
msgstr "\"Număr invalid\""

#: src/unsafe-rust.md
#, fuzzy
msgid "[Unsafe](./unsafe-rust/unsafe.md) (5 minutes)"
msgstr "[Nesigur](./unsafe-rust/unsafe.md) (5 minute)"

#: src/unsafe-rust.md
#, fuzzy
msgid ""
"[Dereferencing Raw Pointers](./unsafe-rust/dereferencing.md) (10 minutes)"
msgstr ""
"[Dereferențierea pointerilor brute](./unsafe-rust/dereferencing.md) (10 "
"minute)"

#: src/unsafe-rust.md
#, fuzzy
msgid "[Mutable Static Variables](./unsafe-rust/mutable-static.md) (5 minutes)"
msgstr ""
"[Variabile statice mutabile](./unsafe-rust/mutable-static.md) (5 minute)"

#: src/unsafe-rust.md
#, fuzzy
msgid "[Unions](./unsafe-rust/unions.md) (5 minutes)"
msgstr "[Uniuni](./unsafe-rust/unions.md) (5 minute)"

#: src/unsafe-rust.md
#, fuzzy
msgid "[Unsafe Functions](./unsafe-rust/unsafe-functions.md) (5 minutes)"
msgstr "[Funcții nesigure](./unsafe-rust/unsafe-functions.md) (5 minute)"

#: src/unsafe-rust.md
#, fuzzy
msgid "[Unsafe Traits](./unsafe-rust/unsafe-traits.md) (5 minutes)"
msgstr "[Trăsături nesigure](./unsafe-rust/unsafe-traits.md) (5 minute)"

#: src/unsafe-rust.md
msgid "[Exercise: FFI Wrapper](./unsafe-rust/exercise.md) (30 minutes)"
msgstr "[Exercițiu: Împachetare FFI](./unsafe-rust/exercise.md) (30 minute)"

#: src/unsafe-rust.md
msgid "This segment should take about 1 hour and 5 minutes"
msgstr "Acest segment ar trebui să dureze aproximativ 1 oră și 5 minute"

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid "The Rust language has two parts:"
msgstr "Limbajul Rust are două părți:"

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid "**Safe Rust:** memory safe, no undefined behavior possible."
msgstr "**Safe Rust:** sigur în memorie, fără comportament nedefinit posibil."

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid ""
"**Unsafe Rust:** can trigger undefined behavior if preconditions are "
"violated."
msgstr ""
"**Unsafe Rust:** poate declanșa un comportament nedefinit dacă sunt "
"încălcate condițiile prealabile."

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid ""
"We saw mostly safe Rust in this course, but it's important to know what "
"Unsafe Rust is."
msgstr ""
"În acest curs vom vedea mai ales Rust sigur, dar este important să știm ce "
"este Rust nesigur."

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid ""
"Unsafe code is usually small and isolated, and its correctness should be "
"carefully documented. It is usually wrapped in a safe abstraction layer."
msgstr ""
"Codul nesigur este, de obicei, mic și izolat, iar corectitudinea sa trebuie "
"documentată cu atenție. Acesta este de obicei acoperit de un strat de "
"abstractizare sigur."

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid "Unsafe Rust gives you access to five new capabilities:"
msgstr "Unsafe Rust vă oferă acces la cinci noi capacități:"

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid "Dereference raw pointers."
msgstr "Dereferențierea indicatoarelor brute."

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid "Access or modify mutable static variables."
msgstr "Accesarea sau modificarea variabilelor statice mutabile."

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid "Access `union` fields."
msgstr "Accesați câmpurile `union`."

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid "Call `unsafe` functions, including `extern` functions."
msgstr "Apelarea funcțiilor `unsafe`, inclusiv a funcțiilor `extern`."

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid "Implement `unsafe` traits."
msgstr "Implementarea trăsăturilor `unsafe`."

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid ""
"We will briefly cover unsafe capabilities next. For full details, please see "
"[Chapter 19.1 in the Rust Book](https://doc.rust-lang.org/book/ch19-01-"
"unsafe-rust.html) and the [Rustonomicon](https://doc.rust-lang.org/nomicon/)."
msgstr ""
"În continuare vom aborda pe scurt capacitățile nesigure. Pentru detalii "
"complete, vă rugăm să consultați [Capitolul 19.1 din Rust Book](https://doc."
"rust-lang.org/book/ch19-01-unsafe-rust.html) și [Rustonomicon](https://doc."
"rust-lang.org/nomicon/)."

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid ""
"Unsafe Rust does not mean the code is incorrect. It means that developers "
"have turned off some compiler safety features and have to write correct code "
"by themselves. It means the compiler no longer enforces Rust's memory-safety "
"rules."
msgstr ""
"Unsafe Rust nu înseamnă că codul este incorect. Înseamnă că dezvoltatorii au "
"dezactivat caracteristicile de siguranță ale compilatorului și trebuie să "
"scrie singuri codul corect. Înseamnă că compilatorul nu mai aplică regulile "
"de siguranță a memoriei din Rust."

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid "Creating pointers is safe, but dereferencing them requires `unsafe`:"
msgstr ""
"Crearea de pointeri este sigură, dar dereferențierea lor necesită `unsafe`:"

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid "\"careful!\""
msgstr "\"Atenție!\""

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid ""
"// SAFETY: r1 and r2 were obtained from references and so are guaranteed to\n"
"    // be non-null and properly aligned, the objects underlying the "
"references\n"
"    // from which they were obtained are live throughout the whole unsafe\n"
"    // block, and they are not accessed either through the references or\n"
"    // concurrently through any other pointers.\n"
msgstr ""
"```rust,editabil\n"
"fn main() {\n"
"    let mut num = 5;\n"
"\n"
"    let r1 = &mut num as *mut i32;\n"
"    let r2 = r1 as *const i32;\n"
"\n"
"    // Sigur, deoarece r1 și r2 au fost obținute din referințe și deci sunt\n"
"    // garantate ca fiind non-null și aliniate corespunzător, obiectele care "
"stau la baza lor\n"
"    // referințele din care au fost obținute sunt vii pe tot parcursul\n"
"    // întregul bloc nesigur, și nu sunt accesate nici prin intermediul "
"blocului\n"
"    // referințe, nici în același timp prin intermediul altor pointeri.\n"
"    unsafe {\n"
"        println!(\"r1 este: {}\", *r1);\n"
"        *r1 = 10;\n"
"        println!(\"r2 este: {}\", *r2);\n"
"    }\n"
"}\n"
"```"

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid "\"r1 is: {}\""
msgstr "\"r1 este: {}\""

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid "\"uhoh\""
msgstr "\"uhoh\""

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid "\"r2 is: {}\""
msgstr "\"r2 este: {}\""

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid ""
"// NOT SAFE. DO NOT DO THIS.\n"
"    /*\n"
"    let r3: &String = unsafe { &*r1 };\n"
"    drop(s);\n"
"    println!(\"r3 is: {}\", *r3);\n"
"    */"
msgstr ""
"// NU ESTE SIGUR. NU FACEȚI ACEST LUCRU.\n"
"    /*\n"
"    let r3: &String = unsafe { &*r1 };\n"
"    drop(s);\n"
"    println!(\"r3 este: {}\", *r3);\n"
"    */"

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid ""
"It is good practice (and required by the Android Rust style guide) to write "
"a comment for each `unsafe` block explaining how the code inside it "
"satisfies the safety requirements of the unsafe operations it is doing."
msgstr ""
"Este o bună practică (și este cerută de ghidul de stil Android Rust) să "
"scrieți un comentariu pentru fiecare bloc `unsafe`, explicând modul în care "
"codul din interiorul acestuia îndeplinește cerințele de siguranță ale "
"operațiilor nesigure pe care le efectuează."

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid ""
"In the case of pointer dereferences, this means that the pointers must be "
"[_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), i.e.:"
msgstr ""
"În cazul dereferențierii pointerilor, aceasta înseamnă că pointerii trebuie "
"să fie [_valabili_](https://doc.rust-lang.org/std/ptr/index.html#safety), "
"adică:"

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid "The pointer must be non-null."
msgstr "Pointerul trebuie să nu fie nul."

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid ""
"The pointer must be _dereferenceable_ (within the bounds of a single "
"allocated object)."
msgstr ""
"Pointerul trebuie să fie _dereferențiabil_ (în limitele unui singur obiect "
"alocat)."

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid "The object must not have been deallocated."
msgstr "Obiectul nu trebuie să fi fost dezalocat."

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid "There must not be concurrent accesses to the same location."
msgstr "Nu trebuie să existe accese simultane la aceeași locație."

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid ""
"If the pointer was obtained by casting a reference, the underlying object "
"must be live and no reference may be used to access the memory."
msgstr ""
"În cazul în care pointerul a fost obținut prin turnarea unei referințe, "
"obiectul subiacent trebuie să fie viu și nu se poate utiliza nicio referință "
"pentru a accesa memoria."

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid "In most cases the pointer must also be properly aligned."
msgstr ""
"În cele mai multe cazuri, indicatorul trebuie, de asemenea, să fie bine "
"aliniat."

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid ""
"The \"NOT SAFE\" section gives an example of a common kind of UB bug: `*r1` "
"has the `'static` lifetime, so `r3` has type `&'static String`, and thus "
"outlives `s`. Creating a reference from a pointer requires _great care_."
msgstr ""
"Secțiunea \"NOT SAFE\" oferă un exemplu de un tip comun de eroare UB: `*r1` "
"are durata de viață `'static`, astfel încât `r3` are tipul `&'static String` "
"și, prin urmare, trăiește mai mult decât `s`. Crearea unei referințe dintr-"
"un pointer necesită _grea atenție_."

#: src/unsafe-rust/mutable-static.md
#, fuzzy
msgid "It is safe to read an immutable static variable:"
msgstr "Este sigur să citiți o variabilă statică imuabilă:"

#: src/unsafe-rust/mutable-static.md
#, fuzzy
msgid "\"Hello, world!\""
msgstr "Bună lume"

#: src/unsafe-rust/mutable-static.md
#, fuzzy
msgid "\"HELLO_WORLD: {HELLO_WORLD}\""
msgstr "\"HELLO_WORLD: {HELLO_WORLD}\""

#: src/unsafe-rust/mutable-static.md
#, fuzzy
msgid ""
"However, since data races can occur, it is unsafe to read and write mutable "
"static variables:"
msgstr ""
"Cu toate acestea, deoarece pot apărea curse de date, nu este sigur să se "
"citească și să se scrie variabilele statice mutabile:"

#: src/unsafe-rust/mutable-static.md
#, fuzzy
msgid ""
"// SAFETY: There are no other threads which could be accessing `COUNTER`.\n"
msgstr "// SIGURANȚĂ: Nu există alte fire care ar putea accesa `COUNTER`.\n"

#: src/unsafe-rust/mutable-static.md
#, fuzzy
msgid "\"COUNTER: {COUNTER}\""
msgstr "\"COUNTER: {COUNTER}\""

#: src/unsafe-rust/mutable-static.md
#, fuzzy
msgid ""
"The program here is safe because it is single-threaded. However, the Rust "
"compiler is conservative and will assume the worst. Try removing the "
"`unsafe` and see how the compiler explains that it is undefined behavior to "
"mutate a static from multiple threads."
msgstr ""
"Programul de aici este sigur, deoarece are un singur fir de execuție. Cu "
"toate acestea, compilatorul Rust este conservator și va presupune ce este "
"mai rău. Încercați să eliminați `unsafe` și să vedeți cum compilatorul "
"explică faptul că este un comportament nedefinit să mutați o statică din mai "
"multe fire de execuție."

#: src/unsafe-rust/mutable-static.md
#, fuzzy
msgid ""
"Using a mutable static is generally a bad idea, but there are some cases "
"where it might make sense in low-level `no_std` code, such as implementing a "
"heap allocator or working with some C APIs."
msgstr ""
"Utilizarea unui static mutabil este, în general, o idee proastă, dar există "
"unele cazuri în care ar putea avea sens în codul `no_std` de nivel scăzut, "
"cum ar fi implementarea unui alocator de heap sau lucrul cu unele API-uri C."

#: src/unsafe-rust/unions.md
#, fuzzy
msgid "Unions are like enums, but you need to track the active field yourself:"
msgstr ""
"Uniunile sunt ca și enumerațiile, dar trebuie să urmăriți singur câmpul "
"activ:"

#: src/unsafe-rust/unions.md
#, fuzzy
msgid "\"int: {}\""
msgstr "\"int: {}\""

#: src/unsafe-rust/unions.md
#, fuzzy
msgid "\"bool: {}\""
msgstr "\"bool: {}\""

#: src/unsafe-rust/unions.md
#, fuzzy
msgid "// Undefined behavior!\n"
msgstr "Nici un comportament nedefinit în timpul execuției:"

#: src/unsafe-rust/unions.md
#, fuzzy
msgid ""
"Unions are very rarely needed in Rust as you can usually use an enum. They "
"are occasionally needed for interacting with C library APIs."
msgstr ""
"Uniunile sunt foarte rar necesare în Rust, deoarece puteți utiliza de obicei "
"un enum. Ele sunt ocazional necesare pentru a interacționa cu API-urile "
"bibliotecilor C."

#: src/unsafe-rust/unions.md
#, fuzzy
msgid ""
"If you just want to reinterpret bytes as a different type, you probably want "
"[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn."
"transmute.html) or a safe wrapper such as the [`zerocopy`](https://crates.io/"
"crates/zerocopy) crate."
msgstr ""
"Dacă doriți doar să reinterpretați octeții ca fiind de un tip diferit, "
"probabil că doriți [`std::mem::transmute`](https://doc.rust-lang.org/stable/"
"std/mem/fn.transmute.html) sau un înveliș sigur, cum ar fi [`zerocopy`]"
"(https://crates.io/crates/zerocopy)."

#: src/unsafe-rust/unsafe-functions.md
msgid "Calling Unsafe Functions"
msgstr "Apelarea funcțiilor nesigure"

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"A function or method can be marked `unsafe` if it has extra preconditions "
"you must uphold to avoid undefined behaviour:"
msgstr ""
"O funcție sau o metodă poate fi marcată `unsafe` dacă are condiții "
"prealabile suplimentare pe care trebuie să le respectați pentru a evita un "
"comportament nedefinit:"

#: src/unsafe-rust/unsafe-functions.md src/unsafe-rust/exercise.md
#: src/unsafe-rust/solution.md src/android/interoperability/with-c.md
#: src/android/interoperability/with-c/rust.md
#: src/android/interoperability/cpp/cpp-bridge.md
#: src/exercises/chromium/build-rules.md src/bare-metal/aps/inline-assembly.md
#: src/bare-metal/aps/better-uart/using.md src/bare-metal/aps/logging/using.md
#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "\"C\""
msgstr "\"C\""

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid "\"🗻∈🌏\""
msgstr "\"🗻∈🌏\""

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"// SAFETY: The indices are in the correct order, within the bounds of the\n"
"    // string slice, and lie on UTF-8 sequence boundaries.\n"
msgstr ""
"// Sigur, deoarece indicii sunt în ordinea corectă, în limitele lui\n"
"    // șirului de caractere și se află pe limitele secvenței UTF-8.\n"

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid "\"emoji: {}\""
msgstr "\"emoji: {}\""

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid "\"char count: {}\""
msgstr "\"char count: {}\""

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"// SAFETY: `abs` doesn't deal with pointers and doesn't have any safety\n"
"    // requirements.\n"
msgstr ""
"// SIGURANȚĂ: `abs` nu se ocupă de pointeri și nu are nicio siguranță\n"
"    // cerințe.\n"

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid "\"Absolute value of -3 according to C: {}\""
msgstr "\"Valoarea absolută a lui -3 în conformitate cu C: {}\""

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"// Not upholding the UTF-8 encoding requirement breaks memory safety!\n"
"    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
"    // println!(\"char count: {}\", count_chars(unsafe {\n"
"    // emojis.get_unchecked(0..3) }));\n"
msgstr ""
"// Nerespectarea cerinței de codificare UTF-8 încalcă siguranța memoriei!\n"
"    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
"    // println!(\"char count: {}\", count_chars(unsafe {\n"
"    // emojis.get_ununchecked(0..3) }));\n"

#: src/unsafe-rust/unsafe-functions.md
msgid "Writing Unsafe Functions"
msgstr "Scrierea funcțiilor nesigure"

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"You can mark your own functions as `unsafe` if they require particular "
"conditions to avoid undefined behaviour."
msgstr ""
"Puteți marca propriile funcții ca fiind \"nesigure\" dacă acestea necesită "
"anumite condiții pentru a evita un comportament nedefinit."

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"/// Swaps the values pointed to by the given pointers.\n"
"///\n"
"/// # Safety\n"
"///\n"
"/// The pointers must be valid and properly aligned.\n"
msgstr ""
"/// Schimbă valorile indicate de indicatoarele date.\n"
"///\n"
"/// # Siguranță\n"
"///\n"
"/// Punctele trebuie să fie valide și aliniate corespunzător.\n"

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid "// SAFETY: ...\n"
msgstr "// ...\n"

#: src/unsafe-rust/unsafe-functions.md
msgid "\"a = {}, b = {}\""
msgstr "\"a = {}, b = {}\""

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"`get_unchecked`, like most `_unchecked` functions, is unsafe, because it can "
"create UB if the range is incorrect. `abs` is incorrect for a different "
"reason: it is an external function (FFI). Calling external functions is "
"usually only a problem when those functions do things with pointers which "
"might violate Rust's memory model, but in general any C function might have "
"undefined behaviour under any arbitrary circumstances."
msgstr ""
"Aceasta este de obicei o problemă doar pentru funcțiile externe care fac "
"lucruri cu pointeri care ar putea încălca modelul de memorie Rust, dar în "
"general orice funcție C poate avea un comportament nedefinit în orice "
"circumstanțe arbitrare."

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"The `\"C\"` in this example is the ABI; [other ABIs are available too]"
"(https://doc.rust-lang.org/reference/items/external-blocks.html)."
msgstr ""
"În acest exemplu, `\"C\"` este ABI; [sunt disponibile și alte ABI-uri]"
"(https://doc.rust-lang.org/reference/items/external-blocks.html)."

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"We wouldn't actually use pointers for a `swap` function - it can be done "
"safely with references."
msgstr ""
"De fapt, nu vom folosi pointeri pentru acest lucru, deoarece acest lucru "
"poate fi realizat în siguranță cu referințe."

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"Note that unsafe code is allowed within an unsafe function without an "
"`unsafe` block. We can prohibit this with `#[deny(unsafe_op_in_unsafe_fn)]`. "
"Try adding it and see what happens. This will likely change in a future Rust "
"edition."
msgstr ""
"Rețineți că codul nesigur este permis în cadrul unei funcții nesigure fără "
"un bloc `unsafe`. Putem interzice acest lucru cu "
"`#[deny(unsafe_op_in_unsafe_fn)]`. Încercați să-l adăugați și vedeți ce se "
"întâmplă."

#: src/unsafe-rust/unsafe-traits.md
msgid "Implementing Unsafe Traits"
msgstr "Implementarea trăsăturilor nesigure"

#: src/unsafe-rust/unsafe-traits.md
#, fuzzy
msgid ""
"Like with functions, you can mark a trait as `unsafe` if the implementation "
"must guarantee particular conditions to avoid undefined behaviour."
msgstr ""
"Ca și în cazul funcțiilor, puteți marca o trăsătură ca fiind \"nesigură\" "
"dacă implementarea trebuie să garanteze anumite condiții pentru a evita un "
"comportament nedefinit."

#: src/unsafe-rust/unsafe-traits.md
#, fuzzy
msgid ""
"For example, the `zerocopy` crate has an unsafe trait that looks [something "
"like this](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html):"
msgstr ""
"De exemplu, categoria `zerocopy` are o trăsătură nesigură care arată [ceva "
"de genul acesta](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes."
"html):"

#: src/unsafe-rust/unsafe-traits.md
#, fuzzy
msgid ""
"/// ...\n"
"/// # Safety\n"
"/// The type must have a defined representation and no padding.\n"
msgstr ""
"/// ...\n"
"/// # Siguranță\n"
"/// Tipul trebuie să aibă o reprezentare definită și să nu aibă umplutură.\n"

#: src/unsafe-rust/unsafe-traits.md
#, fuzzy
msgid "// SAFETY: `u32` has a defined representation and no padding.\n"
msgstr ""
"// Sigur, deoarece u32 are o reprezentare definită și nu are umplutură.\n"

#: src/unsafe-rust/unsafe-traits.md
#, fuzzy
msgid ""
"There should be a `# Safety` section on the Rustdoc for the trait explaining "
"the requirements for the trait to be safely implemented."
msgstr ""
"Ar trebui să existe o secțiune `# Siguranță` în Rustdoc pentru trăsătura "
"care să explice cerințele pentru ca trăsătura să fie implementată în "
"siguranță."

#: src/unsafe-rust/unsafe-traits.md
#, fuzzy
msgid ""
"The actual safety section for `AsBytes` is rather longer and more "
"complicated."
msgstr ""
"Secțiunea de siguranță efectivă pentru `AsBytes` este mai lungă și mai "
"complicată."

#: src/unsafe-rust/unsafe-traits.md
#, fuzzy
msgid "The built-in `Send` and `Sync` traits are unsafe."
msgstr "Trăsăturile încorporate `Send` și `Sync` sunt nesigure."

#: src/unsafe-rust/exercise.md
msgid "Safe FFI Wrapper"
msgstr "Înfășurătorul FFI sigur"

#: src/unsafe-rust/exercise.md
msgid ""
"Rust has great support for calling functions through a _foreign function "
"interface_ (FFI). We will use this to build a safe wrapper for the `libc` "
"functions you would use from C to read the names of files in a directory."
msgstr ""
"Rust are un suport excelent pentru apelarea funcțiilor prin intermediul unei "
"interfețe de funcții străine (FFI). Vom folosi acest lucru pentru a construi "
"un înveliș sigur pentru funcțiile `libc` pe care le-ați folosi din C pentru "
"a citi numele fișierelor dintr-un director."

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "You will want to consult the manual pages:"
msgstr "Va trebui să consultați paginile din manual:"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "[`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)"
msgstr "[`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "[`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)"
msgstr "[`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "[`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"
msgstr "[`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid ""
"You will also want to browse the [`std::ffi`](https://doc.rust-lang.org/std/"
"ffi/) module. There you find a number of string types which you need for the "
"exercise:"
msgstr ""
"De asemenea, veți dori să navigați în modulul [`std::ffi`](https://doc.rust-"
"lang.org/std/ffi/). Acolo veți găsi o serie de tipuri de șiruri de caractere "
"de care aveți nevoie pentru exercițiu:"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "Encoding"
msgstr "Codificare"

#: src/unsafe-rust/exercise.md
msgid "Use"
msgstr "Folosește"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid ""
"[`str`](https://doc.rust-lang.org/std/primitive.str.html) and [`String`]"
"(https://doc.rust-lang.org/std/string/struct.String.html)"
msgstr ""
"[`str`](https://doc.rust-lang.org/std/primitive.str.html) și [`String`]"
"(https://doc.rust-lang.org/std/string/struct.String.html)"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "UTF-8"
msgstr ""
"Șirurile de caractere Rust sunt codificate UTF-8 și pot conține orice "
"caracter Unicode."

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "Text processing in Rust"
msgstr "Prelucrarea textului în Rust"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid ""
"[`CStr`](https://doc.rust-lang.org/std/ffi/struct.CStr.html) and [`CString`]"
"(https://doc.rust-lang.org/std/ffi/struct.CString.html)"
msgstr ""
"[`CStr`](https://doc.rust-lang.org/std/ffi/struct.CStr.html) și [`CString`]"
"(https://doc.rust-lang.org/std/ffi/struct.CString.html)"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "NUL-terminated"
msgstr "Terminat cu NUL"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "Communicating with C functions"
msgstr "Comunicarea cu funcțiile C"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid ""
"[`OsStr`](https://doc.rust-lang.org/std/ffi/struct.OsStr.html) and "
"[`OsString`](https://doc.rust-lang.org/std/ffi/struct.OsString.html)"
msgstr ""
"[`OsStr`](https://doc.rust-lang.org/std/ffi/struct.OsStr.html) și "
"[`OsString`](https://doc.rust-lang.org/std/ffi/struct.OsString.html)"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "OS-specific"
msgstr "Specific sistemului de operare"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "Communicating with the OS"
msgstr "Comunicarea cu sistemul de operare"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "You will convert between all these types:"
msgstr "Veți face conversia între toate aceste tipuri:"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid ""
"`&str` to `CString`: you need to allocate space for a trailing `\\0` "
"character,"
msgstr ""
"`&str` în `CString`: trebuie să alocați spațiu pentru un caracter `\\0` la "
"sfârșit,"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "`CString` to `*const i8`: you need a pointer to call C functions,"
msgstr ""
"`CString` la `*const i8`: aveți nevoie de un pointer pentru a apela "
"funcțiile C,"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid ""
"`*const i8` to `&CStr`: you need something which can find the trailing `\\0` "
"character,"
msgstr ""
"`*const i8` la `&CStr`: aveți nevoie de ceva care să poată găsi caracterul "
"`\\0` din urmă,"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid ""
"`&CStr` to `&[u8]`: a slice of bytes is the universal interface for \"some "
"unknown data\","
msgstr ""
"`&CStr` la `&[u8]`: o porțiune de octeți este interfața universală pentru "
"\"unele date necunoscute\","

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid ""
"`&[u8]` to `&OsStr`: `&OsStr` is a step towards `OsString`, use [`OsStrExt`]"
"(https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html) to create it,"
msgstr ""
"`&&[u8]` la `&OsStr`: `&OsStr` este un pas spre `OsString`, utilizați "
"[`OsStrExt`](https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html) "
"pentru a-l crea,"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid ""
"`&OsStr` to `OsString`: you need to clone the data in `&OsStr` to be able to "
"return it and call `readdir` again."
msgstr ""
"`&OsStr` în `OsString`: trebuie să clonați datele din `&OsStr` pentru a le "
"putea returna și a apela din nou `readdir`."

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid ""
"The [Nomicon](https://doc.rust-lang.org/nomicon/ffi.html) also has a very "
"useful chapter about FFI."
msgstr ""
"[Nomicon](https://doc.rust-lang.org/nomicon/ffi.html) are, de asemenea, un "
"capitol foarte util despre FFI."

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing "
"functions and methods:"
msgstr ""
"Copiați codul de mai jos în <https://play.rust-lang.org/> și completați "
"funcțiile și metodele care lipsesc:"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#, fuzzy
msgid "\"macos\""
msgstr "\"macos\""

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#, fuzzy
msgid "// Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
msgstr "// Tip opac. A se vedea https://doc.rust-lang.org/nomicon/ffi.html.\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#, fuzzy
msgid ""
"// Layout according to the Linux man page for readdir(3), where ino_t and\n"
"    // off_t are resolved according to the definitions in\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"
msgstr ""
"// Dispunere în conformitate cu pagina de manual Linux pentru readdir(3), "
"unde ino_t și\n"
"    // off_t sunt rezolvate în conformitate cu definițiile din\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#, fuzzy
msgid "// Layout according to the macOS man page for dir(5).\n"
msgstr ""
"// Dispunere în conformitate cu pagina de manual macOS pentru dir(5).\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#, fuzzy
msgid "\"x86_64\""
msgstr "\"x86_64\""

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#, fuzzy
msgid ""
"// See https://github.com/rust-lang/libc/issues/414 and the section on\n"
"        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).\n"
"        //\n"
"        // \"Platforms that existed before these updates were available\" "
"refers\n"
"        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and "
"PowerPC.\n"
msgstr ""
"// A se vedea https://github.com/rust-lang/libc/issues/414 și secțiunea "
"privind\n"
"        // _DARWIN_FEATURE_64_BIT_INODE din pagina de manual macOS pentru "
"stat(2).\n"
"        //\n"
"        // \"Platformele care existau înainte ca aceste actualizări să fie "
"disponibile\" se referă la\n"
"        // la macOS (spre deosebire de iOS / wearOS / etc.) pe Intel și "
"PowerPC.\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#, fuzzy
msgid "\"readdir$INODE64\""
msgstr "\"readdir$INODE64\""

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#, fuzzy
msgid ""
"// Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
msgstr ""
"// Apelați opendir și returnați o valoare Ok dacă a funcționat,\n"
"        // în caz contrar, se returnează Err cu un mesaj.\n"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid "// Keep calling readdir until we get a NULL pointer back.\n"
msgstr ""
"// Continuați să apelați readdir până când primim înapoi un pointer NULL.\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#, fuzzy
msgid "// Call closedir as needed.\n"
msgstr "// Chemați closedir după cum este necesar.\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "\".\""
msgstr "\".\""

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#, fuzzy
msgid "\"files: {:#?}\""
msgstr ""
"Copiați următorul cod server și client în `src/bin/server.rs` și, respectiv, "
"`src/bin/client.rs`. Sarcina dumneavoastră este de a completa aceste fișiere "
"așa cum este descris mai jos."

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "\"Invalid path: {err}\""
msgstr "\"Invalid path: {err}\""

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "// SAFETY: path.as_ptr() cannot be NULL.\n"
msgstr "// SAFETY: path.as_ptr() nu poate fi NULL.\n"

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "\"Could not open {:?}\""
msgstr "\"Nu s-a putut deschide {:?}\""

#: src/unsafe-rust/solution.md
#, fuzzy
msgid ""
"// Keep calling readdir until we get a NULL pointer back.\n"
"        // SAFETY: self.dir is never NULL.\n"
msgstr ""
"// Continuați să apelați readdir până când primim înapoi un pointer NULL.\n"
"        // SIGURANȚĂ: self.dir nu este niciodată NULL.\n"

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "// We have reached the end of the directory.\n"
msgstr "// Am ajuns la sfârșitul directorului.\n"

#: src/unsafe-rust/solution.md
#, fuzzy
msgid ""
"// SAFETY: dirent is not NULL and dirent.d_name is NUL\n"
"        // terminated.\n"
msgstr ""
"// SAFETY: dirent nu este NULL și dirent.d_name este NUL\n"
"        // terminat.\n"

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "// SAFETY: self.dir is not NULL.\n"
msgstr "// SIGURANȚĂ: self.dir nu este NULL.\n"

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "\"Could not close {:?}\""
msgstr "\"Nu s-a putut închide {:?}\""

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "\"no-such-directory\""
msgstr "\"no-such-directory\""

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "\"Non UTF-8 character in path\""
msgstr "\"Caracter non-UTF-8 în calea de acces\""

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "\"..\""
msgstr "\"..\""

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "\"foo.txt\""
msgstr "\"foo.txt\""

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "\"The Foo Diaries\\n\""
msgstr "\"The Foo Diaries\\n\""

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "\"bar.png\""
msgstr "\"bar.png\""

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "\"<PNG>\\n\""
msgstr "\"<PNG>\\n\""

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "\"crab.rs\""
msgstr "\"crab.rs\""

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "\"//! Crab\\n\""
msgstr "\"//! Crab\\n\""

#: src/android.md
#, fuzzy
msgid "Welcome to Rust in Android"
msgstr "Bine ați venit la Rust în Android"

#: src/android.md
#, fuzzy
msgid ""
"Rust is supported for system software on Android. This means that you can "
"write new services, libraries, drivers or even firmware in Rust (or improve "
"existing code as needed)."
msgstr ""
"Rust este acceptat pentru dezvoltarea platformei native pe Android. Acest "
"lucru înseamnă că puteți scrie noi servicii de sistem de operare în Rust, "
"precum și extinde serviciile existente."

#: src/android.md
#, fuzzy
msgid ""
"We will attempt to call Rust from one of your own projects today. So try to "
"find a little corner of your code base where we can move some lines of code "
"to Rust. The fewer dependencies and \"exotic\" types the better. Something "
"that parses some raw bytes would be ideal."
msgstr ""
"Vom încerca să îl sunăm pe Rust de la unul dintre proiectele dumneavoastră "
"astăzi. Așadar, încercați să găsiți un colțișor din baza dumneavoastră de "
"cod în care să putem muta câteva linii de cod în Rust. Cu cât mai puține "
"dependențe și tipuri \"exotice\", cu atât mai bine. Ceva care analizează "
"niște octeți brute ar fi ideal."

#: src/android.md
#, fuzzy
msgid ""
"The speaker may mention any of the following given the increased use of Rust "
"in Android:"
msgstr ""
"Vorbitorul poate menționa oricare dintre următoarele, având în vedere "
"utilizarea sporită a Rust în Android:"

#: src/android.md
#, fuzzy
msgid ""
"Service example: [DNS over HTTP](https://security.googleblog.com/2022/07/dns-"
"over-http3-in-android.html)"
msgstr ""
"Exemplu de serviciu: [DNS prin HTTP](https://security.googleblog.com/2022/07/"
"dns-over-http3-in-android.html)"

#: src/android.md
#, fuzzy
msgid ""
"Libraries: [Rutabaga Virtual Graphics Interface](https://crosvm.dev/book/"
"appendix/rutabaga_gfx.html)"
msgstr ""
"Biblioteci: [Rutabaga Virtual Graphics Interface](https://crosvm.dev/book/"
"appendix/rutabaga_gfx.html)"

#: src/android.md
#, fuzzy
msgid ""
"Kernel Drivers: [Binder](https://lore.kernel.org/rust-for-linux/20231101-"
"rust-binder-v1-0-08ba9197f637@google.com/)"
msgstr ""
"Driverele nucleului: [Binder](https://lore.kernel.org/rust-for-"
"linux/20231101-rust-binder-v1-0-08ba9197f637@google.com/)"

#: src/android.md
#, fuzzy
msgid ""
"Firmware: [pKVM firmware](https://security.googleblog.com/2023/10/bare-metal-"
"rust-in-android.html)"
msgstr ""
"Firmware: [pKVM firmware](https://security.googleblog.com/2023/10/bare-metal-"
"rust-in-android.html)"

#: src/android/setup.md
#, fuzzy
msgid ""
"We will be using a Cuttlefish Android Virtual Device to test our code. Make "
"sure you have access to one or create a new one with:"
msgstr ""
"Vom folosi un dispozitiv virtual Android pentru a testa codul nostru. "
"Asigurați-vă că aveți acces la unul sau creați unul nou cu:"

#: src/android/setup.md
#, fuzzy
msgid ""
"Please see the [Android Developer Codelab](https://source.android.com/docs/"
"setup/start) for details."
msgstr ""
"Vă rugăm să consultați [Android Developer Codelab](https://source.android."
"com/docs/setup/start) pentru detalii."

#: src/android/setup.md
#, fuzzy
msgid ""
"Cuttlefish is a reference Android device designed to work on generic Linux "
"desktops. MacOS support is also planned."
msgstr ""
"Cuttlefish este un dispozitiv Android de referință conceput pentru a "
"funcționa pe desktop-uri Linux generice. De asemenea, este planificat și "
"suport pentru MacOS."

#: src/android/setup.md
#, fuzzy
msgid ""
"The Cuttlefish system image maintains high fidelity to real devices, and is "
"the ideal emulator to run many Rust use cases."
msgstr ""
"Imaginea de sistem Cuttlefish păstrează o fidelitate ridicată față de "
"dispozitivele reale și este emulatorul ideal pentru a rula multe cazuri de "
"utilizare Rust."

#: src/android/build-rules.md
#, fuzzy
msgid "The Android build system (Soong) supports Rust via a number of modules:"
msgstr ""
"Sistemul de compilare Android (Soong) acceptă Rust prin intermediul unui "
"număr de module:"

#: src/android/build-rules.md
msgid "Module Type"
msgstr "Tipul de modul"

#: src/android/build-rules.md
msgid "Description"
msgstr "Descriere"

#: src/android/build-rules.md
#, fuzzy
msgid "`rust_binary`"
msgstr ""
"```javascript\n"
"rust_binary {\n"
"    name: \"cxx_test\",\n"
"    srcs: [\"lib.rs\"],\n"
"    rustlibs: [\"libcxx\"],\n"
"    static_libs: [\"libcxx_test_cpp\"],\n"
"}\n"
"```"

#: src/android/build-rules.md
#, fuzzy
msgid "Produces a Rust binary."
msgstr "Produce un binar Rust."

#: src/android/build-rules.md
#, fuzzy
msgid "`rust_library`"
msgstr "`rust_library`"

#: src/android/build-rules.md
#, fuzzy
msgid "Produces a Rust library, and provides both `rlib` and `dylib` variants."
msgstr ""
"Produce o bibliotecă Rust și oferă atât variantele `rlib`, cât și `dylib`."

#: src/android/build-rules.md
#, fuzzy
msgid "`rust_ffi`"
msgstr "`rust_ffi`"

#: src/android/build-rules.md
#, fuzzy
msgid ""
"Produces a Rust C library usable by `cc` modules, and provides both static "
"and shared variants."
msgstr ""
"Produce o bibliotecă Rust C utilizabilă de modulele `cc` și oferă atât "
"variante statice cât și partajate."

#: src/android/build-rules.md
#, fuzzy
msgid "`rust_proc_macro`"
msgstr "`rust_proc_macro`"

#: src/android/build-rules.md
#, fuzzy
msgid ""
"Produces a `proc-macro` Rust library. These are analogous to compiler "
"plugins."
msgstr ""
"Produce o bibliotecă Rust `proc-macro`. Acestea sunt analoge cu plugin-urile "
"de compilator."

#: src/android/build-rules.md
#, fuzzy
msgid "`rust_test`"
msgstr "`rust_test`"

#: src/android/build-rules.md
#, fuzzy
msgid "Produces a Rust test binary that uses the standard Rust test harness."
msgstr ""
"Produce un binar de testare Rust care utilizează harnașamentul standard de "
"testare Rust."

#: src/android/build-rules.md
#, fuzzy
msgid "`rust_fuzz`"
msgstr "`rust_fuzz`"

#: src/android/build-rules.md
#, fuzzy
msgid "Produces a Rust fuzz binary leveraging `libfuzzer`."
msgstr "Produce un binar Rust fuzz folosind `libfuzzer`."

#: src/android/build-rules.md
#, fuzzy
msgid "`rust_protobuf`"
msgstr "`rust_protobuf`"

#: src/android/build-rules.md
#, fuzzy
msgid ""
"Generates source and produces a Rust library that provides an interface for "
"a particular protobuf."
msgstr ""
"Generează sursa și produce o bibliotecă Rust care oferă o interfață pentru "
"un anumit protobuf."

#: src/android/build-rules.md
#, fuzzy
msgid "`rust_bindgen`"
msgstr "`rust_bindgen`"

#: src/android/build-rules.md
#, fuzzy
msgid ""
"Generates source and produces a Rust library containing Rust bindings to C "
"libraries."
msgstr ""
"Generează sursa și produce o bibliotecă Rust care conține legături Rust "
"pentru bibliotecile C."

#: src/android/build-rules.md
#, fuzzy
msgid "We will look at `rust_binary` and `rust_library` next."
msgstr "În continuare vom analiza `rust_binary` și `rust_library`."

#: src/android/build-rules.md
#, fuzzy
msgid "Additional items speaker may mention:"
msgstr "Alte elemente pe care vorbitorul le poate menționa:"

#: src/android/build-rules.md
#, fuzzy
msgid ""
"Cargo is not optimized for multi-language repos, and also downloads packages "
"from the internet."
msgstr ""
"Cargo nu este optimizat pentru depozite multilingve și, de asemenea, "
"descarcă pachete de pe internet."

#: src/android/build-rules.md
#, fuzzy
msgid ""
"For compliance and performance, Android must have crates in-tree. It must "
"also interop with C/C++/Java code. Soong fills that gap."
msgstr ""
"Pentru conformitate și performanță, Android trebuie să aibă cratere în "
"copac. De asemenea, trebuie să interacționeze cu codul C/C++/Java. Soong "
"umple acest gol."

#: src/android/build-rules.md
#, fuzzy
msgid ""
"Soong has many similarities to Bazel, which is the open-source variant of "
"Blaze (used in google3)."
msgstr ""
"Soong are multe asemănări cu Bazel, care este varianta open-source a lui "
"Blaze (utilizată în google3)."

#: src/android/build-rules.md
#, fuzzy
msgid ""
"There is a plan to transition [Android](https://source.android.com/docs/"
"setup/build/bazel/introduction), [ChromeOS](https://chromium.googlesource."
"com/chromiumos/bazel/), and [Fuchsia](https://source.android.com/docs/setup/"
"build/bazel/introduction) to Bazel."
msgstr ""
"Există un plan de tranziție de la [Android](https://source.android.com/docs/"
"setup/build/bazel/introduction), [ChromeOS](https://chromium.googlesource."
"com/chromiumos/bazel/) și [Fuchsia](https://source.android.com/docs/setup/"
"build/bazel/introduction) la Bazel."

#: src/android/build-rules.md
#, fuzzy
msgid "Learning Bazel-like build rules is useful for all Rust OS developers."
msgstr ""
"Învățarea regulilor de compilare de tip Bazel este utilă pentru toți "
"dezvoltatorii Rust OS."

#: src/android/build-rules.md
#, fuzzy
msgid "Fun fact: Data from Star Trek is a Soong-type Android."
msgstr "Fapt amuzant: Data din Star Trek este un Android de tip Soong."

#: src/android/build-rules/binary.md
#, fuzzy
msgid "Rust Binaries"
msgstr "Binare Rust"

#: src/android/build-rules/binary.md
#, fuzzy
msgid ""
"Let us start with a simple application. At the root of an AOSP checkout, "
"create the following files:"
msgstr ""
"Să începem cu o aplicație simplă. La rădăcina unei verificări AOSP, creați "
"următoarele fișiere:"

#: src/android/build-rules/binary.md src/android/build-rules/library.md
#, fuzzy
msgid "_hello_rust/Android.bp_:"
msgstr "hello_rust/Android.bp_:"

#: src/android/build-rules/binary.md
#, fuzzy
msgid "\"hello_rust\""
msgstr "\"hello_rust\""

#: src/android/build-rules/binary.md src/android/build-rules/library.md
#: src/android/logging.md
#, fuzzy
msgid "\"src/main.rs\""
msgstr "src/main.rs_:"

#: src/android/build-rules/binary.md src/android/build-rules/library.md
#, fuzzy
msgid "_hello_rust/src/main.rs_:"
msgstr "hello_rust/src/main.rs_:"

#: src/android/build-rules/binary.md src/android/build-rules/library.md
#, fuzzy
msgid "//! Rust demo.\n"
msgstr "//! Demo Rust.\n"

#: src/android/build-rules/binary.md src/android/build-rules/library.md
#, fuzzy
msgid "/// Prints a greeting to standard output.\n"
msgstr "/// Tipărește un mesaj de salut pe ieșirea standard.\n"

#: src/android/build-rules/binary.md src/exercises/chromium/build-rules.md
#, fuzzy
msgid "\"Hello from Rust!\""
msgstr "\"Bună ziua de la Rust!\""

#: src/android/build-rules/binary.md
#, fuzzy
msgid "You can now build, push, and run the binary:"
msgstr "Acum puteți să construiți, să distribuiți și să rulați fișierul binar:"

#: src/android/build-rules/binary.md
#, fuzzy
msgid ""
"```shell\n"
"m hello_rust\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust\" /data/local/tmp\n"
"adb shell /data/local/tmp/hello_rust\n"
"```"
msgstr ""
"```shell\n"
"m hello_rust\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust /data/local/tmp\"\n"
"adb shell /data/local/tmp/hello_rust\n"
"```"

#: src/android/build-rules/library.md
#, fuzzy
msgid "Rust Libraries"
msgstr "Biblioteci Rust"

#: src/android/build-rules/library.md
#, fuzzy
msgid "You use `rust_library` to create a new Rust library for Android."
msgstr ""
"Utilizați `rust_library` pentru a crea o nouă bibliotecă Rust pentru Android."

#: src/android/build-rules/library.md
#, fuzzy
msgid "Here we declare a dependency on two libraries:"
msgstr "Aici declarăm o dependență față de două biblioteci:"

#: src/android/build-rules/library.md
#, fuzzy
msgid "`libgreeting`, which we define below,"
msgstr "`libgreeting`, pe care îl definim mai jos,"

#: src/android/build-rules/library.md
#, fuzzy
msgid ""
"`libtextwrap`, which is a crate already vendored in [`external/rust/crates/`]"
"(https://cs.android.com/android/platform/superproject/+/master:external/rust/"
"crates/)."
msgstr ""
"`libtextwrap`, care este un crate deja vândut în [`external/rust/crates/`]"
"(https://cs.android.com/android/platform/superproject/+/master:external/rust/"
"crates/)."

#: src/android/build-rules/library.md
#, fuzzy
msgid "\"hello_rust_with_dep\""
msgstr "\"hello_rust_with_dep\""

#: src/android/build-rules/library.md
#, fuzzy
msgid "\"libgreetings\""
msgstr "\"libgreetings\""

#: src/android/build-rules/library.md
#, fuzzy
msgid "\"libtextwrap\""
msgstr "\"libtextwrap\""

#: src/android/build-rules/library.md
#, fuzzy
msgid "// Need this to avoid dynamic link error.\n"
msgstr "// Este necesar pentru a evita eroarea de link dinamic.\n"

#: src/android/build-rules/library.md
#, fuzzy
msgid "\"greetings\""
msgstr "\"Salutări\""

#: src/android/build-rules/library.md
#: src/android/aidl/example-service/service.md src/android/testing.md
#: src/android/interoperability/java.md
#, fuzzy
msgid "\"src/lib.rs\""
msgstr "src/main.rs_:"

#: src/android/build-rules/library.md
#, fuzzy
msgid "_hello_rust/src/lib.rs_:"
msgstr "hello_rust/src/lib.rs_:"

#: src/android/build-rules/library.md
#, fuzzy
msgid "//! Greeting library.\n"
msgstr "//! Biblioteca de felicitări.\n"

#: src/android/build-rules/library.md
#, fuzzy
msgid "/// Greet `name`.\n"
msgstr "/// Salutați `name`.\n"

#: src/android/build-rules/library.md
#, fuzzy
msgid "\"Hello {name}, it is very nice to meet you!\""
msgstr "\"Bună ziua {name}, mă bucur să vă cunosc!\""

#: src/android/build-rules/library.md
#, fuzzy
msgid "You build, push, and run the binary like before:"
msgstr "Construiți, distribuiți și rulați programul binar la fel ca înainte:"

#: src/android/build-rules/library.md
#, fuzzy
msgid ""
"```shell\n"
"m hello_rust_with_dep\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/hello_rust_with_dep\n"
"```"
msgstr ""
"```shell\n"
"m hello_rust_with_dep\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/hello_rust_with_dep\n"
"```"

#: src/android/aidl.md
#, fuzzy
msgid ""
"The [Android Interface Definition Language (AIDL)](https://developer.android."
"com/guide/components/aidl) is supported in Rust:"
msgstr ""
"Limbajul [Android Interface Definition Language (AIDL)](https://developer."
"android.com/guide/components/aidl) este acceptat în Rust:"

#: src/android/aidl.md
#, fuzzy
msgid "Rust code can call existing AIDL servers,"
msgstr "Codul Rust poate apela serverele AIDL existente,"

#: src/android/aidl.md
#, fuzzy
msgid "You can create new AIDL servers in Rust."
msgstr "Puteți crea noi servere AIDL în Rust."

#: src/android/aidl/birthday-service.md
#, fuzzy
msgid ""
"To illustrate how to use Rust with Binder, we're going to walk through the "
"process of creating a Binder interface. We're then going to both implement "
"the described service and write client code that talks to that service."
msgstr ""
"Pentru a ilustra cum să folosim Rust cu Binder, vom parcurge procesul de "
"creare a unei interfețe Binder. Apoi, vom implementa serviciul descris și "
"vom scrie codul clientului care vorbește cu serviciul respectiv."

#: src/android/aidl/example-service/interface.md
#, fuzzy
msgid "AIDL Interfaces"
msgstr "Interfețe AIDL"

#: src/android/aidl/example-service/interface.md
#, fuzzy
msgid "You declare the API of your service using an AIDL interface:"
msgstr "Declarați API-ul serviciului dumneavoastră utilizând o interfață AIDL:"

#: src/android/aidl/example-service/interface.md
#: src/android/aidl/example-service/service-bindings.md
#, fuzzy
msgid ""
"_birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl_:"
msgstr ""
"_birthday_service/aidl/com/exemple/birthdayservice/IBirthdayService.aidl_:"

#: src/android/aidl/example-service/interface.md
#: src/android/aidl/example-service/service-bindings.md
#: src/android/aidl/example-service/changing-definition.md
#, fuzzy
msgid "/** Birthday service interface. */"
msgstr "/** Interfață de serviciu de ziua de naștere. */"

#: src/android/aidl/example-service/interface.md
#: src/android/aidl/example-service/service-bindings.md
#: src/android/aidl/example-service/changing-definition.md
#, fuzzy
msgid "/** Generate a Happy Birthday message. */"
msgstr "/** Generează un mesaj de \"La mulți ani\". */"

#: src/android/aidl/example-service/interface.md
#, fuzzy
msgid "_birthday_service/aidl/Android.bp_:"
msgstr "_birthday_service/aidl/Android.bp_:"

#: src/android/aidl/example-service/interface.md
#, fuzzy
msgid "\"com.example.birthdayservice\""
msgstr "\"com.example.birthdayservice\""

#: src/android/aidl/example-service/interface.md
#, fuzzy
msgid "\"com/example/birthdayservice/*.aidl\""
msgstr ""
"_birthday_service/aidl/com/exemple/birthdayservice/IBirthdayService.aidl_:"

#: src/android/aidl/example-service/interface.md
#, fuzzy
msgid "// Rust is not enabled by default\n"
msgstr "// Rust nu este activat în mod implicit\n"

#: src/android/aidl/example-service/interface.md
#, fuzzy
msgid ""
"Note that the directory structure under the `aidl/` directory needs to match "
"the package name used in the AIDL file, i.e. the package is `com.example."
"birthdayservice` and the file is at `aidl/com/example/IBirthdayService.aidl`."
msgstr ""
"Rețineți că structura directoarelor din directorul `aidl/` trebuie să "
"corespundă cu numele pachetului utilizat în fișierul AIDL, de exemplu, "
"pachetul este `com.example.birthdayservice`, iar fișierul se află la `aidl/"
"com/example/IBirthdayService.aidl`."

#: src/android/aidl/example-service/service-bindings.md
#, fuzzy
msgid "Generated Service API"
msgstr "Serviciul generat API"

#: src/android/aidl/example-service/service-bindings.md
#, fuzzy
msgid ""
"Binder generates a trait corresponding to the interface definition. trait to "
"talk to the service."
msgstr ""
"Binder generează o trăsătură corespunzătoare definiției interfeței. "
"trăsătură pentru a vorbi cu serviciul."

#: src/android/aidl/example-service/service-bindings.md
#, fuzzy
msgid "_Generated trait_:"
msgstr "Cod Rust generat:"

#: src/android/aidl/example-service/service-bindings.md
#, fuzzy
msgid ""
"Your service will need to implement this trait, and your client will use "
"this trait to talk to the service."
msgstr ""
"Serviciul dvs. va trebui să implementeze această trăsătură, iar clientul "
"dvs. va folosi această trăsătură pentru a vorbi cu serviciul."

#: src/android/aidl/example-service/service-bindings.md
#, fuzzy
msgid ""
"The generated bindings can be found at `out/soong/.intermediates/<path to "
"module>/`."
msgstr ""
"Legăturile generate pot fi găsite la `out/soong/.intermediates/<path to "
"module>/`."

#: src/android/aidl/example-service/service-bindings.md
#, fuzzy
msgid ""
"Point out how the generated function signature, specifically the argument "
"and return types, correspond the interface definition."
msgstr ""
"Evidențiați modul în care semnătura funcției generate, în special tipurile "
"de argumente și de retur, corespund definiției interfeței."

#: src/android/aidl/example-service/service-bindings.md
#, fuzzy
msgid ""
"`String` for an argument results in a different Rust type than `String` as a "
"return type."
msgstr ""
"`String` pentru un argument are ca rezultat un tip Rust diferit de `String` "
"ca tip de returnare."

#: src/android/aidl/example-service/service.md
#, fuzzy
msgid "Service Implementation"
msgstr "Implementarea serviciilor"

#: src/android/aidl/example-service/service.md
#, fuzzy
msgid "We can now implement the AIDL service:"
msgstr "Acum putem implementa serviciul AIDL:"

#: src/android/aidl/example-service/service.md
#: src/android/aidl/example-service/changing-implementation.md
#, fuzzy
msgid "_birthday_service/src/lib.rs_:"
msgstr "_birthday_service/src/lib.rs_:"

#: src/android/aidl/example-service/service.md
#, fuzzy
msgid "/// The `IBirthdayService` implementation.\n"
msgstr "Implementarea serviciilor"

#: src/android/aidl/example-service/service.md
#: src/android/aidl/example-service/changing-implementation.md
#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "\"Happy Birthday {name}, congratulations with the {years} years!\""
msgstr "\"La mulți ani {name}, felicitări cu {years} ani!\""

#: src/android/aidl/example-service/service.md
#: src/android/aidl/example-service/server.md
#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "_birthday_service/Android.bp_:"
msgstr "_birthday_service/Android.bp_:"

#: src/android/aidl/example-service/service.md
#: src/android/aidl/example-service/server.md
#, fuzzy
msgid "\"libbirthdayservice\""
msgstr "_birthday_service/src/lib.rs_:"

#: src/android/aidl/example-service/service.md
#: src/android/aidl/example-service/server.md
#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "\"birthdayservice\""
msgstr "_birthday_service/src/lib.rs_:"

#: src/android/aidl/example-service/service.md
#: src/android/aidl/example-service/server.md
#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "\"com.example.birthdayservice-rust\""
msgstr "\"com.example.birthdayservice-rust\""

#: src/android/aidl/example-service/service.md
#: src/android/aidl/example-service/server.md
#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "\"libbinder_rs\""
msgstr "\"libbinder_rs\""

#: src/android/aidl/example-service/service.md
#, fuzzy
msgid ""
"Point out the path to the generated `IBirthdayService` trait, and explain "
"why each of the segments is necessary."
msgstr ""
"Indicați calea către trăsătura generată `IBirthdayService` și explicați de "
"ce este necesar fiecare dintre segmente."

#: src/android/aidl/example-service/service.md
#, fuzzy
msgid ""
"TODO: What does the `binder::Interface` trait do? Are there methods to "
"override? Where source?"
msgstr ""
"TODO: Ce face trăsătura `binder::Interface`? Există metode de suprascriere? "
"Unde se află sursa?"

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid "AIDL Server"
msgstr "Server AIDL"

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid "Finally, we can create a server which exposes the service:"
msgstr "În cele din urmă, putem crea un server care să expună serviciul:"

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid "_birthday_service/src/server.rs_:"
msgstr "_birthday_service/src/server.rs_:"

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid "//! Birthday service.\n"
msgstr "//! Slujbă de ziua de naștere.\n"

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid "/// Entry point for birthday service.\n"
msgstr "/// Punct de intrare pentru serviciul de aniversare.\n"

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid "\"Failed to register service\""
msgstr "\"Nu a reușit să înregistreze serviciul\""

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid "\"birthday_server\""
msgstr "_birthday_service/src/lib.rs_:"

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid "\"src/server.rs\""
msgstr "src/bin/server.rs_:"

#: src/android/aidl/example-service/server.md
#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "// To avoid dynamic link error.\n"
msgstr "// Pentru a evita eroarea de legătură dinamică.\n"

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid ""
"The process for taking a user-defined service implementation (in this case "
"the `BirthdayService` type, which implements the `IBirthdayService`) and "
"starting it as a Binder service has multiple steps, and may appear more "
"complicated than students are used to if they've used Binder from C++ or "
"another language. Explain to students why each step is necessary."
msgstr ""
"Procesul de preluare a implementării unui serviciu definit de utilizator (în "
"acest caz, tipul `BirthdayService`, care implementează `IBirthdayService`) "
"și pornirea acestuia ca serviciu Binder are mai mulți pași și poate părea "
"mai complicat decât sunt obișnuiți studenții care au folosit Binder din C++ "
"sau dintr-un alt limbaj. Explicați-le elevilor de ce este necesar fiecare "
"pas."

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid "Create an instance of your service type (`BirthdayService`)."
msgstr "Creați o instanță a tipului dvs. de serviciu (`BirthdayService`)."

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid ""
"Wrap the service object in corresponding `Bn*` type (`BnBirthdayService` in "
"this case). This type is generated by Binder and provides the common Binder "
"functionality that would be provided by the `BnBinder` base class in C++. We "
"don't have inheritance in Rust, so instead we use composition, putting our "
"`BirthdayService` within the generated `BnBinderService`."
msgstr ""
"Înfășurați obiectul serviciului în tipul `Bn*` corespunzător "
"(`BnBirthdayService` în acest caz). Acest tip este generat de Binder și "
"oferă funcționalitatea comună Binder care ar fi furnizată de clasa de bază "
"`BnBinder` în C++. În Rust nu avem moștenire, așa că în schimb folosim "
"compoziția, punând `BirthdayService` în cadrul `BnBinderService` generat."

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid ""
"Call `add_service`, giving it a service identifier and your service object "
"(the `BnBirthdayService` object in the example)."
msgstr ""
"Apelați `add_service`, dându-i un identificator de serviciu și obiectul "
"serviciului dumneavoastră (obiectul `BnBirthdayService` în exemplul de față)."

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid ""
"Call `join_thread_pool` to add the current thread to Binder's thread pool "
"and start listening for connections."
msgstr ""
"Apelați `join_thread_pool` pentru a adăuga firul curent la fondul de fire al "
"Binder și pentru a începe să asculte conexiunile."

#: src/android/aidl/example-service/deploy.md
#, fuzzy
msgid "We can now build, push, and start the service:"
msgstr "Acum putem construi, împinge și porni serviciul:"

#: src/android/aidl/example-service/deploy.md
#, fuzzy
msgid ""
"```shell\n"
"m birthday_server\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_server\" /data/local/"
"tmp\n"
"adb root\n"
"adb shell /data/local/tmp/birthday_server\n"
"```"
msgstr ""
"```shell\n"
"m birthday_server\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/birthday_server\n"
"```"

#: src/android/aidl/example-service/deploy.md
#, fuzzy
msgid "In another terminal, check that the service runs:"
msgstr "Într-un alt terminal, verificați dacă serviciul rulează:"

#: src/android/aidl/example-service/deploy.md
#, fuzzy
msgid "You can also call the service with `service call`:"
msgstr "De asemenea, puteți apela serviciul cu `service call`:"

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "AIDL Client"
msgstr "Client AIDL"

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "Finally, we can create a Rust client for our new service."
msgstr ""
"În cele din urmă, putem crea un client Rust pentru noul nostru serviciu."

#: src/android/aidl/example-service/client.md
#: src/android/aidl/example-service/changing-implementation.md
#, fuzzy
msgid "_birthday_service/src/client.rs_:"
msgstr "_birthday_service/src/client.rs_:"

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "/// Call the birthday service.\n"
msgstr "/// Apelarea serviciului de aniversare.\n"

#: src/android/aidl/example-service/client.md src/android/aidl/types/objects.md
#: src/android/aidl/types/parcelables.md
#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "\"Failed to connect to BirthdayService\""
msgstr "\"Nu a reușit să se conecteze la BirthdayService\""

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "// Call the service.\n"
msgstr "/// Apelarea serviciului de aniversare.\n"

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "\"{msg}\""
msgstr ""
"```rust,editable\n"
"enum Result {\n"
"    Ok(i32),\n"
"    Err(String),\n"
"}\n"
"\n"
"fn divide_in_two(n: i32) -> Result {\n"
"    if n % 2 == 0 {\n"
"        Result::Ok(n / 2)\n"
"    } else {\n"
"        Result::Err(format!(\"nu se poate împărți {n} în două părți "
"egale\"))\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let n = 100;\n"
"    match divide_in_two(n) {\n"
"        Result::Ok(half) => println!(\"{n} împărțit la doi este {half}\"),\n"
"        Result::Err(msg) => println!(\"regret, a apărut o eroare: {msg}\"),\n"
"    }\n"
"}\n"
"```"

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "\"birthday_client\""
msgstr "_birthday_service/src/client.rs_:"

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "\"src/client.rs\""
msgstr "src/bin/client.rs_:"

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "Notice that the client does not depend on `libbirthdayservice`."
msgstr "Observați că clientul nu depinde de `libbirthdayservice`."

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "Build, push, and run the client on your device:"
msgstr "Creați, distribuiți și rulați clientul pe dispozitivul dvs:"

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid ""
"```shell\n"
"m birthday_client\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_client\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/birthday_client Charlie 60\n"
"```"
msgstr ""
"```shell\n"
"m birthday_client\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_client /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/birthday_client Charlie 60\n"
"```"

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid ""
"`Strong<dyn IBirthdayService>` is the trait object representing the service "
"that the client has connected to."
msgstr ""
"`Strong<dyn IBirthdayService>` este obiectul trăsătură care reprezintă "
"serviciul la care s-a conectat clientul."

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid ""
"`Strong` is a custom smart pointer type for Binder. It handles both an in-"
"process ref count for the service trait object, and the global Binder ref "
"count that tracks how many processes have a reference to the object."
msgstr ""
"`Strong` este un tip de pointer inteligent personalizat pentru Binder. "
"Acesta gestionează atât un număr de referințe în cadrul procesului pentru "
"obiectul de serviciu, cât și numărul global de referințe Binder care "
"urmărește câte procese au o referință la obiect."

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid ""
"Note that the trait object that the client uses to talk to the service uses "
"the exact same trait that the server implements. For a given Binder "
"interface, there is a single Rust trait generated that both client and "
"server use."
msgstr ""
"Rețineți că obiectul de trăsătură pe care clientul îl utilizează pentru a "
"vorbi cu serviciul utilizează exact aceeași trăsătură pe care o "
"implementează serverul. Pentru o anumită interfață Binder, există o singură "
"trăsătură Rust generată pe care o utilizează atât clientul, cât și serverul."

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid ""
"Use the same service identifier used when registering the service. This "
"should ideally be defined in a common crate that both the client and server "
"can depend on."
msgstr ""
"Utilizați același identificator de serviciu utilizat la înregistrarea "
"serviciului. Ideal ar fi ca acesta să fie definit într-o casetă comună de "
"care să depindă atât clientul, cât și serverul."

#: src/android/aidl/example-service/changing-definition.md
#, fuzzy
msgid ""
"Let us extend the API with more functionality: we want to let clients "
"specify a list of lines for the birthday card:"
msgstr ""
"Să extindem API-ul cu mai multe funcționalități: dorim să permitem "
"clienților să specifice o listă de linii pentru felicitarea de ziua de "
"naștere:"

#: src/android/aidl/example-service/changing-definition.md
#, fuzzy
msgid "This results in an updated trait definition for `IBirthdayService`:"
msgstr ""
"Aceasta are ca rezultat o definiție actualizată a trăsăturii pentru "
"`IBirthdayService`:"

#: src/android/aidl/example-service/changing-definition.md
#, fuzzy
msgid ""
"Note how the `String[]` in the AIDL definition is translated as a "
"`&[String]` in Rust, i.e. that idiomatic Rust types are used in the "
"generated bindings wherever possible:"
msgstr ""
"Observați cum `String[]` din definiția AIDL este tradus ca `&[String]` în "
"Rust, adică tipurile idiomatice Rust sunt utilizate în legăturile generate "
"ori de câte ori este posibil:"

#: src/android/aidl/example-service/changing-definition.md
#, fuzzy
msgid "`in` array arguments are translated to slices."
msgstr "argumentele matricei `in` sunt transformate în felii."

#: src/android/aidl/example-service/changing-definition.md
#, fuzzy
msgid "`out` and `inout` args are translated to `&mut Vec<T>`."
msgstr "argetele `out` și `inout` sunt traduse în `&amp;mut Vec<T>`."

#: src/android/aidl/example-service/changing-definition.md
#, fuzzy
msgid "Return values are translated to returning a `Vec<T>`."
msgstr "Valorile de returnare sunt convertite în returnarea unui `Vec<T>`."

#: src/android/aidl/example-service/changing-implementation.md
#, fuzzy
msgid "Updating Client and Service"
msgstr "Actualizarea clientului și a serviciului"

#: src/android/aidl/example-service/changing-implementation.md
#, fuzzy
msgid "Update the client and server code to account for the new API."
msgstr ""
"Actualizați codul clientului și al serverului pentru a ține cont de noul API."

#: src/android/aidl/example-service/changing-implementation.md
msgid "'\\n'"
msgstr "'\\n'"

#: src/android/aidl/example-service/changing-implementation.md
#, fuzzy
msgid "\"Habby birfday to yuuuuu\""
msgstr "\"Habby birfday to yuuuuuuu\""

#: src/android/aidl/example-service/changing-implementation.md
#, fuzzy
msgid "\"And also: many more\""
msgstr "\"Și, de asemenea, multe altele\""

#: src/android/aidl/example-service/changing-implementation.md
#, fuzzy
msgid ""
"TODO: Move code snippets into project files where they'll actually be built?"
msgstr ""
"TODO: Să mutăm fragmentele de cod în fișierele de proiect, unde vor fi "
"construite efectiv?"

#: src/android/aidl/types.md
#, fuzzy
msgid "Working With AIDL Types"
msgstr "Lucrul cu tipurile AIDL"

#: src/android/aidl/types.md
#, fuzzy
msgid "AIDL types translate into the appropriate idiomatic Rust type:"
msgstr "Tipurile AIDL se traduc în tipul idiomatic Rust corespunzător:"

#: src/android/aidl/types.md
#, fuzzy
msgid "Primitive types map (mostly) to idiomatic Rust types."
msgstr ""
"Tipurile primitive se adaptează (în mare parte) la tipurile idiomatice Rust."

#: src/android/aidl/types.md
#, fuzzy
msgid "Collection types like slices, `Vec`s and string types are supported."
msgstr ""
"Sunt acceptate tipuri de colecții precum slices, `Vec`s și tipuri de șiruri "
"de caractere."

#: src/android/aidl/types.md
#, fuzzy
msgid ""
"References to AIDL objects and file handles can be sent between clients and "
"services."
msgstr ""
"Referințele la obiecte AIDL și la mânerele de fișiere pot fi trimise între "
"clienți și servicii."

#: src/android/aidl/types.md
#, fuzzy
msgid "File handles and parcelables are fully supported."
msgstr "Mânerele de fișiere și pachetele sunt pe deplin acceptate."

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "Primitive types map (mostly) idiomatically:"
msgstr "Tipurile primitive se mapează (în mare parte) în mod idiomatic:"

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "AIDL Type"
msgstr "AIDL"

#: src/android/aidl/types/primitives.md src/android/aidl/types/arrays.md
#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "Rust Type"
msgstr "Rugină prin exemplu"

#: src/android/aidl/types/primitives.md
msgid "Note"
msgstr "Notiță"

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "`boolean`"
msgstr "`bool`"

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "`byte`"
msgstr "`byte`"

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "`i8`"
msgstr ""
"Biblioteca standard are o implementare a `From<i8> pentru i16`, ceea ce "
"înseamnă că putem converti o variabilă `x` de tip `i8` în `i16` prin "
"apelarea `i16::from(x)`. Sau, mai simplu, cu `x.into()`, deoarece "
"implementarea `From<i8> for i16` creează automat o implementare a `Into<i16> "
"for i8`."

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "Note that bytes are signed."
msgstr "// Mai mult de 7 octeți este invalid.\n"

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "`u16`"
msgstr "`u16`"

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "Note the usage of `u16`, NOT `u32`."
msgstr "Rețineți utilizarea lui `u16`, NU `u32`."

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "`int`"
msgstr "`int`"

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "`i32`"
msgstr ""
"Ar fi avut loc o copiere implicită a matricei. Din moment ce `i32` este un "
"tip care implică copiere, atunci `[i32; 3]` implică, de asemenea, copierea."

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "`long`"
msgstr ""
"Precizați că bucla `while let` va continua atâta timp cât valoarea se "
"potrivește cu modelul."

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "`i64`"
msgstr "`i64`"

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "`float`"
msgstr "`float`"

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "`f32`"
msgstr "`f32`"

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "`double`"
msgstr "Eliberări dublate în C++ modern"

#: src/android/aidl/types/primitives.md
#, fuzzy
msgid "`f64`"
msgstr "`f64`"

#: src/android/aidl/types/arrays.md
#, fuzzy
msgid ""
"The array types (`T[]`, `byte[]`, and `List<T>`) get translated to the "
"appropriate Rust array type depending on how they are used in the function "
"signature:"
msgstr ""
"Tipurile de matrice (`T[]`, `byte[]` și `List<T>`) sunt convertite în tipul "
"de matrice Rust corespunzător, în funcție de modul în care sunt utilizate în "
"semnătura funcției:"

#: src/android/aidl/types/arrays.md
msgid "Position"
msgstr "Poziție"

#: src/android/aidl/types/arrays.md
#, fuzzy
msgid "`in` argument"
msgstr "argument:"

#: src/android/aidl/types/arrays.md
#, fuzzy
msgid "`&[T]`"
msgstr "`Box<T>`"

#: src/android/aidl/types/arrays.md
#, fuzzy
msgid "`out`/`inout` argument"
msgstr "argument `out`/`inout`"

#: src/android/aidl/types/arrays.md
#, fuzzy
msgid "`&mut Vec<T>`"
msgstr "`Vec`"

#: src/android/aidl/types/arrays.md
msgid "Return"
msgstr "Înapoi"

#: src/android/aidl/types/arrays.md
#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`Vec<T>`"
msgstr "`Vec`"

#: src/android/aidl/types/arrays.md
#, fuzzy
msgid ""
"In Android 13 or higher, fixed-size arrays are supported, i.e. `T[N]` "
"becomes `[T; N]`. Fixed-size arrays can have multiple dimensions (e.g. "
"int\\[3\\]\\[4\\]). In the Java backend, fixed-size arrays are represented "
"as array types."
msgstr ""
"În Android 13 sau versiunile ulterioare, sunt acceptate matricele de "
"dimensiuni fixe, adică `T[N]` devine `[T; N]`. Tablourile de dimensiuni fixe "
"pot avea dimensiuni multiple (de exemplu, int\\[3\\]\\[4\\]). În backend-ul "
"Java, array-urile de dimensiuni fixe sunt reprezentate ca tipuri de array-"
"uri."

#: src/android/aidl/types/arrays.md
#, fuzzy
msgid "Arrays in parcelable fields always get translated to `Vec<T>`."
msgstr ""
"Array-urile din câmpurile parcelabile sunt întotdeauna convertite în "
"`Vec<T>`."

#: src/android/aidl/types/objects.md
#, fuzzy
msgid ""
"AIDL objects can be sent either as a concrete AIDL type or as the type-"
"erased `IBinder` interface:"
msgstr ""
"Obiectele AIDL pot fi trimise fie ca un tip AIDL concret, fie ca interfață "
"`IBinder`, care a fost eliminată ca tip:"

#: src/android/aidl/types/objects.md
#, fuzzy
msgid ""
"**birthday_service/aidl/com/example/birthdayservice/IBirthdayInfoProvider."
"aidl**:"
msgstr ""
"_birthday_service/aidl/com/exemple/birthdayservice/IBirthdayService.aidl_:"

#: src/android/aidl/types/objects.md src/android/aidl/types/parcelables.md
#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid ""
"**birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl**:"
msgstr ""
"_birthday_service/aidl/com/exemple/birthdayservice/IBirthdayService.aidl_:"

#: src/android/aidl/types/objects.md
#, fuzzy
msgid "/** The same thing, but using a binder object. */"
msgstr "/** Același lucru, dar folosind un obiect binder. */"

#: src/android/aidl/types/objects.md
#, fuzzy
msgid "/** The same thing, but using `IBinder`. */"
msgstr "/** Același lucru, dar folosind `IBinder`. */"

#: src/android/aidl/types/objects.md src/android/aidl/types/parcelables.md
#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "**birthday_service/src/client.rs**:"
msgstr "_birthday_service/src/client.rs_:"

#: src/android/aidl/types/objects.md
#, fuzzy
msgid "/// Rust struct implementing the `IBirthdayInfoProvider` interface.\n"
msgstr "//! Implementarea interfeței AIDL `IBirthdayService`.\n"

#: src/android/aidl/types/objects.md
#, fuzzy
msgid "// Create a binder object for the `IBirthdayInfoProvider` interface.\n"
msgstr "//! Implementarea interfeței AIDL `IBirthdayService`.\n"

#: src/android/aidl/types/objects.md
#, fuzzy
msgid "// Send the binder object to the service.\n"
msgstr "/// Apelarea serviciului de aniversare.\n"

#: src/android/aidl/types/objects.md
#, fuzzy
msgid ""
"// Perform the same operation but passing the provider as an `SpIBinder`.\n"
msgstr ""
"// Efectuați aceeași operațiune, dar trecând furnizorul ca un `SpIBinder`.\n"

#: src/android/aidl/types/objects.md
#, fuzzy
msgid ""
"Note the usage of `BnBirthdayInfoProvider`. This serves the same purpose as "
"`BnBirthdayService` that we saw previously."
msgstr ""
"Rețineți utilizarea lui `BnBirthdayInfoProvider`. Acesta are același scop ca "
"și `BnBirthdayService` pe care l-am văzut anterior."

#: src/android/aidl/types/parcelables.md
#, fuzzy
msgid "Binder for Rust supports sending parcelables directly:"
msgstr "Binder for Rust acceptă trimiterea directă de colete:"

#: src/android/aidl/types/parcelables.md
#, fuzzy
msgid ""
"**birthday_service/aidl/com/example/birthdayservice/BirthdayInfo.aidl**:"
msgstr ""
"_birthday_service/aidl/com/exemple/birthdayservice/IBirthdayService.aidl_:"

#: src/android/aidl/types/parcelables.md
#, fuzzy
msgid "/** The same thing, but with a parcelable. */"
msgstr "/** Același lucru, dar cu un parcelabil. */"

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid ""
"Files can be sent between Binder clients/servers using the "
"`ParcelFileDescriptor` type:"
msgstr ""
"Fișierele pot fi trimise între clienții/serverele Binder utilizând tipul "
"`ParcelFileDescriptor`:"

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "/** The same thing, but loads info from a file. */"
msgstr "/** Același lucru, dar încarcă informații dintr-un fișier. */"

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "// Open a file and put the birthday info in it.\n"
msgstr ""
"// Deschideți un fișier și puneți informațiile despre ziua de naștere în "
"el.\n"

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "\"/data/local/tmp/birthday.info\""
msgstr "\"/data/local/tmp/birthday.info\""

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "\"{name}\""
msgstr "Nume registru"

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "\"{years}\""
msgstr "\"{years}\""

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "// Create a `ParcelFileDescriptor` from the file and send it.\n"
msgstr "// Creați un `ParcelFileDescriptor` din fișier și trimiteți-l.\n"

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "**birthday_service/src/lib.rs**:"
msgstr "_birthday_service/src/lib.rs_:"

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid ""
"// Convert the file descriptor to a `File`. `ParcelFileDescriptor` wraps\n"
"        // an `OwnedFd`, which can be cloned and then used to create a "
"`File`\n"
"        // object.\n"
msgstr ""
"// Conversia descriptorului de fișier într-un `File`. `ParcelFileDescriptor` "
"înfășoară\n"
"        // un `OwnedFd`, care poate fi clonat și apoi utilizat pentru a crea "
"un `File`\n"
"        // obiect.\n"

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "\"Invalid file handle\""
msgstr "\"Lungime invalidă\""

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid ""
"`ParcelFileDescriptor` wraps an `OwnedFd`, and so can be created from a "
"`File` (or any other type that wraps an `OwnedFd`), and can be used to "
"create a new `File` handle on the other side."
msgstr ""
"`ParcelFileDescriptor` înfășoară un `OwnedFd` și, prin urmare, poate fi "
"creat dintr-un `File` (sau orice alt tip care înfășoară un `OwnedFd`) și "
"poate fi utilizat pentru a crea un nou handle `File` pe partea cealaltă."

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid ""
"Other types of file descriptors can be wrapped and sent, e.g. TCP, UDP, and "
"UNIX sockets."
msgstr ""
"Alte tipuri de descriptori de fișiere pot fi înfășurate și trimise, de "
"exemplu, TCP, UDP și socket-uri UNIX."

#: src/android/testing.md
#, fuzzy
msgid "Testing in Android"
msgstr "Rust în Android"

#: src/android/testing.md
#, fuzzy
msgid ""
"Building on [Testing](../testing.md), we will now look at how unit tests "
"work in AOSP. Use the `rust_test` module for your unit tests:"
msgstr ""
"Pornind de la [Testing](../testing.md), vom analiza acum modul în care "
"funcționează testele unitare în AOSP. Utilizați modulul `rust_test` pentru "
"testele unitare:"

#: src/android/testing.md
#, fuzzy
msgid "_testing/Android.bp_:"
msgstr "hello_rust/Android.bp_:"

#: src/android/testing.md
#, fuzzy
msgid "\"libleftpad\""
msgstr "\"libtextwrap\""

#: src/android/testing.md
#, fuzzy
msgid "\"leftpad\""
msgstr "\"leftpad\""

#: src/android/testing.md
#, fuzzy
msgid "\"libleftpad_test\""
msgstr "\"libbirthday_bindgen_test\""

#: src/android/testing.md
#, fuzzy
msgid "\"leftpad_test\""
msgstr "\"leftpad_test\""

#: src/android/testing.md src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"general-tests\""
msgstr "Rust nesigur"

#: src/android/testing.md
#, fuzzy
msgid "_testing/src/lib.rs_:"
msgstr "hello_rust/src/lib.rs_:"

#: src/android/testing.md
#, fuzzy
msgid "//! Left-padding library.\n"
msgstr "//! Biblioteca de felicitări.\n"

#: src/android/testing.md
#, fuzzy
msgid "/// Left-pad `s` to `width`.\n"
msgstr "/// Introduceți la stânga `s` în `width`.\n"

#: src/android/testing.md
msgid "\"{s:>width$}\""
msgstr "\"{s:>width$}\""

#: src/android/testing.md
#, fuzzy
msgid "\"  foo\""
msgstr "\"foo\""

#: src/android/testing.md
#, fuzzy
msgid "\"foobar\""
msgstr "\"foo\""

#: src/android/testing.md
#, fuzzy
msgid "You can now run the test with"
msgstr "Acum puteți să generați automat legăturile:"

#: src/android/testing.md
#, fuzzy
msgid "The output looks like this:"
msgstr "Abordarea generală arată în felul următor:"

#: src/android/testing.md
#, fuzzy
msgid ""
"```text\n"
"INFO: Elapsed time: 2.666s, Critical Path: 2.40s\n"
"INFO: 3 processes: 2 internal, 1 linux-sandbox.\n"
"INFO: Build completed successfully, 3 total actions\n"
"//comprehensive-rust-android/testing:libleftpad_test_host            PASSED "
"in 2.3s\n"
"    PASSED  libleftpad_test.tests::long_string (0.0s)\n"
"    PASSED  libleftpad_test.tests::short_string (0.0s)\n"
"Test cases: finished with 2 passing and 0 failing out of 2 test cases\n"
"```"
msgstr ""
"```text\n"
"INFO: Timp scurs: 2.666s, Calea critică: 2.40s\n"
"INFO: 3 procese: 2 interne, 1 linux-sandbox.\n"
"INFO: Construirea s-a finalizat cu succes, 3 acțiuni totale\n"
"//comprehensive-rust-android/testing/testing:libleftpad_test_host A TRECUT "
"în 2.3s\n"
"    A TRECUT libleftpad_test.tests::long_string (0.0s)\n"
"    A TRECUT libleftpad_test.tests::short_string (0.0s)\n"
"Cazuri de testare: finalizat cu 2 cazuri de trecere și 0 eșecuri din 2 "
"cazuri de testare\n"
"```"

#: src/android/testing.md
#, fuzzy
msgid ""
"Notice how you only mention the root of the library crate. Tests are found "
"recursively in nested modules."
msgstr ""
"Observați că ați menționat doar rădăcina bibliotecii. Testele se găsesc "
"recursiv în modulele imbricate."

#: src/android/testing/googletest.md
#, fuzzy
msgid ""
"The [GoogleTest](https://docs.rs/googletest/) crate allows for flexible test "
"assertions using _matchers_:"
msgstr ""
"[googletest](https://docs.rs/googletest): Bibliotecă cuprinzătoare de "
"testare a afirmațiilor de testare în tradiția GoogleTest pentru C++."

#: src/android/testing/googletest.md
#, fuzzy
msgid "\"baz\""
msgstr "\"baz\""

#: src/android/testing/googletest.md
#, fuzzy
msgid "\"xyz\""
msgstr "\"xyz\""

#: src/android/testing/googletest.md
#, fuzzy
msgid ""
"If we change the last element to `\"!\"`, the test fails with a structured "
"error message pin-pointing the error:"
msgstr ""
"Dacă schimbăm ultimul element în `\"!\"`, testul eșuează cu un mesaj de "
"eroare structurat care indică eroarea:"

#: src/android/testing/googletest.md
#, fuzzy
msgid ""
"GoogleTest is not part of the Rust Playground, so you need to run this "
"example in a local environment. Use `cargo add googletest` to quickly add it "
"to an existing Cargo project."
msgstr ""
"GoogleTest nu face parte din Rust Playground, așa că trebuie să executați "
"acest exemplu într-un mediu local. Utilizați `cargo add googletest` pentru a-"
"l adăuga rapid la un proiect Cargo existent."

#: src/android/testing/googletest.md
#, fuzzy
msgid ""
"The `use googletest::prelude::*;` line imports a number of [commonly used "
"macros and types](https://docs.rs/googletest/latest/googletest/prelude/index."
"html)."
msgstr ""
"Linia `use googletest::prelude::*;` importă un număr de [macros și tipuri "
"utilizate în mod obișnuit](https://docs.rs/googletest/latest/googletest/"
"prelude/index.html)."

#: src/android/testing/googletest.md
#, fuzzy
msgid ""
"This just scratches the surface, there are many builtin matchers. Consider "
"going through the first chapter of [\"Advanced testing for Rust "
"applications\"](https://github.com/mainmatter/rust-advanced-testing-"
"workshop), a self-guided Rust course: it provides a guided introduction to "
"the library, with exercises to help you get comfortable with `googletest` "
"macros, its matchers and its overall philosophy."
msgstr ""
"Acest lucru este doar o mică parte, deoarece există numeroase elemente de "
"potrivire încorporate. Luați în considerare parcurgerea primului capitol din "
"[\"Testare avansată pentru aplicații Rust\"](https://github.com/mainmatter/"
"rust-advanced-testing-workshop), un curs Rust auto-ghidat: acesta oferă o "
"introducere ghidată în bibliotecă, cu exerciții care să vă ajute să vă "
"acomodați cu macro-urile `googletest`, cu potrivitorii săi și cu filozofia "
"sa generală."

#: src/android/testing/googletest.md
#, fuzzy
msgid ""
"A particularly nice feature is that mismatches in multi-line strings are "
"shown as a diff:"
msgstr ""
"O caracteristică deosebit de plăcută este faptul că neconcordanțele în "
"șirurile de caractere de mai multe linii sunt afișate sub forma unui dif:"

#: src/android/testing/googletest.md
#, fuzzy
msgid ""
"\"Memory safety found,\\n\\\n"
"                 Rust's strong typing guides the way,\\n\\\n"
"                 Secure code you'll write.\""
msgstr ""
"\"Memory safety found,\\n\\\n"
"                 Tiparea puternică a lui Rust ne ghidează în acest sens\n"
"                 Cod sigur pe care îl veți scrie.\""

#: src/android/testing/googletest.md
#, fuzzy
msgid ""
"\"Memory safety found,\\n\\\n"
"            Rust's silly humor guides the way,\\n\\\n"
"            Secure code you'll write.\""
msgstr ""
"\"Memory safety found,\\n\\\n"
"            Umorul caraghios al lui Rust ne ghidează în acest sens\n"
"            Cod sigur pe care îl vei scrie.\""

#: src/android/testing/googletest.md
#, fuzzy
msgid "shows a color-coded diff (colors not shown here):"
msgstr "prezintă o diferență de culori (culorile nu sunt prezentate aici):"

#: src/android/testing/googletest.md
#, fuzzy
msgid ""
"The crate is a Rust port of [GoogleTest for C++](https://google.github.io/"
"googletest/)."
msgstr ""
"Crate este un port Rust al [GoogleTest for C++](https://google.github.io/"
"googletest/)."

#: src/android/testing/mocking.md
#, fuzzy
msgid ""
"For mocking, [Mockall](https://docs.rs/mockall/) is a widely used library. "
"You need to refactor your code to use traits, which you can then quickly "
"mock:"
msgstr ""
"Pentru mocking, [Mockall](https://docs.rs/mockall/) este o bibliotecă "
"utilizată pe scară largă. Trebuie să vă refactorizați codul pentru a utiliza "
"trăsături, pe care le puteți apoi mock-ui rapid:"

#: src/android/testing/mocking.md
#, fuzzy
msgid ""
"Mockall is the recommended mocking library in Android (AOSP). There are "
"other [mocking libraries available on crates.io](https://crates.io/keywords/"
"mock), in particular in the area of mocking HTTP services. The other mocking "
"libraries work in a similar fashion as Mockall, meaning that they make it "
"easy to get a mock implementation of a given trait."
msgstr ""
"Sfatul de aici este pentru Android (AOSP), unde Mockall este biblioteca de "
"mocking recomandată. Există și alte [biblioteci de mocking disponibile pe "
"crates.io](https://crates.io/keywords/mock), în special în domeniul mocking-"
"ului serviciilor HTTP. Celelalte biblioteci de mocking funcționează într-un "
"mod similar cu Mockall, ceea ce înseamnă că acestea facilitează obținerea "
"unei implementări simulate a unei anumite trăsături."

#: src/android/testing/mocking.md
#, fuzzy
msgid ""
"Note that mocking is somewhat _controversial_: mocks allow you to completely "
"isolate a test from its dependencies. The immediate result is faster and "
"more stable test execution. On the other hand, the mocks can be configured "
"wrongly and return output different from what the real dependencies would do."
msgstr ""
"Rețineți că mocking-ul este oarecum _controversat_: mocks vă permite să "
"izolați complet un test de dependențele sale. Rezultatul imediat este o "
"execuție mai rapidă și mai stabilă a testelor. Pe de altă parte, mock-urile "
"pot fi configurate greșit și pot returna rezultate diferite de cele pe care "
"le-ar face dependențele reale."

#: src/android/testing/mocking.md
#, fuzzy
msgid ""
"If at all possible, it is recommended that you use the real dependencies. As "
"an example, many databases allow you to configure an in-memory backend. This "
"means that you get the correct behavior in your tests, plus they are fast "
"and will automatically clean up after themselves."
msgstr ""
"Dacă este posibil, se recomandă să folosiți dependențele reale. Ca exemplu, "
"multe baze de date vă permit să configurați un backend în memorie. Acest "
"lucru înseamnă că obțineți comportamentul corect în testele dvs., în plus, "
"sunt rapide și se vor curăța automat după ele însele."

#: src/android/testing/mocking.md
#, fuzzy
msgid ""
"Similarly, many web frameworks allow you to start an in-process server which "
"binds to a random port on `localhost`. Always prefer this over mocking away "
"the framework since it helps you test your code in the real environment."
msgstr ""
"În mod similar, multe cadre web vă permit să porniți un server în proces "
"care se leagă la un port aleatoriu pe `localhost`. Preferați întotdeauna "
"acest lucru în locul mocking-ului în afara cadrului, deoarece vă ajută să vă "
"testați codul în mediul real."

#: src/android/testing/mocking.md
#, fuzzy
msgid ""
"Mockall is not part of the Rust Playground, so you need to run this example "
"in a local environment. Use `cargo add mockall` to quickly add Mockall to an "
"existing Cargo project."
msgstr ""
"Mockall nu face parte din Rust Playground, așa că trebuie să executați acest "
"exemplu într-un mediu local. Utilizați `cargo add mockall` pentru a adăuga "
"rapid Mockall la un proiect Cargo existent."

#: src/android/testing/mocking.md
#, fuzzy
msgid ""
"Mockall has a lot more functionality. In particular, you can set up "
"expectations which depend on the arguments passed. Here we use this to mock "
"a cat which becomes hungry 3 hours after the last time it was fed:"
msgstr ""
"Mockall are mult mai multe funcționalități. În special, puteți configura "
"așteptări care depind de argumentele transmise. Aici folosim acest lucru "
"pentru a imita o pisică care devine flămândă la 3 ore după ce a fost hrănită "
"ultima dată:"

#: src/android/testing/mocking.md
#, fuzzy
msgid ""
"You can use `.times(n)` to limit the number of times a mock method can be "
"called to `n` --- the mock will automatically panic when dropped if this "
"isn't satisfied."
msgstr ""
"Puteți utiliza `.times(n)` pentru a limita numărul de apeluri ale unei "
"metode mock la `n` --- mock-ul va intra automat în panică atunci când va fi "
"abandonat dacă acest lucru nu este îndeplinit."

#: src/android/logging.md
#, fuzzy
msgid ""
"You should use the `log` crate to automatically log to `logcat` (on-device) "
"or `stdout` (on-host):"
msgstr ""
"Ar trebui să folosiți caseta `log` pentru a înregistra automat în `logcat` "
"(pe dispozitiv) sau `stdout` (pe gazdă):"

#: src/android/logging.md
#, fuzzy
msgid "_hello_rust_logs/Android.bp_:"
msgstr "salut_rust_logs/Android.bp_:"

#: src/android/logging.md
#, fuzzy
msgid "\"hello_rust_logs\""
msgstr "salut_rust_logs/Android.bp_:"

#: src/android/logging.md
#, fuzzy
msgid "\"liblog_rust\""
msgstr "\"liblog_rust\""

#: src/android/logging.md
#, fuzzy
msgid "\"liblogger\""
msgstr "\"liblogger\""

#: src/android/logging.md
#, fuzzy
msgid "_hello_rust_logs/src/main.rs_:"
msgstr "hello_rust_logs/src/main.rs_:"

#: src/android/logging.md
#, fuzzy
msgid "//! Rust logging demo.\n"
msgstr "//! Demonstrație de logare Rust.\n"

#: src/android/logging.md
#, fuzzy
msgid "/// Logs a greeting.\n"
msgstr "/// Înregistrează o salutare.\n"

#: src/android/logging.md
#, fuzzy
msgid "\"rust\""
msgstr ""
"Concurența în Rust:\n"
"A se vedea [Concurența în Rust](concurrency.md)."

#: src/android/logging.md
#, fuzzy
msgid "\"Starting program.\""
msgstr "\"Program de pornire.\""

#: src/android/logging.md
#, fuzzy
msgid "\"Things are going fine.\""
msgstr "\"Lucrurile merg bine.\""

#: src/android/logging.md
#, fuzzy
msgid "\"Something went wrong!\""
msgstr "\"Ceva a mers prost!\""

#: src/android/logging.md src/android/interoperability/with-c/bindgen.md
#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "Build, push, and run the binary on your device:"
msgstr ""
"Creați, distribuiți și rulați programul binar pe dispozitivul dumneavoastră:"

#: src/android/logging.md
#, fuzzy
msgid ""
"```shell\n"
"m hello_rust_logs\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/hello_rust_logs\n"
"```"
msgstr ""
"```shell\n"
"m hello_rust_logs\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/hello_rust_logs\n"
"```"

#: src/android/logging.md
#, fuzzy
msgid "The logs show up in `adb logcat`:"
msgstr "Jurnalele apar în `adb logcat`:"

#: src/android/interoperability.md
#, fuzzy
msgid ""
"Rust has excellent support for interoperability with other languages. This "
"means that you can:"
msgstr ""
"Rust are un suport excelent pentru interoperabilitatea cu alte limbaje. "
"Acest lucru înseamnă că puteți:"

#: src/android/interoperability.md
#, fuzzy
msgid "Call Rust functions from other languages."
msgstr "Apelarea funcțiilor Rust din alte limbaje."

#: src/android/interoperability.md
#, fuzzy
msgid "Call functions written in other languages from Rust."
msgstr "Apelarea funcțiilor scrise în alte limbaje din Rust."

#: src/android/interoperability.md
#, fuzzy
msgid ""
"When you call functions in a foreign language we say that you're using a "
"_foreign function interface_, also known as FFI."
msgstr ""
"Atunci când apelați funcții într-o limbă străină, spunem că utilizați o "
"_interfață de funcții străine_, cunoscută și sub numele de FFI."

#: src/android/interoperability/with-c.md
#, fuzzy
msgid "Interoperability with C"
msgstr "Interoperabilitatea cu C++"

#: src/android/interoperability/with-c.md
#, fuzzy
msgid ""
"Rust has full support for linking object files with a C calling convention. "
"Similarly, you can export Rust functions and call them from C."
msgstr ""
"Rust are un suport complet pentru legarea fișierelor de obiecte cu o "
"convenție de apelare C. În mod similar, puteți exporta funcții Rust și le "
"puteți apela din C."

#: src/android/interoperability/with-c.md
#, fuzzy
msgid "You can do it by hand if you want:"
msgstr "Puteți să o faceți manual, dacă doriți:"

#: src/android/interoperability/with-c.md
#, fuzzy
msgid "// SAFETY: `abs` doesn't have any safety requirements.\n"
msgstr "// SIGURANȚĂ: `abs` nu are nicio cerință de siguranță.\n"

#: src/android/interoperability/with-c.md
#, fuzzy
msgid "\"{x}, {abs_x}\""
msgstr "\"{x}, {abs_x}\""

#: src/android/interoperability/with-c.md
#, fuzzy
msgid ""
"We already saw this in the [Safe FFI Wrapper exercise](../../exercises/day-3/"
"safe-ffi-wrapper.md)."
msgstr ""
"Am văzut deja acest lucru în [Exercițiul [Safe FFI Wrapper] (../../exerciții/"
"zi-3/safe-ffi-wrapper.md)."

#: src/android/interoperability/with-c.md
#, fuzzy
msgid ""
"This assumes full knowledge of the target platform. Not recommended for "
"production."
msgstr ""
"Acest lucru presupune cunoașterea completă a platformei țintă. Nu se "
"recomandă pentru producție."

#: src/android/interoperability/with-c.md
#, fuzzy
msgid "We will look at better options next."
msgstr "În continuare, vom examina opțiuni mai bune."

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "Using Bindgen"
msgstr "Utilizarea Bindgen"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid ""
"The [bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html) "
"tool can auto-generate bindings from a C header file."
msgstr ""
"Instrumentul [bindgen](https://rust-lang.github.io/rust-bindgen/introduction."
"html) poate genera automat legăturile dintr-un fișier de antet C."

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "First create a small C library:"
msgstr "Mai întâi creați o mică bibliotecă C:"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "_interoperability/bindgen/libbirthday.h_:"
msgstr "interoperabilitate/bindgen/libbirthday.h_:"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "_interoperability/bindgen/libbirthday.c_:"
msgstr "interoperabilitate/bindgen/libbirthday.c_:"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "<stdio.h>"
msgstr "<stdio.h>"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"libbirthday.h\""
msgstr ""
"```c\n"
"#include \"libbirthday.h\"\n"
"```"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"+--------------\\n\""
msgstr "\"fib(n) = {}\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"| Happy Birthday %s!\\n\""
msgstr "\"| La mulți ani %s!\\n\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"| Congratulations with the %i years!\\n\""
msgstr "\"| Felicitări cu %i ani!\\n\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "Add this to your `Android.bp` file:"
msgstr "Adăugați acest lucru la fișierul `Android.bp`:"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "_interoperability/bindgen/Android.bp_:"
msgstr "interoperabilitate/bindgen/Android.bp_:"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"libbirthday\""
msgstr "\"libbirthday\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"libbirthday.c\""
msgstr "\"libbirthday.c\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid ""
"Create a wrapper header file for the library (not strictly needed in this "
"example):"
msgstr ""
"Creați un fișier de antet de înfășurare pentru bibliotecă (nu este strict "
"necesar în acest exemplu):"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "_interoperability/bindgen/libbirthday_wrapper.h_:"
msgstr "interoperabilitate/bindgen/libbirthday_wrapper.h_:"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "You can now auto-generate the bindings:"
msgstr "Acum puteți să generați automat legăturile:"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"libbirthday_bindgen\""
msgstr "\"libbirthday_bindgen\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"birthday_bindgen\""
msgstr "`rust_bindgen`"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"libbirthday_wrapper.h\""
msgstr "\"libbirthday_wrapper.h\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"bindings\""
msgstr "Exemple de legături"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "Finally, we can use the bindings in our Rust program:"
msgstr "În cele din urmă, putem utiliza legăturile în programul nostru Rust:"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"print_birthday_card\""
msgstr "\"print_birthday_card\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"main.rs\""
msgstr "_main.rs_:"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "_interoperability/bindgen/main.rs_:"
msgstr "interoperabilitate/bindgen/main.rs_:"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "//! Bindgen demo.\n"
msgstr "//! Bindgen demo.\n"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid ""
"// SAFETY: The pointer we pass is valid because it came from a Rust\n"
"    // reference, and the `name` it contains refers to `name` above which "
"also\n"
"    // remains valid. `print_card` doesn't store either pointer to use "
"later\n"
"    // after it returns.\n"
msgstr ""
"// SIGURANȚĂ: Pointerul pe care îl trecem este valid pentru că provine dintr-"
"un Rust\n"
"    // referință, iar `name` pe care îl conține se referă la `name` de mai "
"sus, care de asemenea\n"
"    // rămâne valabil. `print_card` nu stochează niciunul dintre cei doi "
"pointeri pentru a-i folosi ulterior\n"
"    // după ce se întoarce.\n"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid ""
"```shell\n"
"m print_birthday_card\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/print_birthday_card\n"
"```"
msgstr ""
"```shell\n"
"m print_birthday_card\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/print_birthday_card\n"
"```"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "Finally, we can run auto-generated tests to ensure the bindings work:"
msgstr ""
"În cele din urmă, putem rula teste generate automat pentru a ne asigura că "
"legăturile funcționează:"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"libbirthday_bindgen_test\""
msgstr "\"libbirthday_bindgen_test\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\":libbirthday_bindgen\""
msgstr "\":libbirthday_bindgen\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"none\""
msgstr ""
"```rust,editabile\n"
"fn main() {\n"
"    match std::env::args().next().as_deref() {\n"
"        Some(\"cat\") => println!(\"Va face lucruri de pisică\"),\n"
"        Some(\"ls\") => println!(\"Va face ls unor fișiere\"),\n"
"        Some(\"mv\") => println!(\"Va muta niște fișiere\"),\n"
"        Some(\"rm\") => println!(\"Uh, periculos!\"),\n"
"        None => println!(\"Hmm, niciun nume de program?\"),\n"
"        _ => println!(\"Nume de program necunoscut!\"),\n"
"    }\n"
"}\n"
"```"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "// Generated file, skip linting\n"
msgstr "// Fișier generat, săriți linting\n"

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "Calling Rust"
msgstr "Apelarea Rust din C"

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "Exporting Rust functions and types to C is easy:"
msgstr "Exportul funcțiilor și tipurilor Rust în C este ușor:"

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "_interoperability/rust/libanalyze/analyze.rs_"
msgstr "interoperabilitate/interoperabilitate/rust/libanalyze/analyze.rs_"

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "//! Rust FFI demo.\n"
msgstr "//! Demonstrație Rust FFI.\n"

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "/// Analyze the numbers.\n"
msgstr "/// Analizați numerele.\n"

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "\"x ({x}) is smallest!\""
msgstr "\"x ({x}) este cel mai mic!\""

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "\"y ({y}) is probably larger than x ({x})\""
msgstr "\"y ({y}) este probabil mai mare decât x ({x})\""

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "_interoperability/rust/libanalyze/analyze.h_"
msgstr "interoperabilitate/interoperabilitate/rust/libanalyze/analyze.h_"

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "_interoperability/rust/libanalyze/Android.bp_"
msgstr "interoperabilitate/interoperabilitate/rusine/libanaliza/Android.bp_"

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "\"libanalyze_ffi\""
msgstr "\"libanalyze_ffi\""

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "\"analyze_ffi\""
msgstr "\"analyze_ffi\""

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "\"analyze.rs\""
msgstr "\"analyze.rs\""

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "We can now call this from a C binary:"
msgstr "Acum putem apela acest lucru dintr-un binar C:"

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "_interoperability/rust/analyze/main.c_"
msgstr "interoperabilitate/rust/analiza/main.c_"

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "\"analyze.h\""
msgstr "\"analyze.h\""

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "_interoperability/rust/analyze/Android.bp_"
msgstr "interoperabilitate/încălzire/antreprenoriat/analiza/Android.bp_"

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "\"analyze_numbers\""
msgstr "\"analyze_numbers\""

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "\"main.c\""
msgstr "\"main.c\""

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid ""
"```shell\n"
"m analyze_numbers\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/analyze_numbers\n"
"```"
msgstr ""
"```shell\n"
"m analyze_numbers\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/analyze_numbers\n"
"```"

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid ""
"`#[no_mangle]` disables Rust's usual name mangling, so the exported symbol "
"will just be the name of the function. You can also use `#[export_name = "
"\"some_name\"]` to specify whatever name you want."
msgstr ""
"`#[no_mangle]` dezactivează manipularea obișnuită a numelor din Rust, astfel "
"încât simbolul exportat va fi doar numele funcției. De asemenea, puteți "
"utiliza `#[export_name = \"some_name\"]` pentru a specifica orice nume "
"doriți."

#: src/android/interoperability/cpp.md
#, fuzzy
msgid ""
"The [CXX crate](https://cxx.rs/) makes it possible to do safe "
"interoperability between Rust and C++."
msgstr ""
"[CXX crate](https://cxx.rs/) face posibilă realizarea unei "
"interoperabilități sigure între Rust și C++."

#: src/android/interoperability/cpp.md
#, fuzzy
msgid "The overall approach looks like this:"
msgstr "Abordarea generală arată în felul următor:"

#: src/android/interoperability/cpp/bridge.md
#, fuzzy
msgid ""
"CXX relies on a description of the function signatures that will be exposed "
"from each language to the other. You provide this description using extern "
"blocks in a Rust module annotated with the `#[cxx::bridge]` attribute macro."
msgstr ""
"CXX se bazează pe o descriere a semnăturilor funcțiilor care vor fi expuse "
"de la un limbaj la celălalt. Această descriere este furnizată cu ajutorul "
"blocurilor externe dintr-un modul Rust adnotat cu macroul atribut `#[cxx::"
"bridge]`."

#: src/android/interoperability/cpp/bridge.md
#, fuzzy
msgid "\"org::blobstore\""
msgstr "\"org::blobstore\""

#: src/android/interoperability/cpp/bridge.md
#, fuzzy
msgid "// Shared structs with fields visible to both languages.\n"
msgstr "// Structuri partajate cu câmpuri vizibile pentru ambele limbi.\n"

#: src/android/interoperability/cpp/bridge.md
#: src/android/interoperability/cpp/generated-cpp.md
#, fuzzy
msgid "// Rust types and signatures exposed to C++.\n"
msgstr "// Tipuri și semnături Rust expuse în C++.\n"

#: src/android/interoperability/cpp/bridge.md
#: src/android/interoperability/cpp/rust-bridge.md
#: src/android/interoperability/cpp/generated-cpp.md
#: src/android/interoperability/cpp/rust-result.md
#: src/chromium/interoperability-with-cpp/example-bindings.md
#: src/chromium/interoperability-with-cpp/error-handling-qr.md
#: src/chromium/interoperability-with-cpp/error-handling-png.md
#, fuzzy
msgid "\"Rust\""
msgstr ""
"Concurența în Rust:\n"
"A se vedea [Concurența în Rust](concurrency.md)."

#: src/android/interoperability/cpp/bridge.md
#: src/android/interoperability/cpp/cpp-bridge.md
#, fuzzy
msgid "// C++ types and signatures exposed to Rust.\n"
msgstr "// Tipuri și semnături C++ expuse în Rust.\n"

#: src/android/interoperability/cpp/bridge.md
#: src/android/interoperability/cpp/cpp-bridge.md
#: src/android/interoperability/cpp/cpp-exception.md
#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid "\"C++\""
msgstr "Cu C"

#: src/android/interoperability/cpp/bridge.md
#: src/android/interoperability/cpp/cpp-bridge.md
#, fuzzy
msgid "\"include/blobstore.h\""
msgstr "\"include/blobstore.h\""

#: src/android/interoperability/cpp/bridge.md
#, fuzzy
msgid "The bridge is generally declared in an `ffi` module within your crate."
msgstr ""
"Puntea este, în general, declarată într-un modul `ffi` din cadrul seriei "
"dumneavoastră."

#: src/android/interoperability/cpp/bridge.md
#, fuzzy
msgid ""
"From the declarations made in the bridge module, CXX will generate matching "
"Rust and C++ type/function definitions in order to expose those items to "
"both languages."
msgstr ""
"Din declarațiile făcute în modulul punte, CXX va genera definiții de tip/"
"funcție Rust și C++ corespunzătoare pentru a expune aceste elemente în "
"ambele limbaje."

#: src/android/interoperability/cpp/bridge.md
#, fuzzy
msgid ""
"To view the generated Rust code, use [cargo-expand](https://github.com/"
"dtolnay/cargo-expand) to view the expanded proc macro. For most of the "
"examples you would use `cargo expand ::ffi` to expand just the `ffi` module "
"(though this doesn't apply for Android projects)."
msgstr ""
"Pentru a vizualiza codul Rust generat, utilizați [cargo-expand](https://"
"github.com/dtolnay/cargo-expand) pentru a vizualiza macroul proc extins. "
"Pentru majoritatea exemplelor, veți folosi `cargo expand ::ffi` pentru a "
"extinde doar modulul `ffi` (deși acest lucru nu se aplică pentru proiectele "
"Android)."

#: src/android/interoperability/cpp/bridge.md
#, fuzzy
msgid "To view the generated C++ code, look in `target/cxxbridge`."
msgstr "Pentru a vizualiza codul C++ generat, căutați în `target/cxxbridge`."

#: src/android/interoperability/cpp/rust-bridge.md
#, fuzzy
msgid "Rust Bridge Declarations"
msgstr "Declarații Rust Bridge"

#: src/android/interoperability/cpp/rust-bridge.md
#, fuzzy
msgid "// Opaque type\n"
msgstr "// Tip opac\n"

#: src/android/interoperability/cpp/rust-bridge.md
#, fuzzy
msgid "// Method on `MyType`\n"
msgstr "// Metoda pe `MyType`\n"

#: src/android/interoperability/cpp/rust-bridge.md
#, fuzzy
msgid "// Free function\n"
msgstr "funcție:"

#: src/android/interoperability/cpp/rust-bridge.md
#, fuzzy
msgid ""
"Items declared in the `extern \"Rust\"` reference items that are in scope in "
"the parent module."
msgstr ""
"Elementele declarate în modulul `extern \"Rust\"` fac trimitere la elemente "
"care se află în domeniul de aplicare în modulul părinte."

#: src/android/interoperability/cpp/rust-bridge.md
#, fuzzy
msgid ""
"The CXX code generator uses your `extern \"Rust\"` section(s) to produce a C+"
"+ header file containing the corresponding C++ declarations. The generated "
"header has the same path as the Rust source file containing the bridge, "
"except with a .rs.h file extension."
msgstr ""
"Generatorul de cod CXX utilizează secțiunea (secțiunile) `extern \"Rust\"` "
"pentru a produce un fișier antet C++ care conține declarațiile C++ "
"corespunzătoare. Antetul generat are aceeași cale ca și fișierul sursă Rust "
"care conține puntea, dar cu extensia de fișier .rs.h."

#: src/android/interoperability/cpp/generated-cpp.md
#, fuzzy
msgid "Results in (roughly) the following C++:"
msgstr "Rezultă (aproximativ) următorul C++:"

#: src/android/interoperability/cpp/cpp-bridge.md
#, fuzzy
msgid "C++ Bridge Declarations"
msgstr "Declarații de punte C++"

#: src/android/interoperability/cpp/cpp-bridge.md
#, fuzzy
msgid "Results in (roughly) the following Rust:"
msgstr "Rezultă (aproximativ) următorul Rust:"

#: src/android/interoperability/cpp/cpp-bridge.md
#, fuzzy
msgid "\"org$blobstore$cxxbridge1$new_blobstore_client\""
msgstr "\"org$blobstore$cxxbridge1$new_blobstore_client\""

#: src/android/interoperability/cpp/cpp-bridge.md
#, fuzzy
msgid "\"org$blobstore$cxxbridge1$BlobstoreClient$put\""
msgstr "\"org$blobstore$cxxbridge1$BlobstoreClient$put\""

#: src/android/interoperability/cpp/cpp-bridge.md
#, fuzzy
msgid ""
"The programmer does not need to promise that the signatures they have typed "
"in are accurate. CXX performs static assertions that the signatures exactly "
"correspond with what is declared in C++."
msgstr ""
"Programatorul nu trebuie să promită că semnăturile pe care le-a introdus "
"sunt corecte. CXX efectuează verificări statice pentru a se asigura că "
"semnăturile corespund exact cu ceea ce este declarat în C++."

#: src/android/interoperability/cpp/cpp-bridge.md
#, fuzzy
msgid ""
"`unsafe extern` blocks allow you to declare C++ functions that are safe to "
"call from Rust."
msgstr ""
"blocurile `unsafe extern` vă permit să declarați funcții C++ care pot fi "
"apelate în siguranță din Rust."

#: src/android/interoperability/cpp/shared-types.md
#, fuzzy
msgid "// A=1, J=11, Q=12, K=13\n"
msgstr "// A=1, J=11, Q=12, K=13\n"

#: src/android/interoperability/cpp/shared-types.md
#, fuzzy
msgid "Only C-like (unit) enums are supported."
msgstr "Sunt acceptate numai enumerațiile de tip C (unitate)."

#: src/android/interoperability/cpp/shared-types.md
#, fuzzy
msgid ""
"A limited number of traits are supported for `#[derive()]` on shared types. "
"Corresponding functionality is also generated for the C++ code, e.g. if you "
"derive `Hash` also generates an implementation of `std::hash` for the "
"corresponding C++ type."
msgstr ""
"Un număr limitat de trăsături sunt acceptate pentru `#[derive()]` pe tipuri "
"partajate. Funcționalitatea corespunzătoare este, de asemenea, generată "
"pentru codul C++, de exemplu, dacă derivați `Hash`, se generează și o "
"implementare a `std::hash` pentru tipul C++ corespunzător."

#: src/android/interoperability/cpp/shared-enums.md
msgid "Generated Rust:"
msgstr "Cod Rust generat:"

#: src/android/interoperability/cpp/shared-enums.md
msgid "Generated C++:"
msgstr "Cod C++ generat:"

#: src/android/interoperability/cpp/shared-enums.md
#, fuzzy
msgid ""
"On the Rust side, the code generated for shared enums is actually a struct "
"wrapping a numeric value. This is because it is not UB in C++ for an enum "
"class to hold a value different from all of the listed variants, and our "
"Rust representation needs to have the same behavior."
msgstr ""
"În ceea ce privește Rust, codul generat pentru enumerațiile partajate este "
"de fapt o structură care înfășoară o valoare numerică. Acest lucru se "
"datorează faptului că nu este UB în C++ ca o clasă enum să dețină o valoare "
"diferită de toate variantele enumerate, iar reprezentarea noastră Rust "
"trebuie să aibă același comportament."

#: src/android/interoperability/cpp/rust-result.md
#, fuzzy
msgid "\"fallible1 requires depth > 0\""
msgstr "\"fallible1 necesită adâncime > 0\""

#: src/android/interoperability/cpp/rust-result.md
#, fuzzy
msgid "\"Success!\""
msgstr "\"Succes!\""

#: src/android/interoperability/cpp/rust-result.md
#, fuzzy
msgid ""
"Rust functions that return `Result` are translated to exceptions on the C++ "
"side."
msgstr ""
"Funcțiile Rust care returnează `Result` sunt transformate în excepții în "
"limbajul C++."

#: src/android/interoperability/cpp/rust-result.md
#, fuzzy
msgid ""
"The exception thrown will always be of type `rust::Error`, which primarily "
"exposes a way to get the error message string. The error message will come "
"from the error type's `Display` impl."
msgstr ""
"Excepția aruncată va fi întotdeauna de tipul `rust::Error`, care expune în "
"primul rând o modalitate de a obține șirul de mesaje de eroare. Mesajul de "
"eroare va proveni din implantul `Display` al tipului de eroare."

#: src/android/interoperability/cpp/rust-result.md
#, fuzzy
msgid ""
"A panic unwinding from Rust to C++ will always cause the process to "
"immediately terminate."
msgstr ""
"O dezarhivare de panică din Rust în C++ va determina întotdeauna terminarea "
"imediată a procesului."

#: src/android/interoperability/cpp/cpp-exception.md
#, fuzzy
msgid "\"example/include/example.h\""
msgstr "\"example/include/example.h\""

#: src/android/interoperability/cpp/cpp-exception.md
#, fuzzy
msgid "\"Error: {}\""
msgstr "Trăsături 'Error'"

#: src/android/interoperability/cpp/cpp-exception.md
#, fuzzy
msgid ""
"C++ functions declared to return a `Result` will catch any thrown exception "
"on the C++ side and return it as an `Err` value to the calling Rust function."
msgstr ""
"Funcțiile C++ declarate pentru a returna un `Result` vor prinde orice "
"excepție lansată în partea C++ și o vor returna ca valoare `Err` funcției "
"Rust care o apelează."

#: src/android/interoperability/cpp/cpp-exception.md
#, fuzzy
msgid ""
"If an exception is thrown from an extern \"C++\" function that is not "
"declared by the CXX bridge to return `Result`, the program calls C++'s `std::"
"terminate`. The behavior is equivalent to the same exception being thrown "
"through a `noexcept` C++ function."
msgstr ""
"Dacă o excepție este aruncată de o funcție externă \"C++\" care nu este "
"declarată de puntea CXX pentru a returna `Result`, programul apelează `std::"
"terminate` din C++. Comportamentul este echivalent cu cel al unei excepții "
"aruncate printr-o funcție `noexcept` C++."

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "C++ Type"
msgstr "Exemplu C++"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`rust::String`"
msgstr "`rust_bindgen`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`&str`"
msgstr "`&str`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`rust::Str`"
msgstr "`rust_test`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`CxxString`"
msgstr "Sir"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`std::string`"
msgstr "șir:"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`&[T]`/`&mut [T]`"
msgstr "`&[T]`/`&mut [T]`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`rust::Slice`"
msgstr "`rust_ffi`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`rust::Box<T>`"
msgstr "`rust::Box<T>`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`UniquePtr<T>`"
msgstr "`UniquePtr<T>`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`std::unique_ptr<T>`"
msgstr "`std::unique_ptr<T>`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`rust::Vec<T>`"
msgstr "`mpsc::Receiver<T>`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`CxxVector<T>`"
msgstr "`Celula<T>`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`std::vector<T>`"
msgstr "`mpsc::Receiver<T>`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid ""
"These types can be used in the fields of shared structs and the arguments "
"and returns of extern functions."
msgstr ""
"Aceste tipuri pot fi utilizate în câmpurile structurilor partajate și în "
"argumentele și returnările funcțiilor externe."

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid ""
"Note that Rust's `String` does not map directly to `std::string`. There are "
"a few reasons for this:"
msgstr ""
"Rețineți că `String` din Rust nu se referă direct la `std::string`. Există "
"câteva motive pentru acest lucru:"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid ""
"`std::string` does not uphold the UTF-8 invariant that `String` requires."
msgstr "`std::string` nu respectă invarianta UTF-8 pe care `String` o cere."

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid ""
"The two types have different layouts in memory and so can't be passed "
"directly between languages."
msgstr ""
"Cele două tipuri au configurații diferite în memorie și, prin urmare, nu pot "
"fi transmise direct între limbi."

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid ""
"`std::string` requires move constructors that don't match Rust's move "
"semantics, so a `std::string` can't be passed by value to Rust."
msgstr ""
"`std::string` necesită constructori de mutare care nu se potrivesc cu "
"semantica de mutare a Rust, astfel încât un `std::string` nu poate fi "
"transmis ca valoare către Rust."

#: src/android/interoperability/cpp/android-build-cpp.md
#: src/android/interoperability/cpp/android-cpp-genrules.md
#: src/android/interoperability/cpp/android-build-rust.md
#, fuzzy
msgid "Building in Android"
msgstr "Construirea pentru Android: C++"

#: src/android/interoperability/cpp/android-build-cpp.md
#, fuzzy
msgid ""
"Create a `cc_library_static` to build the C++ library, including the CXX "
"generated header and source file."
msgstr ""
"Creați o `cc_library_static` pentru a construi biblioteca C++, inclusiv "
"fișierul sursă și antetul generat de CXX."

#: src/android/interoperability/cpp/android-build-cpp.md
#: src/android/interoperability/cpp/android-build-rust.md
#, fuzzy
msgid "\"libcxx_test_cpp\""
msgstr "\"libcxx_test_cpp\""

#: src/android/interoperability/cpp/android-build-cpp.md
#, fuzzy
msgid "\"cxx_test.cpp\""
msgstr "\"cxx_test.cpp\""

#: src/android/interoperability/cpp/android-build-cpp.md
#, fuzzy
msgid "\"cxx-bridge-header\""
msgstr "\"cxx-bridge-header\""

#: src/android/interoperability/cpp/android-build-cpp.md
#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid "\"libcxx_test_bridge_header\""
msgstr "\"libcxx_test_bridge_header\""

#: src/android/interoperability/cpp/android-build-cpp.md
#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid "\"libcxx_test_bridge_code\""
msgstr "\"libcxx_test_bridge_code\""

#: src/android/interoperability/cpp/android-build-cpp.md
#, fuzzy
msgid ""
"Point out that `libcxx_test_bridge_header` and `libcxx_test_bridge_code` are "
"the dependencies for the CXX-generated C++ bindings. We'll show how these "
"are setup on the next slide."
msgstr ""
"Indicați că `libcxx_test_bridge_header` și `libcxx_test_bridge_code` sunt "
"dependențele pentru legăturile C++ generate de CXX. Vom arăta cum sunt "
"configurate acestea în slide-ul următor."

#: src/android/interoperability/cpp/android-build-cpp.md
#, fuzzy
msgid ""
"Note that you also need to depend on the `cxx-bridge-header` library in "
"order to pull in common CXX definitions."
msgstr ""
"Rețineți că trebuie să depindeți și de biblioteca `cxx-bridge-header` pentru "
"a trage definițiile CXX comune."

#: src/android/interoperability/cpp/android-build-cpp.md
#, fuzzy
msgid ""
"Full docs for using CXX in Android can be found in [the Android docs]"
"(https://source.android.com/docs/setup/build/rust/building-rust-modules/"
"android-rust-patterns#rust-cpp-interop-using-cxx). You may want to share "
"that link with the class so that students know where they can find these "
"instructions again in the future."
msgstr ""
"Documentația completă pentru utilizarea CXX în Android poate fi găsită în "
"[the Android docs](https://source.android.com/docs/setup/build/rust/building-"
"rust-modules/android-rust-patterns#rust-cpp-interop-using-cxx). Este posibil "
"să doriți să împărtășiți acest link cu clasa, astfel încât elevii să știe "
"unde pot găsi din nou aceste instrucțiuni în viitor."

#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid ""
"Create two genrules: One to generate the CXX header, and one to generate the "
"CXX source file. These are then used as inputs to the `cc_library_static`."
msgstr ""
"Creați două reguli de gen: Una pentru a genera antetul CXX și una pentru a "
"genera fișierul sursă CXX. Acestea sunt apoi folosite ca intrări în "
"`cc_library_static`."

#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid ""
"// Generate a C++ header containing the C++ bindings\n"
"// to the Rust exported functions in lib.rs.\n"
msgstr ""
"// Generați un antet C++ care să conțină legăturile C++\n"
"// la funcțiile exportate Rust din lib.rs.\n"

#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid "\"cxxbridge\""
msgstr "\"cxxbridge\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid "\"$(location cxxbridge) $(in) --header > $(out)\""
msgstr "\"$(location cxxbridge) $(in) --header > $(out)\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
#: src/android/interoperability/cpp/android-build-rust.md
#, fuzzy
msgid "\"lib.rs\""
msgstr "\"lib.rs\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid "\"lib.rs.h\""
msgstr "\"lib.rs.h\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid "// Generate the C++ code that Rust calls into.\n"
msgstr "// Generarea codului C++ pe care Rust îl apelează.\n"

#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid "\"$(location cxxbridge) $(in) > $(out)\""
msgstr "\"$(locația cxxbridge) $(in) > $(out)\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid "\"lib.rs.cc\""
msgstr "\"lib.rs.cc\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid ""
"The `cxxbridge` tool is a standalone tool that generates the C++ side of the "
"bridge module. It is included in Android and available as a Soong tool."
msgstr ""
"Instrumentul `cxxbridge` este un instrument independent care generează "
"partea C++ a modulului punte. Acesta este inclus în Android și este "
"disponibil ca instrument Soong."

#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid ""
"By convention, if your Rust source file is `lib.rs` your header file will be "
"named `lib.rs.h` and your source file will be named `lib.rs.cc`. This naming "
"convention isn't enforced, though."
msgstr ""
"Prin convenție, dacă fișierul sursă Rust este `lib.rs`, fișierul de antet se "
"va numi `lib.rs.h`, iar fișierul sursă se va numi `lib.rs.cc`. Totuși, "
"această convenție de denumire nu este impusă."

#: src/android/interoperability/cpp/android-build-rust.md
#, fuzzy
msgid ""
"Create a `rust_binary` that depends on `libcxx` and your `cc_library_static`."
msgstr ""
"Creați un `rust_binary` care depinde de `libcxx` și de `cc_library_static`."

#: src/android/interoperability/cpp/android-build-rust.md
#, fuzzy
msgid "\"cxx_test\""
msgstr "\"cxx_test\""

#: src/android/interoperability/cpp/android-build-rust.md
#, fuzzy
msgid "\"libcxx\""
msgstr "\"libcxx\""

#: src/android/interoperability/java.md
#, fuzzy
msgid "Interoperability with Java"
msgstr "Interoperabilitate cu Java"

#: src/android/interoperability/java.md
#, fuzzy
msgid ""
"Java can load shared objects via [Java Native Interface (JNI)](https://en."
"wikipedia.org/wiki/Java_Native_Interface). The [`jni` crate](https://docs.rs/"
"jni/) allows you to create a compatible library."
msgstr ""
"Java poate încărca obiecte partajate prin intermediul [Java Native Interface "
"(JNI)](https://en.wikipedia.org/wiki/Java_Native_Interface). Crăiasa [`jni` "
"crate](https://docs.rs/jni/) vă permite să creați o bibliotecă compatibilă."

#: src/android/interoperability/java.md
#, fuzzy
msgid "First, we create a Rust function to export to Java:"
msgstr "Mai întâi, creăm o funcție Rust pentru a exporta în Java:"

#: src/android/interoperability/java.md
#, fuzzy
msgid "_interoperability/java/src/lib.rs_:"
msgstr "interoperabilitate/java/src/lib.rs_:"

#: src/android/interoperability/java.md
#, fuzzy
msgid "//! Rust <-> Java FFI demo.\n"
msgstr "//! Rust <-> Java FFI demo.\n"

#: src/android/interoperability/java.md
#, fuzzy
msgid "/// HelloWorld::hello method implementation.\n"
msgstr "/// Implementarea metodei HelloWorld::hello.\n"

#: src/android/interoperability/java.md
#, fuzzy
msgid "\"system\""
msgstr "\"sistem\""

#: src/android/interoperability/java.md
#, fuzzy
msgid "\"Hello, {input}!\""
msgstr "\"Bună ziua, {input}!\""

#: src/android/interoperability/java.md
#, fuzzy
msgid "_interoperability/java/Android.bp_:"
msgstr "interoperabilitate/java/Android.bp_:"

#: src/android/interoperability/java.md
#, fuzzy
msgid "\"libhello_jni\""
msgstr "\"libhello_jni\""

#: src/android/interoperability/java.md
#, fuzzy
msgid "\"hello_jni\""
msgstr "\"hello_jni\""

#: src/android/interoperability/java.md
#, fuzzy
msgid "\"libjni\""
msgstr "\"libjni\""

#: src/android/interoperability/java.md
#, fuzzy
msgid "We then call this function from Java:"
msgstr "În cele din urmă, putem apela această funcție din Java:"

#: src/android/interoperability/java.md
#, fuzzy
msgid "_interoperability/java/HelloWorld.java_:"
msgstr "interoperabilitate/java/HelloWorld.java_:"

#: src/android/interoperability/java.md
#, fuzzy
msgid "\"helloworld_jni\""
msgstr "\"helloworld_jni\""

#: src/android/interoperability/java.md
#, fuzzy
msgid "\"HelloWorld.java\""
msgstr "Bună lume!"

#: src/android/interoperability/java.md
#, fuzzy
msgid "\"HelloWorld\""
msgstr "Bună lume!"

#: src/android/interoperability/java.md
#, fuzzy
msgid "Finally, you can build, sync, and run the binary:"
msgstr ""
"În cele din urmă, puteți să construiți, să sincronizați și să executați "
"programul binar:"

#: src/exercises/android/morning.md
#, fuzzy
msgid ""
"This is a group exercise: We will look at one of the projects you work with "
"and try to integrate some Rust into it. Some suggestions:"
msgstr ""
"Acesta este un exercițiu de grup: Ne vom uita la unul dintre proiectele la "
"care lucrați și vom încerca să integrăm în el Rust. Câteva sugestii:"

#: src/exercises/android/morning.md
#, fuzzy
msgid "Call your AIDL service with a client written in Rust."
msgstr "Apelați serviciul AIDL cu un client scris în Rust."

#: src/exercises/android/morning.md
#, fuzzy
msgid "Move a function from your project to Rust and call it."
msgstr "Mutați o funcție din proiectul dvs. în Rust și apelați-o."

#: src/exercises/android/morning.md
#, fuzzy
msgid ""
"No solution is provided here since this is open-ended: it relies on someone "
"in the class having a piece of code which you can turn in to Rust on the fly."
msgstr ""
"Nu se oferă nicio soluție aici, deoarece este o întrebare deschisă: se "
"bazează pe faptul că cineva din clasă are o bucată de cod pe care o puteți "
"transforma în Rust din mers."

#: src/chromium.md
#, fuzzy
msgid "Welcome to Rust in Chromium"
msgstr "Bine ați venit la Rust în Android"

#: src/chromium.md
#, fuzzy
msgid ""
"Rust is supported for third-party libraries in Chromium, with first-party "
"glue code to connect between Rust and existing Chromium C++ code."
msgstr ""
"Rust este suportat pentru bibliotecile terților în Chromium, cu un cod de "
"lipire de prima parte pentru a face legătura între Rust și codul C++ "
"existent în Chromium."

#: src/chromium.md
#, fuzzy
msgid ""
"Today, we'll call into Rust to do something silly with strings. If you've "
"got a corner of the code where you're displaying a UTF8 string to the user, "
"feel free to follow this recipe in your part of the codebase instead of the "
"exact part we talk about."
msgstr ""
"Astăzi, vom apela la Rust pentru a face ceva prostesc cu șiruri de "
"caractere. Dacă aveți un colț de cod în care afișați un șir UTF8 "
"utilizatorului, nu ezitați să urmați această rețetă în partea dvs. de bază "
"de cod în loc de partea despre care vorbim noi."

#: src/chromium/setup.md
#, fuzzy
msgid ""
"Make sure you can build and run Chromium. Any platform and set of build "
"flags is OK, so long as your code is relatively recent (commit position "
"1223636 onwards, corresponding to November 2023):"
msgstr ""
"Asigurați-vă că puteți construi și rula Chromium. Orice platformă și orice "
"set de indicatori de compilare este în regulă, atâta timp cât codul dvs. "
"este relativ recent (începând cu poziția de commit 1223636, corespunzând "
"lunii noiembrie 2023):"

#: src/chromium/setup.md
#, fuzzy
msgid ""
"(A component, debug build is recommended for quickest iteration time. This "
"is the default!)"
msgstr ""
"(Pentru un timp de iterație cât mai scurt, se recomandă o componentă, o "
"construcție de depanare. Aceasta este opțiunea implicită)"

#: src/chromium/setup.md
#, fuzzy
msgid ""
"See [How to build Chromium](https://www.chromium.org/developers/how-tos/get-"
"the-code/) if you aren't already at that point. Be warned: setting up to "
"build Chromium takes time."
msgstr ""
"Consultați [How to build Chromium](https://www.chromium.org/developers/how-"
"tos/get-the-code/) dacă nu ați ajuns deja în acest punct. Fiți atenți: "
"configurarea pentru a construi Chromium necesită timp."

#: src/chromium/setup.md
#, fuzzy
msgid "It's also recommended that you have Visual Studio code installed."
msgstr "De asemenea, se recomandă să aveți instalat codul Visual Studio."

#: src/chromium/setup.md
#, fuzzy
msgid "About the exercises"
msgstr "Despre exerciții"

#: src/chromium/setup.md
#, fuzzy
msgid ""
"This part of the course has a series of exercises which build on each other. "
"We'll be doing them spread throughout the course instead of just at the end. "
"If you don't have time to complete a certain part, don't worry: you can "
"catch up in the next slot."
msgstr ""
"Această parte a cursului cuprinde o serie de exerciții care se bazează unul "
"pe celălalt. Le vom face repartizate pe tot parcursul cursului și nu doar la "
"sfârșit. Dacă nu aveți timp să terminați o anumită parte, nu vă faceți "
"griji: puteți recupera în intervalul următor."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"The Rust community typically uses `cargo` and libraries from [crates.io]"
"(https://crates.io/). Chromium is built using `gn` and `ninja` and a curated "
"set of dependencies."
msgstr ""
"Comunitatea Rust folosește de obicei `cargo` și bibliotecile din [crates.io]"
"(https://crates.io/). Chromium este construit folosind `gn` și `ninja` și un "
"set curatorial de dependențe."

#: src/chromium/cargo.md
#, fuzzy
msgid "When writing code in Rust, your choices are:"
msgstr "Când scrieți cod în Rust, aveți de ales între:"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Use `gn` and `ninja` with the help of the templates from `//build/rust/*."
"gni` (e.g. `rust_static_library` that we'll meet later). This uses "
"Chromium's audited toolchain and crates."
msgstr ""
"Utilizați `gn` și `ninja` cu ajutorul șabloanelor din `//build/rust/*.gni` "
"(de exemplu `rust_static_library` pe care îl vom întâlni mai târziu). Acest "
"lucru utilizează toolchain-ul și crates auditate de Chromium."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Use `cargo`, but [restrict yourself to Chromium's audited toolchain and "
"crates](https://chromium.googlesource.com/chromium/src/+/refs/heads/main/"
"docs/rust.md#Using-cargo)"
msgstr ""
"Folosiți `cargo`, dar [limitați-vă la lanțul de instrumente și la crates "
"auditate de Chromium](https://chromium.googlesource.com/chromium/src/+/refs/"
"heads/main/docs/rust.md#Using-cargo)"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Use `cargo`, trusting a [toolchain](https://rustup.rs/) and/or [crates "
"downloaded from the internet](https://crates.io/)"
msgstr ""
"Folosiți `cargo`, având încredere într-un [toolchain](https://rustup.rs/) și/"
"sau [lăzi descărcate de pe internet](https://crates.io/)"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"From here on we'll be focusing on `gn` and `ninja`, because this is how Rust "
"code can be built into the Chromium browser. At the same time, Cargo is an "
"important part of the Rust ecosystem and you should keep it in your toolbox."
msgstr ""
"De aici încolo ne vom concentra pe `gn` și `ninja`, deoarece acesta este "
"modul în care codul Rust poate fi integrat în browserul Chromium. În același "
"timp, Cargo este o parte importantă a ecosistemului Rust și ar trebui să îl "
"păstrați în setul de instrumente."

#: src/chromium/cargo.md
#, fuzzy
msgid "Mini exercise"
msgstr "exercițiu:"

#: src/chromium/cargo.md
#, fuzzy
msgid "Split into small groups and:"
msgstr "Împărțiți-vă în grupuri mici și:"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Brainstorm scenarios where `cargo` may offer an advantage and assess the "
"risk profile of these scenarios."
msgstr ""
"Gândiți-vă la scenarii în care \"încărcătura\" poate oferi un avantaj și "
"evaluați profilul de risc al acestor scenarii."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Discuss which tools, libraries, and groups of people need to be trusted when "
"using `gn` and `ninja`, offline `cargo`, etc."
msgstr ""
"Discutați ce instrumente, biblioteci și grupuri de persoane trebuie să fie "
"de încredere atunci când se utilizează `gn` și `ninja`, `cargo` offline etc."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Ask students to avoid peeking at the speaker notes before completing the "
"exercise. Assuming folks taking the course are physically together, ask them "
"to discuss in small groups of 3-4 people."
msgstr ""
"Cereți elevilor să evite să tragă cu ochiul la notele vorbitorului înainte "
"de a finaliza exercițiul. Presupunând că cei care urmează cursul sunt fizic "
"împreună, rugați-i să discute în grupuri mici de 3-4 persoane."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Notes/hints related to the first part of the exercise (\"scenarios where "
"Cargo may offer an advantage\"):"
msgstr ""
"Note/sugestii legate de prima parte a exercițiului (\"scenarii în care Cargo "
"poate oferi un avantaj\"):"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"It's fantastic that when writing a tool, or prototyping a part of Chromium, "
"one has access to the rich ecosystem of crates.io libraries. There is a "
"crate for almost anything and they are usually quite pleasant to use. "
"(`clap` for command-line parsing, `serde` for serializing/deserializing to/"
"from various formats, `itertools` for working with iterators, etc.)."
msgstr ""
"Este fantastic faptul că atunci când se scrie un instrument sau se creează "
"prototipuri pentru o parte din Chromium, se are acces la ecosistemul bogat "
"de biblioteci crates.io. Există un crate pentru aproape orice și, de obicei, "
"acestea sunt destul de plăcute de utilizat. (`clap` pentru parsarea liniei "
"de comandă, `serde` pentru serializare/deserializare în/din diverse formate, "
"`itertools` pentru lucrul cu iteratori, etc.)."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"`cargo` makes it easy to try a library (just add a single line to `Cargo."
"toml` and start writing code)"
msgstr ""
"`cargo` face mai ușoară încercarea unei biblioteci (doar adăugați o singură "
"linie la `Cargo.toml` și începeți să scrieți cod)"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"It may be worth comparing how CPAN helped make `perl` a popular choice. Or "
"comparing with `python` + `pip`."
msgstr ""
"Poate că merită să comparăm modul în care CPAN a ajutat la transformarea lui "
"`perl` într-o alegere populară. Sau comparând cu `python` + `pip`."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Development experience is made really nice not only by core Rust tools (e.g. "
"using `rustup` to switch to a different `rustc` version when testing a crate "
"that needs to work on nightly, current stable, and older stable) but also by "
"an ecosystem of third-party tools (e.g. Mozilla provides `cargo vet` for "
"streamlining and sharing security audits; `criterion` crate gives a "
"streamlined way to run benchmarks)."
msgstr ""
"Experiența de dezvoltare este foarte plăcută nu numai prin instrumentele "
"Rust de bază (de exemplu, utilizarea `rustup` pentru a trece la o versiune "
"diferită de `rustc` atunci când se testează un crate care trebuie să "
"funcționeze pe nightly, current stable și old stable), ci și printr-un "
"ecosistem de instrumente terțe (de exemplu, Mozilla oferă `cargo vet` pentru "
"simplificarea și partajarea auditurilor de securitate; crate `criterion` "
"oferă o modalitate simplificată de a rula teste de referință)."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"`cargo` makes it easy to add a tool via `cargo install --locked cargo-vet`."
msgstr ""
"`cargo` facilitează adăugarea unui instrument prin `cargo install --locked "
"cargo-vet`."

#: src/chromium/cargo.md
#, fuzzy
msgid "It may be worth comparing with Chrome Extensions or VScode extensions."
msgstr ""
"Ar putea fi utilă o comparație cu extensiile Chrome Extensions sau VScode "
"Extensions."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Broad, generic examples of projects where `cargo` may be the right choice:"
msgstr ""
"Exemple generale, generice, de proiecte în care `cargo` poate fi alegerea "
"potrivită:"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Perhaps surprisingly, Rust is becoming increasingly popular in the industry "
"for writing command line tools. The breadth and ergonomics of libraries is "
"comparable to Python, while being more robust (thanks to the rich "
"typesystem) and running faster (as a compiled, rather than interpreted "
"language)."
msgstr ""
"Poate surprinzător, Rust devine din ce în ce mai popular în industrie pentru "
"scrierea instrumentelor de linie de comandă. Amploarea și ergonomia "
"bibliotecilor este comparabilă cu Python, fiind în același timp mai robust "
"(datorită sistemului de tipuri bogat) și funcționând mai rapid (fiind un "
"limbaj compilat, mai degrabă decât interpretat)."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Participating in the Rust ecosystem requires using standard Rust tools like "
"Cargo. Libraries that want to get external contributions, and want to be "
"used outside of Chromium (e.g. in Bazel or Android/Soong build environments) "
"should probably use Cargo."
msgstr ""
"Participarea la ecosistemul Rust necesită utilizarea instrumentelor standard "
"Rust, cum ar fi Cargo. Bibliotecile care doresc să primească contribuții "
"externe și care doresc să fie utilizate în afara Chromium (de exemplu, în "
"Bazel sau în mediile de compilare Android/Soong) ar trebui probabil să "
"utilizeze Cargo."

#: src/chromium/cargo.md
#, fuzzy
msgid "Examples of Chromium-related projects that are `cargo`\\-based:"
msgstr "Exemple de proiecte legate de Chromium care sunt bazate pe `cargo`:"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"`serde_json_lenient` (experimented with in other parts of Google which "
"resulted in PRs with performance improvements)"
msgstr ""
"`serde_json_lenient` (experimentat în alte părți ale Google, ceea ce a dus "
"la PR-uri cu îmbunătățiri de performanță)"

#: src/chromium/cargo.md
#, fuzzy
msgid "Fontations libraries like `font-types`"
msgstr "Biblioteci de fonturi precum `font-types`"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"`gnrt` tool (we will meet it later in the course) which depends on `clap` "
"for command-line parsing and on `toml` for configuration files."
msgstr ""
"instrumentul `gnrt` (îl vom întâlni mai târziu în curs) care depinde de "
"`clap` pentru analiza liniei de comandă și de `toml` pentru fișierele de "
"configurare."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Disclaimer: a unique reason for using `cargo` was unavailability of `gn` "
"when building and bootstrapping Rust standard library when building Rust "
"toolchain."
msgstr ""
"Avertisment: un motiv unic pentru a folosi `cargo` a fost indisponibilitatea "
"lui `gn` la construirea și bootstraparea bibliotecii standard Rust la "
"construirea lanțului de instrumente Rust)"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"`run_gnrt.py` uses Chromium's copy of `cargo` and `rustc`. `gnrt` depends on "
"third-party libraries downloaded from the internet, but `run_gnrt.py` asks "
"`cargo` that only `--locked` content is allowed via `Cargo.lock`.)"
msgstr ""
"`run_gnrt.py` folosește copia Chromium a `cargo` și `rustc`. `gnrt` depinde "
"de biblioteci terțe descărcate de pe internet, prin `run_gnrt.py` cere "
"`cargo` ca numai conținutul `--blocat` să fie permis prin `Cargo.lock`)"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Students may identify the following items as being implicitly or explicitly "
"trusted:"
msgstr ""
"Elevii pot identifica următoarele elemente ca fiind de încredere implicită "
"sau explicită:"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"`rustc` (the Rust compiler) which in turn depends on the LLVM libraries, the "
"Clang compiler, the `rustc` sources (fetched from GitHub, reviewed by Rust "
"compiler team), binary Rust compiler downloaded for bootstrapping"
msgstr ""
"`rustc` (compilatorul Rust), care la rândul său depinde de bibliotecile "
"LLVM, de compilatorul Clang, de sursele `rustc` (preluate de pe GitHub, "
"revizuite de echipa compilatorului Rust), de compilatorul binar Rust "
"descărcat pentru bootstrap"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"`rustup` (it may be worth pointing out that `rustup` is developed under the "
"umbrella of the https://github.com/rust-lang/ organization - same as `rustc`)"
msgstr ""
"`rustup` (poate că merită subliniat faptul că `rustup` este dezvoltat sub "
"umbrela organizației https://github.com/rust-lang/ - la fel ca `rustc`)"

#: src/chromium/cargo.md
#, fuzzy
msgid "`cargo`, `rustfmt`, etc."
msgstr "`cargo`, `rustfmt`, etc."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Various internal infrastructure (bots that build `rustc`, system for "
"distributing the prebuilt toolchain to Chromium engineers, etc.)"
msgstr ""
"Diferite infrastructuri interne (roboți care construiesc `rustc`, sistemul "
"de distribuire a lanțului de instrumente pre-construit către inginerii "
"Chromium, etc.)"

#: src/chromium/cargo.md
#, fuzzy
msgid "Cargo tools like `cargo audit`, `cargo vet`, etc."
msgstr "Instrumente pentru mărfuri, cum ar fi `cargo audit`, `cargo vet`, etc."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Rust libraries vendored into `//third_party/rust` (audited by "
"security@chromium.org)"
msgstr ""
"Biblioteci Rust vândute în `//third_party/rust` (auditate de "
"security@chromium.org)"

#: src/chromium/cargo.md
#, fuzzy
msgid "Other Rust libraries (some niche, some quite popular and commonly used)"
msgstr ""
"Alte biblioteci Rust (unele de nișă, altele destul de populare și utilizate "
"în mod obișnuit)"

#: src/chromium/policy.md
#, fuzzy
msgid "Chromium Rust policy"
msgstr "Politica privind rugina de crom"

#: src/chromium/policy.md
#, fuzzy
msgid ""
"Chromium does not yet allow first-party Rust except in rare cases as "
"approved by Chromium's [Area Tech Leads](https://source.chromium.org/"
"chromium/chromium/src/+/main:ATL_OWNERS)."
msgstr ""
"Chromium nu permite încă Rust de la prima parte, cu excepția unor cazuri "
"rare, aprobate de [Area Tech Leads] (https://source.chromium.org/chromium/"
"chromium/src/+/main:ATL_OWNERS)."

#: src/chromium/policy.md
#, fuzzy
msgid ""
"Chromium's policy on third party libraries is outlined [here](https://"
"chromium.googlesource.com/chromium/src/+/main/docs/adding_to_third_party."
"md#rust) - Rust is allowed for third party libraries under various "
"circumstances, including if they're the best option for performance or for "
"security."
msgstr ""
"Politica Chromium cu privire la bibliotecile terților este prezentată [aici] "
"(https://chromium.googlesource.com/chromium/src/+/main/docs/"
"adding_to_third_party.md#rust) - Rust este permis pentru bibliotecile "
"terților în diverse circumstanțe, inclusiv dacă acestea reprezintă cea mai "
"bună opțiune pentru performanță sau securitate."

#: src/chromium/policy.md
#, fuzzy
msgid ""
"Very few Rust libraries directly expose a C/C++ API, so that means that "
"nearly all such libraries will require a small amount of first-party glue "
"code."
msgstr ""
"Foarte puține biblioteci Rust expun direct un API C/C++, ceea ce înseamnă că "
"aproape toate aceste biblioteci vor necesita o cantitate mică de cod glue de "
"la prima parte."

#: src/chromium/policy.md
#, fuzzy
msgid ""
"```bob\n"
"\"C++\"                           Rust\n"
".- - - - - - - - - -.           .- - - - - - - - - - - - - - - - - - - - - - "
"-.\n"
":                   :           :                                             :\n"
": Existing Chromium :           :  Chromium Rust              Existing "
"Rust   :\n"
": \"C++\"             :           :  \"wrapper\"                  "
"crate           :\n"
": +---------------+ :           : +----------------+          +-------------"
"+ :\n"
": |               | :           : |                |          |             "
"| :\n"
": |         o-----+-+-----------+-+->            o-+----------+-->          "
"| :\n"
": |               | : Language  : |                | Crate    |             "
"| :\n"
": +---------------+ : boundary  : +----------------+ API      +-------------"
"+ :\n"
":                   :           :                                             :\n"
"`- - - - - - - - - -'           `- - - - - - - - - - - - - - - - - - - - - - "
"-'\n"
"```"
msgstr ""
"```bob\n"
" Stiva Heap\n"
".- - - - - - - - - - - - -. .- - - - - - - - - - - - - - - - - - - - - - -.\n"
": : : :\n"
": listă : : : :\n"
":   +----+----+ : : +----+----+ +----+------+ :\n"
":   | 1 | o--+-----------+-----+--->| 2 | o--++--->| // | null | :\n"
":   +----+----+ : : +----+----+ +----+------+ :\n"
": : : :\n"
": : : :\n"
"`- - - - - - - - - - - - -' '- - - - - - - - - - - - - - - - - - - - - - -'\n"
"```"

#: src/chromium/policy.md
#, fuzzy
msgid ""
"First-party Rust glue code for a particular third-party crate should "
"normally be kept in `third_party/rust/<crate>/<version>/wrapper`."
msgstr ""
"Codul de lipire Rust de prima parte pentru o anumită crăpătură terță parte "
"ar trebui să fie păstrat în mod normal în `third_party/rust/<crate>/"
"<version>/wrapper`."

#: src/chromium/policy.md
#, fuzzy
msgid "Because of this, today's course will be heavily focused on:"
msgstr "Din acest motiv, cursul de astăzi se va concentra pe:"

#: src/chromium/policy.md
#, fuzzy
msgid "Bringing in third-party Rust libraries (\"crates\")"
msgstr "Introducerea de biblioteci Rust de la terți (\"crates\")"

#: src/chromium/policy.md
#, fuzzy
msgid "Writing glue code to be able to use those crates from Chromium C++."
msgstr ""
"Scrierea codului de lipire pentru a putea utiliza aceste crates din Chromium "
"C++."

#: src/chromium/policy.md
#, fuzzy
msgid "If this policy changes over time, the course will evolve to keep up."
msgstr ""
"Dacă această politică se schimbă în timp, cursul va evolua pentru a ține "
"pasul cu ea."

#: src/chromium/build-rules.md
#, fuzzy
msgid "Build rules"
msgstr "Reguli de construcție"

#: src/chromium/build-rules.md
#, fuzzy
msgid ""
"Rust code is usually built using `cargo`. Chromium builds with `gn` and "
"`ninja` for efficiency --- its static rules allow maximum parallelism. Rust "
"is no exception."
msgstr ""
"Codul Rust este de obicei construit folosind `cargo`. Chromium se "
"construiește cu `gn` și `ninja` pentru eficiență --- regulile sale statice "
"permit un paralelism maxim. Rust nu face excepție."

#: src/chromium/build-rules.md
#, fuzzy
msgid "Adding Rust code to Chromium"
msgstr "Adăugarea de cod Rust în Chromium"

#: src/chromium/build-rules.md
#, fuzzy
msgid ""
"In some existing Chromium `BUILD.gn` file, declare a `rust_static_library`:"
msgstr ""
"În unele fișiere Chromium `BUILD.gn` existente, declarați o "
"`rust_static_library`:"

#: src/chromium/build-rules.md
#, fuzzy
msgid ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"}\n"
"```"
msgstr ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"}\n"
"```"

#: src/chromium/build-rules.md
#, fuzzy
msgid ""
"You can also add `deps` on other Rust targets. Later we'll use this to "
"depend upon third party code."
msgstr ""
"De asemenea, puteți adăuga `deps` pe alte obiective Rust. Mai târziu vom "
"folosi acest lucru pentru a depinde de codul terților."

#: src/chromium/build-rules.md
#, fuzzy
msgid ""
"You must specify _both_ the crate root, _and_ a full list of sources. The "
"`crate_root` is the file given to the Rust compiler representing the root "
"file of the compilation unit --- typically `lib.rs`. `sources` is a complete "
"list of all source files which `ninja` needs in order to determine when "
"rebuilds are necessary."
msgstr ""
"Trebuie să specificați atât rădăcina lăzii, cât și o listă completă de "
"surse. `crate_root` este fișierul dat compilatorului Rust care reprezintă "
"fișierul rădăcină al unității de compilare --- de obicei `lib.rs`. `sources` "
"este o listă completă a tuturor fișierelor sursă de care `ninja` are nevoie "
"pentru a determina când sunt necesare reconstrucțiile."

#: src/chromium/build-rules.md
#, fuzzy
msgid ""
"(There's no such thing as a Rust `source_set`, because in Rust, an entire "
"crate is a compilation unit. A `static_library` is the smallest unit.)"
msgstr ""
"(Nu există un astfel de lucru ca un `source_set` Rust, deoarece în Rust, un "
"întreg crate este o unitate de compilare. O `static_library` este cea mai "
"mică unitate)"

#: src/chromium/build-rules.md
#, fuzzy
msgid ""
"Students might be wondering why we need a gn template, rather than using "
"[gn's built-in support for Rust static libraries](https://gn.googlesource."
"com/gn/+/main/docs/reference.md#func_static_library). The answer is that "
"this template provides support for CXX interop, Rust features, and unit "
"tests, some of which we'll use later."
msgstr ""
"Studenții s-ar putea să se întrebe de ce avem nevoie de un șablon gn, în loc "
"să folosim [suportul încorporat al gn pentru bibliotecile statice Rust] "
"(https://gn.googlesource.com/gn/+/main/docs/reference."
"md#func_static_library). Răspunsul este că acest șablon oferă suport pentru "
"interopulare CXX, caracteristici Rust și teste unitare, unele dintre acestea "
"urmând să le folosim mai târziu."

#: src/chromium/build-rules/unsafe.md
#, fuzzy
msgid "Including `unsafe` Rust Code"
msgstr "Includerea codului Rust `unsafe` Rust"

#: src/chromium/build-rules/unsafe.md
#, fuzzy
msgid ""
"Unsafe Rust code is forbidden in `rust_static_library` by default --- it "
"won't compile. If you need unsafe Rust code, add `allow_unsafe = true` to "
"the gn target. (Later in the course we'll see circumstances where this is "
"necessary.)"
msgstr ""
"Codul Rust nesigur este interzis în `rust_static_library` în mod implicit "
"--- nu va fi compilat. Dacă aveți nevoie de cod Rust nesigur, adăugați "
"`allow_unsafe = true` la ținta gn. (Mai târziu în curs vom vedea "
"circumstanțe în care acest lucru este necesar)"

#: src/chromium/build-rules/unsafe.md
#, fuzzy
msgid ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [\n"
"    \"lib.rs\",\n"
"    \"hippopotamus.rs\"\n"
"  ]\n"
"  allow_unsafe = true\n"
"}\n"
"```"
msgstr ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [\n"
"    \"lib.rs\",\n"
"    \"hippopotamus.rs\"\n"
"  ]\n"
"  allow_unsafe = true\n"
"}\n"
"```"

#: src/chromium/build-rules/depending.md
#, fuzzy
msgid "Simply add the above target to the `deps` of some Chromium C++ target."
msgstr ""
"Pur și simplu adăugați ținta de mai sus la `deps` a unei ținte Chromium C++."

#: src/chromium/build-rules/depending.md
#, fuzzy
msgid ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"}\n"
"\n"
"# or source_set, static_library etc.\n"
"component(\"preexisting_cpp\") {\n"
"  deps = [ \":my_rust_lib\" ]\n"
"}\n"
"```"
msgstr ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"}\n"
"\n"
"# sau source_set, static_library etc.\n"
"component(\"preexisting_cpp\") {\n"
"  deps = [ \":my_rust_lib\" ]\n"
"}\n"
"```"

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid ""
"Types are elided in Rust code, which makes a good IDE even more useful than "
"for C++. Visual Studio code works well for Rust in Chromium. To use it,"
msgstr ""
"Tipurile sunt elidate în codul Rust, ceea ce face ca un IDE bun să fie și "
"mai util decât în cazul C++. Codul Visual Studio funcționează bine pentru "
"Rust în Chromium. Pentru a-l utiliza,"

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid ""
"Ensure your VSCode has the `rust-analyzer` extension, not earlier forms of "
"Rust support"
msgstr ""
"Asigurați-vă că VSCode-ul dumneavoastră are extensia `rust-analyzer`, nu "
"formele anterioare de suport Rust"

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid ""
"`gn gen out/Debug --export-rust-project` (or equivalent for your output "
"directory)"
msgstr ""
"`gn gen out/Debug --export-rust-project` (sau echivalent pentru directorul "
"de ieșire)"

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid "`ln -s out/Debug/rust-project.json rust-project.json`"
msgstr "`ln -s out/Debug/rust-project.json rust-project.json`"

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid ""
"A demo of some of the code annotation and exploration features of rust-"
"analyzer might be beneficial if the audience are naturally skeptical of IDEs."
msgstr ""
"O demonstrație a unora dintre caracteristicile de adnotare și explorare a "
"codului din rust-analyzer ar putea fi benefică dacă audiența este sceptică "
"în mod natural față de IDE-uri."

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid ""
"The following steps may help with the demo (but feel free to instead use a "
"piece of Chromium-related Rust that you are most familiar with):"
msgstr ""
"Următorii pași vă pot ajuta cu demonstrația (dar nu ezitați să folosiți în "
"schimb o bucată de Rust legată de Chromium cu care sunteți cel mai "
"familiarizat):"

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid "Open `components/qr_code_generator/qr_code_generator_ffi_glue.rs`"
msgstr ""
"Deschideți `components/qr_code_generator/qr_code_generator_ffi_glue.rs`"

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid ""
"Place the cursor over the `QrCode::new` call (around line 26) in "
"\\`qr_code_generator_ffi_glue.rs"
msgstr ""
"Așezați cursorul pe apelul `QrCode::new` (în jurul liniei 26) în "
"\\`qr_code_generator_ffi_glue.rs"

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid ""
"Demo **show documentation** (typical bindings: vscode = ctrl k i; vim/CoC = "
"K)."
msgstr ""
"Demo **afișează documentația** (legături tipice: vscode = ctrl k i; vim/CoC "
"= K)."

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid ""
"Demo **go to definition** (typical bindings: vscode = F12; vim/CoC = g d). "
"(This will take you to `//third_party/rust/.../qr_code-.../src/lib.rs`.)"
msgstr ""
"Demonstrație **deplasați-vă la definiție** (legături tipice: vscode = F12; "
"vim/CoC = g d). (Acest lucru vă va duce la `//third_party/rust/.../"
"qr_code-.../src/lib.rs`)"

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid ""
"Demo **outline** and navigate to the `QrCode::with_bits` method (around line "
"164; the outline is in the file explorer pane in vscode; typical vim/CoC "
"bindings = space o)"
msgstr ""
"Demo **outline** și navigați până la metoda `QrCode::with_bits` (în jurul "
"liniei 164; conturul este în panoul de explorare a fișierelor din vscode; "
"legături tipice vim/CoC = space o)"

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid ""
"Demo **type annotations** (there are quote a few nice examples in the "
"`QrCode::with_bits` method)"
msgstr ""
"Demonstrație **Anotații de tip** (există câteva exemple frumoase în metoda "
"`QrCode::with_bits`)"

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid ""
"It may be worth pointing out that `gn gen ... --export-rust-project` will "
"need to be rerun after editing `BUILD.gn` files (which we will do a few "
"times throughout the exercises in this session)."
msgstr ""
"Ar putea fi util să subliniem că `gn gen ... --export-rust-project` va "
"trebui să fie rulat din nou după editarea fișierelor `BUILD.gn` (ceea ce vom "
"face de câteva ori în timpul exercițiilor din această sesiune)."

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid "Build rules exercise"
msgstr "Reguli de construcție"

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"In your Chromium build, add a new Rust target to `//ui/base/BUILD.gn` "
"containing:"
msgstr ""
"În construcția Chromium, adăugați o nouă țintă Rust la `//ui/base/BUILD.gn` "
"care să conțină:"

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"**Important**: note that `no_mangle` here is considered a type of unsafety "
"by the Rust compiler, so you'll need to allow unsafe code in your `gn` "
"target."
msgstr ""
"**Important**: rețineți că `no_mangle` aici este considerat un tip de "
"nesiguranță de către compilatorul Rust, deci va trebui să permiteți cod "
"nesigur în ținta `gn`."

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"Add this new Rust target as a dependency of `//ui/base:base`. Declare this "
"function at the top of `ui/base/resource/resource_bundle.cc` (later, we'll "
"see how this can be automated by bindings generation tools):"
msgstr ""
"Adăugați această nouă țintă Rust ca dependență a `//ui/base:base`. Declarați "
"această funcție în partea de sus a `ui/base/resource/resource_bundle.cc` "
"(mai târziu, vom vedea cum poate fi automatizat acest lucru de către "
"instrumentele de generare a legăturilor):"

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"Call this function from somewhere in `ui/base/resource/resource_bundle.cc` - "
"we suggest the top of `ResourceBundle::MaybeMangleLocalizedString`. Build "
"and run Chromium, and ensure that \"Hello from Rust!\" is printed lots of "
"times."
msgstr ""
"Apelați această funcție de undeva din `ui/base/resource/resource_bundle.cc` "
"- sugerăm partea de sus a `ResourceBundle::MaybeMangleLocalizedString`. "
"Construiți și rulați Chromium și asigurați-vă că \"Hello from Rust!\" este "
"tipărit de multe ori."

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"If you use VSCode, now set up Rust to work well in VSCode. It will be useful "
"in subsequent exercises. If you've succeeded, you will be able to use right-"
"click \"Go to definition\" on `println!`."
msgstr ""
"Dacă utilizați VSCode, configurați Rust pentru a funcționa bine în VSCode. "
"Aceasta va fi utilă în exercițiile următoare. Dacă ați reușit, veți putea "
"folosi click dreapta \"Go to definition\" pe `println!`."

#: src/exercises/chromium/build-rules.md
#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Where to find help"
msgstr "Unde găsiți ajutor"

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"The options available to the [`rust_static_library` gn template](https://"
"source.chromium.org/chromium/chromium/src/+/main:build/rust/"
"rust_static_library.gni;l=16)"
msgstr ""
"Opțiunile disponibile pentru șablonul [`rust_static_library` gn](https://"
"source.chromium.org/chromium/chromium/src/+/main:build/rust/"
"rust_static_library.gni;l=16)"

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"Information about [`#[no_mangle]`](https://doc.rust-lang.org/beta/reference/"
"abi.html#the-no_mangle-attribute)"
msgstr ""
"Informații despre [`#[no_mangle]`](https://doc.rust-lang.org/beta/reference/"
"abi.html#the-no_mangle-attribute)"

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"Information about [`extern \"C\"`](https://doc.rust-lang.org/std/keyword."
"extern.html)"
msgstr ""
"Informații despre [`extern \"C\"`](https://doc.rust-lang.org/std/keyword."
"extern.html)"

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"Information about gn's [`--export-rust-project`](https://gn.googlesource.com/"
"gn/+/main/docs/reference.md#compilation-database) switch"
msgstr ""
"Informații despre comutatorul [`--export-rust-project`](https://gn."
"googlesource.com/gn/+/main/docs/reference.md#compilation-database) de la "
"gn's [`--export-rust-project`](https://gn.googlesource.com/gn/+/main/docs/"
"reference.md#compilation-database)"

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"[How to install rust-analyzer in VSCode](https://code.visualstudio.com/docs/"
"languages/rust)"
msgstr ""
"[Cum se instalează rust-analyzer în VSCode](https://code.visualstudio.com/"
"docs/languages/rust)"

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"This example is unusual because it boils down to the lowest-common-"
"denominator interop language, C. Both C++ and Rust can natively declare and "
"call C ABI functions. Later in the course, we'll connect C++ directly to "
"Rust."
msgstr ""
"Acest exemplu este neobișnuit, deoarece se reduce la cel mai mic limbaj de "
"interoperabilitate, C. Atât C++, cât și Rust pot declara și apela în mod "
"nativ funcții ABI C. Mai târziu, în cadrul cursului, vom conecta C++ direct "
"la Rust."

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"`allow_unsafe = true` is required here because `#[no_mangle]` might allow "
"Rust to generate two functions with the same name, and Rust can no longer "
"guarantee that the right one is called."
msgstr ""
"`allow_unsafe = true` este necesar aici deoarece `#[no_mangle]` ar putea "
"permite ca Rust să genereze două funcții cu același nume, iar Rust nu mai "
"poate garanta că este apelată cea corectă."

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"If you need a pure Rust executable, you can also do that using the "
"`rust_executable` gn template."
msgstr ""
"Dacă aveți nevoie de un executabil Rust pur, puteți face acest lucru "
"folosind șablonul gn `rust_executable`."

#: src/chromium/testing.md
#, fuzzy
msgid ""
"Rust community typically authors unit tests in a module placed in the same "
"source file as the code being tested. This was covered [earlier](../testing."
"md) in the course and looks like this:"
msgstr ""
"Comunitatea Rust autorizează de obicei testele unitare într-un modul plasat "
"în același fișier sursă ca și codul testat. Acest lucru a fost abordat [mai "
"devreme](../testing.md) în cadrul cursului și arată astfel:"

#: src/chromium/testing.md
#, fuzzy
msgid ""
"In Chromium we place unit tests in a separate source file and we continue to "
"follow this practice for Rust --- this makes tests consistently discoverable "
"and helps to avoid rebuilding `.rs` files a second time (in the `test` "
"configuration)."
msgstr ""
"În Chromium plasăm testele unitare într-un fișier sursă separat și continuăm "
"să urmăm această practică pentru Rust --- acest lucru face ca testele să "
"poată fi descoperite în mod constant și ajută la evitarea reconstruirii "
"fișierelor `.rs` a doua oară (în configurația `test`)."

#: src/chromium/testing.md
#, fuzzy
msgid ""
"This results in the following options for testing Rust code in Chromium:"
msgstr ""
"Acest lucru are ca rezultat următoarele opțiuni pentru testarea codului Rust "
"în Chromium:"

#: src/chromium/testing.md
#, fuzzy
msgid ""
"Native Rust tests (i.e. `#[test]`). Discouraged outside of `//third_party/"
"rust`."
msgstr ""
"Teste Rust native (adică `#[test]`). Descurajat în afara `//third_party/"
"rust`."

#: src/chromium/testing.md
#, fuzzy
msgid ""
"`gtest` tests authored in C++ and exercising Rust via FFI calls. Sufficient "
"when Rust code is just a thin FFI layer and the existing unit tests provide "
"sufficient coverage for the feature."
msgstr ""
"teste `gtest` scrise în C++ și care utilizează Rust prin apeluri FFI. "
"Suficient atunci când codul Rust este doar un strat FFI subțire și testele "
"unitare existente oferă o acoperire suficientă pentru această caracteristică."

#: src/chromium/testing.md
#, fuzzy
msgid ""
"`gtest` tests authored in Rust and using the crate under test through its "
"public API (using `pub mod for_testing { ... }` if needed). This is the "
"subject of the next few slides."
msgstr ""
"`gtest` testele sunt scrise în Rust și utilizează crate-ul testat prin "
"intermediul API-ului său public (folosind `pub mod for_testing { ... }` dacă "
"este necesar). Acesta este subiectul următoarelor slide-uri."

#: src/chromium/testing.md
#, fuzzy
msgid ""
"Mention that native Rust tests of third-party crates should eventually be "
"exercised by Chromium bots. (Such testing is needed rarely --- only after "
"adding or updating third-party crates.)"
msgstr ""
"Menționați că testele Rust native ale craterelor terțe ar trebui să fie în "
"cele din urmă exercitate de roboții Chromium. (Astfel de testări sunt "
"necesare rareori --- doar după adăugarea sau actualizarea unor crates de la "
"terți)"

#: src/chromium/testing.md
#, fuzzy
msgid ""
"Some examples may help illustrate when C++ `gtest` vs Rust `gtest` should be "
"used:"
msgstr ""
"Câteva exemple pot ajuta la ilustrarea momentului în care ar trebui să se "
"utilizeze `gtest` din C++ vs `gtest` din Rust:"

#: src/chromium/testing.md
#, fuzzy
msgid ""
"QR has very little functionality in the first-party Rust layer (it's just a "
"thin FFI glue) and therefore uses the existing C++ unit tests for testing "
"both the C++ and the Rust implementation (parameterizing the tests so they "
"enable or disable Rust using a `ScopedFeatureList`)."
msgstr ""
"QR are foarte puțină funcționalitate în stratul Rust de primă instanță (este "
"doar un strat subțire de lipire FFI) și, prin urmare, utilizează testele "
"unitare C++ existente pentru testarea atât a implementării C++, cât și a "
"implementării Rust (parametrizând testele astfel încât să activeze sau să "
"dezactiveze Rust utilizând o `ScopedFeatureList`)."

#: src/chromium/testing.md
#, fuzzy
msgid ""
"Hypothetical/WIP PNG integration may need to implement memory-safe "
"implementation of pixel transformations that are provided by `libpng` but "
"missing in the `png` crate - e.g. RGBA => BGRA, or gamma correction. Such "
"functionality may benefit from separate tests authored in Rust."
msgstr ""
"Integrarea PNG ipotetică/WIP ar putea avea nevoie să implementeze o "
"implementare sigură în memorie a transformărilor de pixeli care sunt "
"furnizate de `libpng`, dar care lipsesc din `png` crate - de exemplu RGBA => "
"BGRA, sau corecția gamma. O astfel de funcționalitate ar putea beneficia de "
"teste separate realizate în Rust."

#: src/chromium/testing/rust-gtest-interop.md
#, fuzzy
msgid ""
"The [`rust_gtest_interop`](https://chromium.googlesource.com/chromium/src/+/"
"main/testing/rust_gtest_interop/README.md) library provides a way to:"
msgstr ""
"Biblioteca [`rust_gtest_interop`](https://chromium.googlesource.com/chromium/"
"src/+/main/testing/rust_gtest_interop/README.md) oferă o modalitate de a:"

#: src/chromium/testing/rust-gtest-interop.md
#, fuzzy
msgid ""
"Use a Rust function as a `gtest` testcase (using the `#[gtest(...)]` "
"attribute)"
msgstr ""
"Utilizați o funcție Rust ca și testcase `gtest` (folosind atributul "
"`#[gtest(...)]`)"

#: src/chromium/testing/rust-gtest-interop.md
#, fuzzy
msgid ""
"Use `expect_eq!` and similar macros (similar to `assert_eq!` but not "
"panicking and not terminating the test when the assertion fails)."
msgstr ""
"Utilizați `expect_eq!` și macrocomenzi similare (similar cu `assert_eq!`, "
"dar fără a intra în panică și fără a încheia testul atunci când afirmația "
"eșuează)."

#: src/chromium/testing/rust-gtest-interop.md
msgid "Example:"
msgstr "Exemplu:"

#: src/chromium/testing/build-gn.md
#, fuzzy
msgid ""
"The simplest way to build Rust `gtest` tests is to add them to an existing "
"test binary that already contains tests authored in C++. For example:"
msgstr ""
"Cel mai simplu mod de a construi teste Rust `gtest` este de a le adăuga la "
"un binar de testare existent care conține deja teste scrise în C++. De "
"exemplu:"

#: src/chromium/testing/build-gn.md
#, fuzzy
msgid ""
"```gn\n"
"test(\"ui_base_unittests\") {\n"
"  ...\n"
"  sources += [ \"my_rust_lib_unittest.rs\" ]\n"
"  deps += [ \":my_rust_lib\" ]\n"
"}\n"
"```"
msgstr ""
"```gn\n"
"test(\"ui_base_unittests\") {\n"
"  ...\n"
"  sources += [ \"my_rust_lib_unittest.rs\" ]\n"
"  deps += [ \":my_rust_lib\" ]\n"
"}\n"
"```"

#: src/chromium/testing/build-gn.md
#, fuzzy
msgid ""
"Authoring Rust tests in a separate `static_library` also works, but requires "
"manually declaring the dependency on the support libraries:"
msgstr ""
"Autorizarea testelor Rust într-o `static_library` separată funcționează, de "
"asemenea, dar necesită declararea manuală a dependenței de bibliotecile de "
"suport:"

#: src/chromium/testing/build-gn.md
#, fuzzy
msgid ""
"```gn\n"
"rust_static_library(\"my_rust_lib_unittests\") {\n"
"  testonly = true\n"
"  is_gtest_unittests = true\n"
"  crate_root = \"my_rust_lib_unittest.rs\"\n"
"  sources = [ \"my_rust_lib_unittest.rs\" ]\n"
"  deps = [\n"
"    \":my_rust_lib\",\n"
"    \"//testing/rust_gtest_interop\",\n"
"  ]\n"
"}\n"
"\n"
"test(\"ui_base_unittests\") {\n"
"  ...\n"
"  deps += [ \":my_rust_lib_unittests\" ]\n"
"}\n"
"```"
msgstr ""
"```gn\n"
"rust_static_library(\"my_rust_lib_unittests\") {\n"
"  testonly = true\n"
"  is_gtest_unittests = true\n"
"  crate_root = \"my_rust_lib_unittest.rs\"\n"
"  sources = [ \"my_rust_lib_unittest.rs\" ]\n"
"  deps = [\n"
"    \":my_rust_lib\",\n"
"    \"//testing/rust_gtest_interop\",\n"
"  ]\n"
"}\n"
"\n"
"test(\"ui_base_unittests\") {\n"
"  ...\n"
"  deps += [ \":my_rust_lib_unittests\" ]\n"
"}\n"
"```"

#: src/chromium/testing/chromium-import-macro.md
#, fuzzy
msgid ""
"After adding `:my_rust_lib` to GN `deps`, we still need to learn how to "
"import and use `my_rust_lib` from `my_rust_lib_unittest.rs`. We haven't "
"provided an explicit `crate_name` for `my_rust_lib` so its crate name is "
"computed based on the full target path and name. Fortunately we can avoid "
"working with such an unwieldy name by using the `chromium::import!` macro "
"from the automatically-imported `chromium` crate:"
msgstr ""
"După ce am adăugat `:my_rust_lib` la GN `deps`, mai trebuie să învățăm cum "
"să importăm și să folosim `my_rust_lib` din `my_rust_lib_unittest.rs`. Nu am "
"furnizat un `crate_name` explicit pentru `my_rust_lib`, astfel încât numele "
"său de crate este calculat pe baza căii și a numelui complet al țintei. Din "
"fericire, putem evita să lucrăm cu un astfel de nume greoi folosind macroul "
"`chromium::import!` din crate-ul `chromium` importat automat:"

#: src/chromium/testing/chromium-import-macro.md
#, fuzzy
msgid "\"//ui/base:my_rust_lib\""
msgstr "\"//ui/base:my_rust_lib\""

#: src/chromium/testing/chromium-import-macro.md
#, fuzzy
msgid "Under the covers the macro expands to something similar to:"
msgstr "Sub acoperire, macroul se extinde la ceva similar cu:"

#: src/chromium/testing/chromium-import-macro.md
#, fuzzy
msgid ""
"More information can be found in [the doc comment](https://source.chromium."
"org/chromium/chromium/src/+/main:build/rust/chromium_prelude/"
"chromium_prelude.rs?q=f:chromium_prelude.rs%20pub.use.*%5Cbimport%5Cb;%20-f:"
"third_party&ss=chromium%2Fchromium%2Fsrc) of the `chromium::import` macro."
msgstr ""
"Mai multe informații pot fi găsite în [comentariul doc](https://source."
"chromium.org/chromium/chromium/src/+/main:build/rust/chromium_prelude/"
"chromium_prelude.rs?q=f:chromium_prelude.rs%20pub.use.*%5Cbimport%5Cb;%20-f:"
"third_party&ss=chromium%2Fchromium%2Fsrc) al macroului `chromium::import`."

#: src/chromium/testing/chromium-import-macro.md
#, fuzzy
msgid ""
"`rust_static_library` supports specifying an explicit name via `crate_name` "
"property, but doing this is discouraged. And it is discouraged because the "
"crate name has to be globally unique. crates.io guarantees uniqueness of its "
"crate names so `cargo_crate` GN targets (generated by the `gnrt` tool "
"covered in a later section) use short crate names."
msgstr ""
"`rust_static_library` acceptă specificarea unui nume explicit prin "
"intermediul proprietății `crate_name`, dar acest lucru este descurajat. Și "
"este descurajată deoarece numele de ladă trebuie să fie unic la nivel "
"global. crates.io garantează unicitatea numelor de ladă, astfel încât "
"țintele GN `cargo_crate` (generate de instrumentul `gnrt`, abordat într-o "
"secțiune ulterioară) utilizează nume de ladă scurte."

#: src/exercises/chromium/testing.md
#, fuzzy
msgid "Testing exercise"
msgstr "exercițiu:"

#: src/exercises/chromium/testing.md
#, fuzzy
msgid "Time for another exercise!"
msgstr "E timpul pentru un alt exercițiu!"

#: src/exercises/chromium/testing.md
#, fuzzy
msgid "In your Chromium build:"
msgstr "În construcția Chromium:"

#: src/exercises/chromium/testing.md
#, fuzzy
msgid ""
"Add a testable function next to `hello_from_rust`. Some suggestions: adding "
"two integers received as arguments, computing the nth Fibonacci number, "
"summing integers in a slice, etc."
msgstr ""
"Adăugați o funcție testabilă lângă `hello_from_rust`. Câteva sugestii: "
"adunarea a două numere întregi primite ca argumente, calcularea celui de-al "
"n-lea număr Fibonacci, însumarea numerelor întregi dintr-o felie etc."

#: src/exercises/chromium/testing.md
#, fuzzy
msgid "Add a separate `..._unittest.rs` file with a test for the new function."
msgstr ""
"Adăugați un fișier separat `..._unittest.rs` cu un test pentru noua funcție."

#: src/exercises/chromium/testing.md
#, fuzzy
msgid "Add the new tests to `BUILD.gn`."
msgstr "Adăugați noile teste la `BUILD.gn`."

#: src/exercises/chromium/testing.md
#, fuzzy
msgid "Build the tests, run them, and verify that the new test works."
msgstr ""
"Construiți testele, rulați-le și verificați dacă noul test funcționează."

#: src/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"The Rust community offers multiple options for C++/Rust interop, with new "
"tools being developed all the time. At the moment, Chromium uses a tool "
"called CXX."
msgstr ""
"Comunitatea Rust oferă mai multe opțiuni pentru interopulare C++/Rust, noi "
"instrumente fiind dezvoltate în permanență. În prezent, Chromium utilizează "
"un instrument numit CXX."

#: src/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"You describe your whole language boundary in an interface definition "
"language (which looks a lot like Rust) and then CXX tools generate "
"declarations for functions and types in both Rust and C++."
msgstr ""
"Descrieți întreaga graniță a limbajului într-un limbaj de definire a "
"interfețelor (care seamănă foarte mult cu Rust) și apoi instrumentele CXX "
"generează declarații pentru funcții și tipuri atât în Rust, cât și în C++."

#: src/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"See the [CXX tutorial](https://cxx.rs/tutorial.html) for a full example of "
"using this."
msgstr ""
"Consultați [CXX tutorial](https://cxx.rs/tutorial.html) pentru un exemplu "
"complet de utilizare."

#: src/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"Talk through the diagram. Explain that behind the scenes, this is doing just "
"the same as you previously did. Point out that automating the process has "
"the following benefits:"
msgstr ""
"Vorbiți despre diagramă. Explicați că, în spatele scenei, aceasta face exact "
"ceea ce ați făcut anterior. Precizați că automatizarea procesului are "
"următoarele avantaje:"

#: src/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"The tool guarantees that the C++ and Rust sides match (e.g. you get compile "
"errors if the `#[cxx::bridge]` doesn't match the actual C++ or Rust "
"definitions, but with out-of-sync manual bindings you'd get Undefined "
"Behavior)"
msgstr ""
"Instrumentul garantează că părțile C++ și Rust se potrivesc (de exemplu, "
"veți obține erori de compilare dacă `#[cxx::bridge]` nu se potrivește cu "
"definițiile reale C++ sau Rust, dar cu legături manuale nesincronizate veți "
"obține Comportament nedefinit)"

#: src/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"The tool automates generation of FFI thunks (small, C-ABI-compatible, free "
"functions) for non-C features (e.g. enabling FFI calls into Rust or C++ "
"methods; manual bindings would require authoring such top-level, free "
"functions manually)"
msgstr ""
"Instrumentul automatizează generarea de thunks FFI (funcții libere mici, "
"compatibile cu C-ABI) pentru caracteristicile non-C (de exemplu, activarea "
"apelurilor FFI în metodele Rust sau C++; legăturile manuale ar necesita "
"crearea manuală a unor astfel de funcții libere de nivel superior)"

#: src/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "The tool and the library can handle a set of core types - for example:"
msgstr ""
"Instrumentul și biblioteca pot gestiona un set de tipuri de bază - de "
"exemplu:"

#: src/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"`&[T]` can be passed across the FFI boundary, even though it doesn't "
"guarantee any particular ABI or memory layout. With manual bindings `std::"
"span<T>` / `&[T]` have to be manually destructured and rebuilt out of a "
"pointer and length - this is error-prone given that each language represents "
"empty slices slightly differently)"
msgstr ""
"`&amp;[T]` poate fi trecut peste granița FFI, chiar dacă nu garantează o "
"anumită ABI sau o anumită dispunere a memoriei. În cazul legăturilor "
"manuale, `std::span<T>` / `&amp;[T]` trebuie să fie destructurate și "
"reconstruite manual dintr-un pointer și o lungime - acest lucru este "
"predispus la erori, având în vedere că fiecare limbaj reprezintă feliile "
"goale în mod ușor diferit)"

#: src/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"Smart pointers like `std::unique_ptr<T>`, `std::shared_ptr<T>`, and/or `Box` "
"are natively supported. With manual bindings, one would have to pass C-ABI-"
"compatible raw pointers, which would increase lifetime and memory-safety "
"risks."
msgstr ""
"Indicatorii inteligenți, cum ar fi `std::unique_ptr<T>`, `std::"
"shared_ptr<T>` și/sau `Box`, sunt suportați nativ. În cazul legăturilor "
"manuale, ar trebui să se treacă pointeri brute compatibile cu C-ABI, ceea ce "
"ar crește riscurile legate de durata de viață și siguranța memoriei."

#: src/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"`rust::String` and `CxxString` types understand and maintain differences in "
"string representation across the languages (e.g. `rust::String::lossy` can "
"build a Rust string from non-UTF8 input and `rust::String::c_str` can NUL-"
"terminate a string)."
msgstr ""
"tipurile `rust::String` și `CxxString` înțeleg și mențin diferențele de "
"reprezentare a șirurilor de caractere între limbaje (de exemplu, `rust::"
"String::lossy` poate construi un șir Rust de la o intrare non-UTF8 și `rust::"
"String::c_str` poate termina un șir cu NUL)."

#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid ""
"CXX requires that the whole C++/Rust boundary is declared in `cxx::bridge` "
"modules inside `.rs` source code."
msgstr ""
"CXX cere ca întreaga graniță C++/Rust să fie declarată în modulele `cxx::"
"bridge` din codul sursă `.rs`."

#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid "\"example/include/blobstore.h\""
msgstr "\"example/include/blobstore.h\""

#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid "// Definitions of Rust types and functions go here\n"
msgstr "// Definițiile tipurilor și funcțiilor Rust merg aici\n"

#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid "Point out:"
msgstr ""
"Ați putea indica modul în care sunt folosite anumite caractere specifice "
"atunci când se află într-un șablon"

#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid ""
"Although this looks like a regular Rust `mod`, the `#[cxx::bridge]` "
"procedural macro does complex things to it. The generated code is quite a "
"bit more sophisticated - though this does still result in a `mod` called "
"`ffi` in your code."
msgstr ""
"Deși acesta arată ca un `mod` obișnuit din Rust, macroul procedural `#[cxx::"
"bridge]` îi face lucruri complexe. Codul generat este mult mai sofisticat - "
"deși acest lucru are ca rezultat un `mod` numit `ffi` în codul dumneavoastră."

#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid "Native support for C++'s `std::unique_ptr` in Rust"
msgstr "Suport nativ pentru `std::unique_ptr` din C++ în Rust"

#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid "Native support for Rust slices in C++"
msgstr "Suport pentru testare încorporat."

#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid "Calls from C++ to Rust, and Rust types (in the top part)"
msgstr "Apeluri din C++ în Rust și tipuri Rust (în partea de sus)"

#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid "Calls from Rust to C++, and C++ types (in the bottom part)"
msgstr "Apeluri din Rust în C++ și tipuri C++ (în partea de jos)"

#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid ""
"**Common misconception**: It _looks_ like a C++ header is being parsed by "
"Rust, but this is misleading. This header is never interpreted by Rust, but "
"simply `#include`d in the generated C++ code for the benefit of C++ "
"compilers."
msgstr ""
"**Inconștiență greșită frecventă**: Se pare că un antet C++ este analizat de "
"Rust, dar acest lucru este înșelător. Acest antet nu este niciodată "
"interpretat de Rust, ci este pur și simplu `#inclus` în codul C++ generat în "
"beneficiul compilatoarelor C++."

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
#, fuzzy
msgid ""
"By far the most useful page when using CXX is the [type reference](https://"
"cxx.rs/bindings.html)."
msgstr ""
"Arătați corespondența dintre [tipurile Rust și C++](https://cxx.rs/bindings."
"html):"

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
#, fuzzy
msgid "CXX fundamentally suits cases where:"
msgstr "CXX se potrivește în mod fundamental cazurilor în care:"

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
#, fuzzy
msgid ""
"Your Rust-C++ interface is sufficiently simple that you can declare all of "
"it."
msgstr ""
"Interfața Rust-C++ este suficient de simplă pentru a o putea declara în "
"întregime."

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
#, fuzzy
msgid ""
"You're using only the types natively supported by CXX already, for example "
"`std::unique_ptr`, `std::string`, `&[u8]` etc."
msgstr ""
"Folosiți doar tipurile suportate nativ de CXX, de exemplu `std::unique_ptr`, "
"`std::string`, `&[u8]` etc."

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
#, fuzzy
msgid ""
"It has many limitations --- for example lack of support for Rust's `Option` "
"type."
msgstr ""
"Are multe limitări --- de exemplu, lipsa de suport pentru tipul `Option` din "
"Rust."

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
#, fuzzy
msgid ""
"These limitations constrain us to using Rust in Chromium only for well "
"isolated \"leaf nodes\" rather than for arbitrary Rust-C++ interop. When "
"considering a use-case for Rust in Chromium, a good starting point is to "
"draft the CXX bindings for the language boundary to see if it appears simple "
"enough."
msgstr ""
"Aceste limitări ne constrâng să folosim Rust în Chromium doar pentru "
"\"noduri de frunze\" bine izolate, mai degrabă decât pentru o interfață Rust-"
"C++ arbitrară. Atunci când se ia în considerare un caz de utilizare pentru "
"Rust în Chromium, un bun punct de plecare este să se redacteze legăturile "
"CXX pentru limita limbajului pentru a vedea dacă pare suficient de simplu."

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
#, fuzzy
msgid ""
"You should also discuss some of the other sticky points with CXX, for "
"example:"
msgstr ""
"De asemenea, ar trebui să discutați cu CXX despre alte puncte sensibile, de "
"exemplu:"

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
#, fuzzy
msgid ""
"Its error handling is based around C++ exceptions (given on the next slide)"
msgstr ""
"Gestionarea erorilor se bazează pe excepțiile C++ (prezentate în slide-ul "
"următor)"

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
#, fuzzy
msgid "Function pointers are awkward to use."
msgstr "Indicatorii de funcție sunt greu de utilizat."

#: src/chromium/interoperability-with-cpp/error-handling.md
#, fuzzy
msgid ""
"CXX's [support for `Result<T,E>`](https://cxx.rs/binding/result.html) relies "
"on C++ exceptions, so we can't use that in Chromium. Alternatives:"
msgstr ""
"CXX [suportul pentru `Result<T,E>`](https://cxx.rs/binding/result.html) se "
"bazează pe excepțiile C++, așa că nu îl putem folosi în Chromium. "
"Alternative:"

#: src/chromium/interoperability-with-cpp/error-handling.md
#, fuzzy
msgid "The `T` part of `Result<T, E>` can be:"
msgstr "Partea `T` din `Result<T, E>` poate fi:"

#: src/chromium/interoperability-with-cpp/error-handling.md
#, fuzzy
msgid ""
"Returned via out parameters (e.g. via `&mut T`). This requires that `T` can "
"be passed across the FFI boundary - for example `T` has to be:"
msgstr ""
"Se returnează prin intermediul parametrilor de ieșire (de exemplu, prin "
"`&mut T`). Acest lucru necesită ca `T` să poată fi transmis peste granița "
"FFI - de exemplu, `T` trebuie să fie:"

#: src/chromium/interoperability-with-cpp/error-handling.md
#, fuzzy
msgid "A primitive type (like `u32` or `usize`)"
msgstr "Un tip primitiv (cum ar fi `u32` sau `usize`)"

#: src/chromium/interoperability-with-cpp/error-handling.md
#, fuzzy
msgid ""
"A type natively supported by `cxx` (like `UniquePtr<T>`) that has a suitable "
"default value to use in a failure case (_unlike_ `Box<T>`)."
msgstr ""
"Un tip suportat nativ de `cxx` (precum `UniquePtr<T>`) care are o valoare "
"implicită adecvată pentru a fi utilizată în caz de eșec (spre deosebire de "
"`Box<T>`)."

#: src/chromium/interoperability-with-cpp/error-handling.md
#, fuzzy
msgid ""
"Retained on the Rust side, and exposed via reference. This may be needed "
"when `T` is a Rust type, which cannot be passed across the FFI boundary, and "
"cannot be stored in `UniquePtr<T>`."
msgstr ""
"Reținută pe partea de rugină și expusă prin referință. Acest lucru poate fi "
"necesar atunci când `T` este un tip Rust, care nu poate fi trecut peste "
"granița FFI și nu poate fi stocat în `UniquePtr<T>`."

#: src/chromium/interoperability-with-cpp/error-handling.md
#, fuzzy
msgid "The `E` part of `Result<T, E>` can be:"
msgstr "Partea `E` din `Result<T, E>` poate fi:"

#: src/chromium/interoperability-with-cpp/error-handling.md
#, fuzzy
msgid ""
"Returned as a boolean (e.g. `true` representing success, and `false` "
"representing failure)"
msgstr ""
"Se returnează sub formă de boolean (de exemplu, `true` reprezintă succesul, "
"iar `false` reprezintă eșecul)"

#: src/chromium/interoperability-with-cpp/error-handling.md
#, fuzzy
msgid ""
"Preserving error details is in theory possible, but so far hasn't been "
"needed in practice."
msgstr ""
"Păstrarea detaliilor privind erorile este teoretic posibilă, dar până în "
"prezent nu a fost necesară în practică."

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
#, fuzzy
msgid "CXX Error Handling: QR Example"
msgstr "Gestionarea erorilor"

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
#, fuzzy
msgid ""
"The QR code generator is [an example](https://source.chromium.org/chromium/"
"chromium/src/+/main:components/qr_code_generator/qr_code_generator_ffi_glue."
"rs;l=13-18;drc=7bf1b75b910ca430501b9c6a74c1d18a0223ecca) where a boolean is "
"used to communicate success vs failure, and where the successful result can "
"be passed across the FFI boundary:"
msgstr ""
"Generatorul de coduri QR este [un exemplu](https://source.chromium.org/"
"chromium/chromium/src/+/main:components/qr_code_generator/"
"qr_code_generator_ffi_glue.rs;l=13-18;"
"drc=7bf1bb75b910ca430501b9c6a74c1d18a0223ecca) în care se utilizează un "
"boolean pentru a comunica succesul vs. eșecul și în care rezultatul de "
"succes poate fi transmis peste granița FFI:"

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
#, fuzzy
msgid "\"qr_code_generator\""
msgstr "\"qr_code_generator\""

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
#, fuzzy
msgid ""
"Students may be curious about the semantics of the `out_qr_size` output. "
"This is not the size of the vector, but the size of the QR code (and "
"admittedly it is a bit redundant - this is the square root of the size of "
"the vector)."
msgstr ""
"Elevii pot fi curioși în legătură cu semantica ieșirii `out_qr_size`. "
"Aceasta nu este dimensiunea vectorului, ci dimensiunea codului QR (și, "
"trebuie să recunoaștem, este un pic redundantă - este rădăcina pătrată a "
"dimensiunii vectorului)."

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
#, fuzzy
msgid ""
"It may be worth pointing out the importance of initializing `out_qr_size` "
"before calling into the Rust function. Creation of a Rust reference that "
"points to uninitialized memory results in Undefined Behavior (unlike in C++, "
"when only the act of dereferencing such memory results in UB)."
msgstr ""
"Ar putea fi util să subliniem importanța inițializării `out_qr_size` înainte "
"de a apela la funcția Rust. Crearea unei referințe Rust care indică o "
"memorie neinițializată are ca rezultat un comportament nedefinit (spre "
"deosebire de C++, când numai actul de dereferențiere a unei astfel de "
"memorii are ca rezultat UB)."

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
#, fuzzy
msgid ""
"If students ask about `Pin`, then explain why CXX needs it for mutable "
"references to C++ data: the answer is that C++ data can't be moved around "
"like Rust data, because it may contain self-referential pointers."
msgstr ""
"Dacă elevii întreabă despre `Pin`, explicați-le de ce CXX are nevoie de el "
"pentru referințele mutabile la datele C++: răspunsul este că datele C++ nu "
"pot fi mutate ca și datele Rust, deoarece pot conține pointeri "
"autoreferențiali."

#: src/chromium/interoperability-with-cpp/error-handling-png.md
#, fuzzy
msgid "CXX Error Handling: PNG Example"
msgstr "Gestionarea erorilor"

#: src/chromium/interoperability-with-cpp/error-handling-png.md
#, fuzzy
msgid ""
"A prototype of a PNG decoder illustrates what can be done when the "
"successful result cannot be passed across the FFI boundary:"
msgstr ""
"Un prototip al unui decodor PNG ilustrează ce se poate face atunci când "
"rezultatul pozitiv nu poate fi transmis peste granița FFI:"

#: src/chromium/interoperability-with-cpp/error-handling-png.md
#, fuzzy
msgid "\"gfx::rust_bindings\""
msgstr "\"gfx::rust_bindings\""

#: src/chromium/interoperability-with-cpp/error-handling-png.md
#, fuzzy
msgid ""
"/// This returns an FFI-friendly equivalent of `Result<PngReader<'a>,\n"
"        /// ()>`.\n"
msgstr ""
"/// Aceasta returnează un echivalent FFI-friendly al `Result<PngReader<'a>,\n"
"        /// ()>`.\n"

#: src/chromium/interoperability-with-cpp/error-handling-png.md
#, fuzzy
msgid "/// C++ bindings for the `crate::png::ResultOfPngReader` type.\n"
msgstr "/// Legături C++ pentru tipul `crate::png::ResultOfPngReader`.\n"

#: src/chromium/interoperability-with-cpp/error-handling-png.md
#, fuzzy
msgid "/// C++ bindings for the `crate::png::PngReader` type.\n"
msgstr "/// Legături C++ pentru tipul `crate::png::PngReader`.\n"

#: src/chromium/interoperability-with-cpp/error-handling-png.md
#, fuzzy
msgid ""
"`PngReader` and `ResultOfPngReader` are Rust types --- objects of these "
"types cannot cross the FFI boundary without indirection of a `Box<T>`. We "
"can't have an `out_parameter: &mut PngReader`, because CXX doesn't allow C++ "
"to store Rust objects by value."
msgstr ""
"`PngReader` și `ResultOfPngReader` sunt tipuri Rust --- obiectele din aceste "
"tipuri nu pot trece granița FFI fără o indirecțiune a unui `Box<T>`. Nu "
"putem avea un `out_parameter: &amp;mut PngReader`, deoarece CXX nu permite "
"ca C++ să stocheze obiecte Rust prin valoare."

#: src/chromium/interoperability-with-cpp/error-handling-png.md
#, fuzzy
msgid ""
"This example illustrates that even though CXX doesn't support arbitrary "
"generics nor templates, we can still pass them across the FFI boundary by "
"manually specializing / monomorphizing them into a non-generic type. In the "
"example `ResultOfPngReader` is a non-generic type that forwards into "
"appropriate methods of `Result<T, E>` (e.g. into `is_err`, `unwrap`, and/or "
"`as_mut`)."
msgstr ""
"Acest exemplu ilustrează faptul că, chiar dacă CXX nu acceptă generici "
"arbitrari și nici șabloane, putem totuși să le trecem peste granița FFI prin "
"specializarea / monomorfizarea manuală într-un tip non-generic. În exemplu, "
"`ResultOfPngReader` este un tip ne-generic care se transmite în metodele "
"corespunzătoare ale `Result<T, E>` (de exemplu, în `is_err`, `unwrap` și/sau "
"`as_mut`)."

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
#, fuzzy
msgid "Using cxx in Chromium"
msgstr "Utilizarea CXX în Chromium"

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
#, fuzzy
msgid ""
"In Chromium, we define an independent `#[cxx::bridge] mod` for each leaf-"
"node where we want to use Rust. You'd typically have one for each "
"`rust_static_library`. Just add"
msgstr ""
"În Chromium, definim un `#[cxx::bridge] mod` independent pentru fiecare nod "
"frunză în care dorim să folosim Rust. De obicei, veți avea unul pentru "
"fiecare `rust_static_library`. Trebuie doar să adăugați"

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
#, fuzzy
msgid ""
"```gn\n"
"cxx_bindings = [ \"my_rust_file.rs\" ]\n"
"   # list of files containing #[cxx::bridge], not all source files\n"
"allow_unsafe = true\n"
"```"
msgstr ""
"```gn\n"
"cxx_bindings = [ \"my_rust_file.rs\" ]\n"
"   # listă de fișiere care conțin #[cxx::bridge], nu toate fișierele sursă\n"
"allow_unsafe = true\n"
"```"

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
#, fuzzy
msgid ""
"to your existing `rust_static_library` target alongside `crate_root` and "
"`sources`."
msgstr ""
"la ținta `rust_static_library` existentă, alături de `crate_root` și "
"`sources`."

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
#, fuzzy
msgid "C++ headers will be generated at a sensible location, so you can just"
msgstr ""
"Anteturile C++ vor fi generate într-o locație sensibilă, astfel încât puteți "
"doar să"

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
#, fuzzy
msgid "\"ui/base/my_rust_file.rs.h\""
msgstr "\"ui/base/my_rust_file.rs.h\""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
#, fuzzy
msgid ""
"You will find some utility functions in `//base` to convert to/from Chromium "
"C++ types to CXX Rust types --- for example [`SpanToRustSlice`](https://"
"source.chromium.org/chromium/chromium/src/+/main:base/containers/span_rust.h;"
"l=21)."
msgstr ""
"Veți găsi câteva funcții utilitare în `//base` pentru a converti la/de la "
"tipurile Chromium C++ la tipurile CXX Rust --- de exemplu [`SpanToRustSlice`]"
"(https://source.chromium.org/chromium/chromium/src/+/main:base/containers/"
"span_rust.h;l=21)."

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
#, fuzzy
msgid "Students may ask --- why do we still need `allow_unsafe = true`?"
msgstr ""
"Studenții se pot întreba --- de ce mai avem nevoie de `allow_unsafe = true`?"

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
#, fuzzy
msgid ""
"The broad answer is that no C/C++ code is \"safe\" by the normal Rust "
"standards. Calling back and forth to C/C++ from Rust may do arbitrary things "
"to memory, and compromise the safety of Rust's own data layouts. Presence of "
"_too many_ `unsafe` keywords in C/C++ interop can harm the signal-to-noise "
"ratio of such a keyword, and is [controversial](https://steveklabnik.com/"
"writing/the-cxx-debate), but strictly, bringing any foreign code into a Rust "
"binary can cause unexpected behavior from Rust's perspective."
msgstr ""
"Răspunsul general este că nici un cod C/C++ nu este \"sigur\" după "
"standardele Rust obișnuite. Apelarea din Rust către C/C++ poate face lucruri "
"arbitrare în memorie și poate compromite siguranța propriilor aranjamente de "
"date din Rust. Prezența a _prea multor_ cuvinte cheie `unsafe` în interop C/"
"C++ poate dăuna raportului semnal-zgomot al unui astfel de cuvânt cheie și "
"este [controversată](https://steveklabnik.com/writing/the-cxx-debate), dar, "
"strict, aducerea oricărui cod străin într-un binar Rust poate cauza un "
"comportament neașteptat din perspectiva Rust."

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
#, fuzzy
msgid ""
"The narrow answer lies in the diagram at the top of [this page](../"
"interoperability-with-cpp.md) --- behind the scenes, CXX generates Rust "
"`unsafe` and `extern \"C\"` functions just like we did manually in the "
"previous section."
msgstr ""
"Răspunsul restrâns se află în diagrama din partea de sus a [acestei pagini]"
"(../interoperabilitate-cu-cpp.md) --- în spatele scenei, CXX generează "
"funcții Rust `unsafe` și `extern \"C\"` exact așa cum am făcut manual în "
"secțiunea anterioară."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Exercise: Interoperability with C++"
msgstr "Interoperabilitate cu C"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Part one"
msgstr "Prima parte"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"In the Rust file you previously created, add a `#[cxx::bridge]` which "
"specifies a single function, to be called from C++, called "
"`hello_from_rust`, taking no parameters and returning no value."
msgstr ""
"În fișierul Rust pe care l-ați creat anterior, adăugați un `#[cxx::bridge]` "
"care specifică o singură funcție, care va fi apelată din C++, numită "
"`hello_from_rust`, care nu primește parametri și nu returnează nicio valoare."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"Modify your previous `hello_from_rust` function to remove `extern \"C\"` and "
"`#[no_mangle]`. This is now just a standard Rust function."
msgstr ""
"Modificați funcția `hello_from_rust` anterioară pentru a elimina `extern "
"\"C\"` și `#[no_mangle]`. Aceasta este acum doar o funcție Rust standard."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Modify your `gn` target to build these bindings."
msgstr "Modificați ținta `gn` pentru a construi aceste legături."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"In your C++ code, remove the forward-declaration of `hello_from_rust`. "
"Instead, include the generated header file."
msgstr ""
"În codul dvs. C++, eliminați declarația forward a lui `hello_from_rust`. În "
"schimb, includeți fișierul antet generat."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Build and run!"
msgstr "Construiește și rulează!"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Part two"
msgstr "Partea a doua"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"It's a good idea to play with CXX a little. It helps you think about how "
"flexible Rust in Chromium actually is."
msgstr ""
"Este o idee bună să vă jucați puțin cu CXX. Vă ajută să vă gândiți la cât de "
"flexibil este de fapt Rust în Chromium."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Some things to try:"
msgstr "Câteva note:"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Call back into C++ from Rust. You will need:"
msgstr "Apelarea înapoi în C++ din Rust. Veți avea nevoie de:"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"An additional header file which you can `include!` from your `cxx::bridge`. "
"You'll need to declare your C++ function in that new header file."
msgstr ""
"Un fișier header suplimentar pe care îl puteți `include!` din `cxx::bridge`. "
"Va trebui să vă declarați funcția C++ în acest nou fișier de antet."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"An `unsafe` block to call such a function, or alternatively specify the "
"`unsafe` keyword in your `#[cxx::bridge]` [as described here](https://cxx.rs/"
"extern-c++.html#functions-and-member-functions)."
msgstr ""
"Un bloc `unsafe` pentru a apela o astfel de funcție sau, alternativ, "
"specificați cuvântul cheie `unsafe` în `#[cxx::bridge]` [așa cum este "
"descris aici](https://cxx.rs/extern-c++.html#functions-and-member-functions)."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"You may also need to `#include \"third_party/rust/cxx/v1/crate/include/cxx."
"h\"`"
msgstr ""
"Este posibil să aveți nevoie și de `#include \"third_party/rust/cxx/v1/crate/"
"include/cxx.h\"``"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Pass a C++ string from C++ into Rust."
msgstr "Treceți un șir C++ din C++ în Rust."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Pass a reference to a C++ object into Rust."
msgstr "Treceți o referință la un obiect C++ în Rust."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"Intentionally get the Rust function signatures mismatched from the `#[cxx::"
"bridge]`, and get used to the errors you see."
msgstr ""
"Obțineți în mod intenționat semnăturile funcțiilor Rust nepotrivite din "
"`#[cxx::bridge]` și obișnuiți-vă cu erorile pe care le vedeți."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"Intentionally get the C++ function signatures mismatched from the `#[cxx::"
"bridge]`, and get used to the errors you see."
msgstr ""
"Obțineți în mod intenționat semnăturile funcțiilor C++ nepotrivite din "
"`#[cxx::bridge]` și obișnuiți-vă cu erorile pe care le vedeți."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"Pass a `std::unique_ptr` of some type from C++ into Rust, so that Rust can "
"own some C++ object."
msgstr ""
"Treceți un `std::unique_ptr` de un anumit tip din C++ în Rust, astfel încât "
"Rust să poată deține un obiect C++."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"Create a Rust object and pass it into C++, so that C++ owns it. (Hint: you "
"need a `Box`)."
msgstr ""
"Creați un obiect Rust și treceți-l în C++, astfel încât C++ să îl dețină. "
"(Indicație: aveți nevoie de un `Box`)."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Declare some methods on a C++ type. Call them from Rust."
msgstr "Declararea unor metode pentru un tip C++. Apelați-le din Rust."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Declare some methods on a Rust type. Call them from C++."
msgstr "Declararea unor metode pentru un tip Rust. Apelați-le din C++."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Part three"
msgstr "Partea a treia"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"Now you understand the strengths and limitations of CXX interop, think of a "
"couple of use-cases for Rust in Chromium where the interface would be "
"sufficiently simple. Sketch how you might define that interface."
msgstr ""
"Acum că ați înțeles punctele forte și limitările interoperării CXX, gândiți-"
"vă la câteva cazuri de utilizare pentru Rust în Chromium în care interfața "
"ar fi suficient de simplă. Schițați cum ați putea defini această interfață."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "The [`cxx` binding reference](https://cxx.rs/bindings.html)"
msgstr ""
"Arătați corespondența dintre [tipurile Rust și C++](https://cxx.rs/bindings."
"html):"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"The [`rust_static_library` gn template](https://source.chromium.org/chromium/"
"chromium/src/+/main:build/rust/rust_static_library.gni;l=16)"
msgstr ""
"Șablonul [`rust_static_library` gn](https://source.chromium.org/chromium/"
"chromium/src/+/main:build/rust/rust/rust_static_library.gni;l=16)"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Some of the questions you may encounter:"
msgstr "Câteva dintre întrebările pe care le puteți întâlni:"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"I'm seeing a problem initializing a variable of type X with type Y, where X "
"and Y are both function types. This is because your C++ function doesn't "
"quite match the declaration in your `cxx::bridge`."
msgstr ""
"Am o problemă în ceea ce privește inițializarea unei variabile de tip X cu "
"tipul Y, unde X și Y sunt ambele tipuri de funcții. Acest lucru se datorează "
"faptului că funcția dvs. C++ nu se potrivește cu declarația din `cxx::"
"bridge`."

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"I seem to be able to freely convert C++ references into Rust references. "
"Doesn't that risk UB? For CXX's _opaque_ types, no, because they are zero-"
"sized. For CXX trivial types yes, it's _possible_ to cause UB, although "
"CXX's design makes it quite difficult to craft such an example."
msgstr ""
"Se pare că pot converti în mod liber referințele C++ în referințe Rust. Nu "
"riscă asta UB? În cazul tipurilor _opaque_ din CXX, nu, deoarece acestea "
"sunt de dimensiune zero. Pentru tipurile triviale din CXX, da, este "
"_posibil_ să provoace UB, deși designul CXX face destul de dificilă crearea "
"unui astfel de exemplu."

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid ""
"Rust libraries are called \"crates\" and are found at [crates.io](https://"
"crates.io). It's _very easy_ for Rust crates to depend upon one another. So "
"they do!"
msgstr ""
"Bibliotecile Rust se numesc \"crates\" și se găsesc la [crates.io](https://"
"crates.io). Este _foarte ușor_ pentru crates Rust să depindă unele de "
"altele. Așa că o fac!"

#: src/chromium/adding-third-party-crates.md
msgid "Property"
msgstr "Proprietate"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "C++ library"
msgstr "bibliotecă:"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "Rust crate"
msgstr "Ecosistemul Rust"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "Build system"
msgstr ""
"Veți avea nevoie de un [sursele AOSP](https://source.android.com/docs/setup/"
"download/downloading). Efectuați o descărcare a [resurselor cursului]"
"(https://github.com/google/comprehensive-rust) pe aceeași mașină și mutați "
"directorul `src/android/` în rădăcina surselor AOSP. Acest lucru va asigura "
"că sistemul de compilare Android vede fișierele `Android.bp` din `src/"
"android/`."

#: src/chromium/adding-third-party-crates.md
msgid "Lots"
msgstr "Multe"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "Consistent: `Cargo.toml`"
msgstr "Puteți utiliza următorul `Cargo.toml`:"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "Typical library size"
msgstr "Dimensiunea tipică a bibliotecii"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "Large-ish"
msgstr "Mare-ish"

#: src/chromium/adding-third-party-crates.md
msgid "Small"
msgstr "Mic"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "Transitive dependencies"
msgstr "Dependențe tranzitive"

#: src/chromium/adding-third-party-crates.md
msgid "Few"
msgstr "Iată câteva link-uri utile pentru a obține ajutor pe parcurs"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "For a Chromium engineer, this has pros and cons:"
msgstr "Pentru un inginer Chromium, acest lucru are avantaje și dezavantaje:"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid ""
"All crates use a common build system so we can automate their inclusion into "
"Chromium..."
msgstr ""
"Toate craterele folosesc un sistem comun de construire, astfel încât să "
"putem automatiza includerea lor în Chromium..."

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid ""
"... but, crates typically have transitive dependencies, so you will likely "
"have to bring in multiple libraries."
msgstr ""
"... dar, de obicei, crates are dependențe tranzitive, așa că va trebui "
"probabil să introduceți mai multe biblioteci."

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "We'll discuss:"
msgstr "Vom discuta:"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "How to put a crate in the Chromium source code tree"
msgstr "Cum se pune o casetă în arborele de cod sursă Chromium"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "How to make `gn` build rules for it"
msgstr "Cum să faci regulile de construcție `gn` pentru el"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "How to audit its source code for sufficient safety."
msgstr "Cum se auditează codul sursă pentru a asigura o siguranță suficientă."

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
#, fuzzy
msgid "Configuring the `Cargo.toml` file to add crates"
msgstr "Configurarea fișierului `Cargo.toml` pentru a adăuga lăzi"

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
#, fuzzy
msgid ""
"Chromium has a single set of centrally-managed direct crate dependencies. "
"These are managed through a single [`Cargo.toml`](https://source.chromium."
"org/chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/Cargo."
"toml):"
msgstr ""
"Chromium are un singur set de dependențe directe de crate gestionate la "
"nivel central. Acestea sunt gestionate prin intermediul unui singur [`Cargo."
"toml`](https://source.chromium.org/chromium/chromium/src/+/main:third_party/"
"rust/chromium_crates_io/Cargo.toml):"

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
#, fuzzy
msgid ""
"```toml\n"
"[dependencies]\n"
"bitflags = \"1\"\n"
"cfg-if = \"1\"\n"
"cxx = \"1\"\n"
"# lots more...\n"
"```"
msgstr ""
"```toml\n"
"[dependențe]\n"
"bitflags = \"1\"\n"
"cfg-if = \"1\"\n"
"cxx = \"1\"\n"
"# multe altele...\n"
"```"

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
#, fuzzy
msgid ""
"As with any other `Cargo.toml`, you can specify [more details about the "
"dependencies](https://doc.rust-lang.org/cargo/reference/specifying-"
"dependencies.html) --- most commonly, you'll want to specify the `features` "
"that you wish to enable in the crate."
msgstr ""
"Ca și în cazul oricărui alt `Cargo.toml`, puteți specifica [mai multe "
"detalii despre dependențe](https://doc.rust-lang.org/cargo/reference/"
"specifying-dependencies.html) --- cel mai frecvent, veți dori să specificați "
"`features` pe care doriți să le activați în crate."

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
#, fuzzy
msgid ""
"When adding a crate to Chromium, you'll often need to provide some extra "
"information in an additional file, `gnrt_config.toml`, which we'll meet next."
msgstr ""
"Atunci când adăugați un crate la Chromium, va trebui adesea să furnizați "
"câteva informații suplimentare într-un fișier suplimentar, `gnrt_config."
"toml`, pe care îl vom întâlni în continuare."

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
#, fuzzy
msgid ""
"Alongside `Cargo.toml` is [`gnrt_config.toml`](https://source.chromium.org/"
"chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/gnrt_config."
"toml). This contains Chromium-specific extensions to crate handling."
msgstr ""
"Alături de `Cargo.toml` se află [`gnrt_config.toml`](https://source.chromium."
"org/chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/"
"gnrt_config.toml). Acesta conține extensii specifice Chromium pentru "
"gestionarea crate-urilor."

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
#, fuzzy
msgid ""
"If you add a new crate, you should specify at least the `group`. This is one "
"of:"
msgstr ""
"Dacă adăugați o ladă nouă, trebuie să specificați cel puțin `group`. Acesta "
"este unul dintre următoarele:"

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
#, fuzzy
msgid "For instance,"
msgstr "De exemplu,"

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
#, fuzzy
msgid ""
"Depending on the crate source code layout, you may also need to use this "
"file to specify where its `LICENSE` file(s) can be found."
msgstr ""
"În funcție de dispunerea codului sursă al crate-ului, este posibil să fie "
"nevoie să folosiți acest fișier pentru a specifica unde pot fi găsite "
"fișierul (fișierele) `LICENSE`."

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
#, fuzzy
msgid ""
"Later, we'll see some other things you will need to configure in this file "
"to resolve problems."
msgstr ""
"Mai târziu, vom vedea alte lucruri pe care va trebui să le configurați în "
"acest fișier pentru a rezolva problemele."

#: src/chromium/adding-third-party-crates/downloading-crates.md
#, fuzzy
msgid ""
"A tool called `gnrt` knows how to download crates and how to generate `BUILD."
"gn` rules."
msgstr ""
"Un instrument numit `gnrt` știe cum să descarce crates și cum să genereze "
"regulile `BUILD.gn`."

#: src/chromium/adding-third-party-crates/downloading-crates.md
#, fuzzy
msgid "To start, download the crate you want like this:"
msgstr "Pentru a începe, descărcați caseta pe care o doriți, astfel:"

#: src/chromium/adding-third-party-crates/downloading-crates.md
#, fuzzy
msgid ""
"Although the `gnrt` tool is part of the Chromium source code, by running "
"this command you will be downloading and running its dependencies from "
"`crates.io`. See [the earlier section](../cargo.md) discussing this security "
"decision."
msgstr ""
"Deși instrumentul `gnrt` face parte din codul sursă Chromium, prin rularea "
"acestei comenzi veți descărca și rula dependențele sale de pe `crates.io`. "
"Consultați [secțiunea anterioară](../cargo.md) în care se discută această "
"decizie de securitate."

#: src/chromium/adding-third-party-crates/downloading-crates.md
#, fuzzy
msgid "This `vendor` command may download:"
msgstr "Această comandă `vendor` poate descărca:"

#: src/chromium/adding-third-party-crates/downloading-crates.md
#, fuzzy
msgid "Your crate"
msgstr "Lăzi (crates) utile"

#: src/chromium/adding-third-party-crates/downloading-crates.md
#, fuzzy
msgid "Direct and transitive dependencies"
msgstr "Dependențe directe și tranzitive"

#: src/chromium/adding-third-party-crates/downloading-crates.md
#, fuzzy
msgid ""
"New versions of other crates, as required by `cargo` to resolve the complete "
"set of crates required by Chromium."
msgstr ""
"Versiuni noi ale altor crates, după cum este necesar pentru ca `cargo` să "
"rezolve setul complet de crates cerut de Chromium."

#: src/chromium/adding-third-party-crates/downloading-crates.md
#, fuzzy
msgid ""
"Chromium maintains patches for some crates, kept in `//third_party/rust/"
"chromium_crates_io/patches`. These will be reapplied automatically, but if "
"patching fails you may need to take manual action."
msgstr ""
"Chromium menține patch-uri pentru unele crates, păstrate în `//third_party/"
"rust/chromium_crates_io/patches`. Acestea vor fi reaplicate în mod automat, "
"dar dacă patch-urile nu reușesc este posibil să fie nevoie să luați măsuri "
"manuale."

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
#, fuzzy
msgid ""
"Once you've downloaded the crate, generate the `BUILD.gn` files like this:"
msgstr "După ce ați descărcat crate, generați fișierele `BUILD.gn` astfel:"

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
#, fuzzy
msgid "Now run `git status`. You should find:"
msgstr "Acum rulați `git status`. Ar trebui să găsiți:"

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
#, fuzzy
msgid ""
"At least one new crate source code in `third_party/rust/chromium_crates_io/"
"vendor`"
msgstr ""
"Cel puțin un nou cod sursă de crate în `third_party/rust/chromium_crates_io/"
"vendor`"

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
#, fuzzy
msgid ""
"At least one new `BUILD.gn` in `third_party/rust/<crate name>/v<major semver "
"version>`"
msgstr ""
"Cel puțin un nou `BUILD.gn` în `third_party/rust/<crate name>/v<major semver "
"version>`"

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
#, fuzzy
msgid "An appropriate `README.chromium`"
msgstr "Un `README.chromium` adecvat"

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
#, fuzzy
msgid ""
"The \"major semver version\" is a [Rust \"semver\" version number](https://"
"doc.rust-lang.org/cargo/reference/semver.html)."
msgstr ""
"A se vedea [Rust Reference](https://doc.rust-lang.org/reference/type-layout."
"html)."

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
#, fuzzy
msgid ""
"Take a close look, especially at the things generated in `third_party/rust`."
msgstr ""
"Uitați-vă cu atenție, în special la lucrurile generate în `third_party/rust`."

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
#, fuzzy
msgid ""
"Talk a little about semver --- and specifically the way that in Chromium "
"it's to allow multiple incompatible versions of a crate, which is "
"discouraged but sometimes necessary in the Cargo ecosystem."
msgstr ""
"Vorbiți puțin despre semver --- și în special despre modul în care, în "
"Chromium, permite mai multe versiuni incompatibile ale unei cutii, ceea ce "
"este descurajat, dar uneori necesar în ecosistemul Cargo."

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid ""
"If your build fails, it may be because of a `build.rs`: programs which do "
"arbitrary things at build time. This is fundamentally at odds with the "
"design of `gn` and `ninja` which aim for static, deterministic, build rules "
"to maximize parallelism and repeatability of builds."
msgstr ""
"Dacă nu reușiți să construiți, este posibil să fie din cauza unui `build."
"rs`: programe care fac lucruri arbitrare în momentul construirii. Acest "
"lucru este în mod fundamental în contradicție cu proiectarea `gn` și "
"`ninja`, care vizează reguli de construire statice, deterministe, pentru a "
"maximiza paralelismul și repetabilitatea compilărilor."

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid ""
"Some `build.rs` actions are automatically supported; others require action:"
msgstr ""
"Unele acțiuni `build.rs` sunt acceptate în mod automat; altele necesită o "
"acțiune:"

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid "build script effect"
msgstr "efect de script de construcție"

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid "Supported by our gn templates"
msgstr "Sprijinit de șabloanele noastre gn"

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid "Work required by you"
msgstr "Lucrări solicitate de dumneavoastră"

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid "Checking rustc version to configure features on and off"
msgstr ""
"Verificarea versiunii rustc pentru a configura funcțiile de activare și "
"dezactivare"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Yes"
msgstr "Da"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "None"
msgstr "Nici unul"

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid "Checking platform or CPU to configure features on and off"
msgstr ""
"Verificarea platformei sau a unității centrale de procesare pentru a "
"configura funcțiile activate și dezactivate"

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid "Generating code"
msgstr "Produse generice"

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid "Yes - specify in `gnrt_config.toml`"
msgstr "Da - specificați în `gnrt_config.toml`"

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid "Building C/C++"
msgstr "Construirea C/C++"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "No"
msgstr "Nu"

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid "Patch around it"
msgstr "Patch în jurul ei"

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid "Arbitrary other actions"
msgstr "Alte acțiuni arbitrare"

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid ""
"Fortunately, most crates don't contain a build script, and fortunately, most "
"build scripts only do the top two actions."
msgstr ""
"Din fericire, cele mai multe cratere nu conțin un script de construcție și, "
"din fericire, majoritatea scripturilor de construcție efectuează doar "
"primele două acțiuni."

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
#, fuzzy
msgid ""
"If `ninja` complains about missing files, check the `build.rs` to see if it "
"writes source code files."
msgstr ""
"Dacă `ninja` se plânge că lipsesc fișiere, verificați `build.rs` pentru a "
"vedea dacă scrie fișiere de cod sursă."

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
#, fuzzy
msgid ""
"If so, modify [`gnrt_config.toml`](../configuring-gnrt-config-toml.md) to "
"add `build-script-outputs` to the crate. If this is a transitive dependency, "
"that is, one on which Chromium code should not directly depend, also add "
"`allow-first-party-usage=false`. There are several examples already in that "
"file:"
msgstr ""
"În acest caz, modificați [`gnrt_config_config.toml`](../configuring-gnrt-"
"config-toml.md) pentru a adăuga `build-script-outputs` la crate. Dacă "
"aceasta este o dependență tranzitivă, adică una de care codul Chromium nu ar "
"trebui să depindă direct, adăugați și `allow-first-party-usage=false`. "
"Există deja câteva exemple în acel fișier:"

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
#, fuzzy
msgid ""
"```toml\n"
"[crate.unicode-linebreak]\n"
"allow-first-party-usage = false\n"
"build-script-outputs = [\"tables.rs\"]\n"
"```"
msgstr ""
"```toml\n"
"[crate.unicode-linebreak]\n"
"allow-first-party-usage = false\n"
"build-script-outputs = [\"tables.rs\"]\n"
"```"

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
#, fuzzy
msgid ""
"Now rerun [`gnrt.py -- gen`](../generating-gn-build-rules.md) to regenerate "
"`BUILD.gn` files to inform ninja that this particular output file is input "
"to subsequent build steps."
msgstr ""
"Acum rulați din nou [`gnrt.py -- gen`](../generating-gn-gn-build-rules.md) "
"pentru a regenera fișierele `BUILD.gn` pentru a informa ninja că acest "
"fișier de ieșire este o intrare pentru etapele ulterioare de construire."

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
#, fuzzy
msgid ""
"Some crates use the [`cc`](https://crates.io/crates/cc) crate to build and "
"link C/C++ libraries. Other crates parse C/C++ using [`bindgen`](https://"
"crates.io/crates/bindgen) within their build scripts. These actions can't be "
"supported in a Chromium context --- our gn, ninja and LLVM build system is "
"very specific in expressing relationships between build actions."
msgstr ""
"Unele crates utilizează crate-ul [`cc`](https://crates.io/crates/cc) pentru "
"a construi și lega bibliotecile C/C++. Alte crates analizează C/C++ folosind "
"[`bindgen`](https://crates.io/crates/bindgen) în scripturile lor de "
"compilare. Aceste acțiuni nu pot fi suportate în contextul Chromium --- "
"sistemul nostru de compilare gn, ninja și LLVM este foarte specific în "
"exprimarea relațiilor dintre acțiunile de compilare."

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
#, fuzzy
msgid "So, your options are:"
msgstr "Deci, opțiunile tale sunt:"

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
#, fuzzy
msgid "Avoid these crates"
msgstr "Evitați aceste lăzi"

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
#, fuzzy
msgid "Apply a patch to the crate."
msgstr "Aplicați un plasture pe ladă."

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
#, fuzzy
msgid ""
"Patches should be kept in `third_party/rust/chromium_crates_io/patches/"
"<crate>` - see for example the [patches against the `cxx` crate](https://"
"source.chromium.org/chromium/chromium/src/+/main:third_party/rust/"
"chromium_crates_io/patches/cxx/) - and will be applied automatically by "
"`gnrt` each time it upgrades the crate."
msgstr ""
"Patch-urile ar trebui păstrate în `third_party/rust/chromium_crates_io/"
"patches/<crate>` - a se vedea, de exemplu, [patches against the `cxx` crate]"
"(https://source.chromium.org/chromium/chromium/src/+/main:third_party/rust/"
"chromium_crates_io/patches/cxx/) - și vor fi aplicate automat de către "
"`gnrt` de fiecare dată când actualizează crate-ul."

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
#, fuzzy
msgid ""
"Once you've added a third-party crate and generated build rules, depending "
"on a crate is simple. Find your `rust_static_library` target, and add a "
"`dep` on the `:lib` target within your crate."
msgstr ""
"Odată ce ați adăugat o casetă terță parte și ați generat reguli de "
"construcție, este simplu să depindeți de o casetă. Găsiți ținta "
"`rust_static_library` și adăugați un `dep` pe ținta `:lib` în cadrul crate-"
"ului dumneavoastră."

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
#, fuzzy
msgid "Specifically,"
msgstr "Specific sistemului de operare"

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
#, fuzzy
msgid ""
"```bob\n"
"                     +------------+      +----------------------+\n"
"\"//third_party/rust\" | crate name | \"/v\" | major semver version | \":"
"lib\"\n"
"                     +------------+      +----------------------+\n"
"```"
msgstr ""
"```bob\n"
"                     +------------+ +----------------------+\n"
"\"//third_party/rust\" | nume ladă | \"/v\" | versiunea majoră a semver | \":"
"lib\"\n"
"                     +------------+ +----------------------+\n"
"```"

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
#, fuzzy
msgid ""
"```gn\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"  deps = [ \"//third_party/rust/example_rust_crate/v1:lib\" ]\n"
"}\n"
"```"
msgstr ""
"```gn\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"  deps = [ \"//third_party/rust/example_rust_crate/v1:lib\" ]\n"
"}\n"
"```"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
#, fuzzy
msgid "Auditing Third Party Crates"
msgstr "Auditul caselor terților"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
#, fuzzy
msgid ""
"Adding new libraries is subject to Chromium's standard [policies](https://"
"chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/rust."
"md#Third_party-review), but of course also subject to security review. As "
"you may be bringing in not just a single crate but also transitive "
"dependencies, there may be a lot of code to review. On the other hand, safe "
"Rust code can have limited negative side effects. How should you review it?"
msgstr ""
"Adăugarea de noi biblioteci este supusă [politicilor] standard ale Chromium "
"(https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/rust."
"md#Third_party-review), dar, bineînțeles, este supusă și unei revizuiri de "
"securitate. Deoarece este posibil să aduceți nu doar o singură crăiasă, ci "
"și dependențe tranzitive, este posibil să existe o mulțime de cod de "
"revizuit. Pe de altă parte, codul Rust sigur poate avea efecte secundare "
"negative limitate. Cum ar trebui să îl revizuiți?"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
#, fuzzy
msgid ""
"Over time Chromium aims to move to a process based around [cargo vet]"
"(https://mozilla.github.io/cargo-vet/)."
msgstr ""
"În timp, Chromium își propune să treacă la un proces bazat pe [cargo vet]"
"(https://mozilla.github.io/cargo-vet/)."

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
#, fuzzy
msgid ""
"Meanwhile, for each new crate addition, we are checking for the following:"
msgstr "Între timp, pentru fiecare nouă ladă adăugată, verificăm următoarele:"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
#, fuzzy
msgid ""
"Understand why each crate is used. What's the relationship between crates? "
"If the build system for each crate contains a `build.rs` or procedural "
"macros, work out what they're for. Are they compatible with the way Chromium "
"is normally built?"
msgstr ""
"Înțelegeți de ce este folosită fiecare ladă. Care este relația dintre lăzi? "
"Dacă sistemul de compilare pentru fiecare crate conține un `build.rs` sau "
"macroproceduri procedurale, încercați să aflați la ce folosesc. Sunt "
"compatibile cu modul în care Chromium este construit în mod normal?"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
#, fuzzy
msgid "Check each crate seems to be reasonably well maintained"
msgstr "Verificați dacă fiecare ladă pare a fi rezonabil de bine întreținută"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
#, fuzzy
msgid ""
"Use `cd third-party/rust/chromium_crates_io; cargo audit` to check for known "
"vulnerabilities (first you'll need to `cargo install cargo-audit`, which "
"ironically involves downloading lots of dependencies from the internet[2](../"
"cargo.md))"
msgstr ""
"Folosiți `cd third-party/rust/chromium_crates_io; cargo audit` pentru a "
"verifica vulnerabilitățile cunoscute (mai întâi va trebui să `cargo install "
"cargo-audit`, care, în mod ironic, implică descărcarea multor dependențe de "
"pe internet[2](../cargo.md)))"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
#, fuzzy
msgid ""
"Ensure any `unsafe` code is good enough for the [Rule of Two](https://"
"chromium.googlesource.com/chromium/src/+/main/docs/security/rule-of-2."
"md#unsafe-code-in-safe-languages)"
msgstr ""
"Asigurați-vă că orice cod `unsafe` este suficient de bun pentru [Rule of Two]"
"(https://chromium.googlesource.com/chromium/src/+/main/docs/security/rule-"
"of-2.md#unsafe-code-in-safe-languages)"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
#, fuzzy
msgid "Check for any use of `fs` or `net` APIs"
msgstr "Verificați dacă se utilizează API-urile `fs` sau `net`"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
#, fuzzy
msgid ""
"Read all the code at a sufficient level to look for anything out of place "
"that might have been maliciously inserted. (You can't realistically aim for "
"100% perfection here: there's often just too much code.)"
msgstr ""
"Citiți tot codul la un nivel suficient pentru a căuta orice lucru care nu "
"este la locul lui și care ar fi putut fi introdus în mod rău intenționat. "
"(În mod realist, nu puteți urmări 100% perfecțiune aici: de multe ori este "
"prea mult cod)"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
#, fuzzy
msgid ""
"These are just guidelines --- work with reviewers from `security@chromium."
"org` to work out the right way to become confident of the crate."
msgstr ""
"Acestea sunt doar linii directoare --- lucrați cu recenzenții de la "
"`security@chromium.org` pentru a găsi modul corect de a deveni încrezător în "
"ladă."

#: src/chromium/adding-third-party-crates/checking-in.md
#, fuzzy
msgid "Checking Crates into Chromium Source Code"
msgstr "Verificarea Crates în codul sursă Chromium"

#: src/chromium/adding-third-party-crates/checking-in.md
#, fuzzy
msgid "`git status` should reveal:"
msgstr "`git status` ar trebui să arate:"

#: src/chromium/adding-third-party-crates/checking-in.md
#, fuzzy
msgid "Crate code in `//third_party/rust/chromium_crates_io`"
msgstr "Cod de crăiță în `//third_party/rust/chromium_crates_io`"

#: src/chromium/adding-third-party-crates/checking-in.md
#, fuzzy
msgid ""
"Metadata (`BUILD.gn` and `README.chromium`) in `//third_party/rust/<crate>/"
"<version>`"
msgstr ""
"Metadate (`BUILD.gn` și `README.chromium`) în `//third_party/rust/<crate>/"
"<version>`"

#: src/chromium/adding-third-party-crates/checking-in.md
#, fuzzy
msgid "Please also add an `OWNERS` file in the latter location."
msgstr ""
"Vă rugăm să adăugați, de asemenea, un fișier `OWNERS` în această din urmă "
"locație."

#: src/chromium/adding-third-party-crates/checking-in.md
#, fuzzy
msgid ""
"You should land all this, along with your `Cargo.toml` and `gnrt_config."
"toml` changes, into the Chromium repo."
msgstr ""
"Ar trebui să transferați toate acestea, împreună cu modificările `Cargo."
"toml` și `gnrt_config.toml`, în repo-ul Chromium."

#: src/chromium/adding-third-party-crates/checking-in.md
#, fuzzy
msgid ""
"**Important**: you need to use `git add -f` because otherwise `.gitignore` "
"files may result in some files being skipped."
msgstr ""
"**Important**: trebuie să folosiți `git add -f` pentru că altfel fișierele `."
"gitignore` pot duce la omiterea unor fișiere."

#: src/chromium/adding-third-party-crates/checking-in.md
#, fuzzy
msgid ""
"As you do so, you might find presubmit checks fail because of non-inclusive "
"language. This is because Rust crate data tends to include names of git "
"branches, and many projects still use non-inclusive terminology there. So "
"you may need to run:"
msgstr ""
"Pe măsură ce faceți acest lucru, s-ar putea să constatați că verificările "
"înainte de trimitere eșuează din cauza limbajului neincluziv. Acest lucru se "
"datorează faptului că datele din Rust crate tind să includă nume de ramuri "
"git, iar multe proiecte încă folosesc terminologia neinclusivă acolo. "
"Așadar, este posibil să fie nevoie să rulați:"

#: src/chromium/adding-third-party-crates/keeping-up-to-date.md
#, fuzzy
msgid ""
"As the OWNER of any third party Chromium dependency, you are [expected to "
"keep it up to date with any security fixes](https://chromium.googlesource."
"com/chromium/src/+/main/docs/adding_to_third_party.md#add-owners). It is "
"hoped that we will soon automate this for Rust crates, but for now, it's "
"still your responsibility just as it is for any other third party dependency."
msgstr ""
"În calitate de PROPRIETAR al oricărei dependențe de Chromium de la terți, "
"trebuie [să o mențineți la zi cu toate corecturile de securitate] (https://"
"chromium.googlesource.com/chromium/src/+/main/docs/adding_to_third_party."
"md#add-owners). Se speră că în curând vom automatiza acest lucru pentru Rust "
"crates, dar, deocamdată, este în continuare responsabilitatea dvs. la fel ca "
"pentru orice altă dependență terță parte."

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid ""
"Add [uwuify](https://crates.io/crates/uwuify) to Chromium, turning off the "
"crate's [default features](https://doc.rust-lang.org/cargo/reference/"
"features.html#the-default-feature). Assume that the crate will be used in "
"shipping Chromium, but won't be used to handle untrustworthy input."
msgstr ""
"Adăugați [uwuify](https://crates.io/crates/uwuify) la Chromium, dezactivând "
"[caracteristici implicite](https://doc.rust-lang.org/cargo/reference/"
"features.html#the-default-feature). Presupuneți că crate-ul va fi utilizat "
"în livrarea Chromium, dar nu va fi folosit pentru a gestiona intrările "
"nesigure."

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid ""
"(In the next exercise we'll use uwuify from Chromium, but feel free to skip "
"ahead and do that now if you like. Or, you could create a new "
"[`rust_executable` target](https://source.chromium.org/chromium/chromium/src/"
"+/main:build/rust/rust_executable.gni) which uses `uwuify`)."
msgstr ""
"(În următorul exercițiu vom folosi uwuify din Chromium, dar nu ezitați să "
"treceți peste și să faceți asta acum dacă doriți. Sau, puteți crea o nouă "
"țintă [`rust_executable`](https://source.chromium.org/chromium/chromium/src/"
"+/main:build/rust/rust_executable.gni) care utilizează `uwuify`)."

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid "Students will need to download lots of transitive dependencies."
msgstr "Elevii vor trebui să descarce o mulțime de dependențe tranzitive."

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid "The total crates needed are:"
msgstr "Numărul total de lăzi necesare este:"

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid "`instant`,"
msgstr "Constant"

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid "`lock_api`,"
msgstr "`lock_api`,"

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid "`parking_lot`,"
msgstr "`parking_lot`,"

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid "`parking_lot_core`,"
msgstr "`parking_lot_core`,"

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid "`redox_syscall`,"
msgstr "`redox_syscall`,"

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid "`scopeguard`,"
msgstr "`scopeguard`,"

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid "`smallvec`, and"
msgstr "`smallvec`, și"

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid "`uwuify`."
msgstr "`uwuify`."

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid ""
"If students are downloading even more than that, they probably forgot to "
"turn off the default features."
msgstr ""
"Dacă elevii descarcă chiar mai mult decât atât, probabil că au uitat să "
"dezactiveze funcțiile implicite."

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid ""
"Thanks to [Daniel Liu](https://github.com/Daniel-Liu-c0deb0t) for this crate!"
msgstr ""
"Mulțumim lui [Daniel Liu](https://github.com/Daniel-Liu-c0deb0t) pentru "
"această ladă!"

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid "Bringing It Together --- Exercise"
msgstr "Reunind totul - Exercițiu"

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"In this exercise, you're going to add a whole new Chromium feature, bringing "
"together everything you already learned."
msgstr ""
"În acest exercițiu, veți adăuga o funcție Chromium complet nouă, reunind tot "
"ceea ce ați învățat deja."

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid "The Brief from Product Management"
msgstr "Informarea din partea managementului de produs"

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"A community of pixies has been discovered living in a remote rainforest. "
"It's important that we get Chromium for Pixies delivered to them as soon as "
"possible."
msgstr ""
"A fost descoperită o comunitate de zâne care trăiește într-o pădure "
"tropicală izolată. Este important să le livrăm Chromium pentru Pixies cât "
"mai curând posibil."

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"The requirement is to translate all Chromium's UI strings into Pixie "
"language."
msgstr ""
"Cerința este de a traduce toate șirurile interfeței de utilizare a Chromium "
"în limbajul Pixie."

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"There's not time to wait for proper translations, but fortunately pixie "
"language is very close to English, and it turns out there's a Rust crate "
"which does the translation."
msgstr ""
"Nu avem timp să așteptăm traduceri adecvate, dar din fericire, limba pixie "
"este foarte apropiată de limba engleză și se pare că există o casetă Rust "
"care face traducerea."

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"In fact, you already [imported that crate in the previous exercise](https://"
"crates.io/crates/uwuify)."
msgstr ""
"De fapt, ați [importat deja acea ladă în exercițiul anterior](https://crates."
"io/crates/uwuify)."

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"(Obviously, real translations of Chrome require incredible care and "
"diligence. Don't ship this!)"
msgstr ""
"(Evident, traducerile reale ale lui Chrome necesită o atenție și o diligență "
"incredibile. Nu expediați asta!)"

#: src/exercises/chromium/bringing-it-together.md
msgid "Steps"
msgstr "Pași"

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"Modify `ResourceBundle::MaybeMangleLocalizedString` so that it uwuifies all "
"strings before display. In this special build of Chromium, it should always "
"do this irrespective of the setting of `mangle_localized_strings_`."
msgstr ""
"Modifică `ResourceBundle::MaybeMangleLocalizedString` astfel încât să "
"uwuifice toate șirurile înainte de afișare. În această versiune specială a "
"Chromium, ar trebui să facă întotdeauna acest lucru indiferent de setarea "
"lui `mangle_localized_strings_`."

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"If you've done everything right across all these exercises, congratulations, "
"you should have created Chrome for pixies!"
msgstr ""
"Dacă ai făcut totul bine în toate aceste exerciții, felicitări, ar trebui să "
"creezi Chrome pentru pixeli!"

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"UTF16 vs UTF8. Students should be aware that Rust strings are always UTF8, "
"and will probably decide that it's better to do the conversion on the C++ "
"side using `base::UTF16ToUTF8` and back again."
msgstr ""
"UTF16 vs UTF8. Studenții ar trebui să fie conștienți de faptul că șirurile "
"de caractere Rust sunt întotdeauna UTF8 și probabil vor decide că este mai "
"bine să facă conversia pe partea C++ folosind `base::UTF16ToUTF8` și invers."

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"If students decide to do the conversion on the Rust side, they'll need to "
"consider [`String::from_utf16`](https://doc.rust-lang.org/std/string/struct."
"String.html#method.from_utf16), consider error handling, and consider which "
"[CXX supported types can transfer a lot of u16s](https://cxx.rs/binding/"
"slice.html)."
msgstr ""
"Dacă studenții decid să facă conversia pe partea Rust, ei vor trebui să ia "
"în considerare [`String::from_utf16`](https://doc.rust-lang.org/std/string/"
"struct.String.html#method.from_utf16), să ia în considerare gestionarea "
"erorilor și să ia în considerare care dintre tipurile acceptate de [CXX pot "
"transfera o mulțime de u16s](https://cxx.rs/binding/slice.html)."

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"Students may design the C++/Rust boundary in several different ways, e.g. "
"taking and returning strings by value, or taking a mutable reference to a "
"string. If a mutable reference is used, CXX will likely tell the student "
"that they need to use [`Pin`](https://doc.rust-lang.org/std/pin/). You may "
"need to explain what `Pin` does, and then explain why CXX needs it for "
"mutable references to C++ data: the answer is that C++ data can't be moved "
"around like Rust data, because it may contain self-referential pointers."
msgstr ""
"Elevii pot proiecta granița C++/Rust în mai multe moduri diferite, de "
"exemplu, preluarea și returnarea șirurilor de caractere prin valoare sau "
"preluarea unei referințe mutabile la un șir de caractere. În cazul în care "
"se utilizează o referință mutabilă, CXX îi va spune probabil elevului că "
"trebuie să utilizeze [`Pin`](https://doc.rust-lang.org/std/pin/). Este "
"posibil să fie necesar să explicați ce face `Pin` și apoi să explicați de ce "
"CXX are nevoie de el pentru referințele mutabile la datele C++: răspunsul "
"este că datele C++ nu pot fi mutate ca datele Rust, deoarece pot conține "
"pointeri autoreferențiali."

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"The C++ target containing `ResourceBundle::MaybeMangleLocalizedString` will "
"need to depend on a `rust_static_library` target. The student probably "
"already did this."
msgstr ""
"Ținta C++ care conține `ResourceBundle::MaybeMangleLocalizedString` va "
"trebui să depindă de o țintă `rust_static_library`. Probabil că studentul a "
"făcut deja acest lucru."

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid ""
"The `rust_static_library` target will need to depend on `//third_party/rust/"
"uwuify/v0_2:lib`."
msgstr ""
"Ținta `rust_static_library` va trebui să depindă de `//third_party/rust/"
"uwuify/v0_2:lib`."

#: src/exercises/chromium/solutions.md
#, fuzzy
msgid ""
"Solutions to the Chromium exercises can be found in [this series of CLs]"
"(https://chromium-review.googlesource.com/c/chromium/src/+/5096560)."
msgstr ""
"Soluțiile la exercițiile cu Chromium se găsesc în [această serie de CL]"
"(https://chromium-review.googlesource.com/c/chromium/src/+/5096560)."

#: src/bare-metal.md
#, fuzzy
msgid "Welcome to Bare Metal Rust"
msgstr "Bine ați venit la Bare Metal Rust"

#: src/bare-metal.md
#, fuzzy
msgid ""
"This is a standalone one-day course about bare-metal Rust, aimed at people "
"who are familiar with the basics of Rust (perhaps from completing the "
"Comprehensive Rust course), and ideally also have some experience with bare-"
"metal programming in some other language such as C."
msgstr ""
"Acesta este un curs independent de o zi despre Rust, care se adresează "
"persoanelor care sunt familiarizate cu elementele de bază ale Rust (poate în "
"urma absolvirii cursului Comprehensive Rust) și care, în mod ideal, au și o "
"anumită experiență în programarea bare-metal într-un alt limbaj, cum ar fi C."

#: src/bare-metal.md
#, fuzzy
msgid ""
"Today we will talk about 'bare-metal' Rust: running Rust code without an OS "
"underneath us. This will be divided into several parts:"
msgstr ""
"Astăzi vom vorbi despre Rust \"bare-metal\": rularea codului Rust fără un "
"sistem de operare sub noi. Acest subiect va fi împărțit în mai multe părți:"

#: src/bare-metal.md
#, fuzzy
msgid "What is `no_std` Rust?"
msgstr "Ce este `no_std` Rust?"

#: src/bare-metal.md
#, fuzzy
msgid "Writing firmware for microcontrollers."
msgstr "Scrierea de firmware pentru microcontrolere."

#: src/bare-metal.md
#, fuzzy
msgid "Writing bootloader / kernel code for application processors."
msgstr "Scrierea codului bootloader / kernel pentru procesoarele de aplicații."

#: src/bare-metal.md
#, fuzzy
msgid "Some useful crates for bare-metal Rust development."
msgstr "Câteva lădițe utile pentru dezvoltarea Rust pe suport metalic gol."

#: src/bare-metal.md
#, fuzzy
msgid ""
"For the microcontroller part of the course we will use the [BBC micro:bit]"
"(https://microbit.org/) v2 as an example. It's a [development board](https://"
"tech.microbit.org/hardware/) based on the Nordic nRF51822 microcontroller "
"with some LEDs and buttons, an I2C-connected accelerometer and compass, and "
"an on-board SWD debugger."
msgstr ""
"Pentru partea de microcontroler a cursului vom folosi [BBC micro:bit]"
"(https://microbit.org/) v2 ca exemplu. Este o [placă de dezvoltare](https://"
"tech.microbit.org/hardware/) bazată pe microcontrolerul Nordic nRF51822 cu "
"câteva LED-uri și butoane, un accelerometru și o busolă conectate I2C și un "
"depanator SWD la bord."

#: src/bare-metal.md
#, fuzzy
msgid ""
"To get started, install some tools we'll need later. On gLinux or Debian:"
msgstr ""
"Pentru a începe, instalați câteva instrumente de care vom avea nevoie mai "
"târziu. Pe gLinux sau Debian:"

#: src/bare-metal.md
#, fuzzy
msgid ""
"And give users in the `plugdev` group access to the micro:bit programmer:"
msgstr ""
"Și oferiți utilizatorilor din grupul `plugdev` acces la programatorul micro:"
"bit:"

#: src/bare-metal.md src/bare-metal/microcontrollers/debugging.md
#, fuzzy
msgid "On MacOS:"
msgstr "Pe MacOS:"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`core`"
msgstr "`core`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`std`"
msgstr "no_std"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "Slices, `&str`, `CStr`"
msgstr "Slices, `&str`, `CStr`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`NonZeroU8`..."
msgstr "`NonZeroU8`..."

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`Option`, `Result`"
msgstr "`Opțiune`, `Rezultat`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`Display`, `Debug`, `write!`..."
msgstr "`Display`, `Debug`, `write!`..."

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`panic!`, `assert_eq!`..."
msgstr "`panic!`, `assert_eq!`..."

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`NonNull` and all the usual pointer-related functions"
msgstr "`NonNull` și toate funcțiile obișnuite legate de pointer"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`Future` and `async`/`await`"
msgstr "`Future` și `async`/`await`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`fence`, `AtomicBool`, `AtomicPtr`, `AtomicU32`..."
msgstr "`fence`, `AtomicBool`, `AtomicPtr`, `AtomicU32`..."

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`Duration`"
msgstr "`Durată`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`Box`, `Cow`, `Arc`, `Rc`"
msgstr "`Box`, `Cow`, `Arc`, `Rc`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`Vec`, `BinaryHeap`, `BtreeMap`, `LinkedList`, `VecDeque`"
msgstr "`Vec`, `BinaryHeap`, `BtreeMap`, `LinkedList`, `VecDeque`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`String`, `CString`, `format!`"
msgstr "`String`, `CString`, `format!`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`Error`"
msgstr "[Gestionarea erorilor](../error-handling.md) (45 minute)"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`Mutex`, `Condvar`, `Barrier`, `Once`, `RwLock`, `mpsc`"
msgstr "`Mutex`, `Condvar`, `Barrier`, `Once`, `RwLock`, `mpsc`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`File` and the rest of `fs`"
msgstr "`File` și restul de `fs`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`println!`, `Read`, `Write`, `Stdin`, `Stdout` and the rest of `io`"
msgstr "`println!`, `Read`, `Write`, `Stdin`, `Stdout` și restul de `io`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`Path`, `OsString`"
msgstr "`Path`, `OsString`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`net`"
msgstr "`net`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`Command`, `Child`, `ExitCode`"
msgstr "`Command`, `Child`, `ExitCode`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`spawn`, `sleep` and the rest of `thread`"
msgstr "`spawn`, `sleep` și restul de `thread`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`SystemTime`, `Instant`"
msgstr "`SystemTime`, `Instant`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`HashMap` depends on RNG."
msgstr "`HashMap` depinde de RNG."

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`std` re-exports the contents of both `core` and `alloc`."
msgstr "`std` reexportă conținutul atât al lui `core` cât și al lui `alloc`."

#: src/bare-metal/minimal.md
#, fuzzy
msgid "A minimal `no_std` program"
msgstr "Un program minimal `no_std`"

#: src/bare-metal/minimal.md
#, fuzzy
msgid "This will compile to an empty binary."
msgstr "Aceasta va compila un binar gol."

#: src/bare-metal/minimal.md
#, fuzzy
msgid "`std` provides a panic handler; without it we must provide our own."
msgstr ""
"`std` oferă un gestionar de panică; în lipsa acestuia, trebuie să ne "
"furnizăm propriul gestionar."

#: src/bare-metal/minimal.md
#, fuzzy
msgid "It can also be provided by another crate, such as `panic-halt`."
msgstr "Acesta poate fi furnizat și de o altă ladă, cum ar fi `panic-halt`."

#: src/bare-metal/minimal.md
#, fuzzy
msgid ""
"Depending on the target, you may need to compile with `panic = \"abort\"` to "
"avoid an error about `eh_personality`."
msgstr ""
"În funcție de țintă, este posibil să fie nevoie să compilați cu `panic = "
"\"abort\"` pentru a evita o eroare cu privire la `eh_personality`."

#: src/bare-metal/minimal.md
#, fuzzy
msgid ""
"Note that there is no `main` or any other entry point; it's up to you to "
"define your own entry point. This will typically involve a linker script and "
"some assembly code to set things up ready for Rust code to run."
msgstr ""
"Rețineți că nu există niciun `main` sau alt punct de intrare; depinde de "
"dumneavoastră să vă definiți propriul punct de intrare. Acest lucru va "
"implica, de obicei, un script de linker și ceva cod de asamblare pentru a "
"pregăti lucrurile pentru a permite rularea codului Rust."

#: src/bare-metal/alloc.md
#, fuzzy
msgid ""
"To use `alloc` you must implement a [global (heap) allocator](https://doc."
"rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html)."
msgstr ""
"Pentru a utiliza `alloc` trebuie să implementați un [alocator global (heap)]"
"(https://doc.rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html)."

#: src/bare-metal/alloc.md
#, fuzzy
msgid "// SAFETY: `HEAP` is only used here and `entry` is only called once.\n"
msgstr ""
"// Sigur, deoarece `HEAP` este folosit doar aici și `entry` este apelat doar "
"o singură dată.\n"

#: src/bare-metal/alloc.md
#, fuzzy
msgid "// Give the allocator some memory to allocate.\n"
msgstr "// Dați alocatorului o anumită memorie de alocat.\n"

#: src/bare-metal/alloc.md
#, fuzzy
msgid "// Now we can do things that require heap allocation.\n"
msgstr "// Acum putem face lucruri care necesită alocare de heap.\n"

#: src/bare-metal/alloc.md
#, fuzzy
msgid "\"A string\""
msgstr "Șir"

#: src/bare-metal/alloc.md
#, fuzzy
msgid ""
"`buddy_system_allocator` is a third-party crate implementing a basic buddy "
"system allocator. Other crates are available, or you can write your own or "
"hook into your existing allocator."
msgstr ""
"`buddy_system_allocator` este un crate terț care implementează un alocator "
"de bază pentru sistemul de prieteni. Sunt disponibile și alte crates, sau "
"puteți să vă scrieți propriul alocator sau să vă conectați la alocatorul "
"existent."

#: src/bare-metal/alloc.md
#, fuzzy
msgid ""
"The const parameter of `LockedHeap` is the max order of the allocator; i.e. "
"in this case it can allocate regions of up to 2\\*\\*32 bytes."
msgstr ""
"Parametrul const al `LockedHeap` este ordinea maximă a alocatorului; adică, "
"în acest caz, acesta poate aloca regiuni de până la 2\\*\\*32 octeți."

#: src/bare-metal/alloc.md
#, fuzzy
msgid ""
"If any crate in your dependency tree depends on `alloc` then you must have "
"exactly one global allocator defined in your binary. Usually this is done in "
"the top-level binary crate."
msgstr ""
"Dacă orice crate din arborele de dependență depinde de `alloc`, atunci "
"trebuie să aveți exact un alocator global definit în binarul dumneavoastră. "
"De obicei, acest lucru se face în crate-ul binar de nivel superior."

#: src/bare-metal/alloc.md
#, fuzzy
msgid ""
"`extern crate panic_halt as _` is necessary to ensure that the `panic_halt` "
"crate is linked in so we get its panic handler."
msgstr ""
"`extern crate panic_halt as _` este necesar pentru a ne asigura că crate-ul "
"`panic_halt` este legat, astfel încât să obținem gestionarul de panică al "
"acestuia."

#: src/bare-metal/alloc.md
#, fuzzy
msgid "This example will build but not run, as it doesn't have an entry point."
msgstr ""
"Acest exemplu va fi construit, dar nu va fi executat, deoarece nu are un "
"punct de intrare."

#: src/bare-metal/microcontrollers.md
#, fuzzy
msgid ""
"The `cortex_m_rt` crate provides (among other things) a reset handler for "
"Cortex M microcontrollers."
msgstr ""
"Crate `cortex_m_rt` oferă (printre altele) un gestionar de resetare pentru "
"microcontrolerele Cortex M."

#: src/bare-metal/microcontrollers.md
#, fuzzy
msgid ""
"Next we'll look at how to access peripherals, with increasing levels of "
"abstraction."
msgstr ""
"În continuare, vom examina modul de accesare a perifericelor, cu niveluri de "
"abstractizare din ce în ce mai mari."

#: src/bare-metal/microcontrollers.md
#, fuzzy
msgid ""
"The `cortex_m_rt::entry` macro requires that the function have type `fn() -"
"> !`, because returning to the reset handler doesn't make sense."
msgstr ""
"Macroul `cortex_m_rt::entry` necesită ca funcția să aibă tipul `fn() -> !`, "
"deoarece întoarcerea la gestionarul de resetare nu are sens."

#: src/bare-metal/microcontrollers.md
#, fuzzy
msgid "Run the example with `cargo embed --bin minimal`"
msgstr "Rulați exemplul cu `cargo embed --bin minimal`"

#: src/bare-metal/microcontrollers/mmio.md
#, fuzzy
msgid ""
"Most microcontrollers access peripherals via memory-mapped IO. Let's try "
"turning on an LED on our micro:bit:"
msgstr ""
"Majoritatea microcontrolerelor accesează perifericele prin intermediul IO "
"mapate în memorie. Să încercăm să aprindem un LED pe micro:bit-ul nostru:"

#: src/bare-metal/microcontrollers/mmio.md
#, fuzzy
msgid "/// GPIO port 0 peripheral address\n"
msgstr "/// Adresa periferică a portului GPIO 0\n"

#: src/bare-metal/microcontrollers/mmio.md
#, fuzzy
msgid "// GPIO peripheral offsets\n"
msgstr "// Decalajele perifericelor GPIO\n"

#: src/bare-metal/microcontrollers/mmio.md
#, fuzzy
msgid "// PIN_CNF fields\n"
msgstr "// Câmpurile PIN_CNF\n"

#: src/bare-metal/microcontrollers/mmio.md
#: src/bare-metal/microcontrollers/pacs.md
#: src/bare-metal/microcontrollers/hals.md
#, fuzzy
msgid "// Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
msgstr "// Configurați pinii GPIO 0 21 și 28 ca ieșiri push-pull.\n"

#: src/bare-metal/microcontrollers/mmio.md
#, fuzzy
msgid ""
"// SAFETY: The pointers are to valid peripheral control registers, and no\n"
"    // aliases exist.\n"
msgstr ""
"// Sigur, deoarece indicatorii sunt la registrele de control periferic "
"valide, și\n"
"    // nu există alias-uri.\n"

#: src/bare-metal/microcontrollers/mmio.md
#: src/bare-metal/microcontrollers/pacs.md
#: src/bare-metal/microcontrollers/hals.md
#, fuzzy
msgid "// Set pin 28 low and pin 21 high to turn the LED on.\n"
msgstr ""
"// Setați pinul 28 la nivel scăzut și pinul 21 la nivel ridicat pentru a "
"aprinde LED-ul.\n"

#: src/bare-metal/microcontrollers/mmio.md
#, fuzzy
msgid ""
"GPIO 0 pin 21 is connected to the first column of the LED matrix, and pin 28 "
"to the first row."
msgstr ""
"Pinul 21 al GPIO 0 este conectat la prima coloană a matricei de LED-uri, iar "
"pinul 28 la primul rând."

#: src/bare-metal/microcontrollers/mmio.md
#: src/bare-metal/microcontrollers/pacs.md
#: src/bare-metal/microcontrollers/hals.md
#: src/bare-metal/microcontrollers/board-support.md
#, fuzzy
msgid "Run the example with:"
msgstr "Rulați exemplul cu:"

#: src/bare-metal/microcontrollers/pacs.md
#, fuzzy
msgid "Peripheral Access Crates"
msgstr "Lăzi de acces periferic"

#: src/bare-metal/microcontrollers/pacs.md
#, fuzzy
msgid ""
"[`svd2rust`](https://crates.io/crates/svd2rust) generates mostly-safe Rust "
"wrappers for memory-mapped peripherals from [CMSIS-SVD](https://www.keil.com/"
"pack/doc/CMSIS/SVD/html/index.html) files."
msgstr ""
"[`svd2rust`](https://crates.io/crates/svd2rust) generează învelișuri Rust în "
"mare parte sigure pentru perifericele cu memorie mapă din fișierele [CMSIS-"
"SVD](https://www.keil.com/pack/doc/CMSIS/SVD/html/index.html)."

#: src/bare-metal/microcontrollers/pacs.md
#, fuzzy
msgid ""
"SVD (System View Description) files are XML files typically provided by "
"silicon vendors which describe the memory map of the device."
msgstr ""
"Fișierele SVD (System View Description) sunt fișiere XML furnizate de obicei "
"de furnizorii de siliciu care descriu harta de memorie a dispozitivului."

#: src/bare-metal/microcontrollers/pacs.md
#, fuzzy
msgid ""
"They are organised by peripheral, register, field and value, with names, "
"descriptions, addresses and so on."
msgstr ""
"Acestea sunt organizate în funcție de periferic, registru, câmp și valoare, "
"cu nume, descrieri, adrese etc."

#: src/bare-metal/microcontrollers/pacs.md
#, fuzzy
msgid ""
"SVD files are often buggy and incomplete, so there are various projects "
"which patch the mistakes, add missing details, and publish the generated "
"crates."
msgstr ""
"Fișierele SVD sunt deseori eronate și incomplete, așa că există diverse "
"proiecte care corectează greșelile, adaugă detaliile lipsă și publică "
"lădițele generate."

#: src/bare-metal/microcontrollers/pacs.md
#, fuzzy
msgid "`cortex-m-rt` provides the vector table, among other things."
msgstr "`cortex-m-rt` furnizează, printre altele, tabelul vectorial."

#: src/bare-metal/microcontrollers/pacs.md
#, fuzzy
msgid ""
"If you `cargo install cargo-binutils` then you can run `cargo objdump --bin "
"pac -- -d --no-show-raw-insn` to see the resulting binary."
msgstr ""
"Dacă instalați `cargo install cargo-binutils` atunci puteți rula `cargo "
"objdump --bin pac -- -d --no-show-raw-insn` pentru a vedea binarul rezultat."

#: src/bare-metal/microcontrollers/hals.md
#, fuzzy
msgid "HAL crates"
msgstr "Lăzi (crates) HAL"

#: src/bare-metal/microcontrollers/hals.md
#, fuzzy
msgid ""
"[HAL crates](https://github.com/rust-embedded/awesome-embedded-rust#hal-"
"implementation-crates) for many microcontrollers provide wrappers around "
"various peripherals. These generally implement traits from [`embedded-hal`]"
"(https://crates.io/crates/embedded-hal)."
msgstr ""
"[HAL crates](https://github.com/rust-embedded/awesome-embedded-rust#hal-"
"implementation-crates) pentru multe microcontrolere oferă învelișuri în "
"jurul diferitelor periferice. Acestea implementează în general trăsături din "
"[`embedded-hal`](https://crates.io/crates/embedded-hal)."

#: src/bare-metal/microcontrollers/hals.md
#, fuzzy
msgid "// Create HAL wrapper for GPIO port 0.\n"
msgstr "// Creați un înveliș HAL pentru portul GPIO 0.\n"

#: src/bare-metal/microcontrollers/hals.md
#, fuzzy
msgid ""
"`set_low` and `set_high` are methods on the `embedded_hal` `OutputPin` trait."
msgstr ""
"`set_low` și `set_high` sunt metode ale trăsăturii `OutputPin` "
"`embedded_hal`."

#: src/bare-metal/microcontrollers/hals.md
#, fuzzy
msgid ""
"HAL crates exist for many Cortex-M and RISC-V devices, including various "
"STM32, GD32, nRF, NXP, MSP430, AVR and PIC microcontrollers."
msgstr ""
"HAL crates există pentru multe dispozitive Cortex-M și RISC-V, inclusiv "
"pentru diverse microcontrolere STM32, GD32, nRF, NXP, MSP430, AVR și PIC."

#: src/bare-metal/microcontrollers/board-support.md
#, fuzzy
msgid "Board support crates"
msgstr "Crates cu suport pentru plăci"

#: src/bare-metal/microcontrollers/board-support.md
#, fuzzy
msgid ""
"Board support crates provide a further level of wrapping for a specific "
"board for convenience."
msgstr ""
"Lăzile de susținere a plăcilor oferă un nivel suplimentar de împachetare "
"pentru o anumită placă, pentru mai multă comoditate."

#: src/bare-metal/microcontrollers/board-support.md
#, fuzzy
msgid ""
"In this case the board support crate is just providing more useful names, "
"and a bit of initialisation."
msgstr ""
"În acest caz, suportul pentru plăci oferă doar nume mai utile și o mică "
"inițializare."

#: src/bare-metal/microcontrollers/board-support.md
#, fuzzy
msgid ""
"The crate may also include drivers for some on-board devices outside of the "
"microcontroller itself."
msgstr ""
"De asemenea, pachetul poate include drivere pentru unele dispozitive de la "
"bord în afara microcontrolerului propriu-zis."

#: src/bare-metal/microcontrollers/board-support.md
#, fuzzy
msgid "`microbit-v2` includes a simple driver for the LED matrix."
msgstr "`microbit-v2` include un driver simplu pentru matricea de LED-uri."

#: src/bare-metal/microcontrollers/type-state.md
#, fuzzy
msgid "The type state pattern"
msgstr "Modelul de stare de tip"

#: src/bare-metal/microcontrollers/type-state.md
#, fuzzy
msgid "// let gpio0_01_again = gpio0.p0_01; // Error, moved.\n"
msgstr "// let gpio0_01_again = gpio0.p0_01; // Eroare, mutat.\n"

#: src/bare-metal/microcontrollers/type-state.md
#, fuzzy
msgid "// pin_input.is_high(); // Error, moved.\n"
msgstr "// pin_input.is_high(); // Eroare, mutat.\n"

#: src/bare-metal/microcontrollers/type-state.md
#, fuzzy
msgid ""
"Pins don't implement `Copy` or `Clone`, so only one instance of each can "
"exist. Once a pin is moved out of the port struct nobody else can take it."
msgstr ""
"Pinii nu implementează `Copy` sau `Clone`, astfel încât poate exista doar o "
"singură instanță a fiecăruia. Odată ce un pin este mutat din structura "
"portului, nimeni altcineva nu îl poate lua."

#: src/bare-metal/microcontrollers/type-state.md
#, fuzzy
msgid ""
"Changing the configuration of a pin consumes the old pin instance, so you "
"can't keep use the old instance afterwards."
msgstr ""
"Schimbarea configurației unui pin consumă vechea instanță de pin, astfel "
"încât nu mai puteți continua să folosiți vechea instanță după aceea."

#: src/bare-metal/microcontrollers/type-state.md
#, fuzzy
msgid ""
"The type of a value indicates the state that it is in: e.g. in this case, "
"the configuration state of a GPIO pin. This encodes the state machine into "
"the type system, and ensures that you don't try to use a pin in a certain "
"way without properly configuring it first. Illegal state transitions are "
"caught at compile time."
msgstr ""
"Tipul unei valori indică starea în care se află aceasta: de exemplu, în "
"acest caz, starea de configurare a unui pin GPIO. Acest lucru codifică "
"mașina de stare în sistemul de tipuri și garantează că nu încercați să "
"utilizați un pin într-un anumit mod fără să-l configurați mai întâi în mod "
"corespunzător. Tranzițiile de stare ilegale sunt detectate în momentul "
"compilării."

#: src/bare-metal/microcontrollers/type-state.md
#, fuzzy
msgid ""
"You can call `is_high` on an input pin and `set_high` on an output pin, but "
"not vice-versa."
msgstr ""
"Puteți apela `is_high` pe un pin de intrare și `set_high` pe un pin de "
"ieșire, dar nu și invers."

#: src/bare-metal/microcontrollers/type-state.md
#, fuzzy
msgid "Many HAL crates follow this pattern."
msgstr "Multe lăzi HAL urmează acest model."

#: src/bare-metal/microcontrollers/embedded-hal.md
#, fuzzy
msgid ""
"The [`embedded-hal`](https://crates.io/crates/embedded-hal) crate provides a "
"number of traits covering common microcontroller peripherals:"
msgstr ""
"Crăiasa [`embedded-hal`](https://crates.io/crates/embedded-hal) oferă o "
"serie de caracteristici care acoperă perifericele comune ale "
"microcontrolerului."

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid "GPIO"
msgstr "GPIO"

#: src/bare-metal/microcontrollers/embedded-hal.md
#, fuzzy
msgid "PWM"
msgstr "PWM"

#: src/bare-metal/microcontrollers/embedded-hal.md
#, fuzzy
msgid "Delay timers"
msgstr "Temporizatoare cu întârziere"

#: src/bare-metal/microcontrollers/embedded-hal.md
#, fuzzy
msgid "I2C and SPI buses and devices"
msgstr "Busuri și dispozitive I2C și SPI"

#: src/bare-metal/microcontrollers/embedded-hal.md
#, fuzzy
msgid ""
"Similar traits for byte streams (e.g. UARTs), CAN buses and RNGs and broken "
"out into [`embedded-io`](https://crates.io/crates/embedded-io), [`embedded-"
"can`](https://crates.io/crates/embedded-can) and [`rand_core`](https://"
"crates.io/crates/rand_core) respectively."
msgstr ""
"Trăsături similare pentru fluxurile de octeți (de exemplu, UART), "
"magistralele CAN și RNG-uri și împărțite în [`embedded-io`](https://crates."
"io/crates/embedded-io), [`embedded-can`](https://crates.io/crates/embedded-"
"can) și, respectiv, [`rand_core`](https://crates.io/crates/rand_core)."

#: src/bare-metal/microcontrollers/embedded-hal.md
#, fuzzy
msgid ""
"Other crates then implement [drivers](https://github.com/rust-embedded/"
"awesome-embedded-rust#driver-crates) in terms of these traits, e.g. an "
"accelerometer driver might need an I2C or SPI device instance."
msgstr ""
"Alte crates implementează apoi [drivere](https://github.com/rust-embedded/"
"awesome-embedded-rust#driver-crates) în funcție de aceste caracteristici, de "
"exemplu, un driver pentru accelerometru poate avea nevoie de o implementare "
"a bus-ului I2C sau SPI."

#: src/bare-metal/microcontrollers/embedded-hal.md
#, fuzzy
msgid ""
"The traits cover using the peripherals but not initialising or configuring "
"them, as initialisation and configuration is usually highly platform-"
"specific."
msgstr ""
"Trăsăturile se referă la utilizarea perifericelor, dar nu la inițializarea "
"sau configurarea acestora, deoarece inițializarea și configurarea sunt de "
"obicei foarte specifice platformei."

#: src/bare-metal/microcontrollers/embedded-hal.md
#, fuzzy
msgid ""
"There are implementations for many microcontrollers, as well as other "
"platforms such as Linux on Raspberry Pi."
msgstr ""
"Există implementări pentru multe microcontrolere, precum și pentru alte "
"platforme, cum ar fi Linux pe Raspberry Pi."

#: src/bare-metal/microcontrollers/embedded-hal.md
#, fuzzy
msgid ""
"[`embedded-hal-async`](https://crates.io/crates/embedded-hal-async) provides "
"async versions of the traits."
msgstr ""
"Crăiasa [`embedded-hal`](https://crates.io/crates/embedded-hal) oferă o "
"serie de caracteristici care acoperă perifericele comune ale "
"microcontrolerului."

#: src/bare-metal/microcontrollers/embedded-hal.md
#, fuzzy
msgid ""
"[`embedded-hal-nb`](https://crates.io/crates/embedded-hal-nb) provides "
"another approach to non-blocking I/O, based on the [`nb`](https://crates.io/"
"crates/nb) crate."
msgstr ""
"Crăiasa [`embedded-hal`](https://crates.io/crates/embedded-hal) oferă o "
"serie de caracteristici care acoperă perifericele comune ale "
"microcontrolerului."

#: src/bare-metal/microcontrollers/probe-rs.md
#, fuzzy
msgid ""
"[probe-rs](https://probe.rs/) is a handy toolset for embedded debugging, "
"like OpenOCD but better integrated."
msgstr ""
"[probe-rs](https://probe.rs/) este un set de instrumente utile pentru "
"depanarea embedded, precum OpenOCD, dar mai bine integrat."

#: src/bare-metal/microcontrollers/probe-rs.md
#, fuzzy
msgid ""
"SWD (Serial Wire Debug) and JTAG via CMSIS-DAP, ST-Link and J-Link probes"
msgstr ""
"SWD (Serial Wire Debug) și JTAG prin sonde CMSIS-DAP, ST-Link și J-Link"

#: src/bare-metal/microcontrollers/probe-rs.md
#, fuzzy
msgid "GDB stub and Microsoft DAP (Debug Adapter Protocol) server"
msgstr "GDB stub și serverul Microsoft DAP (Debug Adapter Protocol)"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid "Cargo integration"
msgstr "Integrarea Cargo"

#: src/bare-metal/microcontrollers/probe-rs.md
#, fuzzy
msgid ""
"`cargo-embed` is a cargo subcommand to build and flash binaries, log RTT "
"(Real Time Transfers) output and connect GDB. It's configured by an `Embed."
"toml` file in your project directory."
msgstr ""
"`cargo-embed` este o subcomandă cargo pentru a construi și afișa binare, a "
"înregistra ieșirea RTT (Real Time Transfers) și a conecta GDB. Este "
"configurată de un fișier `Embed.toml` din directorul proiectului "
"dumneavoastră."

#: src/bare-metal/microcontrollers/probe-rs.md
#, fuzzy
msgid ""
"[CMSIS-DAP](https://arm-software.github.io/CMSIS_5/DAP/html/index.html) is "
"an Arm standard protocol over USB for an in-circuit debugger to access the "
"CoreSight Debug Access Port of various Arm Cortex processors. It's what the "
"on-board debugger on the BBC micro:bit uses."
msgstr ""
"[CMSIS-DAP](https://arm-software.github.io/CMSIS_5/DAP/html/index.html) este "
"un protocol standard Arm prin USB pentru ca un depanator in-circuit să "
"acceseze portul de acces la depanare CoreSight al diferitelor procesoare Arm "
"Cortex. Este ceea ce folosește depanatorul de bord de pe BBC micro:bit."

#: src/bare-metal/microcontrollers/probe-rs.md
#, fuzzy
msgid ""
"ST-Link is a range of in-circuit debuggers from ST Microelectronics, J-Link "
"is a range from SEGGER."
msgstr ""
"ST-Link este o gamă de depanatoare în circuit de la ST Microelectronics, iar "
"J-Link este o gamă de la SEGGER."

#: src/bare-metal/microcontrollers/probe-rs.md
#, fuzzy
msgid ""
"The Debug Access Port is usually either a 5-pin JTAG interface or 2-pin "
"Serial Wire Debug."
msgstr ""
"Portul de acces pentru depanare este, de obicei, fie o interfață JTAG cu 5 "
"pini, fie o interfață de depanare prin cablu serial cu 2 pini."

#: src/bare-metal/microcontrollers/probe-rs.md
#, fuzzy
msgid ""
"probe-rs is a library which you can integrate into your own tools if you "
"want to."
msgstr ""
"probe-rs este o bibliotecă pe care o puteți integra în propriile "
"instrumente, dacă doriți."

#: src/bare-metal/microcontrollers/probe-rs.md
#, fuzzy
msgid ""
"The [Microsoft Debug Adapter Protocol](https://microsoft.github.io/debug-"
"adapter-protocol/) lets VSCode and other IDEs debug code running on any "
"supported microcontroller."
msgstr ""
"[Microsoft Debug Adapter Protocol](https://microsoft.github.io/debug-adapter-"
"protocol/) permite VSCode și altor IDE-uri să depaneze codul care rulează pe "
"orice microcontroler acceptat."

#: src/bare-metal/microcontrollers/probe-rs.md
#, fuzzy
msgid "cargo-embed is a binary built using the probe-rs library."
msgstr "cargo-embed este un binar construit folosind biblioteca probe-rs."

#: src/bare-metal/microcontrollers/probe-rs.md
#, fuzzy
msgid ""
"RTT (Real Time Transfers) is a mechanism to transfer data between the debug "
"host and the target through a number of ringbuffers."
msgstr ""
"RTT (Real Time Transfers) este un mecanism de transfer de date între gazda "
"de depanare și țintă prin intermediul unui număr de ringbufferi."

#: src/bare-metal/microcontrollers/debugging.md
#, fuzzy
msgid "_Embed.toml_:"
msgstr "_Embed.toml_:"

#: src/bare-metal/microcontrollers/debugging.md
#, fuzzy
msgid "In one terminal under `src/bare-metal/microcontrollers/examples/`:"
msgstr "Într-un terminal, sub `src/bare-metal/microcontrollers/examples/`:"

#: src/bare-metal/microcontrollers/debugging.md
#, fuzzy
msgid "In another terminal in the same directory:"
msgstr "Într-un alt terminal din același director:"

#: src/bare-metal/microcontrollers/debugging.md
#, fuzzy
msgid "On gLinux or Debian:"
msgstr "Pe gLinux sau Debian:"

#: src/bare-metal/microcontrollers/debugging.md
#, fuzzy
msgid "In GDB, try running:"
msgstr "În GDB, încercați să rulați:"

#: src/bare-metal/microcontrollers/other-projects.md
#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid "Other projects"
msgstr "Alte proiecte"

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid "[RTIC](https://rtic.rs/)"
msgstr "[RTIC](https://rtic.rs/)"

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid "\"Real-Time Interrupt-driven Concurrency\""
msgstr "\"Concurrența în timp real bazată pe întreruperi\""

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid ""
"Shared resource management, message passing, task scheduling, timer queue"
msgstr ""
"Gestionarea resurselor partajate, trecerea mesajelor, programarea "
"sarcinilor, coada de timp"

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid "[Embassy](https://embassy.dev/)"
msgstr "[Ambasada](https://embassy.dev/)"

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid "`async` executors with priorities, timers, networking, USB"
msgstr "executori `async` cu priorități, cronometre, rețea, USB"

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid "[TockOS](https://www.tockos.org/documentation/getting-started)"
msgstr "[TockOS](https://www.tockos.org/documentation/getting-started)"

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid ""
"Security-focused RTOS with preemptive scheduling and Memory Protection Unit "
"support"
msgstr ""
"RTOS axat pe securitate, cu programare preemptivă și suport pentru unitatea "
"de protecție a memoriei"

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid "[Hubris](https://hubris.oxide.computer/)"
msgstr "[Hubris](https://hubris.oxide.computer/)"

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid ""
"Microkernel RTOS from Oxide Computer Company with memory protection, "
"unprivileged drivers, IPC"
msgstr ""
"Microkernel RTOS de la Oxide Computer Company cu protecție de memorie, "
"drivere neprivilegiate, IPC"

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid "[Bindings for FreeRTOS](https://github.com/lobaro/FreeRTOS-rust)"
msgstr "[Legături pentru FreeRTOS](https://github.com/lobaro/FreeRTOS-rust)"

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid ""
"Some platforms have `std` implementations, e.g. [esp-idf](https://esp-rs."
"github.io/book/overview/using-the-standard-library.html)."
msgstr ""
"Unele platforme au implementări `std`, de exemplu [esp-idf](https://esp-rs."
"github.io/book/overview/using-the-standard-library.html)."

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid "RTIC can be considered either an RTOS or a concurrency framework."
msgstr "RTIC poate fi considerat fie un RTOS, fie un cadru de concurență."

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid "It doesn't include any HALs."
msgstr "Nu include niciun HAL."

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid ""
"It uses the Cortex-M NVIC (Nested Virtual Interrupt Controller) for "
"scheduling rather than a proper kernel."
msgstr ""
"Acesta utilizează Cortex-M NVIC (Nested Virtual Interrupt Controller) pentru "
"programare, în loc de un kernel propriu-zis."

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid "Cortex-M only."
msgstr "Numai Cortex-M."

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid ""
"Google uses TockOS on the Haven microcontroller for Titan security keys."
msgstr ""
"Google folosește TockOS pe microcontrolerul Haven pentru cheile de "
"securitate Titan."

#: src/bare-metal/microcontrollers/other-projects.md
#, fuzzy
msgid ""
"FreeRTOS is mostly written in C, but there are Rust bindings for writing "
"applications."
msgstr ""
"FreeRTOS este scris în mare parte în C, dar există legături Rust pentru "
"scrierea de aplicații."

#: src/exercises/bare-metal/morning.md
#, fuzzy
msgid ""
"We will read the direction from an I2C compass, and log the readings to a "
"serial port."
msgstr ""
"Vom citi direcția de la o busolă I2C și vom înregistra citirile pe un port "
"serial."

#: src/exercises/bare-metal/morning.md
msgid ""
"After looking at the exercises, you can look at the [solutions](solutions-"
"morning.md) provided."
msgstr ""
"După ce ați studiat exercițiile, puteți consulta [soluțile](solutions-"
"morning.md) furnizate."

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid ""
"We will read the direction from an I2C compass, and log the readings to a "
"serial port. If you have time, try displaying it on the LEDs somehow too, or "
"use the buttons somehow."
msgstr ""
"Vom citi direcția de la o busolă I2C și vom înregistra citirile pe un port "
"serial. Dacă aveți timp, încercați să o afișați cumva și pe LED-uri sau să "
"folosiți cumva butoanele."

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid "Hints:"
msgstr "Sugestii:"

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid ""
"Check the documentation for the [`lsm303agr`](https://docs.rs/lsm303agr/"
"latest/lsm303agr/) and [`microbit-v2`](https://docs.rs/microbit-v2/latest/"
"microbit/) crates, as well as the [micro:bit hardware](https://tech.microbit."
"org/hardware/)."
msgstr ""
"Consultați documentația pentru pachetele [`lsm303agr`](https://docs.rs/"
"lsm303agr/latest/lsm303agr/) și [`microbit-v2`](https://docs.rs/microbit-v2/"
"latest/microbit/), precum și pentru [micro:bit hardware](https://tech."
"microbit.org/hardware/)."

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid ""
"The LSM303AGR Inertial Measurement Unit is connected to the internal I2C bus."
msgstr ""
"Unitatea de măsurare inerțială LSM303AGR este conectată la magistrala "
"internă I2C."

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid ""
"TWI is another name for I2C, so the I2C master peripheral is called TWIM."
msgstr ""
"TWI este un alt nume pentru I2C, astfel încât perifericul master I2C se "
"numește TWIM."

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid ""
"The LSM303AGR driver needs something implementing the `embedded_hal::"
"blocking::i2c::WriteRead` trait. The [`microbit::hal::Twim`](https://docs.rs/"
"microbit-v2/latest/microbit/hal/struct.Twim.html) struct implements this."
msgstr ""
"Driverul LSM303AGR are nevoie de ceva care să implementeze trăsătura "
"`embedded_hal::blocking::i2c::WriteRead`. Structura [`microbit::hal::Twim`]"
"(https://docs.rs/microbit-v2/latest/microbit/hal/struct.Twim.html) "
"implementează acest lucru."

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid ""
"You have a [`microbit::Board`](https://docs.rs/microbit-v2/latest/microbit/"
"struct.Board.html) struct with fields for the various pins and peripherals."
msgstr ""
"Aveți o structură [`microbit::Board`](https://docs.rs/microbit-v2/latest/"
"microbit/struct.Board.html) cu câmpuri pentru diverși pini și periferice."

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid ""
"You can also look at the [nRF52833 datasheet](https://infocenter.nordicsemi."
"com/pdf/nRF52833_PS_v1.5.pdf) if you want, but it shouldn't be necessary for "
"this exercise."
msgstr ""
"Dacă doriți, puteți consulta și [nRF52833 datasheet](https://infocenter."
"nordicsemi.com/pdf/nRF52833_PS_v1.5.pdf), dar nu ar trebui să fie necesar "
"pentru acest exercițiu."

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and "
"look in the `compass` directory for the following files."
msgstr ""
"Descărcați [șablonul de exerciții] (../../comprehensive-rust-exercises.zip) "
"și căutați în directorul `compass` următoarele fișiere."

#: src/exercises/bare-metal/compass.md src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "_src/main.rs_:"
msgstr "src/main.rs_:"

#: src/exercises/bare-metal/compass.md src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "_Cargo.toml_ (you shouldn't need to change this):"
msgstr "_Cargo.toml_ (nu ar trebui să fie nevoie să modificați acest lucru):"

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid "_Embed.toml_ (you shouldn't need to change this):"
msgstr "_Embed.toml_ (nu ar trebui să fie nevoie să modificați acest lucru):"

#: src/exercises/bare-metal/compass.md src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "_.cargo/config.toml_ (you shouldn't need to change this):"
msgstr ""
"_.cargo/config.toml_ (nu ar trebui să fie nevoie să modificați acest lucru):"

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid "See the serial output on Linux with:"
msgstr "Vedeți ieșirea serială pe Linux cu:"

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid ""
"Or on Mac OS something like (the device name may be slightly different):"
msgstr ""
"Sau, pe Mac OS, ceva de genul (numele dispozitivului poate fi ușor diferit):"

#: src/exercises/bare-metal/compass.md
#, fuzzy
msgid "Use Ctrl+A Ctrl+Q to quit picocom."
msgstr "Folosiți Ctrl+A Ctrl+Q pentru a ieși din picocom."

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid "Bare Metal Rust Morning Exercise"
msgstr "Exercițiu de dimineață Bare Metal Rust"

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid "([back to exercise](compass.md))"
msgstr "([back to exercise](compass.md))"

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid "// Configure serial port.\n"
msgstr "// Configurați portul serial.\n"

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid "// Use the system timer as a delay provider.\n"
msgstr "// Utilizați temporizatorul sistemului ca furnizor de întârzieri.\n"

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid "// Set up the I2C controller and Inertial Measurement Unit.\n"
msgstr "// Configurați controlerul I2C și unitatea de măsurare inerțială.\n"

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid "\"Setting up IMU...\""
msgstr "\"Configurarea IMU...\""

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid "// Set up display and timer.\n"
msgstr "// Configurați afișajul și cronometrul.\n"

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid "\"Ready.\""
msgstr "\"Gata.\""

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid "// Read compass data and log it to the serial port.\n"
msgstr "// Citiți datele busolei și înregistrați-le pe portul serial.\n"

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid "\"{},{},{}\\t{},{},{}\""
msgstr "Partiții: `&[T]`"

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid ""
"// If button A is pressed, switch to the next mode and briefly blink all "
"LEDs\n"
"        // on.\n"
msgstr ""
"// Dacă este apăsat butonul A, se trece la modul următor și clipesc pentru "
"scurt timp toate LED-urile\n"
"        // pornit.\n"

#: src/bare-metal/aps.md
#, fuzzy
msgid "Application processors"
msgstr "Procesatori de aplicații"

#: src/bare-metal/aps.md
#, fuzzy
msgid ""
"So far we've talked about microcontrollers, such as the Arm Cortex-M series. "
"Now let's try writing something for Cortex-A. For simplicity we'll just work "
"with QEMU's aarch64 ['virt'](https://qemu-project.gitlab.io/qemu/system/arm/"
"virt.html) board."
msgstr ""
"Până acum am vorbit despre microcontrolere, cum ar fi seria Arm Cortex-M. "
"Acum să încercăm să scriem ceva pentru Cortex-A. Pentru simplitate, vom "
"lucra doar cu placa aarch64 ['virt'](https://qemu-project.gitlab.io/qemu/"
"system/arm/virt.html) a lui QEMU."

#: src/bare-metal/aps.md
#, fuzzy
msgid ""
"Broadly speaking, microcontrollers don't have an MMU or multiple levels of "
"privilege (exception levels on Arm CPUs, rings on x86), while application "
"processors do."
msgstr ""
"În linii mari, microcontrolerele nu au un MMU sau mai multe niveluri de "
"privilegii (niveluri de excepție la procesoarele Arm, inele la x86), în timp "
"ce procesoarele de aplicații au."

#: src/bare-metal/aps.md
#, fuzzy
msgid ""
"QEMU supports emulating various different machines or board models for each "
"architecture. The 'virt' board doesn't correspond to any particular real "
"hardware, but is designed purely for virtual machines."
msgstr ""
"QEMU suportă emularea mai multor mașini sau modele de plăci diferite pentru "
"fiecare arhitectură. Placa \"virt\" nu corespunde unui anumit hardware real, "
"ci este concepută exclusiv pentru mașini virtuale."

#: src/bare-metal/aps/entry-point.md
#, fuzzy
msgid ""
"Before we can start running Rust code, we need to do some initialisation."
msgstr ""
"Înainte de a începe să rulăm codul Rust, trebuie să facem o anumită "
"inițializare."

#: src/bare-metal/aps/entry-point.md
#, fuzzy
msgid ""
"```armasm\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"    /*\n"
"     * Load and apply the memory management configuration, ready to enable "
"MMU and\n"
"     * caches.\n"
"     */\n"
"    adrp x30, idmap\n"
"    msr ttbr0_el1, x30\n"
"\n"
"    mov_i x30, .Lmairval\n"
"    msr mair_el1, x30\n"
"\n"
"    mov_i x30, .Ltcrval\n"
"    /* Copy the supported PA range into TCR_EL1.IPS. */\n"
"    mrs x29, id_aa64mmfr0_el1\n"
"    bfi x30, x29, #32, #4\n"
"\n"
"    msr tcr_el1, x30\n"
"\n"
"    mov_i x30, .Lsctlrval\n"
"\n"
"    /*\n"
"     * Ensure everything before this point has completed, then invalidate "
"any\n"
"     * potentially stale local TLB entries before they start being used.\n"
"     */\n"
"    isb\n"
"    tlbi vmalle1\n"
"    ic iallu\n"
"    dsb nsh\n"
"    isb\n"
"\n"
"    /*\n"
"     * Configure sctlr_el1 to enable MMU and cache and don't proceed until "
"this\n"
"     * has completed.\n"
"     */\n"
"    msr sctlr_el1, x30\n"
"    isb\n"
"\n"
"    /* Disable trapping floating point access in EL1. */\n"
"    mrs x30, cpacr_el1\n"
"    orr x30, x30, #(0x3 << 20)\n"
"    msr cpacr_el1, x30\n"
"    isb\n"
"\n"
"    /* Zero out the bss section. */\n"
"    adr_l x29, bss_begin\n"
"    adr_l x30, bss_end\n"
"0:  cmp x29, x30\n"
"    b.hs 1f\n"
"    stp xzr, xzr, [x29], #16\n"
"    b 0b\n"
"\n"
"1:  /* Prepare the stack. */\n"
"    adr_l x30, boot_stack_end\n"
"    mov sp, x30\n"
"\n"
"    /* Set up exception vector. */\n"
"    adr x30, vector_table_el1\n"
"    msr vbar_el1, x30\n"
"\n"
"    /* Call into Rust code. */\n"
"    bl main\n"
"\n"
"    /* Loop forever waiting for interrupts. */\n"
"2:  wfi\n"
"    b 2b\n"
"```"
msgstr ""
"```armasm\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"intrare:\n"
"    /*\n"
"     * Încărcați și aplicați configurația de gestionare a memoriei, "
"pregătită pentru a activa MMU și\n"
"     * memoria cache.\n"
"     */\n"
"    adrp x30, idmap\n"
"    msr ttbr0_el1, x30\n"
"\n"
"    mov_i x30, .Lmairval\n"
"    msr mair_el1, x30\n"
"\n"
"    mov_i x30, .Ltcrval\n"
"    /* Copiază intervalul PA acceptat în TCR_EL1.IPS. */\n"
"    mrs x29, id_aa64mmfr0_el1\n"
"    bfi x30, x29, #32, #4\n"
"\n"
"    msr tcr_el1, x30\n"
"\n"
"    mov_i x30, .Lsctlrval\n"
"\n"
"    /*\n"
"     * Asigură-te că tot ceea ce a precedat acest punct s-a finalizat, apoi "
"invalidează orice\n"
"     * toate intrările TLB locale potențial vechi înainte de a începe să fie "
"utilizate.\n"
"     */\n"
"    isb\n"
"    tlbi vmalle1\n"
"    ic iallu\n"
"    dsb nsh\n"
"    isb\n"
"\n"
"    /*\n"
"     * Configurați sctlr_el1 pentru a activa MMU și memoria cache și nu "
"continuați până când acest lucru\n"
"     * nu este finalizată.\n"
"     */\n"
"    msr sctlr_el1, x30\n"
"    isb\n"
"\n"
"    /* Dezactivează captarea accesului în virgulă mobilă în EL1. */\n"
"    mrs x30, cpacr_el1\n"
"    orr x30, x30, #(0x3 << 20)\n"
"    msr cpacr_el1, x30\n"
"    isb\n"
"\n"
"    /* Elimină secțiunea bss. */\n"
"    adr_l x29, bss_begin\n"
"    adr_l x30, bss_end\n"
"0: cmp x29, x30\n"
"    b.hs 1f\n"
"    stp xzr, xzr, [x29], #16\n"
"    b 0b\n"
"\n"
"1: /* Pregătește stiva. */\n"
"    adr_l x30, boot_stack_end\n"
"    mov sp, x30\n"
"\n"
"    /* Setează vectorul de excepție. */\n"
"    adr x30, vector_table_el1\n"
"    msr vbar_el1, x30\n"
"\n"
"    /* Apel în codul Rust. */\n"
"    bl main\n"
"\n"
"    /* Buclă veșnică în așteptarea întreruperilor. */\n"
"2: wfi\n"
"    b 2b\n"
"```"

#: src/bare-metal/aps/entry-point.md
#, fuzzy
msgid ""
"This is the same as it would be for C: initialising the processor state, "
"zeroing the BSS, and setting up the stack pointer."
msgstr ""
"Aceasta este aceeași ca și în C: inițializarea stării procesorului, anularea "
"BSS și stabilirea pointerului de stivă."

#: src/bare-metal/aps/entry-point.md
#, fuzzy
msgid ""
"The BSS (block starting symbol, for historical reasons) is the part of the "
"object file which containing statically allocated variables which are "
"initialised to zero. They are omitted from the image, to avoid wasting space "
"on zeroes. The compiler assumes that the loader will take care of zeroing "
"them."
msgstr ""
"BSS (simbolul de pornire al blocului, din motive istorice) este partea din "
"fișierul obiect care conține variabilele alocate static care sunt "
"inițializate la zero. Acestea sunt omise din imagine, pentru a se evita "
"risipa de spațiu cu zerouri. Compilatorul pornește de la premisa că "
"încărcătorul se va ocupa de punerea lor la zero."

#: src/bare-metal/aps/entry-point.md
#, fuzzy
msgid ""
"The BSS may already be zeroed, depending on how memory is initialised and "
"the image is loaded, but we zero it to be sure."
msgstr ""
"Este posibil ca BSS să fie deja zero, în funcție de modul în care memoria "
"este inițializată și imaginea este încărcată, dar trebuie să îl punem la "
"zero pentru a fi siguri."

#: src/bare-metal/aps/entry-point.md
#, fuzzy
msgid ""
"We need to enable the MMU and cache before reading or writing any memory. If "
"we don't:"
msgstr ""
"Trebuie să activăm MMU și memoria cache înainte de a citi sau scrie în "
"memorie. Dacă nu o facem:"

#: src/bare-metal/aps/entry-point.md
#, fuzzy
msgid ""
"Unaligned accesses will fault. We build the Rust code for the `aarch64-"
"unknown-none` target which sets `+strict-align` to prevent the compiler "
"generating unaligned accesses, so it should be fine in this case, but this "
"is not necessarily the case in general."
msgstr ""
"Accesările nealiniate vor fi defectuoase. Noi construim codul Rust pentru "
"ținta `aarch64-unknown-none` care setează `+strict-align` pentru a preveni "
"compilatorul să genereze accese nealiniate, deci ar trebui să fie în regulă "
"în acest caz, dar nu este neapărat cazul în general."

#: src/bare-metal/aps/entry-point.md
#, fuzzy
msgid ""
"If it were running in a VM, this can lead to cache coherency issues. The "
"problem is that the VM is accessing memory directly with the cache disabled, "
"while the host has cacheable aliases to the same memory. Even if the host "
"doesn't explicitly access the memory, speculative accesses can lead to cache "
"fills, and then changes from one or the other will get lost when the cache "
"is cleaned or the VM enables the cache. (Cache is keyed by physical address, "
"not VA or IPA.)"
msgstr ""
"Dacă ar fi rulat într-o mașină virtuală, acest lucru poate duce la probleme "
"de coerență a memoriei cache. Problema constă în faptul că mașina virtuală "
"accesează memoria direct, cu memoria cache dezactivată, în timp ce gazda are "
"alias-uri care pot fi stocate în memoria cache pentru aceeași memorie. Chiar "
"dacă gazda nu accesează în mod explicit memoria, accesările speculative pot "
"duce la umplerea memoriei cache, iar apoi modificările de la unul sau de la "
"celălalt se vor pierde atunci când memoria cache este curățată sau când VM "
"activează memoria cache. (Memoria cache este codificată în funcție de adresa "
"fizică, nu de VA sau IPA)"

#: src/bare-metal/aps/entry-point.md
#, fuzzy
msgid ""
"For simplicity, we just use a hardcoded pagetable (see `idmap.S`) which "
"identity maps the first 1 GiB of address space for devices, the next 1 GiB "
"for DRAM, and another 1 GiB higher up for more devices. This matches the "
"memory layout that QEMU uses."
msgstr ""
"Pentru simplitate, folosim doar o tabelă de pagini codificată (a se vedea "
"`idmap.S`) care mapează identitar primul 1 GiB de spațiu de adrese pentru "
"dispozitive, următorul 1 GiB pentru DRAM și încă 1 GiB mai sus pentru mai "
"multe dispozitive. Acest lucru se potrivește cu dispunerea memoriei pe care "
"o folosește QEMU."

#: src/bare-metal/aps/entry-point.md
#, fuzzy
msgid ""
"We also set up the exception vector (`vbar_el1`), which we'll see more about "
"later."
msgstr ""
"De asemenea, am configurat vectorul de excepții (`vbar_el1`), despre care "
"vom vedea mai multe mai târziu."

#: src/bare-metal/aps/entry-point.md
#, fuzzy
msgid ""
"All examples this afternoon assume we will be running at exception level 1 "
"(EL1). If you need to run at a different exception level you'll need to "
"modify `entry.S` accordingly."
msgstr ""
"Toate exemplele din această după-amiază presupun că vom funcționa la nivelul "
"de excepție 1 (EL1). Dacă aveți nevoie să rulați la un alt nivel de "
"excepție, va trebui să modificați `entry.S` în consecință."

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid "Inline assembly"
msgstr "Ansamblare în linie"

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid ""
"Sometimes we need to use assembly to do things that aren't possible with "
"Rust code. For example, to make an HVC (hypervisor call) to tell the "
"firmware to power off the system:"
msgstr ""
"Uneori trebuie să folosim asamblarea pentru a face lucruri care nu sunt "
"posibile cu codul Rust. De exemplu, pentru a face un apel HVC (hypervisor "
"call) pentru a spune firmware-ului să oprească sistemul:"

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid ""
"// SAFETY: this only uses the declared registers and doesn't do anything\n"
"    // with memory.\n"
msgstr ""
"// Sigur pentru că acest lucru folosește doar registrele declarate și nu "
"face\n"
"    // nimic cu memoria.\n"

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid "\"hvc #0\""
msgstr "\"hvc #0\""

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid "\"w0\""
msgstr "\"w0\""

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid "\"w1\""
msgstr "\"w1\""

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid "\"w2\""
msgstr "\"w2\""

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid "\"w3\""
msgstr "\"w3\""

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid "\"w4\""
msgstr "\"w4\""

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid "\"w5\""
msgstr "\"w5\""

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid "\"w6\""
msgstr "\"w6\""

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid "\"w7\""
msgstr "\"w7\""

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid ""
"(If you actually want to do this, use the [`smccc`](https://crates.io/crates/"
"smccc) crate which has wrappers for all these functions.)"
msgstr ""
"(Dacă doriți să faceți acest lucru, folosiți crăiasa [`smccc`](https://"
"crates.io/crates/smccc) care are învelișuri pentru toate aceste funcții.)"

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid ""
"PSCI is the Arm Power State Coordination Interface, a standard set of "
"functions to manage system and CPU power states, among other things. It is "
"implemented by EL3 firmware and hypervisors on many systems."
msgstr ""
"PSCI este Interfața de coordonare a stării de alimentare a brațului, un set "
"standard de funcții pentru gestionarea stării de alimentare a sistemului și "
"a procesorului, printre altele. Este implementată de firmware-ul EL3 și de "
"hipervizoarele de pe multe sisteme."

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid ""
"The `0 => _` syntax means initialise the register to 0 before running the "
"inline assembly code, and ignore its contents afterwards. We need to use "
"`inout` rather than `in` because the call could potentially clobber the "
"contents of the registers."
msgstr ""
"Sintaxa `0 => _` înseamnă inițializarea registrului la 0 înainte de a rula "
"codul de asamblare în linie și ignorarea conținutului acestuia după aceea. "
"Trebuie să folosim mai degrabă `inout` decât `in` deoarece apelul ar putea "
"să distrugă conținutul registrelor."

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid ""
"This `main` function needs to be `#[no_mangle]` and `extern \"C\"` because "
"it is called from our entry point in `entry.S`."
msgstr ""
"Această funcție `main` trebuie să fie `#[no_mangle]` și `extern \"C\"` "
"deoarece este apelată din punctul nostru de intrare în `entry.S`."

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid ""
"`_x0`–`_x3` are the values of registers `x0`–`x3`, which are conventionally "
"used by the bootloader to pass things like a pointer to the device tree. "
"According to the standard aarch64 calling convention (which is what `extern "
"\"C\"` specifies to use), registers `x0`–`x7` are used for the first 8 "
"arguments passed to a function, so `entry.S` doesn't need to do anything "
"special except make sure it doesn't change these registers."
msgstr ""
"`_x0`-`_x3` sunt valorile registrelor `x0`-`x3`, care sunt utilizate în mod "
"convențional de către bootloader pentru a transmite lucruri precum un "
"pointer la arborele de dispozitive. În conformitate cu convenția standard de "
"apelare aarch64 (care este cea pe care `extern \"C\"` specifică să o "
"folosească), registrele `x0`-`x7` sunt folosite pentru primele 8 argumente "
"transmise unei funcții, astfel încât `entry.S` nu trebuie să facă nimic "
"special, cu excepția faptului că trebuie să se asigure că nu modifică aceste "
"registre."

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid ""
"Run the example in QEMU with `make qemu_psci` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"Rulați exemplul în QEMU cu `make qemu_psci` în `src/bare-metal/aps/examples`."

#: src/bare-metal/aps/mmio.md
#, fuzzy
msgid "Volatile memory access for MMIO"
msgstr "Acces la memoria volatilă pentru MMIO"

#: src/bare-metal/aps/mmio.md
#, fuzzy
msgid "Use `pointer::read_volatile` and `pointer::write_volatile`."
msgstr "Utilizați `pointer::read_volatile` și `pointer::write_volatile`."

#: src/bare-metal/aps/mmio.md
#, fuzzy
msgid "Never hold a reference."
msgstr "Nu țineți niciodată o referință."

#: src/bare-metal/aps/mmio.md
#, fuzzy
msgid ""
"`addr_of!` lets you get fields of structs without creating an intermediate "
"reference."
msgstr ""
"`addr_of!` vă permite să obțineți câmpurile structurilor fără a crea o "
"referință intermediară."

#: src/bare-metal/aps/mmio.md
#, fuzzy
msgid ""
"Volatile access: read or write operations may have side-effects, so prevent "
"the compiler or hardware from reordering, duplicating or eliding them."
msgstr ""
"Acces volatil: Operațiunile de citire sau scriere pot avea efecte secundare, "
"deci împiedicați compilatorul sau hardware-ul să le reordoneze, să le "
"dubleze sau să le eludeze."

#: src/bare-metal/aps/mmio.md
#, fuzzy
msgid ""
"Usually if you write and then read, e.g. via a mutable reference, the "
"compiler may assume that the value read is the same as the value just "
"written, and not bother actually reading memory."
msgstr ""
"De obicei, dacă scrieți și apoi citiți, de exemplu, prin intermediul unei "
"referințe mutabile, compilatorul poate presupune că valoarea citită este "
"aceeași cu cea care tocmai a fost scrisă și nu se mai obosește să citească "
"efectiv memoria."

#: src/bare-metal/aps/mmio.md
#, fuzzy
msgid ""
"Some existing crates for volatile access to hardware do hold references, but "
"this is unsound. Whenever a reference exist, the compiler may choose to "
"dereference it."
msgstr ""
"Unele cutii existente pentru accesul volatil la hardware conțin referințe, "
"dar acest lucru nu este corect. Ori de câte ori există o referință, "
"compilatorul poate alege să o deregleze."

#: src/bare-metal/aps/mmio.md
#, fuzzy
msgid ""
"Use the `addr_of!` macro to get struct field pointers from a pointer to the "
"struct."
msgstr ""
"Utilizați macroul `addr_of!` pentru a obține pointeri de câmpuri de "
"structură dintr-un pointer la structură."

#: src/bare-metal/aps/uart.md
#, fuzzy
msgid "Let's write a UART driver"
msgstr "Să scriem un driver UART"

#: src/bare-metal/aps/uart.md
#, fuzzy
msgid ""
"The QEMU 'virt' machine has a [PL011](https://developer.arm.com/"
"documentation/ddi0183/g) UART, so let's write a driver for that."
msgstr ""
"Mașina QEMU 'virt' are o UART [PL011](https://developer.arm.com/"
"documentation/ddi0183/g), așa că haideți să scriem un driver pentru aceasta."

#: src/bare-metal/aps/uart.md
#, fuzzy
msgid "/// Minimal driver for a PL011 UART.\n"
msgstr "/// Driver minim pentru o UART PL011.\n"

#: src/bare-metal/aps/uart.md src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid ""
"/// Constructs a new instance of the UART driver for a PL011 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the 8 MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
msgstr ""
"/// Construiește o nouă instanță a driverului UART pentru un dispozitiv "
"PL011 la nivelul\n"
"    /// adresa de bază dată.\n"
"    ///\n"
"    /// # Siguranță\n"
"    ///\n"
"    /// Adresa de bază dată trebuie să indice cele 8 registre de control "
"MMIO ale unui dispozitiv de tip\n"
"    /// PL011, care trebuie să fie mapate în spațiul de adrese al "
"procesului\n"
"    /// ca memorie a dispozitivului și să nu aibă alte pseudonime.\n"

#: src/bare-metal/aps/uart.md src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid "/// Writes a single byte to the UART.\n"
msgstr "/// Scrie un singur octet pe UART.\n"

#: src/bare-metal/aps/uart.md src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid "// Wait until there is room in the TX buffer.\n"
msgstr "// Așteptați până când există spațiu în bufferul TX.\n"

#: src/bare-metal/aps/uart.md
#, fuzzy
msgid ""
"// SAFETY: We know that the base address points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
msgstr ""
"// Sigur, deoarece știm că adresa de bază indică controlul\n"
"        // registrele de control ale unui dispozitiv PL011 care este mapat "
"corespunzător.\n"

#: src/bare-metal/aps/uart.md src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid "// Write to the TX buffer.\n"
msgstr "// Scrieți în bufferul TX.\n"

#: src/bare-metal/aps/uart.md src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid "// Wait until the UART is no longer busy.\n"
msgstr "// Așteptați până când UART nu mai este ocupată.\n"

#: src/bare-metal/aps/uart.md
#, fuzzy
msgid ""
"Note that `Uart::new` is unsafe while the other methods are safe. This is "
"because as long as the caller of `Uart::new` guarantees that its safety "
"requirements are met (i.e. that there is only ever one instance of the "
"driver for a given UART, and nothing else aliasing its address space), then "
"it is always safe to call `write_byte` later because we can assume the "
"necessary preconditions."
msgstr ""
"Rețineți că `Uart::new` este nesigură, în timp ce celelalte metode sunt "
"sigure. Acest lucru se datorează faptului că, atâta timp cât apelantul lui "
"`Uart::new` garantează că cerințele sale de siguranță sunt îndeplinite (de "
"exemplu, că există doar o singură instanță a driverului pentru o anumită "
"UART și nimic altceva care să se alăture spațiului său de adrese), atunci "
"este întotdeauna sigur să apelăm mai târziu `write_byte`, deoarece putem "
"presupune condițiile prealabile necesare."

#: src/bare-metal/aps/uart.md
#, fuzzy
msgid ""
"We could have done it the other way around (making `new` safe but "
"`write_byte` unsafe), but that would be much less convenient to use as every "
"place that calls `write_byte` would need to reason about the safety"
msgstr ""
"Am fi putut face invers (făcând `new` sigur, dar `write_byte` nesigur), dar "
"ar fi fost mult mai puțin convenabil de utilizat, deoarece fiecare loc care "
"apelează `write_byte` ar trebui să se gândească la siguranța lui `write_byte`"

#: src/bare-metal/aps/uart.md
#, fuzzy
msgid ""
"This is a common pattern for writing safe wrappers of unsafe code: moving "
"the burden of proof for soundness from a large number of places to a smaller "
"number of places."
msgstr ""
"Acesta este un model comun pentru scrierea de învelișuri sigure pentru cod "
"nesigur: mutarea sarcinii de a dovedi soliditatea de la un număr mare de "
"locuri la un număr mai mic de locuri."

#: src/bare-metal/aps/uart/traits.md
#, fuzzy
msgid "More traits"
msgstr "Mai multe trăsături"

#: src/bare-metal/aps/uart/traits.md
#, fuzzy
msgid ""
"We derived the `Debug` trait. It would be useful to implement a few more "
"traits too."
msgstr ""
"Am derivat trăsătura `Debug`. Ar fi util să implementăm și alte câteva "
"trăsături."

#: src/bare-metal/aps/uart/traits.md
#, fuzzy
msgid ""
"// SAFETY: `Uart` just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
msgstr ""
"// Sigur, deoarece conține doar un pointer către memoria dispozitivului, "
"care poate fi\n"
"// accesată din orice context.\n"

#: src/bare-metal/aps/uart/traits.md
#, fuzzy
msgid ""
"Implementing `Write` lets us use the `write!` and `writeln!` macros with our "
"`Uart` type."
msgstr ""
"Implementarea `Write` ne permite să folosim macrogramele `write!` și "
"`writeln!` cu tipul nostru `Uart`."

#: src/bare-metal/aps/uart/traits.md
#, fuzzy
msgid ""
"Run the example in QEMU with `make qemu_minimal` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"Rulați exemplul în QEMU cu `make qemu_minimal` în `src/bare-metal/aps/"
"examples`."

#: src/bare-metal/aps/better-uart.md
#, fuzzy
msgid "A better UART driver"
msgstr "Un driver UART mai bun"

#: src/bare-metal/aps/better-uart.md
#, fuzzy
msgid ""
"The PL011 actually has [a bunch more registers](https://developer.arm.com/"
"documentation/ddi0183/g/programmers-model/summary-of-registers), and adding "
"offsets to construct pointers to access them is error-prone and hard to "
"read. Plus, some of them are bit fields which would be nice to access in a "
"structured way."
msgstr ""
"PL011 are de fapt [o grămadă de registre](https://developer.arm.com/"
"documentation/ddi0183/g/programmers-model/summary-of-registers), iar "
"adăugarea de offset-uri pentru a construi pointeri pentru a le accesa este "
"predispusă la erori și greu de citit. În plus, unele dintre ele sunt câmpuri "
"de biți care ar fi frumos să fie accesate într-un mod structurat."

#: src/bare-metal/aps/better-uart.md
msgid "Offset"
msgstr "Decalaj"

#: src/bare-metal/aps/better-uart.md
msgid "Register name"
msgstr "Nume registru"

#: src/bare-metal/aps/better-uart.md
msgid "Width"
msgstr "Lăţime"

#: src/bare-metal/aps/better-uart.md
msgid "0x00"
msgstr "0x00"

#: src/bare-metal/aps/better-uart.md
msgid "DR"
msgstr "DR"

#: src/bare-metal/aps/better-uart.md
msgid "12"
msgstr "12"

#: src/bare-metal/aps/better-uart.md
msgid "0x04"
msgstr "0x04"

#: src/bare-metal/aps/better-uart.md
msgid "RSR"
msgstr "RSR"

#: src/bare-metal/aps/better-uart.md
msgid "0x18"
msgstr "0x18"

#: src/bare-metal/aps/better-uart.md
msgid "FR"
msgstr "V"

#: src/bare-metal/aps/better-uart.md
msgid "9"
msgstr "9"

#: src/bare-metal/aps/better-uart.md
msgid "0x20"
msgstr "0x20"

#: src/bare-metal/aps/better-uart.md
msgid "ILPR"
msgstr "ILPR"

#: src/bare-metal/aps/better-uart.md
msgid "0x24"
msgstr "0x24"

#: src/bare-metal/aps/better-uart.md
msgid "IBRD"
msgstr "IBRD"

#: src/bare-metal/aps/better-uart.md
msgid "16"
msgstr "16"

#: src/bare-metal/aps/better-uart.md
msgid "0x28"
msgstr "0x28"

#: src/bare-metal/aps/better-uart.md
msgid "FBRD"
msgstr "FBRD"

#: src/bare-metal/aps/better-uart.md
msgid "0x2c"
msgstr "0x2c"

#: src/bare-metal/aps/better-uart.md
msgid "LCR_H"
msgstr "LCR_H"

#: src/bare-metal/aps/better-uart.md
msgid "0x30"
msgstr "0x30"

#: src/bare-metal/aps/better-uart.md
msgid "CR"
msgstr "GD"

#: src/bare-metal/aps/better-uart.md
msgid "0x34"
msgstr "0x34"

#: src/bare-metal/aps/better-uart.md
msgid "IFLS"
msgstr "IFLS"

#: src/bare-metal/aps/better-uart.md
msgid "0x38"
msgstr "0x38"

#: src/bare-metal/aps/better-uart.md
msgid "IMSC"
msgstr "IMSC"

#: src/bare-metal/aps/better-uart.md
msgid "11"
msgstr "11"

#: src/bare-metal/aps/better-uart.md
msgid "0x3c"
msgstr "0x3c"

#: src/bare-metal/aps/better-uart.md
msgid "RIS"
msgstr "RIS"

#: src/bare-metal/aps/better-uart.md
msgid "0x40"
msgstr "0x40"

#: src/bare-metal/aps/better-uart.md
msgid "MIS"
msgstr "MIS"

#: src/bare-metal/aps/better-uart.md
msgid "0x44"
msgstr "0x44"

#: src/bare-metal/aps/better-uart.md
msgid "ICR"
msgstr "ICR"

#: src/bare-metal/aps/better-uart.md
msgid "0x48"
msgstr "0x48"

#: src/bare-metal/aps/better-uart.md
msgid "DMACR"
msgstr "DMACR"

#: src/bare-metal/aps/better-uart.md
#, fuzzy
msgid "There are also some ID registers which have been omitted for brevity."
msgstr ""
"Există, de asemenea, unele registre de identificare care au fost omise "
"pentru a fi mai scurte."

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid ""
"The [`bitflags`](https://crates.io/crates/bitflags) crate is useful for "
"working with bitflags."
msgstr ""
"Crăiasa [`bitflags`](https://crates.io/crates/bitflags) este utilă pentru a "
"lucra cu bitflags."

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Flags from the UART flag register.\n"
msgstr "/// Semnalizatoare din registrul de semnalizare UART.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Clear to send.\n"
msgstr "/// Liber la trimitere.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Data set ready.\n"
msgstr "/// Set de date pregătit.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Data carrier detect.\n"
msgstr "/// Detectarea purtătorului de date.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// UART busy transmitting data.\n"
msgstr "/// UART ocupată cu transmiterea de date.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Receive FIFO is empty.\n"
msgstr "/// Receive FIFO este gol.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Transmit FIFO is full.\n"
msgstr "/// Transmit FIFO este plin.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Receive FIFO is full.\n"
msgstr "/// Receive FIFO este plin.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Transmit FIFO is empty.\n"
msgstr "/// Transmit FIFO este gol.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Ring indicator.\n"
msgstr "/// Indicator de inel.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid ""
"The `bitflags!` macro creates a newtype something like `Flags(u16)`, along "
"with a bunch of method implementations to get and set flags."
msgstr ""
"Macroul `bitflags!` creează un nou tip, ceva de genul `Flags(u16)`, împreună "
"cu o serie de implementări de metode pentru a obține și seta steaguri."

#: src/bare-metal/aps/better-uart/registers.md
#, fuzzy
msgid "Multiple registers"
msgstr "Registre multiple"

#: src/bare-metal/aps/better-uart/registers.md
#, fuzzy
msgid ""
"We can use a struct to represent the memory layout of the UART's registers."
msgstr ""
"Putem folosi o structură pentru a reprezenta structura de memorie a "
"registrelor UART."

#: src/bare-metal/aps/better-uart/registers.md
#, fuzzy
msgid ""
"[`#[repr(C)]`](https://doc.rust-lang.org/reference/type-layout.html#the-c-"
"representation) tells the compiler to lay the struct fields out in order, "
"following the same rules as C. This is necessary for our struct to have a "
"predictable layout, as default Rust representation allows the compiler to "
"(among other things) reorder fields however it sees fit."
msgstr ""
"[`#[repr(C)]`](https://doc.rust-lang.org/reference/type-layout.html#the-c-"
"representation) îi spune compilatorului să așeze câmpurile structurii în "
"ordine, urmând aceleași reguli ca și în C. Acest lucru este necesar pentru "
"ca structura noastră să aibă o dispunere previzibilă, deoarece reprezentarea "
"implicită Rust permite compilatorului (printre altele) să reordoneze "
"câmpurile după cum crede de cuviință."

#: src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid "Now let's use the new `Registers` struct in our driver."
msgstr "Acum să folosim noua structură `Registers` în driverul nostru."

#: src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid "/// Driver for a PL011 UART.\n"
msgstr "/// Driver pentru o UART PL011.\n"

#: src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid ""
"// SAFETY: We know that self.registers points to the control registers\n"
"        // of a PL011 device which is appropriately mapped.\n"
msgstr ""
"// Sigur, deoarece știm că self.registers indică controlul\n"
"        // registre ale unui dispozitiv PL011 care este mapat în mod "
"corespunzător.\n"

#: src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid ""
"/// Reads and returns a pending byte, or `None` if nothing has been\n"
"    /// received.\n"
msgstr ""
"/// Citește și returnează un octet în așteptare, sau `None` dacă nu a fost "
"nimic\n"
"    /// primit.\n"

#: src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid ""
"// SAFETY: We know that self.registers points to the control\n"
"            // registers of a PL011 device which is appropriately mapped.\n"
msgstr ""
"// Sigur, deoarece știm că self.registers indică controlul\n"
"        // registre ale unui dispozitiv PL011 care este mapat în mod "
"corespunzător.\n"

#: src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid "// TODO: Check for error conditions in bits 8-11.\n"
msgstr "// TODO: Verificați dacă există condiții de eroare în biții 8-11.\n"

#: src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid ""
"Note the use of `addr_of!` / `addr_of_mut!` to get pointers to individual "
"fields without creating an intermediate reference, which would be unsound."
msgstr ""
"Rețineți utilizarea lui `addr_of!` / `addr_of_mut!` pentru a obține pointeri "
"la câmpuri individuale fără a crea o referință intermediară, ceea ce ar fi "
"nesigur."

#: src/bare-metal/aps/better-uart/using.md src/bare-metal/aps/logging/using.md
#, fuzzy
msgid "Using it"
msgstr "Folosirea Cargo"

#: src/bare-metal/aps/better-uart/using.md
#, fuzzy
msgid ""
"Let's write a small program using our driver to write to the serial console, "
"and echo incoming bytes."
msgstr ""
"Să scriem un mic program care utilizează driverul nostru pentru a scrie pe "
"consola serială și pentru a reda ecourile octeților care intră."

#: src/bare-metal/aps/better-uart/using.md src/bare-metal/aps/logging/using.md
#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Base address of the primary PL011 UART.\n"
msgstr "/// Adresa de bază a UART PL011 primară.\n"

#: src/bare-metal/aps/better-uart/using.md src/bare-metal/aps/logging/using.md
#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"// SAFETY: `PL011_BASE_ADDRESS` is the base address of a PL011 device, and\n"
"    // nothing else accesses that address range.\n"
msgstr ""
"// Sigur, deoarece `PL011_BASE_ADDRESS` este adresa de bază a unui "
"dispozitiv PL011,\n"
"    // și nimic altceva nu accesează acest interval de adrese.\n"

#: src/bare-metal/aps/better-uart/using.md src/bare-metal/aps/logging/using.md
#, fuzzy
msgid "\"main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})\""
msgstr "\"main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})\""

#: src/bare-metal/aps/better-uart/using.md
#, fuzzy
msgid "b'\\r'"
msgstr "b'\\r'"

#: src/bare-metal/aps/better-uart/using.md
#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid "b'\\n'"
msgstr "b'\\n'"

#: src/bare-metal/aps/better-uart/using.md
#, fuzzy
msgid "b'q'"
msgstr "b'q'"

#: src/bare-metal/aps/better-uart/using.md
#, fuzzy
msgid "\"Bye!\""
msgstr "\"La revedere!\""

#: src/bare-metal/aps/better-uart/using.md
#, fuzzy
msgid ""
"As in the [inline assembly](../inline-assembly.md) example, this `main` "
"function is called from our entry point code in `entry.S`. See the speaker "
"notes there for details."
msgstr ""
"Ca și în exemplul [inline assembly](../inline-assembly.md), această funcție "
"`main` este apelată din codul punctului de intrare în `entry.S`. Pentru "
"detalii, consultați notele vorbitorului de acolo."

#: src/bare-metal/aps/better-uart/using.md
#, fuzzy
msgid ""
"Run the example in QEMU with `make qemu` under `src/bare-metal/aps/examples`."
msgstr ""
"Rulați exemplul în QEMU cu `make qemu` în `src/bare-metal/aps/examples`."

#: src/bare-metal/aps/logging.md
#, fuzzy
msgid ""
"It would be nice to be able to use the logging macros from the [`log`]"
"(https://crates.io/crates/log) crate. We can do this by implementing the "
"`Log` trait."
msgstr ""
"Ar fi frumos să putem folosi macrogramele de logare de la [`log`](https://"
"crates.io/crates/log) crate. Putem face acest lucru prin implementarea "
"trăsăturii `Log`."

#: src/bare-metal/aps/logging.md
#, fuzzy
msgid "\"[{}] {}\""
msgstr "\"[{}] {}\""

#: src/bare-metal/aps/logging.md
#, fuzzy
msgid "/// Initialises UART logger.\n"
msgstr "/// Inițializează loggerul UART.\n"

#: src/bare-metal/aps/logging.md
#, fuzzy
msgid ""
"The unwrap in `log` is safe because we initialise `LOGGER` before calling "
"`set_logger`."
msgstr ""
"Desfășurarea în `log` este sigură deoarece inițializăm `LOGGER` înainte de a "
"apela `set_logger`."

#: src/bare-metal/aps/logging/using.md
#, fuzzy
msgid "We need to initialise the logger before we use it."
msgstr "Trebuie să inițializăm loggerul înainte de a-l utiliza."

#: src/bare-metal/aps/logging/using.md
#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "\"{info}\""
msgstr "\"{info}\""

#: src/bare-metal/aps/logging/using.md
#, fuzzy
msgid "Note that our panic handler can now log details of panics."
msgstr ""
"Rețineți că gestionarul nostru de panică poate acum să înregistreze "
"detaliile panicii."

#: src/bare-metal/aps/logging/using.md
#, fuzzy
msgid ""
"Run the example in QEMU with `make qemu_logger` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"Rulați exemplul în QEMU cu `make qemu_logger` în `src/bare-metal/aps/"
"examples`."

#: src/bare-metal/aps/exceptions.md
#, fuzzy
msgid ""
"AArch64 defines an exception vector table with 16 entries, for 4 types of "
"exceptions (synchronous, IRQ, FIQ, SError) from 4 states (current EL with "
"SP0, current EL with SPx, lower EL using AArch64, lower EL using AArch32). "
"We implement this in assembly to save volatile registers to the stack before "
"calling into Rust code:"
msgstr ""
"AArch64 definește un tabel de vectori de excepții cu 16 intrări, pentru 4 "
"tipuri de excepții (sincronă, IRQ, FIQ, SError) din 4 stări (EL curent cu "
"SP0, EL curent cu SPx, EL inferior utilizând AArch64, EL inferior utilizând "
"AArch32). Implementăm acest lucru în asamblare pentru a salva registrele "
"volatile pe stivă înainte de a apela în codul Rust:"

#: src/bare-metal/aps/exceptions.md
#, fuzzy
msgid "EL is exception level; all our examples this afternoon run in EL1."
msgstr ""
"EL reprezintă nivelul de excepție; toate exemplele noastre din această după-"
"amiază rulează în EL1."

#: src/bare-metal/aps/exceptions.md
#, fuzzy
msgid ""
"For simplicity we aren't distinguishing between SP0 and SPx for the current "
"EL exceptions, or between AArch32 and AArch64 for the lower EL exceptions."
msgstr ""
"Pentru simplificare, nu facem distincție între SP0 și SPx pentru excepțiile "
"EL curente, sau între AArch32 și AArch64 pentru excepțiile EL inferioare."

#: src/bare-metal/aps/exceptions.md
#, fuzzy
msgid ""
"For this example we just log the exception and power down, as we don't "
"expect any of them to actually happen."
msgstr ""
"Pentru acest exemplu, ne limităm la înregistrarea excepției și la oprirea "
"alimentării, deoarece nu ne așteptăm ca vreuna dintre acestea să se întâmple."

#: src/bare-metal/aps/exceptions.md
#, fuzzy
msgid ""
"We can think of exception handlers and our main execution context more or "
"less like different threads. [`Send` and `Sync`](../../concurrency/send-sync."
"md) will control what we can share between them, just like with threads. For "
"example, if we want to share some value between exception handlers and the "
"rest of the program, and it's `Send` but not `Sync`, then we'll need to wrap "
"it in something like a `Mutex` and put it in a static."
msgstr ""
"Ne putem gândi la gestionarii de excepții și la contextul nostru principal "
"de execuție mai mult sau mai puțin ca la fire diferite. [`Send` și `Sync`]"
"(../../concurrency/send-sync.md) vor controla ceea ce putem partaja între "
"ele, la fel ca în cazul firelor de execuție. De exemplu, dacă dorim să "
"partajăm o anumită valoare între gestionarii de excepții și restul "
"programului, iar aceasta este `Send`, dar nu `Sync`, atunci va trebui să o "
"înfășurăm în ceva de genul `Mutex` și să o punem într-o statică."

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid "[oreboot](https://github.com/oreboot/oreboot)"
msgstr "[oreboot](https://github.com/oreboot/oreboot)"

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid "\"coreboot without the C\""
msgstr "\"coreboot fără C\""

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid "Supports x86, aarch64 and RISC-V."
msgstr "Suportă x86, aarch64 și RISC-V."

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid "Relies on LinuxBoot rather than having many drivers itself."
msgstr "Se bazează pe LinuxBoot în loc să aibă multe drivere."

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid ""
"[Rust RaspberryPi OS tutorial](https://github.com/rust-embedded/rust-"
"raspberrypi-OS-tutorials)"
msgstr ""
"[Tutorial Rust RaspberryPi OS](https://github.com/rust-embedded/rust-"
"raspberrypi-OS-tutorials)"

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid ""
"Initialisation, UART driver, simple bootloader, JTAG, exception levels, "
"exception handling, page tables"
msgstr ""
"Inițializare, driver UART, bootloader simplu, JTAG, niveluri de excepție, "
"tratarea excepțiilor, tabele de pagini"

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid ""
"Some dodginess around cache maintenance and initialisation in Rust, not "
"necessarily a good example to copy for production code."
msgstr ""
"Unele dificultăți în ceea ce privește întreținerea și inițializarea cache-"
"ului în Rust, nu neapărat un exemplu bun de copiat pentru codul de producție."

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid "[`cargo-call-stack`](https://crates.io/crates/cargo-call-stack)"
msgstr "[`cargo-call-stack`](https://crates.io/crates/cargo-call-stack)"

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid "Static analysis to determine maximum stack usage."
msgstr "Analiza statică pentru a determina utilizarea maximă a stivei."

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid ""
"The RaspberryPi OS tutorial runs Rust code before the MMU and caches are "
"enabled. This will read and write memory (e.g. the stack). However:"
msgstr ""
"Tutorialul RaspberryPi OS rulează codul Rust înainte ca MMU și memoria cache "
"să fie activate. Aceasta va citi și va scrie în memorie (de exemplu, stiva). "
"Cu toate acestea:"

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid ""
"Without the MMU and cache, unaligned accesses will fault. It builds with "
"`aarch64-unknown-none` which sets `+strict-align` to prevent the compiler "
"generating unaligned accesses so it should be alright, but this is not "
"necessarily the case in general."
msgstr ""
"Fără MMU și memoria cache, accesările nealiniate vor eșua. Se construiește "
"cu `aarch64-unknown-none`, care setează `+strict-align` pentru a împiedica "
"compilatorul să genereze accese nealiniate, deci ar trebui să fie în regulă, "
"dar acest lucru nu este neapărat valabil în general."

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid ""
"If it were running in a VM, this can lead to cache coherency issues. The "
"problem is that the VM is accessing memory directly with the cache disabled, "
"while the host has cacheable aliases to the same memory. Even if the host "
"doesn't explicitly access the memory, speculative accesses can lead to cache "
"fills, and then changes from one or the other will get lost. Again this is "
"alright in this particular case (running directly on the hardware with no "
"hypervisor), but isn't a good pattern in general."
msgstr ""
"Dacă ar fi rulat într-o mașină virtuală, acest lucru poate duce la probleme "
"de coerență a memoriei cache. Problema constă în faptul că mașina virtuală "
"accesează memoria direct, cu memoria cache dezactivată, în timp ce gazda are "
"alias-uri care pot fi stocate în memoria cache pentru aceeași memorie. Chiar "
"dacă gazda nu accesează în mod explicit memoria, accesările speculative pot "
"duce la umplerea cache-ului, iar apoi modificările de la unul sau de la "
"celălalt se vor pierde. Din nou, acest lucru este în regulă în acest caz "
"particular (care rulează direct pe hardware fără hipervizor), dar nu este un "
"model bun în general."

#: src/bare-metal/useful-crates.md
msgid "Useful crates"
msgstr "Lăzi (crates) utile"

#: src/bare-metal/useful-crates.md
#, fuzzy
msgid ""
"We'll go over a few crates which solve some common problems in bare-metal "
"programming."
msgstr ""
"Vom trece în revistă câteva crates care rezolvă unele probleme comune în "
"programarea bare-metal."

#: src/bare-metal/useful-crates/zerocopy.md
#, fuzzy
msgid ""
"The [`zerocopy`](https://docs.rs/zerocopy/) crate (from Fuchsia) provides "
"traits and macros for safely converting between byte sequences and other "
"types."
msgstr ""
"Crăiasa [`zerocopy`](https://docs.rs/zerocopy/) (din Fuchsia) oferă "
"trăsături și macro-uri pentru conversia în siguranță între secvențe de "
"octeți și alte tipuri."

#: src/bare-metal/useful-crates/zerocopy.md
#, fuzzy
msgid ""
"This is not suitable for MMIO (as it doesn't use volatile reads and writes), "
"but can be useful for working with structures shared with hardware e.g. by "
"DMA, or sent over some external interface."
msgstr ""
"Acest lucru nu este potrivit pentru MMIO (deoarece nu utilizează citiri și "
"scrieri volatile), dar poate fi util pentru lucrul cu structuri partajate cu "
"hardware, de exemplu prin DMA, sau trimise prin intermediul unei interfețe "
"externe."

#: src/bare-metal/useful-crates/zerocopy.md
#, fuzzy
msgid ""
"`FromBytes` can be implemented for types for which any byte pattern is "
"valid, and so can safely be converted from an untrusted sequence of bytes."
msgstr ""
"`FromBytes` poate fi implementat pentru tipurile pentru care orice model de "
"octeți este valabil și, prin urmare, poate fi convertit în siguranță dintr-o "
"secvență de octeți nesigură."

#: src/bare-metal/useful-crates/zerocopy.md
#, fuzzy
msgid ""
"Attempting to derive `FromBytes` for these types would fail, because "
"`RequestType` doesn't use all possible u32 values as discriminants, so not "
"all byte patterns are valid."
msgstr ""
"Încercarea de a deriva `FromBytes` pentru aceste tipuri ar eșua, deoarece "
"`RequestType` nu utilizează toate valorile u32 posibile ca discriminanți, "
"astfel încât nu toate modelele de octeți sunt valide."

#: src/bare-metal/useful-crates/zerocopy.md
#, fuzzy
msgid ""
"`zerocopy::byteorder` has types for byte-order aware numeric primitives."
msgstr ""
"`zerocopy::byteorder` are tipuri pentru primitive numerice care cunosc "
"ordinea octeților."

#: src/bare-metal/useful-crates/zerocopy.md
#, fuzzy
msgid ""
"Run the example with `cargo run` under `src/bare-metal/useful-crates/"
"zerocopy-example/`. (It won't run in the Playground because of the crate "
"dependency.)"
msgstr ""
"Rulați exemplul cu `cargo run` în `src/bare-metal/useful-crates/zerocopy-"
"example/`. (Nu va rula în Playground din cauza dependenței de crate)"

#: src/bare-metal/useful-crates/aarch64-paging.md
#, fuzzy
msgid ""
"The [`aarch64-paging`](https://crates.io/crates/aarch64-paging) crate lets "
"you create page tables according to the AArch64 Virtual Memory System "
"Architecture."
msgstr ""
"Crăiasa [`aarch64-paging`](https://crates.io/crates/aarch64-paging) vă "
"permite să creați tabele de pagini în conformitate cu arhitectura sistemului "
"de memorie virtuală AArch64."

#: src/bare-metal/useful-crates/aarch64-paging.md
#, fuzzy
msgid "// Create a new page table with identity mapping.\n"
msgstr "// Creați o nouă tabelă de pagini cu corespondență de identitate.\n"

#: src/bare-metal/useful-crates/aarch64-paging.md
#, fuzzy
msgid "// Map a 2 MiB region of memory as read-only.\n"
msgstr ""
"// Maparea unei regiuni de 2 MiB de memorie ca fiind numai pentru citire.\n"

#: src/bare-metal/useful-crates/aarch64-paging.md
#, fuzzy
msgid "// Set `TTBR0_EL1` to activate the page table.\n"
msgstr "// Setați `TTBR0_EL1` pentru a activa tabelul de pagini.\n"

#: src/bare-metal/useful-crates/aarch64-paging.md
#, fuzzy
msgid ""
"For now it only supports EL1, but support for other exception levels should "
"be straightforward to add."
msgstr ""
"Deocamdată, acceptă doar EL1, dar ar trebui să fie ușor de adăugat suportul "
"pentru alte niveluri de excepție."

#: src/bare-metal/useful-crates/aarch64-paging.md
#, fuzzy
msgid ""
"This is used in Android for the [Protected VM Firmware](https://cs.android."
"com/android/platform/superproject/+/master:packages/modules/Virtualization/"
"pvmfw/)."
msgstr ""
"Aceasta este utilizată în Android pentru [Protected VM Firmware] (https://cs."
"android.com/android/platform/superproject/+/master:packages/modules/"
"Virtualization/pvmfw/)."

#: src/bare-metal/useful-crates/aarch64-paging.md
#, fuzzy
msgid ""
"There's no easy way to run this example, as it needs to run on real hardware "
"or under QEMU."
msgstr ""
"Nu există o modalitate ușoară de a rula acest exemplu, deoarece trebuie să "
"ruleze pe hardware real sau în QEMU."

#: src/bare-metal/useful-crates/buddy_system_allocator.md
#, fuzzy
msgid ""
"[`buddy_system_allocator`](https://crates.io/crates/buddy_system_allocator) "
"is a third-party crate implementing a basic buddy system allocator. It can "
"be used both for [`LockedHeap`](https://docs.rs/buddy_system_allocator/0.9.0/"
"buddy_system_allocator/struct.LockedHeap.html) implementing [`GlobalAlloc`]"
"(https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html) so you can use "
"the standard `alloc` crate (as we saw [before](../alloc.md)), or for "
"allocating other address space. For example, we might want to allocate MMIO "
"space for PCI BARs:"
msgstr ""
"[`buddy_system_allocator`](https://crates.io/crates/buddy_system_allocator) "
"este o crăiasă terță parte care implementează un alocator de bază pentru "
"sistemul de prieteni. Acesta poate fi utilizat atât pentru [`LockedHeap`]"
"(https://docs.rs/buddy_system_allocator/0.9.0/buddy_system_allocator/struct."
"LockedHeap.html) care implementează [`GlobalAlloc`](https://doc.rust-lang."
"org/core/alloc/trait.GlobalAlloc.html), astfel încât să puteți utiliza crate-"
"ul standard `alloc` (așa cum am văzut [înainte](../alloc.md)), cât și pentru "
"alocarea altor spații de adrese. De exemplu, am putea dori să alocăm spațiu "
"MMIO pentru BAR-uri PCI:"

#: src/bare-metal/useful-crates/buddy_system_allocator.md
#, fuzzy
msgid "PCI BARs always have alignment equal to their size."
msgstr "BAR-urile PCI au întotdeauna o aliniere egală cu dimensiunea lor."

#: src/bare-metal/useful-crates/buddy_system_allocator.md
#, fuzzy
msgid ""
"Run the example with `cargo run` under `src/bare-metal/useful-crates/"
"allocator-example/`. (It won't run in the Playground because of the crate "
"dependency.)"
msgstr ""
"Rulați exemplul cu `cargo run` în `src/bare-metal/useful-crates/allocator-"
"example/`. (Nu va rula în Playground din cauza dependenței de crate)"

#: src/bare-metal/useful-crates/tinyvec.md
#, fuzzy
msgid ""
"Sometimes you want something which can be resized like a `Vec`, but without "
"heap allocation. [`tinyvec`](https://crates.io/crates/tinyvec) provides "
"this: a vector backed by an array or slice, which could be statically "
"allocated or on the stack, which keeps track of how many elements are used "
"and panics if you try to use more than are allocated."
msgstr ""
"Uneori doriți ceva care poate fi redimensionat ca un `Vec`, dar fără alocare "
"de heap. [`tinyvec`](https://crates.io/crates/tinyvec) oferă acest lucru: un "
"vector susținut de o matrice sau de o felie, care poate fi alocat static sau "
"pe stivă, care ține evidența numărului de elemente utilizate și intră în "
"panică dacă încercați să utilizați mai multe decât sunt alocate."

#: src/bare-metal/useful-crates/tinyvec.md
#, fuzzy
msgid ""
"`tinyvec` requires that the element type implement `Default` for "
"initialisation."
msgstr ""
"`tinyvec` necesită ca tipul de element să implementeze `Default` pentru "
"inițializare."

#: src/bare-metal/useful-crates/tinyvec.md
#, fuzzy
msgid ""
"The Rust Playground includes `tinyvec`, so this example will run fine inline."
msgstr ""
"Rust Playground include `tinyvec`, deci acest exemplu va rula bine în linie."

#: src/bare-metal/useful-crates/spin.md
#, fuzzy
msgid ""
"`std::sync::Mutex` and the other synchronisation primitives from `std::sync` "
"are not available in `core` or `alloc`. How can we manage synchronisation or "
"interior mutability, such as for sharing state between different CPUs?"
msgstr ""
"`std::sync::Mutex` și celelalte primitive de sincronizare din `std::sync` nu "
"sunt disponibile în `core` sau `alloc`. Cum putem gestiona sincronizarea sau "
"mutabilitatea interioară, cum ar fi pentru partajarea stării între diferite "
"unități centrale de procesare?"

#: src/bare-metal/useful-crates/spin.md
#, fuzzy
msgid ""
"The [`spin`](https://crates.io/crates/spin) crate provides spinlock-based "
"equivalents of many of these primitives."
msgstr ""
"Crăiasa [`spin`](https://crates.io/crates/spin) oferă echivalente bazate pe "
"spinlock pentru multe dintre aceste primitive."

#: src/bare-metal/useful-crates/spin.md
#, fuzzy
msgid "Be careful to avoid deadlock if you take locks in interrupt handlers."
msgstr ""
"Aveți grijă să evitați blocajul dacă luați blocaje în gestionarii de "
"întreruperi."

#: src/bare-metal/useful-crates/spin.md
#, fuzzy
msgid ""
"`spin` also has a ticket lock mutex implementation; equivalents of `RwLock`, "
"`Barrier` and `Once` from `std::sync`; and `Lazy` for lazy initialisation."
msgstr ""
"`spin` are, de asemenea, o implementare a unui mutex de blocare a biletului; "
"echivalenți ai lui `RwLock`, `Barrier` și `Once` din `std::sync`; și `Lazy` "
"pentru inițializare leneșă."

#: src/bare-metal/useful-crates/spin.md
#, fuzzy
msgid ""
"The [`once_cell`](https://crates.io/crates/once_cell) crate also has some "
"useful types for late initialisation with a slightly different approach to "
"`spin::once::Once`."
msgstr ""
"Crăiasa [`once_cell`](https://crates.io/crates/once_cell) are, de asemenea, "
"câteva tipuri utile pentru inițializarea târzie cu o abordare ușor diferită "
"de `spin::once::Once`."

#: src/bare-metal/useful-crates/spin.md
#, fuzzy
msgid ""
"The Rust Playground includes `spin`, so this example will run fine inline."
msgstr ""
"Rust Playground include `spin`, astfel că acest exemplu va rula fără "
"probleme în linie."

#: src/bare-metal/android.md
#, fuzzy
msgid ""
"To build a bare-metal Rust binary in AOSP, you need to use a "
"`rust_ffi_static` Soong rule to build your Rust code, then a `cc_binary` "
"with a linker script to produce the binary itself, and then a `raw_binary` "
"to convert the ELF to a raw binary ready to be run."
msgstr ""
"Pentru a construi un binar Rust de tip bare-metal în AOSP, trebuie să "
"utilizați o regulă Soong `rust_ffi_static` pentru a construi codul Rust, "
"apoi un `cc_binary` cu un script linker pentru a produce binarul propriu-zis "
"și apoi un `raw_binary` pentru a converti ELF-ul într-un binar brut gata de "
"a fi rulat."

#: src/bare-metal/android/vmbase.md
msgid "vmbase"
msgstr "vmbase"

#: src/bare-metal/android/vmbase.md
#, fuzzy
msgid ""
"For VMs running under crosvm on aarch64, the [vmbase](https://android."
"googlesource.com/platform/packages/modules/Virtualization/+/refs/heads/"
"master/vmbase/) library provides a linker script and useful defaults for the "
"build rules, along with an entry point, UART console logging and more."
msgstr ""
"Pentru mașinile virtuale care rulează sub crosvm pe aarch64, biblioteca "
"[vmbase](https://android.googlesource.com/platform/packages/modules/"
"Virtualization/+/refs/heads/master/vmbase/) oferă un script de linker și "
"valori implicite utile pentru regulile de compilare, împreună cu un punct de "
"intrare, logare a consolei UART și multe altele."

#: src/bare-metal/android/vmbase.md
#, fuzzy
msgid ""
"The `main!` macro marks your main function, to be called from the `vmbase` "
"entry point."
msgstr ""
"Macroul `main!` marchează funcția principală, care va fi apelată din punctul "
"de intrare `vmbase`."

#: src/bare-metal/android/vmbase.md
#, fuzzy
msgid ""
"The `vmbase` entry point handles console initialisation, and issues a "
"PSCI_SYSTEM_OFF to shutdown the VM if your main function returns."
msgstr ""
"Punctul de intrare `vmbase` se ocupă de inițializarea consolei și emite un "
"PSCI_SYSTEM_OFF pentru a închide VM dacă funcția principală se întoarce."

#: src/exercises/bare-metal/afternoon.md
#, fuzzy
msgid "We will write a driver for the PL031 real-time clock device."
msgstr "Vom scrie un driver pentru dispozitivul de ceas în timp real PL031."

#: src/exercises/bare-metal/afternoon.md
msgid ""
"After looking at the exercises, you can look at the [solutions](solutions-"
"afternoon.md) provided."
msgstr ""
"După ce ați studiat exercițiile, puteți consulta [soluțiile](solutions-"
"afternoon.md) furnizate."

#: src/exercises/bare-metal/rtc.md
#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "RTC driver"
msgstr "Conductor RTC"

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid ""
"The QEMU aarch64 virt machine has a [PL031](https://developer.arm.com/"
"documentation/ddi0224/c) real-time clock at 0x9010000. For this exercise, "
"you should write a driver for it."
msgstr ""
"Mașina virtuală QEMU aarch64 are un ceas în timp real [PL031](https://"
"developer.arm.com/documentation/ddi0224/c) la 0x9010000. Pentru acest "
"exercițiu, trebuie să scrieți un driver pentru acesta."

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid ""
"Use it to print the current time to the serial console. You can use the "
"[`chrono`](https://crates.io/crates/chrono) crate for date/time formatting."
msgstr ""
"Utilizați-o pentru a imprima ora curentă pe consola serială. Puteți utiliza "
"crate-ul [`chrono`](https://crates.io/crates/chrono) pentru formatarea datei/"
"orei."

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid ""
"Use the match register and raw interrupt status to busy-wait until a given "
"time, e.g. 3 seconds in the future. (Call [`core::hint::spin_loop`](https://"
"doc.rust-lang.org/core/hint/fn.spin_loop.html) inside the loop.)"
msgstr ""
"Utilizați registrul de potrivire și starea brută a întreruperii pentru a "
"aștepta ocupat până la un anumit moment, de exemplu, 3 secunde în viitor. "
"(Chemați [`core::hint::spin_loop`](https://doc.rust-lang.org/core/hint/fn."
"spin_loop.html) în interiorul buclei)"

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid ""
"_Extension if you have time:_ Enable and handle the interrupt generated by "
"the RTC match. You can use the driver provided in the [`arm-gic`](https://"
"docs.rs/arm-gic/) crate to configure the Arm Generic Interrupt Controller."
msgstr ""
"extindere dacă aveți timp:_ Activați și gestionați întreruperea generată de "
"meciul RTC. Puteți utiliza driverul furnizat în crăiasa [`arm-gic`](https://"
"docs.rs/arm-gic/) pentru a configura controlerul generic de întreruperi Arm "
"Generic Interrupt Controller."

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "Use the RTC interrupt, which is wired to the GIC as `IntId::spi(2)`."
msgstr ""
"Utilizați întreruperea RTC, care este conectată la GIC ca `IntId::spi(2)`."

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid ""
"Once the interrupt is enabled, you can put the core to sleep via `arm_gic::"
"wfi()`, which will cause the core to sleep until it receives an interrupt."
msgstr ""
"Odată ce întreruperea este activată, puteți pune nucleul în stare de veghe "
"prin intermediul `arm_gic::wfi()`, ceea ce va face ca nucleul să doarmă până "
"când va primi o întrerupere."

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and "
"look in the `rtc` directory for the following files."
msgstr ""
"Descărcați [șablonul de exerciții] (../../comprehensive-rust-exercises.zip) "
"și căutați în directorul `rtc` următoarele fișiere."

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid ""
"_src/exceptions.rs_ (you should only need to change this for the 3rd part of "
"the exercise):"
msgstr ""
"_src/exceptions.rs_ (ar trebui să fie nevoie să modificați acest lucru doar "
"pentru a treia parte a exercițiului):"

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "_src/logger.rs_ (you shouldn't need to change this):"
msgstr ""
"_src/logger.rs_ (nu ar trebui să fie nevoie să modificați acest lucru):"

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "_src/pl011.rs_ (you shouldn't need to change this):"
msgstr "_src/pl011.rs_ (nu ar trebui să fie nevoie să modificați acest lucru):"

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "_build.rs_ (you shouldn't need to change this):"
msgstr "_build.rs_ (nu ar trebui să fie nevoie să modificați acest lucru):"

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "_entry.S_ (you shouldn't need to change this):"
msgstr "_entry.S_ (nu ar trebui să fie nevoie să modificați acest lucru):"

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "_exceptions.S_ (you shouldn't need to change this):"
msgstr "_exceptions.S_ (nu ar trebui să fie nevoie să modificați acest lucru):"

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "_idmap.S_ (you shouldn't need to change this):"
msgstr "_idmap.S_ (nu ar trebui să fie nevoie să modificați acest lucru):"

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "_image.ld_ (you shouldn't need to change this):"
msgstr "_image.ld_ (nu ar trebui să fie nevoie să modificați acest lucru):"

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "_Makefile_ (you shouldn't need to change this):"
msgstr "_Makefile_ (nu ar trebui să fie nevoie să modificați acest lucru):"

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "Run the code in QEMU with `make qemu`."
msgstr "Rulați codul în QEMU cu `make qemu`."

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "Bare Metal Rust Afternoon"
msgstr "Rust bare metal După-amiază"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "([back to exercise](rtc.md))"
msgstr "([back to exercise](rtc.md))"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "_main.rs_:"
msgstr "_main.rs_:"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Base addresses of the GICv3.\n"
msgstr "/// Adresele de bază ale GICv3.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Base address of the PL031 RTC.\n"
msgstr "/// Adresa de bază a PL031 RTC.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// The IRQ used by the PL031 RTC.\n"
msgstr "/// IRQ-ul utilizat de PL031 RTC.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "\"main({:#x}, {:#x}, {:#x}, {:#x})\""
msgstr "\"main({:#x}, {:#x}, {:#x}, {:#x})\""

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"// SAFETY: `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base\n"
"    // addresses of a GICv3 distributor and redistributor respectively, and\n"
"    // nothing else accesses those address ranges.\n"
msgstr ""
"// Sigur, deoarece `GICD_BASE_ADDRESS` și `GICR_BASE_ADDRESS` sunt baza\n"
"    // adrese ale unui distribuitor și, respectiv, redistribuitor GICv3, și\n"
"    // nimic altceva nu accesează aceste intervale de adrese.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"// SAFETY: `PL031_BASE_ADDRESS` is the base address of a PL031 device, and\n"
"    // nothing else accesses that address range.\n"
msgstr ""
"// Sigur, deoarece `PL031_BASE_ADDRESS` este adresa de bază a unui "
"dispozitiv PL031,\n"
"    // și nimic altceva nu accesează acest interval de adrese.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "\"RTC: {time}\""
msgstr "\"RTC: {time}\""

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "// Wait for 3 seconds, without interrupts.\n"
msgstr "// Așteptați timp de 3 secunde, fără întreruperi.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "\"Waiting for {}\""
msgstr "\"În așteptare pentru {}\""

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "\"matched={}, interrupt_pending={}\""
msgstr "\"matched={}, interrupt_pending={}\""

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "\"Finished waiting\""
msgstr "\"Am terminat de așteptat\""

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "// Wait another 3 seconds for an interrupt.\n"
msgstr "// Așteptați încă 3 secunde pentru o întrerupere.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "_pl031.rs_:"
msgstr "_pl031.rs_:"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Data register\n"
msgstr "/// Registrul de date\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Match register\n"
msgstr "/// Registrul de corespondență\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Load register\n"
msgstr "/// Încărcați registrul\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Control register\n"
msgstr "/// Registrul de control\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Interrupt Mask Set or Clear register\n"
msgstr "/// Registru de setare sau ștergere a măștii de întrerupere\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Raw Interrupt Status\n"
msgstr "/// Starea de întrerupere brută\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Masked Interrupt Status\n"
msgstr "/// Stare de întrerupere mascată\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Interrupt Clear Register\n"
msgstr "/// Registrul de ștergere a întreruperilor\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Driver for a PL031 real-time clock.\n"
msgstr "Vom scrie un driver pentru dispozitivul de ceas în timp real PL031."

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"/// Constructs a new instance of the RTC driver for a PL031 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of "
"a\n"
"    /// PL031 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
msgstr ""
"/// Construiește o nouă instanță a driverului RTC pentru un dispozitiv PL031 "
"la nivelul\n"
"    /// adresa de bază dată.\n"
"    ///\n"
"    /// # Siguranță\n"
"    ///\n"
"    /// Adresa de bază dată trebuie să indice registrele de control MMIO ale "
"unui dispozitiv de tip\n"
"    /// dispozitiv PL031, care trebuie să fie mapate în spațiul de adrese al "
"procesului\n"
"    /// ca memorie a dispozitivului și să nu aibă alte pseudonime.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Reads the current RTC value.\n"
msgstr "/// Citește valoarea curentă a RTC.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"// SAFETY: We know that self.registers points to the control registers\n"
"        // of a PL031 device which is appropriately mapped.\n"
msgstr ""
"// Sigur, deoarece știm că self.registers indică controlul\n"
"        // registre ale unui dispozitiv PL031 care este cartografiat în mod "
"corespunzător.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"/// Writes a match value. When the RTC value matches this then an interrupt\n"
"    /// will be generated (if it is enabled).\n"
msgstr ""
"/// Scrie o valoare de potrivire. Atunci când valoarea RTC se potrivește cu "
"aceasta, se declanșează o întrerupere\n"
"    /// va fi generată (dacă este activată).\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"/// Returns whether the match register matches the RTC value, whether or "
"not\n"
"    /// the interrupt is enabled.\n"
msgstr ""
"/// Întoarce dacă registrul de potrivire se potrivește cu valoarea RTC, dacă "
"este sau nu\n"
"    /// întreruperea este activată.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"/// Returns whether there is currently an interrupt pending.\n"
"    ///\n"
"    /// This should be true if and only if `matched` returns true and the\n"
"    /// interrupt is masked.\n"
msgstr ""
"/// Returnează dacă există în prezent o întrerupere în așteptare.\n"
"    ///\n"
"    /// Acest lucru ar trebui să fie adevărat dacă și numai dacă `matched` "
"returnează true și dacă\n"
"    /// întreruperea este mascată.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"/// Sets or clears the interrupt mask.\n"
"    ///\n"
"    /// When the mask is true the interrupt is enabled; when it is false "
"the\n"
"    /// interrupt is disabled.\n"
msgstr ""
"/// Setează sau șterge masca de întrerupere.\n"
"    ///\n"
"    /// Când masca este adevărată, întreruperea este activată; când este "
"falsă, întreruperea este activată\n"
"    /// întreruperea este dezactivată.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Clears a pending interrupt, if any.\n"
msgstr "/// Șterge o întrerupere în așteptare, dacă există.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"// SAFETY: `Rtc` just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
msgstr ""
"// Sigur, deoarece conține doar un pointer către memoria dispozitivului, "
"care poate fi\n"
"// accesată din orice context.\n"

#: src/concurrency/welcome.md
#, fuzzy
msgid "Welcome to Concurrency in Rust"
msgstr "Bine ați venit la Concurrency în Rust"

#: src/concurrency/welcome.md
#, fuzzy
msgid ""
"Rust has full support for concurrency using OS threads with mutexes and "
"channels."
msgstr ""
"Rust are un suport complet pentru concurență folosind fire de execuție OS cu "
"mutexuri și canale."

#: src/concurrency/welcome.md
#, fuzzy
msgid ""
"The Rust type system plays an important role in making many concurrency bugs "
"compile time bugs. This is often referred to as _fearless concurrency_ since "
"you can rely on the compiler to ensure correctness at runtime."
msgstr ""
"Sistemul de tipuri Rust joacă un rol important în transformarea multor erori "
"de concurență în erori de timp de compilare. Acest lucru este deseori "
"denumit _concurență fără frică_, deoarece vă puteți baza pe compilator "
"pentru a asigura corectitudinea la momentul execuției."

#: src/concurrency/welcome.md
#, fuzzy
msgid "[Threads](./concurrency/threads.md) (30 minutes)"
msgstr "[Referințe partajate](./references/shared.md) (10 minute)"

#: src/concurrency/welcome.md
#, fuzzy
msgid "[Channels](./concurrency/channels.md) (20 minutes)"
msgstr "[Referințe partajate](./references/shared.md) (10 minute)"

#: src/concurrency/welcome.md
#, fuzzy
msgid "[Send and Sync](./concurrency/send-sync.md) (15 minutes)"
msgstr "[Referințe partajate](./references/shared.md) (10 minute)"

#: src/concurrency/welcome.md
#, fuzzy
msgid "[Shared State](./concurrency/shared-state.md) (30 minutes)"
msgstr "[Referințe partajate](./references/shared.md) (10 minute)"

#: src/concurrency/welcome.md
#, fuzzy
msgid "[Exercises](./concurrency/sync-exercises.md) (1 hour and 10 minutes)"
msgstr "[Exercițiu: Geometrie](./references/exercise.md) (30 minute)"

#: src/concurrency/welcome.md src/concurrency/welcome-async.md
#, fuzzy
msgid ""
"Including 10 minute breaks, this session should take about 3 hours and 20 "
"minutes"
msgstr ""
"Incluzând pauzele de 10 minute, această sesiune ar trebui să dureze "
"aproximativ 2 ore și 20 de minute"

#: src/concurrency/welcome.md
#, fuzzy
msgid ""
"Rust lets us access OS concurrency toolkit: threads, sync. primitives, etc."
msgstr ""
"Rust ne permite să accesăm setul de instrumente de simultaneitate al "
"sistemului de operare: fire, primitive de sincronizare, etc."

#: src/concurrency/welcome.md
#, fuzzy
msgid ""
"The type system gives us safety for concurrency without any special features."
msgstr ""
"Sistemul de tipuri ne oferă siguranță pentru simultaneitate fără "
"caracteristici speciale."

#: src/concurrency/welcome.md
#, fuzzy
msgid ""
"The same tools that help with \"concurrent\" access in a single thread (e."
"g., a called function that might mutate an argument or save references to it "
"to read later) save us from multi-threading issues."
msgstr ""
"Aceleași instrumente care ajută la accesul \"concurent\" într-un singur fir "
"(de exemplu, o funcție apelată care ar putea modifica un argument sau salva "
"referințe la acesta pentru a fi citite mai târziu) ne salvează de problemele "
"legate de mai multe fire de execuție."

#: src/concurrency/threads.md
#, fuzzy
msgid "[Plain Threads](./concurrency/threads/plain.md) (15 minutes)"
msgstr "[impl Trait](./generics/impl-trait.md) (5 minute)"

#: src/concurrency/threads.md
#, fuzzy
msgid "[Scoped Threads](./concurrency/threads/scoped.md) (15 minutes)"
msgstr "[Referințe partajate](./references/shared.md) (10 minute)"

#: src/concurrency/threads.md src/concurrency/shared-state.md
#: src/concurrency/async.md
#, fuzzy
msgid "This segment should take about 30 minutes"
msgstr "Acest segment ar trebui să dureze aproximativ 40 de minute"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Rust threads work similarly to threads in other languages:"
msgstr ""
"Firele de execuție din Rust funcționează în mod similar cu cele din alte "
"limbaje:"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "\"Count in thread: {i}!\""
msgstr "\"Numărătoarea în fir: {i}!\""

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "\"Main thread: {i}\""
msgstr "\"Firul principal: {i}\""

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Threads are all daemon threads, the main thread does not wait for them."
msgstr "Firele sunt toate fire de tip daemon, firul principal nu le așteaptă."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Thread panics are independent of each other."
msgstr "Panica firelor este independentă una de cealaltă."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Panics can carry a payload, which can be unpacked with `downcast_ref`."
msgstr ""
"Panicile pot transporta o sarcină utilă, care poate fi despachetată cu "
"`downcast_ref`."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Rust thread APIs look not too different from e.g. C++ ones."
msgstr ""
"API-urile Rust pentru fire de execuție nu par prea diferite de cele din C++."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Run the example."
msgstr "Rulați exemplul cu:"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid ""
"5ms timing is loose enough that main and spawned threads stay mostly in "
"lockstep."
msgstr ""
"o sincronizare de 5ms este suficient de liberă pentru ca firele principale "
"și cele generate să rămână în mare parte în același timp."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Notice that the program ends before the spawned thread reaches 10!"
msgstr ""
"Observați că programul se termină înainte ca firul generat să ajungă la 10!"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid ""
"This is because main ends the program and spawned threads do not make it "
"persist."
msgstr ""
"Acest lucru se datorează faptului că main încheie programul, iar firele de "
"execuție generate nu îl fac să persiste."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Compare to pthreads/C++ std::thread/boost::thread if desired."
msgstr ""
"Comparați cu pthreads/C++ std::thread/boost::thread dacă se dorește acest "
"lucru."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "How do we wait around for the spawned thread to complete?"
msgstr "Cum putem aștepta ca firul generat să se finalizeze?"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid ""
"[`thread::spawn`](https://doc.rust-lang.org/std/thread/fn.spawn.html) "
"returns a `JoinHandle`. Look at the docs."
msgstr ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) "
"utilizat pentru a construi o instanță implicită a unui tip."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid ""
"`JoinHandle` has a [`.join()`](https://doc.rust-lang.org/std/thread/struct."
"JoinHandle.html#method.join) method that blocks."
msgstr ""
"`JoinHandle` are o metodă [`.join()`](https://doc.rust-lang.org/std/thread/"
"struct.JoinHandle.html#method.join) care se blochează."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid ""
"Use `let handle = thread::spawn(...)` and later `handle.join()` to wait for "
"the thread to finish and have the program count all the way to 10."
msgstr ""
"Utilizați `let handle = thread::spawn(...)` și mai târziu `handle.join()` "
"pentru a aștepta ca firul să se termine."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Now what if we want to return a value?"
msgstr "Acum, ce se întâmplă dacă vrem să returnăm o valoare?"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Look at docs again:"
msgstr "Uită-te din nou la documente:"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid ""
"[`thread::spawn`](https://doc.rust-lang.org/std/thread/fn.spawn.html)'s "
"closure returns `T`"
msgstr ""
"Cu toate acestea, puteți utiliza un [scoped thread](https://doc.rust-lang."
"org/std/thread/fn.scope.html) pentru acest lucru:"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid ""
"`JoinHandle` [`.join()`](https://doc.rust-lang.org/std/thread/struct."
"JoinHandle.html#method.join) returns `thread::Result<T>`"
msgstr ""
"`JoinHandle` [`.join()`](https://doc.rust-lang.org/std/thread/struct."
"JoinHandle.html#method.join) returnează `thread::Result<T>`"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid ""
"Use the `Result` return value from `handle.join()` to get access to the "
"returned value."
msgstr ""
"Utilizați valoarea de returnare `Result` din `handle.join()` pentru a obține "
"acces la sarcina utilă de panică. Acesta este un moment bun pentru a vorbi "
"despre [`Any`](https://doc.rust-lang.org/std/any/index.html)."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Ok, what about the other case?"
msgstr "Bine, dar celălalt caz?"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Trigger a panic in the thread. Note that this doesn't panic `main`."
msgstr ""
"Declanșează o panică în firul de discuție, observați cum acest lucru nu "
"afectează `main`."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid ""
"Access the panic payload. This is a good time to talk about [`Any`](https://"
"doc.rust-lang.org/std/any/index.html)."
msgstr ""
"Utilizați valoarea de returnare `Result` din `handle.join()` pentru a obține "
"acces la sarcina utilă de panică. Acesta este un moment bun pentru a vorbi "
"despre [`Any`](https://doc.rust-lang.org/std/any/index.html)."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Now we can return values from threads! What about taking inputs?"
msgstr ""
"Acum putem returna valori de la fire! Dar cum rămâne cu preluarea intrărilor?"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Capture something by reference in the thread closure."
msgstr "Capturați ceva prin referință în închiderea firului."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "An error message indicates we must move it."
msgstr "Un mesaj de eroare indică faptul că trebuie să o mutăm."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "Move it in, see we can compute and then return a derived value."
msgstr ""
"Mutați-l înăuntru, vedeți că putem calcula și apoi returna o valoare "
"derivată."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "If we want to borrow?"
msgstr "Dacă vrem să împrumutăm?"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid ""
"Main kills child threads when it returns, but another function would just "
"return and leave them running."
msgstr ""
"Main ucide firele de execuție ale copiilor atunci când se întoarce, dar o "
"altă funcție s-ar întoarce și le-ar lăsa în funcțiune."

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "That would be stack use-after-return, which violates memory safety!"
msgstr ""
"Aceasta ar fi o utilizare a stivei după returnare, ceea ce încalcă siguranța "
"memoriei!"

#: src/concurrency/threads/plain.md
#, fuzzy
msgid "How do we avoid this? see next slide."
msgstr "Cum putem evita acest lucru? a se vedea slide-ul următor."

#: src/concurrency/threads/scoped.md
#, fuzzy
msgid "Normal threads cannot borrow from their environment:"
msgstr "Firele normale nu pot împrumuta din mediul lor:"

#: src/concurrency/threads/scoped.md
#, fuzzy
msgid ""
"However, you can use a [scoped thread](https://doc.rust-lang.org/std/thread/"
"fn.scope.html) for this:"
msgstr ""
"Cu toate acestea, puteți utiliza un [scoped thread](https://doc.rust-lang."
"org/std/thread/fn.scope.html) pentru acest lucru:"

#: src/concurrency/threads/scoped.md
#, fuzzy
msgid ""
"The reason for that is that when the `thread::scope` function completes, all "
"the threads are guaranteed to be joined, so they can return borrowed data."
msgstr ""
"Motivul este că, atunci când funcția `thread::scope` se finalizează, toate "
"firele sunt garantate a fi unite, astfel încât pot returna date împrumutate."

#: src/concurrency/threads/scoped.md
#, fuzzy
msgid ""
"Normal Rust borrowing rules apply: you can either borrow mutably by one "
"thread, or immutably by any number of threads."
msgstr ""
"Se aplică regulile normale de împrumut Rust: puteți împrumuta fie în mod "
"mutabil de către un singur fir, fie în mod imuabil de către orice număr de "
"fire."

#: src/concurrency/channels.md
#, fuzzy
msgid ""
"[Senders and Receivers](./concurrency/channels/senders-receivers.md) (10 "
"minutes)"
msgstr "[Referințe partajate](./references/shared.md) (10 minute)"

#: src/concurrency/channels.md
#, fuzzy
msgid "[Unbounded Channels](./concurrency/channels/unbounded.md) (2 minutes)"
msgstr "[Uniuni](./unsafe-rust/unions.md) (5 minute)"

#: src/concurrency/channels.md
#, fuzzy
msgid "[Bounded Channels](./concurrency/channels/bounded.md) (10 minutes)"
msgstr "[Limite ale trăsăturilor](./generics/trait-bounds.md) (10 minute)"

#: src/concurrency/channels.md src/concurrency/async-control-flow.md
msgid "This segment should take about 20 minutes"
msgstr "Acest segment ar trebui să dureze aproximativ 20 de minute"

#: src/concurrency/channels/senders-receivers.md
#, fuzzy
msgid ""
"Rust channels have two parts: a `Sender<T>` and a `Receiver<T>`. The two "
"parts are connected via the channel, but you only see the end-points."
msgstr ""
"Canalele Rust au două părți: un `Sender<T>` și un `Receiver<T>`. Cele două "
"părți sunt conectate prin intermediul canalului, dar nu se văd decât "
"punctele finale."

#: src/concurrency/channels/senders-receivers.md
#, fuzzy
msgid "\"Received: {:?}\""
msgstr "\"Recepționat: {:?}\""

#: src/concurrency/channels/senders-receivers.md
#, fuzzy
msgid ""
"`mpsc` stands for Multi-Producer, Single-Consumer. `Sender` and `SyncSender` "
"implement `Clone` (so you can make multiple producers) but `Receiver` does "
"not."
msgstr ""
"`mpsc` înseamnă Multi-Producer, Single-Consumer. `Sender` și `SyncSender` "
"implementează `Clone` (astfel încât să puteți face mai mulți producători), "
"dar `Receiver` nu o face."

#: src/concurrency/channels/senders-receivers.md
#, fuzzy
msgid ""
"`send()` and `recv()` return `Result`. If they return `Err`, it means the "
"counterpart `Sender` or `Receiver` is dropped and the channel is closed."
msgstr ""
"`send()` și `recv()` returnează `Result`. Dacă acestea returnează `Err`, "
"înseamnă că omologul `Sender` sau `Receiver` este abandonat și canalul este "
"închis."

#: src/concurrency/channels/unbounded.md
#, fuzzy
msgid "You get an unbounded and asynchronous channel with `mpsc::channel()`:"
msgstr "Obțineți un canal nemărginit și asincron cu `mpsc::channel()`:"

#: src/concurrency/channels/unbounded.md src/concurrency/channels/bounded.md
#, fuzzy
msgid "\"Message {i}\""
msgstr "\"Mesaj {i}\""

#: src/concurrency/channels/unbounded.md src/concurrency/channels/bounded.md
#, fuzzy
msgid "\"{thread_id:?}: sent Message {i}\""
msgstr "\"{thread_id:?}: mesaj trimis {i}\""

#: src/concurrency/channels/unbounded.md src/concurrency/channels/bounded.md
#, fuzzy
msgid "\"{thread_id:?}: done\""
msgstr "\"{thread_id:?}: terminat\""

#: src/concurrency/channels/unbounded.md src/concurrency/channels/bounded.md
#, fuzzy
msgid "\"Main: got {msg}\""
msgstr "\"Main: got {msg}\""

#: src/concurrency/channels/bounded.md
#, fuzzy
msgid ""
"With bounded (synchronous) channels, `send` can block the current thread:"
msgstr "Cu canale limitate (sincrone), `send` poate bloca firul curent:"

#: src/concurrency/channels/bounded.md
#, fuzzy
msgid ""
"Calling `send` will block the current thread until there is space in the "
"channel for the new message. The thread can be blocked indefinitely if there "
"is nobody who reads from the channel."
msgstr ""
"Apelul la `send` va bloca firul curent până când va exista spațiu în canal "
"pentru noul mesaj. Firul poate fi blocat la nesfârșit dacă nimeni nu citește "
"de pe canal."

#: src/concurrency/channels/bounded.md
#, fuzzy
msgid ""
"A call to `send` will abort with an error (that is why it returns `Result`) "
"if the channel is closed. A channel is closed when the receiver is dropped."
msgstr ""
"Un apel la `send` va eșua cu o eroare (de aceea returnează `Result`) dacă "
"canalul este închis. Un canal este închis atunci când receptorul este "
"abandonat."

#: src/concurrency/channels/bounded.md
#, fuzzy
msgid ""
"A bounded channel with a size of zero is called a \"rendezvous channel\". "
"Every send will block the current thread until another thread calls `recv`."
msgstr ""
"Un canal delimitat cu dimensiunea zero se numește \"canal de întâlnire\". "
"Fiecare trimitere va bloca firul curent până când un alt fir va apela `read`."

#: src/concurrency/send-sync.md
#, fuzzy
msgid "[Marker Traits](./concurrency/send-sync/marker-traits.md) (2 minutes)"
msgstr "[Trăsături nesigure](./unsafe-rust/unsafe-traits.md) (5 minute)"

#: src/concurrency/send-sync.md
#, fuzzy
msgid "[Send](./concurrency/send-sync/send.md) (2 minutes)"
msgstr "[Șiruri](./types-and-values/strings.md) (10 minute)"

#: src/concurrency/send-sync.md
#, fuzzy
msgid "[Sync](./concurrency/send-sync/sync.md) (2 minutes)"
msgstr "[Șiruri](./types-and-values/strings.md) (10 minute)"

#: src/concurrency/send-sync.md
#, fuzzy
msgid "[Examples](./concurrency/send-sync/examples.md) (10 minutes)"
msgstr ""
"[Tupluri și vectori](./tuples-and-arrays/tuples-and-arrays.md)  (10 minute)"

#: src/concurrency/send-sync/marker-traits.md
#, fuzzy
msgid ""
"How does Rust know to forbid shared access across threads? The answer is in "
"two traits:"
msgstr ""
"Cum știe Rust să interzică accesul partajat între fire de execuție? "
"Răspunsul se află în două trăsături:"

#: src/concurrency/send-sync/marker-traits.md
#, fuzzy
msgid ""
"[`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html): a type `T` "
"is `Send` if it is safe to move a `T` across a thread boundary."
msgstr ""
"[`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html): un tip `T` "
"este `Send` dacă este sigur să muți un `T` peste o limită de fir."

#: src/concurrency/send-sync/marker-traits.md
#, fuzzy
msgid ""
"[`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html): a type `T` "
"is `Sync` if it is safe to move a `&T` across a thread boundary."
msgstr ""
"[`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html): un tip `T` "
"este `Sync` dacă este sigur să muți un `&T` peste o limită de fir."

#: src/concurrency/send-sync/marker-traits.md
#, fuzzy
msgid ""
"`Send` and `Sync` are [unsafe traits](../../unsafe-rust/unsafe-traits.md). "
"The compiler will automatically derive them for your types as long as they "
"only contain `Send` and `Sync` types. You can also implement them manually "
"when you know it is valid."
msgstr ""
"`Send` și `Sync` sunt [trăsături nesigure](../unsafe/unsafe-traits.md). "
"Compilatorul le va deriva în mod automat pentru tipurile dvs. atâta timp cât "
"acestea conțin doar tipurile `Send` și `Sync`. De asemenea, le puteți "
"implementa manual atunci când știți că este valabil."

#: src/concurrency/send-sync/marker-traits.md
#, fuzzy
msgid ""
"One can think of these traits as markers that the type has certain thread-"
"safety properties."
msgstr ""
"Aceste trăsături pot fi considerate ca fiind indicatoare ale faptului că "
"tipul are anumite proprietăți de siguranță a firelor."

#: src/concurrency/send-sync/marker-traits.md
#, fuzzy
msgid "They can be used in the generic constraints as normal traits."
msgstr ""
"Acestea pot fi utilizate în cadrul constrângerilor generice ca și trăsături "
"normale."

#: src/concurrency/send-sync/send.md
#, fuzzy
msgid ""
"A type `T` is [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html) "
"if it is safe to move a `T` value to another thread."
msgstr ""
"Un tip `T` este [`Send`](https://doc.rust-lang.org/std/marker/trait.Send."
"html) dacă este sigur să muți o valoare `T` către un alt fir."

#: src/concurrency/send-sync/send.md
#, fuzzy
msgid ""
"The effect of moving ownership to another thread is that _destructors_ will "
"run in that thread. So the question is when you can allocate a value in one "
"thread and deallocate it in another."
msgstr ""
"Efectul mutării proprietății către un alt fir este că _destructori_ vor rula "
"în acel fir. Așadar, întrebarea este când puteți aloca o valoare într-un fir "
"și o puteți dezaloca în alt fir."

#: src/concurrency/send-sync/send.md
#, fuzzy
msgid ""
"As an example, a connection to the SQLite library must only be accessed from "
"a single thread."
msgstr ""
"De exemplu, o conexiune la biblioteca SQLite trebuie să fie accesată numai "
"de pe un singur fir de execuție."

#: src/concurrency/send-sync/sync.md
#, fuzzy
msgid ""
"A type `T` is [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) "
"if it is safe to access a `T` value from multiple threads at the same time."
msgstr ""
"Un tip `T` este [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync."
"html) dacă este sigur să accesezi o valoare `T` din mai multe fire de "
"execuție în același timp."

#: src/concurrency/send-sync/sync.md
#, fuzzy
msgid "More precisely, the definition is:"
msgstr "Mai exact, definiția este:"

#: src/concurrency/send-sync/sync.md
#, fuzzy
msgid "`T` is `Sync` if and only if `&T` is `Send`"
msgstr "`T` este `Sync` dacă și numai dacă `&T` este `Send`"

#: src/concurrency/send-sync/sync.md
#, fuzzy
msgid ""
"This statement is essentially a shorthand way of saying that if a type is "
"thread-safe for shared use, it is also thread-safe to pass references of it "
"across threads."
msgstr ""
"Această afirmație este, în esență, un mod prescurtat de a spune că, dacă un "
"tip este sigur pentru utilizarea partajată, este, de asemenea, sigur pentru "
"a trece referințe ale acestuia între fire."

#: src/concurrency/send-sync/sync.md
#, fuzzy
msgid ""
"This is because if a type is Sync it means that it can be shared across "
"multiple threads without the risk of data races or other synchronization "
"issues, so it is safe to move it to another thread. A reference to the type "
"is also safe to move to another thread, because the data it references can "
"be accessed from any thread safely."
msgstr ""
"Acest lucru se datorează faptului că, dacă un tip este Sync, înseamnă că "
"poate fi partajat între mai multe fire de execuție fără riscul de curse de "
"date sau alte probleme de sincronizare, astfel încât este sigur să îl mutați "
"pe un alt fir de execuție. O referință la tip este, de asemenea, sigură "
"pentru a fi mutată în alt fir, deoarece datele la care face referire pot fi "
"accesate în siguranță din orice fir."

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`Send + Sync`"
msgstr "`Send + Sync`"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "Most types you come across are `Send + Sync`:"
msgstr "Majoritatea tipurilor pe care le întâlniți sunt de tip `Send + Sync`:"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`i8`, `f32`, `bool`, `char`, `&str`, ..."
msgstr "`i8`, `f32`, `bool`, `char`, `&str`, ..."

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ..."
msgstr "`(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ..."

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`String`, `Option<T>`, `Vec<T>`, `Box<T>`, ..."
msgstr "`String`, `Option<T>`, `Vec<T>`, `Box<T>`, ..."

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`Arc<T>`: Explicitly thread-safe via atomic reference count."
msgstr ""
"`Arc<T>`: În mod explicit, thread-safe prin numărul de referințe atomice."

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`Mutex<T>`: Explicitly thread-safe via internal locking."
msgstr "`Mutex<T>`: În mod explicit, thread-safe prin blocare internă."

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`mpsc::Sender<T>`: As of 1.72.0."
msgstr "`mpsc::Sender<T>`"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`AtomicBool`, `AtomicU8`, ...: Uses special atomic instructions."
msgstr ""
"`AtomicBool`, `AtomicU8`, ....: Utilizează instrucțiuni atomice speciale."

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid ""
"The generic types are typically `Send + Sync` when the type parameters are "
"`Send + Sync`."
msgstr ""
"Tipurile generice sunt de obicei `Send + Sync` atunci când parametrii de tip "
"sunt `Send + Sync`."

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`Send + !Sync`"
msgstr "`Send + !Sync`"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid ""
"These types can be moved to other threads, but they're not thread-safe. "
"Typically because of interior mutability:"
msgstr ""
"Aceste tipuri pot fi mutate în alte fire de execuție, dar nu sunt sigure "
"pentru fire de execuție. De obicei, din cauza mutabilității interioare:"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`mpsc::Receiver<T>`"
msgstr "`mpsc::Receiver<T>`"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`Cell<T>`"
msgstr "`Celula<T>`"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`RefCell<T>`"
msgstr "`RefCell<T>`"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`!Send + Sync`"
msgstr "`!Send + Sync`"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid ""
"These types are thread-safe, but they cannot be moved to another thread:"
msgstr ""
"Aceste tipuri sunt sigure pentru firul de execuție, dar nu pot fi mutate în "
"alt fir de execuție:"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid ""
"`MutexGuard<T: Sync>`: Uses OS level primitives which must be deallocated on "
"the thread which created them."
msgstr ""
"`MutexGuard<T: Sync>`: Utilizează primitive la nivelul sistemului de operare "
"care trebuie să fie dezalocate pe firul care le-a creat."

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "`!Send + !Sync`"
msgstr "`!Send +Sync`"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid "These types are not thread-safe and cannot be moved to other threads:"
msgstr ""
"Aceste tipuri nu sunt sigure pentru fire de execuție și nu pot fi mutate în "
"alte fire de execuție:"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid ""
"`Rc<T>`: each `Rc<T>` has a reference to an `RcBox<T>`, which contains a non-"
"atomic reference count."
msgstr ""
"`Rc<T>`: fiecare `Rc<T>` are o referință la un `RcBox<T>`, care conține un "
"număr de referințe neatomice."

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid ""
"`*const T`, `*mut T`: Rust assumes raw pointers may have special concurrency "
"considerations."
msgstr ""
"`*const T`, `*mut T`: Rust presupune că indicatoarele brute pot avea "
"considerații speciale privind concurența."

#: src/concurrency/shared-state.md
#, fuzzy
msgid "[Arc](./concurrency/shared-state/arc.md) (5 minutes)"
msgstr "[Rc](./smart-pointers/rc.md) (5 minute)"

#: src/concurrency/shared-state.md
#, fuzzy
msgid "[Mutex](./concurrency/shared-state/mutex.md) (15 minutes)"
msgstr "[Nesigur](./unsafe-rust/unsafe.md) (5 minute)"

#: src/concurrency/shared-state.md
#, fuzzy
msgid "[Example](./concurrency/shared-state/example.md) (10 minutes)"
msgstr "[Nesigur](./unsafe-rust/unsafe.md) (5 minute)"

#: src/concurrency/shared-state/arc.md
#, fuzzy
msgid ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html) allows shared "
"read-only access via `Arc::clone`:"
msgstr ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html) permite "
"accesul partajat numai pentru citire prin intermediul `Arc::clone`:"

#: src/concurrency/shared-state/arc.md
#, fuzzy
msgid "\"{thread_id:?}: {v:?}\""
msgstr "\"{thread_id:?}: {v:?}\""

#: src/concurrency/shared-state/arc.md src/concurrency/shared-state/example.md
#, fuzzy
msgid "\"v: {v:?}\""
msgstr "\"v: {v:?}\""

#: src/concurrency/shared-state/arc.md
#, fuzzy
msgid ""
"`Arc` stands for \"Atomic Reference Counted\", a thread safe version of `Rc` "
"that uses atomic operations."
msgstr ""
"`Arc` este acronimul de la \"Atomic Reference Counted\", o versiune thread "
"safe a `Rc` care utilizează operații atomice."

#: src/concurrency/shared-state/arc.md
#, fuzzy
msgid ""
"`Arc<T>` implements `Clone` whether or not `T` does. It implements `Send` "
"and `Sync` if and only if `T` implements them both."
msgstr ""
"`Arc<T>` implementează `Clone` indiferent dacă `T` o face sau nu. "
"Implementează `Send` și `Sync` dacă și numai dacă `T` le implementează pe "
"amândouă."

#: src/concurrency/shared-state/arc.md
#, fuzzy
msgid ""
"`Arc::clone()` has the cost of atomic operations that get executed, but "
"after that the use of the `T` is free."
msgstr ""
"`Arc::clone()` are costul operațiunilor atomice care se execută, dar după "
"aceea utilizarea lui `T` este gratuită."

#: src/concurrency/shared-state/arc.md
#, fuzzy
msgid ""
"Beware of reference cycles, `Arc` does not use a garbage collector to detect "
"them."
msgstr ""
"Atenție la ciclurile de referință, `Arc` nu folosește un garbage collector "
"pentru a le detecta."

#: src/concurrency/shared-state/arc.md
#, fuzzy
msgid "`std::sync::Weak` can help."
msgstr "`std::sync::Weak` poate fi de ajutor."

#: src/concurrency/shared-state/mutex.md
#, fuzzy
msgid ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html) ensures "
"mutual exclusion _and_ allows mutable access to `T` behind a read-only "
"interface (another form of [interior mutability](../../borrowing/interior-"
"mutability)):"
msgstr ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html) asigură "
"excluderea reciprocă _și_ permite accesul mutabil la `T` în spatele unei "
"interfețe de numai citire:"

#: src/concurrency/shared-state/mutex.md
#, fuzzy
msgid "\"v: {:?}\""
msgstr "\"Magnitudinea lui {v:?} după normalizare: {}\""

#: src/concurrency/shared-state/mutex.md
#, fuzzy
msgid ""
"Notice how we have a [`impl<T: Send> Sync for Mutex<T>`](https://doc.rust-"
"lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E) blanket "
"implementation."
msgstr ""
"Observați cum avem o implementare de pătură [`impl<T: Send> Sync for "
"Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-Sync-"
"for-Mutex%3CT%3E)."

#: src/concurrency/shared-state/mutex.md
#, fuzzy
msgid ""
"`Mutex` in Rust looks like a collection with just one element --- the "
"protected data."
msgstr ""
"`Mutex` în Rust arată ca o colecție cu un singur element - datele protejate."

#: src/concurrency/shared-state/mutex.md
#, fuzzy
msgid ""
"It is not possible to forget to acquire the mutex before accessing the "
"protected data."
msgstr ""
"Nu este posibil să se uite să se achiziționeze mutexul înainte de a accesa "
"datele protejate."

#: src/concurrency/shared-state/mutex.md
#, fuzzy
msgid ""
"You can get an `&mut T` from an `&Mutex<T>` by taking the lock. The "
"`MutexGuard` ensures that the `&mut T` doesn't outlive the lock being held."
msgstr ""
"Puteți obține un `&amp;mut T` dintr-un `&amp;Mutex<T>` prin luarea unui "
"blocaj. `MutexGuard` se asigură că `&amp;mut T` nu supraviețuiește mai mult "
"decât blocajul deținut."

#: src/concurrency/shared-state/mutex.md
#, fuzzy
msgid ""
"`Mutex<T>` implements both `Send` and `Sync` iff (if and only if) `T` "
"implements `Send`."
msgstr ""
"`Mutex<T>` implementează atât `Send` cât și `Sync` dacă (dacă și numai dacă) "
"`T` implementează `Send`."

#: src/concurrency/shared-state/mutex.md
#, fuzzy
msgid "A read-write lock counterpart: `RwLock`."
msgstr "O contraparte de blocare la citire-scriere - `RwLock`."

#: src/concurrency/shared-state/mutex.md
#, fuzzy
msgid "Why does `lock()` return a `Result`?"
msgstr "De ce `lock()` returnează `Result`? "

#: src/concurrency/shared-state/mutex.md
#, fuzzy
msgid ""
"If the thread that held the `Mutex` panicked, the `Mutex` becomes "
"\"poisoned\" to signal that the data it protected might be in an "
"inconsistent state. Calling `lock()` on a poisoned mutex fails with a "
"[`PoisonError`](https://doc.rust-lang.org/std/sync/struct.PoisonError.html). "
"You can call `into_inner()` on the error to recover the data regardless."
msgstr ""
"În cazul în care firul care deținea `Mutex` intră în panică, `Mutex` devine "
"\"otrăvit\" pentru a semnala că datele pe care le protejează ar putea fi "
"într-o stare inconsistentă. Apelul la `lock()` pe un mutex otrăvit eșuează "
"cu un [`PoisonError`](https://doc.rust-lang.org/std/sync/struct.PoisonError."
"html). Puteți apela `into_inner()` la eroare pentru a recupera datele "
"indiferent de situație."

#: src/concurrency/shared-state/example.md
#, fuzzy
msgid "Let us see `Arc` and `Mutex` in action:"
msgstr "Să vedem `Arc` și `Mutex` în acțiune:"

#: src/concurrency/shared-state/example.md
#, fuzzy
msgid "// use std::sync::{Arc, Mutex};\n"
msgstr "// folosiți std::sync::{Arc, Mutex};\n"

#: src/concurrency/shared-state/example.md
msgid "Possible solution:"
msgstr "O posibilă soluție:"

#: src/concurrency/shared-state/example.md
msgid "Notable parts:"
msgstr "Părți notabile:"

#: src/concurrency/shared-state/example.md
#, fuzzy
msgid ""
"`v` is wrapped in both `Arc` and `Mutex`, because their concerns are "
"orthogonal."
msgstr ""
"`v` este înfășurat atât în `Arc` cât și în `Mutex`, deoarece preocupările "
"lor sunt ortogonale."

#: src/concurrency/shared-state/example.md
#, fuzzy
msgid ""
"Wrapping a `Mutex` in an `Arc` is a common pattern to share mutable state "
"between threads."
msgstr ""
"Înfășurarea unui `Mutex` într-un `Arc` este un model comun de partajare a "
"stării mutabile între fire."

#: src/concurrency/shared-state/example.md
#, fuzzy
msgid ""
"`v: Arc<_>` needs to be cloned as `v2` before it can be moved into another "
"thread. Note `move` was added to the lambda signature."
msgstr ""
"`v: Arc<_>` trebuie să fie clonat ca `v2` înainte de a putea fi mutat într-"
"un alt fir de execuție. Rețineți că `move` a fost adăugat la semnătura "
"lambda."

#: src/concurrency/shared-state/example.md
#, fuzzy
msgid ""
"Blocks are introduced to narrow the scope of the `LockGuard` as much as "
"possible."
msgstr ""
"Blocurile sunt introduse pentru a restrânge cât mai mult posibil domeniul de "
"aplicare al `LockGuard`."

#: src/concurrency/sync-exercises.md
#, fuzzy
msgid ""
"[Dining Philosophers](./concurrency/sync-exercises/dining-philosophers.md) "
"(20 minutes)"
msgstr ""
"[Dining Philosophers](./concurrency/sync-exercises/dining-philosophers.md) "
"(20 minute)"

#: src/concurrency/sync-exercises.md
#, fuzzy
msgid ""
"[Multi-threaded Link Checker](./concurrency/sync-exercises/link-checker.md) "
"(20 minutes)"
msgstr ""
"[Verificator de legături cu mai multe fire](./concurrency/sync-exercises/"
"link-checker.md) (20 minute)"

#: src/concurrency/sync-exercises.md
#, fuzzy
msgid "[Solutions](./concurrency/sync-exercises/solutions.md) (30 minutes)"
msgstr "[Șiruri](./types-and-values/strings.md) (10 minute)"

#: src/concurrency/sync-exercises.md src/concurrency/async-exercises.md
#, fuzzy
msgid "This segment should take about 1 hour and 10 minutes"
msgstr "Acest segment ar trebui să dureze aproximativ 1 oră și 10 minute"

#: src/concurrency/sync-exercises/dining-philosophers.md
#, fuzzy
msgid "The dining philosophers problem is a classic problem in concurrency:"
msgstr ""
"Problema filozofilor care servesc masa este o problemă clasică în domeniul "
"concurenței:"

#: src/concurrency/sync-exercises/dining-philosophers.md
#, fuzzy
msgid ""
"Five philosophers dine together at the same table. Each philosopher has "
"their own place at the table. There is a fork between each plate. The dish "
"served is a kind of spaghetti which has to be eaten with two forks. Each "
"philosopher can only alternately think and eat. Moreover, a philosopher can "
"only eat their spaghetti when they have both a left and right fork. Thus two "
"forks will only be available when their two nearest neighbors are thinking, "
"not eating. After an individual philosopher finishes eating, they will put "
"down both forks."
msgstr ""
"Cinci filozofi iau masa împreună la aceeași masă. Fiecare filozof are "
"propriul loc la masă. Între fiecare farfurie se află câte o furculiță. Felul "
"de mâncare servit este un fel de spaghete care trebuie mâncate cu două "
"furculițe. Fiecare filozof nu poate decât să gândească și să mănânce "
"alternativ. În plus, un filozof poate mânca spaghetele doar dacă are atât "
"furculița din stânga, cât și cea din dreapta. Astfel, cele două furculițe "
"vor fi disponibile doar atunci când cei doi vecini cei mai apropiați "
"gândesc, nu mănâncă. După ce un filozof individual termină de mâncat, el va "
"pune jos ambele furculițe."

#: src/concurrency/sync-exercises/dining-philosophers.md
#, fuzzy
msgid ""
"You will need a local [Cargo installation](../../cargo/running-locally.md) "
"for this exercise. Copy the code below to a file called `src/main.rs`, fill "
"out the blanks, and test that `cargo run` does not deadlock:"
msgstr ""
"Veți avea nevoie de o [instalare Cargo] locală (../../cargo/running-locally."
"md) pentru acest exercițiu. Copiați codul de mai jos într-un fișier numit "
"`src/main.rs`, completați spațiile goale și testați dacă `cargo run` nu se "
"blochează:"

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/dining-philosophers.md
#, fuzzy
msgid ""
"// left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
msgstr ""
"// left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/sync-exercises/solutions.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "\"Eureka! {} has a new idea!\""
msgstr "\"Eureka! {} are o idee nouă!\""

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "// Pick up forks...\n"
msgstr "// Ridicați furculițele...\n"

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/sync-exercises/solutions.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "\"{} is eating...\""
msgstr "\"{} mănâncă...\""

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/sync-exercises/solutions.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "\"Socrates\""
msgstr "Lăzi HAL"

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/sync-exercises/solutions.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "\"Hypatia\""
msgstr "\"Hypatia\""

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/sync-exercises/solutions.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "\"Plato\""
msgstr "\"Platon\""

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/sync-exercises/solutions.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "\"Aristotle\""
msgstr "\"Aristotel\""

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/sync-exercises/solutions.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "\"Pythagoras\""
msgstr "\"Pythagoras\""

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "// Create forks\n"
msgstr "// Creați furci\n"

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "// Create philosophers\n"
msgstr "// Creați filosofi\n"

#: src/concurrency/sync-exercises/dining-philosophers.md
#, fuzzy
msgid "// Make each of them think and eat 100 times\n"
msgstr ""
"// Fă-i pe fiecare dintre ei să gândească și să mănânce de 100 de ori\n"

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "// Output their thoughts\n"
msgstr "// Emiteți gândurile lor\n"

#: src/concurrency/sync-exercises/dining-philosophers.md
#, fuzzy
msgid "You can use the following `Cargo.toml`:"
msgstr "Puteți utiliza următorul `Cargo.toml`:"

#: src/concurrency/sync-exercises/dining-philosophers.md
#, fuzzy
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"```"
msgstr ""
"```toml\n"
"[pachet]\n"
"name = \"dining-philosophers\"\n"
"versiune = \"0.1.0\"\n"
"edition = \"2021\"\n"
"```"

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid ""
"Let us use our new knowledge to create a multi-threaded link checker. It "
"should start at a webpage and check that links on the page are valid. It "
"should recursively check other pages on the same domain and keep doing this "
"until all pages have been validated."
msgstr ""
"Să folosim noile noastre cunoștințe pentru a crea un verificator de legături "
"cu mai multe fire. Acesta ar trebui să pornească de la o pagină web și să "
"verifice dacă legăturile de pe pagină sunt valide. Ar trebui să verifice în "
"mod recursiv alte pagini din același domeniu și să continue să facă acest "
"lucru până când toate paginile sunt validate."

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid ""
"For this, you will need an HTTP client such as [`reqwest`](https://docs.rs/"
"reqwest/). You will also need a way to find links, we can use [`scraper`]"
"(https://docs.rs/scraper/). Finally, we'll need some way of handling errors, "
"we will use [`thiserror`](https://docs.rs/thiserror/)."
msgstr ""
"Pentru aceasta, veți avea nevoie de un client HTTP, cum ar fi [`reqwest`]"
"(https://docs.rs/reqwest/). De asemenea, veți avea nevoie de o modalitate de "
"a găsi link-uri, putem folosi [`scraper`](https://docs.rs/scraper/). În cele "
"din urmă, vom avea nevoie de o modalitate de gestionare a erorilor, vom "
"folosi [`thiserror`](https://docs.rs/thiserror/)."

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid "Create a new Cargo project and `reqwest` it as a dependency with:"
msgstr "Creați un nou proiect Cargo și adăugați următoarele dependențe:"

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid ""
"If `cargo add` fails with `error: no such subcommand`, then please edit the "
"`Cargo.toml` file by hand. Add the dependencies listed below."
msgstr ""
"Dacă `cargo add` eșuează cu `error: no such subcommand`, atunci vă rugăm să "
"editați manual fișierul `Cargo.toml`. Adăugați dependențele enumerate mai "
"jos."

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid ""
"The `cargo add` calls will update the `Cargo.toml` file to look like this:"
msgstr ""
"Apelurile `cargo add` vor actualiza fișierul `Cargo.toml` astfel încât să "
"arate astfel:"

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid ""
"```toml\n"
"[package]\n"
"name = \"link-checker\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-"
"tls\"] }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"
msgstr ""
"```toml\n"
"[pachet]\n"
"name = \"link-checker\"\n"
"versiune = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependențe]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-"
"tls\"]] } }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid ""
"You can now download the start page. Try with a small site such as `https://"
"www.google.org/`."
msgstr ""
"Acum puteți descărca pagina de start. Încercați cu un site mic, cum ar fi "
"`https://www.google.org/`."

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid "Your `src/main.rs` file should look something like this:"
msgstr "Fișierul dvs. `src/main.rs` ar trebui să arate cam așa:"

#: src/concurrency/sync-exercises/link-checker.md
#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "\"request error: {0}\""
msgstr "\"eroare de solicitare: {0}\""

#: src/concurrency/sync-exercises/link-checker.md
#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "\"bad http response: {0}\""
msgstr "\"bad http response: {0}\""

#: src/concurrency/sync-exercises/link-checker.md
#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "\"Checking {:#}\""
msgstr "Verificarea împrumuturilor"

#: src/concurrency/sync-exercises/link-checker.md
#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "\"href\""
msgstr "\"href\""

#: src/concurrency/sync-exercises/link-checker.md
#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "\"On {base_url:#}: ignored unparsable {href:?}: {err}\""
msgstr "\"On {base_url:#}: ignorat neparsabil {href:?}: {err}\""

#: src/concurrency/sync-exercises/link-checker.md
#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "\"https://www.google.org\""
msgstr "\"https://www.google.org\""

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid "\"Links: {links:#?}\""
msgstr "\"Link-uri: {links:#?}\""

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid "\"Could not extract links: {err:#}\""
msgstr "\"Could not extract links: {err:#}\""

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid "Run the code in `src/main.rs` with"
msgstr "Rulați codul din `src/main.rs` cu"

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid ""
"Use threads to check the links in parallel: send the URLs to be checked to a "
"channel and let a few threads check the URLs in parallel."
msgstr ""
"Folosiți fire de execuție pentru a verifica legăturile în paralel: trimiteți "
"URL-urile care trebuie verificate pe un canal și lăsați câteva fire de "
"execuție să verifice URL-urile în paralel."

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid ""
"Extend this to recursively extract links from all pages on the `www.google."
"org` domain. Put an upper limit of 100 pages or so so that you don't end up "
"being blocked by the site."
msgstr ""
"Extindeți acest lucru pentru a extrage în mod recursiv legăturile din toate "
"paginile de pe domeniul `www.google.org`. Puneți o limită superioară de "
"aproximativ 100 de pagini, astfel încât să nu ajungeți să fiți blocat de "
"site."

#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "\"{} is trying to eat\""
msgstr "\"{} încearcă să mănânce\""

#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid ""
"// To avoid a deadlock, we have to break the symmetry\n"
"        // somewhere. This will swap the forks without deinitializing\n"
"        // either of them.\n"
msgstr ""
"// Pentru a evita un blocaj, trebuie să rupem simetria\n"
"            // undeva. Acest lucru va schimba bifurcațiile de fire de "
"execuție \n"
"           //fără a dezinitializa niciuna dintre ele.\n"

#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "\"{thought}\""
msgstr "\"{thought}\""

#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "Link Checker"
msgstr "Verificator de legături"

#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid ""
"/// Determine whether links within the given page should be extracted.\n"
msgstr "/// Determină dacă legăturile din pagina dată trebuie extrase.\n"

#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid ""
"/// Mark the given page as visited, returning false if it had already\n"
"    /// been visited.\n"
msgstr ""
"/// Marchează pagina dată ca fiind vizitată, returnând false dacă a fost "
"deja vizitată\n"
"    /// fost vizitată.\n"

#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "// The sender got dropped. No more commands coming in.\n"
msgstr "// Expeditorul a fost abandonat. Nu mai vin comenzi.\n"

#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "\"Got crawling error: {:#}\""
msgstr "\"Am primit o eroare de crawling: {:#}\""

#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "\"Bad URLs: {:#?}\""
msgstr "\"URL-uri proaste: {:#?}\""

#: src/concurrency/welcome-async.md
#, fuzzy
msgid ""
"\"Async\" is a concurrency model where multiple tasks are executed "
"concurrently by executing each task until it would block, then switching to "
"another task that is ready to make progress. The model allows running a "
"larger number of tasks on a limited number of threads. This is because the "
"per-task overhead is typically very low and operating systems provide "
"primitives for efficiently identifying I/O that is able to proceed."
msgstr ""
"\"Async\" este un model de simultaneitate în care mai multe sarcini sunt "
"executate simultan prin executarea fiecărei sarcini până când se blochează, "
"apoi se trece la o altă sarcină care este gata să progreseze. Acest model "
"permite rularea unui număr mai mare de sarcini pe un număr limitat de fire "
"de execuție. Acest lucru se datorează faptului că, de obicei, costurile de "
"operare per sarcină sunt foarte scăzute, iar sistemele de operare oferă "
"primitive pentru identificarea eficientă a I/O care pot continua."

#: src/concurrency/welcome-async.md
#, fuzzy
msgid ""
"Rust's asynchronous operation is based on \"futures\", which represent work "
"that may be completed in the future. Futures are \"polled\" until they "
"signal that they are complete."
msgstr ""
"Funcționarea asincronă a Rust se bazează pe \"futures\", care reprezintă "
"munca ce poate fi finalizată în viitor. Futures sunt \"interogate\" până "
"când semnalează că sunt finalizate."

#: src/concurrency/welcome-async.md
#, fuzzy
msgid ""
"Futures are polled by an async runtime, and several different runtimes are "
"available."
msgstr ""
"Futures sunt interogate de un timp de execuție asincron și sunt disponibile "
"mai multe timpuri de execuție diferite."

#: src/concurrency/welcome-async.md
#, fuzzy
msgid ""
"Python has a similar model in its `asyncio`. However, its `Future` type is "
"callback-based, and not polled. Async Python programs require a \"loop\", "
"similar to a runtime in Rust."
msgstr ""
"Python are un model similar în `asyncio`. Cu toate acestea, tipul său "
"`Future` se bazează pe callback și nu pe polled. Programele asincrone din "
"Python necesită o \"buclă\", similară cu un timp de execuție în Rust."

#: src/concurrency/welcome-async.md
#, fuzzy
msgid ""
"JavaScript's `Promise` is similar, but again callback-based. The language "
"runtime implements the event loop, so many of the details of Promise "
"resolution are hidden."
msgstr ""
"`Promise` din JavaScript este similar, dar se bazează din nou pe callback. "
"Timpul de execuție al limbajului implementează bucla de evenimente, astfel "
"încât multe dintre detaliile rezolvării promisiunilor sunt ascunse."

#: src/concurrency/welcome-async.md
#, fuzzy
msgid "[Async Basics](./concurrency/async.md) (30 minutes)"
msgstr "[Generice](../generics.md) (45 minute)"

#: src/concurrency/welcome-async.md
#, fuzzy
msgid ""
"[Channels and Control Flow](./concurrency/async-control-flow.md) (20 minutes)"
msgstr ""
"[Lasă controlul să curgă](./pattern-matching/let-control-flow.md) (10 minute)"

#: src/concurrency/welcome-async.md
#, fuzzy
msgid "[Pitfalls](./concurrency/async-pitfalls.md) (55 minutes)"
msgstr "[Referințe](../references.md) (50 minute)"

#: src/concurrency/welcome-async.md
#, fuzzy
msgid "[Exercises](./concurrency/async-exercises.md) (1 hour and 10 minutes)"
msgstr "[Exercițiu: Geometrie](./references/exercise.md) (30 minute)"

#: src/concurrency/async.md
#, fuzzy
msgid "[async/await](./concurrency/async/async-await.md) (10 minutes)"
msgstr "[async/await](./concurrency/async/async/async-await.md) (10 minute)"

#: src/concurrency/async.md
#, fuzzy
msgid "[Futures](./concurrency/async/futures.md) (4 minutes)"
msgstr "[Șiruri](./types-and-values/strings.md) (10 minute)"

#: src/concurrency/async.md
#, fuzzy
msgid "[Runtimes](./concurrency/async/runtimes.md) (10 minutes)"
msgstr "[Șiruri](./types-and-values/strings.md) (10 minute)"

#: src/concurrency/async.md
#, fuzzy
msgid "[Tasks](./concurrency/async/tasks.md) (10 minutes)"
msgstr "[Șiruri](./types-and-values/strings.md) (10 minute)"

#: src/concurrency/async/async-await.md
#, fuzzy
msgid ""
"At a high level, async Rust code looks very much like \"normal\" sequential "
"code:"
msgstr ""
"La un nivel înalt, codul Rust asincron seamănă foarte mult cu codul "
"secvențial \"normal\":"

#: src/concurrency/async/async-await.md
#, fuzzy
msgid "\"Count is: {i}!\""
msgstr "\"Contele este: {i}!\""

#: src/concurrency/async/async-await.md
#, fuzzy
msgid ""
"Note that this is a simplified example to show the syntax. There is no long "
"running operation or any real concurrency in it!"
msgstr ""
"Rețineți că acesta este un exemplu simplificat pentru a arăta sintaxa. Nu "
"există nicio operațiune de lungă durată sau vreo concurență reală!"

#: src/concurrency/async/async-await.md
#, fuzzy
msgid "What is the return type of an async call?"
msgstr "Care este tipul de returnare al unui apel asincron?"

#: src/concurrency/async/async-await.md
#, fuzzy
msgid "Use `let future: () = async_main(10);` in `main` to see the type."
msgstr ""
"Utilizați `let future: () = async_main(10);` în `main` pentru a vedea tipul."

#: src/concurrency/async/async-await.md
#, fuzzy
msgid ""
"The \"async\" keyword is syntactic sugar. The compiler replaces the return "
"type with a future."
msgstr ""
"Cuvântul cheie \"async\" este un zahăr sintactic. Compilatorul înlocuiește "
"tipul return cu un future."

#: src/concurrency/async/async-await.md
#, fuzzy
msgid ""
"You cannot make `main` async, without additional instructions to the "
"compiler on how to use the returned future."
msgstr ""
"Nu puteți face ca `main` să fie asincron, fără instrucțiuni suplimentare "
"pentru compilator cu privire la modul de utilizare a viitorului returnat."

#: src/concurrency/async/async-await.md
#, fuzzy
msgid ""
"You need an executor to run async code. `block_on` blocks the current thread "
"until the provided future has run to completion."
msgstr ""
"Aveți nevoie de un executor pentru a rula cod asincron. `block_on` blochează "
"firul curent până când viitorul furnizat a fost executat până la finalizare."

#: src/concurrency/async/async-await.md
#, fuzzy
msgid ""
"`.await` asynchronously waits for the completion of another operation. "
"Unlike `block_on`, `.await` doesn't block the current thread."
msgstr ""
"`.await` așteaptă în mod asincron finalizarea unei alte operațiuni. Spre "
"deosebire de `block_on`, `.await` nu blochează firul curent."

#: src/concurrency/async/async-await.md
#, fuzzy
msgid ""
"`.await` can only be used inside an `async` function (or block; these are "
"introduced later)."
msgstr ""
"`.await` poate fi folosit numai în interiorul unei funcții `async` (sau "
"bloc; acestea sunt prezentate mai târziu)."

#: src/concurrency/async/futures.md
#, fuzzy
msgid ""
"[`Future`](https://doc.rust-lang.org/std/future/trait.Future.html) is a "
"trait, implemented by objects that represent an operation that may not be "
"complete yet. A future can be polled, and `poll` returns a [`Poll`](https://"
"doc.rust-lang.org/std/task/enum.Poll.html)."
msgstr ""
"[`Future`](https://doc.rust-lang.org/std/future/trait.Future.html) este o "
"trăsătură, implementată de obiecte care reprezintă o operațiune care poate "
"să nu fie încă finalizată. Un viitor poate fi interogat, iar `poll` "
"returnează un [`Poll`](https://doc.rust-lang.org/std/task/enum.Poll.html)."

#: src/concurrency/async/futures.md
#, fuzzy
msgid ""
"An async function returns an `impl Future`. It's also possible (but "
"uncommon) to implement `Future` for your own types. For example, the "
"`JoinHandle` returned from `tokio::spawn` implements `Future` to allow "
"joining to it."
msgstr ""
"O funcție asincronă returnează un `impl Future`. De asemenea, este posibil "
"(dar mai puțin obișnuit) să implementați `Future` pentru propriile tipuri. "
"De exemplu, `JoinHandle` returnat de `tokio::spawn` implementează `Future` "
"pentru a permite îmbinarea cu acesta."

#: src/concurrency/async/futures.md
#, fuzzy
msgid ""
"The `.await` keyword, applied to a Future, causes the current async function "
"to pause until that Future is ready, and then evaluates to its output."
msgstr ""
"Cuvântul cheie `.await`, aplicat la un Future, determină funcția asincronă "
"curentă să se oprească până când Future-ul este gata și apoi evaluează la "
"ieșire."

#: src/concurrency/async/futures.md
#, fuzzy
msgid ""
"The `Future` and `Poll` types are implemented exactly as shown; click the "
"links to show the implementations in the docs."
msgstr ""
"Tipurile `Future` și `Poll` sunt implementate exact așa cum se arată; faceți "
"clic pe linkuri pentru a vedea implementările din documentație."

#: src/concurrency/async/futures.md
#, fuzzy
msgid ""
"We will not get to `Pin` and `Context`, as we will focus on writing async "
"code, rather than building new async primitives. Briefly:"
msgstr ""
"Nu vom ajunge la `Pin` și `Context`, deoarece ne vom concentra pe scrierea "
"de cod asincron, mai degrabă decât pe construirea de noi primitive "
"asincrone. Pe scurt:"

#: src/concurrency/async/futures.md
#, fuzzy
msgid ""
"`Context` allows a Future to schedule itself to be polled again when an "
"event occurs."
msgstr ""
"`Context` permite unui Future să se programeze pentru a fi interogat din nou "
"atunci când are loc un eveniment."

#: src/concurrency/async/futures.md
#, fuzzy
msgid ""
"`Pin` ensures that the Future isn't moved in memory, so that pointers into "
"that future remain valid. This is required to allow references to remain "
"valid after an `.await`."
msgstr ""
"`Pin` se asigură că viitorul nu este mutat în memorie, astfel încât "
"indicatorii către acel viitor rămân valabili. Acest lucru este necesar "
"pentru a permite ca referințele să rămână valabile după un `.await`."

#: src/concurrency/async/runtimes.md
#, fuzzy
msgid ""
"A _runtime_ provides support for performing operations asynchronously (a "
"_reactor_) and is responsible for executing futures (an _executor_). Rust "
"does not have a \"built-in\" runtime, but several options are available:"
msgstr ""
"Un _runtime_ oferă suport pentru efectuarea de operații asincrone (un "
"_reactor_) și este responsabil pentru executarea futures (un _executor_). "
"Rust nu are un timp de execuție \"încorporat\", dar sunt disponibile mai "
"multe opțiuni:"

#: src/concurrency/async/runtimes.md
#, fuzzy
msgid ""
"[Tokio](https://tokio.rs/): performant, with a well-developed ecosystem of "
"functionality like [Hyper](https://hyper.rs/) for HTTP or [Tonic](https://"
"github.com/hyperium/tonic) for gRPC."
msgstr ""
"[Tokio](https://tokio.rs/): performant, cu un ecosistem bine dezvoltat de "
"funcționalități precum [Hyper](https://hyper.rs/) pentru HTTP sau [Tonic]"
"(https://github.com/hyperium/tonic) pentru gRPC."

#: src/concurrency/async/runtimes.md
#, fuzzy
msgid ""
"[async-std](https://async.rs/): aims to be a \"std for async\", and includes "
"a basic runtime in `async::task`."
msgstr ""
"[async-std](https://async.rs/): își propune să fie un \"std pentru async\" "
"și include un timp de execuție de bază în `async::task`."

#: src/concurrency/async/runtimes.md
#, fuzzy
msgid "[smol](https://docs.rs/smol/latest/smol/): simple and lightweight"
msgstr "[smol](https://docs.rs/smol/latest/smol/): simplu și ușor"

#: src/concurrency/async/runtimes.md
#, fuzzy
msgid ""
"Several larger applications have their own runtimes. For example, [Fuchsia]"
"(https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/lib/fuchsia-"
"async/src/lib.rs) already has one."
msgstr ""
"Mai multe aplicații mai mari au propriile lor timpuri de execuție. De "
"exemplu, [Fuchsia](https://fuchsia.googlesource.com/fuchsia/+/refs/heads/"
"main/src/lib/fuchsia-async/src/lib.rs) are deja unul."

#: src/concurrency/async/runtimes.md
#, fuzzy
msgid ""
"Note that of the listed runtimes, only Tokio is supported in the Rust "
"playground. The playground also does not permit any I/O, so most interesting "
"async things can't run in the playground."
msgstr ""
"Rețineți că, dintre timpii de execuție enumerați, numai Tokio este acceptat "
"în zona de joacă Rust. De asemenea, terenul de joacă nu permite niciun fel "
"de I/O, astfel încât cele mai multe lucruri asincrone interesante nu pot fi "
"rulate în terenul de joacă."

#: src/concurrency/async/runtimes.md
#, fuzzy
msgid ""
"Futures are \"inert\" in that they do not do anything (not even start an I/O "
"operation) unless there is an executor polling them. This differs from JS "
"Promises, for example, which will run to completion even if they are never "
"used."
msgstr ""
"Futures sunt \"inerți\", în sensul că nu fac nimic (nici măcar nu încep o "
"operațiune de I/O) decât dacă există un executor care să le interogheze. "
"Acest lucru este diferit de JS Promises, de exemplu, care vor fi executate "
"până la finalizare chiar dacă nu sunt folosite niciodată."

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid "Tokio provides:"
msgstr "Tokio oferă:"

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid "A multi-threaded runtime for executing asynchronous code."
msgstr ""
"Un timp de execuție cu mai multe fire de execuție pentru executarea de cod "
"asincron."

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid "An asynchronous version of the standard library."
msgstr "O versiune asincronă a bibliotecii standard."

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid "A large ecosystem of libraries."
msgstr "Un ecosistem mare de biblioteci."

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid "\"Count in task: {i}!\""
msgstr "\"Numărătoarea în sarcină: {i}!\""

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid "\"Main task: {i}\""
msgstr "\"Sarcina principală: {i}\""

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid "With the `tokio::main` macro we can now make `main` async."
msgstr ""
"Cu ajutorul macroului `tokio::main` putem face acum ca `main` să fie "
"asincronizat."

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid "The `spawn` function creates a new, concurrent \"task\"."
msgstr "Funcția `spawn` creează o nouă \"sarcină\" concurentă."

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid "Note: `spawn` takes a `Future`, you don't call `.await` on `count_to`."
msgstr "Notă: `spawn` ia un `Future`, nu se apelează `.await` pe `count_to`."

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid "**Further exploration:**"
msgstr "**Explorare suplimentară:**"

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid ""
"Why does `count_to` not (usually) get to 10? This is an example of async "
"cancellation. `tokio::spawn` returns a handle which can be awaited to wait "
"until it finishes."
msgstr ""
"De ce `count_to` nu ajunge (de obicei) la 10? Acesta este un exemplu de "
"anulare asincronă. `tokio::spawn` returnează un handle care poate fi "
"așteptat pentru a aștepta până când se termină."

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid "Try `count_to(10).await` instead of spawning."
msgstr "Încearcă `count_to(10).await` în loc de spawning."

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid "Try awaiting the task returned from `tokio::spawn`."
msgstr "Încercați să așteptați sarcina returnată de `tokio::spawn`."

#: src/concurrency/async/tasks.md
#, fuzzy
msgid "Rust has a task system, which is a form of lightweight threading."
msgstr "Rust are un sistem de sarcini, care este o formă de threading ușor."

#: src/concurrency/async/tasks.md
#, fuzzy
msgid ""
"A task has a single top-level future which the executor polls to make "
"progress. That future may have one or more nested futures that its `poll` "
"method polls, corresponding loosely to a call stack. Concurrency within a "
"task is possible by polling multiple child futures, such as racing a timer "
"and an I/O operation."
msgstr ""
"O sarcină are un singur viitor de nivel superior pe care executorul îl "
"sondează pentru a progresa. Acel viitor poate avea unul sau mai multe "
"viitoare imbricate pe care metoda sa `poll` le interoghează, ceea ce "
"corespunde, în linii mari, unei stive de apeluri. Concurența în cadrul unei "
"sarcini este posibilă prin interogarea mai multor futures mai mici, cum ar "
"fi cursele dintre un cronometru și o operațiune I/O."

#: src/concurrency/async/tasks.md
#, fuzzy
msgid "\"127.0.0.1:0\""
msgstr "\"127.0.0.1:0\""

#: src/concurrency/async/tasks.md
#, fuzzy
msgid "\"listening on port {}\""
msgstr "\"ascultând pe portul 2000\""

#: src/concurrency/async/tasks.md
#, fuzzy
msgid "\"connection from {addr:?}\""
msgstr "\"Conexiune nouă de la {addr:?}\""

#: src/concurrency/async/tasks.md
#, fuzzy
msgid "b\"Who are you?\\n\""
msgstr "b \"Cine ești tu?\\n\""

#: src/concurrency/async/tasks.md
#, fuzzy
msgid "\"socket error\""
msgstr "\"eroare de socket\""

#: src/concurrency/async/tasks.md
#, fuzzy
msgid "\"Thanks for dialing in, {name}!\\n\""
msgstr "\"Mulțumesc că ați sunat, {name}!\\n\""

#: src/concurrency/async/tasks.md src/concurrency/async-control-flow/join.md
#, fuzzy
msgid ""
"Copy this example into your prepared `src/main.rs` and run it from there."
msgstr ""
"Copiați acest exemplu în fișierul pregătit `src/main.rs` și rulați-l de "
"acolo."

#: src/concurrency/async/tasks.md
#, fuzzy
msgid ""
"Try connecting to it with a TCP connection tool like [nc](https://www.unix."
"com/man-page/linux/1/nc/) or [telnet](https://www.unix.com/man-page/linux/1/"
"telnet/)."
msgstr ""
"Încercați să vă conectați la acesta cu un instrument de conexiune TCP, cum "
"ar fi [nc](https://www.unix.com/man-page/linux/1/nc/) sau [telnet](https://"
"www.unix.com/man-page/linux/1/telnet/)."

#: src/concurrency/async/tasks.md
#, fuzzy
msgid ""
"Ask students to visualize what the state of the example server would be with "
"a few connected clients. What tasks exist? What are their Futures?"
msgstr ""
"Cereți elevilor să vizualizeze care ar fi starea serverului de exemplu cu "
"câțiva clienți conectați. Ce sarcini există? Care este viitorul lor?"

#: src/concurrency/async/tasks.md
#, fuzzy
msgid ""
"This is the first time we've seen an `async` block. This is similar to a "
"closure, but does not take any arguments. Its return value is a Future, "
"similar to an `async fn`."
msgstr ""
"Aceasta este prima dată când vedem un bloc `async`. Acesta este asemănător "
"cu o închidere, dar nu primește niciun argument. Valoarea sa de întoarcere "
"este un Future, similar cu un `async fn`."

#: src/concurrency/async/tasks.md
#, fuzzy
msgid ""
"Refactor the async block into a function, and improve the error handling "
"using `?`."
msgstr ""
"Refaceți blocul asincron într-o funcție și îmbunătățiți gestionarea erorilor "
"folosind `?`."

#: src/concurrency/async-control-flow.md
#, fuzzy
msgid ""
"[Async Channels](./concurrency/async-control-flow/channels.md) (10 minutes)"
msgstr ""
"[Canale asincrone](./concurrency/async-control-flow/channels.md) (10 minute)"

#: src/concurrency/async-control-flow.md
#, fuzzy
msgid "[Join](./concurrency/async-control-flow/join.md) (4 minutes)"
msgstr "[Join](control-flow/join.md)"

#: src/concurrency/async-control-flow.md
#, fuzzy
msgid "[Select](./concurrency/async-control-flow/select.md) (5 minutes)"
msgstr "[Selectare](control-flow/select.md)"

#: src/concurrency/async-control-flow/channels.md
#, fuzzy
msgid ""
"Several crates have support for asynchronous channels. For instance `tokio`:"
msgstr ""
"Mai multe crates au suport pentru canale asincrone. De exemplu, `tokio`:"

#: src/concurrency/async-control-flow/channels.md
#, fuzzy
msgid "\"Received {count} pings so far.\""
msgstr "\"A primit {count} ping-uri până acum.\""

#: src/concurrency/async-control-flow/channels.md
#, fuzzy
msgid "\"ping_handler complete\""
msgstr "\"ping_handler complete\""

#: src/concurrency/async-control-flow/channels.md
#, fuzzy
msgid "\"Failed to send ping.\""
msgstr "\"Nu a reușit să trimită ping.\""

#: src/concurrency/async-control-flow/channels.md
#, fuzzy
msgid "\"Sent {} pings so far.\""
msgstr "\"A trimis {} ping-uri până acum.\""

#: src/concurrency/async-control-flow/channels.md
#, fuzzy
msgid "\"Something went wrong in ping handler task.\""
msgstr "\"Ceva a mers prost în sarcina de gestionare a ping-ului.\""

#: src/concurrency/async-control-flow/channels.md
#, fuzzy
msgid "Change the channel size to `3` and see how it affects the execution."
msgstr ""
"Schimbați dimensiunea canalului la `3` și vedeți cum afectează execuția."

#: src/concurrency/async-control-flow/channels.md
#, fuzzy
msgid ""
"Overall, the interface is similar to the `sync` channels as seen in the "
"[morning class](concurrency/channels.md)."
msgstr ""
"În general, interfața este similară cu cea a canalelor `sync`, așa cum se "
"vede în [morning class](concurrency/channels.md)."

#: src/concurrency/async-control-flow/channels.md
#, fuzzy
msgid "Try removing the `std::mem::drop` call. What happens? Why?"
msgstr "Încercați să eliminați apelul `std::mem::drop`. Ce se întâmplă? De ce?"

#: src/concurrency/async-control-flow/channels.md
#, fuzzy
msgid ""
"The [Flume](https://docs.rs/flume/latest/flume/) crate has channels that "
"implement both `sync` and `async` `send` and `recv`. This can be convenient "
"for complex applications with both IO and heavy CPU processing tasks."
msgstr ""
"Crate [Flume](https://docs.rs/flume/latest/flume/) are canale care "
"implementează atât `sync` cât și `async` `send` și `recv`. Acest lucru poate "
"fi convenabil pentru aplicațiile complexe cu sarcini de procesare atât IO, "
"cât și grele pentru CPU."

#: src/concurrency/async-control-flow/channels.md
#, fuzzy
msgid ""
"What makes working with `async` channels preferable is the ability to "
"combine them with other `future`s to combine them and create complex control "
"flow."
msgstr ""
"Ceea ce face ca lucrul cu canalele `async` să fie preferabil este "
"capacitatea de a le combina cu alte `future` pentru a le combina și a crea "
"un flux de control complex."

#: src/concurrency/async-control-flow/join.md
#, fuzzy
msgid ""
"A join operation waits until all of a set of futures are ready, and returns "
"a collection of their results. This is similar to `Promise.all` in "
"JavaScript or `asyncio.gather` in Python."
msgstr ""
"O operațiune de îmbinare așteaptă până când toți viitorii dintr-un set de "
"viitoare sunt gata și returnează o colecție de rezultate ale acestora. Acest "
"lucru este similar cu `Promise.all` în JavaScript sau `asyncio.gather` în "
"Python."

#: src/concurrency/async-control-flow/join.md
#, fuzzy
msgid "\"https://google.com\""
msgstr "\"https://google.com\""

#: src/concurrency/async-control-flow/join.md
#, fuzzy
msgid "\"https://httpbin.org/ip\""
msgstr "\"https://httpbin.org/ip\""

#: src/concurrency/async-control-flow/join.md
#, fuzzy
msgid "\"https://play.rust-lang.org/\""
msgstr "\"https://play.rust-lang.org/\""

#: src/concurrency/async-control-flow/join.md
#, fuzzy
msgid "\"BAD_URL\""
msgstr "\"BAD_URL\""

#: src/concurrency/async-control-flow/join.md
#, fuzzy
msgid ""
"For multiple futures of disjoint types, you can use `std::future::join!` but "
"you must know how many futures you will have at compile time. This is "
"currently in the `futures` crate, soon to be stabilised in `std::future`."
msgstr ""
"Pentru mai multe futures de tipuri disjuncte, puteți utiliza `std::future::"
"join!`, dar trebuie să știți câte futures veți avea în momentul compilării. "
"Acest lucru se află în prezent în crăiasa `futures`, urmând a fi stabilizat "
"în curând în `std::future`."

#: src/concurrency/async-control-flow/join.md
#, fuzzy
msgid ""
"The risk of `join` is that one of the futures may never resolve, this would "
"cause your program to stall."
msgstr ""
"Riscul `join` este ca unul dintre futures să nu se rezolve niciodată, ceea "
"ce ar face ca programul dumneavoastră să se blocheze."

#: src/concurrency/async-control-flow/join.md
#, fuzzy
msgid ""
"You can also combine `join_all` with `join!` for instance to join all "
"requests to an http service as well as a database query. Try adding a "
"`tokio::time::sleep` to the future, using `futures::join!`. This is not a "
"timeout (that requires `select!`, explained in the next chapter), but "
"demonstrates `join!`."
msgstr ""
"De asemenea, puteți combina `join_all` cu `join!`, de exemplu, pentru a uni "
"toate cererile către un serviciu http, precum și o interogare a unei baze de "
"date. Încercați să adăugați un `tokio::time::sleep` la viitor, folosind "
"`futures::join!`. Acesta nu este un timeout (care necesită `select!`, "
"explicat în capitolul următor), ci demonstrează `join!`."

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid ""
"A select operation waits until any of a set of futures is ready, and "
"responds to that future's result. In JavaScript, this is similar to `Promise."
"race`. In Python, it compares to `asyncio.wait(task_set, return_when=asyncio."
"FIRST_COMPLETED)`."
msgstr ""
"O operațiune de selectare așteaptă până când oricare dintre un set de "
"viitoare este gata și răspunde la rezultatul viitorului respectiv. În "
"JavaScript, această operațiune este similară cu `Promise.race`. În Python, "
"se compară cu `asyncio.wait(task_set, return_when=asyncio.FIRST_COMPLETED)`."

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid ""
"Similar to a match statement, the body of `select!` has a number of arms, "
"each of the form `pattern = future => statement`. When a `future` is ready, "
"its return value is destructured by the `pattern`. The `statement` is then "
"run with the resulting variables. The `statement` result becomes the result "
"of the `select!` macro."
msgstr ""
"La fel ca o instrucțiune match, corpul instrucțiunii `select!` are mai multe "
"brațe, fiecare de forma `pattern = future => statement`. Când `future` este "
"gata, `statement` este executat cu variabilele din `pattern` legate de "
"rezultatul `future`."

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid "\"Felix\""
msgstr "\"Felix\""

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid "\"Failed to send cat.\""
msgstr "\"Nu a reușit să trimită pisica.\""

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid "\"Failed to send dog.\""
msgstr "\"Nu a reușit să trimită câinele.\""

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid "\"Failed to receive winner\""
msgstr "\"Nu a reușit să primească câștigătorul\""

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid "\"Winner is {winner:?}\""
msgstr "\"Câștigătorul este {winner:?}\""

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid ""
"In this example, we have a race between a cat and a dog. "
"`first_animal_to_finish_race` listens to both channels and will pick "
"whichever arrives first. Since the dog takes 50ms, it wins against the cat "
"that take 500ms."
msgstr ""
"În acest exemplu, avem o cursă între o pisică și un câine. "
"`first_animal_to_finish_race` ascultă ambele canale și îl va alege pe cel "
"care ajunge primul. Deoarece câinele are nevoie de 50ms, câștigă împotriva "
"pisicii care are nevoie de 500ms."

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid ""
"You can use `oneshot` channels in this example as the channels are supposed "
"to receive only one `send`."
msgstr ""
"În acest exemplu, puteți utiliza canale `oneshot`, deoarece canalele trebuie "
"să primească doar un singur `send`."

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid ""
"Try adding a deadline to the race, demonstrating selecting different sorts "
"of futures."
msgstr ""
"Încercați să adăugați un termen limită la cursă, demonstrând că ați selectat "
"diferite tipuri de viitoruri."

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid ""
"Note that `select!` drops unmatched branches, which cancels their futures. "
"It is easiest to use when every execution of `select!` creates new futures."
msgstr ""
"Rețineți că `select!` renunță la ramurile nepotrivite, ceea ce anulează "
"viitorul acestora. Este cel mai ușor de utilizat atunci când fiecare "
"execuție a `select!` creează noi futures."

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid ""
"An alternative is to pass `&mut future` instead of the future itself, but "
"this can lead to issues, further discussed in the pinning slide."
msgstr ""
"O alternativă este de a trece `&mut future` în locul viitorului însuși, dar "
"acest lucru poate duce la probleme, discutate în continuare în slide-ul cu "
"privire la fixarea."

#: src/concurrency/async-pitfalls.md
#, fuzzy
msgid ""
"Async / await provides convenient and efficient abstraction for concurrent "
"asynchronous programming. However, the async/await model in Rust also comes "
"with its share of pitfalls and footguns. We illustrate some of them in this "
"chapter."
msgstr ""
"Async / await oferă o abstractizare convenabilă și eficientă pentru "
"programarea asincronă concurentă. Cu toate acestea, modelul async/await din "
"Rust vine și el cu partea sa de capcane și piedici. În acest capitol "
"ilustrăm câteva dintre ele:"

#: src/concurrency/async-pitfalls.md
#, fuzzy
msgid ""
"[Blocking the Executor](./concurrency/async-pitfalls/blocking-executor.md) "
"(10 minutes)"
msgstr "[Blocarea executorului](pitfalls/blocking-executor.md)"

#: src/concurrency/async-pitfalls.md
#, fuzzy
msgid "[Pin](./concurrency/async-pitfalls/pin.md) (20 minutes)"
msgstr "[Șiruri](./types-and-values/strings.md) (10 minute)"

#: src/concurrency/async-pitfalls.md
#, fuzzy
msgid ""
"[Async Traits](./concurrency/async-pitfalls/async-traits.md) (5 minutes)"
msgstr "[Trăsături asincrone](pitfalls/async-traits.md)"

#: src/concurrency/async-pitfalls.md
#, fuzzy
msgid ""
"[Cancellation](./concurrency/async-pitfalls/cancellation.md) (20 minutes)"
msgstr "[Anulare](pitfalls/cancellation.md)"

#: src/concurrency/async-pitfalls/blocking-executor.md
#, fuzzy
msgid "Blocking the executor"
msgstr "Blocarea executorului"

#: src/concurrency/async-pitfalls/blocking-executor.md
#, fuzzy
msgid ""
"Most async runtimes only allow IO tasks to run concurrently. This means that "
"CPU blocking tasks will block the executor and prevent other tasks from "
"being executed. An easy workaround is to use async equivalent methods where "
"possible."
msgstr ""
"Majoritatea timpilor de execuție asincronă permit doar executarea simultană "
"a sarcinilor IO. Aceasta înseamnă că sarcinile care blochează CPU vor bloca "
"executorul și vor împiedica executarea altor sarcini. O soluție ușoară este "
"utilizarea unor metode echivalente asincrone acolo unde este posibil."

#: src/concurrency/async-pitfalls/blocking-executor.md
#, fuzzy
msgid "\"future {id} slept for {duration_ms}ms, finished after {}ms\""
msgstr ""
"\"viitorul {id} a dormit timp de {duration_ms}ms, a terminat după {}ms\""

#: src/concurrency/async-pitfalls/blocking-executor.md
#, fuzzy
msgid "\"current_thread\""
msgstr "\"current_thread\""

#: src/concurrency/async-pitfalls/blocking-executor.md
#, fuzzy
msgid ""
"Run the code and see that the sleeps happen consecutively rather than "
"concurrently."
msgstr ""
"Rulați codul și vedeți că somnul se produce consecutiv și nu concomitent."

#: src/concurrency/async-pitfalls/blocking-executor.md
#, fuzzy
msgid ""
"The `\"current_thread\"` flavor puts all tasks on a single thread. This "
"makes the effect more obvious, but the bug is still present in the multi-"
"threaded flavor."
msgstr ""
"Aroma `\"current_thread\"` pune toate sarcinile pe un singur fir. Acest "
"lucru face ca efectul să fie mai evident, dar eroarea este încă prezentă în "
"varianta cu mai multe fire."

#: src/concurrency/async-pitfalls/blocking-executor.md
#, fuzzy
msgid ""
"Switch the `std::thread::sleep` to `tokio::time::sleep` and await its result."
msgstr ""
"Schimbă `std::thread::sleep` cu `tokio::time::sleep` și așteaptă rezultatul."

#: src/concurrency/async-pitfalls/blocking-executor.md
#, fuzzy
msgid ""
"Another fix would be to `tokio::task::spawn_blocking` which spawns an actual "
"thread and transforms its handle into a future without blocking the executor."
msgstr ""
"O altă soluție ar fi `tokio::task::spawn_blocking` care generează un fir "
"real și transformă mânerul său într-un viitor fără a bloca executorul."

#: src/concurrency/async-pitfalls/blocking-executor.md
#, fuzzy
msgid ""
"You should not think of tasks as OS threads. They do not map 1 to 1 and most "
"executors will allow many tasks to run on a single OS thread. This is "
"particularly problematic when interacting with other libraries via FFI, "
"where that library might depend on thread-local storage or map to specific "
"OS threads (e.g., CUDA). Prefer `tokio::task::spawn_blocking` in such "
"situations."
msgstr ""
"Nu ar trebui să vă gândiți la sarcini ca la fire de sistem de operare. "
"Acestea nu se corelează 1 la 1 și majoritatea executorilor vor permite "
"rularea mai multor sarcini pe un singur fir OS. Acest lucru este deosebit de "
"problematic atunci când interacționați cu alte biblioteci prin intermediul "
"FFI, în cazul în care biblioteca respectivă ar putea depinde de stocarea "
"locală a firelor de execuție sau ar putea fi mapată pe anumite fire de "
"execuție ale sistemului de operare (de exemplu, CUDA). Preferați `tokio::"
"task::spawn_blocking` în astfel de situații."

#: src/concurrency/async-pitfalls/blocking-executor.md
#, fuzzy
msgid ""
"Use sync mutexes with care. Holding a mutex over an `.await` may cause "
"another task to block, and that task may be running on the same thread."
msgstr ""
"Utilizați mutexurile de sincronizare cu grijă. Menținerea unui mutex peste "
"un `.await` poate provoca blocarea unei alte sarcini, iar acea sarcină poate "
"fi executată pe același fir."

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"Async blocks and functions return types implementing the `Future` trait. The "
"type returned is the result of a compiler transformation which turns local "
"variables into data stored inside the future."
msgstr ""
"Blocurile și funcțiile asincrone returnează tipuri care implementează "
"trăsătura `Future`. Tipul returnat este rezultatul unei transformări a "
"compilatorului care transformă variabilele locale în date stocate în "
"interiorul viitorului."

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"Some of those variables can hold pointers to other local variables. Because "
"of that, the future should never be moved to a different memory location, as "
"it would invalidate those pointers."
msgstr ""
"Unele dintre aceste variabile pot conține indicatori către alte variabile "
"locale. Din acest motiv, viitorul nu ar trebui să fie mutat niciodată într-o "
"altă locație de memorie, deoarece aceasta ar invalida acești indicatori."

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"To prevent moving the future type in memory, it can only be polled through a "
"pinned pointer. `Pin` is a wrapper around a reference that disallows all "
"operations that would move the instance it points to into a different memory "
"location."
msgstr ""
"Pentru a preveni deplasarea tipului de viitor în memorie, acesta poate fi "
"interogat numai prin intermediul unui pointer fixat. `Pin` este un înveliș "
"în jurul unei referințe care interzice toate operațiunile care ar putea muta "
"instanța la care indică într-o altă locație de memorie."

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"// A work item. In this case, just sleep for the given time and respond\n"
"// with a message on the `respond_on` channel.\n"
msgstr ""
"// Un element de lucru. În acest caz, doar dormiți pentru timpul dat și "
"răspundeți\n"
"// cu un mesaj pe canalul `respond_on`.\n"

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid "// A worker which listens for work on a queue and performs it.\n"
msgstr "// Un lucrător care ascultă munca într-o coadă și o execută.\n"

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid "// Pretend to work.\n"
msgstr "// Prefă-te că lucrezi.\n"

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid "\"failed to send response\""
msgstr "\"nu a reușit să trimită răspunsul\""

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid "// TODO: report number of iterations every 100ms\n"
msgstr "// TODO: raportați numărul de iterații la fiecare 100ms\n"

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid "// A requester which requests work and waits for it to complete.\n"
msgstr ""
"// Un solicitant care solicită lucrări și așteaptă ca acestea să fie "
"finalizate.\n"

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid "\"failed to send on work queue\""
msgstr "\"nu a reușit să trimită în coada de lucru\""

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid "\"failed waiting for response\""
msgstr "\"eșuat în așteptarea răspunsului\""

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid "\"work result for iteration {i}: {resp}\""
msgstr "\"rezultatul muncii pentru iterația {i}: {resp}\""

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"You may recognize this as an example of the actor pattern. Actors typically "
"call `select!` in a loop."
msgstr ""
"Este posibil să recunoașteți acest lucru ca fiind un exemplu de model actor. "
"De obicei, actorii apelează `select!` într-o buclă."

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"This serves as a summation of a few of the previous lessons, so take your "
"time with it."
msgstr ""
"Aceasta este o rezumare a câtorva dintre lecțiile anterioare, așa că nu vă "
"grăbiți cu ea."

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"Naively add a `_ = sleep(Duration::from_millis(100)) => { println!(..) }` to "
"the `select!`. This will never execute. Why?"
msgstr ""
"Adăugați în mod naiv un `_ = sleep(Duration::from_millis(100)) => { println!"
"(..) }` la `select!`. Aceasta nu se va executa niciodată. De ce?"

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"Instead, add a `timeout_fut` containing that future outside of the `loop`:"
msgstr ""
"În schimb, adăugați un `timeout_fut` care să conțină acel viitor în afara "
"`loop`:"

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"This still doesn't work. Follow the compiler errors, adding `&mut` to the "
"`timeout_fut` in the `select!` to work around the move, then using `Box::"
"pin`:"
msgstr ""
"Acest lucru tot nu funcționează. Urmați erorile compilatorului, adăugând "
"`&mut` la `timeout_fut` în `select!` pentru a evita deplasarea, apoi "
"utilizați `Box::pin`:"

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"This compiles, but once the timeout expires it is `Poll::Ready` on every "
"iteration (a fused future would help with this). Update to reset "
"`timeout_fut` every time it expires."
msgstr ""
"Acest lucru se compilează, dar odată ce expiră timpul de așteptare este "
"`Poll::Ready` la fiecare iterație (un viitor fuzionat ar ajuta cu acest "
"lucru). Actualizați pentru a reseta `timeout_fut` de fiecare dată când "
"expiră."

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"Box allocates on the heap. In some cases, `std::pin::pin!` (only recently "
"stabilized, with older code often using `tokio::pin!`) is also an option, "
"but that is difficult to use for a future that is reassigned."
msgstr ""
"Box alocă pe heap. În unele cazuri, `std::pin::pin!` (stabilizat doar "
"recent, codul mai vechi folosind adesea `tokio::pin!`) este, de asemenea, o "
"opțiune, dar este dificil de utilizat pentru un viitor care este realocat."

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"Another alternative is to not use `pin` at all but spawn another task that "
"will send to a `oneshot` channel every 100ms."
msgstr ""
"O altă alternativă este să nu folosiți `pin` deloc, ci să generați o altă "
"sarcină care va trimite la un canal `oneshot` la fiecare 100ms."

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"Data that contains pointers to itself is called self-referential. Normally, "
"the Rust borrow checker would prevent self-referential data from being "
"moved, as the references cannot outlive the data they point to. However, the "
"code transformation for async blocks and functions is not verified by the "
"borrow checker."
msgstr ""
"Datele care conțin indicatoare către ele însele se numesc autoreferențiale. "
"În mod normal, verificatorul de împrumuturi Rust ar împiedica mutarea "
"datelor autoreferențiale, deoarece referințele nu pot supraviețui datelor la "
"care indică. Cu toate acestea, transformarea codului pentru blocurile și "
"funcțiile asincrone nu este verificată de verificatorul de împrumuturi."

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"`Pin` is a wrapper around a reference. An object cannot be moved from its "
"place using a pinned pointer. However, it can still be moved through an "
"unpinned pointer."
msgstr ""
"`Pin` este un înveliș în jurul unei referințe. Un obiect nu poate fi mutat "
"de la locul său folosind un pointer fixat. Cu toate acestea, el poate fi "
"mutat printr-un pointer nefixat."

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"The `poll` method of the `Future` trait uses `Pin<&mut Self>` instead of "
"`&mut Self` to refer to the instance. That's why it can only be called on a "
"pinned pointer."
msgstr ""
"Metoda `poll` a trăsăturii `Future` utilizează `Pin<&mut Self>` în loc de "
"`&mut Self` pentru a se referi la instanță. De aceea, poate fi apelată numai "
"pe un pointer fixat."

#: src/concurrency/async-pitfalls/async-traits.md
#, fuzzy
msgid ""
"Async methods in traits are were stabilized only recently, in the 1.75 "
"release. This required support for using return-position `impl Trait` (RPIT) "
"in traits, as the desugaring for `async fn` includes `-> impl Future<Output "
"= ...>`."
msgstr ""
"Metodele asincrone din trăsături au fost stabilizate doar recent, în "
"versiunea 1.75. Acest lucru a necesitat suport pentru utilizarea poziției de "
"întoarcere `impl Trait` (RPIT) în traits, deoarece desugrăvirea pentru "
"`async fn` include `-> impl Future<Output = ...>`."

#: src/concurrency/async-pitfalls/async-traits.md
#, fuzzy
msgid ""
"However, even with the native support today there are some pitfalls around "
"`async fn` and RPIT in traits:"
msgstr ""
"Cu toate acestea, chiar și cu suportul nativ de astăzi, există unele capcane "
"în jurul `async fn` și RPIT în trăsături:"

#: src/concurrency/async-pitfalls/async-traits.md
#, fuzzy
msgid ""
"Return-position impl Trait captures all in-scope lifetimes (so some patterns "
"of borrowing cannot be expressed)"
msgstr ""
"Return-position impl Trait captează toate duratele de viață din domeniul de "
"aplicare (astfel încât unele modele de împrumut nu pot fi exprimate)"

#: src/concurrency/async-pitfalls/async-traits.md
#, fuzzy
msgid ""
"Traits whose methods use return-position `impl trait` or `async` are not "
"`dyn` compatible."
msgstr ""
"Trăsăturile ale căror metode utilizează poziția de returnare `impl trait` "
"sau `async` nu sunt compatibile cu `dyn`."

#: src/concurrency/async-pitfalls/async-traits.md
#, fuzzy
msgid ""
"If we do need `dyn` support, the crate [async_trait](https://docs.rs/async-"
"trait/latest/async_trait/) provides a workaround through a macro, with some "
"caveats:"
msgstr ""
"Crate [async_trait](https://docs.rs/async-trait/latest/async_trait/) oferă o "
"soluție de rezolvare prin intermediul unei macro:"

#: src/concurrency/async-pitfalls/async-traits.md
#, fuzzy
msgid "\"running all sleepers..\""
msgstr "\"alergând toți cei care dorm...\""

#: src/concurrency/async-pitfalls/async-traits.md
#, fuzzy
msgid "\"slept for {}ms\""
msgstr "\"adormit pentru {}ms\""

#: src/concurrency/async-pitfalls/async-traits.md
#, fuzzy
msgid ""
"`async_trait` is easy to use, but note that it's using heap allocations to "
"achieve this. This heap allocation has performance overhead."
msgstr ""
"`async_trait` este ușor de utilizat, dar rețineți că utilizează alocări heap "
"pentru a realiza acest lucru. Această alocare în heap are costuri "
"suplimentare de performanță."

#: src/concurrency/async-pitfalls/async-traits.md
#, fuzzy
msgid ""
"The challenges in language support for `async trait` are deep Rust and "
"probably not worth describing in-depth. Niko Matsakis did a good job of "
"explaining them in [this post](https://smallcultfollowing.com/babysteps/"
"blog/2019/10/26/async-fn-in-traits-are-hard/) if you are interested in "
"digging deeper."
msgstr ""
"Provocările în ceea ce privește suportul lingvistic pentru `async trait` "
"sunt adânci Rust și probabil nu merită să fie descrise în profunzime. Niko "
"Matsakis a făcut o treabă bună explicându-le în [această postare](https://"
"smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-"
"hard/) dacă sunteți interesat să aprofundați."

#: src/concurrency/async-pitfalls/async-traits.md
#, fuzzy
msgid ""
"Try creating a new sleeper struct that will sleep for a random amount of "
"time and adding it to the Vec."
msgstr ""
"Încercați să creați o nouă structură de somn care va dormi pentru o perioadă "
"de timp aleatorie și adăugați-o la Vec."

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid ""
"Dropping a future implies it can never be polled again. This is called "
"_cancellation_ and it can occur at any `await` point. Care is needed to "
"ensure the system works correctly even when futures are cancelled. For "
"example, it shouldn't deadlock or lose data."
msgstr ""
"Renunțarea la un viitor implică faptul că acesta nu mai poate fi interogat "
"niciodată. Acest lucru se numește _cancellation_ și poate avea loc în orice "
"punct de așteptare (`await`). Este necesară o atenție deosebită pentru a se "
"asigura că sistemul funcționează corect chiar și atunci când futures sunt "
"anulate. De exemplu, nu trebuie să se blocheze sau să piardă date."

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid "\"not UTF-8\""
msgstr ""
"Șirurile de caractere Rust sunt codificate UTF-8 și pot conține orice "
"caracter Unicode."

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid "\"hi\\nthere\\n\""
msgstr "\"hi\\nthere\\n\""

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid "\"tick!\""
msgstr "\"tic!\""

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid ""
"The compiler doesn't help with cancellation-safety. You need to read API "
"documentation and consider what state your `async fn` holds."
msgstr ""
"Compilatorul nu vă ajută în ceea ce privește siguranța la anulare. Trebuie "
"să citiți documentația API și să vă gândiți la starea pe care o deține "
"`async fn`."

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid ""
"Unlike `panic` and `?`, cancellation is part of normal control flow (vs "
"error-handling)."
msgstr ""
"Spre deosebire de `panic` și `?`, anularea face parte din fluxul normal de "
"control (față de gestionarea erorilor)."

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid "The example loses parts of the string."
msgstr "Exemplul pierde părți din șir."

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid ""
"Whenever the `tick()` branch finishes first, `next()` and its `buf` are "
"dropped."
msgstr ""
"Ori de câte ori ramura `tick()` se termină prima, se renunță la `next()` și "
"la `buf` al acestuia."

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid ""
"`LinesReader` can be made cancellation-safe by making `buf` part of the "
"struct:"
msgstr ""
"`LinesReader` poate fi securizat împotriva anulării prin includerea lui "
"`buf` în structură:"

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid "// prefix buf and bytes with self.\n"
msgstr "// prefixează buf și bytes cu self.\n"

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid ""
"[`Interval::tick`](https://docs.rs/tokio/latest/tokio/time/struct.Interval."
"html#method.tick) is cancellation-safe because it keeps track of whether a "
"tick has been 'delivered'."
msgstr ""
"[`Interval::tick`](https://docs.rs/tokio/latest/tokio/time/struct.Interval."
"html#method.tick) este sigur în ceea ce privește anularea, deoarece ține "
"evidența dacă un tick a fost \"livrat\"."

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid ""
"[`AsyncReadExt::read`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncReadExt.html#method.read) is cancellation-safe because it either "
"returns or doesn't read data."
msgstr ""
"[`AsyncReadExt::read`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncReadExt.html#method.read) este sigur în ceea ce privește anularea, "
"deoarece fie returnează, fie nu citește datele."

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid ""
"[`AsyncBufReadExt::read_line`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncBufReadExt.html#method.read_line) is similar to the example and _isn't_ "
"cancellation-safe. See its documentation for details and alternatives."
msgstr ""
"[`AsyncBufReadExt::read_line`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncBufReadExt.html#method.read_line) este similar cu exemplul și _nu este_ "
"sigur la anulare. Consultați documentația sa pentru detalii și alternative."

#: src/concurrency/async-exercises.md
#, fuzzy
msgid ""
"[Dining Philosophers](./concurrency/async-exercises/dining-philosophers.md) "
"(20 minutes)"
msgstr ""
"[Dining Philosophers](./concurrency/async-exercises/dining-philosophers.md) "
"(20 minute)"

#: src/concurrency/async-exercises.md
#, fuzzy
msgid ""
"[Broadcast Chat Application](./concurrency/async-exercises/chat-app.md) (30 "
"minutes)"
msgstr ""
"[Aplicație de chat cu difuzare](./concurrency/async-exercises/chat-app.md) "
"(30 minute)"

#: src/concurrency/async-exercises.md
#, fuzzy
msgid "[Solutions](./concurrency/async-exercises/solutions.md) (20 minutes)"
msgstr "[Șiruri](./types-and-values/strings.md) (10 minute)"

#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "Dining Philosophers --- Async"
msgstr "Filozofii care mănâncă - Async"

#: src/concurrency/async-exercises/dining-philosophers.md
#, fuzzy
msgid ""
"See [dining philosophers](dining-philosophers.md) for a description of the "
"problem."
msgstr ""
"Vezi [dining philosophers](dining-philosophers.md) pentru o descriere a "
"problemei."

#: src/concurrency/async-exercises/dining-philosophers.md
#, fuzzy
msgid ""
"As before, you will need a local [Cargo installation](../../cargo/running-"
"locally.md) for this exercise. Copy the code below to a file called `src/"
"main.rs`, fill out the blanks, and test that `cargo run` does not deadlock:"
msgstr ""
"Ca și înainte, veți avea nevoie de o [instalare Cargo] locală (../../cargo/"
"running-locally.md) pentru acest exercițiu. Copiați codul de mai jos într-un "
"fișier numit `src/main.rs`, completați spațiile goale și testați dacă `cargo "
"run` nu se blochează:"

#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "// Keep trying until we have both forks\n"
msgstr "// Continuă să încerci până când avem ambele furci\n"

#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "// Make them think and eat\n"
msgstr "// Fă-i să gândească și să mănânce\n"

#: src/concurrency/async-exercises/dining-philosophers.md
#, fuzzy
msgid ""
"Since this time you are using Async Rust, you'll need a `tokio` dependency. "
"You can use the following `Cargo.toml`:"
msgstr ""
"Deoarece de data aceasta folosiți Async Rust, veți avea nevoie de o "
"dependență `tokio`. Puteți utiliza următorul `Cargo.toml`:"

#: src/concurrency/async-exercises/dining-philosophers.md
#, fuzzy
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers-async-dine\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"tokio = { version = \"1.26.0\", features = [\"sync\", \"time\", \"macros\", "
"\"rt-multi-thread\"] }\n"
"```"
msgstr ""
"```toml\n"
"[pachet]\n"
"name = \"dining-philosophers-async-dine\"\n"
"versiune = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependențe]\n"
"tokio = {version = \"1.26.0\", features = [\"sync\", \"time\", \"macros\", "
"\"rt-multi-thread\"]}\n"
"```"

#: src/concurrency/async-exercises/dining-philosophers.md
#, fuzzy
msgid ""
"Also note that this time you have to use the `Mutex` and the `mpsc` module "
"from the `tokio` crate."
msgstr ""
"De asemenea, rețineți că de data aceasta trebuie să folosiți modulele "
"`Mutex` și `mpsc` de la `tokio` crate."

#: src/concurrency/async-exercises/dining-philosophers.md
#, fuzzy
msgid "Can you make your implementation single-threaded?"
msgstr "Poți face ca implementarea ta să fie cu un singur fir de execuție?"

#: src/concurrency/async-exercises/chat-app.md
#, fuzzy
msgid ""
"In this exercise, we want to use our new knowledge to implement a broadcast "
"chat application. We have a chat server that the clients connect to and "
"publish their messages. The client reads user messages from the standard "
"input, and sends them to the server. The chat server broadcasts each message "
"that it receives to all the clients."
msgstr ""
"În acest exercițiu, dorim să folosim noile noastre cunoștințe pentru a "
"implementa o aplicație de chat cu difuzare. Avem un server de chat la care "
"clienții se conectează și își publică mesajele. Clientul citește mesajele "
"utilizatorilor de la intrarea standard și le trimite la server. Serverul de "
"chat difuzează fiecare mesaj pe care îl primește către toți clienții."

#: src/concurrency/async-exercises/chat-app.md
#, fuzzy
msgid ""
"For this, we use [a broadcast channel](https://docs.rs/tokio/latest/tokio/"
"sync/broadcast/fn.channel.html) on the server, and [`tokio_websockets`]"
"(https://docs.rs/tokio-websockets/) for the communication between the client "
"and the server."
msgstr ""
"Pentru aceasta, folosim [un canal de difuzare](https://docs.rs/tokio/latest/"
"tokio/sync/broadcast/fn.channel.html) pe server și [`tokio_websockets`]"
"(https://docs.rs/tokio-websockets/0.4.0/tokio_websockets/) pentru "
"comunicarea dintre client și server."

#: src/concurrency/async-exercises/chat-app.md
#, fuzzy
msgid "Create a new Cargo project and add the following dependencies:"
msgstr "Creați un nou proiect Cargo și adăugați următoarele dependențe:"

#: src/concurrency/async-exercises/chat-app.md
msgid "_Cargo.toml_:"
msgstr "_Cargo.toml_:"

#: src/concurrency/async-exercises/chat-app.md
#, fuzzy
msgid ""
"```toml\n"
"[package]\n"
"name = \"chat-async\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"futures-util = { version = \"0.3.30\", features = [\"sink\"] }\n"
"http = \"1.1.0\"\n"
"tokio = { version = \"1.37.0\", features = [\"full\"] }\n"
"tokio-websockets = { version = \"0.8.2\", features = [\"client\", "
"\"fastrand\", \"server\", \"sha1_smol\"] }\n"
"```"
msgstr ""
"```toml\n"
"[pachet]\n"
"name = \"chat-async\"\n"
"versiune = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependențe]\n"
"futures-util = { version = \"0.3.28\", features = [\"sink\"]] }\n"
"http = \"0.2.9\"\n"
"tokio = { version = \"1.28.1\", features = [\"full\"]] }\n"
"tokio-websockets = { version = \"0.4.0\", features = [\"client\", "
"\"fastrand\", \"server\", \"sha1_smol\"] } }\n"
"```"

#: src/concurrency/async-exercises/chat-app.md
msgid "The required APIs"
msgstr "API-urile necesare"

#: src/concurrency/async-exercises/chat-app.md
#, fuzzy
msgid ""
"You are going to need the following functions from `tokio` and "
"[`tokio_websockets`](https://docs.rs/tokio-websockets/). Spend a few minutes "
"to familiarize yourself with the API."
msgstr ""
"Veți avea nevoie de următoarele funcții din `tokio` și [`tokio_websockets`]"
"(https://docs.rs/tokio-websockets/0.4.0/tokio_websockets/). Petreceți câteva "
"minute pentru a vă familiariza cu API-ul."

#: src/concurrency/async-exercises/chat-app.md
#, fuzzy
msgid ""
"[StreamExt::next()](https://docs.rs/futures-util/0.3.28/futures_util/stream/"
"trait.StreamExt.html#method.next) implemented by `WebSocketStream`: for "
"asynchronously reading messages from a Websocket Stream."
msgstr ""
"[StreamExt::next()](https://docs.rs/futures-util/0.3.28/futures_util/stream/"
"trait.StreamExt.html#method.next) implementat de `WebsocketStream`: pentru "
"citirea asincronă a mesajelor dintr-un flux Websocket."

#: src/concurrency/async-exercises/chat-app.md
#, fuzzy
msgid ""
"[SinkExt::send()](https://docs.rs/futures-util/0.3.28/futures_util/sink/"
"trait.SinkExt.html#method.send) implemented by `WebSocketStream`: for "
"asynchronously sending messages on a Websocket Stream."
msgstr ""
"[SinkExt::send()](https://docs.rs/futures-util/0.3.28/futures_util/sink/"
"trait.SinkExt.html#method.send) implementat de `WebsocketStream`: pentru "
"trimiterea asincronă de mesaje pe un flux Websocket."

#: src/concurrency/async-exercises/chat-app.md
#, fuzzy
msgid ""
"[Lines::next_line()](https://docs.rs/tokio/latest/tokio/io/struct.Lines."
"html#method.next_line): for asynchronously reading user messages from the "
"standard input."
msgstr ""
"[Lines::next_line()](https://docs.rs/tokio/latest/tokio/io/struct.Lines."
"html#method.next_line): pentru citirea asincronă a mesajelor utilizatorului "
"de la intrarea standard."

#: src/concurrency/async-exercises/chat-app.md
#, fuzzy
msgid ""
"[Sender::subscribe()](https://docs.rs/tokio/latest/tokio/sync/broadcast/"
"struct.Sender.html#method.subscribe): for subscribing to a broadcast channel."
msgstr ""
"[Sender::subscribe()](https://docs.rs/tokio/latest/tokio/sync/broadcast/"
"struct.Sender.html#method.subscribe): pentru abonarea la un canal de "
"difuzare."

#: src/concurrency/async-exercises/chat-app.md
msgid "Two binaries"
msgstr "Două binare"

#: src/concurrency/async-exercises/chat-app.md
msgid ""
"Normally in a Cargo project, you can have only one binary, and one `src/main."
"rs` file. In this project, we need two binaries. One for the client, and one "
"for the server. You could potentially make them two separate Cargo projects, "
"but we are going to put them in a single Cargo project with two binaries. "
"For this to work, the client and the server code should go under `src/bin` "
"(see the [documentation](https://doc.rust-lang.org/cargo/reference/cargo-"
"targets.html#binaries))."
msgstr ""
"În mod normal, într-un proiect Cargo, puteți avea un singur fișier binar și "
"un singur fișier `src/main.rs`. În acest proiect, avem nevoie de două "
"fișiere binare. Unul pentru client și unul pentru server. Ați putea eventual "
"să le faceți două proiecte Cargo separate, dar noi le vom pune într-un "
"singur proiect Cargo cu două binare. Pentru ca acest lucru să funcționeze, "
"codul clientului și cel al serverului trebuie să se regăsească în `src/bin` "
"(a se vedea [documentation](https://doc.rust-lang.org/cargo/reference/cargo-"
"targets.html#binaries))."

#: src/concurrency/async-exercises/chat-app.md
msgid ""
"Copy the following server and client code into `src/bin/server.rs` and `src/"
"bin/client.rs`, respectively. Your task is to complete these files as "
"described below."
msgstr ""
"Copiați următorul cod server și client în `src/bin/server.rs` și, respectiv, "
"`src/bin/client.rs`. Sarcina dumneavoastră este de a completa aceste fișiere "
"așa cum este descris mai jos."

#: src/concurrency/async-exercises/chat-app.md
#: src/concurrency/async-exercises/solutions.md
msgid "_src/bin/server.rs_:"
msgstr "_src/bin/server.rs_:"

#: src/concurrency/async-exercises/chat-app.md
msgid "// TODO: For a hint, see the description of the task below.\n"
msgstr ""
"// TODO: Pentru un indiciu, consultați descrierea sarcinii de mai jos.\n"

#: src/concurrency/async-exercises/chat-app.md
#: src/concurrency/async-exercises/solutions.md
msgid "\"127.0.0.1:2000\""
msgstr "\"127.0.0.1:2000\""

#: src/concurrency/async-exercises/chat-app.md
#: src/concurrency/async-exercises/solutions.md
msgid "\"listening on port 2000\""
msgstr "\"ascultând pe portul 2000\""

#: src/concurrency/async-exercises/chat-app.md
#: src/concurrency/async-exercises/solutions.md
msgid "\"New connection from {addr:?}\""
msgstr "\"Conexiune nouă de la {addr:?}\""

#: src/concurrency/async-exercises/chat-app.md
#: src/concurrency/async-exercises/solutions.md
msgid "// Wrap the raw TCP stream into a websocket.\n"
msgstr "// Împachetați fluxul TCP brut într-un websocket.\n"

#: src/concurrency/async-exercises/chat-app.md
#: src/concurrency/async-exercises/solutions.md
msgid "_src/bin/client.rs_:"
msgstr "_src/bin/client.rs_:"

#: src/concurrency/async-exercises/chat-app.md
#: src/concurrency/async-exercises/solutions.md
msgid "\"ws://127.0.0.1:2000\""
msgstr "\"ws://127.0.0.1:2000\""

#: src/concurrency/async-exercises/chat-app.md
msgid "Running the binaries"
msgstr "Rularea fișierelor binare"

#: src/concurrency/async-exercises/chat-app.md
msgid "Run the server with:"
msgstr "Rulați serverul cu:"

#: src/concurrency/async-exercises/chat-app.md
msgid "and the client with:"
msgstr "și clientul cu:"

#: src/concurrency/async-exercises/chat-app.md
msgid "Implement the `handle_connection` function in `src/bin/server.rs`."
msgstr "Implementați funcția `handle_connection` în `src/bin/server.rs`."

#: src/concurrency/async-exercises/chat-app.md
msgid ""
"Hint: Use `tokio::select!` for concurrently performing two tasks in a "
"continuous loop. One task receives messages from the client and broadcasts "
"them. The other sends messages received by the server to the client."
msgstr ""
"Indicație: Folosiți `tokio::select!` pentru a efectua concomitent două "
"sarcini într-o buclă continuă. O sarcină primește mesaje de la client și le "
"difuzează. Cealaltă trimite mesajele primite de server către client."

#: src/concurrency/async-exercises/chat-app.md
msgid "Complete the main function in `src/bin/client.rs`."
msgstr "Completați funcția principală din `src/bin/client.rs`."

#: src/concurrency/async-exercises/chat-app.md
msgid ""
"Hint: As before, use `tokio::select!` in a continuous loop for concurrently "
"performing two tasks: (1) reading user messages from standard input and "
"sending them to the server, and (2) receiving messages from the server, and "
"displaying them for the user."
msgstr ""
"Sugestie: Ca și înainte, utilizați `tokio::select!` într-o buclă continuă "
"pentru a efectua concomitent două sarcini: (1) citirea mesajelor "
"utilizatorului de la intrarea standard și trimiterea lor la server și (2) "
"primirea mesajelor de la server și afișarea lor pentru utilizator."

#: src/concurrency/async-exercises/chat-app.md
msgid ""
"Optional: Once you are done, change the code to broadcast messages to all "
"clients, but the sender of the message."
msgstr ""
"Opțional: După ce ați terminat, modificați codul pentru a difuza mesajele "
"către toți clienții, cu excepția expeditorului mesajului."

#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid ""
"// If we didn't get the left fork, drop the right fork if we\n"
"                // have it and let other tasks make progress.\n"
msgstr ""
"// Dacă nu am primit furculița din stânga, renunțăm la furculița din "
"dreapta, dacă avem\n"
"                // o avem și lăsăm celelalte sarcini să progreseze.\n"

#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid ""
"// If we didn't get the right fork, drop the left fork and let\n"
"                // other tasks make progress.\n"
msgstr ""
"// Dacă nu am primit furculița din dreapta, renunțăm la furculița din stânga "
"și lăsăm\n"
"                // alte sarcini să progreseze.\n"

#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "// The locks are dropped here\n"
msgstr "// Încuietorile sunt aruncate aici\n"

#: src/concurrency/async-exercises/solutions.md
msgid "// tx is dropped here, so we don't need to explicitly drop it later\n"
msgstr ""
"// tx este abandonat aici, așa că nu este nevoie să îl abandonăm explicit "
"mai târziu\n"

#: src/concurrency/async-exercises/solutions.md
msgid "\"Here is a thought: {thought}\""
msgstr "\"Iată un idee: {thought}\""

#: src/concurrency/async-exercises/solutions.md
msgid "\"Welcome to chat! Type a message\""
msgstr "\"Bine ați venit pe chat! Scrieți un mesaj\""

#: src/concurrency/async-exercises/solutions.md
msgid ""
"// A continuous loop for concurrently performing two tasks: (1) receiving\n"
"    // messages from `ws_stream` and broadcasting them, and (2) receiving\n"
"    // messages on `bcast_rx` and sending them to the client.\n"
msgstr ""
"// O buclă continuă care face două activități în același timp: (1) primește\n"
"    // mesaje de la 'ws_stream' și le transmite, și (2) primește\n"
"    // mesajele la apelul 'bcast_rx' și le trimite clientului.\n"

#: src/concurrency/async-exercises/solutions.md
msgid "\"From client {addr:?} {text:?}\""
msgstr "\"De la client {addr:?} {text:?}\""

#: src/concurrency/async-exercises/solutions.md
msgid "// Continuous loop for concurrently sending and receiving messages.\n"
msgstr "// Bucla continuă pentru trimiterea și primirea simultană de mesaje.\n"

#: src/concurrency/async-exercises/solutions.md
msgid "\"From server: {}\""
msgstr "\"De la server: {}\""

#: src/thanks.md
msgid ""
"_Thank you for taking Comprehensive Rust 🦀!_ We hope you enjoyed it and "
"that it was useful."
msgstr ""
"vă mulțumim că ați parcurs Comprehensive Rust 🦀!_ Sperăm că v-a plăcut și "
"că a fost util."

#: src/thanks.md
msgid ""
"We've had a lot of fun putting the course together. The course is not "
"perfect, so if you spotted any mistakes or have ideas for improvements, "
"please get in [contact with us on GitHub](https://github.com/google/"
"comprehensive-rust/discussions). We would love to hear from you."
msgstr ""
"Cursul nu este perfect, așa că, dacă ați observat greșeli sau aveți idei de "
"îmbunătățire, vă rugăm să ne [contactați pe GitHub](https://github.com/"
"google/comprehensive-rust/discussions)."

#: src/glossary.md
msgid ""
"The following is a glossary which aims to give a short definition of many "
"Rust terms. For translations, this also serves to connect the term back to "
"the English original."
msgstr ""
"Următorul glosar își propune să ofere o scurtă definiție a numeroși termeni "
"Rust. În cazul traducerilor, acesta servește, de asemenea, pentru a face "
"legătura între termenul respectiv și originalul în limba engleză."

#: src/glossary.md
msgid ""
"allocate:  \n"
"Dynamic memory allocation on [the heap](memory-management/stack-vs-heap.md)."
msgstr ""
"alocare:  \n"
"Alocarea dinamică a memoriei pe [heap](memory-management/stack-vs-heap.md)."

#: src/glossary.md
msgid ""
"argument:  \n"
"Information that is passed into a function or method."
msgstr ""
"argument:\n"
"Informații care sunt transmise într-o funcție sau metodă."

#: src/glossary.md
msgid ""
"Bare-metal Rust:  \n"
"Low-level Rust development, often deployed to a system without an operating "
"system. See [Bare-metal Rust](bare-metal.md)."
msgstr ""
"Bare-metal Rust:\n"
"Dezvoltare Rust de nivel scăzut, adesea implementată pe un sistem fără "
"sistem de operare. A se vedea [Bare-metal Rust](bare-metal.md)."

#: src/glossary.md
msgid ""
"block:  \n"
"See [Blocks](control-flow/blocks.md) and _scope_."
msgstr ""
"bloc:\n"
"A se vedea [Blocuri](control-flow/blocks.md) și _scope_."

#: src/glossary.md
msgid ""
"borrow:  \n"
"See [Borrowing](ownership/borrowing.md)."
msgstr ""
"împrumut (borrow):\n"
"A se vedea [Împrumut](ownership/borrowing.md)."

#: src/glossary.md
msgid ""
"borrow checker:  \n"
"The part of the Rust compiler which checks that all borrows are valid."
msgstr ""
"verificator de împrumuturi (borrow checker):\n"
"Partea din compilatorul Rust care verifică dacă toate împrumuturile de date "
"sunt valide."

#: src/glossary.md
msgid ""
"brace:  \n"
"`{` and `}`. Also called _curly brace_, they delimit _blocks_."
msgstr ""
"paranteze:\n"
"`{` și `}`. Numite și _acolade_, ele delimitează _blocuri_."

#: src/glossary.md
msgid ""
"build:  \n"
"The process of converting source code into executable code or a usable "
"program."
msgstr ""
"construire:  \n"
"Procesul de conversie a codului sursă în cod executabil sau într-un program "
"utilizabil."

#: src/glossary.md
msgid ""
"call:  \n"
"To invoke or execute a function or method."
msgstr ""
"apel (call):  \n"
"Invocarea sau execuția unei funcții sau metode."

#: src/glossary.md
msgid ""
"channel:  \n"
"Used to safely pass messages [between threads](concurrency/channels.md)."
msgstr ""
"canal (channel):  \n"
"Folosit pentru a transmite în siguranță mesaje [între fire de execuție] "
"(concurrency/channels.md)."

#: src/glossary.md
msgid ""
"Comprehensive Rust 🦀:  \n"
"The courses here are jointly called Comprehensive Rust 🦀."
msgstr ""
"Comprehensive Rust 🦀:\n"
"Cursurile de aici se numesc în comun Fundamentele Rust 🦀."

#: src/glossary.md
msgid ""
"concurrency:  \n"
"The execution of multiple tasks or processes at the same time."
msgstr ""
"concurența (concurrency):\n"
"Executarea mai multor sarcini sau procese în același timp."

#: src/glossary.md
msgid ""
"Concurrency in Rust:  \n"
"See [Concurrency in Rust](concurrency.md)."
msgstr ""
"Concurența în Rust:\n"
"A se vedea [Concurența în Rust](concurrency.md)."

#: src/glossary.md
msgid ""
"constant:  \n"
"A value that does not change during the execution of a program."
msgstr ""
"constantă:\n"
"O valoare care nu se modifică în timpul execuției unui program."

#: src/glossary.md
msgid ""
"control flow:  \n"
"The order in which the individual statements or instructions are executed in "
"a program."
msgstr ""
"fluxul de control:  \n"
"Ordinea în care sunt executate instrucțiunile sau declarațiile individuale "
"într-un program."

#: src/glossary.md
msgid ""
"crash:  \n"
"An unexpected and unhandled failure or termination of a program."
msgstr ""
"crash:\n"
"Un eșec neașteptat și netratat sau o terminare a unui program."

#: src/glossary.md
msgid ""
"enumeration:  \n"
"A data type that holds one of several named constants, possibly with an "
"associated tuple or struct."
msgstr ""
"enumerare (enumeration):\n"
"Un tip de date care conține una dintre mai multe constante numite, eventual "
"cu un tupluplu sau o structură asociată."

#: src/glossary.md
msgid ""
"error:  \n"
"An unexpected condition or result that deviates from the expected behavior."
msgstr ""
"eroare (error):\n"
"O condiție sau un rezultat neașteptat care se abate de la comportamentul "
"așteptat."

#: src/glossary.md
msgid ""
"error handling:  \n"
"The process of managing and responding to errors that occur during program "
"execution."
msgstr ""
"gestionarea erorilor:\n"
"Procesul de gestionare și de răspuns la erorile care apar în timpul "
"execuției programului."

#: src/glossary.md
msgid ""
"exercise:  \n"
"A task or problem designed to practice and test programming skills."
msgstr ""
"exercițiu:\n"
"O sarcină sau o problemă concepută pentru a exersa și testa abilitățile de "
"programare."

#: src/glossary.md
msgid ""
"function:  \n"
"A reusable block of code that performs a specific task."
msgstr ""
"funcție:\n"
"Un bloc de cod reutilizabil care îndeplinește o sarcină specifică."

#: src/glossary.md
msgid ""
"garbage collector:  \n"
"A mechanism that automatically frees up memory occupied by objects that are "
"no longer in use."
msgstr ""
"colector de gunoi (garbage collector):\n"
"Un mecanism care eliberează automat memoria ocupată de obiecte care nu mai "
"sunt utilizate."

#: src/glossary.md
msgid ""
"generics:  \n"
"A feature that allows writing code with placeholders for types, enabling "
"code reuse with different data types."
msgstr ""
"generice (generics):  \n"
"O caracteristică care permite scrierea de cod cu caractere de substituție "
"pentru tipuri, permițând reutilizarea codului cu diferite tipuri de date."

#: src/glossary.md
msgid ""
"immutable:  \n"
"Unable to be changed after creation."
msgstr ""
"imuabile (immutable):\n"
"Nu poate fi modificat după creare."

#: src/glossary.md
msgid ""
"integration test:  \n"
"A type of test that verifies the interactions between different parts or "
"components of a system."
msgstr ""
"testul de integrare:\n"
"Un tip de test care verifică interacțiunile dintre diferitele părți sau "
"componente ale unui sistem."

#: src/glossary.md
msgid ""
"keyword:  \n"
"A reserved word in a programming language that has a specific meaning and "
"cannot be used as an identifier."
msgstr ""
"cuvânt cheie:\n"
"Un cuvânt rezervat într-un limbaj de programare care are o semnificație "
"specifică și care nu poate fi folosit ca identificator."

#: src/glossary.md
msgid ""
"library:  \n"
"A collection of precompiled routines or code that can be used by programs."
msgstr ""
"bibliotecă:  \n"
"O colecție de rutine precompilate sau cod care poate fi utilizat de programe."

#: src/glossary.md
msgid ""
"macro:  \n"
"Rust macros can be recognized by a `!` in the name. Macros are used when "
"normal functions are not enough. A typical example is `format!`, which takes "
"a variable number of arguments, which isn't supported by Rust functions."
msgstr ""
"macro:  \n"
"Macro-urile Rust pot fi recunoscute prin introducerea unui `!` în nume. "
"Macrogramele sunt utilizate atunci când funcțiile normale nu sunt "
"suficiente. Un exemplu tipic este `format!`, care acceptă un număr variabil "
"de argumente, ceea ce nu este acceptat de funcțiile Rust."

#: src/glossary.md
msgid ""
"`main` function:  \n"
"Rust programs start executing with the `main` function."
msgstr ""
"funcția `main`:\n"
"Programele Rust încep să fie executate cu funcția `main`."

#: src/glossary.md
msgid ""
"match:  \n"
"A control flow construct in Rust that allows for pattern matching on the "
"value of an expression."
msgstr ""
"potrivire (match):\n"
"O construcție a fluxului de control din Rust care permite potrivirea de "
"tipare pe valoarea unei expresii."

#: src/glossary.md
msgid ""
"memory leak:  \n"
"A situation where a program fails to release memory that is no longer "
"needed, leading to a gradual increase in memory usage."
msgstr ""
"scurgere de memorie (memory leak):\n"
"O situație în care un program nu reușește să elibereze memoria care nu mai "
"este necesară, ceea ce duce la o creștere treptată a utilizării memoriei."

#: src/glossary.md
msgid ""
"method:  \n"
"A function associated with an object or a type in Rust."
msgstr ""
"metoda:\n"
"O funcție asociată cu un obiect sau un tip în Rust."

#: src/glossary.md
msgid ""
"module:  \n"
"A namespace that contains definitions, such as functions, types, or traits, "
"to organize code in Rust."
msgstr ""
"modul:  \n"
"Un spațiu de nume care conține definiții, cum ar fi funcții, tipuri sau "
"trăsături, pentru a organiza codul în Rust."

#: src/glossary.md
msgid ""
"move:  \n"
"The transfer of ownership of a value from one variable to another in Rust."
msgstr ""
"mutare (move):\n"
"Transferul proprietății unei valori de la o variabilă la alta în Rust."

#: src/glossary.md
msgid ""
"mutable:  \n"
"A property in Rust that allows variables to be modified after they have been "
"declared."
msgstr ""
"mutabil:\n"
"O proprietate din Rust care permite variabilelor să fie modificate după ce "
"au fost declarate."

#: src/glossary.md
msgid ""
"ownership:  \n"
"The concept in Rust that defines which part of the code is responsible for "
"managing the memory associated with a value."
msgstr ""
"posesia (ownership):\n"
"Conceptul din Rust care definește ce parte a codului este responsabilă "
"pentru gestionarea memoriei asociate cu o valoare."

#: src/glossary.md
msgid ""
"panic:  \n"
"An unrecoverable error condition in Rust that results in the termination of "
"the program."
msgstr ""
"panică:\n"
"O stare de eroare irecuperabilă în Rust care duce la terminarea programului."

#: src/glossary.md
msgid ""
"parameter:  \n"
"A value that is passed into a function or method when it is called."
msgstr ""
"parametru:\n"
"O valoare care este transmisă într-o funcție sau metodă atunci când este "
"apelată."

#: src/glossary.md
msgid ""
"pattern:  \n"
"A combination of values, literals, or structures that can be matched against "
"an expression in Rust."
msgstr ""
"șablon (pattern):\n"
"O combinație de valori, literali sau structuri care pot fi comparate cu o "
"expresie în Rust."

#: src/glossary.md
msgid ""
"payload:  \n"
"The data or information carried by a message, event, or data structure."
msgstr ""
"sarcina utilă:  \n"
"Datele sau informațiile transportate de un mesaj, eveniment sau structură de "
"date."

#: src/glossary.md
msgid ""
"program:  \n"
"A set of instructions that a computer can execute to perform a specific task "
"or solve a particular problem."
msgstr ""
"program:  \n"
"Un set de instrucțiuni pe care un computer le poate executa pentru a "
"îndeplini o anumită sarcină sau pentru a rezolva o anumită problemă."

#: src/glossary.md
msgid ""
"programming language:  \n"
"A formal system used to communicate instructions to a computer, such as Rust."
msgstr ""
"limbaj de programare:  \n"
"Un sistem formal utilizat pentru a comunica instrucțiuni unui calculator, "
"cum ar fi Rust."

#: src/glossary.md
msgid ""
"receiver:  \n"
"The first parameter in a Rust method that represents the instance on which "
"the method is called."
msgstr ""
"receptor:\n"
"Primul parametru dintr-o metodă Rust care reprezintă instanța asupra căreia "
"este apelată metoda."

#: src/glossary.md
msgid ""
"reference counting:  \n"
"A memory management technique in which the number of references to an object "
"is tracked, and the object is deallocated when the count reaches zero."
msgstr ""
"numărarea referințelor:\n"
"O tehnică de gestionare a memoriei în care se urmărește numărul de referințe "
"la un obiect, iar obiectul este dezalocat atunci când numărul ajunge la zero."

#: src/glossary.md
msgid ""
"return:  \n"
"A keyword in Rust used to indicate the value to be returned from a function."
msgstr ""
"return:\n"
"Un cuvânt cheie din Rust utilizat pentru a indica valoarea care trebuie "
"returnată de o funcție."

#: src/glossary.md
msgid ""
"Rust:  \n"
"A systems programming language that focuses on safety, performance, and "
"concurrency."
msgstr ""
"Rust:\n"
"Un limbaj de programare de sisteme care se concentrează pe siguranță, "
"performanță și concurență."

#: src/glossary.md
#, fuzzy
msgid ""
"Rust Fundamentals:  \n"
"Days 1 to 4 of this course."
msgstr ""
"Noțiuni fundamentale ale Rust:\n"
"Zilele 1 - 3 ale acestui curs."

#: src/glossary.md
msgid ""
"Rust in Android:  \n"
"See [Rust in Android](android.md)."
msgstr ""
"Rust în Android:\n"
"A se vedea [Rust in Android](android.md)."

#: src/glossary.md
msgid ""
"Rust in Chromium:  \n"
"See [Rust in Chromium](chromium.md)."
msgstr ""
"Rust în Android:\n"
"A se vedea [Rust in Android](android.md)."

#: src/glossary.md
msgid ""
"safe:  \n"
"Refers to code that adheres to Rust's ownership and borrowing rules, "
"preventing memory-related errors."
msgstr ""
"sigur (safe):  \n"
"Se referă la codul care respectă regulile de proprietate și împrumut ale "
"Rust, prevenind erorile legate de memorie."

#: src/glossary.md
msgid ""
"scope:  \n"
"The region of a program where a variable is valid and can be used."
msgstr ""
"domeniul de aplicare:  \n"
"Regiunea unui program în care o variabilă este valabilă și poate fi "
"utilizată."

#: src/glossary.md
msgid ""
"standard library:  \n"
"A collection of modules providing essential functionality in Rust."
msgstr ""
"biblioteca standard:  \n"
"O colecție de module care oferă funcționalități esențiale în Rust."

#: src/glossary.md
#, fuzzy
msgid ""
"static:  \n"
"A keyword in Rust used to define static variables or items with a `'static` "
"lifetime."
msgstr ""
"static:\n"
"Un cuvânt cheie din Rust folosit pentru a defini variabile statice sau "
"elemente cu o durată de viață `'static`'."

#: src/glossary.md
#, fuzzy
msgid ""
"string:  \n"
"A data type storing textual data. See [`String` vs `str`](basic-syntax/"
"string-slices.html) for more."
msgstr ""
"șir:\n"
"Un tip de date care stochează date textuale. Consultați [`String` vs `str`]"
"(basic-syntax/string-slices.html) pentru mai multe informații."

#: src/glossary.md
#, fuzzy
msgid ""
"struct:  \n"
"A composite data type in Rust that groups together variables of different "
"types under a single name."
msgstr ""
"struct:  \n"
"Un tip de date compozit în Rust care grupează variabile de diferite tipuri "
"sub un singur nume."

#: src/glossary.md
msgid ""
"test:  \n"
"A Rust module containing functions that test the correctness of other "
"functions."
msgstr ""
"test:\n"
"Un modul Rust care conține funcții care testează corectitudinea altor "
"funcții."

#: src/glossary.md
msgid ""
"thread:  \n"
"A separate sequence of execution in a program, allowing concurrent execution."
msgstr ""
"fir de execuție:\n"
"O secvență separată de execuție într-un program, permițând executarea "
"simultană."

#: src/glossary.md
msgid ""
"thread safety:  \n"
"The property of a program that ensures correct behavior in a multithreaded "
"environment."
msgstr ""
"siguranța firelor de execuție:\n"
"Proprietatea unui program care asigură un comportament corect într-un mediu "
"cu mai multe fire de execuție."

#: src/glossary.md
#, fuzzy
msgid ""
"trait:  \n"
"A collection of methods defined for an unknown type, providing a way to "
"achieve polymorphism in Rust."
msgstr ""
"trăsătură:\n"
"O colecție de metode definite pentru un tip necunoscut, oferind o modalitate "
"de a realiza polimorfismul în Rust."

#: src/glossary.md
msgid ""
"trait bound:  \n"
"An abstraction where you can require types to implement some traits of your "
"interest."
msgstr ""
"trăsături obligatorii:\n"
"O abstractizare prin care puteți cere tipurilor să implementeze anumite "
"trăsături de interes pentru dumneavoastră."

#: src/glossary.md
msgid ""
"tuple:  \n"
"A composite data type that contains variables of different types. Tuple "
"fields have no names, and are accessed by their ordinal numbers."
msgstr ""
"tuplu:  \n"
"Un tip de date compozit care conține variabile de diferite tipuri. Câmpurile "
"tuplu nu au nume și sunt accesate prin numerele lor ordinale."

#: src/glossary.md
msgid ""
"type:  \n"
"A classification that specifies which operations can be performed on values "
"of a particular kind in Rust."
msgstr ""
"tip:  \n"
"O clasificare care specifică ce operații pot fi efectuate asupra valorilor "
"datelor în Rust."

#: src/glossary.md
msgid ""
"type inference:  \n"
"The ability of the Rust compiler to deduce the type of a variable or "
"expression."
msgstr ""
"inferența de tip:  \n"
"Capacitatea compilatorului Rust de a deduce tipul unei variabile sau "
"expresii."

#: src/glossary.md
msgid ""
"undefined behavior:  \n"
"Actions or conditions in Rust that have no specified result, often leading "
"to unpredictable program behavior."
msgstr ""
"comportament nedefinit:\n"
"Acțiuni sau condiții din Rust care nu au un rezultat specificat, ceea ce "
"duce adesea la un comportament imprevizibil al programului."

#: src/glossary.md
msgid ""
"union:  \n"
"A data type that can hold values of different types but only one at a time."
msgstr ""
"uniune (union):\n"
"Un tip de date care poate conține valori de tipuri diferite, dar numai una "
"la un moment dat."

#: src/glossary.md
msgid ""
"unit test:  \n"
"Rust comes with built-in support for running small unit tests and larger "
"integration tests. See [Unit Tests](testing/unit-tests.html)."
msgstr ""
"test unitar:\n"
"Rust vine cu un suport încorporat pentru a rula teste unitare mici și teste "
"de integrare mai mari. Consultați [Teste unitare](testing/unit-tests.html)."

#: src/glossary.md
msgid ""
"unit type:  \n"
"Type that holds no data, written as a tuple with no members."
msgstr ""
"tipul unitate:  \n"
"Tip care nu conține date, scris ca un tuplu fără membri."

#: src/glossary.md
msgid ""
"unsafe:  \n"
"The subset of Rust which allows you to trigger _undefined behavior_. See "
"[Unsafe Rust](unsafe.html)."
msgstr ""
"nesigur:  \n"
"Un subansamblul Rust care vă permite să declanșați _comportamentul "
"nedefinit_. A se vedea [Rust nesigur](unsafe.html)."

#: src/glossary.md
msgid ""
"variable:  \n"
"A memory location storing data. Variables are valid in a _scope_."
msgstr ""
"variabilă:\n"
"O locație de memorie care stochează date. Variabilele sunt valabile într-un "
"_scop_."

#: src/other-resources.md
msgid "Other Rust Resources"
msgstr "Alte resurse privind Rust"

#: src/other-resources.md
msgid ""
"The Rust community has created a wealth of high-quality and free resources "
"online."
msgstr ""
"Comunitatea Rust a creat o multitudine de resurse online gratuite și de "
"înaltă calitate."

#: src/other-resources.md
msgid "Official Documentation"
msgstr "Documentație oficială"

#: src/other-resources.md
msgid "The Rust project hosts many resources. These cover Rust in general:"
msgstr ""
"Proiectul Rust găzduiește multe resurse. Acestea se referă la Rust în "
"general:"

#: src/other-resources.md
msgid ""
"[The Rust Programming Language](https://doc.rust-lang.org/book/): the "
"canonical free book about Rust. Covers the language in detail and includes a "
"few projects for people to build."
msgstr ""
"[The Rust Programming Language](https://doc.rust-lang.org/book/): cartea "
"canonică gratuită despre Rust. Acoperă limbajul în detaliu și include câteva "
"proiecte care pot fi construite."

#: src/other-resources.md
msgid ""
"[Rust By Example](https://doc.rust-lang.org/rust-by-example/): covers the "
"Rust syntax via a series of examples which showcase different constructs. "
"Sometimes includes small exercises where you are asked to expand on the code "
"in the examples."
msgstr ""
"[Rust By Example](https://doc.rust-lang.org/rust-by-example/): acoperă "
"sintaxa Rust prin intermediul unei serii de exemple care prezintă diferite "
"construcții. Uneori include mici exerciții în care vi se cere să dezvoltați "
"codul din exemple."

#: src/other-resources.md
msgid ""
"[Rust Standard Library](https://doc.rust-lang.org/std/): full documentation "
"of the standard library for Rust."
msgstr ""
"[Rust Standard Library](https://doc.rust-lang.org/std/): documentația "
"completă a bibliotecii standard pentru Rust."

#: src/other-resources.md
msgid ""
"[The Rust Reference](https://doc.rust-lang.org/reference/): an incomplete "
"book which describes the Rust grammar and memory model."
msgstr ""
"[The Rust Reference](https://doc.rust-lang.org/reference/): o carte "
"incompletă care descrie gramatica și modelul de memorie Rust."

#: src/other-resources.md
msgid "More specialized guides hosted on the official Rust site:"
msgstr "Ghiduri mai specializate găzduite pe site-ul oficial Rust:"

#: src/other-resources.md
msgid ""
"[The Rustonomicon](https://doc.rust-lang.org/nomicon/): covers unsafe Rust, "
"including working with raw pointers and interfacing with other languages "
"(FFI)."
msgstr ""
"[The Rustonomicon](https://doc.rust-lang.org/nomicon/): acoperă Rust "
"nesigur, inclusiv lucrul cu pointeri bruți și interfața cu alte limbaje "
"(FFI)."

#: src/other-resources.md
msgid ""
"[Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/): "
"covers the new asynchronous programming model which was introduced after the "
"Rust Book was written."
msgstr ""
"[Asynchronous Programming în Rust](https://rust-lang.github.io/async-book/): "
"acoperă noul model de programare asincronă care a fost introdus după ce a "
"fost scrisă cartea Rust."

#: src/other-resources.md
msgid ""
"[The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): "
"an introduction to using Rust on embedded devices without an operating "
"system."
msgstr ""
"[The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): o "
"introducere în utilizarea Rust pe dispozitive încorporate care nu au un "
"sistem de operare."

#: src/other-resources.md
msgid "Unofficial Learning Material"
msgstr "Material didactic neoficial"

#: src/other-resources.md
msgid "A small selection of other guides and tutorial for Rust:"
msgstr "O mică selecție de alte ghiduri și tutoriale pentru Rust:"

#: src/other-resources.md
msgid ""
"[Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): covers Rust "
"from the perspective of low-level C programmers."
msgstr ""
"[Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): acoperă "
"Rust din perspectiva programatorilor C de nivel inferior."

#: src/other-resources.md
msgid ""
"[Rust for Embedded C Programmers](https://docs.opentitan.org/doc/ug/"
"rust_for_c/): covers Rust from the perspective of developers who write "
"firmware in C."
msgstr ""
"[Rust for Embedded C Programmers](https://docs.opentitan.org/doc/ug/"
"rust_for_c/): acoperă Rust din perspectiva dezvoltatorilor care scriu "
"firmware în C."

#: src/other-resources.md
msgid ""
"[Rust for professionals](https://overexact.com/rust-for-professionals/): "
"covers the syntax of Rust using side-by-side comparisons with other "
"languages such as C, C++, Java, JavaScript, and Python."
msgstr ""
"[Rust pentru profesioniști](https://overexact.com/rust-for-professionals/): "
"acoperă sintaxa Rust folosind comparații cu alte limbaje precum C, C++, "
"Java, JavaScript și Python."

#: src/other-resources.md
msgid ""
"[Rust on Exercism](https://exercism.org/tracks/rust): 100+ exercises to help "
"you learn Rust."
msgstr ""
"[Rust on Exercism](https://exercism.org/tracks/rust): 100+ exerciții pentru "
"a vă ajuta să învățați Rust."

#: src/other-resources.md
msgid ""
"[Ferrous Teaching Material](https://ferrous-systems.github.io/teaching-"
"material/index.html): a series of small presentations covering both basic "
"and advanced part of the Rust language. Other topics such as WebAssembly, "
"and async/await are also covered."
msgstr ""
"[Ferrous Teaching Material](https://ferrous-systems.github.io/teaching-"
"material/index.html): o serie de mici prezentări care acoperă atât partea de "
"bază, cât și cea avansată a limbajului Rust. Sunt abordate și alte subiecte, "
"cum ar fi WebAssembly și async/await."

#: src/other-resources.md
#, fuzzy
msgid ""
"[Advanced testing for Rust applications](https://github.com/mainmatter/rust-"
"advanced-testing-workshop): a self-paced workshop that goes beyond Rust's "
"built-in testing framework. It covers `googletest`, snapshot testing, "
"mocking as well as how to write your own custom test harness."
msgstr ""
"[Testarea avansată a aplicațiilor Rust](https://github.com/mainmatter/rust-"
"advanced-testing-workshop): un atelier de lucru care merge mai departe de "
"cadrul de testare încorporat în Rust. Acesta acoperă `googletest`, testarea "
"instantanee, mocking, precum și cum să vă scrieți propriul harnașament de "
"testare personalizat."

#: src/other-resources.md
msgid ""
"[Beginner's Series to Rust](https://docs.microsoft.com/en-us/shows/beginners-"
"series-to-rust/) and [Take your first steps with Rust](https://docs."
"microsoft.com/en-us/learn/paths/rust-first-steps/): two Rust guides aimed at "
"new developers. The first is a set of 35 videos and the second is a set of "
"11 modules which covers Rust syntax and basic constructs."
msgstr ""
"[Beginner's Series to Rust] (https://docs.microsoft.com/en-us/shows/"
"beginners-series-to-rust/) și [Take your first steps with Rust] (https://"
"docs.microsoft.com/en-us/learn/paths/rust-first-steps/): două ghiduri Rust "
"destinate noilor dezvoltatori. Primul este un set de 35 de videoclipuri, iar "
"al doilea este un set de 11 module care acoperă sintaxa Rust și "
"construcțiile de bază."

#: src/other-resources.md
msgid ""
"[Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial."
"github.io/too-many-lists/): in-depth exploration of Rust's memory management "
"rules, through implementing a few different types of list structures."
msgstr ""
"[Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial."
"github.io/too-many-lists/): explorarea în profunzime a regulilor de "
"gestionare a memoriei din Rust, prin implementarea câtorva tipuri diferite "
"de structuri de liste."

#: src/other-resources.md
msgid ""
"Please see the [Little Book of Rust Books](https://lborb.github.io/book/) "
"for even more Rust books."
msgstr ""
"Vă rugăm să consultați [Little Book of Rust Books](https://lborb.github.io/"
"book/) pentru și mai multe cărți Rust."

#: src/credits.md
msgid ""
"The material here builds on top of the many great sources of Rust "
"documentation. See the page on [other resources](other-resources.md) for a "
"full list of useful resources."
msgstr ""
"Materialul de aici se bazează pe numeroasele surse excelente din "
"documentația Rust. Consultați pagina privind [alte resurse](other-resources."
"md) pentru o listă completă de resurse utile."

#: src/credits.md
msgid ""
"The material of Comprehensive Rust is licensed under the terms of the Apache "
"2.0 license, please see [`LICENSE`](https://github.com/google/comprehensive-"
"rust/blob/main/LICENSE) for details."
msgstr ""
"Materialul din `Comprehensive Rust` este licențiat în conformitate cu "
"termenii licenței Apache 2.0, vă rugăm să consultați [`LICENSE`](https://"
"github.com/google/comprehensive-rust/blob/main/LICENSE) pentru detalii."

#: src/credits.md
msgid "Rust by Example"
msgstr "Rust în exemple"

#: src/credits.md
msgid ""
"Some examples and exercises have been copied and adapted from [Rust by "
"Example](https://doc.rust-lang.org/rust-by-example/). Please see the "
"`third_party/rust-by-example/` directory for details, including the license "
"terms."
msgstr ""
"Unele exemple și exerciții au fost copiate și adaptate din [Rust by Example]"
"(https://doc.rust-lang.org/rust-by-example/). Vă rugăm să consultați "
"directorul `third_party/rust-by-example/` pentru detalii, inclusiv termenii "
"licenței."

#: src/credits.md
#, fuzzy
msgid "Rust on Exercism"
msgstr ""
"[Rust on Exercism](https://exercism.org/tracks/rust): 100+ exerciții pentru "
"a vă ajuta să învățați Rust."

#: src/credits.md
msgid ""
"Some exercises have been copied and adapted from [Rust on Exercism](https://"
"exercism.org/tracks/rust). Please see the `third_party/rust-on-exercism/` "
"directory for details, including the license terms."
msgstr ""
"Unele exerciții au fost copiate și adaptate din [Rust on Exercism](https://"
"exercism.org/tracks/rust). Vă rugăm să consultați directorul `third_party/"
"rust-on-exercism/` pentru detalii, inclusiv termenii licenței."

#: src/credits.md
msgid "CXX"
msgstr "CXX"

#: src/credits.md
msgid ""
"The [Interoperability with C++](android/interoperability/cpp.md) section "
"uses an image from [CXX](https://cxx.rs/). Please see the `third_party/cxx/` "
"directory for details, including the license terms."
msgstr ""
"Secțiunea [Interoperabilitate cu C++](android/interoperabilitate/cpp.md) "
"utilizează o imagine din [CXX](https://cxx.rs/). Vă rugăm să consultați "
"directorul `third_party/cxx/` pentru detalii, inclusiv termenii licenței."
