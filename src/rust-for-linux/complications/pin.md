---
minutes: 15
---

# `Pin` and Self-Reference

The Linux kernel pervasively relies on intrusive data structures and programming
patterns that rely on the stability of objects' addresses.

In C, these patterns show up in places like `struct list_head` and the
`container_of` macro.

The programming rules for these data structures require being careful about
where instances are allocated and how they are linked into and removed from
containing data structures.

## Moves

In Rust, however, instances of data types may change their addresses any time
they are moved, and the compiler is relied on to be aware of any outstanding
references that would prevent moving them. The most common pattern for
constructing values in Rust even involves a move-- simply returning the value
from a constructor function.

This paradigm does not work for values that must be constructed "in-place" to
avoid moves, but the C approach of writing into a blob of uninitialized memory
until fully initialized is also an anathema in Rust: it would force us into
writing unsafe code any place we wanted to construct an instance of our type.

## `Pin`

A similar concern already exists in Rust for compiler-generated types that
internally contain self references; these can be occur in the state machines
generated by the compiler for `async` functions.

The `Pin<T>` wrapper type exists to wrap an indirection (such as `&mut T` or
`Box<T>`) in such a way that an `&mut T` cannot be created to the underlying `T`
(as this would allow using a function like `mem::swap` that would effectively
change its address).

## Field projection

`Pin<T>` also has the effect of requiring a choice for each field of the pinned
type: will it be accessed through a `Pin<&mut Field>` or simply through
`&mut Field`? Either may be acceptable, depending on the semantics of the type,
but the two options must not coexist for a single field as that would allow the
`Pin<&mut Field>` to be moved via `mem::swap` on the `&mut Field`.

The boilerplate for exposing access to each field of a pinned struct
("projecting" the field) via only one of `Pin<_>` or directly is handled by the
`pin-project` crate in userspace Rust.

Unfortunately, this crate uses procedural macros to parse Rust code and these in
turn have heavy dependencies that the Rust for Linux project does not want to
take on.

Instead, Rust for Linux has its own solution to pinned initialization and pin
projection.

## `pinned-init`

The solution employed for these concerns in Rust for Linux is the `pinned-init`
crate. Using this crate looks like the following:

```rust
use kernel::{prelude::*, sync::Mutex, new_mutex};
#[pin_data]
struct Foo {
    #[pin]
    a: Mutex<usize>,
    b: u32,
}

let foo = pin_init!(Foo {
    a <- new_mutex!(42, "Foo::a"),
    b: 24,
});

// `foo` now is of the type `impl PinInit<Foo>`.
// We can now use any smart pointer that we like (or just the stack) to actually initialize a Foo:

let foo: Result<Pin<Box<Foo>>> = Box::pin_init(foo);
```

### Further reading

- <https://rust-for-linux.com/the-safe-pinned-initialization-problem>
- <https://github.com/Rust-for-Linux/pinned-init>
