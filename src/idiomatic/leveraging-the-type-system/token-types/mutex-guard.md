---
minutes: 5
---

# Mutex Guards â€“ Token Types with Data

A token type might only be useful when there's other data, a mutex guard is an
example of permission + data.

```rust,editable
use std::sync::{Arc, Mutex, MutexGuard};

fn main() {
    let mutex = Arc::new(Mutex::new(42));
    let try_mutex_guard: Result<MutexGuard<'_, _>, _> = mutex.lock();
    if let Ok(mut guarded) = try_mutex_guard {
        // We've proven we have exclusive access to the data through the successful
        // construction of
        *guarded = 451;
    }
}
```

<details>

<!-- TODO: Reference the Mutex section of the RAII chapter once that is merged.
Remind the students that the RAII section specifically covered automatic mutex unlocking and did not talk about access to the data.
-->

- Mutexes need to enforce mutual exclusion of read/write access to a value.
  We've covered Mutexes earlier in this course already (See: RAII/Mutex), but
  here we're looking at `MutexGuard` specifically.

- `MutexGuard` is a value generated by a `Mutex` that "proves" you have
  read/write access at that point in time, as well as holding onto a reference
  to the data it wraps for reading and writing of that value.

  If a `MutexGuard` isn't returned by `mutex.lock()`, you don't have permission
  to change the value within the mutex.

</details>
